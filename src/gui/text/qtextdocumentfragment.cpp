begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextdocumentfragment.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocumentfragment_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextcursor_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextlist.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QTextCopyHelper
name|QTextCopyHelper
operator|::
name|QTextCopyHelper
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|_source
parameter_list|,
specifier|const
name|QTextCursor
modifier|&
name|_destination
parameter_list|,
name|bool
name|forceCharFormat
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|fmt
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
comment|// compiler bug
member_init_list|:
name|formatCollection
argument_list|(
operator|*
name|_destination
operator|.
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
argument_list|)
member_init_list|,
name|originalText
argument_list|(
operator|(
specifier|const
name|QString
operator|)
name|_source
operator|.
name|d
operator|->
name|priv
operator|->
name|buffer
argument_list|()
argument_list|)
else|#
directive|else
member_init_list|:
name|formatCollection
argument_list|(
operator|*
name|_destination
operator|.
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
argument_list|)
member_init_list|,
name|originalText
argument_list|(
name|_source
operator|.
name|d
operator|->
name|priv
operator|->
name|buffer
argument_list|()
argument_list|)
endif|#
directive|endif
block|{
name|src
operator|=
name|_source
operator|.
name|d
operator|->
name|priv
expr_stmt|;
name|dst
operator|=
name|_destination
operator|.
name|d
operator|->
name|priv
expr_stmt|;
name|insertPos
operator|=
name|_destination
operator|.
name|position
argument_list|()
expr_stmt|;
name|this
operator|->
name|forceCharFormat
operator|=
name|forceCharFormat
expr_stmt|;
name|primaryCharFormatIndex
operator|=
name|convertFormatIndex
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|_source
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|convertFormatIndex
name|int
name|QTextCopyHelper
operator|::
name|convertFormatIndex
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|oldFormat
parameter_list|,
name|int
name|objectIndexToSet
parameter_list|)
block|{
name|QTextFormat
name|fmt
init|=
name|oldFormat
decl_stmt|;
if|if
condition|(
name|objectIndexToSet
operator|!=
operator|-
literal|1
condition|)
block|{
name|fmt
operator|.
name|setObjectIndex
argument_list|(
name|objectIndexToSet
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|.
name|objectIndex
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|newObjectIndex
init|=
name|objectIndexMap
operator|.
name|value
argument_list|(
name|fmt
operator|.
name|objectIndex
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|newObjectIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|QTextFormat
name|objFormat
init|=
name|src
operator|->
name|formatCollection
argument_list|()
operator|->
name|objectFormat
argument_list|(
name|fmt
operator|.
name|objectIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|objFormat
operator|.
name|objectIndex
argument_list|()
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newObjectIndex
operator|=
name|formatCollection
operator|.
name|createObjectIndex
argument_list|(
name|objFormat
argument_list|)
expr_stmt|;
name|objectIndexMap
operator|.
name|insert
argument_list|(
name|fmt
operator|.
name|objectIndex
argument_list|()
argument_list|,
name|newObjectIndex
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|.
name|setObjectIndex
argument_list|(
name|newObjectIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|idx
init|=
name|formatCollection
operator|.
name|indexForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|formatCollection
operator|.
name|format
argument_list|(
name|idx
argument_list|)
operator|.
name|type
argument_list|()
operator|==
name|oldFormat
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function
begin_function
DECL|function|appendFragment
name|int
name|QTextCopyHelper
operator|::
name|appendFragment
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|endPos
parameter_list|,
name|int
name|objectIndex
parameter_list|)
block|{
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|fragIt
init|=
name|src
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|fragIt
operator|.
name|value
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|objectIndex
operator|==
operator|-
literal|1
operator|||
operator|(
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|src
operator|->
name|formatCollection
argument_list|()
operator|->
name|format
argument_list|(
name|frag
operator|->
name|format
argument_list|)
operator|.
name|objectIndex
argument_list|()
operator|!=
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|int
name|charFormatIndex
decl_stmt|;
if|if
condition|(
name|forceCharFormat
condition|)
name|charFormatIndex
operator|=
name|primaryCharFormatIndex
expr_stmt|;
else|else
name|charFormatIndex
operator|=
name|convertFormatIndex
argument_list|(
name|frag
operator|->
name|format
argument_list|,
name|objectIndex
argument_list|)
expr_stmt|;
specifier|const
name|int
name|inFragmentOffset
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
name|fragIt
operator|.
name|position
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|charsToCopy
init|=
name|qMin
argument_list|(
name|int
argument_list|(
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
operator|-
name|inFragmentOffset
argument_list|)
argument_list|,
name|endPos
operator|-
name|pos
argument_list|)
decl_stmt|;
name|QTextBlock
name|nextBlock
init|=
name|src
operator|->
name|blocksFind
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|blockIdx
init|=
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|nextBlock
operator|.
name|position
argument_list|()
operator|==
name|pos
operator|+
literal|1
condition|)
block|{
name|blockIdx
operator|=
name|convertFormatIndex
argument_list|(
name|nextBlock
operator|.
name|blockFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|==
literal|0
operator|&&
name|insertPos
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|setBlockFormat
argument_list|(
name|dst
operator|->
name|blocksBegin
argument_list|()
argument_list|,
name|dst
operator|->
name|blocksBegin
argument_list|()
argument_list|,
name|convertFormat
argument_list|(
name|src
operator|->
name|blocksBegin
argument_list|()
operator|.
name|blockFormat
argument_list|()
argument_list|)
operator|.
name|toBlockFormat
argument_list|()
argument_list|)
expr_stmt|;
name|dst
operator|->
name|setCharFormat
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|convertFormat
argument_list|(
name|src
operator|->
name|blocksBegin
argument_list|()
operator|.
name|charFormat
argument_list|()
argument_list|)
operator|.
name|toCharFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|txtToInsert
argument_list|(
name|originalText
operator|.
name|constData
argument_list|()
operator|+
name|frag
operator|->
name|stringPosition
operator|+
name|inFragmentOffset
argument_list|,
name|charsToCopy
argument_list|)
decl_stmt|;
if|if
condition|(
name|txtToInsert
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
operator|(
name|txtToInsert
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QChar
operator|::
name|ParagraphSeparator
operator|||
name|txtToInsert
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QTextBeginningOfFrame
operator|||
name|txtToInsert
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QTextEndOfFrame
operator|)
condition|)
block|{
name|dst
operator|->
name|insertBlock
argument_list|(
name|txtToInsert
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|insertPos
argument_list|,
name|blockIdx
argument_list|,
name|charFormatIndex
argument_list|)
expr_stmt|;
operator|++
name|insertPos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nextBlock
operator|.
name|textList
argument_list|()
condition|)
block|{
name|QTextBlock
name|dstBlock
init|=
name|dst
operator|->
name|blocksFind
argument_list|(
name|insertPos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dstBlock
operator|.
name|textList
argument_list|()
condition|)
block|{
comment|// insert a new text block with the block and char format from the
comment|// source block to make sure that the following text fragments
comment|// end up in a list as they should
name|int
name|listBlockFormatIndex
init|=
name|convertFormatIndex
argument_list|(
name|nextBlock
operator|.
name|blockFormat
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|listCharFormatIndex
init|=
name|convertFormatIndex
argument_list|(
name|nextBlock
operator|.
name|charFormat
argument_list|()
argument_list|)
decl_stmt|;
name|dst
operator|->
name|insertBlock
argument_list|(
name|insertPos
argument_list|,
name|listBlockFormatIndex
argument_list|,
name|listCharFormatIndex
argument_list|)
expr_stmt|;
operator|++
name|insertPos
expr_stmt|;
block|}
block|}
name|dst
operator|->
name|insert
argument_list|(
name|insertPos
argument_list|,
name|txtToInsert
argument_list|,
name|charFormatIndex
argument_list|)
expr_stmt|;
specifier|const
name|int
name|userState
init|=
name|nextBlock
operator|.
name|userState
argument_list|()
decl_stmt|;
if|if
condition|(
name|userState
operator|!=
operator|-
literal|1
condition|)
name|dst
operator|->
name|blocksFind
argument_list|(
name|insertPos
argument_list|)
operator|.
name|setUserState
argument_list|(
name|userState
argument_list|)
expr_stmt|;
name|insertPos
operator|+=
name|txtToInsert
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|charsToCopy
return|;
block|}
end_function
begin_function
DECL|function|appendFragments
name|void
name|QTextCopyHelper
operator|::
name|appendFragments
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|endPos
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pos
operator|<
name|endPos
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|endPos
condition|)
name|pos
operator|+=
name|appendFragment
argument_list|(
name|pos
argument_list|,
name|endPos
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copy
name|void
name|QTextCopyHelper
operator|::
name|copy
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|.
name|hasComplexSelection
argument_list|()
condition|)
block|{
name|QTextTable
modifier|*
name|table
init|=
name|cursor
operator|.
name|currentTable
argument_list|()
decl_stmt|;
name|int
name|row_start
decl_stmt|,
name|col_start
decl_stmt|,
name|num_rows
decl_stmt|,
name|num_cols
decl_stmt|;
name|cursor
operator|.
name|selectedTableCells
argument_list|(
operator|&
name|row_start
argument_list|,
operator|&
name|num_rows
argument_list|,
operator|&
name|col_start
argument_list|,
operator|&
name|num_cols
argument_list|)
expr_stmt|;
name|QTextTableFormat
name|tableFormat
init|=
name|table
operator|->
name|format
argument_list|()
decl_stmt|;
name|tableFormat
operator|.
name|setColumns
argument_list|(
name|num_cols
argument_list|)
expr_stmt|;
name|tableFormat
operator|.
name|clearColumnWidthConstraints
argument_list|()
expr_stmt|;
specifier|const
name|int
name|objectIndex
init|=
name|dst
operator|->
name|formatCollection
argument_list|()
operator|->
name|createObjectIndex
argument_list|(
name|tableFormat
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|row_start
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row_start
init|;
name|r
operator|<
name|row_start
operator|+
name|num_rows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|col_start
init|;
name|c
operator|<
name|col_start
operator|+
name|num_cols
condition|;
operator|++
name|c
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
specifier|const
name|int
name|rspan
init|=
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
specifier|const
name|int
name|cspan
init|=
name|cell
operator|.
name|columnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|rspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cr
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|cr
operator|!=
name|r
condition|)
continue|continue;
block|}
if|if
condition|(
name|cspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
name|c
condition|)
continue|continue;
block|}
comment|// add the QTextBeginningOfFrame
name|QTextCharFormat
name|cellFormat
init|=
name|cell
operator|.
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|+
name|rspan
operator|>=
name|row_start
operator|+
name|num_rows
condition|)
block|{
name|cellFormat
operator|.
name|setTableCellRowSpan
argument_list|(
name|row_start
operator|+
name|num_rows
operator|-
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|+
name|cspan
operator|>=
name|col_start
operator|+
name|num_cols
condition|)
block|{
name|cellFormat
operator|.
name|setTableCellColumnSpan
argument_list|(
name|col_start
operator|+
name|num_cols
operator|-
name|c
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|charFormatIndex
init|=
name|convertFormatIndex
argument_list|(
name|cellFormat
argument_list|,
name|objectIndex
argument_list|)
decl_stmt|;
name|int
name|blockIdx
init|=
operator|-
literal|2
decl_stmt|;
specifier|const
name|int
name|cellPos
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
name|QTextBlock
name|block
init|=
name|src
operator|->
name|blocksFind
argument_list|(
name|cellPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|position
argument_list|()
operator|==
name|cellPos
condition|)
block|{
name|blockIdx
operator|=
name|convertFormatIndex
argument_list|(
name|block
operator|.
name|blockFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dst
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|insertPos
argument_list|,
name|blockIdx
argument_list|,
name|charFormatIndex
argument_list|)
expr_stmt|;
operator|++
name|insertPos
expr_stmt|;
comment|// nothing to add for empty cells
if|if
condition|(
name|cell
operator|.
name|lastPosition
argument_list|()
operator|>
name|cellPos
condition|)
block|{
comment|// add the contents
name|appendFragments
argument_list|(
name|cellPos
argument_list|,
name|cell
operator|.
name|lastPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// add end of table
name|int
name|end
init|=
name|table
operator|->
name|lastPosition
argument_list|()
decl_stmt|;
name|appendFragment
argument_list|(
name|end
argument_list|,
name|end
operator|+
literal|1
argument_list|,
name|objectIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendFragments
argument_list|(
name|cursor
operator|.
name|selectionStart
argument_list|()
argument_list|,
name|cursor
operator|.
name|selectionEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QTextDocumentFragmentPrivate
name|QTextDocumentFragmentPrivate
operator|::
name|QTextDocumentFragmentPrivate
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|_cursor
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|doc
argument_list|(
operator|new
name|QTextDocument
argument_list|)
member_init_list|,
name|importedFromPlainText
argument_list|(
literal|false
argument_list|)
block|{
name|doc
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_cursor
operator|.
name|hasSelection
argument_list|()
condition|)
return|return;
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|QTextCursor
name|destCursor
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|QTextCopyHelper
argument_list|(
name|_cursor
argument_list|,
name|destCursor
argument_list|)
operator|.
name|copy
argument_list|()
expr_stmt|;
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|_cursor
operator|.
name|d
condition|)
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|mergeCachedResources
argument_list|(
name|_cursor
operator|.
name|d
operator|->
name|priv
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|insert
name|void
name|QTextDocumentFragmentPrivate
operator|::
name|insert
parameter_list|(
name|QTextCursor
modifier|&
name|_cursor
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|_cursor
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QTextDocumentPrivate
modifier|*
name|destPieceTable
init|=
name|_cursor
operator|.
name|d
operator|->
name|priv
decl_stmt|;
name|destPieceTable
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|QTextCursor
name|sourceCursor
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|sourceCursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|End
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|QTextCopyHelper
argument_list|(
name|sourceCursor
argument_list|,
name|_cursor
argument_list|,
name|importedFromPlainText
argument_list|,
name|_cursor
operator|.
name|charFormat
argument_list|()
argument_list|)
operator|.
name|copy
argument_list|()
expr_stmt|;
name|destPieceTable
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTextDocumentFragment     \reentrant      \inmodule QtGui     \brief The QTextDocumentFragment class represents a piece of formatted text     from a QTextDocument.      \ingroup richtext-processing     \ingroup shared      A QTextDocumentFragment is a fragment of rich text, that can be inserted into     a QTextDocument. A document fragment can be created from a     QTextDocument, from a QTextCursor's selection, or from another     document fragment. Document fragments can also be created by the     static functions, fromPlainText() and fromHtml().      The contents of a document fragment can be obtained as plain text     by using the toPlainText() function, or it can be obtained as HTML     with toHtml(). */
end_comment
begin_comment
comment|/*!     Constructs an empty QTextDocumentFragment.      \sa isEmpty() */
end_comment
begin_constructor
DECL|function|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|QTextDocumentFragment
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Converts the given \a document into a QTextDocumentFragment.     Note that the QTextDocumentFragment only stores the document contents, not meta information     like the document's title. */
end_comment
begin_constructor
DECL|function|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|QTextDocumentFragment
parameter_list|(
specifier|const
name|QTextDocument
modifier|*
name|document
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
operator|!
name|document
condition|)
return|return;
name|QTextCursor
name|cursor
argument_list|(
cast|const_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|document
argument_list|)
argument_list|)
decl_stmt|;
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|End
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|QTextDocumentFragmentPrivate
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a QTextDocumentFragment from the \a{cursor}'s selection.     If the cursor doesn't have a selection, the created fragment is empty.      \sa isEmpty(), QTextCursor::selection() */
end_comment
begin_constructor
DECL|function|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|QTextDocumentFragment
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
operator|!
name|cursor
operator|.
name|hasSelection
argument_list|()
condition|)
return|return;
name|d
operator|=
operator|new
name|QTextDocumentFragmentPrivate
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QTextDocumentFragment::QTextDocumentFragment(const QTextDocumentFragment&other)      Copy constructor. Creates a copy of the \a other fragment. */
end_comment
begin_constructor
DECL|function|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|QTextDocumentFragment
parameter_list|(
specifier|const
name|QTextDocumentFragment
modifier|&
name|rhs
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|rhs
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QTextDocumentFragment&QTextDocumentFragment::operator=(const QTextDocumentFragment&other)      Assigns the \a other fragment to this fragment. */
end_comment
begin_function
DECL|function|operator =
name|QTextDocumentFragment
modifier|&
name|QTextDocumentFragment
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QTextDocumentFragment
modifier|&
name|rhs
parameter_list|)
block|{
if|if
condition|(
name|rhs
operator|.
name|d
condition|)
name|rhs
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|rhs
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the document fragment. */
end_comment
begin_destructor
DECL|function|~QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|~
name|QTextDocumentFragment
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns true if the fragment is empty; otherwise returns false. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QTextDocumentFragment
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|doc
operator|||
name|d
operator|->
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|length
argument_list|()
operator|<=
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document fragment's text as plain text (i.e. with no     formatting information).      \sa toHtml() */
end_comment
begin_function
DECL|function|toPlainText
name|QString
name|QTextDocumentFragment
operator|::
name|toPlainText
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|doc
operator|->
name|toPlainText
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_comment
comment|/*!     \since 4.2      Returns the contents of the document fragment as HTML,     using the specified \a encoding (e.g., "UTF-8", "ISO 8859-1").      \sa toPlainText(), QTextDocument::toHtml(), QTextCodec */
end_comment
begin_function
DECL|function|toHtml
name|QString
name|QTextDocumentFragment
operator|::
name|toHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|encoding
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QTextHtmlExporter
argument_list|(
name|d
operator|->
name|doc
argument_list|)
operator|.
name|toHtml
argument_list|(
name|encoding
argument_list|,
name|QTextHtmlExporter
operator|::
name|ExportFragment
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     Returns a document fragment that contains the given \a plainText.      When inserting such a fragment into a QTextDocument the current char format of     the QTextCursor used for insertion is used as format for the text. */
end_comment
begin_function
DECL|function|fromPlainText
name|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|fromPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|plainText
parameter_list|)
block|{
name|QTextDocumentFragment
name|res
decl_stmt|;
name|res
operator|.
name|d
operator|=
operator|new
name|QTextDocumentFragmentPrivate
expr_stmt|;
name|res
operator|.
name|d
operator|->
name|importedFromPlainText
operator|=
literal|true
expr_stmt|;
name|QTextCursor
name|cursor
argument_list|(
name|res
operator|.
name|d
operator|->
name|doc
argument_list|)
decl_stmt|;
name|cursor
operator|.
name|insertText
argument_list|(
name|plainText
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|nextListStyle
specifier|static
name|QTextListFormat
operator|::
name|Style
name|nextListStyle
parameter_list|(
name|QTextListFormat
operator|::
name|Style
name|style
parameter_list|)
block|{
if|if
condition|(
name|style
operator|==
name|QTextListFormat
operator|::
name|ListDisc
condition|)
return|return
name|QTextListFormat
operator|::
name|ListCircle
return|;
elseif|else
if|if
condition|(
name|style
operator|==
name|QTextListFormat
operator|::
name|ListCircle
condition|)
return|return
name|QTextListFormat
operator|::
name|ListSquare
return|;
return|return
name|style
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_constructor
DECL|function|QTextHtmlImporter
name|QTextHtmlImporter
operator|::
name|QTextHtmlImporter
parameter_list|(
name|QTextDocument
modifier|*
name|_doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|_html
parameter_list|,
name|ImportMode
name|mode
parameter_list|,
specifier|const
name|QTextDocument
modifier|*
name|resourceProvider
parameter_list|)
member_init_list|:
name|indent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|compressNextWhitespace
argument_list|(
name|PreserveWhiteSpace
argument_list|)
member_init_list|,
name|doc
argument_list|(
name|_doc
argument_list|)
member_init_list|,
name|importMode
argument_list|(
name|mode
argument_list|)
block|{
name|cursor
operator|=
name|QTextCursor
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|wsm
operator|=
name|QTextHtmlParserNode
operator|::
name|WhiteSpaceNormal
expr_stmt|;
name|QString
name|html
init|=
name|_html
decl_stmt|;
specifier|const
name|int
name|startFragmentPos
init|=
name|html
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"<!--StartFragment-->"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|startFragmentPos
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|qt3RichTextHeader
argument_list|(
name|QLatin1String
argument_list|(
literal|"<meta name=\"qrichtext\" content=\"1\" />"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Hack for Qt3
specifier|const
name|bool
name|hasQtRichtextMetaTag
init|=
name|html
operator|.
name|contains
argument_list|(
name|qt3RichTextHeader
argument_list|)
decl_stmt|;
specifier|const
name|int
name|endFragmentPos
init|=
name|html
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"<!--EndFragment-->"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|startFragmentPos
operator|<
name|endFragmentPos
condition|)
name|html
operator|=
name|html
operator|.
name|mid
argument_list|(
name|startFragmentPos
argument_list|,
name|endFragmentPos
operator|-
name|startFragmentPos
argument_list|)
expr_stmt|;
else|else
name|html
operator|=
name|html
operator|.
name|mid
argument_list|(
name|startFragmentPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasQtRichtextMetaTag
condition|)
name|html
operator|.
name|prepend
argument_list|(
name|qt3RichTextHeader
argument_list|)
expr_stmt|;
block|}
name|parse
argument_list|(
name|html
argument_list|,
name|resourceProvider
condition|?
name|resourceProvider
else|:
name|doc
argument_list|)
expr_stmt|;
comment|//    dumpHtml();
block|}
end_constructor
begin_function
DECL|function|import
name|void
name|QTextHtmlImporter
operator|::
name|import
parameter_list|()
block|{
name|cursor
operator|.
name|beginEditBlock
argument_list|()
expr_stmt|;
name|hasBlock
operator|=
literal|true
expr_stmt|;
name|forceBlockMerging
operator|=
literal|false
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
name|blockTagClosed
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|currentNodeIdx
operator|=
literal|0
init|;
name|currentNodeIdx
operator|<
name|count
argument_list|()
condition|;
operator|++
name|currentNodeIdx
control|)
block|{
name|currentNode
operator|=
operator|&
name|at
argument_list|(
name|currentNodeIdx
argument_list|)
expr_stmt|;
name|wsm
operator|=
name|textEditMode
condition|?
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePreWrap
else|:
name|currentNode
operator|->
name|wsm
expr_stmt|;
comment|/*          * process each node in three stages:          * 1) check if the hierarchy changed and we therefore passed the          *    equivalent of a closing tag -> we may need to finish off          *    some structures like tables          *          * 2) check if the current node is a special node like a          *<table>,<ul> or<img> tag that requires special processing          *          * 3) if the node should result in a QTextBlock create one and          *    finally insert text that may be attached to the node          */
comment|/* emit 'closing' table blocks or adjust current indent level          * if we          *  1) are beyond the first node          *  2) the current node not being a child of the previous node          *      means there was a tag closing in the input html          */
if|if
condition|(
name|currentNodeIdx
operator|>
literal|0
operator|&&
operator|(
name|currentNode
operator|->
name|parent
operator|!=
name|currentNodeIdx
operator|-
literal|1
operator|)
condition|)
block|{
name|blockTagClosed
operator|=
name|closeTag
argument_list|()
expr_stmt|;
comment|// visually collapse subsequent block tags, but if the element after the closed block tag
comment|// is for example an inline element (!isBlock) we have to make sure we start a new paragraph by setting
comment|// hasBlock to false.
if|if
condition|(
name|blockTagClosed
operator|&&
operator|!
name|currentNode
operator|->
name|isBlock
argument_list|()
operator|&&
name|currentNode
operator|->
name|id
operator|!=
name|Html_unknown
condition|)
block|{
name|hasBlock
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasBlock
condition|)
block|{
comment|// when collapsing subsequent block tags we need to clear the block format
name|QTextBlockFormat
name|blockFormat
init|=
name|currentNode
operator|->
name|blockFormat
decl_stmt|;
name|blockFormat
operator|.
name|setIndent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|QTextBlockFormat
name|oldFormat
init|=
name|cursor
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|PageBreakPolicy
argument_list|)
condition|)
block|{
name|QTextFormat
operator|::
name|PageBreakFlags
name|pageBreak
init|=
name|oldFormat
operator|.
name|pageBreakPolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|pageBreak
operator|==
name|QTextFormat
operator|::
name|PageBreak_AlwaysAfter
condition|)
comment|/* We remove an empty paragrah that requested a page break after.                            moving that request to the next paragraph means we also need to make                             that a pagebreak before to keep the same visual appearance.                         */
name|pageBreak
operator|=
name|QTextFormat
operator|::
name|PageBreak_AlwaysBefore
expr_stmt|;
name|blockFormat
operator|.
name|setPageBreakPolicy
argument_list|(
name|pageBreak
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|blockFormat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentNode
operator|->
name|displayMode
operator|==
name|QTextHtmlElement
operator|::
name|DisplayNone
condition|)
block|{
if|if
condition|(
name|currentNode
operator|->
name|id
operator|==
name|Html_title
condition|)
name|doc
operator|->
name|setMetaInformation
argument_list|(
name|QTextDocument
operator|::
name|DocumentTitle
argument_list|,
name|currentNode
operator|->
name|text
argument_list|)
expr_stmt|;
comment|// ignore explicitly 'invisible' elements
continue|continue;
block|}
if|if
condition|(
name|processSpecialNodes
argument_list|()
operator|==
name|ContinueWithNextNode
condition|)
continue|continue;
comment|// make sure there's a block for 'Blah' after<ul><li>foo</ul>Blah
if|if
condition|(
name|blockTagClosed
operator|&&
operator|!
name|hasBlock
operator|&&
operator|!
name|currentNode
operator|->
name|isBlock
argument_list|()
operator|&&
operator|!
name|currentNode
operator|->
name|text
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|currentNode
operator|->
name|hasOnlyWhitespace
argument_list|()
operator|&&
name|currentNode
operator|->
name|displayMode
operator|==
name|QTextHtmlElement
operator|::
name|DisplayInline
condition|)
block|{
name|QTextBlockFormat
name|block
init|=
name|currentNode
operator|->
name|blockFormat
decl_stmt|;
name|block
operator|.
name|setIndent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|appendBlock
argument_list|(
name|block
argument_list|,
name|currentNode
operator|->
name|charFormat
argument_list|)
expr_stmt|;
name|hasBlock
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|currentNode
operator|->
name|isBlock
argument_list|()
condition|)
block|{
name|QTextHtmlImporter
operator|::
name|ProcessNodeResult
name|result
init|=
name|processBlockNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ContinueWithNextNode
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ContinueWithNextSibling
condition|)
block|{
name|currentNodeIdx
operator|+=
name|currentNode
operator|->
name|children
operator|.
name|size
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|currentNode
operator|->
name|charFormat
operator|.
name|isAnchor
argument_list|()
operator|&&
operator|!
name|currentNode
operator|->
name|charFormat
operator|.
name|anchorName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|namedAnchors
operator|.
name|append
argument_list|(
name|currentNode
operator|->
name|charFormat
operator|.
name|anchorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appendNodeText
argument_list|()
condition|)
name|hasBlock
operator|=
literal|false
expr_stmt|;
comment|// if we actually appended text then we don't
comment|// have an empty block anymore
block|}
name|cursor
operator|.
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendNodeText
name|bool
name|QTextHtmlImporter
operator|::
name|appendNodeText
parameter_list|()
block|{
specifier|const
name|int
name|initialCursorPosition
init|=
name|cursor
operator|.
name|position
argument_list|()
decl_stmt|;
name|QTextCharFormat
name|format
init|=
name|currentNode
operator|->
name|charFormat
decl_stmt|;
if|if
condition|(
name|wsm
operator|==
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePre
operator|||
name|wsm
operator|==
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePreWrap
condition|)
name|compressNextWhitespace
operator|=
name|PreserveWhiteSpace
expr_stmt|;
name|QString
name|text
init|=
name|currentNode
operator|->
name|text
decl_stmt|;
name|QString
name|textToInsert
decl_stmt|;
name|textToInsert
operator|.
name|reserve
argument_list|(
name|text
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|text
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|.
name|isSpace
argument_list|()
operator|&&
name|ch
operator|!=
name|QChar
operator|::
name|Nbsp
operator|&&
name|ch
operator|!=
name|QChar
operator|::
name|ParagraphSeparator
condition|)
block|{
if|if
condition|(
name|compressNextWhitespace
operator|==
name|CollapseWhiteSpace
condition|)
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
comment|// allow this one, and remove the ones coming next.
elseif|else
if|if
condition|(
name|compressNextWhitespace
operator|==
name|RemoveWhiteSpace
condition|)
continue|continue;
if|if
condition|(
name|wsm
operator|==
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePre
operator|||
name|textEditMode
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
name|textEditMode
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|wsm
operator|!=
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePreWrap
condition|)
block|{
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
if|if
condition|(
name|wsm
operator|==
name|QTextHtmlParserNode
operator|::
name|WhiteSpaceNoWrap
condition|)
name|ch
operator|=
name|QChar
operator|::
name|Nbsp
expr_stmt|;
else|else
name|ch
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|compressNextWhitespace
operator|=
name|PreserveWhiteSpace
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|||
name|ch
operator|==
name|QChar
operator|::
name|ParagraphSeparator
condition|)
block|{
if|if
condition|(
operator|!
name|textToInsert
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cursor
operator|.
name|insertText
argument_list|(
name|textToInsert
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|textToInsert
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QTextBlockFormat
name|fmt
init|=
name|cursor
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|fmt
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockBottomMargin
argument_list|)
condition|)
block|{
name|QTextBlockFormat
name|tmp
init|=
name|fmt
decl_stmt|;
name|tmp
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockBottomMargin
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockTopMargin
argument_list|)
expr_stmt|;
name|appendBlock
argument_list|(
name|fmt
argument_list|,
name|cursor
operator|.
name|charFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|namedAnchors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|textToInsert
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cursor
operator|.
name|insertText
argument_list|(
name|textToInsert
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|textToInsert
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|format
operator|.
name|setAnchor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|format
operator|.
name|setAnchorNames
argument_list|(
name|namedAnchors
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|insertText
argument_list|(
name|ch
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|namedAnchors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|IsAnchor
argument_list|)
expr_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|AnchorName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|textToInsert
operator|+=
name|ch
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|textToInsert
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cursor
operator|.
name|insertText
argument_list|(
name|textToInsert
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
operator|.
name|position
argument_list|()
operator|!=
name|initialCursorPosition
return|;
block|}
end_function
begin_function
DECL|function|processSpecialNodes
name|QTextHtmlImporter
operator|::
name|ProcessNodeResult
name|QTextHtmlImporter
operator|::
name|processSpecialNodes
parameter_list|()
block|{
switch|switch
condition|(
name|currentNode
operator|->
name|id
condition|)
block|{
case|case
name|Html_body
case|:
if|if
condition|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|QTextFrameFormat
name|fmt
init|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|fmt
operator|.
name|setBackground
argument_list|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|setFrameFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QTextHtmlParserNode
operator|*
argument_list|>
argument_list|(
name|currentNode
argument_list|)
operator|->
name|charFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
expr_stmt|;
block|}
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
break|break;
case|case
name|Html_ol
case|:
case|case
name|Html_ul
case|:
block|{
name|QTextListFormat
operator|::
name|Style
name|style
init|=
name|currentNode
operator|->
name|listStyle
decl_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|id
operator|==
name|Html_ul
operator|&&
operator|!
name|currentNode
operator|->
name|hasOwnListStyle
operator|&&
name|currentNode
operator|->
name|parent
condition|)
block|{
specifier|const
name|QTextHtmlParserNode
modifier|*
name|n
init|=
operator|&
name|at
argument_list|(
name|currentNode
operator|->
name|parent
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|id
operator|==
name|Html_ul
condition|)
block|{
name|style
operator|=
name|nextListStyle
argument_list|(
name|currentNode
operator|->
name|listStyle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|parent
condition|)
name|n
operator|=
operator|&
name|at
argument_list|(
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|QTextListFormat
name|listFmt
decl_stmt|;
name|listFmt
operator|.
name|setStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentNode
operator|->
name|textListNumberPrefix
operator|.
name|isNull
argument_list|()
condition|)
name|listFmt
operator|.
name|setNumberPrefix
argument_list|(
name|currentNode
operator|->
name|textListNumberPrefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentNode
operator|->
name|textListNumberSuffix
operator|.
name|isNull
argument_list|()
condition|)
name|listFmt
operator|.
name|setNumberSuffix
argument_list|(
name|currentNode
operator|->
name|textListNumberSuffix
argument_list|)
expr_stmt|;
operator|++
name|indent
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|hasCssListIndent
condition|)
name|listFmt
operator|.
name|setIndent
argument_list|(
name|currentNode
operator|->
name|cssListIndent
argument_list|)
expr_stmt|;
else|else
name|listFmt
operator|.
name|setIndent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|List
name|l
decl_stmt|;
name|l
operator|.
name|format
operator|=
name|listFmt
expr_stmt|;
name|l
operator|.
name|listNode
operator|=
name|currentNodeIdx
expr_stmt|;
name|lists
operator|.
name|append
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
comment|// broken html:<ul>Text here<li>Foo
specifier|const
name|QString
name|simpl
init|=
name|currentNode
operator|->
name|text
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|simpl
operator|.
name|isEmpty
argument_list|()
operator|||
name|simpl
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
return|return
name|ContinueWithNextNode
return|;
break|break;
block|}
case|case
name|Html_table
case|:
block|{
name|Table
name|t
init|=
name|scanTable
argument_list|(
name|currentNodeIdx
argument_list|)
decl_stmt|;
name|tables
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|hasBlock
operator|=
literal|false
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
return|return
name|ContinueWithNextNode
return|;
block|}
case|case
name|Html_tr
case|:
return|return
name|ContinueWithNextNode
return|;
case|case
name|Html_img
case|:
block|{
name|QTextImageFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setName
argument_list|(
name|currentNode
operator|->
name|imageName
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|merge
argument_list|(
name|currentNode
operator|->
name|charFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|imageWidth
operator|!=
operator|-
literal|1
condition|)
name|fmt
operator|.
name|setWidth
argument_list|(
name|currentNode
operator|->
name|imageWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|imageHeight
operator|!=
operator|-
literal|1
condition|)
name|fmt
operator|.
name|setHeight
argument_list|(
name|currentNode
operator|->
name|imageHeight
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|insertImage
argument_list|(
name|fmt
argument_list|,
name|QTextFrameFormat
operator|::
name|Position
argument_list|(
name|currentNode
operator|->
name|cssFloat
argument_list|)
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Left
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|mergeCharFormat
argument_list|(
name|currentNode
operator|->
name|charFormat
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Right
argument_list|)
expr_stmt|;
name|compressNextWhitespace
operator|=
name|CollapseWhiteSpace
expr_stmt|;
name|hasBlock
operator|=
literal|false
expr_stmt|;
return|return
name|ContinueWithNextNode
return|;
block|}
case|case
name|Html_hr
case|:
block|{
name|QTextBlockFormat
name|blockFormat
init|=
name|currentNode
operator|->
name|blockFormat
decl_stmt|;
name|blockFormat
operator|.
name|setTopMargin
argument_list|(
name|topMargin
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
name|blockFormat
operator|.
name|setBottomMargin
argument_list|(
name|bottomMargin
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
name|blockFormat
operator|.
name|setProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockTrailingHorizontalRulerWidth
argument_list|,
name|currentNode
operator|->
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasBlock
operator|&&
name|importMode
operator|==
name|ImportToDocument
condition|)
name|cursor
operator|.
name|mergeBlockFormat
argument_list|(
name|blockFormat
argument_list|)
expr_stmt|;
else|else
name|appendBlock
argument_list|(
name|blockFormat
argument_list|)
expr_stmt|;
name|hasBlock
operator|=
literal|false
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
return|return
name|ContinueWithNextNode
return|;
block|}
default|default:
break|break;
block|}
return|return
name|ContinueWithCurrentNode
return|;
block|}
end_function
begin_comment
comment|// returns true if a block tag was closed
end_comment
begin_function
DECL|function|closeTag
name|bool
name|QTextHtmlImporter
operator|::
name|closeTag
parameter_list|()
block|{
specifier|const
name|QTextHtmlParserNode
modifier|*
name|closedNode
init|=
operator|&
name|at
argument_list|(
name|currentNodeIdx
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|endDepth
init|=
name|depth
argument_list|(
name|currentNodeIdx
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|depth
init|=
name|this
operator|->
name|depth
argument_list|(
name|currentNodeIdx
operator|-
literal|1
argument_list|)
decl_stmt|;
name|bool
name|blockTagClosed
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|depth
operator|>
name|endDepth
condition|)
block|{
name|Table
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tables
operator|.
name|isEmpty
argument_list|()
condition|)
name|t
operator|=
operator|&
name|tables
operator|.
name|last
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|closedNode
operator|->
name|id
condition|)
block|{
case|case
name|Html_tr
case|:
if|if
condition|(
name|t
operator|&&
operator|!
name|t
operator|->
name|isTextFrame
condition|)
block|{
operator|++
name|t
operator|->
name|currentRow
expr_stmt|;
comment|// for broken html with rowspans but missing tr tags
while|while
condition|(
operator|!
name|t
operator|->
name|currentCell
operator|.
name|atEnd
argument_list|()
operator|&&
name|t
operator|->
name|currentCell
operator|.
name|row
operator|<
name|t
operator|->
name|currentRow
condition|)
operator|++
name|t
operator|->
name|currentCell
expr_stmt|;
block|}
name|blockTagClosed
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Html_table
case|:
if|if
condition|(
operator|!
name|t
condition|)
break|break;
name|indent
operator|=
name|t
operator|->
name|lastIndent
expr_stmt|;
name|tables
operator|.
name|resize
argument_list|(
name|tables
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cursor
operator|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|lastCursorPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|&
name|tables
operator|.
name|last
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|isTextFrame
condition|)
name|cursor
operator|=
name|t
operator|->
name|frame
operator|->
name|lastCursorPosition
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|currentCell
operator|.
name|atEnd
argument_list|()
condition|)
name|cursor
operator|=
name|t
operator|->
name|currentCell
operator|.
name|cell
argument_list|()
operator|.
name|lastCursorPosition
argument_list|()
expr_stmt|;
block|}
comment|// we don't need an extra block after tables, so we don't
comment|// claim to have closed one for the creation of a new one
comment|// in import()
name|blockTagClosed
operator|=
literal|false
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
break|break;
case|case
name|Html_th
case|:
case|case
name|Html_td
case|:
if|if
condition|(
name|t
operator|&&
operator|!
name|t
operator|->
name|isTextFrame
condition|)
operator|++
name|t
operator|->
name|currentCell
expr_stmt|;
name|blockTagClosed
operator|=
literal|true
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
break|break;
case|case
name|Html_ol
case|:
case|case
name|Html_ul
case|:
if|if
condition|(
name|lists
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|lists
operator|.
name|resize
argument_list|(
name|lists
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|indent
expr_stmt|;
name|blockTagClosed
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Html_br
case|:
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
break|break;
case|case
name|Html_div
case|:
if|if
condition|(
name|closedNode
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
comment|// fall through
default|default:
if|if
condition|(
name|closedNode
operator|->
name|isBlock
argument_list|()
condition|)
name|blockTagClosed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|closedNode
operator|=
operator|&
name|at
argument_list|(
name|closedNode
operator|->
name|parent
argument_list|)
expr_stmt|;
operator|--
name|depth
expr_stmt|;
block|}
return|return
name|blockTagClosed
return|;
block|}
end_function
begin_function
DECL|function|scanTable
name|QTextHtmlImporter
operator|::
name|Table
name|QTextHtmlImporter
operator|::
name|scanTable
parameter_list|(
name|int
name|tableNodeIdx
parameter_list|)
block|{
name|Table
name|table
decl_stmt|;
name|table
operator|.
name|columns
operator|=
literal|0
expr_stmt|;
name|QVector
argument_list|<
name|QTextLength
argument_list|>
name|columnWidths
decl_stmt|;
name|int
name|tableHeaderRowCount
init|=
literal|0
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|rowNodes
decl_stmt|;
name|rowNodes
operator|.
name|reserve
argument_list|(
name|at
argument_list|(
name|tableNodeIdx
argument_list|)
operator|.
name|children
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|int
name|row
decl|,
name|at
argument_list|(
name|tableNodeIdx
argument_list|)
operator|.
name|children
control|)
switch|switch
condition|(
name|at
argument_list|(
name|row
argument_list|)
operator|.
name|id
condition|)
block|{
case|case
name|Html_tr
case|:
name|rowNodes
operator|+=
name|row
expr_stmt|;
break|break;
case|case
name|Html_thead
case|:
case|case
name|Html_tbody
case|:
case|case
name|Html_tfoot
case|:
foreach|foreach
control|(
name|int
name|potentialRow
decl|,
name|at
argument_list|(
name|row
argument_list|)
operator|.
name|children
control|)
if|if
condition|(
name|at
argument_list|(
name|potentialRow
argument_list|)
operator|.
name|id
operator|==
name|Html_tr
condition|)
block|{
name|rowNodes
operator|+=
name|potentialRow
expr_stmt|;
if|if
condition|(
name|at
argument_list|(
name|row
argument_list|)
operator|.
name|id
operator|==
name|Html_thead
condition|)
operator|++
name|tableHeaderRowCount
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|QVector
argument_list|<
name|RowColSpanInfo
argument_list|>
name|rowColSpans
decl_stmt|;
name|QVector
argument_list|<
name|RowColSpanInfo
argument_list|>
name|rowColSpanForColumn
decl_stmt|;
name|int
name|effectiveRow
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|int
name|row
decl|,
name|rowNodes
control|)
block|{
name|int
name|colsInRow
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|int
name|cell
decl|,
name|at
argument_list|(
name|row
argument_list|)
operator|.
name|children
control|)
if|if
condition|(
name|at
argument_list|(
name|cell
argument_list|)
operator|.
name|isTableCell
argument_list|()
condition|)
block|{
comment|// skip all columns with spans from previous rows
while|while
condition|(
name|colsInRow
operator|<
name|rowColSpanForColumn
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|const
name|RowColSpanInfo
modifier|&
name|spanInfo
init|=
name|rowColSpanForColumn
index|[
name|colsInRow
index|]
decl_stmt|;
if|if
condition|(
name|spanInfo
operator|.
name|row
operator|+
name|spanInfo
operator|.
name|rowSpan
operator|>
name|effectiveRow
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|spanInfo
operator|.
name|col
operator|==
name|colsInRow
argument_list|)
expr_stmt|;
name|colsInRow
operator|+=
name|spanInfo
operator|.
name|colSpan
expr_stmt|;
block|}
else|else
break|break;
block|}
specifier|const
name|QTextHtmlParserNode
modifier|&
name|c
init|=
name|at
argument_list|(
name|cell
argument_list|)
decl_stmt|;
specifier|const
name|int
name|currentColumn
init|=
name|colsInRow
decl_stmt|;
name|colsInRow
operator|+=
name|c
operator|.
name|tableCellColSpan
expr_stmt|;
name|RowColSpanInfo
name|spanInfo
decl_stmt|;
name|spanInfo
operator|.
name|row
operator|=
name|effectiveRow
expr_stmt|;
name|spanInfo
operator|.
name|col
operator|=
name|currentColumn
expr_stmt|;
name|spanInfo
operator|.
name|colSpan
operator|=
name|c
operator|.
name|tableCellColSpan
expr_stmt|;
name|spanInfo
operator|.
name|rowSpan
operator|=
name|c
operator|.
name|tableCellRowSpan
expr_stmt|;
if|if
condition|(
name|spanInfo
operator|.
name|colSpan
operator|>
literal|1
operator|||
name|spanInfo
operator|.
name|rowSpan
operator|>
literal|1
condition|)
name|rowColSpans
operator|.
name|append
argument_list|(
name|spanInfo
argument_list|)
expr_stmt|;
name|columnWidths
operator|.
name|resize
argument_list|(
name|qMax
argument_list|(
name|columnWidths
operator|.
name|count
argument_list|()
argument_list|,
name|colsInRow
argument_list|)
argument_list|)
expr_stmt|;
name|rowColSpanForColumn
operator|.
name|resize
argument_list|(
name|columnWidths
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|currentColumn
init|;
name|i
operator|<
name|currentColumn
operator|+
name|c
operator|.
name|tableCellColSpan
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|columnWidths
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
operator|==
name|QTextLength
operator|::
name|VariableLength
condition|)
block|{
name|QTextLength
name|w
init|=
name|c
operator|.
name|width
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|tableCellColSpan
operator|>
literal|1
operator|&&
name|w
operator|.
name|type
argument_list|()
operator|!=
name|QTextLength
operator|::
name|VariableLength
condition|)
name|w
operator|=
name|QTextLength
argument_list|(
name|w
operator|.
name|type
argument_list|()
argument_list|,
name|w
operator|.
name|value
argument_list|(
literal|100.
argument_list|)
operator|/
name|c
operator|.
name|tableCellColSpan
argument_list|)
expr_stmt|;
name|columnWidths
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
block|}
name|rowColSpanForColumn
index|[
name|i
index|]
operator|=
name|spanInfo
expr_stmt|;
block|}
block|}
name|table
operator|.
name|columns
operator|=
name|qMax
argument_list|(
name|table
operator|.
name|columns
argument_list|,
name|colsInRow
argument_list|)
expr_stmt|;
operator|++
name|effectiveRow
expr_stmt|;
block|}
name|table
operator|.
name|rows
operator|=
name|effectiveRow
expr_stmt|;
name|table
operator|.
name|lastIndent
operator|=
name|indent
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
operator|.
name|rows
operator|==
literal|0
operator|||
name|table
operator|.
name|columns
operator|==
literal|0
condition|)
return|return
name|table
return|;
name|QTextFrameFormat
name|fmt
decl_stmt|;
specifier|const
name|QTextHtmlParserNode
modifier|&
name|node
init|=
name|at
argument_list|(
name|tableNodeIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isTextFrame
condition|)
block|{
name|QTextTableFormat
name|tableFmt
decl_stmt|;
name|tableFmt
operator|.
name|setCellSpacing
argument_list|(
name|node
operator|.
name|tableCellSpacing
argument_list|)
expr_stmt|;
name|tableFmt
operator|.
name|setCellPadding
argument_list|(
name|node
operator|.
name|tableCellPadding
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|blockFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockAlignment
argument_list|)
condition|)
name|tableFmt
operator|.
name|setAlignment
argument_list|(
name|node
operator|.
name|blockFormat
operator|.
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
name|tableFmt
operator|.
name|setColumns
argument_list|(
name|table
operator|.
name|columns
argument_list|)
expr_stmt|;
name|tableFmt
operator|.
name|setColumnWidthConstraints
argument_list|(
name|columnWidths
argument_list|)
expr_stmt|;
name|tableFmt
operator|.
name|setHeaderRowCount
argument_list|(
name|tableHeaderRowCount
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|tableFmt
expr_stmt|;
block|}
name|fmt
operator|.
name|setTopMargin
argument_list|(
name|topMargin
argument_list|(
name|tableNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setBottomMargin
argument_list|(
name|bottomMargin
argument_list|(
name|tableNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setLeftMargin
argument_list|(
name|leftMargin
argument_list|(
name|tableNodeIdx
argument_list|)
operator|+
name|table
operator|.
name|lastIndent
operator|*
literal|40
comment|// ##### not a good emulation
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setRightMargin
argument_list|(
name|rightMargin
argument_list|(
name|tableNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
comment|// compatibility
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|fmt
operator|.
name|leftMargin
argument_list|()
argument_list|,
name|fmt
operator|.
name|rightMargin
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|fmt
operator|.
name|leftMargin
argument_list|()
argument_list|,
name|fmt
operator|.
name|topMargin
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|fmt
operator|.
name|leftMargin
argument_list|()
argument_list|,
name|fmt
operator|.
name|bottomMargin
argument_list|()
argument_list|)
condition|)
name|fmt
operator|.
name|setProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameMargin
argument_list|,
name|fmt
operator|.
name|leftMargin
argument_list|()
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setBorderStyle
argument_list|(
name|node
operator|.
name|borderStyle
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setBorderBrush
argument_list|(
name|node
operator|.
name|borderBrush
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setBorder
argument_list|(
name|node
operator|.
name|tableBorder
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setWidth
argument_list|(
name|node
operator|.
name|width
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setHeight
argument_list|(
name|node
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|blockFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|PageBreakPolicy
argument_list|)
condition|)
name|fmt
operator|.
name|setPageBreakPolicy
argument_list|(
name|node
operator|.
name|blockFormat
operator|.
name|pageBreakPolicy
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|blockFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|LayoutDirection
argument_list|)
condition|)
name|fmt
operator|.
name|setLayoutDirection
argument_list|(
name|node
operator|.
name|blockFormat
operator|.
name|layoutDirection
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|charFormat
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
name|fmt
operator|.
name|setBackground
argument_list|(
name|node
operator|.
name|charFormat
operator|.
name|background
argument_list|()
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setPosition
argument_list|(
name|QTextFrameFormat
operator|::
name|Position
argument_list|(
name|node
operator|.
name|cssFloat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|isTextFrame
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isRootFrame
condition|)
block|{
name|table
operator|.
name|frame
operator|=
name|cursor
operator|.
name|currentFrame
argument_list|()
expr_stmt|;
name|table
operator|.
name|frame
operator|->
name|setFrameFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
else|else
name|table
operator|.
name|frame
operator|=
name|cursor
operator|.
name|insertFrame
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|table
operator|.
name|isTextFrame
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|oldPos
init|=
name|cursor
operator|.
name|position
argument_list|()
decl_stmt|;
name|QTextTable
modifier|*
name|textTable
init|=
name|cursor
operator|.
name|insertTable
argument_list|(
name|table
operator|.
name|rows
argument_list|,
name|table
operator|.
name|columns
argument_list|,
name|fmt
operator|.
name|toTableFormat
argument_list|()
argument_list|)
decl_stmt|;
name|table
operator|.
name|frame
operator|=
name|textTable
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowColSpans
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|RowColSpanInfo
modifier|&
name|nfo
init|=
name|rowColSpans
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|textTable
operator|->
name|mergeCells
argument_list|(
name|nfo
operator|.
name|row
argument_list|,
name|nfo
operator|.
name|col
argument_list|,
name|nfo
operator|.
name|rowSpan
argument_list|,
name|nfo
operator|.
name|colSpan
argument_list|)
expr_stmt|;
block|}
name|table
operator|.
name|currentCell
operator|=
name|TableCellIterator
argument_list|(
name|textTable
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
comment|// restore for caption support which needs to be inserted right before the table
block|}
return|return
name|table
return|;
block|}
end_function
begin_function
DECL|function|processBlockNode
name|QTextHtmlImporter
operator|::
name|ProcessNodeResult
name|QTextHtmlImporter
operator|::
name|processBlockNode
parameter_list|()
block|{
name|QTextBlockFormat
name|block
decl_stmt|;
name|QTextCharFormat
name|charFmt
decl_stmt|;
name|bool
name|modifiedBlockFormat
init|=
literal|true
decl_stmt|;
name|bool
name|modifiedCharFormat
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|isTableCell
argument_list|()
operator|&&
operator|!
name|tables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Table
modifier|&
name|t
init|=
name|tables
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isTextFrame
operator|&&
operator|!
name|t
operator|.
name|currentCell
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QTextTableCell
name|cell
init|=
name|t
operator|.
name|currentCell
operator|.
name|cell
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QTextTableCellFormat
name|fmt
init|=
name|cell
operator|.
name|format
argument_list|()
operator|.
name|toTableCellFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|topPadding
argument_list|(
name|currentNodeIdx
argument_list|)
operator|>=
literal|0
condition|)
name|fmt
operator|.
name|setTopPadding
argument_list|(
name|topPadding
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottomPadding
argument_list|(
name|currentNodeIdx
argument_list|)
operator|>=
literal|0
condition|)
name|fmt
operator|.
name|setBottomPadding
argument_list|(
name|bottomPadding
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftPadding
argument_list|(
name|currentNodeIdx
argument_list|)
operator|>=
literal|0
condition|)
name|fmt
operator|.
name|setLeftPadding
argument_list|(
name|leftPadding
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightPadding
argument_list|(
name|currentNodeIdx
argument_list|)
operator|>=
literal|0
condition|)
name|fmt
operator|.
name|setRightPadding
argument_list|(
name|rightPadding
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
expr_stmt|;
name|cell
operator|.
name|setFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|cell
operator|.
name|firstPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|hasBlock
operator|=
literal|true
expr_stmt|;
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|charFmt
operator|.
name|setBackground
argument_list|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|mergeBlockCharFormat
argument_list|(
name|charFmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasBlock
condition|)
block|{
name|block
operator|=
name|cursor
operator|.
name|blockFormat
argument_list|()
expr_stmt|;
name|charFmt
operator|=
name|cursor
operator|.
name|blockCharFormat
argument_list|()
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|false
expr_stmt|;
name|modifiedCharFormat
operator|=
literal|false
expr_stmt|;
block|}
comment|// collapse
block|{
name|qreal
name|tm
init|=
name|qreal
argument_list|(
name|topMargin
argument_list|(
name|currentNodeIdx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tm
operator|>
name|block
operator|.
name|topMargin
argument_list|()
condition|)
block|{
name|block
operator|.
name|setTopMargin
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|int
name|bottomMargin
init|=
name|this
operator|->
name|bottomMargin
argument_list|(
name|currentNodeIdx
argument_list|)
decl_stmt|;
comment|// for list items we may want to collapse with the bottom margin of the
comment|// list.
specifier|const
name|QTextHtmlParserNode
modifier|*
name|parentNode
init|=
name|currentNode
operator|->
name|parent
condition|?
operator|&
name|at
argument_list|(
name|currentNode
operator|->
name|parent
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|currentNode
operator|->
name|id
operator|==
name|Html_li
operator|||
name|currentNode
operator|->
name|id
operator|==
name|Html_dt
operator|||
name|currentNode
operator|->
name|id
operator|==
name|Html_dd
operator|)
operator|&&
name|parentNode
operator|&&
operator|(
name|parentNode
operator|->
name|isListStart
argument_list|()
operator|||
name|parentNode
operator|->
name|id
operator|==
name|Html_dl
operator|)
operator|&&
operator|(
name|parentNode
operator|->
name|children
operator|.
name|last
argument_list|()
operator|==
name|currentNodeIdx
operator|)
condition|)
block|{
name|bottomMargin
operator|=
name|qMax
argument_list|(
name|bottomMargin
argument_list|,
name|this
operator|->
name|bottomMargin
argument_list|(
name|currentNode
operator|->
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|.
name|bottomMargin
argument_list|()
operator|!=
name|bottomMargin
condition|)
block|{
name|block
operator|.
name|setBottomMargin
argument_list|(
name|bottomMargin
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
block|{
specifier|const
name|qreal
name|lm
init|=
name|leftMargin
argument_list|(
name|currentNodeIdx
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|rm
init|=
name|rightMargin
argument_list|(
name|currentNodeIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|leftMargin
argument_list|()
operator|!=
name|lm
condition|)
block|{
name|block
operator|.
name|setLeftMargin
argument_list|(
name|lm
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|.
name|rightMargin
argument_list|()
operator|!=
name|rm
condition|)
block|{
name|block
operator|.
name|setRightMargin
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentNode
operator|->
name|id
operator|!=
name|Html_li
operator|&&
name|indent
operator|!=
literal|0
operator|&&
operator|(
name|lists
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|hasBlock
operator|||
operator|!
name|lists
operator|.
name|last
argument_list|()
operator|.
name|list
operator|||
name|lists
operator|.
name|last
argument_list|()
operator|.
name|list
operator|->
name|itemNumber
argument_list|(
name|cursor
operator|.
name|block
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|block
operator|.
name|setIndent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|currentNode
operator|->
name|blockFormat
operator|.
name|propertyCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
name|block
operator|.
name|merge
argument_list|(
name|currentNode
operator|->
name|blockFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentNode
operator|->
name|charFormat
operator|.
name|propertyCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|modifiedCharFormat
operator|=
literal|true
expr_stmt|;
name|charFmt
operator|.
name|merge
argument_list|(
name|currentNode
operator|->
name|charFormat
argument_list|)
expr_stmt|;
block|}
comment|// ####################
comment|//                block.setFloatPosition(node->cssFloat);
if|if
condition|(
name|wsm
operator|==
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePre
condition|)
block|{
name|block
operator|.
name|setNonBreakableLines
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
operator|!
name|currentNode
operator|->
name|isTableCell
argument_list|()
condition|)
block|{
name|block
operator|.
name|setBackground
argument_list|(
name|currentNode
operator|->
name|charFormat
operator|.
name|background
argument_list|()
argument_list|)
expr_stmt|;
name|modifiedBlockFormat
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|hasBlock
operator|&&
operator|(
operator|!
name|currentNode
operator|->
name|isEmptyParagraph
operator|||
name|forceBlockMerging
operator|)
condition|)
block|{
if|if
condition|(
name|modifiedBlockFormat
condition|)
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifiedCharFormat
condition|)
name|cursor
operator|.
name|setBlockCharFormat
argument_list|(
name|charFmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentNodeIdx
operator|==
literal|1
operator|&&
name|cursor
operator|.
name|position
argument_list|()
operator|==
literal|0
operator|&&
name|currentNode
operator|->
name|isEmptyParagraph
condition|)
block|{
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setBlockCharFormat
argument_list|(
name|charFmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendBlock
argument_list|(
name|block
argument_list|,
name|charFmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentNode
operator|->
name|userState
operator|!=
operator|-
literal|1
condition|)
name|cursor
operator|.
name|block
argument_list|()
operator|.
name|setUserState
argument_list|(
name|currentNode
operator|->
name|userState
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|id
operator|==
name|Html_li
operator|&&
operator|!
name|lists
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
modifier|&
name|l
init|=
name|lists
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|list
condition|)
block|{
name|l
operator|.
name|list
operator|->
name|add
argument_list|(
name|cursor
operator|.
name|block
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l
operator|.
name|list
operator|=
name|cursor
operator|.
name|createList
argument_list|(
name|l
operator|.
name|format
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|listTopMargin
init|=
name|topMargin
argument_list|(
name|l
operator|.
name|listNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|listTopMargin
operator|>
name|block
operator|.
name|topMargin
argument_list|()
condition|)
block|{
name|block
operator|.
name|setTopMargin
argument_list|(
name|listTopMargin
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|mergeBlockFormat
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasBlock
condition|)
block|{
name|QTextBlockFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setIndent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|mergeBlockFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
block|}
name|forceBlockMerging
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|id
operator|==
name|Html_body
operator|||
name|currentNode
operator|->
name|id
operator|==
name|Html_html
condition|)
name|forceBlockMerging
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|currentNode
operator|->
name|isEmptyParagraph
condition|)
block|{
name|hasBlock
operator|=
literal|false
expr_stmt|;
return|return
name|ContinueWithNextSibling
return|;
block|}
name|hasBlock
operator|=
literal|true
expr_stmt|;
name|blockTagClosed
operator|=
literal|false
expr_stmt|;
return|return
name|ContinueWithCurrentNode
return|;
block|}
end_function
begin_function
DECL|function|appendBlock
name|void
name|QTextHtmlImporter
operator|::
name|appendBlock
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|,
name|QTextCharFormat
name|charFmt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namedAnchors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|charFmt
operator|.
name|setAnchor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|charFmt
operator|.
name|setAnchorNames
argument_list|(
name|namedAnchors
argument_list|)
expr_stmt|;
name|namedAnchors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|cursor
operator|.
name|insertBlock
argument_list|(
name|format
argument_list|,
name|charFmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsm
operator|!=
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePre
operator|&&
name|wsm
operator|!=
name|QTextHtmlParserNode
operator|::
name|WhiteSpacePreWrap
condition|)
name|compressNextWhitespace
operator|=
name|RemoveWhiteSpace
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     \fn QTextDocumentFragment QTextDocumentFragment::fromHtml(const QString&text)      Returns a QTextDocumentFragment based on the arbitrary piece of     HTML in the given \a text. The formatting is preserved as much as     possible; for example, "<b>bold</b>" will become a document     fragment with the text "bold" with a bold character format. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|fromHtml
name|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|fromHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|html
parameter_list|)
block|{
return|return
name|fromHtml
argument_list|(
name|html
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextDocumentFragment QTextDocumentFragment::fromHtml(const QString&text, const QTextDocument *resourceProvider)     \since 4.2      Returns a QTextDocumentFragment based on the arbitrary piece of     HTML in the given \a text. The formatting is preserved as much as     possible; for example, "<b>bold</b>" will become a document     fragment with the text "bold" with a bold character format.      If the provided HTML contains references to external resources such as imported style sheets, then     they will be loaded through the \a resourceProvider. */
end_comment
begin_function
DECL|function|fromHtml
name|QTextDocumentFragment
name|QTextDocumentFragment
operator|::
name|fromHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|html
parameter_list|,
specifier|const
name|QTextDocument
modifier|*
name|resourceProvider
parameter_list|)
block|{
name|QTextDocumentFragment
name|res
decl_stmt|;
name|res
operator|.
name|d
operator|=
operator|new
name|QTextDocumentFragmentPrivate
expr_stmt|;
name|QTextHtmlImporter
name|importer
argument_list|(
name|res
operator|.
name|d
operator|->
name|doc
argument_list|,
name|html
argument_list|,
name|QTextHtmlImporter
operator|::
name|ImportToFragment
argument_list|,
name|resourceProvider
argument_list|)
decl_stmt|;
name|importer
operator|.
name|import
argument_list|()
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
end_unit
