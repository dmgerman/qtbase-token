begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextlayout.h"
end_include
begin_include
include|#
directive|include
file|"qtextengine_p.h"
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qfont.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qtextformat.h>
end_include
begin_include
include|#
directive|include
file|<qabstracttextdocumentlayout.h>
end_include
begin_include
include|#
directive|include
file|"qtextdocument_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextformat_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qglyphrun.h"
end_include
begin_include
include|#
directive|include
file|"qglyphrun_p.h"
end_include
begin_include
include|#
directive|include
file|"qrawfont.h"
end_include
begin_include
include|#
directive|include
file|"qrawfont_p.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qfontengine_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qpainter_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|ObjectSelectionBrush
define|#
directive|define
name|ObjectSelectionBrush
value|(QTextFormat::ForegroundBrush + 1)
DECL|macro|SuppressText
define|#
directive|define
name|SuppressText
value|0x5012
DECL|macro|SuppressBackground
define|#
directive|define
name|SuppressBackground
value|0x513
comment|/*!     \class QTextLayout::FormatRange     \reentrant      \brief The QTextLayout::FormatRange structure is used to apply extra formatting information     for a specified area in the text layout's content.     \inmodule QtGui      \sa QTextLayout::setFormats(), QTextLayout::draw() */
comment|/*!     \variable QTextLayout::FormatRange::start     Specifies the beginning of the format range within the text layout's text. */
comment|/*!     \variable QTextLayout::FormatRange::length     Specifies the numer of characters the format range spans. */
comment|/*!     \variable QTextLayout::FormatRange::format     Specifies the format to apply. */
comment|/*!     \class QTextInlineObject     \reentrant      \brief The QTextInlineObject class represents an inline object in     a QAbstractTextDocumentLayout and its implementations.     \inmodule QtGui      \ingroup richtext-processing      Normally, you do not need to create a QTextInlineObject. It is     used by QAbstractTextDocumentLayout to handle inline objects when     implementing a custom layout.      The inline object has various attributes that can be set, for     example using, setWidth(), setAscent(), and setDescent(). The     rectangle it occupies is given by rect(), and its direction by     textDirection(). Its position in the text layout is given by     textPosition(), and its format is given by format(). */
comment|/*!     \fn QTextInlineObject::QTextInlineObject(int i, QTextEngine *e)     \internal      Creates a new inline object for the item at position \a i in the     text engine \a e. */
comment|/*!     \fn QTextInlineObject::QTextInlineObject()      \internal */
comment|/*!     \fn bool QTextInlineObject::isValid() const      Returns \c true if this inline object is valid; otherwise returns     false. */
comment|/*!     Returns the inline object's rectangle.      \sa ascent(), descent(), width() */
DECL|function|rect
name|QRectF
name|QTextInlineObject
operator|::
name|rect
parameter_list|()
specifier|const
block|{
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
decl_stmt|;
return|return
name|QRectF
argument_list|(
literal|0
argument_list|,
operator|-
name|si
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
argument_list|,
name|si
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|si
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the inline object's width.      \sa ascent(), descent(), rect() */
end_comment
begin_function
DECL|function|width
name|qreal
name|QTextInlineObject
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|width
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the inline object's ascent.      \sa descent(), width(), rect() */
end_comment
begin_function
DECL|function|ascent
name|qreal
name|QTextInlineObject
operator|::
name|ascent
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the inline object's descent.      \sa ascent(), width(), rect() */
end_comment
begin_function
DECL|function|descent
name|qreal
name|QTextInlineObject
operator|::
name|descent
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|descent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the inline object's total height. This is equal to     ascent() + descent() + 1.      \sa ascent(), descent(), width(), rect() */
end_comment
begin_function
DECL|function|height
name|qreal
name|QTextInlineObject
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the inline object's width to \a w.      \sa width(), ascent(), descent(), rect() */
end_comment
begin_function
DECL|function|setWidth
name|void
name|QTextInlineObject
operator|::
name|setWidth
parameter_list|(
name|qreal
name|w
parameter_list|)
block|{
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|width
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the inline object's ascent to \a a.      \sa ascent(), setDescent(), width(), rect() */
end_comment
begin_function
DECL|function|setAscent
name|void
name|QTextInlineObject
operator|::
name|setAscent
parameter_list|(
name|qreal
name|a
parameter_list|)
block|{
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|ascent
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the inline object's descent to \a d.      \sa descent(), setAscent(), width(), rect() */
end_comment
begin_function
DECL|function|setDescent
name|void
name|QTextInlineObject
operator|::
name|setDescent
parameter_list|(
name|qreal
name|d
parameter_list|)
block|{
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|descent
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     The position of the inline object within the text layout. */
end_comment
begin_function
DECL|function|textPosition
name|int
name|QTextInlineObject
operator|::
name|textPosition
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an integer describing the format of the inline object     within the text layout. */
end_comment
begin_function
DECL|function|formatIndex
name|int
name|QTextInlineObject
operator|::
name|formatIndex
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|formatIndex
argument_list|(
operator|&
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns format of the inline object within the text layout. */
end_comment
begin_function
DECL|function|format
name|QTextFormat
name|QTextInlineObject
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|format
argument_list|(
operator|&
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns if the object should be laid out right-to-left or left-to-right. */
end_comment
begin_function
DECL|function|textDirection
name|Qt
operator|::
name|LayoutDirection
name|QTextInlineObject
operator|::
name|textDirection
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextLayout     \reentrant      \brief The QTextLayout class is used to lay out and render text.     \inmodule QtGui      \ingroup richtext-processing      It offers many features expected from a modern text layout     engine, including Unicode compliant rendering, line breaking and     handling of cursor positioning. It can also produce and render     device independent layout, something that is important for WYSIWYG     applications.      The class has a rather low level API and unless you intend to     implement your own text rendering for some specialized widget, you     probably won't need to use it directly.      QTextLayout can be used with both plain and rich text.      QTextLayout can be used to create a sequence of QTextLine     instances with given widths and can position them independently     on the screen. Once the layout is done, these lines can be drawn     on a paint device.      The text to be laid out can be provided in the constructor or set with     setText().      The layout can be seen as a sequence of QTextLine objects; use createLine()     to create a QTextLine instance, and lineAt() or lineForTextPosition() to retrieve     created lines.      Here is a code snippet that demonstrates the layout phase:     \snippet code/src_gui_text_qtextlayout.cpp 0      The text can then be rendered by calling the layout's draw() function:     \snippet code/src_gui_text_qtextlayout.cpp 1      For a given position in the text you can find a valid cursor position with     isValidCursorPosition(), nextCursorPosition(), and previousCursorPosition().      The QTextLayout itself can be positioned with setPosition(); it has a     boundingRect(), and a minimumWidth() and a maximumWidth().      \sa QStaticText */
end_comment
begin_comment
comment|/*!     \enum QTextLayout::CursorMode      \value SkipCharacters     \value SkipWords */
end_comment
begin_comment
comment|/*!     \fn QTextEngine *QTextLayout::engine() const     \internal      Returns the text engine used to render the text layout. */
end_comment
begin_comment
comment|/*!     Constructs an empty text layout.      \sa setText() */
end_comment
begin_constructor
DECL|function|QTextLayout
name|QTextLayout
operator|::
name|QTextLayout
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QTextEngine
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a text layout to lay out the given \a text. */
end_comment
begin_constructor
DECL|function|QTextLayout
name|QTextLayout
operator|::
name|QTextLayout
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QTextEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a text layout to lay out the given \a text with the specified     \a font.      All the metric and layout calculations will be done in terms of     the paint device, \a paintdevice. If \a paintdevice is 0 the     calculations will be done in screen metrics. */
end_comment
begin_constructor
DECL|function|QTextLayout
name|QTextLayout
operator|::
name|QTextLayout
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
name|QPaintDevice
modifier|*
name|paintdevice
parameter_list|)
block|{
name|QFont
name|f
argument_list|(
name|font
argument_list|)
decl_stmt|;
if|if
condition|(
name|paintdevice
condition|)
name|f
operator|=
name|QFont
argument_list|(
name|font
argument_list|,
name|paintdevice
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|QTextEngine
argument_list|(
operator|(
name|text
operator|.
name|isNull
argument_list|()
condition|?
operator|(
specifier|const
name|QString
operator|&
operator|)
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|)
else|:
name|text
operator|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal     Constructs a text layout to lay out the given \a block. */
end_comment
begin_constructor
DECL|function|QTextLayout
name|QTextLayout
operator|::
name|QTextLayout
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QTextEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|block
operator|=
name|block
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructs the layout. */
end_comment
begin_destructor
DECL|function|~QTextLayout
name|QTextLayout
operator|::
name|~
name|QTextLayout
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|stackEngine
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_RAWFONT
end_ifndef
begin_comment
comment|/*!     \internal     Sets a raw font, to be used with QTextLayout::glyphRuns.     Note that this only supports the needs of WebKit.     Use of this function with e.g. QTextLayout::draw will result     in undefined behaviour. */
end_comment
begin_function
DECL|function|setRawFont
name|void
name|QTextLayout
operator|::
name|setRawFont
parameter_list|(
specifier|const
name|QRawFont
modifier|&
name|rawFont
parameter_list|)
block|{
name|d
operator|->
name|rawFont
operator|=
name|rawFont
expr_stmt|;
name|d
operator|->
name|useRawFont
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|resetFontEngineCache
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Sets the layout's font to the given \a font. The layout is     invalidated and must be laid out again.      \sa font() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QTextLayout
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|d
operator|->
name|fnt
operator|=
name|font
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RAWFONT
name|d
operator|->
name|useRawFont
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|resetFontEngineCache
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current font that is used for the layout, or a default     font if none is set.      \sa setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QTextLayout
operator|::
name|font
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the layout's text to the given \a string. The layout is     invalidated and must be laid out again.      Notice that when using this QTextLayout as part of a QTextDocument this     method will have no effect.      \sa text() */
end_comment
begin_function
DECL|function|setText
name|void
name|QTextLayout
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|d
operator|->
name|invalidate
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearLineData
argument_list|()
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|string
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the layout's text.      \sa setText() */
end_comment
begin_function
DECL|function|text
name|QString
name|QTextLayout
operator|::
name|text
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the text option structure that controls the layout process to the     given \a option.      \sa textOption() */
end_comment
begin_function
DECL|function|setTextOption
name|void
name|QTextLayout
operator|::
name|setTextOption
parameter_list|(
specifier|const
name|QTextOption
modifier|&
name|option
parameter_list|)
block|{
name|d
operator|->
name|option
operator|=
name|option
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current text option used to control the layout process.      \sa setTextOption() */
end_comment
begin_function
DECL|function|textOption
specifier|const
name|QTextOption
modifier|&
name|QTextLayout
operator|::
name|textOption
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|option
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a position and \a text of the area in the layout that is     processed before editing occurs. The layout is     invalidated and must be laid out again.      \sa preeditAreaPosition(), preeditAreaText() */
end_comment
begin_function
DECL|function|setPreeditArea
name|void
name|QTextLayout
operator|::
name|setPreeditArea
parameter_list|(
name|int
name|position
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|preeditAreaPosition
argument_list|()
operator|==
name|position
operator|&&
name|d
operator|->
name|preeditAreaText
argument_list|()
operator|==
name|text
condition|)
return|return;
name|d
operator|->
name|setPreeditArea
argument_list|(
name|position
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|block
operator|.
name|docHandle
argument_list|()
condition|)
name|d
operator|->
name|block
operator|.
name|docHandle
argument_list|()
operator|->
name|documentChange
argument_list|(
name|d
operator|->
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|d
operator|->
name|block
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the position of the area in the text layout that will be     processed before editing occurs.      \sa preeditAreaText() */
end_comment
begin_function
DECL|function|preeditAreaPosition
name|int
name|QTextLayout
operator|::
name|preeditAreaPosition
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|preeditAreaPosition
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text that is inserted in the layout before editing occurs.      \sa preeditAreaPosition() */
end_comment
begin_function
DECL|function|preeditAreaText
name|QString
name|QTextLayout
operator|::
name|preeditAreaText
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|preeditAreaText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the additional formats supported by the text layout to \a formatList.     The formats are applied with preedit area text in place.      \sa additionalFormats(), clearAdditionalFormats() */
end_comment
begin_function
DECL|function|setAdditionalFormats
name|void
name|QTextLayout
operator|::
name|setAdditionalFormats
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FormatRange
argument_list|>
modifier|&
name|formatList
parameter_list|)
block|{
name|setFormats
argument_list|(
name|formatList
operator|.
name|toVector
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.6      Sets the additional formats supported by the text layout to \a formats.     The formats are applied with preedit area text in place.      \sa formats(), clearFormats() */
end_comment
begin_function
DECL|function|setFormats
name|void
name|QTextLayout
operator|::
name|setFormats
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|FormatRange
argument_list|>
modifier|&
name|formats
parameter_list|)
block|{
name|d
operator|->
name|setFormats
argument_list|(
name|formats
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|block
operator|.
name|docHandle
argument_list|()
condition|)
name|d
operator|->
name|block
operator|.
name|docHandle
argument_list|()
operator|->
name|documentChange
argument_list|(
name|d
operator|->
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|d
operator|->
name|block
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of additional formats supported by the text layout.      \sa setAdditionalFormats(), clearAdditionalFormats() */
end_comment
begin_function
DECL|function|additionalFormats
name|QList
argument_list|<
name|QTextLayout
operator|::
name|FormatRange
argument_list|>
name|QTextLayout
operator|::
name|additionalFormats
parameter_list|()
specifier|const
block|{
return|return
name|formats
argument_list|()
operator|.
name|toList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.6      Returns the list of additional formats supported by the text layout.      \sa setFormats(), clearFormats() */
end_comment
begin_function
DECL|function|formats
name|QVector
argument_list|<
name|QTextLayout
operator|::
name|FormatRange
argument_list|>
name|QTextLayout
operator|::
name|formats
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|formats
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the list of additional formats supported by the text layout.      \sa additionalFormats(), setAdditionalFormats() */
end_comment
begin_function
DECL|function|clearAdditionalFormats
name|void
name|QTextLayout
operator|::
name|clearAdditionalFormats
parameter_list|()
block|{
name|clearFormats
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.6      Clears the list of additional formats supported by the text layout.      \sa formats(), setFormats() */
end_comment
begin_function
DECL|function|clearFormats
name|void
name|QTextLayout
operator|::
name|clearFormats
parameter_list|()
block|{
name|setFormats
argument_list|(
name|QVector
argument_list|<
name|FormatRange
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Enables caching of the complete layout information if \a enable is     true; otherwise disables layout caching. Usually     QTextLayout throws most of the layouting information away after a     call to endLayout() to reduce memory consumption. If you however     want to draw the laid out text directly afterwards enabling caching     might speed up drawing significantly.      \sa cacheEnabled() */
end_comment
begin_function
DECL|function|setCacheEnabled
name|void
name|QTextLayout
operator|::
name|setCacheEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|d
operator|->
name|cacheGlyphs
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the complete layout information is cached; otherwise     returns \c false.      \sa setCacheEnabled() */
end_comment
begin_function
DECL|function|cacheEnabled
name|bool
name|QTextLayout
operator|::
name|cacheEnabled
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|cacheGlyphs
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the visual cursor movement style to the given \a style. If the     QTextLayout is backed by a document, you can ignore this and use the option     in QTextDocument, this option is for widgets like QLineEdit or custom     widgets without a QTextDocument. Default value is Qt::LogicalMoveStyle.      \sa cursorMoveStyle() */
end_comment
begin_function
DECL|function|setCursorMoveStyle
name|void
name|QTextLayout
operator|::
name|setCursorMoveStyle
parameter_list|(
name|Qt
operator|::
name|CursorMoveStyle
name|style
parameter_list|)
block|{
name|d
operator|->
name|visualMovement
operator|=
name|style
operator|==
name|Qt
operator|::
name|VisualMoveStyle
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     The cursor movement style of this QTextLayout. The default is     Qt::LogicalMoveStyle.      \sa setCursorMoveStyle() */
end_comment
begin_function
DECL|function|cursorMoveStyle
name|Qt
operator|::
name|CursorMoveStyle
name|QTextLayout
operator|::
name|cursorMoveStyle
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|visualMovement
condition|?
name|Qt
operator|::
name|VisualMoveStyle
else|:
name|Qt
operator|::
name|LogicalMoveStyle
return|;
block|}
end_function
begin_comment
comment|/*!     Begins the layout process.      \sa endLayout() */
end_comment
begin_function
DECL|function|beginLayout
name|void
name|QTextLayout
operator|::
name|beginLayout
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|d
operator|->
name|layoutData
operator|&&
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|==
name|QTextEngine
operator|::
name|InLayout
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextLayout::beginLayout: Called while already doing layout"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|d
operator|->
name|invalidate
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearLineData
argument_list|()
expr_stmt|;
name|d
operator|->
name|itemize
argument_list|()
expr_stmt|;
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|=
name|QTextEngine
operator|::
name|InLayout
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ends the layout process.      \sa beginLayout() */
end_comment
begin_function
DECL|function|endLayout
name|void
name|QTextLayout
operator|::
name|endLayout
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|d
operator|->
name|layoutData
operator|||
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|==
name|QTextEngine
operator|::
name|LayoutEmpty
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextLayout::endLayout: Called without beginLayout()"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|int
name|l
init|=
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|&&
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|length
operator|<
literal|0
condition|)
block|{
name|QTextLine
argument_list|(
name|l
operator|-
literal|1
argument_list|,
name|d
argument_list|)
operator|.
name|setNumColumns
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|=
name|QTextEngine
operator|::
name|LayoutEmpty
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cacheGlyphs
condition|)
name|d
operator|->
name|freeMemory
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Clears the line information in the layout. After having called     this function, lineCount() returns 0. */
end_comment
begin_function
DECL|function|clearLayout
name|void
name|QTextLayout
operator|::
name|clearLayout
parameter_list|()
block|{
name|d
operator|->
name|clearLineData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the next valid cursor position after \a oldPos that     respects the given cursor \a mode.     Returns value of \a oldPos, if \a oldPos is not a valid cursor position.      \sa isValidCursorPosition(), previousCursorPosition() */
end_comment
begin_function
DECL|function|nextCursorPosition
name|int
name|QTextLayout
operator|::
name|nextCursorPosition
parameter_list|(
name|int
name|oldPos
parameter_list|,
name|CursorMode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QCharAttributes
modifier|*
name|attributes
init|=
name|d
operator|->
name|attributes
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|block
operator|.
name|isValid
argument_list|()
condition|?
name|d
operator|->
name|block
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|len
operator|<=
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attributes
operator|||
name|oldPos
operator|<
literal|0
operator|||
name|oldPos
operator|>=
name|len
condition|)
return|return
name|oldPos
return|;
if|if
condition|(
name|mode
operator|==
name|SkipCharacters
condition|)
block|{
name|oldPos
operator|++
expr_stmt|;
while|while
condition|(
name|oldPos
operator|<
name|len
operator|&&
operator|!
name|attributes
index|[
name|oldPos
index|]
operator|.
name|graphemeBoundary
condition|)
name|oldPos
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldPos
operator|<
name|len
operator|&&
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
argument_list|)
condition|)
block|{
name|oldPos
operator|++
expr_stmt|;
while|while
condition|(
name|oldPos
operator|<
name|len
operator|&&
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
argument_list|)
condition|)
name|oldPos
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|oldPos
operator|<
name|len
operator|&&
operator|!
name|attributes
index|[
name|oldPos
index|]
operator|.
name|whiteSpace
operator|&&
operator|!
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
argument_list|)
condition|)
name|oldPos
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|oldPos
operator|<
name|len
operator|&&
name|attributes
index|[
name|oldPos
index|]
operator|.
name|whiteSpace
condition|)
name|oldPos
operator|++
expr_stmt|;
block|}
return|return
name|oldPos
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the first valid cursor position before \a oldPos that     respects the given cursor \a mode.     Returns value of \a oldPos, if \a oldPos is not a valid cursor position.      \sa isValidCursorPosition(), nextCursorPosition() */
end_comment
begin_function
DECL|function|previousCursorPosition
name|int
name|QTextLayout
operator|::
name|previousCursorPosition
parameter_list|(
name|int
name|oldPos
parameter_list|,
name|CursorMode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QCharAttributes
modifier|*
name|attributes
init|=
name|d
operator|->
name|attributes
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|block
operator|.
name|isValid
argument_list|()
condition|?
name|d
operator|->
name|block
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|len
operator|<=
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attributes
operator|||
name|oldPos
operator|<=
literal|0
operator|||
name|oldPos
operator|>
name|len
condition|)
return|return
name|oldPos
return|;
if|if
condition|(
name|mode
operator|==
name|SkipCharacters
condition|)
block|{
name|oldPos
operator|--
expr_stmt|;
while|while
condition|(
name|oldPos
operator|&&
operator|!
name|attributes
index|[
name|oldPos
index|]
operator|.
name|graphemeBoundary
condition|)
name|oldPos
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|oldPos
operator|>
literal|0
operator|&&
name|attributes
index|[
name|oldPos
operator|-
literal|1
index|]
operator|.
name|whiteSpace
condition|)
name|oldPos
operator|--
expr_stmt|;
if|if
condition|(
name|oldPos
operator|&&
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
operator|-
literal|1
argument_list|)
condition|)
block|{
name|oldPos
operator|--
expr_stmt|;
while|while
condition|(
name|oldPos
operator|&&
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
operator|-
literal|1
argument_list|)
condition|)
name|oldPos
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|oldPos
operator|>
literal|0
operator|&&
operator|!
name|attributes
index|[
name|oldPos
operator|-
literal|1
index|]
operator|.
name|whiteSpace
operator|&&
operator|!
name|d
operator|->
name|atWordSeparator
argument_list|(
name|oldPos
operator|-
literal|1
argument_list|)
condition|)
name|oldPos
operator|--
expr_stmt|;
block|}
block|}
return|return
name|oldPos
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the cursor position to the right of \a oldPos, next to it.     It's dependent on the visual position of characters, after bi-directional     reordering.      \sa leftCursorPosition(), nextCursorPosition() */
end_comment
begin_function
DECL|function|rightCursorPosition
name|int
name|QTextLayout
operator|::
name|rightCursorPosition
parameter_list|(
name|int
name|oldPos
parameter_list|)
specifier|const
block|{
name|int
name|newPos
init|=
name|d
operator|->
name|positionAfterVisualMovement
argument_list|(
name|oldPos
argument_list|,
name|QTextCursor
operator|::
name|Right
argument_list|)
decl_stmt|;
comment|//    qDebug("%d -> %d", oldPos, newPos);
return|return
name|newPos
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the cursor position to the left of \a oldPos, next to it.     It's dependent on the visual position of characters, after bi-directional     reordering.      \sa rightCursorPosition(), previousCursorPosition() */
end_comment
begin_function
DECL|function|leftCursorPosition
name|int
name|QTextLayout
operator|::
name|leftCursorPosition
parameter_list|(
name|int
name|oldPos
parameter_list|)
specifier|const
block|{
name|int
name|newPos
init|=
name|d
operator|->
name|positionAfterVisualMovement
argument_list|(
name|oldPos
argument_list|,
name|QTextCursor
operator|::
name|Left
argument_list|)
decl_stmt|;
comment|//    qDebug("%d -> %d", oldPos, newPos);
return|return
name|newPos
return|;
block|}
end_function
begin_comment
comment|/*!/     Returns \c true if position \a pos is a valid cursor position.      In a Unicode context some positions in the text are not valid     cursor positions, because the position is inside a Unicode     surrogate or a grapheme cluster.      A grapheme cluster is a sequence of two or more Unicode characters     that form one indivisible entity on the screen. For example the     latin character `\unicode{0xC4}' can be represented in Unicode by two     characters, `A' (0x41), and the combining diaresis (0x308). A text     cursor can only validly be positioned before or after these two     characters, never between them since that wouldn't make sense. In     indic languages every syllable forms a grapheme cluster. */
end_comment
begin_function
DECL|function|isValidCursorPosition
name|bool
name|QTextLayout
operator|::
name|isValidCursorPosition
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
specifier|const
name|QCharAttributes
modifier|*
name|attributes
init|=
name|d
operator|->
name|attributes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attributes
operator|||
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
operator|(
name|int
operator|)
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|attributes
index|[
name|pos
index|]
operator|.
name|graphemeBoundary
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a new text line to be laid out if there is text to be     inserted into the layout; otherwise returns an invalid text line.      The text layout creates a new line object that starts after the     last line in the layout, or at the beginning if the layout is empty.     The layout maintains an internal cursor, and each line is filled     with text from the cursor position onwards when the     QTextLine::setLineWidth() function is called.      Once QTextLine::setLineWidth() is called, a new line can be created and     filled with text. Repeating this process will lay out the whole block     of text contained in the QTextLayout. If there is no text left to be     inserted into the layout, the QTextLine returned will not be valid     (isValid() will return false). */
end_comment
begin_function
DECL|function|createLine
name|QTextLine
name|QTextLayout
operator|::
name|createLine
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|d
operator|->
name|layoutData
operator|||
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|==
name|QTextEngine
operator|::
name|LayoutEmpty
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextLayout::createLine: Called without layouting"
argument_list|)
expr_stmt|;
return|return
name|QTextLine
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|layoutData
operator|->
name|layoutState
operator|==
name|QTextEngine
operator|::
name|LayoutFailed
condition|)
return|return
name|QTextLine
argument_list|()
return|;
name|int
name|l
init|=
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|&&
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|length
operator|<
literal|0
condition|)
block|{
name|QTextLine
argument_list|(
name|l
operator|-
literal|1
argument_list|,
name|d
argument_list|)
operator|.
name|setNumColumns
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
name|int
name|from
init|=
name|l
operator|>
literal|0
condition|?
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|from
operator|+
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|length
operator|+
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|trailingSpaces
else|:
literal|0
decl_stmt|;
name|int
name|strlen
init|=
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|&&
name|from
operator|>=
name|strlen
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|.
name|length
operator|||
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|at
argument_list|(
name|strlen
operator|-
literal|1
argument_list|)
operator|!=
name|QChar
operator|::
name|LineSeparator
condition|)
return|return
name|QTextLine
argument_list|()
return|;
block|}
name|QScriptLine
name|line
decl_stmt|;
name|line
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|line
operator|.
name|length
operator|=
operator|-
literal|1
expr_stmt|;
name|line
operator|.
name|justified
operator|=
literal|false
expr_stmt|;
name|line
operator|.
name|gridfitted
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|lines
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|QTextLine
argument_list|(
name|l
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of lines in this text layout.      \sa lineAt() */
end_comment
begin_function
DECL|function|lineCount
name|int
name|QTextLayout
operator|::
name|lineCount
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the \a{i}-th line of text in this text layout.      \sa lineCount(), lineForTextPosition() */
end_comment
begin_function
DECL|function|lineAt
name|QTextLine
name|QTextLayout
operator|::
name|lineAt
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
return|return
name|i
operator|<
name|lineCount
argument_list|()
condition|?
name|QTextLine
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
else|:
name|QTextLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line that contains the cursor position specified by \a pos.      \sa isValidCursorPosition(), lineAt() */
end_comment
begin_function
DECL|function|lineForTextPosition
name|QTextLine
name|QTextLayout
operator|::
name|lineForTextPosition
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|int
name|lineNum
init|=
name|d
operator|->
name|lineNumberForTextPosition
argument_list|(
name|pos
argument_list|)
decl_stmt|;
return|return
name|lineNum
operator|>=
literal|0
condition|?
name|lineAt
argument_list|(
name|lineNum
argument_list|)
else|:
name|QTextLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      The global position of the layout. This is independent of the     bounding rectangle and of the layout process.      \sa setPosition() */
end_comment
begin_function
DECL|function|position
name|QPointF
name|QTextLayout
operator|::
name|position
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     Moves the text layout to point \a p.      \sa position() */
end_comment
begin_function
DECL|function|setPosition
name|void
name|QTextLayout
operator|::
name|setPosition
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
name|d
operator|->
name|position
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     The smallest rectangle that contains all the lines in the layout. */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QTextLayout
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|lines
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QRectF
argument_list|()
return|;
name|QFixed
name|xmax
decl_stmt|,
name|ymax
decl_stmt|;
name|QFixed
name|xmin
init|=
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
decl_stmt|;
name|QFixed
name|ymin
init|=
name|d
operator|->
name|lines
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QScriptLine
modifier|&
name|si
init|=
name|d
operator|->
name|lines
index|[
name|i
index|]
decl_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|si
operator|.
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|si
operator|.
name|y
argument_list|)
expr_stmt|;
name|QFixed
name|lineWidth
init|=
name|si
operator|.
name|width
operator|<
name|QFIXED_MAX
condition|?
name|qMax
argument_list|(
name|si
operator|.
name|width
argument_list|,
name|si
operator|.
name|textWidth
argument_list|)
else|:
name|si
operator|.
name|textWidth
decl_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|si
operator|.
name|x
operator|+
name|lineWidth
argument_list|)
expr_stmt|;
comment|// ### shouldn't the ascent be used in ymin???
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|si
operator|.
name|y
operator|+
name|si
operator|.
name|height
argument_list|()
operator|.
name|ceil
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|QRectF
argument_list|(
name|xmin
operator|.
name|toReal
argument_list|()
argument_list|,
name|ymin
operator|.
name|toReal
argument_list|()
argument_list|,
operator|(
name|xmax
operator|-
name|xmin
operator|)
operator|.
name|toReal
argument_list|()
argument_list|,
operator|(
name|ymax
operator|-
name|ymin
operator|)
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     The minimum width the layout needs. This is the width of the     layout's smallest non-breakable substring.      \warning This function only returns a valid value after the layout     has been done.      \sa maximumWidth() */
end_comment
begin_function
DECL|function|minimumWidth
name|qreal
name|QTextLayout
operator|::
name|minimumWidth
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|minWidth
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     The maximum width the layout could expand to; this is essentially     the width of the entire text.      \warning This function only returns a valid value after the layout     has been done.      \sa minimumWidth() */
end_comment
begin_function
DECL|function|maximumWidth
name|qreal
name|QTextLayout
operator|::
name|maximumWidth
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|maxWidth
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setFlags
name|void
name|QTextLayout
operator|::
name|setFlags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|TextJustificationForced
condition|)
block|{
name|d
operator|->
name|option
operator|.
name|setAlignment
argument_list|(
name|Qt
operator|::
name|AlignJustify
argument_list|)
expr_stmt|;
name|d
operator|->
name|forceJustification
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|Qt
operator|::
name|TextForceLeftToRight
operator||
name|Qt
operator|::
name|TextForceRightToLeft
operator|)
condition|)
block|{
name|d
operator|->
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|option
operator|.
name|setTextDirection
argument_list|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|TextForceLeftToRight
operator|)
condition|?
name|Qt
operator|::
name|LeftToRight
else|:
name|Qt
operator|::
name|RightToLeft
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addSelectedRegionsToPath
specifier|static
name|void
name|addSelectedRegionsToPath
parameter_list|(
name|QTextEngine
modifier|*
name|eng
parameter_list|,
name|int
name|lineNumber
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|QTextLayout
operator|::
name|FormatRange
modifier|*
name|selection
parameter_list|,
name|QPainterPath
modifier|*
name|region
parameter_list|,
name|QRectF
name|boundingRect
parameter_list|)
block|{
specifier|const
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|lineNumber
index|]
decl_stmt|;
name|QTextLineItemIterator
name|iterator
argument_list|(
name|eng
argument_list|,
name|lineNumber
argument_list|,
name|pos
argument_list|,
name|selection
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|selectionY
init|=
name|pos
operator|.
name|y
argument_list|()
operator|+
name|line
operator|.
name|y
operator|.
name|toReal
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|lineHeight
init|=
name|line
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|QFixed
name|lastSelectionX
init|=
name|iterator
operator|.
name|x
decl_stmt|;
name|QFixed
name|lastSelectionWidth
decl_stmt|;
while|while
condition|(
operator|!
name|iterator
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|QFixed
name|selectionX
decl_stmt|,
name|selectionWidth
decl_stmt|;
if|if
condition|(
name|iterator
operator|.
name|getSelectionBounds
argument_list|(
operator|&
name|selectionX
argument_list|,
operator|&
name|selectionWidth
argument_list|)
condition|)
block|{
if|if
condition|(
name|selectionX
operator|==
name|lastSelectionX
operator|+
name|lastSelectionWidth
condition|)
block|{
name|lastSelectionWidth
operator|+=
name|selectionWidth
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lastSelectionWidth
operator|>
literal|0
condition|)
block|{
name|QRectF
name|rect
init|=
name|boundingRect
operator|&
name|QRectF
argument_list|(
name|lastSelectionX
operator|.
name|toReal
argument_list|()
argument_list|,
name|selectionY
argument_list|,
name|lastSelectionWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|lineHeight
argument_list|)
decl_stmt|;
name|rect
operator|.
name|moveLeft
argument_list|(
name|qFloor
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|moveTop
argument_list|(
name|qFloor
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|->
name|addRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|lastSelectionX
operator|=
name|selectionX
expr_stmt|;
name|lastSelectionWidth
operator|=
name|selectionWidth
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastSelectionWidth
operator|>
literal|0
condition|)
block|{
name|QRectF
name|rect
init|=
name|boundingRect
operator|&
name|QRectF
argument_list|(
name|lastSelectionX
operator|.
name|toReal
argument_list|()
argument_list|,
name|selectionY
argument_list|,
name|lastSelectionWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|lineHeight
argument_list|)
decl_stmt|;
name|rect
operator|.
name|moveLeft
argument_list|(
name|qFloor
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|moveTop
argument_list|(
name|qFloor
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|->
name|addRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clipIfValid
specifier|static
specifier|inline
name|QRectF
name|clipIfValid
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|clip
parameter_list|)
block|{
return|return
name|clip
operator|.
name|isValid
argument_list|()
condition|?
operator|(
name|rect
operator|&
name|clip
operator|)
else|:
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the glyph indexes and positions for all glyphs corresponding to the \a length characters     starting at the position \a from in this QTextLayout. This is an expensive function, and should     not be called in a time sensitive context.      If \a from is less than zero, then the glyph run will begin at the first character in the     layout. If \a length is less than zero, it will span the entire string from the start position.      \since 4.8      \sa draw(), QPainter::drawGlyphRun() */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_RAWFONT
argument_list|)
end_if
begin_function
DECL|function|glyphRuns
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|QTextLayout
operator|::
name|glyphRuns
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|length
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|length
operator|=
name|text
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
name|QHash
argument_list|<
name|QPair
argument_list|<
name|QFontEngine
modifier|*
argument_list|,
name|int
argument_list|>
argument_list|,
name|QGlyphRun
argument_list|>
name|glyphRunHash
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|lines
index|[
name|i
index|]
operator|.
name|from
operator|>
name|from
operator|+
name|length
condition|)
break|break;
elseif|else
if|if
condition|(
name|d
operator|->
name|lines
index|[
name|i
index|]
operator|.
name|from
operator|+
name|d
operator|->
name|lines
index|[
name|i
index|]
operator|.
name|length
operator|>=
name|from
condition|)
block|{
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|glyphRuns
init|=
name|QTextLine
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
operator|.
name|glyphRuns
argument_list|(
name|from
argument_list|,
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|glyphRuns
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|QGlyphRun
modifier|&
name|glyphRun
init|=
name|glyphRuns
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QRawFont
name|rawFont
init|=
name|glyphRun
operator|.
name|rawFont
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|fontEngine
init|=
name|rawFont
operator|.
name|d
operator|->
name|fontEngine
decl_stmt|;
name|QGlyphRun
operator|::
name|GlyphRunFlags
name|flags
init|=
name|glyphRun
operator|.
name|flags
argument_list|()
decl_stmt|;
name|QPair
argument_list|<
name|QFontEngine
modifier|*
argument_list|,
name|int
argument_list|>
name|key
argument_list|(
name|fontEngine
argument_list|,
name|int
argument_list|(
name|flags
argument_list|)
argument_list|)
decl_stmt|;
comment|// merge the glyph runs using the same font
if|if
condition|(
name|glyphRunHash
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|QGlyphRun
modifier|&
name|oldGlyphRun
init|=
name|glyphRunHash
index|[
name|key
index|]
decl_stmt|;
name|QVector
argument_list|<
name|quint32
argument_list|>
name|indexes
init|=
name|oldGlyphRun
operator|.
name|glyphIndexes
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|positions
init|=
name|oldGlyphRun
operator|.
name|positions
argument_list|()
decl_stmt|;
name|indexes
operator|+=
name|glyphRun
operator|.
name|glyphIndexes
argument_list|()
expr_stmt|;
name|positions
operator|+=
name|glyphRun
operator|.
name|positions
argument_list|()
expr_stmt|;
name|oldGlyphRun
operator|.
name|setGlyphIndexes
argument_list|(
name|indexes
argument_list|)
expr_stmt|;
name|oldGlyphRun
operator|.
name|setPositions
argument_list|(
name|positions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glyphRunHash
index|[
name|key
index|]
operator|=
name|glyphRun
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|glyphRunHash
operator|.
name|values
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_RAWFONT
end_comment
begin_comment
comment|/*!     Draws the whole layout on the painter \a p at the position specified by \a pos.     The rendered layout includes the given \a selections and is clipped within     the rectangle specified by \a clip. */
end_comment
begin_function
DECL|function|draw
name|void
name|QTextLayout
operator|::
name|draw
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|FormatRange
argument_list|>
modifier|&
name|selections
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|clip
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|lines
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|layoutData
condition|)
name|d
operator|->
name|itemize
argument_list|()
expr_stmt|;
name|QPointF
name|position
init|=
name|pos
operator|+
name|d
operator|->
name|position
decl_stmt|;
name|QFixed
name|clipy
init|=
operator|(
name|INT_MIN
operator|/
literal|256
operator|)
decl_stmt|;
name|QFixed
name|clipe
init|=
operator|(
name|INT_MAX
operator|/
literal|256
operator|)
decl_stmt|;
if|if
condition|(
name|clip
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|clipy
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|clip
operator|.
name|y
argument_list|()
operator|-
name|position
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|clipe
operator|=
name|clipy
operator|+
name|QFixed
operator|::
name|fromReal
argument_list|(
name|clip
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|firstLine
init|=
literal|0
decl_stmt|;
name|int
name|lastLine
init|=
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextLine
name|l
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|d
operator|->
name|lines
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sl
operator|.
name|y
operator|>
name|clipe
condition|)
block|{
name|lastLine
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sl
operator|.
name|y
operator|+
name|sl
operator|.
name|height
argument_list|()
operator|)
operator|<
name|clipy
condition|)
block|{
name|firstLine
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
block|}
name|QPainterPath
name|excludedRegion
decl_stmt|;
name|QPainterPath
name|textDoneRegion
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selections
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|FormatRange
name|selection
init|=
name|selections
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QBrush
name|bg
init|=
name|selection
operator|.
name|format
operator|.
name|background
argument_list|()
decl_stmt|;
name|QPainterPath
name|region
decl_stmt|;
name|region
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|line
init|=
name|firstLine
init|;
name|line
operator|<
name|lastLine
condition|;
operator|++
name|line
control|)
block|{
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|d
operator|->
name|lines
index|[
name|line
index|]
decl_stmt|;
name|QTextLine
name|tl
argument_list|(
name|line
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QRectF
name|lineRect
argument_list|(
name|tl
operator|.
name|naturalTextRect
argument_list|()
argument_list|)
decl_stmt|;
name|lineRect
operator|.
name|translate
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|lineRect
operator|.
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|leadingSpaceWidth
argument_list|(
name|sl
argument_list|)
operator|.
name|toReal
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bool
name|isLastLineInBlock
init|=
operator|(
name|line
operator|==
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|sl_length
init|=
name|sl
operator|.
name|length
operator|+
operator|(
name|isLastLineInBlock
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|// the infamous newline
if|if
condition|(
name|sl
operator|.
name|from
operator|>
name|selection
operator|.
name|start
operator|+
name|selection
operator|.
name|length
operator|||
name|sl
operator|.
name|from
operator|+
name|sl_length
operator|<=
name|selection
operator|.
name|start
condition|)
continue|continue;
comment|// no actual intersection
specifier|const
name|bool
name|selectionStartInLine
init|=
name|sl
operator|.
name|from
operator|<=
name|selection
operator|.
name|start
decl_stmt|;
specifier|const
name|bool
name|selectionEndInLine
init|=
name|selection
operator|.
name|start
operator|+
name|selection
operator|.
name|length
operator|<
name|sl
operator|.
name|from
operator|+
name|sl_length
decl_stmt|;
if|if
condition|(
name|sl
operator|.
name|length
operator|&&
operator|(
name|selectionStartInLine
operator|||
name|selectionEndInLine
operator|)
condition|)
block|{
name|addSelectedRegionsToPath
argument_list|(
name|d
argument_list|,
name|line
argument_list|,
name|position
argument_list|,
operator|&
name|selection
argument_list|,
operator|&
name|region
argument_list|,
name|clipIfValid
argument_list|(
name|lineRect
argument_list|,
name|clip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|region
operator|.
name|addRect
argument_list|(
name|clipIfValid
argument_list|(
name|lineRect
argument_list|,
name|clip
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selection
operator|.
name|format
operator|.
name|boolProperty
argument_list|(
name|QTextFormat
operator|::
name|FullWidthSelection
argument_list|)
condition|)
block|{
name|QRectF
name|fullLineRect
argument_list|(
name|tl
operator|.
name|rect
argument_list|()
argument_list|)
decl_stmt|;
name|fullLineRect
operator|.
name|translate
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|fullLineRect
operator|.
name|setRight
argument_list|(
name|QFIXED_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|selectionEndInLine
condition|)
name|region
operator|.
name|addRect
argument_list|(
name|clipIfValid
argument_list|(
name|QRectF
argument_list|(
name|lineRect
operator|.
name|topRight
argument_list|()
argument_list|,
name|fullLineRect
operator|.
name|bottomRight
argument_list|()
argument_list|)
argument_list|,
name|clip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|selectionStartInLine
condition|)
name|region
operator|.
name|addRect
argument_list|(
name|clipIfValid
argument_list|(
name|QRectF
argument_list|(
name|fullLineRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|lineRect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
argument_list|,
name|clip
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|selectionEndInLine
operator|&&
name|isLastLineInBlock
operator|&&
operator|!
operator|(
name|d
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowLineAndParagraphSeparators
operator|)
condition|)
block|{
name|region
operator|.
name|addRect
argument_list|(
name|clipIfValid
argument_list|(
name|QRectF
argument_list|(
name|lineRect
operator|.
name|right
argument_list|()
argument_list|,
name|lineRect
operator|.
name|top
argument_list|()
argument_list|,
name|lineRect
operator|.
name|height
argument_list|()
operator|/
literal|4
argument_list|,
name|lineRect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|clip
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
specifier|const
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
specifier|const
name|QBrush
name|oldBrush
init|=
name|p
operator|->
name|brush
argument_list|()
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|selection
operator|.
name|format
operator|.
name|penProperty
argument_list|(
name|QTextFormat
operator|::
name|OutlinePen
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|selection
operator|.
name|format
operator|.
name|brushProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPath
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasText
init|=
operator|(
name|selection
operator|.
name|format
operator|.
name|foreground
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|)
decl_stmt|;
name|bool
name|hasBackground
init|=
operator|(
name|selection
operator|.
name|format
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|)
decl_stmt|;
if|if
condition|(
name|hasBackground
condition|)
block|{
name|selection
operator|.
name|format
operator|.
name|setProperty
argument_list|(
name|ObjectSelectionBrush
argument_list|,
name|selection
operator|.
name|format
operator|.
name|property
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
argument_list|)
expr_stmt|;
comment|// don't just clear the property, set an empty brush that overrides a potential
comment|// background brush specified in the text
name|selection
operator|.
name|format
operator|.
name|setProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|,
name|QBrush
argument_list|()
argument_list|)
expr_stmt|;
name|selection
operator|.
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|OutlinePen
argument_list|)
expr_stmt|;
block|}
name|selection
operator|.
name|format
operator|.
name|setProperty
argument_list|(
name|SuppressText
argument_list|,
operator|!
name|hasText
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasText
operator|&&
operator|!
name|hasBackground
operator|&&
operator|!
operator|(
name|textDoneRegion
operator|&
name|region
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|p
operator|->
name|setClipPath
argument_list|(
name|region
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|line
init|=
name|firstLine
init|;
name|line
operator|<
name|lastLine
condition|;
operator|++
name|line
control|)
block|{
name|QTextLine
name|l
argument_list|(
name|line
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|l
operator|.
name|draw
argument_list|(
name|p
argument_list|,
name|position
argument_list|,
operator|&
name|selection
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasText
condition|)
block|{
name|textDoneRegion
operator|+=
name|region
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hasBackground
condition|)
name|textDoneRegion
operator|-=
name|region
expr_stmt|;
block|}
name|excludedRegion
operator|+=
name|region
expr_stmt|;
block|}
name|QPainterPath
name|needsTextButNoBackground
init|=
name|excludedRegion
operator|-
name|textDoneRegion
decl_stmt|;
if|if
condition|(
operator|!
name|needsTextButNoBackground
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|p
operator|->
name|setClipPath
argument_list|(
name|needsTextButNoBackground
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
name|FormatRange
name|selection
decl_stmt|;
name|selection
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|selection
operator|.
name|length
operator|=
name|INT_MAX
expr_stmt|;
name|selection
operator|.
name|format
operator|.
name|setProperty
argument_list|(
name|SuppressBackground
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|line
init|=
name|firstLine
init|;
name|line
operator|<
name|lastLine
condition|;
operator|++
name|line
control|)
block|{
name|QTextLine
name|l
argument_list|(
name|line
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|l
operator|.
name|draw
argument_list|(
name|p
argument_list|,
name|position
argument_list|,
operator|&
name|selection
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|excludedRegion
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|QRectF
name|br
init|=
name|boundingRect
argument_list|()
operator|.
name|translated
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|br
operator|.
name|setRight
argument_list|(
name|QFIXED_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clip
operator|.
name|isNull
argument_list|()
condition|)
name|br
operator|=
name|br
operator|.
name|intersected
argument_list|(
name|clip
argument_list|)
expr_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|path
operator|-=
name|excludedRegion
expr_stmt|;
name|p
operator|->
name|setClipPath
argument_list|(
name|path
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|firstLine
init|;
name|i
operator|<
name|lastLine
condition|;
operator|++
name|i
control|)
block|{
name|QTextLine
name|l
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|l
operator|.
name|draw
argument_list|(
name|p
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|excludedRegion
operator|.
name|isEmpty
argument_list|()
condition|)
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cacheGlyphs
condition|)
name|d
operator|->
name|freeMemory
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextLayout::drawCursor(QPainter *painter, const QPointF&position, int cursorPosition) const     \overload      Draws a text cursor with the current pen at the given \a position using the     \a painter specified.     The corresponding position within the text is specified by \a cursorPosition. */
end_comment
begin_function
DECL|function|drawCursor
name|void
name|QTextLayout
operator|::
name|drawCursor
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|int
name|cursorPosition
parameter_list|)
specifier|const
block|{
name|drawCursor
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|cursorPosition
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextLayout::drawCursor(QPainter *painter, const QPointF&position, int cursorPosition, int width) const      Draws a text cursor with the current pen and the specified \a width at the given \a position using the     \a painter specified.     The corresponding position within the text is specified by \a cursorPosition. */
end_comment
begin_function
DECL|function|drawCursor
name|void
name|QTextLayout
operator|::
name|drawCursor
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|int
name|cursorPosition
parameter_list|,
name|int
name|width
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|lines
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|layoutData
condition|)
name|d
operator|->
name|itemize
argument_list|()
expr_stmt|;
name|QPointF
name|position
init|=
name|pos
operator|+
name|d
operator|->
name|position
decl_stmt|;
name|cursorPosition
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|cursorPosition
argument_list|,
name|d
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|line
init|=
name|d
operator|->
name|lineNumberForTextPosition
argument_list|(
name|cursorPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|<
literal|0
condition|)
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
operator|>=
name|d
operator|->
name|lines
operator|.
name|size
argument_list|()
condition|)
return|return;
name|QTextLine
name|l
argument_list|(
name|line
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|d
operator|->
name|lines
index|[
name|line
index|]
decl_stmt|;
name|qreal
name|x
init|=
name|position
operator|.
name|x
argument_list|()
operator|+
name|l
operator|.
name|cursorToX
argument_list|(
name|cursorPosition
argument_list|)
decl_stmt|;
name|int
name|itm
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|visualCursorMovement
argument_list|()
condition|)
block|{
if|if
condition|(
name|cursorPosition
operator|==
name|sl
operator|.
name|from
operator|+
name|sl
operator|.
name|length
condition|)
name|cursorPosition
operator|--
expr_stmt|;
name|itm
operator|=
name|d
operator|->
name|findItem
argument_list|(
name|cursorPosition
argument_list|)
expr_stmt|;
block|}
else|else
name|itm
operator|=
name|d
operator|->
name|findItem
argument_list|(
name|cursorPosition
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QFixed
name|base
init|=
name|sl
operator|.
name|base
argument_list|()
decl_stmt|;
name|QFixed
name|descent
init|=
name|sl
operator|.
name|descent
decl_stmt|;
name|bool
name|rightToLeft
init|=
name|d
operator|->
name|isRightToLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|itm
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QScriptItem
modifier|&
name|si
init|=
name|d
operator|->
name|layoutData
operator|->
name|items
operator|.
name|at
argument_list|(
name|itm
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|ascent
operator|>
literal|0
condition|)
name|base
operator|=
name|si
operator|.
name|ascent
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|descent
operator|>
literal|0
condition|)
name|descent
operator|=
name|si
operator|.
name|descent
expr_stmt|;
name|rightToLeft
operator|=
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
expr_stmt|;
block|}
name|qreal
name|y
init|=
name|position
operator|.
name|y
argument_list|()
operator|+
operator|(
name|sl
operator|.
name|y
operator|+
name|sl
operator|.
name|base
argument_list|()
operator|-
name|base
operator|)
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|bool
name|toggleAntialiasing
init|=
operator|!
operator|(
name|p
operator|->
name|renderHints
argument_list|()
operator|&
name|QPainter
operator|::
name|Antialiasing
operator|)
operator|&&
operator|(
name|p
operator|->
name|transform
argument_list|()
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|)
decl_stmt|;
if|if
condition|(
name|toggleAntialiasing
condition|)
name|p
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
name|p
operator|->
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|qreal
argument_list|(
name|width
argument_list|)
argument_list|,
operator|(
name|base
operator|+
name|descent
operator|)
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|p
operator|->
name|pen
argument_list|()
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|toggleAntialiasing
condition|)
name|p
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layoutData
operator|->
name|hasBidi
condition|)
block|{
specifier|const
name|int
name|arrow_extent
init|=
literal|4
decl_stmt|;
name|int
name|sign
init|=
name|rightToLeft
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|QLineF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
operator|(
name|sign
operator|*
name|arrow_extent
operator|/
literal|2
operator|)
argument_list|,
name|y
operator|+
name|arrow_extent
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|QLineF
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|arrow_extent
argument_list|,
name|x
operator|+
operator|(
name|sign
operator|*
name|arrow_extent
operator|/
literal|2
operator|)
argument_list|,
name|y
operator|+
name|arrow_extent
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function
begin_comment
comment|/*!     \class QTextLine     \reentrant      \brief The QTextLine class represents a line of text inside a QTextLayout.     \inmodule QtGui      \ingroup richtext-processing      A text line is usually created by QTextLayout::createLine().      After being created, the line can be filled using the setLineWidth()     or setNumColumns() functions. A line has a number of attributes including the     rectangle it occupies, rect(), its coordinates, x() and y(), its     textLength(), width() and naturalTextWidth(), and its ascent() and descent()     relative to the text. The position of the cursor in terms of the     line is available from cursorToX() and its inverse from     xToCursor(). A line can be moved with setPosition(). */
end_comment
begin_comment
comment|/*!     \enum QTextLine::Edge      \value Leading     \value Trailing */
end_comment
begin_comment
comment|/*!     \enum QTextLine::CursorPosition      \value CursorBetweenCharacters     \value CursorOnCharacter */
end_comment
begin_comment
comment|/*!     \fn QTextLine::QTextLine(int line, QTextEngine *e)     \internal      Constructs a new text line using the line at position \a line in     the text engine \a e. */
end_comment
begin_comment
comment|/*!     \fn QTextLine::QTextLine()      Creates an invalid line. */
end_comment
begin_comment
comment|/*!     \fn bool QTextLine::isValid() const      Returns \c true if this text line is valid; otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn int QTextLine::lineNumber() const      Returns the position of the line in the text engine. */
end_comment
begin_comment
comment|/*!     Returns the line's bounding rectangle.      \sa x(), y(), textLength(), width() */
end_comment
begin_function
DECL|function|rect
name|QRectF
name|QTextLine
operator|::
name|rect
parameter_list|()
specifier|const
block|{
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|sl
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|sl
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|sl
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|sl
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the rectangle covered by the line. */
end_comment
begin_function
DECL|function|naturalTextRect
name|QRectF
name|QTextLine
operator|::
name|naturalTextRect
parameter_list|()
specifier|const
block|{
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|QFixed
name|x
init|=
name|sl
operator|.
name|x
operator|+
name|eng
operator|->
name|alignLine
argument_list|(
name|sl
argument_list|)
decl_stmt|;
name|QFixed
name|width
init|=
name|sl
operator|.
name|textWidth
decl_stmt|;
if|if
condition|(
name|sl
operator|.
name|justified
condition|)
name|width
operator|=
name|sl
operator|.
name|width
expr_stmt|;
return|return
name|QRectF
argument_list|(
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|sl
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|sl
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's x position.      \sa rect(), y(), textLength(), width() */
end_comment
begin_function
DECL|function|x
name|qreal
name|QTextLine
operator|::
name|x
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|x
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's y position.      \sa x(), rect(), textLength(), width() */
end_comment
begin_function
DECL|function|y
name|qreal
name|QTextLine
operator|::
name|y
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|y
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's width as specified by the layout() function.      \sa naturalTextWidth(), x(), y(), textLength(), rect() */
end_comment
begin_function
DECL|function|width
name|qreal
name|QTextLine
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|width
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's ascent.      \sa descent(), height() */
end_comment
begin_function
DECL|function|ascent
name|qreal
name|QTextLine
operator|::
name|ascent
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's descent.      \sa ascent(), height() */
end_comment
begin_function
DECL|function|descent
name|qreal
name|QTextLine
operator|::
name|descent
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|descent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's height. This is equal to ascent() + descent()     if leading is not included. If leading is included, this equals to     ascent() + descent() + leading().      \sa ascent(), descent(), leading(), setLeadingIncluded() */
end_comment
begin_function
DECL|function|height
name|qreal
name|QTextLine
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|height
argument_list|()
operator|.
name|ceil
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the line's leading.      \sa ascent(), descent(), height() */
end_comment
begin_function
DECL|function|leading
name|qreal
name|QTextLine
operator|::
name|leading
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|leading
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Includes positive leading into the line's height if \a included is true;     otherwise does not include leading.      By default, leading is not included.      Note that negative leading is ignored, it must be handled     in the code using the text lines by letting the lines overlap.      \sa leadingIncluded()  */
end_comment
begin_function
DECL|function|setLeadingIncluded
name|void
name|QTextLine
operator|::
name|setLeadingIncluded
parameter_list|(
name|bool
name|included
parameter_list|)
block|{
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|leadingIncluded
operator|=
name|included
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns \c true if positive leading is included into the line's height;     otherwise returns \c false.      By default, leading is not included.      \sa setLeadingIncluded() */
end_comment
begin_function
DECL|function|leadingIncluded
name|bool
name|QTextLine
operator|::
name|leadingIncluded
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|leadingIncluded
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the line that is occupied by text. This is     always \<= to width(), and is the minimum width that could be used     by layout() without changing the line break position. */
end_comment
begin_function
DECL|function|naturalTextWidth
name|qreal
name|QTextLine
operator|::
name|naturalTextWidth
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the horizontal advance of the text. The advance of the text     is the distance from its position to the next position at which     text would naturally be drawn.      By adding the advance to the position of the text line and using this     as the position of a second text line, you will be able to position     the two lines side-by-side without gaps in-between. */
end_comment
begin_function
DECL|function|horizontalAdvance
name|qreal
name|QTextLine
operator|::
name|horizontalAdvance
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|textAdvance
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Lays out the line with the given \a width. The line is filled from     its starting position with as many characters as will fit into     the line. In case the text cannot be split at the end of the line,     it will be filled with additional characters to the next whitespace     or end of the text. */
end_comment
begin_function
DECL|function|setLineWidth
name|void
name|QTextLine
operator|::
name|setLineWidth
parameter_list|(
name|qreal
name|width
parameter_list|)
block|{
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|layoutData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextLine: Can't set a line width while not layouting."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|width
operator|>
name|QFIXED_MAX
condition|)
name|width
operator|=
name|QFIXED_MAX
expr_stmt|;
name|line
operator|.
name|width
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
operator|&&
name|line
operator|.
name|textWidth
operator|<=
name|line
operator|.
name|width
operator|&&
name|line
operator|.
name|from
operator|+
name|line
operator|.
name|length
operator|==
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
condition|)
comment|// no need to do anything if the line is already layouted and the last one. This optimization helps
comment|// when using things in a single line layout.
return|return;
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|layout_helper
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Lays out the line. The line is filled from its starting position     with as many characters as are specified by \a numColumns. In case     the text cannot be split until \a numColumns characters, the line     will be filled with as many characters to the next whitespace or     end of the text. */
end_comment
begin_function
DECL|function|setNumColumns
name|void
name|QTextLine
operator|::
name|setNumColumns
parameter_list|(
name|int
name|numColumns
parameter_list|)
block|{
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|line
operator|.
name|width
operator|=
name|QFIXED_MAX
expr_stmt|;
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|layout_helper
argument_list|(
name|numColumns
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Lays out the line. The line is filled from its starting position     with as many characters as are specified by \a numColumns. In case     the text cannot be split until \a numColumns characters, the line     will be filled with as many characters to the next whitespace or     end of the text. The provided \a alignmentWidth is used as reference     width for alignment. */
end_comment
begin_function
DECL|function|setNumColumns
name|void
name|QTextLine
operator|::
name|setNumColumns
parameter_list|(
name|int
name|numColumns
parameter_list|,
name|qreal
name|alignmentWidth
parameter_list|)
block|{
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|line
operator|.
name|width
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|alignmentWidth
argument_list|)
expr_stmt|;
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|layout_helper
argument_list|(
name|numColumns
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_define
define|#
directive|define
name|LB_DEBUG
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|LB_DEBUG
define|#
directive|define
name|LB_DEBUG
value|if (0) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
namespace|namespace
block|{
DECL|struct|LineBreakHelper
struct|struct
name|LineBreakHelper
block|{
DECL|function|LineBreakHelper
name|LineBreakHelper
parameter_list|()
member_init_list|:
name|glyphCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxGlyphs
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentPosition
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fontEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|logClusters
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|manualWrap
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|whiteSpaceOrObject
argument_list|(
literal|true
argument_list|)
block|{         }
DECL|member|tmpData
name|QScriptLine
name|tmpData
decl_stmt|;
DECL|member|spaceData
name|QScriptLine
name|spaceData
decl_stmt|;
DECL|member|glyphs
name|QGlyphLayout
name|glyphs
decl_stmt|;
DECL|member|glyphCount
name|int
name|glyphCount
decl_stmt|;
DECL|member|maxGlyphs
name|int
name|maxGlyphs
decl_stmt|;
DECL|member|currentPosition
name|int
name|currentPosition
decl_stmt|;
DECL|member|previousGlyph
name|glyph_t
name|previousGlyph
decl_stmt|;
DECL|member|minw
name|QFixed
name|minw
decl_stmt|;
DECL|member|softHyphenWidth
name|QFixed
name|softHyphenWidth
decl_stmt|;
DECL|member|rightBearing
name|QFixed
name|rightBearing
decl_stmt|;
DECL|member|minimumRightBearing
name|QFixed
name|minimumRightBearing
decl_stmt|;
DECL|member|fontEngine
name|QFontEngine
modifier|*
name|fontEngine
decl_stmt|;
DECL|member|logClusters
specifier|const
name|unsigned
name|short
modifier|*
name|logClusters
decl_stmt|;
DECL|member|manualWrap
name|bool
name|manualWrap
decl_stmt|;
DECL|member|whiteSpaceOrObject
name|bool
name|whiteSpaceOrObject
decl_stmt|;
name|bool
name|checkFullOtherwiseExtend
parameter_list|(
name|QScriptLine
modifier|&
name|line
parameter_list|)
function_decl|;
DECL|function|calculateNewWidth
name|QFixed
name|calculateNewWidth
parameter_list|(
specifier|const
name|QScriptLine
modifier|&
name|line
parameter_list|)
specifier|const
block|{
return|return
name|line
operator|.
name|textWidth
operator|+
name|tmpData
operator|.
name|textWidth
operator|+
name|spaceData
operator|.
name|textWidth
operator|+
name|softHyphenWidth
operator|-
name|qMin
argument_list|(
name|rightBearing
argument_list|,
name|QFixed
argument_list|()
argument_list|)
return|;
block|}
DECL|function|currentGlyph
specifier|inline
name|glyph_t
name|currentGlyph
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|currentPosition
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|logClusters
index|[
name|currentPosition
operator|-
literal|1
index|]
operator|<
name|glyphs
operator|.
name|numGlyphs
argument_list|)
expr_stmt|;
return|return
name|glyphs
operator|.
name|glyphs
index|[
name|logClusters
index|[
name|currentPosition
operator|-
literal|1
index|]
index|]
return|;
block|}
DECL|function|saveCurrentGlyph
specifier|inline
name|void
name|saveCurrentGlyph
parameter_list|()
block|{
name|previousGlyph
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|currentPosition
operator|>
literal|0
operator|&&
name|logClusters
index|[
name|currentPosition
operator|-
literal|1
index|]
operator|<
name|glyphs
operator|.
name|numGlyphs
condition|)
block|{
name|previousGlyph
operator|=
name|currentGlyph
argument_list|()
expr_stmt|;
comment|// needed to calculate right bearing later
block|}
block|}
DECL|function|adjustRightBearing
specifier|inline
name|void
name|adjustRightBearing
parameter_list|(
name|glyph_t
name|glyph
parameter_list|)
block|{
name|qreal
name|rb
decl_stmt|;
name|fontEngine
operator|->
name|getGlyphBearings
argument_list|(
name|glyph
argument_list|,
literal|0
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
name|rightBearing
operator|=
name|qMin
argument_list|(
name|QFixed
argument_list|()
argument_list|,
name|QFixed
operator|::
name|fromReal
argument_list|(
name|rb
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|adjustRightBearing
specifier|inline
name|void
name|adjustRightBearing
parameter_list|()
block|{
if|if
condition|(
name|currentPosition
operator|<=
literal|0
condition|)
return|return;
name|adjustRightBearing
argument_list|(
name|currentGlyph
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|adjustPreviousRightBearing
specifier|inline
name|void
name|adjustPreviousRightBearing
parameter_list|()
block|{
if|if
condition|(
name|previousGlyph
operator|>
literal|0
condition|)
name|adjustRightBearing
argument_list|(
name|previousGlyph
argument_list|)
expr_stmt|;
block|}
DECL|function|resetRightBearing
specifier|inline
name|void
name|resetRightBearing
parameter_list|()
block|{
name|rightBearing
operator|=
name|QFixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Any positive number is defined as invalid since only
comment|// negative right bearings are interesting to us.
block|}
block|}
struct|;
DECL|function|checkFullOtherwiseExtend
specifier|inline
name|bool
name|LineBreakHelper
operator|::
name|checkFullOtherwiseExtend
parameter_list|(
name|QScriptLine
modifier|&
name|line
parameter_list|)
block|{
name|LB_DEBUG
argument_list|(
literal|"possible break width %f, spacew=%f"
argument_list|,
name|tmpData
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|spaceData
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|QFixed
name|newWidth
init|=
name|calculateNewWidth
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|length
operator|&&
operator|!
name|manualWrap
operator|&&
operator|(
name|newWidth
operator|>
name|line
operator|.
name|width
operator|||
name|glyphCount
operator|>
name|maxGlyphs
operator|)
condition|)
return|return
literal|true
return|;
name|minw
operator|=
name|qMax
argument_list|(
name|minw
argument_list|,
name|tmpData
operator|.
name|textWidth
argument_list|)
expr_stmt|;
name|line
operator|+=
name|tmpData
expr_stmt|;
name|line
operator|.
name|textWidth
operator|+=
name|spaceData
operator|.
name|textWidth
expr_stmt|;
name|line
operator|.
name|length
operator|+=
name|spaceData
operator|.
name|length
expr_stmt|;
name|tmpData
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|tmpData
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|spaceData
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|spaceData
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_namespace
begin_comment
comment|// anonymous namespace
end_comment
begin_function
DECL|function|addNextCluster
specifier|static
specifier|inline
name|void
name|addNextCluster
parameter_list|(
name|int
modifier|&
name|pos
parameter_list|,
name|int
name|end
parameter_list|,
name|QScriptLine
modifier|&
name|line
parameter_list|,
name|int
modifier|&
name|glyphCount
parameter_list|,
specifier|const
name|QScriptItem
modifier|&
name|current
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|logClusters
parameter_list|,
specifier|const
name|QGlyphLayout
modifier|&
name|glyphs
parameter_list|)
block|{
name|int
name|glyphPosition
init|=
name|logClusters
index|[
name|pos
index|]
decl_stmt|;
do|do
block|{
comment|// got to the first next cluster
operator|++
name|pos
expr_stmt|;
operator|++
name|line
operator|.
name|length
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|<
name|end
operator|&&
name|logClusters
index|[
name|pos
index|]
operator|==
name|glyphPosition
condition|)
do|;
do|do
block|{
comment|// calculate the textWidth for the rest of the current cluster.
if|if
condition|(
operator|!
name|glyphs
operator|.
name|attributes
index|[
name|glyphPosition
index|]
operator|.
name|dontPrint
condition|)
name|line
operator|.
name|textWidth
operator|+=
name|glyphs
operator|.
name|advances
index|[
name|glyphPosition
index|]
expr_stmt|;
operator|++
name|glyphPosition
expr_stmt|;
block|}
do|while
condition|(
name|glyphPosition
operator|<
name|current
operator|.
name|num_glyphs
operator|&&
operator|!
name|glyphs
operator|.
name|attributes
index|[
name|glyphPosition
index|]
operator|.
name|clusterStart
condition|)
do|;
name|Q_ASSERT
argument_list|(
operator|(
name|pos
operator|==
name|end
operator|&&
name|glyphPosition
operator|==
name|current
operator|.
name|num_glyphs
operator|)
operator|||
name|logClusters
index|[
name|pos
index|]
operator|==
name|glyphPosition
argument_list|)
expr_stmt|;
operator|++
name|glyphCount
expr_stmt|;
block|}
end_function
begin_comment
comment|// fill QScriptLine
end_comment
begin_function
DECL|function|layout_helper
name|void
name|QTextLine
operator|::
name|layout_helper
parameter_list|(
name|int
name|maxGlyphs
parameter_list|)
block|{
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|trailingSpaces
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|hasTrailingSpaces
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
operator|||
name|line
operator|.
name|from
operator|>=
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
condition|)
block|{
name|line
operator|.
name|setDefaultHeight
argument_list|(
name|eng
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|line
operator|.
name|from
operator|<
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|LineBreakHelper
name|lbh
decl_stmt|;
name|lbh
operator|.
name|maxGlyphs
operator|=
name|maxGlyphs
expr_stmt|;
name|QTextOption
operator|::
name|WrapMode
name|wrapMode
init|=
name|eng
operator|->
name|option
operator|.
name|wrapMode
argument_list|()
decl_stmt|;
name|bool
name|breakany
init|=
operator|(
name|wrapMode
operator|==
name|QTextOption
operator|::
name|WrapAnywhere
operator|)
decl_stmt|;
name|lbh
operator|.
name|manualWrap
operator|=
operator|(
name|wrapMode
operator|==
name|QTextOption
operator|::
name|ManualWrap
operator|||
name|wrapMode
operator|==
name|QTextOption
operator|::
name|NoWrap
operator|)
expr_stmt|;
name|int
name|item
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|newItem
init|=
name|eng
operator|->
name|findItem
argument_list|(
name|line
operator|.
name|from
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|newItem
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|LB_DEBUG
argument_list|(
literal|"from: %d: item=%d, total %d, width available %f"
argument_list|,
name|line
operator|.
name|from
argument_list|,
name|newItem
argument_list|,
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
argument_list|,
name|line
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|Alignment
name|alignment
init|=
name|eng
operator|->
name|option
operator|.
name|alignment
argument_list|()
decl_stmt|;
specifier|const
name|QCharAttributes
modifier|*
name|attributes
init|=
name|eng
operator|->
name|attributes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attributes
condition|)
return|return;
name|lbh
operator|.
name|currentPosition
operator|=
name|line
operator|.
name|from
expr_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|lbh
operator|.
name|logClusters
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|logClustersPtr
expr_stmt|;
name|lbh
operator|.
name|previousGlyph
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newItem
operator|<
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
condition|)
block|{
name|lbh
operator|.
name|resetRightBearing
argument_list|()
expr_stmt|;
name|lbh
operator|.
name|softHyphenWidth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newItem
operator|!=
name|item
condition|)
block|{
name|item
operator|=
name|newItem
expr_stmt|;
specifier|const
name|QScriptItem
modifier|&
name|current
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|num_glyphs
condition|)
block|{
name|eng
operator|->
name|shape
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|attributes
operator|=
name|eng
operator|->
name|attributes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|attributes
condition|)
return|return;
name|lbh
operator|.
name|logClusters
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|logClustersPtr
expr_stmt|;
block|}
name|lbh
operator|.
name|currentPosition
operator|=
name|qMax
argument_list|(
name|line
operator|.
name|from
argument_list|,
name|current
operator|.
name|position
argument_list|)
expr_stmt|;
name|end
operator|=
name|current
operator|.
name|position
operator|+
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|lbh
operator|.
name|glyphs
operator|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
name|QFontEngine
modifier|*
name|fontEngine
init|=
name|eng
operator|->
name|fontEngine
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|lbh
operator|.
name|fontEngine
operator|!=
name|fontEngine
condition|)
block|{
name|lbh
operator|.
name|fontEngine
operator|=
name|fontEngine
expr_stmt|;
name|lbh
operator|.
name|minimumRightBearing
operator|=
name|qMin
argument_list|(
name|QFixed
argument_list|()
argument_list|,
name|QFixed
operator|::
name|fromReal
argument_list|(
name|fontEngine
operator|->
name|minRightBearing
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|QScriptItem
modifier|&
name|current
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
name|lbh
operator|.
name|tmpData
operator|.
name|leading
operator|=
name|qMax
argument_list|(
name|lbh
operator|.
name|tmpData
operator|.
name|leading
operator|+
name|lbh
operator|.
name|tmpData
operator|.
name|ascent
argument_list|,
name|current
operator|.
name|leading
operator|+
name|current
operator|.
name|ascent
argument_list|)
operator|-
name|qMax
argument_list|(
name|lbh
operator|.
name|tmpData
operator|.
name|ascent
argument_list|,
name|current
operator|.
name|ascent
argument_list|)
expr_stmt|;
name|lbh
operator|.
name|tmpData
operator|.
name|ascent
operator|=
name|qMax
argument_list|(
name|lbh
operator|.
name|tmpData
operator|.
name|ascent
argument_list|,
name|current
operator|.
name|ascent
argument_list|)
expr_stmt|;
name|lbh
operator|.
name|tmpData
operator|.
name|descent
operator|=
name|qMax
argument_list|(
name|lbh
operator|.
name|tmpData
operator|.
name|descent
argument_list|,
name|current
operator|.
name|descent
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Tab
operator|&&
operator|(
name|alignment
operator|&
operator|(
name|Qt
operator|::
name|AlignLeft
operator||
name|Qt
operator|::
name|AlignRight
operator||
name|Qt
operator|::
name|AlignCenter
operator||
name|Qt
operator|::
name|AlignJustify
operator|)
operator|)
condition|)
block|{
name|lbh
operator|.
name|whiteSpaceOrObject
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|QFixed
name|x
init|=
name|line
operator|.
name|x
operator|+
name|line
operator|.
name|textWidth
operator|+
name|lbh
operator|.
name|tmpData
operator|.
name|textWidth
operator|+
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
decl_stmt|;
name|QFixed
name|tabWidth
init|=
name|eng
operator|->
name|calculateTabWidth
argument_list|(
name|item
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|attributes
operator|=
name|eng
operator|->
name|attributes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|attributes
condition|)
return|return;
name|lbh
operator|.
name|logClusters
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|logClustersPtr
expr_stmt|;
name|lbh
operator|.
name|glyphs
operator|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
operator|+=
name|tabWidth
expr_stmt|;
name|lbh
operator|.
name|spaceData
operator|.
name|length
operator|++
expr_stmt|;
name|newItem
operator|=
name|item
operator|+
literal|1
expr_stmt|;
name|QFixed
name|averageCharWidth
init|=
name|eng
operator|->
name|fontEngine
argument_list|(
name|current
argument_list|)
operator|->
name|averageCharWidth
argument_list|()
decl_stmt|;
name|lbh
operator|.
name|glyphCount
operator|+=
name|qRound
argument_list|(
name|tabWidth
operator|/
name|averageCharWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|current
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|LineOrParagraphSeparator
condition|)
block|{
name|lbh
operator|.
name|whiteSpaceOrObject
operator|=
literal|true
expr_stmt|;
comment|// if the line consists only of the line separator make sure
comment|// we have a sane height
if|if
condition|(
operator|!
name|line
operator|.
name|length
operator|&&
operator|!
name|lbh
operator|.
name|tmpData
operator|.
name|length
condition|)
name|line
operator|.
name|setDefaultHeight
argument_list|(
name|eng
argument_list|)
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowLineAndParagraphSeparators
condition|)
block|{
if|if
condition|(
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|addNextCluster
argument_list|(
name|lbh
operator|.
name|currentPosition
argument_list|,
name|end
argument_list|,
name|lbh
operator|.
name|tmpData
argument_list|,
name|lbh
operator|.
name|glyphCount
argument_list|,
name|current
argument_list|,
name|lbh
operator|.
name|logClusters
argument_list|,
name|lbh
operator|.
name|glyphs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lbh
operator|.
name|tmpData
operator|.
name|length
operator|++
expr_stmt|;
name|lbh
operator|.
name|adjustPreviousRightBearing
argument_list|()
expr_stmt|;
block|}
name|line
operator|+=
name|lbh
operator|.
name|tmpData
expr_stmt|;
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|current
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Object
condition|)
block|{
name|lbh
operator|.
name|whiteSpaceOrObject
operator|=
literal|true
expr_stmt|;
name|lbh
operator|.
name|tmpData
operator|.
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|block
operator|.
name|docHandle
argument_list|()
condition|)
block|{
name|QTextInlineObject
name|inlineObject
argument_list|(
name|item
argument_list|,
name|eng
argument_list|)
decl_stmt|;
name|eng
operator|->
name|docLayout
argument_list|()
operator|->
name|positionInlineObject
argument_list|(
name|inlineObject
argument_list|,
name|eng
operator|->
name|block
operator|.
name|position
argument_list|()
operator|+
name|current
operator|.
name|position
argument_list|,
name|inlineObject
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|lbh
operator|.
name|tmpData
operator|.
name|textWidth
operator|+=
name|current
operator|.
name|width
expr_stmt|;
name|newItem
operator|=
name|item
operator|+
literal|1
expr_stmt|;
operator|++
name|lbh
operator|.
name|glyphCount
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|whiteSpace
condition|)
block|{
name|lbh
operator|.
name|whiteSpaceOrObject
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|lbh
operator|.
name|currentPosition
operator|<
name|end
operator|&&
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|whiteSpace
condition|)
name|addNextCluster
argument_list|(
name|lbh
operator|.
name|currentPosition
argument_list|,
name|end
argument_list|,
name|lbh
operator|.
name|spaceData
argument_list|,
name|lbh
operator|.
name|glyphCount
argument_list|,
name|current
argument_list|,
name|lbh
operator|.
name|logClusters
argument_list|,
name|lbh
operator|.
name|glyphs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lbh
operator|.
name|manualWrap
operator|&&
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
operator|>
name|line
operator|.
name|width
condition|)
block|{
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
operator|=
name|line
operator|.
name|width
expr_stmt|;
comment|// ignore spaces that fall out of the line.
goto|goto
name|found
goto|;
block|}
block|}
else|else
block|{
name|lbh
operator|.
name|whiteSpaceOrObject
operator|=
literal|false
expr_stmt|;
name|bool
name|sb_or_ws
init|=
literal|false
decl_stmt|;
name|lbh
operator|.
name|saveCurrentGlyph
argument_list|()
expr_stmt|;
do|do
block|{
name|addNextCluster
argument_list|(
name|lbh
operator|.
name|currentPosition
argument_list|,
name|end
argument_list|,
name|lbh
operator|.
name|tmpData
argument_list|,
name|lbh
operator|.
name|glyphCount
argument_list|,
name|current
argument_list|,
name|lbh
operator|.
name|logClusters
argument_list|,
name|lbh
operator|.
name|glyphs
argument_list|)
expr_stmt|;
comment|// This is a hack to fix a regression caused by the introduction of the
comment|// whitespace flag to non-breakable spaces and will cause the non-breakable
comment|// spaces to behave as in previous Qt versions in the line breaking algorithm.
comment|// The line breaks do not currently follow the Unicode specs, but fixing this would
comment|// require refactoring the code and would cause behavioral regressions.
name|bool
name|isBreakableSpace
init|=
name|lbh
operator|.
name|currentPosition
operator|<
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
operator|&&
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|whiteSpace
operator|&&
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|at
argument_list|(
name|lbh
operator|.
name|currentPosition
argument_list|)
operator|.
name|decompositionTag
argument_list|()
operator|!=
name|QChar
operator|::
name|NoBreak
decl_stmt|;
if|if
condition|(
name|lbh
operator|.
name|currentPosition
operator|>=
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
operator|||
name|isBreakableSpace
operator|||
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|lineBreak
condition|)
block|{
name|sb_or_ws
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|breakany
operator|&&
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|graphemeBoundary
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
name|lbh
operator|.
name|currentPosition
operator|<
name|end
condition|)
do|;
name|lbh
operator|.
name|minw
operator|=
name|qMax
argument_list|(
name|lbh
operator|.
name|tmpData
operator|.
name|textWidth
argument_list|,
name|lbh
operator|.
name|minw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|currentPosition
operator|>
literal|0
operator|&&
name|lbh
operator|.
name|currentPosition
operator|<
name|end
operator|&&
name|attributes
index|[
name|lbh
operator|.
name|currentPosition
index|]
operator|.
name|lineBreak
operator|&&
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|at
argument_list|(
name|lbh
operator|.
name|currentPosition
operator|-
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|QChar
operator|::
name|SoftHyphen
condition|)
block|{
comment|// if we are splitting up a word because of
comment|// a soft hyphen then we ...
comment|//
comment|//  a) have to take the width of the soft hyphen into
comment|//     account to see if the first syllable(s) /and/
comment|//     the soft hyphen fit into the line
comment|//
comment|//  b) if we are so short of available width that the
comment|//     soft hyphen is the first breakable position, then
comment|//     we don't want to show it. However we initially
comment|//     have to take the width for it into account so that
comment|//     the text document layout sees the overflow and
comment|//     switch to break-anywhere mode, in which we
comment|//     want the soft-hyphen to slip into the next line
comment|//     and thus become invisible again.
comment|//
if|if
condition|(
name|line
operator|.
name|length
condition|)
name|lbh
operator|.
name|softHyphenWidth
operator|=
name|lbh
operator|.
name|glyphs
operator|.
name|advances
index|[
name|lbh
operator|.
name|logClusters
index|[
name|lbh
operator|.
name|currentPosition
operator|-
literal|1
index|]
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|breakany
condition|)
name|lbh
operator|.
name|tmpData
operator|.
name|textWidth
operator|+=
name|lbh
operator|.
name|glyphs
operator|.
name|advances
index|[
name|lbh
operator|.
name|logClusters
index|[
name|lbh
operator|.
name|currentPosition
operator|-
literal|1
index|]
index|]
expr_stmt|;
block|}
comment|// The actual width of the text needs to take the right bearing into account. The
comment|// right bearing is left-ward, which means that if the rightmost pixel is to the right
comment|// of the advance of the glyph, the bearing will be negative. We flip the sign
comment|// for the code to be more readable. Logic borrowed from qfontmetrics.cpp.
comment|// We ignore the right bearing if the minimum negative bearing is too little to
comment|// expand the text beyond the edge.
if|if
condition|(
name|sb_or_ws
operator||
name|breakany
condition|)
block|{
name|QFixed
name|rightBearing
init|=
name|lbh
operator|.
name|rightBearing
decl_stmt|;
comment|// store previous right bearing
if|if
condition|(
name|lbh
operator|.
name|calculateNewWidth
argument_list|(
name|line
argument_list|)
operator|-
name|lbh
operator|.
name|minimumRightBearing
operator|>
name|line
operator|.
name|width
condition|)
name|lbh
operator|.
name|adjustRightBearing
argument_list|()
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|// we are too wide, fix right bearing
if|if
condition|(
name|rightBearing
operator|<=
literal|0
condition|)
name|lbh
operator|.
name|rightBearing
operator|=
name|rightBearing
expr_stmt|;
comment|// take from cache
else|else
name|lbh
operator|.
name|adjustPreviousRightBearing
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|breakany
condition|)
block|{
name|line
operator|.
name|textWidth
operator|+=
name|lbh
operator|.
name|softHyphenWidth
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
block|}
name|lbh
operator|.
name|saveCurrentGlyph
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lbh
operator|.
name|currentPosition
operator|==
name|end
condition|)
name|newItem
operator|=
name|item
operator|+
literal|1
expr_stmt|;
block|}
name|LB_DEBUG
argument_list|(
literal|"reached end of line"
argument_list|)
expr_stmt|;
name|lbh
operator|.
name|checkFullOtherwiseExtend
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|found
label|:
if|if
condition|(
name|lbh
operator|.
name|rightBearing
operator|>
literal|0
operator|&&
operator|!
name|lbh
operator|.
name|whiteSpaceOrObject
condition|)
comment|// If right bearing has not yet been adjusted
name|lbh
operator|.
name|adjustRightBearing
argument_list|()
expr_stmt|;
name|line
operator|.
name|textAdvance
operator|=
name|line
operator|.
name|textWidth
expr_stmt|;
name|line
operator|.
name|textWidth
operator|-=
name|qMin
argument_list|(
name|QFixed
argument_list|()
argument_list|,
name|lbh
operator|.
name|rightBearing
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LB_DEBUG
argument_list|(
literal|"no break available in line, adding temp: length %d, width %f, space: length %d, width %f"
argument_list|,
name|lbh
operator|.
name|tmpData
operator|.
name|length
argument_list|,
name|lbh
operator|.
name|tmpData
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|lbh
operator|.
name|spaceData
operator|.
name|length
argument_list|,
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|line
operator|+=
name|lbh
operator|.
name|tmpData
expr_stmt|;
block|}
name|LB_DEBUG
argument_list|(
literal|"line length = %d, ascent=%f, descent=%f, textWidth=%f (spacew=%f)"
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|line
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
argument_list|,
name|line
operator|.
name|descent
operator|.
name|toReal
argument_list|()
argument_list|,
name|line
operator|.
name|textWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|lbh
operator|.
name|spaceData
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|LB_DEBUG
argument_list|(
literal|"        : '%s'"
argument_list|,
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|mid
argument_list|(
name|line
operator|.
name|from
argument_list|,
name|line
operator|.
name|length
argument_list|)
operator|.
name|toUtf8
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|manualWrap
condition|)
block|{
name|eng
operator|->
name|minWidth
operator|=
name|qMax
argument_list|(
name|eng
operator|->
name|minWidth
argument_list|,
name|line
operator|.
name|textWidth
argument_list|)
expr_stmt|;
name|eng
operator|->
name|maxWidth
operator|=
name|qMax
argument_list|(
name|eng
operator|->
name|maxWidth
argument_list|,
name|line
operator|.
name|textWidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eng
operator|->
name|minWidth
operator|=
name|qMax
argument_list|(
name|eng
operator|->
name|minWidth
argument_list|,
name|lbh
operator|.
name|minw
argument_list|)
expr_stmt|;
name|eng
operator|->
name|maxWidth
operator|+=
name|line
operator|.
name|textWidth
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|textWidth
operator|>
literal|0
operator|&&
name|item
operator|<
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
condition|)
name|eng
operator|->
name|maxWidth
operator|+=
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|IncludeTrailingSpaces
condition|)
name|line
operator|.
name|textWidth
operator|+=
name|lbh
operator|.
name|spaceData
operator|.
name|textWidth
expr_stmt|;
if|if
condition|(
name|lbh
operator|.
name|spaceData
operator|.
name|length
condition|)
block|{
name|line
operator|.
name|trailingSpaces
operator|=
name|lbh
operator|.
name|spaceData
operator|.
name|length
expr_stmt|;
name|line
operator|.
name|hasTrailingSpaces
operator|=
literal|true
expr_stmt|;
block|}
name|line
operator|.
name|justified
operator|=
literal|false
expr_stmt|;
name|line
operator|.
name|gridfitted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|wrapMode
argument_list|()
operator|==
name|QTextOption
operator|::
name|WrapAtWordBoundaryOrAnywhere
condition|)
block|{
if|if
condition|(
operator|(
name|lbh
operator|.
name|maxGlyphs
operator|!=
name|INT_MAX
operator|&&
name|lbh
operator|.
name|glyphCount
operator|>
name|lbh
operator|.
name|maxGlyphs
operator|)
operator|||
operator|(
name|lbh
operator|.
name|maxGlyphs
operator|==
name|INT_MAX
operator|&&
name|line
operator|.
name|textWidth
operator|>
name|line
operator|.
name|width
operator|)
condition|)
block|{
name|eng
operator|->
name|option
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|WrapAnywhere
argument_list|)
expr_stmt|;
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|textWidth
operator|=
literal|0
expr_stmt|;
name|layout_helper
argument_list|(
name|lbh
operator|.
name|maxGlyphs
argument_list|)
expr_stmt|;
name|eng
operator|->
name|option
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|WrapAtWordBoundaryOrAnywhere
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Moves the line to position \a pos. */
end_comment
begin_function
DECL|function|setPosition
name|void
name|QTextLine
operator|::
name|setPosition
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
block|{
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|x
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|y
operator|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the line's position relative to the text layout's position. */
end_comment
begin_function
DECL|function|position
name|QPointF
name|QTextLine
operator|::
name|position
parameter_list|()
specifier|const
block|{
return|return
name|QPointF
argument_list|(
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// ### DOC: I have no idea what this means/does.
end_comment
begin_comment
comment|// You create a text layout with a string of text. Once you laid
end_comment
begin_comment
comment|// it out, it contains a number of QTextLines. from() returns the position
end_comment
begin_comment
comment|// inside the text string where this line starts. If you e.g. has a
end_comment
begin_comment
comment|// text of "This is a string", laid out into two lines (the second
end_comment
begin_comment
comment|// starting at the word 'a'), layout.lineAt(0).from() == 0 and
end_comment
begin_comment
comment|// layout.lineAt(1).from() == 8.
end_comment
begin_comment
comment|/*!     Returns the start of the line from the beginning of the string     passed to the QTextLayout. */
end_comment
begin_function
DECL|function|textStart
name|int
name|QTextLine
operator|::
name|textStart
parameter_list|()
specifier|const
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|from
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the text in the line.      \sa naturalTextWidth() */
end_comment
begin_function
DECL|function|textLength
name|int
name|QTextLine
operator|::
name|textLength
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowLineAndParagraphSeparators
operator|&&
name|eng
operator|->
name|block
operator|.
name|isValid
argument_list|()
operator|&&
name|index
operator|==
name|eng
operator|->
name|lines
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|length
operator|-
literal|1
return|;
block|}
return|return
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|length
operator|+
name|eng
operator|->
name|lines
index|[
name|index
index|]
operator|.
name|trailingSpaces
return|;
block|}
end_function
begin_function
DECL|function|setPenAndDrawBackground
specifier|static
name|void
name|setPenAndDrawBackground
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPen
modifier|&
name|defaultPen
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|chf
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
name|QBrush
name|c
init|=
name|chf
operator|.
name|foreground
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|p
operator|->
name|setPen
argument_list|(
name|defaultPen
argument_list|)
expr_stmt|;
block|}
name|QBrush
name|bg
init|=
name|chf
operator|.
name|background
argument_list|()
decl_stmt|;
if|if
condition|(
name|bg
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
operator|!
name|chf
operator|.
name|property
argument_list|(
name|SuppressBackground
argument_list|)
operator|.
name|toBool
argument_list|()
condition|)
name|p
operator|->
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|qFloor
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qFloor
argument_list|(
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|bg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_RAWFONT
argument_list|)
end_if
begin_function
DECL|function|glyphRunWithInfo
specifier|static
name|QGlyphRun
name|glyphRunWithInfo
parameter_list|(
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|QGlyphLayout
modifier|&
name|glyphLayout
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QGlyphRun
operator|::
name|GlyphRunFlags
modifier|&
name|flags
parameter_list|,
specifier|const
name|QFixed
modifier|&
name|selectionX
parameter_list|,
specifier|const
name|QFixed
modifier|&
name|selectionWidth
parameter_list|,
name|int
name|glyphsStart
parameter_list|,
name|int
name|glyphsEnd
parameter_list|,
name|unsigned
name|short
modifier|*
name|logClusters
parameter_list|,
name|int
name|textPosition
parameter_list|,
name|int
name|textLength
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|logClusters
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QGlyphRun
name|glyphRun
decl_stmt|;
name|QGlyphRunPrivate
modifier|*
name|d
init|=
name|QGlyphRunPrivate
operator|::
name|get
argument_list|(
name|glyphRun
argument_list|)
decl_stmt|;
name|int
name|rangeStart
init|=
name|textPosition
decl_stmt|;
while|while
condition|(
operator|*
name|logClusters
operator|!=
name|glyphsStart
operator|&&
name|rangeStart
operator|<
name|textPosition
operator|+
name|textLength
condition|)
block|{
operator|++
name|logClusters
expr_stmt|;
operator|++
name|rangeStart
expr_stmt|;
block|}
name|int
name|rangeEnd
init|=
name|rangeStart
decl_stmt|;
while|while
condition|(
operator|*
name|logClusters
operator|!=
name|glyphsEnd
operator|&&
name|rangeEnd
operator|<
name|textPosition
operator|+
name|textLength
condition|)
block|{
operator|++
name|logClusters
expr_stmt|;
operator|++
name|rangeEnd
expr_stmt|;
block|}
name|d
operator|->
name|textRangeStart
operator|=
name|rangeStart
expr_stmt|;
name|d
operator|->
name|textRangeEnd
operator|=
name|rangeEnd
expr_stmt|;
comment|// Make a font for this particular engine
name|QRawFont
name|font
decl_stmt|;
name|QRawFontPrivate
modifier|*
name|fontD
init|=
name|QRawFontPrivate
operator|::
name|get
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|fontD
operator|->
name|setFontEngine
argument_list|(
name|fontEngine
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|glyph_t
argument_list|>
name|glyphsArray
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QFixedPoint
argument_list|>
name|positionsArray
decl_stmt|;
name|QTextItem
operator|::
name|RenderFlags
name|renderFlags
decl_stmt|;
if|if
condition|(
name|flags
operator|.
name|testFlag
argument_list|(
name|QGlyphRun
operator|::
name|Overline
argument_list|)
condition|)
name|renderFlags
operator||=
name|QTextItem
operator|::
name|Overline
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|testFlag
argument_list|(
name|QGlyphRun
operator|::
name|Underline
argument_list|)
condition|)
name|renderFlags
operator||=
name|QTextItem
operator|::
name|Underline
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|testFlag
argument_list|(
name|QGlyphRun
operator|::
name|StrikeOut
argument_list|)
condition|)
name|renderFlags
operator||=
name|QTextItem
operator|::
name|StrikeOut
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|testFlag
argument_list|(
name|QGlyphRun
operator|::
name|RightToLeft
argument_list|)
condition|)
name|renderFlags
operator||=
name|QTextItem
operator|::
name|RightToLeft
expr_stmt|;
name|fontEngine
operator|->
name|getGlyphPositions
argument_list|(
name|glyphLayout
argument_list|,
name|QTransform
argument_list|()
argument_list|,
name|renderFlags
argument_list|,
name|glyphsArray
argument_list|,
name|positionsArray
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|glyphsArray
operator|.
name|size
argument_list|()
operator|==
name|positionsArray
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qreal
name|fontHeight
init|=
name|font
operator|.
name|ascent
argument_list|()
operator|+
name|font
operator|.
name|descent
argument_list|()
decl_stmt|;
name|qreal
name|minY
init|=
literal|0
decl_stmt|;
name|qreal
name|maxY
init|=
literal|0
decl_stmt|;
name|QVector
argument_list|<
name|quint32
argument_list|>
name|glyphs
decl_stmt|;
name|glyphs
operator|.
name|reserve
argument_list|(
name|glyphsArray
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|positions
decl_stmt|;
name|positions
operator|.
name|reserve
argument_list|(
name|glyphsArray
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphsArray
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|glyphs
operator|.
name|append
argument_list|(
name|glyphsArray
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|&
literal|0xffffff
argument_list|)
expr_stmt|;
name|QPointF
name|position
init|=
name|positionsArray
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toPointF
argument_list|()
operator|+
name|pos
decl_stmt|;
name|positions
operator|.
name|append
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|maxY
operator|=
name|minY
operator|=
name|position
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|minY
operator|=
name|qMin
argument_list|(
name|minY
argument_list|,
name|position
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|maxY
operator|=
name|qMax
argument_list|(
name|maxY
argument_list|,
name|position
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|qreal
name|height
init|=
name|maxY
operator|+
name|fontHeight
operator|-
name|minY
decl_stmt|;
name|glyphRun
operator|.
name|setGlyphIndexes
argument_list|(
name|glyphs
argument_list|)
expr_stmt|;
name|glyphRun
operator|.
name|setPositions
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|glyphRun
operator|.
name|setFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|glyphRun
operator|.
name|setRawFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|glyphRun
operator|.
name|setBoundingRect
argument_list|(
name|QRectF
argument_list|(
name|selectionX
operator|.
name|toReal
argument_list|()
argument_list|,
name|minY
operator|-
name|font
operator|.
name|ascent
argument_list|()
argument_list|,
name|selectionWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|height
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|glyphRun
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the glyph indexes and positions for all glyphs in this QTextLine for characters     in the range defined by \a from and \a length. The \a from index is relative to the beginning     of the text in the containing QTextLayout, and the range must be within the range of QTextLine     as given by functions textStart() and textLength().      If \a from is negative, it will default to textStart(), and if \a length is negative it will     default to the return value of textLength().      \since 5.0      \sa QTextLayout::glyphRuns() */
end_comment
begin_function
DECL|function|glyphRuns
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|QTextLine
operator|::
name|glyphRuns
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|length
parameter_list|)
specifier|const
block|{
specifier|const
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|length
operator|==
literal|0
condition|)
return|return
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
argument_list|()
return|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|textStart
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|length
operator|=
name|textLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
argument_list|()
return|;
name|QTextLayout
operator|::
name|FormatRange
name|selection
decl_stmt|;
name|selection
operator|.
name|start
operator|=
name|from
expr_stmt|;
name|selection
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|QTextLineItemIterator
name|iterator
argument_list|(
name|eng
argument_list|,
name|index
argument_list|,
name|QPointF
argument_list|()
argument_list|,
operator|&
name|selection
argument_list|)
decl_stmt|;
name|qreal
name|y
init|=
name|line
operator|.
name|y
operator|.
name|toReal
argument_list|()
operator|+
name|line
operator|.
name|base
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|glyphRuns
decl_stmt|;
while|while
condition|(
operator|!
name|iterator
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QScriptItem
modifier|&
name|si
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
continue|continue;
if|if
condition|(
name|from
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
operator|&&
operator|(
name|from
operator|>=
name|iterator
operator|.
name|itemEnd
operator|||
name|from
operator|+
name|length
operator|<=
name|iterator
operator|.
name|itemStart
operator|)
condition|)
continue|continue;
name|QPointF
name|pos
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|QFont
name|font
decl_stmt|;
name|QGlyphRun
operator|::
name|GlyphRunFlags
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|useRawFont
condition|)
block|{
name|font
operator|=
name|eng
operator|->
name|font
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|overline
argument_list|()
condition|)
name|flags
operator||=
name|QGlyphRun
operator|::
name|Overline
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|underline
argument_list|()
condition|)
name|flags
operator||=
name|QGlyphRun
operator|::
name|Underline
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|strikeOut
argument_list|()
condition|)
name|flags
operator||=
name|QGlyphRun
operator|::
name|StrikeOut
expr_stmt|;
block|}
name|bool
name|rtl
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
block|{
name|flags
operator||=
name|QGlyphRun
operator|::
name|RightToLeft
expr_stmt|;
name|rtl
operator|=
literal|true
expr_stmt|;
block|}
name|int
name|relativeFrom
init|=
name|qMax
argument_list|(
name|iterator
operator|.
name|itemStart
argument_list|,
name|from
argument_list|)
operator|-
name|si
operator|.
name|position
decl_stmt|;
name|int
name|relativeTo
init|=
name|qMin
argument_list|(
name|iterator
operator|.
name|itemEnd
argument_list|,
name|from
operator|+
name|length
argument_list|)
operator|-
literal|1
operator|-
name|si
operator|.
name|position
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|eng
operator|->
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|int
name|glyphsStart
init|=
name|logClusters
index|[
name|relativeFrom
index|]
decl_stmt|;
name|int
name|glyphsEnd
init|=
operator|(
name|relativeTo
operator|==
name|iterator
operator|.
name|itemLength
operator|)
condition|?
name|si
operator|.
name|num_glyphs
operator|-
literal|1
else|:
name|logClusters
index|[
name|relativeTo
index|]
decl_stmt|;
comment|// the glyph index right next to the requested range
name|int
name|nextGlyphIndex
init|=
operator|(
name|relativeTo
operator|<
name|iterator
operator|.
name|itemLength
operator|-
literal|1
operator|)
condition|?
name|logClusters
index|[
name|relativeTo
operator|+
literal|1
index|]
else|:
name|si
operator|.
name|num_glyphs
decl_stmt|;
if|if
condition|(
name|nextGlyphIndex
operator|-
literal|1
operator|>
name|glyphsEnd
condition|)
name|glyphsEnd
operator|=
name|nextGlyphIndex
operator|-
literal|1
expr_stmt|;
name|bool
name|startsInsideLigature
init|=
name|relativeFrom
operator|>
literal|0
operator|&&
name|logClusters
index|[
name|relativeFrom
operator|-
literal|1
index|]
operator|==
name|glyphsStart
decl_stmt|;
name|bool
name|endsInsideLigature
init|=
name|nextGlyphIndex
operator|==
name|glyphsEnd
decl_stmt|;
name|int
name|itemGlyphsStart
init|=
name|logClusters
index|[
name|iterator
operator|.
name|itemStart
operator|-
name|si
operator|.
name|position
index|]
decl_stmt|;
name|int
name|itemGlyphsEnd
init|=
name|logClusters
index|[
name|iterator
operator|.
name|itemEnd
operator|-
literal|1
operator|-
name|si
operator|.
name|position
index|]
decl_stmt|;
name|QGlyphLayout
name|glyphLayout
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
comment|// Calculate new x position of glyph layout for a subset. This becomes somewhat complex
comment|// when we're breaking a RTL script item, since the expected position passed into
comment|// getGlyphPositions() is the left-most edge of the left-most glyph in an RTL run.
if|if
condition|(
name|relativeFrom
operator|!=
operator|(
name|iterator
operator|.
name|itemStart
operator|-
name|si
operator|.
name|position
operator|)
operator|&&
operator|!
name|rtl
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|itemGlyphsStart
init|;
name|i
operator|<
name|glyphsStart
condition|;
operator|++
name|i
control|)
block|{
name|QFixed
name|justification
init|=
name|QFixed
operator|::
name|fromFixed
argument_list|(
name|glyphLayout
operator|.
name|justifications
index|[
name|i
index|]
operator|.
name|space_18d6
argument_list|)
decl_stmt|;
name|pos
operator|.
name|rx
argument_list|()
operator|+=
operator|(
name|glyphLayout
operator|.
name|advances
index|[
name|i
index|]
operator|+
name|justification
operator|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|relativeTo
operator|!=
operator|(
name|iterator
operator|.
name|itemEnd
operator|-
name|si
operator|.
name|position
operator|-
literal|1
operator|)
operator|&&
name|rtl
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|itemGlyphsEnd
init|;
name|i
operator|>
name|glyphsEnd
condition|;
operator|--
name|i
control|)
block|{
name|QFixed
name|justification
init|=
name|QFixed
operator|::
name|fromFixed
argument_list|(
name|glyphLayout
operator|.
name|justifications
index|[
name|i
index|]
operator|.
name|space_18d6
argument_list|)
decl_stmt|;
name|pos
operator|.
name|rx
argument_list|()
operator|+=
operator|(
name|glyphLayout
operator|.
name|advances
index|[
name|i
index|]
operator|+
name|justification
operator|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
block|}
name|glyphLayout
operator|=
name|glyphLayout
operator|.
name|mid
argument_list|(
name|glyphsStart
argument_list|,
name|glyphsEnd
operator|-
name|glyphsStart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QFixed
name|x
decl_stmt|;
name|QFixed
name|width
decl_stmt|;
name|iterator
operator|.
name|getSelectionBounds
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyphLayout
operator|.
name|numGlyphs
operator|>
literal|0
condition|)
block|{
name|QFontEngine
modifier|*
name|mainFontEngine
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RAWFONT
if|if
condition|(
name|eng
operator|->
name|useRawFont
operator|&&
name|eng
operator|->
name|rawFont
operator|.
name|isValid
argument_list|()
condition|)
name|mainFontEngine
operator|=
name|eng
operator|->
name|fontEngine
argument_list|(
name|si
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mainFontEngine
operator|=
name|font
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|si
operator|.
name|analysis
operator|.
name|script
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainFontEngine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Multi
condition|)
block|{
name|QFontEngineMulti
modifier|*
name|multiFontEngine
init|=
cast|static_cast
argument_list|<
name|QFontEngineMulti
operator|*
argument_list|>
argument_list|(
name|mainFontEngine
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|rtl
condition|?
name|glyphLayout
operator|.
name|numGlyphs
else|:
literal|0
decl_stmt|;
name|int
name|start
init|=
name|rtl
condition|?
name|end
else|:
literal|0
decl_stmt|;
name|int
name|which
init|=
name|glyphLayout
operator|.
name|glyphs
index|[
name|rtl
condition|?
name|start
operator|-
literal|1
else|:
name|end
index|]
operator|>>
literal|24
decl_stmt|;
for|for
control|(
init|;
operator|(
name|rtl
operator|&&
name|start
operator|>
literal|0
operator|)
operator|||
operator|(
operator|!
name|rtl
operator|&&
name|end
operator|<
name|glyphLayout
operator|.
name|numGlyphs
operator|)
condition|;
name|rtl
condition|?
operator|--
name|start
else|:
operator|++
name|end
control|)
block|{
specifier|const
name|int
name|e
init|=
name|glyphLayout
operator|.
name|glyphs
index|[
name|rtl
condition|?
name|start
operator|-
literal|1
else|:
name|end
index|]
operator|>>
literal|24
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|which
condition|)
continue|continue;
name|QGlyphLayout
name|subLayout
init|=
name|glyphLayout
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|multiFontEngine
operator|->
name|ensureEngineAt
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|QGlyphRun
operator|::
name|GlyphRunFlags
name|subFlags
init|=
name|flags
decl_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
operator|&&
name|startsInsideLigature
condition|)
name|subFlags
operator||=
name|QGlyphRun
operator|::
name|SplitLigature
expr_stmt|;
name|glyphRuns
operator|.
name|append
argument_list|(
name|glyphRunWithInfo
argument_list|(
name|multiFontEngine
operator|->
name|engine
argument_list|(
name|which
argument_list|)
argument_list|,
name|subLayout
argument_list|,
name|pos
argument_list|,
name|subFlags
argument_list|,
name|x
argument_list|,
name|width
argument_list|,
name|glyphsStart
operator|+
name|start
argument_list|,
name|glyphsStart
operator|+
name|end
argument_list|,
name|logClusters
argument_list|,
name|iterator
operator|.
name|itemStart
argument_list|,
name|iterator
operator|.
name|itemLength
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subLayout
operator|.
name|numGlyphs
condition|;
operator|++
name|i
control|)
block|{
name|QFixed
name|justification
init|=
name|QFixed
operator|::
name|fromFixed
argument_list|(
name|subLayout
operator|.
name|justifications
index|[
name|i
index|]
operator|.
name|space_18d6
argument_list|)
decl_stmt|;
name|pos
operator|.
name|rx
argument_list|()
operator|+=
operator|(
name|subLayout
operator|.
name|advances
index|[
name|i
index|]
operator|+
name|justification
operator|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rtl
condition|)
name|end
operator|=
name|start
expr_stmt|;
else|else
name|start
operator|=
name|end
expr_stmt|;
name|which
operator|=
name|e
expr_stmt|;
block|}
name|QGlyphLayout
name|subLayout
init|=
name|glyphLayout
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|multiFontEngine
operator|->
name|ensureEngineAt
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|QGlyphRun
operator|::
name|GlyphRunFlags
name|subFlags
init|=
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|==
literal|0
operator|&&
name|startsInsideLigature
operator|)
operator|||
name|endsInsideLigature
condition|)
name|subFlags
operator||=
name|QGlyphRun
operator|::
name|SplitLigature
expr_stmt|;
name|QGlyphRun
name|glyphRun
init|=
name|glyphRunWithInfo
argument_list|(
name|multiFontEngine
operator|->
name|engine
argument_list|(
name|which
argument_list|)
argument_list|,
name|subLayout
argument_list|,
name|pos
argument_list|,
name|subFlags
argument_list|,
name|x
argument_list|,
name|width
argument_list|,
name|glyphsStart
operator|+
name|start
argument_list|,
name|glyphsStart
operator|+
name|end
argument_list|,
name|logClusters
argument_list|,
name|iterator
operator|.
name|itemStart
argument_list|,
name|iterator
operator|.
name|itemLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|glyphRun
operator|.
name|isEmpty
argument_list|()
condition|)
name|glyphRuns
operator|.
name|append
argument_list|(
name|glyphRun
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|startsInsideLigature
operator|||
name|endsInsideLigature
condition|)
name|flags
operator||=
name|QGlyphRun
operator|::
name|SplitLigature
expr_stmt|;
name|QGlyphRun
name|glyphRun
init|=
name|glyphRunWithInfo
argument_list|(
name|mainFontEngine
argument_list|,
name|glyphLayout
argument_list|,
name|pos
argument_list|,
name|flags
argument_list|,
name|x
argument_list|,
name|width
argument_list|,
name|glyphsStart
argument_list|,
name|glyphsEnd
argument_list|,
name|logClusters
argument_list|,
name|iterator
operator|.
name|itemStart
argument_list|,
name|iterator
operator|.
name|itemLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|glyphRun
operator|.
name|isEmpty
argument_list|()
condition|)
name|glyphRuns
operator|.
name|append
argument_list|(
name|glyphRun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|glyphRuns
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_RAWFONT
end_comment
begin_comment
comment|/*!     \fn void QTextLine::draw(QPainter *painter, const QPointF&position, const QTextLayout::FormatRange *selection) const      Draws a line on the given \a painter at the specified \a position.     The \a selection is reserved for internal use. */
end_comment
begin_function
DECL|function|draw
name|void
name|QTextLine
operator|::
name|draw
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QTextLayout
operator|::
name|FormatRange
modifier|*
name|selection
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_RAWFONT
comment|// Not intended to work with rawfont
name|Q_ASSERT
argument_list|(
operator|!
name|eng
operator|->
name|useRawFont
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|QPen
name|pen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
name|bool
name|noText
init|=
operator|(
name|selection
operator|&&
name|selection
operator|->
name|format
operator|.
name|property
argument_list|(
name|SuppressText
argument_list|)
operator|.
name|toBool
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|selection
operator|&&
name|selection
operator|->
name|start
operator|<=
name|line
operator|.
name|from
operator|&&
name|selection
operator|->
name|start
operator|+
name|selection
operator|->
name|length
operator|>
name|line
operator|.
name|from
condition|)
block|{
specifier|const
name|qreal
name|lineHeight
init|=
name|line
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|QRectF
name|r
argument_list|(
name|pos
operator|.
name|x
argument_list|()
operator|+
name|line
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|+
name|line
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|lineHeight
operator|/
literal|2
argument_list|,
name|QFontMetrics
argument_list|(
name|eng
operator|->
name|font
argument_list|()
argument_list|)
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|setPenAndDrawBackground
argument_list|(
name|p
argument_list|,
name|QPen
argument_list|()
argument_list|,
name|selection
operator|->
name|format
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|QTextLineItemIterator
name|iterator
argument_list|(
name|eng
argument_list|,
name|index
argument_list|,
name|pos
argument_list|,
name|selection
argument_list|)
decl_stmt|;
name|QFixed
name|lineBase
init|=
name|line
operator|.
name|base
argument_list|()
decl_stmt|;
name|eng
operator|->
name|clearDecorations
argument_list|()
expr_stmt|;
name|eng
operator|->
name|enableDelayDecorations
argument_list|()
expr_stmt|;
specifier|const
name|QFixed
name|y
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|pos
operator|.
name|y
argument_list|()
argument_list|)
operator|+
name|line
operator|.
name|y
operator|+
name|lineBase
decl_stmt|;
name|bool
name|suppressColors
init|=
operator|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|SuppressColors
operator|)
decl_stmt|;
while|while
condition|(
operator|!
name|iterator
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QScriptItem
modifier|&
name|si
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|selection
operator|&&
name|selection
operator|->
name|start
operator|>=
literal|0
operator|&&
name|iterator
operator|.
name|isOutsideSelection
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|LineOrParagraphSeparator
operator|&&
operator|!
operator|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowLineAndParagraphSeparators
operator|)
condition|)
continue|continue;
name|QFixed
name|itemBaseLine
init|=
name|y
decl_stmt|;
name|QFont
name|f
init|=
name|eng
operator|->
name|font
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|format
decl_stmt|;
if|if
condition|(
name|eng
operator|->
name|hasFormats
argument_list|()
operator|||
name|selection
condition|)
block|{
name|format
operator|=
name|eng
operator|->
name|format
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|suppressColors
condition|)
block|{
name|format
operator|.
name|clearForeground
argument_list|()
expr_stmt|;
name|format
operator|.
name|clearBackground
argument_list|()
expr_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|TextUnderlineColor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selection
condition|)
name|format
operator|.
name|merge
argument_list|(
name|selection
operator|->
name|format
argument_list|)
expr_stmt|;
name|setPenAndDrawBackground
argument_list|(
name|p
argument_list|,
name|pen
argument_list|,
name|format
argument_list|,
name|QRectF
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
operator|(
name|y
operator|-
name|lineBase
operator|)
operator|.
name|toReal
argument_list|()
argument_list|,
name|iterator
operator|.
name|itemWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|line
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTextCharFormat
operator|::
name|VerticalAlignment
name|valign
init|=
name|format
operator|.
name|verticalAlignment
argument_list|()
decl_stmt|;
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSuperScript
operator|||
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSubScript
condition|)
block|{
name|QFontEngine
modifier|*
name|fe
init|=
name|f
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|si
operator|.
name|analysis
operator|.
name|script
argument_list|)
decl_stmt|;
name|QFixed
name|height
init|=
name|fe
operator|->
name|ascent
argument_list|()
operator|+
name|fe
operator|->
name|descent
argument_list|()
decl_stmt|;
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSubScript
condition|)
name|itemBaseLine
operator|+=
name|height
operator|/
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSuperScript
condition|)
name|itemBaseLine
operator|-=
name|height
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
if|if
condition|(
name|eng
operator|->
name|hasFormats
argument_list|()
condition|)
block|{
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Object
operator|&&
name|eng
operator|->
name|block
operator|.
name|docHandle
argument_list|()
condition|)
block|{
name|QFixed
name|itemY
init|=
name|y
operator|-
name|si
operator|.
name|ascent
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|verticalAlignment
argument_list|()
operator|==
name|QTextCharFormat
operator|::
name|AlignTop
condition|)
block|{
name|itemY
operator|=
name|y
operator|-
name|lineBase
expr_stmt|;
block|}
name|QRectF
name|itemRect
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|itemY
operator|.
name|toReal
argument_list|()
argument_list|,
name|iterator
operator|.
name|itemWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|si
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
decl_stmt|;
name|eng
operator|->
name|docLayout
argument_list|()
operator|->
name|drawInlineObject
argument_list|(
name|p
argument_list|,
name|itemRect
argument_list|,
name|QTextInlineObject
argument_list|(
name|iterator
operator|.
name|item
argument_list|,
name|eng
argument_list|)
argument_list|,
name|si
operator|.
name|position
operator|+
name|eng
operator|->
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|selection
condition|)
block|{
name|QBrush
name|bg
init|=
name|format
operator|.
name|brushProperty
argument_list|(
name|ObjectSelectionBrush
argument_list|)
decl_stmt|;
if|if
condition|(
name|bg
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|QColor
name|c
init|=
name|bg
operator|.
name|color
argument_list|()
decl_stmt|;
name|c
operator|.
name|setAlpha
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|p
operator|->
name|fillRect
argument_list|(
name|itemRect
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// si.isTab
name|QFont
name|f
init|=
name|eng
operator|->
name|font
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|QTextItemInt
name|gf
argument_list|(
name|si
argument_list|,
operator|&
name|f
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|gf
operator|.
name|chars
operator|=
literal|0
expr_stmt|;
name|gf
operator|.
name|num_chars
operator|=
literal|0
expr_stmt|;
name|gf
operator|.
name|width
operator|=
name|iterator
operator|.
name|itemWidth
expr_stmt|;
name|QPainterPrivate
operator|::
name|get
argument_list|(
name|p
argument_list|)
operator|->
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|y
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|gf
argument_list|,
name|eng
argument_list|)
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowTabsAndSpaces
condition|)
block|{
name|QChar
name|visualTab
argument_list|(
literal|0x2192
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|QFontMetrics
argument_list|(
name|f
argument_list|)
operator|.
name|width
argument_list|(
name|visualTab
argument_list|)
decl_stmt|;
name|qreal
name|x
init|=
name|iterator
operator|.
name|itemWidth
operator|.
name|toReal
argument_list|()
operator|-
name|w
decl_stmt|;
comment|// Right-aligned
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|p
operator|->
name|setClipRect
argument_list|(
name|QRectF
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|line
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|iterator
operator|.
name|itemWidth
operator|.
name|toReal
argument_list|()
argument_list|,
name|line
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
else|else
name|x
operator|/=
literal|2
expr_stmt|;
comment|// Centered
name|p
operator|->
name|drawText
argument_list|(
name|QPointF
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
operator|+
name|x
argument_list|,
name|y
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|visualTab
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|eng
operator|->
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|QGlyphLayout
name|glyphs
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|QTextItemInt
name|gf
argument_list|(
name|glyphs
operator|.
name|mid
argument_list|(
name|iterator
operator|.
name|glyphsStart
argument_list|,
name|iterator
operator|.
name|glyphsEnd
operator|-
name|iterator
operator|.
name|glyphsStart
argument_list|)
argument_list|,
operator|&
name|f
argument_list|,
name|eng
operator|->
name|layoutData
operator|->
name|string
operator|.
name|unicode
argument_list|()
operator|+
name|iterator
operator|.
name|itemStart
argument_list|,
name|iterator
operator|.
name|itemEnd
operator|-
name|iterator
operator|.
name|itemStart
argument_list|,
name|eng
operator|->
name|fontEngine
argument_list|(
name|si
argument_list|)
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|gf
operator|.
name|logClusters
operator|=
name|logClusters
operator|+
name|iterator
operator|.
name|itemStart
operator|-
name|si
operator|.
name|position
expr_stmt|;
name|gf
operator|.
name|width
operator|=
name|iterator
operator|.
name|itemWidth
expr_stmt|;
name|gf
operator|.
name|justified
operator|=
name|line
operator|.
name|justified
expr_stmt|;
name|gf
operator|.
name|initWithScriptItem
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|gf
operator|.
name|fontEngine
argument_list|)
expr_stmt|;
name|QPointF
name|pos
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|itemBaseLine
operator|.
name|toReal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|penProperty
argument_list|(
name|QTextFormat
operator|::
name|TextOutline
argument_list|)
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
condition|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
if|if
condition|(
name|gf
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|)
name|gf
operator|.
name|fontEngine
operator|->
name|addOutlineToPath
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
name|gf
operator|.
name|glyphs
argument_list|,
operator|&
name|path
argument_list|,
name|gf
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|gf
operator|.
name|flags
condition|)
block|{
specifier|const
name|QFontEngine
modifier|*
name|fe
init|=
name|gf
operator|.
name|fontEngine
decl_stmt|;
specifier|const
name|qreal
name|lw
init|=
name|fe
operator|->
name|lineThickness
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
if|if
condition|(
name|gf
operator|.
name|flags
operator|&
name|QTextItem
operator|::
name|Underline
condition|)
block|{
name|qreal
name|offs
init|=
name|fe
operator|->
name|underlinePosition
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|+
name|offs
argument_list|,
name|gf
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gf
operator|.
name|flags
operator|&
name|QTextItem
operator|::
name|Overline
condition|)
block|{
name|qreal
name|offs
init|=
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
operator|+
literal|1
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|-
name|offs
argument_list|,
name|gf
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gf
operator|.
name|flags
operator|&
name|QTextItem
operator|::
name|StrikeOut
condition|)
block|{
name|qreal
name|offs
init|=
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
operator|/
literal|3
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|-
name|offs
argument_list|,
name|gf
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|p
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
comment|//Currently QPen with a Qt::NoPen style still returns a default
comment|//QBrush which != Qt::NoBrush so we need this specialcase to reset it
if|if
condition|(
name|p
operator|->
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
name|p
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setBrush
argument_list|(
name|p
operator|->
name|pen
argument_list|()
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|format
operator|.
name|textOutline
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|noText
condition|)
name|gf
operator|.
name|glyphs
operator|.
name|numGlyphs
operator|=
literal|0
expr_stmt|;
comment|// slightly less elegant than it should be
name|QPainterPrivate
operator|::
name|get
argument_list|(
name|p
argument_list|)
operator|->
name|drawTextItem
argument_list|(
name|pos
argument_list|,
name|gf
argument_list|,
name|eng
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Space
operator|&&
operator|(
name|eng
operator|->
name|option
operator|.
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|ShowTabsAndSpaces
operator|)
condition|)
block|{
name|QBrush
name|c
init|=
name|format
operator|.
name|foreground
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|c
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|QChar
name|visualSpace
argument_list|(
operator|(
name|ushort
operator|)
literal|0xb7
argument_list|)
decl_stmt|;
name|p
operator|->
name|drawText
argument_list|(
name|QPointF
argument_list|(
name|iterator
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|itemBaseLine
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|visualSpace
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
block|}
name|eng
operator|->
name|drawDecorations
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|hasFormats
argument_list|()
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn int QTextLine::cursorToX(int cursorPos, Edge edge) const      \overload */
end_comment
begin_comment
comment|/*!     Converts the cursor position \a cursorPos to the corresponding x position     inside the line, taking account of the \a edge.      If \a cursorPos is not a valid cursor position, the nearest valid     cursor position will be used instead, and cpos will be modified to     point to this valid cursor position.      \sa xToCursor() */
end_comment
begin_function
DECL|function|cursorToX
name|qreal
name|QTextLine
operator|::
name|cursorToX
parameter_list|(
name|int
modifier|*
name|cursorPos
parameter_list|,
name|Edge
name|edge
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|eng
operator|->
name|layoutData
condition|)
name|eng
operator|->
name|itemize
argument_list|()
expr_stmt|;
specifier|const
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|bool
name|lastLine
init|=
name|index
operator|>=
name|eng
operator|->
name|lines
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|QFixed
name|x
init|=
name|line
operator|.
name|x
decl_stmt|;
name|x
operator|+=
name|eng
operator|->
name|alignLine
argument_list|(
name|line
argument_list|)
operator|-
name|eng
operator|->
name|leadingSpaceWidth
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|&&
operator|!
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|cursorPos
operator|=
literal|0
expr_stmt|;
return|return
name|x
operator|.
name|toReal
argument_list|()
return|;
block|}
name|int
name|lineEnd
init|=
name|line
operator|.
name|from
operator|+
name|line
operator|.
name|length
operator|+
name|line
operator|.
name|trailingSpaces
decl_stmt|;
name|int
name|pos
init|=
name|qBound
argument_list|(
literal|0
argument_list|,
operator|*
name|cursorPos
argument_list|,
name|lineEnd
argument_list|)
decl_stmt|;
name|int
name|itm
decl_stmt|;
specifier|const
name|QCharAttributes
modifier|*
name|attributes
init|=
name|eng
operator|->
name|attributes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attributes
condition|)
block|{
operator|*
name|cursorPos
operator|=
literal|0
expr_stmt|;
return|return
name|x
operator|.
name|toReal
argument_list|()
return|;
block|}
while|while
condition|(
name|pos
operator|<
name|lineEnd
operator|&&
operator|!
name|attributes
index|[
name|pos
index|]
operator|.
name|graphemeBoundary
condition|)
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|lineEnd
condition|)
block|{
comment|// end of line ensure we have the last item on the line
name|itm
operator|=
name|eng
operator|->
name|findItem
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|itm
operator|=
name|eng
operator|->
name|findItem
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|itm
operator|<
literal|0
condition|)
block|{
operator|*
name|cursorPos
operator|=
literal|0
expr_stmt|;
return|return
name|x
operator|.
name|toReal
argument_list|()
return|;
block|}
name|eng
operator|->
name|shapeLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
specifier|const
name|QScriptItem
modifier|*
name|si
init|=
operator|&
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|si
operator|->
name|num_glyphs
condition|)
name|eng
operator|->
name|shape
argument_list|(
name|itm
argument_list|)
expr_stmt|;
name|pos
operator|-=
name|si
operator|->
name|position
expr_stmt|;
name|QGlyphLayout
name|glyphs
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|eng
operator|->
name|logClusters
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|logClusters
argument_list|)
expr_stmt|;
name|int
name|l
init|=
name|eng
operator|->
name|length
argument_list|(
name|itm
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
name|l
condition|)
name|pos
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|int
name|glyph_pos
init|=
name|pos
operator|==
name|l
condition|?
name|si
operator|->
name|num_glyphs
else|:
name|logClusters
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|edge
operator|==
name|Trailing
operator|&&
name|glyph_pos
operator|<
name|si
operator|->
name|num_glyphs
condition|)
block|{
comment|// trailing edge is leading edge of next cluster
name|glyph_pos
operator|++
expr_stmt|;
while|while
condition|(
name|glyph_pos
operator|<
name|si
operator|->
name|num_glyphs
operator|&&
operator|!
name|glyphs
operator|.
name|attributes
index|[
name|glyph_pos
index|]
operator|.
name|clusterStart
condition|)
name|glyph_pos
operator|++
expr_stmt|;
block|}
name|bool
name|reverse
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|itm
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
decl_stmt|;
comment|// add the items left of the cursor
name|int
name|firstItem
init|=
name|eng
operator|->
name|findItem
argument_list|(
name|line
operator|.
name|from
argument_list|)
decl_stmt|;
name|int
name|lastItem
init|=
name|eng
operator|->
name|findItem
argument_list|(
name|lineEnd
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|nItems
init|=
operator|(
name|firstItem
operator|>=
literal|0
operator|&&
name|lastItem
operator|>=
name|firstItem
operator|)
condition|?
operator|(
name|lastItem
operator|-
name|firstItem
operator|+
literal|1
operator|)
else|:
literal|0
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|visualOrder
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|uchar
argument_list|>
name|levels
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
name|levels
index|[
name|i
index|]
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|i
operator|+
name|firstItem
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
expr_stmt|;
name|QTextEngine
operator|::
name|bidiReorder
argument_list|(
name|nItems
argument_list|,
name|levels
operator|.
name|data
argument_list|()
argument_list|,
name|visualOrder
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
block|{
name|int
name|item
init|=
name|visualOrder
index|[
name|i
index|]
operator|+
name|firstItem
decl_stmt|;
if|if
condition|(
name|item
operator|==
name|itm
condition|)
break|break;
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|si
operator|.
name|num_glyphs
condition|)
name|eng
operator|->
name|shape
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
name|x
operator|+=
name|si
operator|.
name|width
expr_stmt|;
continue|continue;
block|}
name|int
name|start
init|=
name|qMax
argument_list|(
name|line
operator|.
name|from
argument_list|,
name|si
operator|.
name|position
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|qMin
argument_list|(
name|lineEnd
argument_list|,
name|si
operator|.
name|position
operator|+
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
name|logClusters
operator|=
name|eng
operator|->
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|int
name|gs
init|=
name|logClusters
index|[
name|start
operator|-
name|si
operator|.
name|position
index|]
decl_stmt|;
name|int
name|ge
init|=
operator|(
name|end
operator|==
name|si
operator|.
name|position
operator|+
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
operator|)
condition|?
name|si
operator|.
name|num_glyphs
operator|-
literal|1
else|:
name|logClusters
index|[
name|end
operator|-
name|si
operator|.
name|position
operator|-
literal|1
index|]
decl_stmt|;
name|QGlyphLayout
name|glyphs
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
name|x
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
operator|++
name|gs
expr_stmt|;
block|}
block|}
name|logClusters
operator|=
name|eng
operator|->
name|logClusters
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|glyphs
operator|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
if|if
condition|(
name|pos
operator|==
operator|(
name|reverse
condition|?
literal|0
else|:
name|l
operator|)
condition|)
name|x
operator|+=
name|si
operator|->
name|width
expr_stmt|;
block|}
else|else
block|{
name|bool
name|rtl
init|=
name|eng
operator|->
name|isRightToLeft
argument_list|()
decl_stmt|;
name|bool
name|visual
init|=
name|eng
operator|->
name|visualCursorMovement
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|qMin
argument_list|(
name|lineEnd
argument_list|,
name|si
operator|->
name|position
operator|+
name|l
argument_list|)
operator|-
name|si
operator|->
name|position
decl_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
name|int
name|glyph_end
init|=
name|end
operator|==
name|l
condition|?
name|si
operator|->
name|num_glyphs
else|:
name|logClusters
index|[
name|end
index|]
decl_stmt|;
name|int
name|glyph_start
init|=
name|glyph_pos
decl_stmt|;
if|if
condition|(
name|visual
operator|&&
operator|!
name|rtl
operator|&&
operator|!
operator|(
name|lastLine
operator|&&
name|itm
operator|==
operator|(
name|visualOrder
index|[
name|nItems
operator|-
literal|1
index|]
operator|+
name|firstItem
operator|)
operator|)
condition|)
name|glyph_start
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|glyph_end
operator|-
literal|1
init|;
name|i
operator|>=
name|glyph_start
condition|;
name|i
operator|--
control|)
name|x
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|qMax
argument_list|(
name|line
operator|.
name|from
operator|-
name|si
operator|->
name|position
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|glyph_start
init|=
name|logClusters
index|[
name|start
index|]
decl_stmt|;
name|int
name|glyph_end
init|=
name|glyph_pos
decl_stmt|;
if|if
condition|(
operator|!
name|visual
operator|||
operator|!
name|rtl
operator|||
operator|(
name|lastLine
operator|&&
name|itm
operator|==
name|visualOrder
index|[
literal|0
index|]
operator|+
name|firstItem
operator|)
condition|)
name|glyph_end
operator|--
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|glyph_start
init|;
name|i
operator|<=
name|glyph_end
condition|;
name|i
operator|++
control|)
name|x
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|eng
operator|->
name|offsetInLigature
argument_list|(
name|si
argument_list|,
name|pos
argument_list|,
name|end
argument_list|,
name|glyph_pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|wrapMode
argument_list|()
operator|!=
name|QTextOption
operator|::
name|NoWrap
operator|&&
name|x
operator|>
name|line
operator|.
name|x
operator|+
name|line
operator|.
name|width
condition|)
name|x
operator|=
name|line
operator|.
name|x
operator|+
name|line
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|option
operator|.
name|wrapMode
argument_list|()
operator|!=
name|QTextOption
operator|::
name|NoWrap
operator|&&
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|cursorPos
operator|=
name|pos
operator|+
name|si
operator|->
name|position
expr_stmt|;
return|return
name|x
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QTextLine::xToCursor(qreal x, CursorPosition cpos) const      Converts the x-coordinate \a x, to the nearest matching cursor     position, depending on the cursor position type, \a cpos.     Note that result cursor position includes possible preedit area text.      \sa cursorToX() */
end_comment
begin_function
DECL|function|xToCursor
name|int
name|QTextLine
operator|::
name|xToCursor
parameter_list|(
name|qreal
name|_x
parameter_list|,
name|CursorPosition
name|cpos
parameter_list|)
specifier|const
block|{
name|QFixed
name|x
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|_x
argument_list|)
decl_stmt|;
specifier|const
name|QScriptLine
modifier|&
name|line
init|=
name|eng
operator|->
name|lines
index|[
name|index
index|]
decl_stmt|;
name|bool
name|lastLine
init|=
name|index
operator|>=
name|eng
operator|->
name|lines
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|lineNum
init|=
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|layoutData
condition|)
name|eng
operator|->
name|itemize
argument_list|()
expr_stmt|;
name|int
name|line_length
init|=
name|textLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|line_length
condition|)
return|return
name|line
operator|.
name|from
return|;
name|int
name|firstItem
init|=
name|eng
operator|->
name|findItem
argument_list|(
name|line
operator|.
name|from
argument_list|)
decl_stmt|;
name|int
name|lastItem
init|=
name|eng
operator|->
name|findItem
argument_list|(
name|line
operator|.
name|from
operator|+
name|line_length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|nItems
init|=
operator|(
name|firstItem
operator|>=
literal|0
operator|&&
name|lastItem
operator|>=
name|firstItem
operator|)
condition|?
operator|(
name|lastItem
operator|-
name|firstItem
operator|+
literal|1
operator|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|nItems
condition|)
return|return
literal|0
return|;
name|x
operator|-=
name|line
operator|.
name|x
expr_stmt|;
name|x
operator|-=
name|eng
operator|->
name|alignLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|//     qDebug("xToCursor: x=%f, cpos=%d", x.toReal(), cpos);
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|visualOrder
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|unsigned
name|char
argument_list|>
name|levels
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
name|levels
index|[
name|i
index|]
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|i
operator|+
name|firstItem
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
expr_stmt|;
name|QTextEngine
operator|::
name|bidiReorder
argument_list|(
name|nItems
argument_list|,
name|levels
operator|.
name|data
argument_list|()
argument_list|,
name|visualOrder
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|visual
init|=
name|eng
operator|->
name|visualCursorMovement
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
comment|// left of first item
name|int
name|item
init|=
name|visualOrder
index|[
literal|0
index|]
operator|+
name|firstItem
decl_stmt|;
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|si
operator|.
name|num_glyphs
condition|)
name|eng
operator|->
name|shape
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|si
operator|.
name|position
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
name|pos
operator|+=
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|pos
operator|=
name|qMax
argument_list|(
name|line
operator|.
name|from
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
name|qMin
argument_list|(
name|line
operator|.
name|from
operator|+
name|line_length
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|line
operator|.
name|textWidth
operator|||
operator|(
name|line
operator|.
name|justified
operator|&&
name|x
operator|<
name|line
operator|.
name|width
operator|)
condition|)
block|{
comment|// has to be in one of the runs
name|QFixed
name|pos
decl_stmt|;
name|bool
name|rtl
init|=
name|eng
operator|->
name|isRightToLeft
argument_list|()
decl_stmt|;
name|eng
operator|->
name|shapeLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|insertionPoints
decl_stmt|;
if|if
condition|(
name|visual
operator|&&
name|rtl
condition|)
name|eng
operator|->
name|insertionPointsForLine
argument_list|(
name|lineNum
argument_list|,
name|insertionPoints
argument_list|)
expr_stmt|;
name|int
name|nchars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
block|{
name|int
name|item
init|=
name|visualOrder
index|[
name|i
index|]
operator|+
name|firstItem
decl_stmt|;
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
name|int
name|item_length
init|=
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|//             qDebug("    item %d, visual %d x_remain=%f", i, item, x.toReal());
name|int
name|start
init|=
name|qMax
argument_list|(
name|line
operator|.
name|from
operator|-
name|si
operator|.
name|position
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|qMin
argument_list|(
name|line
operator|.
name|from
operator|+
name|line_length
operator|-
name|si
operator|.
name|position
argument_list|,
name|item_length
argument_list|)
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|eng
operator|->
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|int
name|gs
init|=
name|logClusters
index|[
name|start
index|]
decl_stmt|;
name|int
name|ge
init|=
operator|(
name|end
operator|==
name|item_length
condition|?
name|si
operator|.
name|num_glyphs
else|:
name|logClusters
index|[
name|end
index|]
operator|)
operator|-
literal|1
decl_stmt|;
name|QGlyphLayout
name|glyphs
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|QFixed
name|item_width
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
name|item_width
operator|=
name|si
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|int
name|g
init|=
name|gs
decl_stmt|;
while|while
condition|(
name|g
operator|<=
name|ge
condition|)
block|{
name|item_width
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|g
argument_list|)
expr_stmt|;
operator|++
name|g
expr_stmt|;
block|}
block|}
comment|//             qDebug("      start=%d, end=%d, gs=%d, ge=%d item_width=%f", start, end, gs, ge, item_width.toReal());
if|if
condition|(
name|pos
operator|+
name|item_width
operator|<
name|x
condition|)
block|{
name|pos
operator|+=
name|item_width
expr_stmt|;
name|nchars
operator|+=
name|end
expr_stmt|;
continue|continue;
block|}
comment|//             qDebug("      inside run");
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
if|if
condition|(
name|cpos
operator|==
name|QTextLine
operator|::
name|CursorOnCharacter
condition|)
return|return
name|si
operator|.
name|position
return|;
name|bool
name|left_half
init|=
operator|(
name|x
operator|-
name|pos
operator|)
operator|<
name|item_width
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|bool
argument_list|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
operator|!=
name|left_half
condition|)
return|return
name|si
operator|.
name|position
return|;
return|return
name|si
operator|.
name|position
operator|+
literal|1
return|;
block|}
name|int
name|glyph_pos
init|=
operator|-
literal|1
decl_stmt|;
name|QFixed
name|edge
decl_stmt|;
comment|// has to be inside run
if|if
condition|(
name|cpos
operator|==
name|QTextLine
operator|::
name|CursorOnCharacter
condition|)
block|{
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
block|{
name|pos
operator|+=
name|item_width
expr_stmt|;
name|glyph_pos
operator|=
name|gs
expr_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|gs
index|]
operator|.
name|clusterStart
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|x
condition|)
break|break;
name|glyph_pos
operator|=
name|gs
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
block|}
name|pos
operator|-=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
operator|++
name|gs
expr_stmt|;
block|}
block|}
else|else
block|{
name|glyph_pos
operator|=
name|gs
expr_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|gs
index|]
operator|.
name|clusterStart
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|x
condition|)
break|break;
name|glyph_pos
operator|=
name|gs
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
block|}
name|pos
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
operator|++
name|gs
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|QFixed
name|dist
init|=
name|INT_MAX
operator|/
literal|256
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|visual
operator|||
name|rtl
operator|||
operator|(
name|lastLine
operator|&&
name|i
operator|==
name|nItems
operator|-
literal|1
operator|)
condition|)
block|{
name|pos
operator|+=
name|item_width
expr_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|gs
index|]
operator|.
name|clusterStart
operator|&&
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
operator|<
name|dist
condition|)
block|{
name|glyph_pos
operator|=
name|gs
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
name|dist
operator|=
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
name|pos
operator|-=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
operator|++
name|gs
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|ge
operator|>=
name|gs
condition|)
block|{
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|ge
index|]
operator|.
name|clusterStart
operator|&&
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
operator|<
name|dist
condition|)
block|{
name|glyph_pos
operator|=
name|ge
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
name|dist
operator|=
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|ge
argument_list|)
expr_stmt|;
operator|--
name|ge
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|visual
operator|||
operator|!
name|rtl
operator|||
operator|(
name|lastLine
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|gs
index|]
operator|.
name|clusterStart
operator|&&
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
operator|<
name|dist
condition|)
block|{
name|glyph_pos
operator|=
name|gs
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
name|dist
operator|=
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
operator|++
name|gs
expr_stmt|;
block|}
block|}
else|else
block|{
name|QFixed
name|oldPos
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
name|pos
operator|+=
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|gs
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyphs
operator|.
name|attributes
index|[
name|gs
index|]
operator|.
name|clusterStart
operator|&&
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
operator|<
name|dist
condition|)
block|{
name|glyph_pos
operator|=
name|gs
expr_stmt|;
name|edge
operator|=
name|pos
expr_stmt|;
name|dist
operator|=
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
operator|++
name|gs
expr_stmt|;
block|}
name|pos
operator|=
name|oldPos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|x
operator|-
name|pos
argument_list|)
operator|<
name|dist
condition|)
block|{
if|if
condition|(
name|visual
condition|)
block|{
if|if
condition|(
operator|!
name|rtl
operator|&&
name|i
operator|<
name|nItems
operator|-
literal|1
condition|)
block|{
name|nchars
operator|+=
name|end
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rtl
operator|&&
name|nchars
operator|>
literal|0
condition|)
return|return
name|insertionPoints
index|[
name|lastLine
condition|?
name|nchars
else|:
name|nchars
operator|-
literal|1
index|]
return|;
block|}
return|return
name|eng
operator|->
name|positionInLigature
argument_list|(
operator|&
name|si
argument_list|,
name|end
argument_list|,
name|x
argument_list|,
name|pos
argument_list|,
operator|-
literal|1
argument_list|,
name|cpos
operator|==
name|QTextLine
operator|::
name|CursorOnCharacter
argument_list|)
return|;
block|}
block|}
name|Q_ASSERT
argument_list|(
name|glyph_pos
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|eng
operator|->
name|positionInLigature
argument_list|(
operator|&
name|si
argument_list|,
name|end
argument_list|,
name|x
argument_list|,
name|edge
argument_list|,
name|glyph_pos
argument_list|,
name|cpos
operator|==
name|QTextLine
operator|::
name|CursorOnCharacter
argument_list|)
return|;
block|}
block|}
comment|// right of last item
comment|//     qDebug()<< "right of last";
name|int
name|item
init|=
name|visualOrder
index|[
name|nItems
operator|-
literal|1
index|]
operator|+
name|firstItem
decl_stmt|;
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|si
operator|.
name|num_glyphs
condition|)
name|eng
operator|->
name|shape
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|si
operator|.
name|position
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
operator|)
condition|)
name|pos
operator|+=
name|eng
operator|->
name|length
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|pos
operator|=
name|qMax
argument_list|(
name|line
operator|.
name|from
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|int
name|maxPos
init|=
name|line
operator|.
name|from
operator|+
name|line_length
decl_stmt|;
comment|// except for the last line we assume that the
comment|// character between lines is a space and we want
comment|// to position the cursor to the left of that
comment|// character.
comment|// ###### breaks with japanese for example
if|if
condition|(
name|this
operator|->
name|index
operator|<
name|eng
operator|->
name|lines
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|)
operator|--
name|maxPos
expr_stmt|;
name|pos
operator|=
name|qMin
argument_list|(
name|pos
argument_list|,
name|maxPos
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
