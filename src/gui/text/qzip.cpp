begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTODFWRITER
end_ifndef
begin_include
include|#
directive|include
file|"qzipreader_p.h"
end_include
begin_include
include|#
directive|include
file|"qzipwriter_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qplatformdefs.h>
end_include
begin_include
include|#
directive|include
file|<qendian.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<zlib.h>
end_include
begin_comment
comment|// Zip standard version for archives handled by this API
end_comment
begin_comment
comment|// (actually, the only basic support of this version is implemented but it is enough for now)
end_comment
begin_define
DECL|macro|ZIP_VERSION
define|#
directive|define
name|ZIP_VERSION
value|20
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_undef
DECL|macro|S_IFREG
undef|#
directive|undef
name|S_IFREG
end_undef
begin_define
DECL|macro|S_IFREG
define|#
directive|define
name|S_IFREG
value|0100000
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|S_IFDIR
end_ifndef
begin_define
DECL|macro|S_IFDIR
define|#
directive|define
name|S_IFDIR
value|0040000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef
begin_define
DECL|macro|S_ISDIR
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|x
parameter_list|)
value|((x)& S_IFDIR)> 0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef
begin_define
DECL|macro|S_ISREG
define|#
directive|define
name|S_ISREG
parameter_list|(
name|x
parameter_list|)
value|((x)& 0170000) == S_IFREG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|S_IFLNK
define|#
directive|define
name|S_IFLNK
value|020000
end_define
begin_define
DECL|macro|S_ISLNK
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|x
parameter_list|)
value|((x)& S_IFLNK)> 0
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|S_IRUSR
end_ifndef
begin_define
DECL|macro|S_IRUSR
define|#
directive|define
name|S_IRUSR
value|0400
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_IWUSR
end_ifndef
begin_define
DECL|macro|S_IWUSR
define|#
directive|define
name|S_IWUSR
value|0200
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef
begin_define
DECL|macro|S_IXUSR
define|#
directive|define
name|S_IXUSR
value|0100
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|S_IRGRP
define|#
directive|define
name|S_IRGRP
value|0040
end_define
begin_define
DECL|macro|S_IWGRP
define|#
directive|define
name|S_IWGRP
value|0020
end_define
begin_define
DECL|macro|S_IXGRP
define|#
directive|define
name|S_IXGRP
value|0010
end_define
begin_define
DECL|macro|S_IROTH
define|#
directive|define
name|S_IROTH
value|0004
end_define
begin_define
DECL|macro|S_IWOTH
define|#
directive|define
name|S_IWOTH
value|0002
end_define
begin_define
DECL|macro|S_IXOTH
define|#
directive|define
name|S_IXOTH
value|0001
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FILE_ATTRIBUTE_READONLY
end_ifndef
begin_define
DECL|macro|FILE_ATTRIBUTE_READONLY
define|#
directive|define
name|FILE_ATTRIBUTE_READONLY
value|0x1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FILE_ATTRIBUTE_DIRECTORY
end_ifndef
begin_define
DECL|macro|FILE_ATTRIBUTE_DIRECTORY
define|#
directive|define
name|FILE_ATTRIBUTE_DIRECTORY
value|0x10
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_define
define|#
directive|define
name|ZDEBUG
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ZDEBUG
define|#
directive|define
name|ZDEBUG
value|if (0) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|readUInt
specifier|static
specifier|inline
name|uint
name|readUInt
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|data
index|[
literal|0
index|]
operator|)
operator|+
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|data
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function
begin_function
DECL|function|readUShort
specifier|static
specifier|inline
name|ushort
name|readUShort
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|data
index|[
literal|0
index|]
operator|)
operator|+
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
return|;
block|}
end_function
begin_function
DECL|function|writeUInt
specifier|static
specifier|inline
name|void
name|writeUInt
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|uint
name|i
parameter_list|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeUShort
specifier|static
specifier|inline
name|void
name|writeUShort
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|ushort
name|i
parameter_list|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copyUInt
specifier|static
specifier|inline
name|void
name|copyUInt
parameter_list|(
name|uchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
name|dest
index|[
literal|3
index|]
operator|=
name|src
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copyUShort
specifier|static
specifier|inline
name|void
name|copyUShort
parameter_list|(
name|uchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeMSDosDate
specifier|static
name|void
name|writeMSDosDate
parameter_list|(
name|uchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|)
block|{
if|if
condition|(
name|dt
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|quint16
name|time
init|=
operator|(
name|dt
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
operator|<<
literal|11
operator|)
comment|// 5 bit hour
operator||
operator|(
name|dt
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
operator|<<
literal|5
operator|)
comment|// 6 bit minute
operator||
operator|(
name|dt
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
operator|>>
literal|1
operator|)
decl_stmt|;
comment|// 5 bit double seconds
name|dest
index|[
literal|0
index|]
operator|=
name|time
operator|&
literal|0xff
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|time
operator|>>
literal|8
expr_stmt|;
name|quint16
name|date
init|=
operator|(
operator|(
name|dt
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|-
literal|1980
operator|)
operator|<<
literal|9
operator|)
comment|// 7 bit year 1980-based
operator||
operator|(
name|dt
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
operator|<<
literal|5
operator|)
comment|// 4 bit month
operator||
operator|(
name|dt
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
operator|)
decl_stmt|;
comment|// 5 bit day
name|dest
index|[
literal|2
index|]
operator|=
name|char
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|dest
index|[
literal|3
index|]
operator|=
name|char
argument_list|(
name|date
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dest
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|permissionsToMode
specifier|static
name|quint32
name|permissionsToMode
parameter_list|(
name|QFile
operator|::
name|Permissions
name|perms
parameter_list|)
block|{
name|quint32
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ReadOwner
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|WriteOwner
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ExeOwner
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ReadUser
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|WriteUser
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ExeUser
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ReadGroup
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|WriteGroup
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ExeGroup
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ReadOther
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|WriteOther
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|perms
operator|&
name|QFile
operator|::
name|ExeOther
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function
begin_function
DECL|function|inflate
specifier|static
name|int
name|inflate
parameter_list|(
name|Bytef
modifier|*
name|dest
parameter_list|,
name|ulong
modifier|*
name|destLen
parameter_list|,
specifier|const
name|Bytef
modifier|*
name|source
parameter_list|,
name|ulong
name|sourceLen
parameter_list|)
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|err
decl_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|source
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|sourceLen
expr_stmt|;
if|if
condition|(
operator|(
name|uLong
operator|)
name|stream
operator|.
name|avail_in
operator|!=
name|sourceLen
condition|)
return|return
name|Z_BUF_ERROR
return|;
name|stream
operator|.
name|next_out
operator|=
name|dest
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
operator|*
name|destLen
expr_stmt|;
if|if
condition|(
operator|(
name|uLong
operator|)
name|stream
operator|.
name|avail_out
operator|!=
operator|*
name|destLen
condition|)
return|return
name|Z_BUF_ERROR
return|;
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|err
operator|=
name|inflateInit2
argument_list|(
operator|&
name|stream
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|err
return|;
name|err
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|Z_NEED_DICT
operator|||
operator|(
name|err
operator|==
name|Z_BUF_ERROR
operator|&&
name|stream
operator|.
name|avail_in
operator|==
literal|0
operator|)
condition|)
return|return
name|Z_DATA_ERROR
return|;
return|return
name|err
return|;
block|}
operator|*
name|destLen
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|err
operator|=
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_function
DECL|function|deflate
specifier|static
name|int
name|deflate
parameter_list|(
name|Bytef
modifier|*
name|dest
parameter_list|,
name|ulong
modifier|*
name|destLen
parameter_list|,
specifier|const
name|Bytef
modifier|*
name|source
parameter_list|,
name|ulong
name|sourceLen
parameter_list|)
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|err
decl_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|source
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|sourceLen
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|dest
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
operator|*
name|destLen
expr_stmt|;
if|if
condition|(
operator|(
name|uLong
operator|)
name|stream
operator|.
name|avail_out
operator|!=
operator|*
name|destLen
condition|)
return|return
name|Z_BUF_ERROR
return|;
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|stream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|err
operator|=
name|deflateInit2
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
name|MAX_WBITS
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|err
return|;
name|err
operator|=
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
return|return
name|err
operator|==
name|Z_OK
condition|?
name|Z_BUF_ERROR
else|:
name|err
return|;
block|}
operator|*
name|destLen
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|err
operator|=
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_function
DECL|function|modeToPermissions
specifier|static
name|QFile
operator|::
name|Permissions
name|modeToPermissions
parameter_list|(
name|quint32
name|mode
parameter_list|)
block|{
name|QFile
operator|::
name|Permissions
name|ret
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ReadOwner
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|WriteOwner
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ExeOwner
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ReadUser
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|WriteUser
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ExeUser
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ReadGroup
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|ret
operator||=
name|QFile
operator|::
name|WriteGroup
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ExeGroup
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ReadOther
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|ret
operator||=
name|QFile
operator|::
name|WriteOther
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|ret
operator||=
name|QFile
operator|::
name|ExeOther
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|readMSDosDate
specifier|static
name|QDateTime
name|readMSDosDate
parameter_list|(
specifier|const
name|uchar
modifier|*
name|src
parameter_list|)
block|{
name|uint
name|dosDate
init|=
name|readUInt
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|quint64
name|uDate
decl_stmt|;
name|uDate
operator|=
call|(
name|quint64
call|)
argument_list|(
name|dosDate
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|uint
name|tm_mday
init|=
operator|(
name|uDate
operator|&
literal|0x1f
operator|)
decl_stmt|;
name|uint
name|tm_mon
init|=
operator|(
operator|(
name|uDate
operator|&
literal|0x1E0
operator|)
operator|>>
literal|5
operator|)
decl_stmt|;
name|uint
name|tm_year
init|=
operator|(
operator|(
operator|(
name|uDate
operator|&
literal|0x0FE00
operator|)
operator|>>
literal|9
operator|)
operator|+
literal|1980
operator|)
decl_stmt|;
name|uint
name|tm_hour
init|=
operator|(
operator|(
name|dosDate
operator|&
literal|0xF800
operator|)
operator|>>
literal|11
operator|)
decl_stmt|;
name|uint
name|tm_min
init|=
operator|(
operator|(
name|dosDate
operator|&
literal|0x7E0
operator|)
operator|>>
literal|5
operator|)
decl_stmt|;
name|uint
name|tm_sec
init|=
operator|(
operator|(
name|dosDate
operator|&
literal|0x1f
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|tm_year
argument_list|,
name|tm_mon
argument_list|,
name|tm_mday
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|tm_hour
argument_list|,
name|tm_min
argument_list|,
name|tm_sec
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// for details, see http://www.pkware.com/documents/casestudies/APPNOTE.TXT
end_comment
begin_enum
DECL|enum|HostOS
enum|enum
name|HostOS
block|{
DECL|enumerator|HostFAT
name|HostFAT
init|=
literal|0
block|,
DECL|enumerator|HostAMIGA
name|HostAMIGA
init|=
literal|1
block|,
DECL|enumerator|HostVMS
name|HostVMS
init|=
literal|2
block|,
comment|// VAX/VMS
DECL|enumerator|HostUnix
name|HostUnix
init|=
literal|3
block|,
DECL|enumerator|HostVM_CMS
name|HostVM_CMS
init|=
literal|4
block|,
DECL|enumerator|HostAtari
name|HostAtari
init|=
literal|5
block|,
comment|// what if it's a minix filesystem? [cjh]
DECL|enumerator|HostHPFS
name|HostHPFS
init|=
literal|6
block|,
comment|// filesystem used by OS/2 (and NT 3.x)
DECL|enumerator|HostMac
name|HostMac
init|=
literal|7
block|,
DECL|enumerator|HostZ_System
name|HostZ_System
init|=
literal|8
block|,
DECL|enumerator|HostCPM
name|HostCPM
init|=
literal|9
block|,
DECL|enumerator|HostTOPS20
name|HostTOPS20
init|=
literal|10
block|,
comment|// pkzip 2.50 NTFS
DECL|enumerator|HostNTFS
name|HostNTFS
init|=
literal|11
block|,
comment|// filesystem used by Windows NT
DECL|enumerator|HostQDOS
name|HostQDOS
init|=
literal|12
block|,
comment|// SMS/QDOS
DECL|enumerator|HostAcorn
name|HostAcorn
init|=
literal|13
block|,
comment|// Archimedes Acorn RISC OS
DECL|enumerator|HostVFAT
name|HostVFAT
init|=
literal|14
block|,
comment|// filesystem used by Windows 95, NT
DECL|enumerator|HostMVS
name|HostMVS
init|=
literal|15
block|,
DECL|enumerator|HostBeOS
name|HostBeOS
init|=
literal|16
block|,
comment|// hybrid POSIX/database filesystem
DECL|enumerator|HostTandem
name|HostTandem
init|=
literal|17
block|,
DECL|enumerator|HostOS400
name|HostOS400
init|=
literal|18
block|,
DECL|enumerator|HostOSX
name|HostOSX
init|=
literal|19
block|}
enum|;
end_enum
begin_enum
DECL|enum|GeneralPurposeFlag
enum|enum
name|GeneralPurposeFlag
block|{
DECL|enumerator|Encrypted
name|Encrypted
init|=
literal|0x01
block|,
DECL|enumerator|AlgTune1
name|AlgTune1
init|=
literal|0x02
block|,
DECL|enumerator|AlgTune2
name|AlgTune2
init|=
literal|0x04
block|,
DECL|enumerator|HasDataDescriptor
name|HasDataDescriptor
init|=
literal|0x08
block|,
DECL|enumerator|PatchedData
name|PatchedData
init|=
literal|0x20
block|,
DECL|enumerator|StrongEncrypted
name|StrongEncrypted
init|=
literal|0x40
block|,
DECL|enumerator|Utf8Names
name|Utf8Names
init|=
literal|0x0800
block|,
DECL|enumerator|CentralDirectoryEncrypted
name|CentralDirectoryEncrypted
init|=
literal|0x2000
block|}
enum|;
end_enum
begin_enum
DECL|enum|CompressionMethod
enum|enum
name|CompressionMethod
block|{
DECL|enumerator|CompressionMethodStored
name|CompressionMethodStored
init|=
literal|0
block|,
DECL|enumerator|CompressionMethodShrunk
name|CompressionMethodShrunk
init|=
literal|1
block|,
DECL|enumerator|CompressionMethodReduced1
name|CompressionMethodReduced1
init|=
literal|2
block|,
DECL|enumerator|CompressionMethodReduced2
name|CompressionMethodReduced2
init|=
literal|3
block|,
DECL|enumerator|CompressionMethodReduced3
name|CompressionMethodReduced3
init|=
literal|4
block|,
DECL|enumerator|CompressionMethodReduced4
name|CompressionMethodReduced4
init|=
literal|5
block|,
DECL|enumerator|CompressionMethodImploded
name|CompressionMethodImploded
init|=
literal|6
block|,
DECL|enumerator|CompressionMethodReservedTokenizing
name|CompressionMethodReservedTokenizing
init|=
literal|7
block|,
comment|// reserved for tokenizing
DECL|enumerator|CompressionMethodDeflated
name|CompressionMethodDeflated
init|=
literal|8
block|,
DECL|enumerator|CompressionMethodDeflated64
name|CompressionMethodDeflated64
init|=
literal|9
block|,
DECL|enumerator|CompressionMethodPKImploding
name|CompressionMethodPKImploding
init|=
literal|10
block|,
DECL|enumerator|CompressionMethodBZip2
name|CompressionMethodBZip2
init|=
literal|12
block|,
DECL|enumerator|CompressionMethodLZMA
name|CompressionMethodLZMA
init|=
literal|14
block|,
DECL|enumerator|CompressionMethodTerse
name|CompressionMethodTerse
init|=
literal|18
block|,
DECL|enumerator|CompressionMethodLz77
name|CompressionMethodLz77
init|=
literal|19
block|,
DECL|enumerator|CompressionMethodJpeg
name|CompressionMethodJpeg
init|=
literal|96
block|,
DECL|enumerator|CompressionMethodWavPack
name|CompressionMethodWavPack
init|=
literal|97
block|,
DECL|enumerator|CompressionMethodPPMd
name|CompressionMethodPPMd
init|=
literal|98
block|,
DECL|enumerator|CompressionMethodWzAES
name|CompressionMethodWzAES
init|=
literal|99
block|}
enum|;
end_enum
begin_struct
DECL|struct|LocalFileHeader
struct|struct
name|LocalFileHeader
block|{
DECL|member|signature
name|uchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
comment|//  0x04034b50
DECL|member|version_needed
name|uchar
name|version_needed
index|[
literal|2
index|]
decl_stmt|;
DECL|member|general_purpose_bits
name|uchar
name|general_purpose_bits
index|[
literal|2
index|]
decl_stmt|;
DECL|member|compression_method
name|uchar
name|compression_method
index|[
literal|2
index|]
decl_stmt|;
DECL|member|last_mod_file
name|uchar
name|last_mod_file
index|[
literal|4
index|]
decl_stmt|;
DECL|member|crc_32
name|uchar
name|crc_32
index|[
literal|4
index|]
decl_stmt|;
DECL|member|compressed_size
name|uchar
name|compressed_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|uncompressed_size
name|uchar
name|uncompressed_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|file_name_length
name|uchar
name|file_name_length
index|[
literal|2
index|]
decl_stmt|;
DECL|member|extra_field_length
name|uchar
name|extra_field_length
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|DataDescriptor
struct|struct
name|DataDescriptor
block|{
DECL|member|crc_32
name|uchar
name|crc_32
index|[
literal|4
index|]
decl_stmt|;
DECL|member|compressed_size
name|uchar
name|compressed_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|uncompressed_size
name|uchar
name|uncompressed_size
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|CentralFileHeader
struct|struct
name|CentralFileHeader
block|{
DECL|member|signature
name|uchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
comment|// 0x02014b50
DECL|member|version_made
name|uchar
name|version_made
index|[
literal|2
index|]
decl_stmt|;
DECL|member|version_needed
name|uchar
name|version_needed
index|[
literal|2
index|]
decl_stmt|;
DECL|member|general_purpose_bits
name|uchar
name|general_purpose_bits
index|[
literal|2
index|]
decl_stmt|;
DECL|member|compression_method
name|uchar
name|compression_method
index|[
literal|2
index|]
decl_stmt|;
DECL|member|last_mod_file
name|uchar
name|last_mod_file
index|[
literal|4
index|]
decl_stmt|;
DECL|member|crc_32
name|uchar
name|crc_32
index|[
literal|4
index|]
decl_stmt|;
DECL|member|compressed_size
name|uchar
name|compressed_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|uncompressed_size
name|uchar
name|uncompressed_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|file_name_length
name|uchar
name|file_name_length
index|[
literal|2
index|]
decl_stmt|;
DECL|member|extra_field_length
name|uchar
name|extra_field_length
index|[
literal|2
index|]
decl_stmt|;
DECL|member|file_comment_length
name|uchar
name|file_comment_length
index|[
literal|2
index|]
decl_stmt|;
DECL|member|disk_start
name|uchar
name|disk_start
index|[
literal|2
index|]
decl_stmt|;
DECL|member|internal_file_attributes
name|uchar
name|internal_file_attributes
index|[
literal|2
index|]
decl_stmt|;
DECL|member|external_file_attributes
name|uchar
name|external_file_attributes
index|[
literal|4
index|]
decl_stmt|;
DECL|member|offset_local_header
name|uchar
name|offset_local_header
index|[
literal|4
index|]
decl_stmt|;
name|LocalFileHeader
name|toLocalHeader
parameter_list|()
specifier|const
function_decl|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|EndOfDirectory
struct|struct
name|EndOfDirectory
block|{
DECL|member|signature
name|uchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
comment|// 0x06054b50
DECL|member|this_disk
name|uchar
name|this_disk
index|[
literal|2
index|]
decl_stmt|;
DECL|member|start_of_directory_disk
name|uchar
name|start_of_directory_disk
index|[
literal|2
index|]
decl_stmt|;
DECL|member|num_dir_entries_this_disk
name|uchar
name|num_dir_entries_this_disk
index|[
literal|2
index|]
decl_stmt|;
DECL|member|num_dir_entries
name|uchar
name|num_dir_entries
index|[
literal|2
index|]
decl_stmt|;
DECL|member|directory_size
name|uchar
name|directory_size
index|[
literal|4
index|]
decl_stmt|;
DECL|member|dir_start_offset
name|uchar
name|dir_start_offset
index|[
literal|4
index|]
decl_stmt|;
DECL|member|comment_length
name|uchar
name|comment_length
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|FileHeader
struct|struct
name|FileHeader
block|{
DECL|member|h
name|CentralFileHeader
name|h
decl_stmt|;
DECL|member|file_name
name|QByteArray
name|file_name
decl_stmt|;
DECL|member|extra_field
name|QByteArray
name|extra_field
decl_stmt|;
DECL|member|file_comment
name|QByteArray
name|file_comment
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|FileInfo
name|QZipReader
operator|::
name|FileInfo
operator|::
name|FileInfo
parameter_list|()
member_init_list|:
name|isDir
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isFile
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isSymLink
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|crc
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|size
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~FileInfo
name|QZipReader
operator|::
name|FileInfo
operator|::
name|~
name|FileInfo
parameter_list|()
block|{ }
end_destructor
begin_constructor
DECL|function|FileInfo
name|QZipReader
operator|::
name|FileInfo
operator|::
name|FileInfo
parameter_list|(
specifier|const
name|FileInfo
modifier|&
name|other
parameter_list|)
block|{
name|operator
name|=
parameter_list|(
name|other
parameter_list|)
function_decl|;
block|}
end_constructor
begin_function
DECL|function|operator =
name|QZipReader
operator|::
name|FileInfo
modifier|&
name|QZipReader
operator|::
name|FileInfo
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|FileInfo
modifier|&
name|other
parameter_list|)
block|{
name|filePath
operator|=
name|other
operator|.
name|filePath
expr_stmt|;
name|isDir
operator|=
name|other
operator|.
name|isDir
expr_stmt|;
name|isFile
operator|=
name|other
operator|.
name|isFile
expr_stmt|;
name|isSymLink
operator|=
name|other
operator|.
name|isSymLink
expr_stmt|;
name|permissions
operator|=
name|other
operator|.
name|permissions
expr_stmt|;
name|crc
operator|=
name|other
operator|.
name|crc
expr_stmt|;
name|size
operator|=
name|other
operator|.
name|size
expr_stmt|;
name|lastModified
operator|=
name|other
operator|.
name|lastModified
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QZipReader
operator|::
name|FileInfo
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|isDir
operator|||
name|isFile
operator|||
name|isSymLink
return|;
block|}
end_function
begin_class
DECL|class|QZipPrivate
class|class
name|QZipPrivate
block|{
public|public:
DECL|function|QZipPrivate
name|QZipPrivate
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|bool
name|ownDev
parameter_list|)
member_init_list|:
name|device
argument_list|(
name|device
argument_list|)
member_init_list|,
name|ownDevice
argument_list|(
name|ownDev
argument_list|)
member_init_list|,
name|dirtyFileTree
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|start_of_directory
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|~QZipPrivate
name|~
name|QZipPrivate
parameter_list|()
block|{
if|if
condition|(
name|ownDevice
condition|)
operator|delete
name|device
expr_stmt|;
block|}
name|void
name|fillFileInfo
parameter_list|(
name|int
name|index
parameter_list|,
name|QZipReader
operator|::
name|FileInfo
modifier|&
name|fileInfo
parameter_list|)
specifier|const
function_decl|;
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|ownDevice
name|bool
name|ownDevice
decl_stmt|;
DECL|member|dirtyFileTree
name|bool
name|dirtyFileTree
decl_stmt|;
DECL|member|fileHeaders
name|QList
argument_list|<
name|FileHeader
argument_list|>
name|fileHeaders
decl_stmt|;
DECL|member|comment
name|QByteArray
name|comment
decl_stmt|;
DECL|member|start_of_directory
name|uint
name|start_of_directory
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|fillFileInfo
name|void
name|QZipPrivate
operator|::
name|fillFileInfo
parameter_list|(
name|int
name|index
parameter_list|,
name|QZipReader
operator|::
name|FileInfo
modifier|&
name|fileInfo
parameter_list|)
specifier|const
block|{
name|FileHeader
name|header
init|=
name|fileHeaders
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|quint32
name|mode
init|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|external_file_attributes
argument_list|)
decl_stmt|;
specifier|const
name|HostOS
name|hostOS
init|=
name|HostOS
argument_list|(
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|version_made
argument_list|)
operator|>>
literal|8
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|hostOS
condition|)
block|{
case|case
name|HostUnix
case|:
name|mode
operator|=
operator|(
name|mode
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|fileInfo
operator|.
name|isDir
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
condition|)
name|fileInfo
operator|.
name|isFile
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
name|fileInfo
operator|.
name|isSymLink
operator|=
literal|true
expr_stmt|;
name|fileInfo
operator|.
name|permissions
operator|=
name|modeToPermissions
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|HostFAT
case|:
case|case
name|HostNTFS
case|:
case|case
name|HostHPFS
case|:
case|case
name|HostVFAT
case|:
name|fileInfo
operator|.
name|permissions
operator||=
name|QFile
operator|::
name|ReadOwner
operator||
name|QFile
operator|::
name|ReadUser
operator||
name|QFile
operator|::
name|ReadGroup
operator||
name|QFile
operator|::
name|ReadOther
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|FILE_ATTRIBUTE_READONLY
operator|)
operator|==
literal|0
condition|)
name|fileInfo
operator|.
name|permissions
operator||=
name|QFile
operator|::
name|WriteOwner
operator||
name|QFile
operator|::
name|WriteUser
operator||
name|QFile
operator|::
name|WriteGroup
operator||
name|QFile
operator|::
name|WriteOther
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
operator|)
operator|==
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
block|{
name|fileInfo
operator|.
name|isDir
operator|=
literal|true
expr_stmt|;
name|fileInfo
operator|.
name|permissions
operator||=
name|QFile
operator|::
name|ExeOwner
operator||
name|QFile
operator|::
name|ExeUser
operator||
name|QFile
operator|::
name|ExeGroup
operator||
name|QFile
operator|::
name|ExeOther
expr_stmt|;
block|}
else|else
block|{
name|fileInfo
operator|.
name|isFile
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QZip: Zip entry format at %d is not supported."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
comment|// we don't support anything else
block|}
name|ushort
name|general_purpose_bits
init|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|general_purpose_bits
argument_list|)
decl_stmt|;
comment|// if bit 11 is set, the filename and comment fields must be encoded using UTF-8
specifier|const
name|bool
name|inUtf8
init|=
operator|(
name|general_purpose_bits
operator|&
name|Utf8Names
operator|)
operator|!=
literal|0
decl_stmt|;
name|fileInfo
operator|.
name|filePath
operator|=
name|inUtf8
condition|?
name|QString
operator|::
name|fromUtf8
argument_list|(
name|header
operator|.
name|file_name
argument_list|)
else|:
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|header
operator|.
name|file_name
argument_list|)
expr_stmt|;
name|fileInfo
operator|.
name|crc
operator|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|crc_32
argument_list|)
expr_stmt|;
name|fileInfo
operator|.
name|size
operator|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|uncompressed_size
argument_list|)
expr_stmt|;
name|fileInfo
operator|.
name|lastModified
operator|=
name|readMSDosDate
argument_list|(
name|header
operator|.
name|h
operator|.
name|last_mod_file
argument_list|)
expr_stmt|;
comment|// fix the file path, if broken (convert separators, eat leading and trailing ones)
name|fileInfo
operator|.
name|filePath
operator|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|fileInfo
operator|.
name|filePath
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fileInfo
operator|.
name|filePath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|fileInfo
operator|.
name|filePath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|||
name|fileInfo
operator|.
name|filePath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
condition|)
name|fileInfo
operator|.
name|filePath
operator|=
name|fileInfo
operator|.
name|filePath
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fileInfo
operator|.
name|filePath
operator|.
name|isEmpty
argument_list|()
operator|&&
name|fileInfo
operator|.
name|filePath
operator|.
name|at
argument_list|(
name|fileInfo
operator|.
name|filePath
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|fileInfo
operator|.
name|filePath
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QZipReaderPrivate
class|class
name|QZipReaderPrivate
super|:
specifier|public
name|QZipPrivate
block|{
public|public:
DECL|function|QZipReaderPrivate
name|QZipReaderPrivate
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|bool
name|ownDev
parameter_list|)
member_init_list|:
name|QZipPrivate
argument_list|(
name|device
argument_list|,
name|ownDev
argument_list|)
member_init_list|,
name|status
argument_list|(
name|QZipReader
operator|::
name|NoError
argument_list|)
block|{     }
name|void
name|scanFiles
parameter_list|()
function_decl|;
DECL|member|status
name|QZipReader
operator|::
name|Status
name|status
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QZipWriterPrivate
class|class
name|QZipWriterPrivate
super|:
specifier|public
name|QZipPrivate
block|{
public|public:
DECL|function|QZipWriterPrivate
name|QZipWriterPrivate
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|bool
name|ownDev
parameter_list|)
member_init_list|:
name|QZipPrivate
argument_list|(
name|device
argument_list|,
name|ownDev
argument_list|)
member_init_list|,
name|status
argument_list|(
name|QZipWriter
operator|::
name|NoError
argument_list|)
member_init_list|,
name|permissions
argument_list|(
name|QFile
operator|::
name|ReadOwner
operator||
name|QFile
operator|::
name|WriteOwner
argument_list|)
member_init_list|,
name|compressionPolicy
argument_list|(
name|QZipWriter
operator|::
name|AlwaysCompress
argument_list|)
block|{     }
DECL|member|status
name|QZipWriter
operator|::
name|Status
name|status
decl_stmt|;
DECL|member|permissions
name|QFile
operator|::
name|Permissions
name|permissions
decl_stmt|;
DECL|member|compressionPolicy
name|QZipWriter
operator|::
name|CompressionPolicy
name|compressionPolicy
decl_stmt|;
DECL|enum|EntryType
DECL|enumerator|Directory
DECL|enumerator|File
DECL|enumerator|Symlink
enum|enum
name|EntryType
block|{
name|Directory
block|,
name|File
block|,
name|Symlink
block|}
enum|;
name|void
name|addEntry
parameter_list|(
name|EntryType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|contents
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|toLocalHeader
name|LocalFileHeader
name|CentralFileHeader
operator|::
name|toLocalHeader
parameter_list|()
specifier|const
block|{
name|LocalFileHeader
name|h
decl_stmt|;
name|writeUInt
argument_list|(
name|h
operator|.
name|signature
argument_list|,
literal|0x04034b50
argument_list|)
expr_stmt|;
name|copyUShort
argument_list|(
name|h
operator|.
name|version_needed
argument_list|,
name|version_needed
argument_list|)
expr_stmt|;
name|copyUShort
argument_list|(
name|h
operator|.
name|general_purpose_bits
argument_list|,
name|general_purpose_bits
argument_list|)
expr_stmt|;
name|copyUShort
argument_list|(
name|h
operator|.
name|compression_method
argument_list|,
name|compression_method
argument_list|)
expr_stmt|;
name|copyUInt
argument_list|(
name|h
operator|.
name|last_mod_file
argument_list|,
name|last_mod_file
argument_list|)
expr_stmt|;
name|copyUInt
argument_list|(
name|h
operator|.
name|crc_32
argument_list|,
name|crc_32
argument_list|)
expr_stmt|;
name|copyUInt
argument_list|(
name|h
operator|.
name|compressed_size
argument_list|,
name|compressed_size
argument_list|)
expr_stmt|;
name|copyUInt
argument_list|(
name|h
operator|.
name|uncompressed_size
argument_list|,
name|uncompressed_size
argument_list|)
expr_stmt|;
name|copyUShort
argument_list|(
name|h
operator|.
name|file_name_length
argument_list|,
name|file_name_length
argument_list|)
expr_stmt|;
name|copyUShort
argument_list|(
name|h
operator|.
name|extra_field_length
argument_list|,
name|extra_field_length
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function
begin_function
DECL|function|scanFiles
name|void
name|QZipReaderPrivate
operator|::
name|scanFiles
parameter_list|()
block|{
if|if
condition|(
operator|!
name|dirtyFileTree
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|device
operator|->
name|isOpen
argument_list|()
operator|||
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|)
condition|)
block|{
name|status
operator|=
name|QZipReader
operator|::
name|FileOpenError
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|device
operator|->
name|openMode
argument_list|()
operator|&
name|QIODevice
operator|::
name|ReadOnly
operator|)
operator|==
literal|0
condition|)
block|{
comment|// only read the index from readable files.
name|status
operator|=
name|QZipReader
operator|::
name|FileReadError
expr_stmt|;
return|return;
block|}
name|dirtyFileTree
operator|=
literal|false
expr_stmt|;
name|uchar
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|device
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|readUInt
argument_list|(
name|tmp
argument_list|)
operator|!=
literal|0x04034b50
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: not a zip file!"
expr_stmt|;
return|return;
block|}
comment|// find EndOfDirectory header
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|start_of_directory
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|num_dir_entries
init|=
literal|0
decl_stmt|;
name|EndOfDirectory
name|eod
decl_stmt|;
while|while
condition|(
name|start_of_directory
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|int
name|pos
init|=
name|device
operator|->
name|size
argument_list|()
operator|-
name|int
argument_list|(
sizeof|sizeof
argument_list|(
name|EndOfDirectory
argument_list|)
argument_list|)
operator|-
name|i
decl_stmt|;
if|if
condition|(
name|pos
argument_list|<
literal|0
operator|||
name|i
argument_list|>
literal|65535
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: EndOfDirectory not found"
expr_stmt|;
return|return;
block|}
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|device
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eod
argument_list|,
sizeof|sizeof
argument_list|(
name|EndOfDirectory
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readUInt
argument_list|(
name|eod
operator|.
name|signature
argument_list|)
operator|==
literal|0x06054b50
condition|)
break|break;
operator|++
name|i
expr_stmt|;
block|}
comment|// have the eod
name|start_of_directory
operator|=
name|readUInt
argument_list|(
name|eod
operator|.
name|dir_start_offset
argument_list|)
expr_stmt|;
name|num_dir_entries
operator|=
name|readUShort
argument_list|(
name|eod
operator|.
name|num_dir_entries
argument_list|)
expr_stmt|;
name|ZDEBUG
argument_list|(
literal|"start_of_directory at %d, num_dir_entries=%d"
argument_list|,
name|start_of_directory
argument_list|,
name|num_dir_entries
argument_list|)
expr_stmt|;
name|int
name|comment_length
init|=
name|readUShort
argument_list|(
name|eod
operator|.
name|comment_length
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment_length
operator|!=
name|i
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QZip: failed to parse zip file."
expr_stmt|;
name|comment
operator|=
name|device
operator|->
name|read
argument_list|(
name|qMin
argument_list|(
name|comment_length
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|->
name|seek
argument_list|(
name|start_of_directory
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dir_entries
condition|;
operator|++
name|i
control|)
block|{
name|FileHeader
name|header
decl_stmt|;
name|int
name|read
init|=
name|device
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
operator|.
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|CentralFileHeader
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|CentralFileHeader
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: Failed to read complete header, index may be incomplete"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|signature
argument_list|)
operator|!=
literal|0x02014b50
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: invalid header signature, index may be incomplete"
expr_stmt|;
break|break;
block|}
name|int
name|l
init|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|file_name_length
argument_list|)
decl_stmt|;
name|header
operator|.
name|file_name
operator|=
name|device
operator|->
name|read
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|file_name
operator|.
name|length
argument_list|()
operator|!=
name|l
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: Failed to read filename from zip index, index may be incomplete"
expr_stmt|;
break|break;
block|}
name|l
operator|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|extra_field_length
argument_list|)
expr_stmt|;
name|header
operator|.
name|extra_field
operator|=
name|device
operator|->
name|read
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|extra_field
operator|.
name|length
argument_list|()
operator|!=
name|l
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: Failed to read extra field in zip file, skipping file, index may be incomplete"
expr_stmt|;
break|break;
block|}
name|l
operator|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|file_comment_length
argument_list|)
expr_stmt|;
name|header
operator|.
name|file_comment
operator|=
name|device
operator|->
name|read
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|file_comment
operator|.
name|length
argument_list|()
operator|!=
name|l
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QZip: Failed to read read file comment, index may be incomplete"
expr_stmt|;
break|break;
block|}
name|ZDEBUG
argument_list|(
literal|"found file '%s'"
argument_list|,
name|header
operator|.
name|file_name
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|fileHeaders
operator|.
name|append
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addEntry
name|void
name|QZipWriterPrivate
operator|::
name|addEntry
parameter_list|(
name|EntryType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|contents
comment|/*, QFile::Permissions permissions, QZip::Method m*/
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
specifier|static
specifier|const
name|char
modifier|*
name|entryTypes
index|[]
init|=
block|{
literal|"directory"
block|,
literal|"file     "
block|,
literal|"symlink  "
block|}
decl_stmt|;
name|ZDEBUG
argument_list|()
operator|<<
literal|"adding"
operator|<<
name|entryTypes
index|[
name|type
index|]
operator|<<
literal|":"
operator|<<
name|fileName
operator|.
name|toUtf8
argument_list|()
operator|.
name|data
argument_list|()
operator|<<
operator|(
name|type
operator|==
literal|2
condition|?
name|QByteArray
argument_list|(
literal|" -> "
operator|+
name|contents
argument_list|)
operator|.
name|constData
argument_list|()
else|:
literal|""
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|device
operator|->
name|isOpen
argument_list|()
operator|||
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
operator|)
condition|)
block|{
name|status
operator|=
name|QZipWriter
operator|::
name|FileOpenError
expr_stmt|;
return|return;
block|}
name|device
operator|->
name|seek
argument_list|(
name|start_of_directory
argument_list|)
expr_stmt|;
comment|// don't compress small files
name|QZipWriter
operator|::
name|CompressionPolicy
name|compression
init|=
name|compressionPolicy
decl_stmt|;
if|if
condition|(
name|compressionPolicy
operator|==
name|QZipWriter
operator|::
name|AutoCompress
condition|)
block|{
if|if
condition|(
name|contents
operator|.
name|length
argument_list|()
operator|<
literal|64
condition|)
name|compression
operator|=
name|QZipWriter
operator|::
name|NeverCompress
expr_stmt|;
else|else
name|compression
operator|=
name|QZipWriter
operator|::
name|AlwaysCompress
expr_stmt|;
block|}
name|FileHeader
name|header
decl_stmt|;
name|memset
argument_list|(
operator|&
name|header
operator|.
name|h
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CentralFileHeader
argument_list|)
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|signature
argument_list|,
literal|0x02014b50
argument_list|)
expr_stmt|;
name|writeUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|version_needed
argument_list|,
name|ZIP_VERSION
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|uncompressed_size
argument_list|,
name|contents
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|writeMSDosDate
argument_list|(
name|header
operator|.
name|h
operator|.
name|last_mod_file
argument_list|,
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|data
init|=
name|contents
decl_stmt|;
if|if
condition|(
name|compression
operator|==
name|QZipWriter
operator|::
name|AlwaysCompress
condition|)
block|{
name|writeUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|compression_method
argument_list|,
name|CompressionMethodDeflated
argument_list|)
expr_stmt|;
name|ulong
name|len
init|=
name|contents
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// shamelessly copied form zlib
name|len
operator|+=
operator|(
name|len
operator|>>
literal|12
operator|)
operator|+
operator|(
name|len
operator|>>
literal|14
operator|)
operator|+
literal|11
expr_stmt|;
name|int
name|res
decl_stmt|;
do|do
block|{
name|data
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|res
operator|=
name|deflate
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|data
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|len
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|contents
operator|.
name|constData
argument_list|()
argument_list|,
name|contents
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|Z_OK
case|:
name|data
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|qWarning
argument_list|(
literal|"QZip: Z_MEM_ERROR: Not enough memory to compress file, skipping"
argument_list|)
expr_stmt|;
name|data
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
name|len
operator|*=
literal|2
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|res
operator|==
name|Z_BUF_ERROR
condition|)
do|;
block|}
comment|// TODO add a check if data.length()> contents.length().  Then try to store the original and revert the compression method to be uncompressed
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|compressed_size
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|uint
name|crc_32
init|=
operator|::
name|crc32
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|crc_32
operator|=
operator|::
name|crc32
argument_list|(
name|crc_32
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|contents
operator|.
name|constData
argument_list|()
argument_list|,
name|contents
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|crc_32
argument_list|,
name|crc_32
argument_list|)
expr_stmt|;
comment|// if bit 11 is set, the filename and comment fields must be encoded using UTF-8
name|ushort
name|general_purpose_bits
init|=
name|Utf8Names
decl_stmt|;
comment|// always use utf-8
name|writeUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|general_purpose_bits
argument_list|,
name|general_purpose_bits
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|inUtf8
init|=
operator|(
name|general_purpose_bits
operator|&
name|Utf8Names
operator|)
operator|!=
literal|0
decl_stmt|;
name|header
operator|.
name|file_name
operator|=
name|inUtf8
condition|?
name|fileName
operator|.
name|toUtf8
argument_list|()
else|:
name|fileName
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|file_name
operator|.
name|size
argument_list|()
operator|>
literal|0xffff
condition|)
block|{
name|qWarning
argument_list|(
literal|"QZip: Filename is too long, chopping it to 65535 bytes"
argument_list|)
expr_stmt|;
name|header
operator|.
name|file_name
operator|=
name|header
operator|.
name|file_name
operator|.
name|left
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
comment|// ### don't break the utf-8 sequence, if any
block|}
if|if
condition|(
name|header
operator|.
name|file_comment
operator|.
name|size
argument_list|()
operator|+
name|header
operator|.
name|file_name
operator|.
name|size
argument_list|()
operator|>
literal|0xffff
condition|)
block|{
name|qWarning
argument_list|(
literal|"QZip: File comment is too long, chopping it to 65535 bytes"
argument_list|)
expr_stmt|;
name|header
operator|.
name|file_comment
operator|.
name|truncate
argument_list|(
literal|0xffff
operator|-
name|header
operator|.
name|file_name
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### don't break the utf-8 sequence, if any
block|}
name|writeUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|file_name_length
argument_list|,
name|header
operator|.
name|file_name
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|//h.extra_field_length[2];
name|writeUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|version_made
argument_list|,
name|HostUnix
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|//uchar internal_file_attributes[2];
comment|//uchar external_file_attributes[4];
name|quint32
name|mode
init|=
name|permissionsToMode
argument_list|(
name|permissions
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|File
case|:
name|mode
operator||=
name|S_IFREG
expr_stmt|;
break|break;
case|case
name|Directory
case|:
name|mode
operator||=
name|S_IFDIR
expr_stmt|;
break|break;
case|case
name|Symlink
case|:
name|mode
operator||=
name|S_IFLNK
expr_stmt|;
break|break;
block|}
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|external_file_attributes
argument_list|,
name|mode
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|offset_local_header
argument_list|,
name|start_of_directory
argument_list|)
expr_stmt|;
name|fileHeaders
operator|.
name|append
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|LocalFileHeader
name|h
init|=
name|header
operator|.
name|h
operator|.
name|toLocalHeader
argument_list|()
decl_stmt|;
name|device
operator|->
name|write
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalFileHeader
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|->
name|write
argument_list|(
name|header
operator|.
name|file_name
argument_list|)
expr_stmt|;
name|device
operator|->
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|start_of_directory
operator|=
name|device
operator|->
name|pos
argument_list|()
expr_stmt|;
name|dirtyFileTree
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|//////////////////////////////  Reader
end_comment
begin_comment
comment|/*!     \class QZipReader::FileInfo     \internal     Represents one entry in the zip table of contents. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::filePath     The full filepath inside the archive. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::isDir     A boolean type indicating if the entry is a directory. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::isFile     A boolean type, if it is one this entry is a file. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::isSymLink     A boolean type, if it is one this entry is symbolic link. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::permissions     A list of flags for the permissions of this entry. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::crc     The calculated checksum as a crc type. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::size     The total size of the unpacked content. */
end_comment
begin_comment
comment|/*!     \variable FileInfo::d     \internal     private pointer. */
end_comment
begin_comment
comment|/*!     \class QZipReader     \internal     \since 4.5      \brief the QZipReader class provides a way to inspect the contents of a zip     archive and extract individual files from it.      QZipReader can be used to read a zip archive either from a file or from any     device. An in-memory QBuffer for instance.  The reader can be used to read     which files are in the archive using fileInfoList() and entryInfoAt() but     also to extract individual files using fileData() or even to extract all     files in the archive using extractAll() */
end_comment
begin_comment
comment|/*!     Create a new zip archive that operates on the \a fileName.  The file will be     opened with the \a mode. */
end_comment
begin_constructor
DECL|function|QZipReader
name|QZipReader
operator|::
name|QZipReader
parameter_list|(
specifier|const
name|QString
modifier|&
name|archive
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|mode
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QFile
argument_list|>
name|f
argument_list|(
operator|new
name|QFile
argument_list|(
name|archive
argument_list|)
argument_list|)
decl_stmt|;
name|f
operator|->
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|QZipReader
operator|::
name|Status
name|status
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
name|status
operator|=
name|NoError
expr_stmt|;
else|else
block|{
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|ReadError
condition|)
name|status
operator|=
name|FileReadError
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|OpenError
condition|)
name|status
operator|=
name|FileOpenError
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|PermissionsError
condition|)
name|status
operator|=
name|FilePermissionsError
expr_stmt|;
else|else
name|status
operator|=
name|FileError
expr_stmt|;
block|}
name|d
operator|=
operator|new
name|QZipReaderPrivate
argument_list|(
name|f
operator|.
name|data
argument_list|()
argument_list|,
comment|/*ownDevice=*/
literal|true
argument_list|)
expr_stmt|;
name|f
operator|.
name|take
argument_list|()
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|status
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Create a new zip archive that operates on the archive found in \a device.     You have to open the device previous to calling the constructor and only a     device that is readable will be scanned for zip filecontent.  */
end_comment
begin_constructor
DECL|function|QZipReader
name|QZipReader
operator|::
name|QZipReader
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QZipReaderPrivate
argument_list|(
name|device
argument_list|,
comment|/*ownDevice=*/
literal|false
argument_list|)
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Desctructor */
end_comment
begin_destructor
DECL|function|~QZipReader
name|QZipReader
operator|::
name|~
name|QZipReader
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns device used for reading zip archive. */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QZipReader
operator|::
name|device
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the user can read the file; otherwise returns false. */
end_comment
begin_function
DECL|function|isReadable
name|bool
name|QZipReader
operator|::
name|isReadable
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
operator|->
name|isReadable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file exists; otherwise returns false. */
end_comment
begin_function
DECL|function|exists
name|bool
name|QZipReader
operator|::
name|exists
parameter_list|()
specifier|const
block|{
name|QFile
modifier|*
name|f
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|true
return|;
return|return
name|f
operator|->
name|exists
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of files the archive contains. */
end_comment
begin_function
DECL|function|fileInfoList
name|QList
argument_list|<
name|QZipReader
operator|::
name|FileInfo
argument_list|>
name|QZipReader
operator|::
name|fileInfoList
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|scanFiles
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QZipReader
operator|::
name|FileInfo
argument_list|>
name|files
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QZipReader
operator|::
name|FileInfo
name|fi
decl_stmt|;
name|d
operator|->
name|fillFileInfo
argument_list|(
name|i
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|files
operator|.
name|append
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
end_function
begin_comment
comment|/*!     Return the number of items in the zip archive. */
end_comment
begin_function
DECL|function|count
name|int
name|QZipReader
operator|::
name|count
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|scanFiles
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|fileHeaders
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a FileInfo of an entry in the zipfile.     The \a index is the index into the directory listing of the zipfile.     Returns an invalid FileInfo if \a index is out of boundaries.      \sa fileInfoList() */
end_comment
begin_function
DECL|function|entryInfoAt
name|QZipReader
operator|::
name|FileInfo
name|QZipReader
operator|::
name|entryInfoAt
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|scanFiles
argument_list|()
expr_stmt|;
name|QZipReader
operator|::
name|FileInfo
name|fi
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|d
operator|->
name|fileHeaders
operator|.
name|count
argument_list|()
condition|)
name|d
operator|->
name|fillFileInfo
argument_list|(
name|index
argument_list|,
name|fi
argument_list|)
expr_stmt|;
return|return
name|fi
return|;
block|}
end_function
begin_comment
comment|/*!     Fetch the file contents from the zip archive and return the uncompressed bytes. */
end_comment
begin_function
DECL|function|fileData
name|QByteArray
name|QZipReader
operator|::
name|fileData
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|scanFiles
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|d
operator|->
name|fileHeaders
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|file_name
argument_list|)
operator|==
name|fileName
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|FileHeader
name|header
init|=
name|d
operator|->
name|fileHeaders
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ushort
name|version_needed
init|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|version_needed
argument_list|)
decl_stmt|;
if|if
condition|(
name|version_needed
operator|>
name|ZIP_VERSION
condition|)
block|{
name|qWarning
argument_list|(
literal|"QZip: .ZIP specification version %d implementationis needed to extract the data."
argument_list|,
name|version_needed
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|ushort
name|general_purpose_bits
init|=
name|readUShort
argument_list|(
name|header
operator|.
name|h
operator|.
name|general_purpose_bits
argument_list|)
decl_stmt|;
name|int
name|compressed_size
init|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|compressed_size
argument_list|)
decl_stmt|;
name|int
name|uncompressed_size
init|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|uncompressed_size
argument_list|)
decl_stmt|;
name|int
name|start
init|=
name|readUInt
argument_list|(
name|header
operator|.
name|h
operator|.
name|offset_local_header
argument_list|)
decl_stmt|;
comment|//qDebug("uncompressing file %d: local header at %d", i, start);
name|d
operator|->
name|device
operator|->
name|seek
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|LocalFileHeader
name|lh
decl_stmt|;
name|d
operator|->
name|device
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lh
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalFileHeader
argument_list|)
argument_list|)
expr_stmt|;
name|uint
name|skip
init|=
name|readUShort
argument_list|(
name|lh
operator|.
name|file_name_length
argument_list|)
operator|+
name|readUShort
argument_list|(
name|lh
operator|.
name|extra_field_length
argument_list|)
decl_stmt|;
name|d
operator|->
name|device
operator|->
name|seek
argument_list|(
name|d
operator|->
name|device
operator|->
name|pos
argument_list|()
operator|+
name|skip
argument_list|)
expr_stmt|;
name|int
name|compression_method
init|=
name|readUShort
argument_list|(
name|lh
operator|.
name|compression_method
argument_list|)
decl_stmt|;
comment|//qDebug("file=%s: compressed_size=%d, uncompressed_size=%d", fileName.toLocal8Bit().data(), compressed_size, uncompressed_size);
if|if
condition|(
operator|(
name|general_purpose_bits
operator|&
name|Encrypted
operator|)
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QZip: Unsupported encryption method is needed to extract the data."
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
comment|//qDebug("file at %lld", d->device->pos());
name|QByteArray
name|compressed
init|=
name|d
operator|->
name|device
operator|->
name|read
argument_list|(
name|compressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|compression_method
operator|==
name|CompressionMethodStored
condition|)
block|{
comment|// no compression
name|compressed
operator|.
name|truncate
argument_list|(
name|uncompressed_size
argument_list|)
expr_stmt|;
return|return
name|compressed
return|;
block|}
elseif|else
if|if
condition|(
name|compression_method
operator|==
name|CompressionMethodDeflated
condition|)
block|{
comment|// Deflate
comment|//qDebug("compressed=%d", compressed.size());
name|compressed
operator|.
name|truncate
argument_list|(
name|compressed_size
argument_list|)
expr_stmt|;
name|QByteArray
name|baunzip
decl_stmt|;
name|ulong
name|len
init|=
name|qMax
argument_list|(
name|uncompressed_size
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
do|do
block|{
name|baunzip
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|res
operator|=
name|inflate
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|baunzip
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|compressed
operator|.
name|constData
argument_list|()
argument_list|,
name|compressed_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|Z_OK
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|!=
name|baunzip
operator|.
name|size
argument_list|()
condition|)
name|baunzip
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|qWarning
argument_list|(
literal|"QZip: Z_MEM_ERROR: Not enough memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
name|len
operator|*=
literal|2
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|qWarning
argument_list|(
literal|"QZip: Z_DATA_ERROR: Input data is corrupted"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|res
operator|==
name|Z_BUF_ERROR
condition|)
do|;
return|return
name|baunzip
return|;
block|}
name|qWarning
argument_list|(
literal|"QZip: Unsupported compression method %d is needed to extract the data."
argument_list|,
name|compression_method
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Extracts the full contents of the zip file into \a destinationDir on     the local filesystem.     In case writing or linking a file fails, the extraction will be aborted. */
end_comment
begin_function
DECL|function|extractAll
name|bool
name|QZipReader
operator|::
name|extractAll
parameter_list|(
specifier|const
name|QString
modifier|&
name|destinationDir
parameter_list|)
specifier|const
block|{
name|QDir
name|baseDir
argument_list|(
name|destinationDir
argument_list|)
decl_stmt|;
comment|// create directories first
name|QList
argument_list|<
name|FileInfo
argument_list|>
name|allFiles
init|=
name|fileInfoList
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|FileInfo
modifier|&
name|fi
decl|,
name|allFiles
control|)
block|{
specifier|const
name|QString
name|absPath
init|=
name|destinationDir
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|fi
operator|.
name|filePath
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isDir
condition|)
block|{
if|if
condition|(
operator|!
name|baseDir
operator|.
name|mkpath
argument_list|(
name|fi
operator|.
name|filePath
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|setPermissions
argument_list|(
name|absPath
argument_list|,
name|fi
operator|.
name|permissions
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// set up symlinks
foreach|foreach
control|(
specifier|const
name|FileInfo
modifier|&
name|fi
decl|,
name|allFiles
control|)
block|{
specifier|const
name|QString
name|absPath
init|=
name|destinationDir
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|fi
operator|.
name|filePath
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isSymLink
condition|)
block|{
name|QString
name|destination
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|fileData
argument_list|(
name|fi
operator|.
name|filePath
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|destination
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QFileInfo
name|linkFi
argument_list|(
name|absPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|linkFi
operator|.
name|absolutePath
argument_list|()
argument_list|)
condition|)
name|QDir
operator|::
name|root
argument_list|()
operator|.
name|mkpath
argument_list|(
name|linkFi
operator|.
name|absolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|link
argument_list|(
name|destination
argument_list|,
name|absPath
argument_list|)
condition|)
return|return
literal|false
return|;
comment|/* cannot change permission of links             if (!QFile::setPermissions(absPath, fi.permissions))                 return false;             */
block|}
block|}
foreach|foreach
control|(
specifier|const
name|FileInfo
modifier|&
name|fi
decl|,
name|allFiles
control|)
block|{
specifier|const
name|QString
name|absPath
init|=
name|destinationDir
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|fi
operator|.
name|filePath
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isFile
condition|)
block|{
name|QFile
name|f
argument_list|(
name|absPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
condition|)
return|return
literal|false
return|;
name|f
operator|.
name|write
argument_list|(
name|fileData
argument_list|(
name|fi
operator|.
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|setPermissions
argument_list|(
name|fi
operator|.
name|permissions
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QZipReader::Status      The following status values are possible:      \value NoError  No error occurred.     \value FileReadError    An error occurred when reading from the file.     \value FileOpenError    The file could not be opened.     \value FilePermissionsError The file could not be accessed.     \value FileError        Another file error occurred. */
end_comment
begin_comment
comment|/*!     Returns a status code indicating the first error that was met by QZipReader,     or QZipReader::NoError if no error occurred. */
end_comment
begin_function
DECL|function|status
name|QZipReader
operator|::
name|Status
name|QZipReader
operator|::
name|status
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|status
return|;
block|}
end_function
begin_comment
comment|/*!     Close the zip file. */
end_comment
begin_function
DECL|function|close
name|void
name|QZipReader
operator|::
name|close
parameter_list|()
block|{
name|d
operator|->
name|device
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|////////////////////////////// Writer
end_comment
begin_comment
comment|/*!     \class QZipWriter     \internal     \since 4.5      \brief the QZipWriter class provides a way to create a new zip archive.      QZipWriter can be used to create a zip archive containing any number of files     and directories. The files in the archive will be compressed in a way that is     compatible with common zip reader applications. */
end_comment
begin_comment
comment|/*!     Create a new zip archive that operates on the \a archive filename.  The file will     be opened with the \a mode.     \sa isValid() */
end_comment
begin_constructor
DECL|function|QZipWriter
name|QZipWriter
operator|::
name|QZipWriter
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|mode
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QFile
argument_list|>
name|f
argument_list|(
operator|new
name|QFile
argument_list|(
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|f
operator|->
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|QZipWriter
operator|::
name|Status
name|status
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
name|status
operator|=
name|QZipWriter
operator|::
name|NoError
expr_stmt|;
else|else
block|{
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|WriteError
condition|)
name|status
operator|=
name|QZipWriter
operator|::
name|FileWriteError
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|OpenError
condition|)
name|status
operator|=
name|QZipWriter
operator|::
name|FileOpenError
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|PermissionsError
condition|)
name|status
operator|=
name|QZipWriter
operator|::
name|FilePermissionsError
expr_stmt|;
else|else
name|status
operator|=
name|QZipWriter
operator|::
name|FileError
expr_stmt|;
block|}
name|d
operator|=
operator|new
name|QZipWriterPrivate
argument_list|(
name|f
operator|.
name|data
argument_list|()
argument_list|,
comment|/*ownDevice=*/
literal|true
argument_list|)
expr_stmt|;
name|f
operator|.
name|take
argument_list|()
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|status
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Create a new zip archive that operates on the archive found in \a device.     You have to open the device previous to calling the constructor and     only a device that is readable will be scanned for zip filecontent.  */
end_comment
begin_constructor
DECL|function|QZipWriter
name|QZipWriter
operator|::
name|QZipWriter
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QZipWriterPrivate
argument_list|(
name|device
argument_list|,
comment|/*ownDevice=*/
literal|false
argument_list|)
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QZipWriter
name|QZipWriter
operator|::
name|~
name|QZipWriter
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns device used for writing zip archive. */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QZipWriter
operator|::
name|device
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the user can write to the archive; otherwise returns false. */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QZipWriter
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
operator|->
name|isWritable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file exists; otherwise returns false. */
end_comment
begin_function
DECL|function|exists
name|bool
name|QZipWriter
operator|::
name|exists
parameter_list|()
specifier|const
block|{
name|QFile
modifier|*
name|f
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|true
return|;
return|return
name|f
operator|->
name|exists
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QZipWriter::Status      The following status values are possible:      \value NoError  No error occurred.     \value FileWriteError    An error occurred when writing to the device.     \value FileOpenError    The file could not be opened.     \value FilePermissionsError The file could not be accessed.     \value FileError        Another file error occurred. */
end_comment
begin_comment
comment|/*!     Returns a status code indicating the first error that was met by QZipWriter,     or QZipWriter::NoError if no error occurred. */
end_comment
begin_function
DECL|function|status
name|QZipWriter
operator|::
name|Status
name|QZipWriter
operator|::
name|status
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|status
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QZipWriter::CompressionPolicy      \value AlwaysCompress   A file that is added is compressed.     \value NeverCompress    A file that is added will be stored without changes.     \value AutoCompress     A file that is added will be compressed only if that will give a smaller file. */
end_comment
begin_comment
comment|/*!      Sets the policy for compressing newly added files to the new \a policy.      \note the default policy is AlwaysCompress      \sa compressionPolicy()     \sa addFile() */
end_comment
begin_function
DECL|function|setCompressionPolicy
name|void
name|QZipWriter
operator|::
name|setCompressionPolicy
parameter_list|(
name|CompressionPolicy
name|policy
parameter_list|)
block|{
name|d
operator|->
name|compressionPolicy
operator|=
name|policy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      Returns the currently set compression policy.     \sa setCompressionPolicy()     \sa addFile() */
end_comment
begin_function
DECL|function|compressionPolicy
name|QZipWriter
operator|::
name|CompressionPolicy
name|QZipWriter
operator|::
name|compressionPolicy
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|compressionPolicy
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the permissions that will be used for newly added files.      \note the default permissions are QFile::ReadOwner | QFile::WriteOwner.      \sa creationPermissions()     \sa addFile() */
end_comment
begin_function
DECL|function|setCreationPermissions
name|void
name|QZipWriter
operator|::
name|setCreationPermissions
parameter_list|(
name|QFile
operator|::
name|Permissions
name|permissions
parameter_list|)
block|{
name|d
operator|->
name|permissions
operator|=
name|permissions
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      Returns the currently set creation permissions.      \sa setCreationPermissions()     \sa addFile() */
end_comment
begin_function
DECL|function|creationPermissions
name|QFile
operator|::
name|Permissions
name|QZipWriter
operator|::
name|creationPermissions
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|permissions
return|;
block|}
end_function
begin_comment
comment|/*!     Add a file to the archive with \a data as the file contents.     The file will be stored in the archive using the \a fileName which     includes the full path in the archive.      The new file will get the file permissions based on the current     creationPermissions and it will be compressed using the zip compression     based on the current compression policy.      \sa setCreationPermissions()     \sa setCompressionPolicy() */
end_comment
begin_function
DECL|function|addFile
name|void
name|QZipWriter
operator|::
name|addFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|d
operator|->
name|addEntry
argument_list|(
name|QZipWriterPrivate
operator|::
name|File
argument_list|,
name|fileName
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Add a file to the archive with \a device as the source of the contents.     The contents returned from QIODevice::readAll() will be used as the     filedata.     The file will be stored in the archive using the \a fileName which     includes the full path in the archive. */
end_comment
begin_function
DECL|function|addFile
name|void
name|QZipWriter
operator|::
name|addFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|QIODevice
operator|::
name|OpenMode
name|mode
init|=
name|device
operator|->
name|openMode
argument_list|()
decl_stmt|;
name|bool
name|opened
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|QIODevice
operator|::
name|ReadOnly
operator|)
operator|==
literal|0
condition|)
block|{
name|opened
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|FileOpenError
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|addEntry
argument_list|(
name|QZipWriterPrivate
operator|::
name|File
argument_list|,
name|fileName
argument_list|,
name|device
operator|->
name|readAll
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opened
condition|)
name|device
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Create a new directory in the archive with the specified \a dirName and     the \a permissions; */
end_comment
begin_function
DECL|function|addDirectory
name|void
name|QZipWriter
operator|::
name|addDirectory
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|)
block|{
name|QString
name|name
init|=
name|dirName
decl_stmt|;
comment|// separator is mandatory
if|if
condition|(
operator|!
name|name
operator|.
name|endsWith
argument_list|(
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
condition|)
name|name
operator|.
name|append
argument_list|(
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|addEntry
argument_list|(
name|QZipWriterPrivate
operator|::
name|Directory
argument_list|,
name|name
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Create a new symbolic link in the archive with the specified \a dirName     and the \a permissions;     A symbolic link contains the destination (relative) path and name. */
end_comment
begin_function
DECL|function|addSymLink
name|void
name|QZipWriter
operator|::
name|addSymLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|destination
parameter_list|)
block|{
name|d
operator|->
name|addEntry
argument_list|(
name|QZipWriterPrivate
operator|::
name|Symlink
argument_list|,
name|fileName
argument_list|,
name|QFile
operator|::
name|encodeName
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    Closes the zip file. */
end_comment
begin_function
DECL|function|close
name|void
name|QZipWriter
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|device
operator|->
name|openMode
argument_list|()
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|)
block|{
name|d
operator|->
name|device
operator|->
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
comment|//qDebug("QZip::close writing directory, %d entries", d->fileHeaders.size());
name|d
operator|->
name|device
operator|->
name|seek
argument_list|(
name|d
operator|->
name|start_of_directory
argument_list|)
expr_stmt|;
comment|// write new directory
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FileHeader
modifier|&
name|header
init|=
name|d
operator|->
name|fileHeaders
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|header
operator|.
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|CentralFileHeader
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
name|header
operator|.
name|file_name
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
name|header
operator|.
name|extra_field
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
name|header
operator|.
name|file_comment
argument_list|)
expr_stmt|;
block|}
name|int
name|dir_size
init|=
name|d
operator|->
name|device
operator|->
name|pos
argument_list|()
operator|-
name|d
operator|->
name|start_of_directory
decl_stmt|;
comment|// write end of directory
name|EndOfDirectory
name|eod
decl_stmt|;
name|memset
argument_list|(
operator|&
name|eod
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EndOfDirectory
argument_list|)
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|eod
operator|.
name|signature
argument_list|,
literal|0x06054b50
argument_list|)
expr_stmt|;
comment|//uchar this_disk[2];
comment|//uchar start_of_directory_disk[2];
name|writeUShort
argument_list|(
name|eod
operator|.
name|num_dir_entries_this_disk
argument_list|,
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|writeUShort
argument_list|(
name|eod
operator|.
name|num_dir_entries
argument_list|,
name|d
operator|->
name|fileHeaders
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|eod
operator|.
name|directory_size
argument_list|,
name|dir_size
argument_list|)
expr_stmt|;
name|writeUInt
argument_list|(
name|eod
operator|.
name|dir_start_offset
argument_list|,
name|d
operator|->
name|start_of_directory
argument_list|)
expr_stmt|;
name|writeUShort
argument_list|(
name|eod
operator|.
name|comment_length
argument_list|,
name|d
operator|->
name|comment
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|eod
argument_list|,
sizeof|sizeof
argument_list|(
name|EndOfDirectory
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|write
argument_list|(
name|d
operator|->
name|comment
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTODFWRITER
end_comment
end_unit
