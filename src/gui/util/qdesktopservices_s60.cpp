begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qurl.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_symbian_p.h>
end_include
begin_include
include|#
directive|include
file|<f32file.h>
end_include
begin_comment
comment|// TDriveUnit etc
end_comment
begin_include
include|#
directive|include
file|<pathinfo.h>
end_include
begin_comment
comment|// PathInfo
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_SCHEMEHANDLER
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_S60
end_ifdef
begin_comment
comment|// This flag changes the implementation to use S60 CDcoumentHandler
end_comment
begin_comment
comment|// instead of apparc when opening the files
end_comment
begin_define
DECL|macro|USE_DOCUMENTHANDLER
define|#
directive|define
name|USE_DOCUMENTHANDLER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<txtrich.h>
end_include
begin_comment
comment|// CRichText
end_comment
begin_include
include|#
directive|include
file|<eikenv.h>
end_include
begin_comment
comment|// CEikonEnv
end_comment
begin_include
include|#
directive|include
file|<apgcli.h>
end_include
begin_comment
comment|// RApaLsSession
end_comment
begin_include
include|#
directive|include
file|<apgtask.h>
end_include
begin_comment
comment|// TApaTaskList, TApaTask
end_comment
begin_include
include|#
directive|include
file|<rsendas.h>
end_include
begin_comment
comment|// RSendAs
end_comment
begin_include
include|#
directive|include
file|<rsendasmessage.h>
end_include
begin_comment
comment|// RSendAsMessage
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|USE_DOCUMENTHANDLER
end_ifdef
begin_include
include|#
directive|include
file|<DocumentHandler.h>
end_include
begin_comment
comment|// CDocumentHandler
end_comment
begin_include
include|#
directive|include
file|<AknServerApp.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|// USE_SCHEMEHANDLER
end_comment
begin_include
include|#
directive|include
file|<schemehandler.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|_LIT
argument_list|(
name|KCacheSubDir
argument_list|,
literal|"Cache\\"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|_LIT
argument_list|(
name|KSysBin
argument_list|,
literal|"\\Sys\\Bin\\"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|_LIT
argument_list|(
name|KBrowserPrefix
argument_list|,
literal|"4 "
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|_LIT
argument_list|(
name|KFontsDir
argument_list|,
literal|"z:\\resource\\Fonts\\"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|USE_SCHEMEHANDLER
end_ifndef
begin_comment
comment|// copied from miutset.h, so we don't get a dependency into the app layer
end_comment
begin_decl_stmt
DECL|variable|KUidMsgTypeSMTP
specifier|const
name|TUid
name|KUidMsgTypeSMTP
init|=
block|{
literal|0x10001028
block|}
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|KUidMsgTypeSMTP
comment|// 268439592
end_comment
begin_decl_stmt
DECL|variable|KUidBrowser
specifier|const
name|TUid
name|KUidBrowser
init|=
block|{
literal|0x10008D39
block|}
decl_stmt|;
end_decl_stmt
begin_class
template|template
parameter_list|<
name|class
name|R
parameter_list|>
class|class
DECL|class|QAutoClose
name|QAutoClose
block|{
public|public:
DECL|function|QAutoClose
name|QAutoClose
parameter_list|(
name|R
modifier|&
name|aObj
parameter_list|)
member_init_list|:
name|mPtr
argument_list|(
operator|&
name|aObj
argument_list|)
block|{}
DECL|function|~QAutoClose
name|~
name|QAutoClose
parameter_list|()
block|{
if|if
condition|(
name|mPtr
condition|)
name|mPtr
operator|->
name|Close
argument_list|()
expr_stmt|;
block|}
DECL|function|Forget
name|void
name|Forget
parameter_list|()
block|{
name|mPtr
operator|=
literal|0
expr_stmt|;
block|}
private|private:
name|QAutoClose
parameter_list|(
specifier|const
name|QAutoClose
modifier|&
parameter_list|)
constructor_decl|;
name|QAutoClose
modifier|&
name|operator
name|=
parameter_list|(
specifier|const
name|QAutoClose
modifier|&
parameter_list|)
function_decl|;
private|private:
DECL|member|mPtr
name|R
modifier|*
name|mPtr
decl_stmt|;
block|}
class|;
end_class
begin_ifdef
ifdef|#
directive|ifdef
name|USE_DOCUMENTHANDLER
end_ifdef
begin_class
DECL|class|QS60DocumentHandler
class|class
name|QS60DocumentHandler
super|:
specifier|public
name|MAknServerAppExitObserver
block|{
public|public:
DECL|function|QS60DocumentHandler
name|QS60DocumentHandler
parameter_list|()
member_init_list|:
name|docHandler
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|~QS60DocumentHandler
name|~
name|QS60DocumentHandler
parameter_list|()
block|{
operator|delete
name|docHandler
expr_stmt|;
block|}
DECL|function|documentHandler
name|CDocumentHandler
modifier|&
name|documentHandler
parameter_list|()
block|{
comment|// In case user calls openUrl twice subsequently, before the first embedded app is closed
comment|// we use the same CDocumentHandler instance. Using same instance makes sure the first
comment|// launched embedded app is closed and latter one gets embedded to our app.
comment|// Using different instance would help only theoretically since user cannot interact with
comment|// several embedded apps at the same time.
if|if
condition|(
operator|!
name|docHandler
condition|)
block|{
name|QT_TRAP_THROWING
argument_list|(
name|docHandler
operator|=
name|CDocumentHandler
operator|::
name|NewL
argument_list|()
argument_list|)
expr_stmt|;
name|docHandler
operator|->
name|SetExitObserver
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|docHandler
return|;
block|}
private|private:
comment|// From MAknServerAppExitObserver
DECL|function|HandleServerAppExit
name|void
name|HandleServerAppExit
parameter_list|(
name|TInt
comment|/*aReason*/
parameter_list|)
block|{
operator|delete
name|docHandler
expr_stmt|;
name|docHandler
operator|=
literal|0
expr_stmt|;
block|}
private|private:
DECL|member|docHandler
name|CDocumentHandler
modifier|*
name|docHandler
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QS60DocumentHandler
argument_list|,
name|qt_s60_documenthandler
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleMailtoSchemeLX
specifier|static
name|void
name|handleMailtoSchemeLX
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
comment|// this function has many intermingled leaves and throws. Qt and Symbian objects do not have
comment|// destructor dependencies, and cleanup object is used to prevent cleanup stack dependency on stack.
name|QString
name|recipient
init|=
name|url
operator|.
name|path
argument_list|()
decl_stmt|;
name|QString
name|subject
init|=
name|url
operator|.
name|queryItemValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"subject"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|body
init|=
name|url
operator|.
name|queryItemValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"body"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|to
init|=
name|url
operator|.
name|queryItemValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"to"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|cc
init|=
name|url
operator|.
name|queryItemValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"cc"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|bcc
init|=
name|url
operator|.
name|queryItemValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"bcc"
argument_list|)
argument_list|)
decl_stmt|;
comment|// these fields might have comma separated addresses
name|QStringList
name|recipients
init|=
name|recipient
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|","
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|QStringList
name|tos
init|=
name|to
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|","
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|QStringList
name|ccs
init|=
name|cc
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|","
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|QStringList
name|bccs
init|=
name|bcc
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|","
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|RSendAs
name|sendAs
decl_stmt|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|sendAs
operator|.
name|Connect
argument_list|()
argument_list|)
expr_stmt|;
name|QAutoClose
argument_list|<
name|RSendAs
argument_list|>
name|sendAsCleanup
argument_list|(
name|sendAs
argument_list|)
decl_stmt|;
name|CSendAsAccounts
modifier|*
name|accounts
init|=
name|CSendAsAccounts
operator|::
name|NewL
argument_list|()
decl_stmt|;
name|CleanupStack
operator|::
name|PushL
argument_list|(
name|accounts
argument_list|)
expr_stmt|;
name|sendAs
operator|.
name|AvailableAccountsL
argument_list|(
name|KUidMsgTypeSMTP
argument_list|,
operator|*
name|accounts
argument_list|)
expr_stmt|;
name|TInt
name|count
init|=
name|accounts
operator|->
name|Count
argument_list|()
decl_stmt|;
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|(
name|accounts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
block|{
comment|// TODO: Task 259192: We should try to create account if count == 0
comment|// CSendUi would provide account creation service for us, but it requires ridicilous
comment|// capabilities: LocalServices NetworkServices ReadDeviceData ReadUserData WriteDeviceData WriteUserData
name|User
operator|::
name|Leave
argument_list|(
name|KErrNotSupported
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RSendAsMessage
name|sendAsMessage
decl_stmt|;
name|sendAsMessage
operator|.
name|CreateL
argument_list|(
name|sendAs
argument_list|,
name|KUidMsgTypeSMTP
argument_list|)
expr_stmt|;
name|QAutoClose
argument_list|<
name|RSendAsMessage
argument_list|>
name|sendAsMessageCleanup
argument_list|(
name|sendAsMessage
argument_list|)
decl_stmt|;
comment|// Subject
name|sendAsMessage
operator|.
name|SetSubjectL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|subject
argument_list|)
argument_list|)
expr_stmt|;
comment|// Body
name|sendAsMessage
operator|.
name|SetBodyTextL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
comment|// To
foreach|foreach
control|(
name|QString
name|item
decl|,
name|recipients
control|)
name|sendAsMessage
operator|.
name|AddRecipientL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|item
argument_list|)
argument_list|,
name|RSendAsMessage
operator|::
name|ESendAsRecipientTo
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QString
name|item
decl|,
name|tos
control|)
name|sendAsMessage
operator|.
name|AddRecipientL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|item
argument_list|)
argument_list|,
name|RSendAsMessage
operator|::
name|ESendAsRecipientTo
argument_list|)
expr_stmt|;
comment|// Cc
foreach|foreach
control|(
name|QString
name|item
decl|,
name|ccs
control|)
name|sendAsMessage
operator|.
name|AddRecipientL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|item
argument_list|)
argument_list|,
name|RSendAsMessage
operator|::
name|ESendAsRecipientCc
argument_list|)
expr_stmt|;
comment|// Bcc
foreach|foreach
control|(
name|QString
name|item
decl|,
name|bccs
control|)
name|sendAsMessage
operator|.
name|AddRecipientL
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|item
argument_list|)
argument_list|,
name|RSendAsMessage
operator|::
name|ESendAsRecipientBcc
argument_list|)
expr_stmt|;
comment|// send the message
name|sendAsMessage
operator|.
name|LaunchEditorAndCloseL
argument_list|()
expr_stmt|;
comment|// sendAsMessage is already closed
name|sendAsMessageCleanup
operator|.
name|Forget
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleMailtoScheme
specifier|static
name|bool
name|handleMailtoScheme
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|TRAPD
argument_list|(
name|err
argument_list|,
name|QT_TRYCATCH_LEAVING
argument_list|(
name|handleMailtoSchemeLX
argument_list|(
name|url
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
literal|false
else|:
literal|true
return|;
block|}
end_function
begin_function
DECL|function|handleOtherSchemesL
specifier|static
name|void
name|handleOtherSchemesL
parameter_list|(
specifier|const
name|TDesC
modifier|&
name|aUrl
parameter_list|)
block|{
comment|// Other schemes are at the moment passed to WEB browser
name|HBufC
modifier|*
name|buf16
init|=
name|HBufC
operator|::
name|NewLC
argument_list|(
name|aUrl
operator|.
name|Length
argument_list|()
operator|+
name|KBrowserPrefix
operator|.
name|iTypeLength
argument_list|)
decl_stmt|;
name|buf16
operator|->
name|Des
argument_list|()
operator|.
name|Copy
argument_list|(
name|KBrowserPrefix
argument_list|)
expr_stmt|;
comment|// Prefix used to launch correct browser view
name|buf16
operator|->
name|Des
argument_list|()
operator|.
name|Append
argument_list|(
name|aUrl
argument_list|)
expr_stmt|;
name|TApaTaskList
name|taskList
argument_list|(
name|CEikonEnv
operator|::
name|Static
argument_list|()
operator|->
name|WsSession
argument_list|()
argument_list|)
decl_stmt|;
name|TApaTask
name|task
init|=
name|taskList
operator|.
name|FindApp
argument_list|(
name|KUidBrowser
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|Exists
argument_list|()
condition|)
block|{
comment|// Switch to existing browser instance
name|task
operator|.
name|BringToForeground
argument_list|()
expr_stmt|;
name|HBufC8
modifier|*
name|param8
init|=
name|HBufC8
operator|::
name|NewLC
argument_list|(
name|buf16
operator|->
name|Length
argument_list|()
argument_list|)
decl_stmt|;
name|param8
operator|->
name|Des
argument_list|()
operator|.
name|Append
argument_list|(
name|buf16
operator|->
name|Des
argument_list|()
argument_list|)
expr_stmt|;
name|task
operator|.
name|SendMessage
argument_list|(
name|TUid
operator|::
name|Uid
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|*
name|param8
argument_list|)
expr_stmt|;
comment|// Uid is not used
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|(
name|param8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Start a new browser instance
name|RApaLsSession
name|appArcSession
decl_stmt|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|appArcSession
operator|.
name|Connect
argument_list|()
argument_list|)
expr_stmt|;
name|CleanupClosePushL
argument_list|<
name|RApaLsSession
argument_list|>
argument_list|(
name|appArcSession
argument_list|)
expr_stmt|;
name|TThreadId
name|id
decl_stmt|;
name|appArcSession
operator|.
name|StartDocument
argument_list|(
operator|*
name|buf16
argument_list|,
name|KUidBrowser
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|()
expr_stmt|;
comment|// appArcSession
block|}
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|(
name|buf16
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleOtherSchemes
specifier|static
name|bool
name|handleOtherSchemes
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QString
name|encUrl
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|url
operator|.
name|toEncoded
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|TPtrC
name|urlPtr
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|encUrl
argument_list|)
argument_list|)
decl_stmt|;
name|TRAPD
argument_list|(
name|err
argument_list|,
name|handleOtherSchemesL
argument_list|(
name|urlPtr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
literal|false
else|:
literal|true
return|;
block|}
end_function
begin_function
DECL|function|openDocumentL
specifier|static
name|void
name|openDocumentL
parameter_list|(
specifier|const
name|TDesC
modifier|&
name|aUrl
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_DOCUMENTHANDLER
comment|// Start app associated to file MIME type by using RApaLsSession
comment|// Apparc base method cannot be used to open app in embedded mode,
comment|// but seems to be most stable way at the moment
name|RApaLsSession
name|appArcSession
decl_stmt|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|appArcSession
operator|.
name|Connect
argument_list|()
argument_list|)
expr_stmt|;
name|CleanupClosePushL
argument_list|<
name|RApaLsSession
argument_list|>
argument_list|(
name|appArcSession
argument_list|)
expr_stmt|;
name|TThreadId
name|id
decl_stmt|;
comment|// ESwitchFiles means do not start another instance
comment|// Leaves if file does not exist, leave is trapped in openDocument and false returned to user.
name|User
operator|::
name|LeaveIfError
argument_list|(
name|appArcSession
operator|.
name|StartDocument
argument_list|(
name|aUrl
argument_list|,
name|id
argument_list|,
name|RApaLsSession
operator|::
name|ESwitchFiles
argument_list|)
argument_list|)
expr_stmt|;
comment|// ELaunchNewApp
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|()
expr_stmt|;
comment|// appArcSession
else|#
directive|else
comment|// This is an alternative way to launch app associated to MIME type
comment|// CDocumentHandler also supports opening apps in embedded mode.
name|TDataType
name|temp
decl_stmt|;
name|qt_s60_documenthandler
argument_list|()
operator|->
name|documentHandler
argument_list|()
operator|.
name|OpenFileEmbeddedL
argument_list|(
name|aUrl
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|launchWebBrowser
specifier|static
name|bool
name|launchWebBrowser
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"mailto"
argument_list|)
condition|)
block|{
return|return
name|handleMailtoScheme
argument_list|(
name|url
argument_list|)
return|;
block|}
return|return
name|handleOtherSchemes
argument_list|(
name|url
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|openDocument
specifier|static
name|bool
name|openDocument
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|filePath
init|=
name|file
operator|.
name|toLocalFile
argument_list|()
decl_stmt|;
name|filePath
operator|=
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
name|TPtrC
name|filePathPtr
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|filePath
argument_list|)
argument_list|)
decl_stmt|;
name|TRAPD
argument_list|(
name|err
argument_list|,
name|openDocumentL
argument_list|(
name|filePathPtr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
literal|false
else|:
literal|true
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|//USE_SCHEMEHANDLER
end_comment
begin_comment
comment|// The schemehandler component only exist in private SDK. This implementation
end_comment
begin_comment
comment|// exist here just for convenience in case that we need to use it later on
end_comment
begin_comment
comment|// The schemehandle based implementation is not yet tested.
end_comment
begin_comment
comment|// The biggest advantage of schemehandler is that it can handle
end_comment
begin_comment
comment|// wide range of schemes and is extensible by plugins
end_comment
begin_function
DECL|function|handleUrlL
specifier|static
name|void
name|handleUrlL
parameter_list|(
specifier|const
name|TDesC
modifier|&
name|aUrl
parameter_list|)
block|{
name|CSchemeHandler
modifier|*
name|schemeHandler
init|=
name|CSchemeHandler
operator|::
name|NewL
argument_list|(
name|aUrl
argument_list|)
decl_stmt|;
name|CleanupStack
operator|::
name|PushL
argument_list|(
name|schemeHandler
argument_list|)
expr_stmt|;
name|schemeHandler
operator|->
name|HandleUrlStandaloneL
argument_list|()
expr_stmt|;
comment|// Process the Url in standalone mode
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleUrl
specifier|static
name|bool
name|handleUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|urlString
argument_list|(
name|url
operator|.
name|toEncoded
argument_list|()
argument_list|)
decl_stmt|;
name|TPtrC
name|urlPtr
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|urlString
argument_list|)
argument_list|)
decl_stmt|;
name|TRAPD
argument_list|(
name|err
argument_list|,
name|handleUrlL
argument_list|(
name|urlPtr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
literal|false
else|:
literal|true
return|;
block|}
end_function
begin_function
DECL|function|launchWebBrowser
specifier|static
name|bool
name|launchWebBrowser
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
return|return
name|handleUrl
argument_list|(
name|url
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|openDocument
specifier|static
name|bool
name|openDocument
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|file
parameter_list|)
block|{
return|return
name|handleUrl
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//USE_SCHEMEHANDLER
end_comment
begin_comment
comment|// Common functions to all implementations
end_comment
begin_function
DECL|function|exeDrive
specifier|static
name|TDriveUnit
name|exeDrive
parameter_list|()
block|{
name|RProcess
name|me
decl_stmt|;
name|TFileName
name|processFileName
init|=
name|me
operator|.
name|FileName
argument_list|()
decl_stmt|;
name|TDriveUnit
name|drive
argument_list|(
name|processFileName
argument_list|)
decl_stmt|;
return|return
name|drive
return|;
block|}
end_function
begin_function
DECL|function|writableExeDrive
specifier|static
name|TDriveUnit
name|writableExeDrive
parameter_list|()
block|{
name|TDriveUnit
name|drive
init|=
name|exeDrive
argument_list|()
decl_stmt|;
if|if
condition|(
name|drive
operator|.
name|operator
name|TInt
argument_list|()
operator|==
name|EDriveZ
condition|)
return|return
name|TDriveUnit
argument_list|(
name|EDriveC
argument_list|)
return|;
return|return
name|drive
return|;
block|}
end_function
begin_function
DECL|function|writableDataRoot
specifier|static
name|TPtrC
name|writableDataRoot
parameter_list|()
block|{
name|TDriveUnit
name|drive
init|=
name|exeDrive
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|drive
operator|.
name|operator
name|TInt
argument_list|()
condition|)
block|{
case|case
name|EDriveC
case|:
return|return
name|PathInfo
operator|::
name|PhoneMemoryRootPath
argument_list|()
return|;
break|break;
case|case
name|EDriveE
case|:
return|return
name|PathInfo
operator|::
name|MemoryCardRootPath
argument_list|()
return|;
break|break;
case|case
name|EDriveZ
case|:
comment|// It is not possible to write on ROM drive ->
comment|// return phone mem root path instead
return|return
name|PathInfo
operator|::
name|PhoneMemoryRootPath
argument_list|()
return|;
break|break;
default|default:
return|return
name|PathInfo
operator|::
name|PhoneMemoryRootPath
argument_list|()
return|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|storageLocation
name|QString
name|QDesktopServices
operator|::
name|storageLocation
parameter_list|(
name|StandardLocation
name|type
parameter_list|)
block|{
name|TFileName
name|path
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DesktopLocation
case|:
name|qWarning
argument_list|(
literal|"No desktop concept in Symbian OS"
argument_list|)
expr_stmt|;
comment|// But lets still use some feasible default
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DocumentsLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FontsLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|KFontsDir
argument_list|)
expr_stmt|;
break|break;
case|case
name|ApplicationsLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|exeDrive
argument_list|()
operator|.
name|Name
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|Append
argument_list|(
name|KSysBin
argument_list|)
expr_stmt|;
break|break;
case|case
name|MusicLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|Append
argument_list|(
name|PathInfo
operator|::
name|SoundsPath
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MoviesLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|Append
argument_list|(
name|PathInfo
operator|::
name|VideosPath
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PicturesLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|Append
argument_list|(
name|PathInfo
operator|::
name|ImagesPath
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TempLocation
case|:
return|return
name|QDir
operator|::
name|tempPath
argument_list|()
return|;
break|break;
case|case
name|HomeLocation
case|:
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
comment|//return QDir::homePath(); break;
break|break;
case|case
name|DataLocation
case|:
name|qt_s60GetRFs
argument_list|()
operator|.
name|PrivatePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|Insert
argument_list|(
literal|0
argument_list|,
name|writableExeDrive
argument_list|()
operator|.
name|Name
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CacheLocation
case|:
name|qt_s60GetRFs
argument_list|()
operator|.
name|PrivatePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|.
name|Insert
argument_list|(
literal|0
argument_list|,
name|writableExeDrive
argument_list|()
operator|.
name|Name
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|Append
argument_list|(
name|KCacheSubDir
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Lets use feasible default
name|path
operator|.
name|Append
argument_list|(
name|writableDataRoot
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Convert to cross-platform format and clean the path
name|QString
name|nativePath
init|=
name|QString
operator|::
name|fromUtf16
argument_list|(
name|path
operator|.
name|Ptr
argument_list|()
argument_list|,
name|path
operator|.
name|Length
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|qtPath
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|nativePath
argument_list|)
decl_stmt|;
name|qtPath
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|qtPath
argument_list|)
expr_stmt|;
comment|// Note: The storage location returned can be a directory that does not exist;
comment|// i.e., it may need to be created by the system or the user.
return|return
name|qtPath
return|;
block|}
end_function
begin_typedef
DECL|typedef|LocalizerFunc
typedef|typedef
name|QString
function_decl|(
modifier|*
name|LocalizerFunc
function_decl|)
parameter_list|(
name|QString
modifier|&
parameter_list|)
function_decl|;
end_typedef
begin_function
DECL|function|defaultLocalizedDirectoryName
specifier|static
name|QString
name|defaultLocalizedDirectoryName
parameter_list|(
name|QString
modifier|&
parameter_list|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QDesktopServices
operator|::
name|displayName
parameter_list|(
name|StandardLocation
name|type
parameter_list|)
block|{
specifier|static
name|LocalizerFunc
name|ptrLocalizerFunc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ptrLocalizerFunc
condition|)
block|{
name|ptrLocalizerFunc
operator|=
cast|reinterpret_cast
argument_list|<
name|LocalizerFunc
argument_list|>
argument_list|(
name|qt_resolveS60PluginFunc
argument_list|(
name|S60Plugin_LocalizedDirectoryName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrLocalizerFunc
condition|)
name|ptrLocalizerFunc
operator|=
operator|&
name|defaultLocalizedDirectoryName
expr_stmt|;
block|}
name|QString
name|rawPath
init|=
name|storageLocation
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|ptrLocalizerFunc
argument_list|(
name|rawPath
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
