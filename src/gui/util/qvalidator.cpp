begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qvalidator.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VALIDATOR
end_ifndef
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qlocale_p.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QValidator     \brief The QValidator class provides validation of input text.      The class itself is abstract. Two subclasses, \l QIntValidator and     \l QDoubleValidator, provide basic numeric-range checking, and \l     QRegExpValidator provides general checking using a custom regular     expression.      If the built-in validators aren't sufficient, you can subclass     QValidator. The class has two virtual functions: validate() and     fixup().      \l validate() must be implemented by every subclass. It returns     \l Invalid, \l Intermediate or \l Acceptable depending on whether     its argument is valid (for the subclass's definition of valid).      These three states require some explanation. An \l Invalid string     is \e clearly invalid. \l Intermediate is less obvious: the     concept of validity is difficult to apply when the string is     incomplete (still being edited). QValidator defines \l Intermediate     as the property of a string that is neither clearly invalid nor     acceptable as a final result. \l Acceptable means that the string     is acceptable as a final result. One might say that any string     that is a plausible intermediate state during entry of an \l     Acceptable string is \l Intermediate.      Here are some examples:      \list      \li For a line edit that accepts integers from 10 to 1000 inclusive,     42 and 123 are \l Acceptable, the empty string and 5 are \l     Intermediate, and "asdf" and 1114 is \l Invalid.      \li For an editable combobox that accepts URLs, any well-formed URL     is \l Acceptable, "http://example.com/," is \l Intermediate     (it might be a cut and paste action that accidentally took in a     comma at the end), the empty string is \l Intermediate (the user     might select and delete all of the text in preparation for entering     a new URL) and "http:///./" is \l Invalid.      \li For a spin box that accepts lengths, "11cm" and "1in" are \l     Acceptable, "11" and the empty string are \l Intermediate, and     "http://example.com" and "hour" are \l Invalid.      \endlist      \l fixup() is provided for validators that can repair some user     errors. The default implementation does nothing. QLineEdit, for     example, will call fixup() if the user presses Enter (or Return)     and the content is not currently valid. This allows the fixup()     function the opportunity of performing some magic to make an \l     Invalid string \l Acceptable.      A validator has a locale, set with setLocale(). It is typically used     to parse localized data. For example, QIntValidator and QDoubleValidator     use it to parse localized representations of integers and doubles.      QValidator is typically used with QLineEdit, QSpinBox and     QComboBox.      \sa QIntValidator, QDoubleValidator, QRegExpValidator, {Line Edits Example} */
end_comment
begin_comment
comment|/*!     \enum QValidator::State      This enum type defines the states in which a validated string can     exist.      \value Invalid       The string is \e clearly invalid.     \value Intermediate  The string is a plausible intermediate value.     \value Acceptable    The string is acceptable as a final result;                          i.e. it is valid.      \omitvalue Valid */
end_comment
begin_comment
comment|/*!     \fn void QValidator::changed()      This signal is emitted when any property that may affect the validity of     a string has changed. */
end_comment
begin_comment
comment|/*!     \fn void QIntValidator::topChanged(int top)      This signal is emitted after the top property changed.      \sa QIntValidator::top(), QIntValidator::setTop(), QIntValidator::bottom(), QIntValidator::setBottom()     \internal */
end_comment
begin_comment
comment|/*!     \fn void QIntValidator::bottomChanged(int bottom)      This signal is emitted after the bottom property changed.      \sa QIntValidator::top(), QIntValidator::setTop(), QIntValidator::bottom(), QIntValidator::setBottom()     \internal */
end_comment
begin_comment
comment|/*!     \fn void QDoubleValidator::topChanged(double top)      This signal is emitted after the top property changed.      \sa QDoubleValidator::top(), QDoubleValidator::setTop(), QDoubleValidator::bottom(), QDoubleValidator::setBottom()     \internal */
end_comment
begin_comment
comment|/*!     \fn void QDoubleValidator::bottomChanged(double bottom)      This signal is emitted after the bottom property changed.      \sa QDoubleValidator::top(), QDoubleValidator::setTop(), QDoubleValidator::bottom(), QDoubleValidator::setBottom()     \internal */
end_comment
begin_comment
comment|/*!     \fn void QDoubleValidator::decimalsChanged(int decimals)      This signal is emitted after the decimals property changed.      \internal */
end_comment
begin_comment
comment|/*!     \fn void QDoubleValidator::notationChanged(QDoubleValidator::Notation notation)      This signal is emitted after the notation property changed.      QDoubleValidator::Notation is not a registered metatype, so for queued connections,     you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().      \internal */
end_comment
begin_comment
comment|/*!     \fn void QRegExpValidator::regExpChanged(const QRegExp&regExp)      This signal is emitted after the regExp property changed.     \internal */
end_comment
begin_class
DECL|class|QValidatorPrivate
class|class
name|QValidatorPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QValidator
parameter_list|)
specifier|public
private|:
DECL|function|QValidatorPrivate
name|QValidatorPrivate
parameter_list|()
member_init_list|:
name|QObjectPrivate
argument_list|()
block|{     }
DECL|member|locale
name|QLocale
name|locale
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Sets up the validator. The \a parent parameter is     passed on to the QObject constructor. */
end_comment
begin_constructor
DECL|function|QValidator
name|QValidator
operator|::
name|QValidator
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QValidatorPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the validator, freeing any storage and other resources     used. */
end_comment
begin_destructor
DECL|function|~QValidator
name|QValidator
operator|::
name|~
name|QValidator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the locale for the validator. The locale is by default initialized to the same as QLocale().      \sa setLocale()     \sa QLocale::QLocale() */
end_comment
begin_function
DECL|function|locale
name|QLocale
name|QValidator
operator|::
name|locale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QValidator
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|locale
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a locale that will be used for the validator. Unless     setLocale has been called, the validator will use the default     locale set with QLocale::setDefault(). If a default locale has not     been set, it is the operating system's locale.      \sa locale() QLocale::setDefault() */
end_comment
begin_function
DECL|function|setLocale
name|void
name|QValidator
operator|::
name|setLocale
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QValidator
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|locale
operator|!=
name|locale
condition|)
block|{
name|d
operator|->
name|locale
operator|=
name|locale
expr_stmt|;
emit|emit
name|changed
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QValidator::State QValidator::validate(QString&input, int&pos) const      This virtual function returns \l Invalid if \a input is invalid     according to this validator's rules, \l Intermediate if it     is likely that a little more editing will make the input     acceptable (e.g. the user types "4" into a widget which accepts     integers between 10 and 99), and \l Acceptable if the input is     valid.      The function can change both \a input and \a pos (the cursor position)     if required. */
end_comment
begin_comment
comment|/*!     \fn void QValidator::fixup(QString& input) const      This function attempts to change \a input to be valid according to     this validator's rules. It need not result in a valid string:     callers of this function must re-test afterwards; the default does     nothing.      Reimplementations of this function can change \a input even if     they do not produce a valid string. For example, an ISBN validator     might want to delete every character except digits and "-", even     if the result is still not a valid ISBN; a surname validator might     want to remove whitespace from the start and end of the string,     even if the resulting string is not in the list of accepted     surnames. */
end_comment
begin_function
DECL|function|fixup
name|void
name|QValidator
operator|::
name|fixup
parameter_list|(
name|QString
modifier|&
parameter_list|)
specifier|const
block|{ }
end_function
begin_comment
comment|/*!     \class QIntValidator     \brief The QIntValidator class provides a validator that ensures     a string contains a valid integer within a specified range.      Example of use:      \snippet doc/src/snippets/code/src_gui_widgets_qvalidator.cpp 0      Below we present some examples of validators. In practice they would     normally be associated with a widget as in the example above.      \snippet doc/src/snippets/code/src_gui_widgets_qvalidator.cpp 1      Notice that the value \c 999 returns Intermediate. Values     consisting of a number of digits equal to or less than the max     value are considered intermediate. This is intended because the     digit that prevents a number to be in range is not necessarily the     last digit typed. This also means that an intermediate number can     have leading zeros.      The minimum and maximum values are set in one call with setRange(),     or individually with setBottom() and setTop().      QIntValidator uses its locale() to interpret the number. For example,     in Arabic locales, QIntValidator will accept Arabic digits.      \sa QDoubleValidator, QRegExpValidator, {Line Edits Example} */
end_comment
begin_comment
comment|/*!     Constructs a validator with a \a parent object that     accepts all integers. */
end_comment
begin_constructor
DECL|function|QIntValidator
name|QIntValidator
operator|::
name|QIntValidator
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
name|parent
argument_list|)
block|{
name|b
operator|=
name|INT_MIN
expr_stmt|;
name|t
operator|=
name|INT_MAX
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a validator with a \a parent, that accepts integers     from \a minimum to \a maximum inclusive. */
end_comment
begin_constructor
DECL|function|QIntValidator
name|QIntValidator
operator|::
name|QIntValidator
parameter_list|(
name|int
name|minimum
parameter_list|,
name|int
name|maximum
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
name|parent
argument_list|)
block|{
name|b
operator|=
name|minimum
expr_stmt|;
name|t
operator|=
name|maximum
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the validator. */
end_comment
begin_destructor
DECL|function|~QIntValidator
name|QIntValidator
operator|::
name|~
name|QIntValidator
parameter_list|()
block|{
comment|// nothing
block|}
end_destructor
begin_comment
comment|/*!     \fn QValidator::State QIntValidator::validate(QString&input, int&pos) const      Returns \l Acceptable if the \a input is an integer within the     valid range, \l Intermediate if the \a input is a prefix of an integer in the     valid range, and \l Invalid otherwise.      If the valid range consists of just positive integers (e.g., 32 to 100)     and \a input is a negative integer, then Invalid is returned. (On the other     hand, if the range consists of negative integers (e.g., -100 to -32) and     \a input is a positive integer, then Intermediate is returned, because     the user might be just about to type the minus (especially for right-to-left     languages).      \snippet doc/src/snippets/code/src_gui_widgets_qvalidator.cpp 2      By default, the \a pos parameter is not used by this validator. */
end_comment
begin_function
DECL|function|numDigits
specifier|static
name|int
name|numDigits
parameter_list|(
name|qlonglong
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|int
operator|)
name|log10
argument_list|(
name|double
argument_list|(
name|n
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|pow10
specifier|static
name|qlonglong
name|pow10
parameter_list|(
name|int
name|exp
parameter_list|)
block|{
name|qlonglong
name|result
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exp
condition|;
operator|++
name|i
control|)
name|result
operator|*=
literal|10
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|validate
name|QValidator
operator|::
name|State
name|QIntValidator
operator|::
name|validate
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
parameter_list|)
specifier|const
block|{
name|QByteArray
name|buff
decl_stmt|;
if|if
condition|(
operator|!
name|locale
argument_list|()
operator|.
name|d
argument_list|()
operator|->
name|validateChars
argument_list|(
name|input
argument_list|,
name|QLocalePrivate
operator|::
name|IntegerMode
argument_list|,
operator|&
name|buff
argument_list|)
condition|)
block|{
return|return
name|Invalid
return|;
block|}
if|if
condition|(
name|buff
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|Intermediate
return|;
if|if
condition|(
name|b
operator|>=
literal|0
operator|&&
name|buff
operator|.
name|startsWith
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
name|Invalid
return|;
if|if
condition|(
name|t
operator|<
literal|0
operator|&&
name|buff
operator|.
name|startsWith
argument_list|(
literal|'+'
argument_list|)
condition|)
return|return
name|Invalid
return|;
if|if
condition|(
name|buff
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
name|buff
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'+'
operator|||
name|buff
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
operator|)
condition|)
return|return
name|Intermediate
return|;
name|bool
name|ok
decl_stmt|,
name|overflow
decl_stmt|;
name|qlonglong
name|entered
init|=
name|QLocalePrivate
operator|::
name|bytearrayToLongLong
argument_list|(
name|buff
operator|.
name|constData
argument_list|()
argument_list|,
literal|10
argument_list|,
operator|&
name|ok
argument_list|,
operator|&
name|overflow
argument_list|)
decl_stmt|;
if|if
condition|(
name|overflow
operator|||
operator|!
name|ok
condition|)
return|return
name|Invalid
return|;
if|if
condition|(
name|entered
operator|>=
name|b
operator|&&
name|entered
operator|<=
name|t
condition|)
block|{
name|locale
argument_list|()
operator|.
name|toInt
argument_list|(
name|input
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
return|return
name|ok
condition|?
name|Acceptable
else|:
name|Intermediate
return|;
block|}
if|if
condition|(
name|entered
operator|>=
literal|0
condition|)
block|{
comment|// the -entered< b condition is necessary to allow people to type
comment|// the minus last (e.g. for right-to-left languages)
return|return
operator|(
name|entered
operator|>
name|t
operator|&&
operator|-
name|entered
operator|<
name|b
operator|)
condition|?
name|Invalid
else|:
name|Intermediate
return|;
block|}
else|else
block|{
return|return
operator|(
name|entered
operator|<
name|b
operator|)
condition|?
name|Invalid
else|:
name|Intermediate
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|fixup
name|void
name|QIntValidator
operator|::
name|fixup
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|)
specifier|const
block|{
name|QByteArray
name|buff
decl_stmt|;
if|if
condition|(
operator|!
name|locale
argument_list|()
operator|.
name|d
argument_list|()
operator|->
name|validateChars
argument_list|(
name|input
argument_list|,
name|QLocalePrivate
operator|::
name|IntegerMode
argument_list|,
operator|&
name|buff
argument_list|)
condition|)
block|{
return|return;
block|}
name|bool
name|ok
decl_stmt|,
name|overflow
decl_stmt|;
name|qlonglong
name|entered
init|=
name|QLocalePrivate
operator|::
name|bytearrayToLongLong
argument_list|(
name|buff
operator|.
name|constData
argument_list|()
argument_list|,
literal|10
argument_list|,
operator|&
name|ok
argument_list|,
operator|&
name|overflow
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
operator|!
name|overflow
condition|)
name|input
operator|=
name|locale
argument_list|()
operator|.
name|toString
argument_list|(
name|entered
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the range of the validator to only accept integers between \a     bottom and \a top inclusive. */
end_comment
begin_function
DECL|function|setRange
name|void
name|QIntValidator
operator|::
name|setRange
parameter_list|(
name|int
name|bottom
parameter_list|,
name|int
name|top
parameter_list|)
block|{
name|bool
name|rangeChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|bottom
condition|)
block|{
name|b
operator|=
name|bottom
expr_stmt|;
name|rangeChanged
operator|=
literal|true
expr_stmt|;
emit|emit
name|bottomChanged
argument_list|(
name|b
argument_list|)
emit|;
block|}
if|if
condition|(
name|t
operator|!=
name|top
condition|)
block|{
name|t
operator|=
name|top
expr_stmt|;
name|rangeChanged
operator|=
literal|true
expr_stmt|;
emit|emit
name|topChanged
argument_list|(
name|t
argument_list|)
emit|;
block|}
if|if
condition|(
name|rangeChanged
condition|)
emit|emit
name|changed
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QIntValidator::bottom     \brief the validator's lowest acceptable value      By default, this property's value is derived from the lowest signed     integer available (typically -2147483647).      \sa setRange() */
end_comment
begin_function
DECL|function|setBottom
name|void
name|QIntValidator
operator|::
name|setBottom
parameter_list|(
name|int
name|bottom
parameter_list|)
block|{
name|setRange
argument_list|(
name|bottom
argument_list|,
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QIntValidator::top     \brief the validator's highest acceptable value      By default, this property's value is derived from the highest signed     integer available (typically 2147483647).      \sa setRange() */
end_comment
begin_function
DECL|function|setTop
name|void
name|QIntValidator
operator|::
name|setTop
parameter_list|(
name|int
name|top
parameter_list|)
block|{
name|setRange
argument_list|(
name|bottom
argument_list|()
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QValidator
name|QValidator
operator|::
name|QValidator
parameter_list|(
name|QObjectPrivate
modifier|&
name|d
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QValidator
name|QValidator
operator|::
name|QValidator
parameter_list|(
name|QValidatorPrivate
modifier|&
name|d
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_class
DECL|class|QDoubleValidatorPrivate
class|class
name|QDoubleValidatorPrivate
super|:
specifier|public
name|QValidatorPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QDoubleValidator
parameter_list|)
specifier|public
private|:
DECL|function|QDoubleValidatorPrivate
name|QDoubleValidatorPrivate
parameter_list|()
member_init_list|:
name|QValidatorPrivate
argument_list|()
member_init_list|,
name|notation
argument_list|(
name|QDoubleValidator
operator|::
name|ScientificNotation
argument_list|)
block|{     }
DECL|member|notation
name|QDoubleValidator
operator|::
name|Notation
name|notation
decl_stmt|;
name|QValidator
operator|::
name|State
name|validateWithLocale
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|QLocalePrivate
operator|::
name|NumberMode
name|numMode
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QDoubleValidator      \brief The QDoubleValidator class provides range checking of     floating-point numbers.      QDoubleValidator provides an upper bound, a lower bound, and a     limit on the number of digits after the decimal point. It does not     provide a fixup() function.      You can set the acceptable range in one call with setRange(), or     with setBottom() and setTop(). Set the number of decimal places     with setDecimals(). The validate() function returns the validation     state.      QDoubleValidator uses its locale() to interpret the number. For example,     in the German locale, "1,234" will be accepted as the fractional number     1.234. In Arabic locales, QDoubleValidator will accept Arabic digits.      \sa QIntValidator, QRegExpValidator, {Line Edits Example} */
end_comment
begin_comment
comment|/*!     \enum QDoubleValidator::Notation     \since 4.3     This enum defines the allowed notations for entering a double.      \value StandardNotation      The string is written as a standard number                                  (i.e. 0.015).     \value ScientificNotation    The string is written in scientific                                  form. It may have an exponent part(i.e. 1.5E-2). */
end_comment
begin_comment
comment|/*!     Constructs a validator object with a \a parent object     that accepts any double. */
end_comment
begin_constructor
DECL|function|QDoubleValidator
name|QDoubleValidator
operator|::
name|QDoubleValidator
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
operator|*
operator|new
name|QDoubleValidatorPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|b
operator|=
operator|-
name|HUGE_VAL
expr_stmt|;
name|t
operator|=
name|HUGE_VAL
expr_stmt|;
name|dec
operator|=
literal|1000
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a validator object with a \a parent object. This     validator will accept doubles from \a bottom to \a top inclusive,     with up to \a decimals digits after the decimal point. */
end_comment
begin_constructor
DECL|function|QDoubleValidator
name|QDoubleValidator
operator|::
name|QDoubleValidator
parameter_list|(
name|double
name|bottom
parameter_list|,
name|double
name|top
parameter_list|,
name|int
name|decimals
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
operator|*
operator|new
name|QDoubleValidatorPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|b
operator|=
name|bottom
expr_stmt|;
name|t
operator|=
name|top
expr_stmt|;
name|dec
operator|=
name|decimals
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the validator. */
end_comment
begin_destructor
DECL|function|~QDoubleValidator
name|QDoubleValidator
operator|::
name|~
name|QDoubleValidator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn QValidator::State QDoubleValidator::validate(QString&input, int&pos) const      Returns \l Acceptable if the string \a input contains a double     that is within the valid range and is in the correct format.      Returns \l Intermediate if \a input contains a double that is     outside the range or is in the wrong format; e.g. with too many     digits after the decimal point or is empty.      Returns \l Invalid if the \a input is not a double.      Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0)     and \a input is a negative double then \l Invalid is returned. If notation()     is set to StandardNotation, and the input contains more digits before the     decimal point than a double in the valid range may have, \l Invalid is returned.     If notation() is ScientificNotation, and the input is not in the valid range,     \l Intermediate is returned. The value may yet become valid by changing the exponent.      By default, the \a pos parameter is not used by this validator. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LLONG_MAX
end_ifndef
begin_define
DECL|macro|LLONG_MAX
define|#
directive|define
name|LLONG_MAX
value|Q_INT64_C(0x7fffffffffffffff)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|validate
name|QValidator
operator|::
name|State
name|QDoubleValidator
operator|::
name|validate
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDoubleValidator
argument_list|)
expr_stmt|;
name|QLocalePrivate
operator|::
name|NumberMode
name|numMode
init|=
name|QLocalePrivate
operator|::
name|DoubleStandardMode
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|notation
condition|)
block|{
case|case
name|StandardNotation
case|:
name|numMode
operator|=
name|QLocalePrivate
operator|::
name|DoubleStandardMode
expr_stmt|;
break|break;
case|case
name|ScientificNotation
case|:
name|numMode
operator|=
name|QLocalePrivate
operator|::
name|DoubleScientificMode
expr_stmt|;
break|break;
block|}
return|return
name|d
operator|->
name|validateWithLocale
argument_list|(
name|input
argument_list|,
name|numMode
argument_list|,
name|locale
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|validateWithLocale
name|QValidator
operator|::
name|State
name|QDoubleValidatorPrivate
operator|::
name|validateWithLocale
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|QLocalePrivate
operator|::
name|NumberMode
name|numMode
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QDoubleValidator
argument_list|)
expr_stmt|;
name|QByteArray
name|buff
decl_stmt|;
if|if
condition|(
operator|!
name|locale
operator|.
name|d
argument_list|()
operator|->
name|validateChars
argument_list|(
name|input
argument_list|,
name|numMode
argument_list|,
operator|&
name|buff
argument_list|,
name|q
operator|->
name|dec
argument_list|)
condition|)
return|return
name|QValidator
operator|::
name|Invalid
return|;
if|if
condition|(
name|buff
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QValidator
operator|::
name|Intermediate
return|;
if|if
condition|(
name|q
operator|->
name|b
operator|>=
literal|0
operator|&&
name|buff
operator|.
name|startsWith
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
name|QValidator
operator|::
name|Invalid
return|;
if|if
condition|(
name|q
operator|->
name|t
operator|<
literal|0
operator|&&
name|buff
operator|.
name|startsWith
argument_list|(
literal|'+'
argument_list|)
condition|)
return|return
name|QValidator
operator|::
name|Invalid
return|;
name|bool
name|ok
decl_stmt|,
name|overflow
decl_stmt|;
name|double
name|i
init|=
name|QLocalePrivate
operator|::
name|bytearrayToDouble
argument_list|(
name|buff
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|ok
argument_list|,
operator|&
name|overflow
argument_list|)
decl_stmt|;
if|if
condition|(
name|overflow
condition|)
return|return
name|QValidator
operator|::
name|Invalid
return|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QValidator
operator|::
name|Intermediate
return|;
if|if
condition|(
name|i
operator|>=
name|q
operator|->
name|b
operator|&&
name|i
operator|<=
name|q
operator|->
name|t
condition|)
return|return
name|QValidator
operator|::
name|Acceptable
return|;
if|if
condition|(
name|notation
operator|==
name|QDoubleValidator
operator|::
name|StandardNotation
condition|)
block|{
name|double
name|max
init|=
name|qMax
argument_list|(
name|qAbs
argument_list|(
name|q
operator|->
name|b
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|q
operator|->
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|max
operator|<
name|LLONG_MAX
condition|)
block|{
name|qlonglong
name|n
init|=
name|pow10
argument_list|(
name|numDigits
argument_list|(
name|qlonglong
argument_list|(
name|max
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|i
argument_list|)
operator|>
name|n
condition|)
return|return
name|QValidator
operator|::
name|Invalid
return|;
block|}
block|}
return|return
name|QValidator
operator|::
name|Intermediate
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the validator to accept doubles from \a minimum to \a maximum     inclusive, with at most \a decimals digits after the decimal     point. */
end_comment
begin_function
DECL|function|setRange
name|void
name|QDoubleValidator
operator|::
name|setRange
parameter_list|(
name|double
name|minimum
parameter_list|,
name|double
name|maximum
parameter_list|,
name|int
name|decimals
parameter_list|)
block|{
name|bool
name|rangeChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|minimum
condition|)
block|{
name|b
operator|=
name|minimum
expr_stmt|;
name|rangeChanged
operator|=
literal|true
expr_stmt|;
emit|emit
name|bottomChanged
argument_list|(
name|b
argument_list|)
emit|;
block|}
if|if
condition|(
name|t
operator|!=
name|maximum
condition|)
block|{
name|t
operator|=
name|maximum
expr_stmt|;
name|rangeChanged
operator|=
literal|true
expr_stmt|;
emit|emit
name|topChanged
argument_list|(
name|t
argument_list|)
emit|;
block|}
if|if
condition|(
name|dec
operator|!=
name|decimals
condition|)
block|{
name|dec
operator|=
name|decimals
expr_stmt|;
name|rangeChanged
operator|=
literal|true
expr_stmt|;
emit|emit
name|decimalsChanged
argument_list|(
name|dec
argument_list|)
emit|;
block|}
if|if
condition|(
name|rangeChanged
condition|)
emit|emit
name|changed
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QDoubleValidator::bottom     \brief the validator's minimum acceptable value      By default, this property contains a value of -infinity.      \sa setRange() */
end_comment
begin_function
DECL|function|setBottom
name|void
name|QDoubleValidator
operator|::
name|setBottom
parameter_list|(
name|double
name|bottom
parameter_list|)
block|{
name|setRange
argument_list|(
name|bottom
argument_list|,
name|top
argument_list|()
argument_list|,
name|decimals
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QDoubleValidator::top     \brief the validator's maximum acceptable value      By default, this property contains a value of infinity.      \sa setRange() */
end_comment
begin_function
DECL|function|setTop
name|void
name|QDoubleValidator
operator|::
name|setTop
parameter_list|(
name|double
name|top
parameter_list|)
block|{
name|setRange
argument_list|(
name|bottom
argument_list|()
argument_list|,
name|top
argument_list|,
name|decimals
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QDoubleValidator::decimals     \brief the validator's maximum number of digits after the decimal point      By default, this property contains a value of 1000.      \sa setRange() */
end_comment
begin_function
DECL|function|setDecimals
name|void
name|QDoubleValidator
operator|::
name|setDecimals
parameter_list|(
name|int
name|decimals
parameter_list|)
block|{
name|setRange
argument_list|(
name|bottom
argument_list|()
argument_list|,
name|top
argument_list|()
argument_list|,
name|decimals
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QDoubleValidator::notation     \since 4.3     \brief the notation of how a string can describe a number      By default, this property is set to ScientificNotation.      \sa Notation */
end_comment
begin_function
DECL|function|setNotation
name|void
name|QDoubleValidator
operator|::
name|setNotation
parameter_list|(
name|Notation
name|newNotation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDoubleValidator
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|notation
operator|!=
name|newNotation
condition|)
block|{
name|d
operator|->
name|notation
operator|=
name|newNotation
expr_stmt|;
emit|emit
name|notationChanged
argument_list|(
name|d
operator|->
name|notation
argument_list|)
emit|;
emit|emit
name|changed
argument_list|()
emit|;
block|}
block|}
end_function
begin_function
DECL|function|notation
name|QDoubleValidator
operator|::
name|Notation
name|QDoubleValidator
operator|::
name|notation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDoubleValidator
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|notation
return|;
block|}
end_function
begin_comment
comment|/*!     \class QRegExpValidator     \brief The QRegExpValidator class is used to check a string     against a regular expression.      QRegExpValidator uses a regular expression (regexp) to     determine whether an input string is \l Acceptable, \l     Intermediate, or \l Invalid. The regexp can either be supplied     when the QRegExpValidator is constructed, or at a later time.      When QRegExpValidator determines whether a string is \l Acceptable     or not, the regexp is treated as if it begins with the start of string     assertion (\b{^}) and ends with the end of string assertion     (\b{$}); the match is against the entire input string, or from     the given position if a start position greater than zero is given.      If a string is a prefix of an \l Acceptable string, it is considered     \l Intermediate. For example, "" and "A" are \l Intermediate for the     regexp \b{[A-Z][0-9]} (whereas "_" would be \l Invalid).      For a brief introduction to Qt's regexp engine, see \l QRegExp.      Example of use:     \snippet doc/src/snippets/code/src_gui_widgets_qvalidator.cpp 3      Below we present some examples of validators. In practice they would     normally be associated with a widget as in the example above.      \snippet doc/src/snippets/code/src_gui_widgets_qvalidator.cpp 4      \sa QRegExp, QIntValidator, QDoubleValidator, {Settings Editor Example} */
end_comment
begin_comment
comment|/*!     Constructs a validator with a \a parent object that accepts     any string (including an empty one) as valid. */
end_comment
begin_constructor
DECL|function|QRegExpValidator
name|QRegExpValidator
operator|::
name|QRegExpValidator
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|r
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|".*"
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a validator with a \a parent object that     accepts all strings that match the regular expression \a rx.      The match is made against the entire string; e.g. if the regexp is     \b{[A-Fa-f0-9]+} it will be treated as \b{^[A-Fa-f0-9]+$}. */
end_comment
begin_constructor
DECL|function|QRegExpValidator
name|QRegExpValidator
operator|::
name|QRegExpValidator
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QValidator
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|r
argument_list|(
name|rx
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the validator. */
end_comment
begin_destructor
DECL|function|~QRegExpValidator
name|QRegExpValidator
operator|::
name|~
name|QRegExpValidator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns \l Acceptable if \a input is matched by the regular     expression for this validator, \l Intermediate if it has matched     partially (i.e. could be a valid match if additional valid     characters are added), and \l Invalid if \a input is not matched.      The \a pos parameter is set to the length of the \a input parameter.      For example, if the regular expression is \b{\\w\\d\\d}     (word-character, digit, digit) then "A57" is \l Acceptable,     "E5" is \l Intermediate, and "+9" is \l Invalid.      \sa QRegExp::exactMatch() */
end_comment
begin_function
DECL|function|validate
name|QValidator
operator|::
name|State
name|QRegExpValidator
operator|::
name|validate
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|r
operator|.
name|exactMatch
argument_list|(
name|input
argument_list|)
condition|)
block|{
return|return
name|Acceptable
return|;
block|}
else|else
block|{
if|if
condition|(
cast|const_cast
argument_list|<
name|QRegExp
operator|&
argument_list|>
argument_list|(
name|r
argument_list|)
operator|.
name|matchedLength
argument_list|()
operator|==
name|input
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|Intermediate
return|;
block|}
else|else
block|{
name|pos
operator|=
name|input
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|Invalid
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \property QRegExpValidator::regExp     \brief the regular expression used for validation      By default, this property contains a regular expression with the pattern \c{.*}     that matches any string. */
end_comment
begin_function
DECL|function|setRegExp
name|void
name|QRegExpValidator
operator|::
name|setRegExp
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
block|{
if|if
condition|(
name|r
operator|!=
name|rx
condition|)
block|{
name|r
operator|=
name|rx
expr_stmt|;
emit|emit
name|regExpChanged
argument_list|(
name|r
argument_list|)
emit|;
emit|emit
name|changed
argument_list|()
emit|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_VALIDATOR
end_comment
end_unit
