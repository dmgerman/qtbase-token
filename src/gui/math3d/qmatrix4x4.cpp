begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmatrix4x4.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvariant.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qmatrix.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qtransform.h>
end_include
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_MATRIX4X4
comment|/*!     \class QMatrix4x4     \brief The QMatrix4x4 class represents a 4x4 transformation matrix in 3D space.     \since 4.6     \ingroup painting-3D     \inmodule QtGui      The QMatrix4x4 class in general is treated as a row-major matrix, in that the     constructors and operator() functions take data in row-major format, as is     familiar in C-style usage.      Internally the data is stored as column-major format, so as to be optimal for     passing to OpenGL functions, which expect column-major data.      When using these functions be aware that they return data in \b{column-major}     format:     \list     \li data()     \li constData()     \endlist      \sa QVector3D, QGenericMatrix */
DECL|variable|inv_dist_to_plane
specifier|static
specifier|const
name|float
name|inv_dist_to_plane
init|=
literal|1.0f
operator|/
literal|1024.0f
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \fn QMatrix4x4::QMatrix4x4()      Constructs an identity matrix. */
end_comment
begin_comment
comment|/*!     Constructs a matrix from the given 16 floating-point \a values.     The contents of the array \a values is assumed to be in     row-major order.      If the matrix has a special type (identity, translate, scale, etc),     the programmer should follow this constructor with a call to     optimize() if they wish QMatrix4x4 to optimize further     calls to translate(), scale(), etc.      \sa copyDataTo(), optimize() */
end_comment
begin_constructor
DECL|function|QMatrix4x4
name|QMatrix4x4
operator|::
name|QMatrix4x4
parameter_list|(
specifier|const
name|float
modifier|*
name|values
parameter_list|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
name|m
index|[
name|col
index|]
index|[
name|row
index|]
operator|=
name|values
index|[
name|row
operator|*
literal|4
operator|+
name|col
index|]
expr_stmt|;
name|flagBits
operator|=
name|General
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QMatrix4x4::QMatrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44)      Constructs a matrix from the 16 elements \a m11, \a m12, \a m13, \a m14,     \a m21, \a m22, \a m23, \a m24, \a m31, \a m32, \a m33, \a m34,     \a m41, \a m42, \a m43, and \a m44.  The elements are specified in     row-major order.      If the matrix has a special type (identity, translate, scale, etc),     the programmer should follow this constructor with a call to     optimize() if they wish QMatrix4x4 to optimize further     calls to translate(), scale(), etc.      \sa optimize() */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4::QMatrix4x4(const QGenericMatrix<N, M, float>& matrix)      Constructs a 4x4 matrix from the left-most 4 columns and top-most     4 rows of \a matrix.  If \a matrix has less than 4 columns or rows,     the remaining elements are filled with elements from the identity     matrix.      \sa toGenericMatrix() */
end_comment
begin_comment
comment|/*!     \fn QGenericMatrix<N, M, float> QMatrix4x4::toGenericMatrix() const      Constructs a NxM generic matrix from the left-most N columns and     top-most M rows of this 4x4 matrix.  If N or M is greater than 4,     then the remaining elements are filled with elements from the     identity matrix. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, float>& matrix)     \relates QMatrix4x4     \obsolete      Returns a 4x4 matrix constructed from the left-most 4 columns and     top-most 4 rows of \a matrix.  If \a matrix has less than 4 columns     or rows, the remaining elements are filled with elements from the     identity matrix.      \sa QMatrix4x4(const QGenericMatrix&) */
end_comment
begin_comment
comment|/*!     \fn QGenericMatrix<N, M, float> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)     \relates QMatrix4x4     \obsolete      Returns a NxM generic matrix constructed from the left-most N columns     and top-most M rows of \a matrix.  If N or M is greater than 4,     then the remaining elements are filled with elements from the     identity matrix.      \sa QMatrix4x4::toGenericMatrix() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QMatrix4x4
name|QMatrix4x4
operator|::
name|QMatrix4x4
parameter_list|(
specifier|const
name|float
modifier|*
name|values
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
block|{
if|if
condition|(
name|col
operator|<
name|cols
operator|&&
name|row
operator|<
name|rows
condition|)
name|m
index|[
name|col
index|]
index|[
name|row
index|]
operator|=
name|values
index|[
name|col
operator|*
name|rows
operator|+
name|row
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|==
name|row
condition|)
name|m
index|[
name|col
index|]
index|[
name|row
index|]
operator|=
literal|1.0f
expr_stmt|;
else|else
name|m
index|[
name|col
index|]
index|[
name|row
index|]
operator|=
literal|0.0f
expr_stmt|;
block|}
block|}
name|flagBits
operator|=
name|General
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a 4x4 matrix from a conventional Qt 2D affine     transformation \a matrix.      If \a matrix has a special type (identity, translate, scale, etc),     the programmer should follow this constructor with a call to     optimize() if they wish QMatrix4x4 to optimize further     calls to translate(), scale(), etc.      \sa toAffine(), optimize() */
end_comment
begin_constructor
DECL|function|QMatrix4x4
name|QMatrix4x4
operator|::
name|QMatrix4x4
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m11
argument_list|()
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m12
argument_list|()
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m21
argument_list|()
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m22
argument_list|()
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|flagBits
operator|=
name|Translation
operator||
name|Scale
operator||
name|Rotation2D
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a 4x4 matrix from the conventional Qt 2D     transformation matrix \a transform.      If \a transform has a special type (identity, translate, scale, etc),     the programmer should follow this constructor with a call to     optimize() if they wish QMatrix4x4 to optimize further     calls to translate(), scale(), etc.      \sa toTransform(), optimize() */
end_comment
begin_constructor
DECL|function|QMatrix4x4
name|QMatrix4x4
operator|::
name|QMatrix4x4
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|transform
operator|.
name|m11
argument_list|()
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|transform
operator|.
name|m12
argument_list|()
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|transform
operator|.
name|m21
argument_list|()
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|transform
operator|.
name|m22
argument_list|()
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|transform
operator|.
name|dx
argument_list|()
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|transform
operator|.
name|dy
argument_list|()
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
name|flagBits
operator|=
name|General
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn const float& QMatrix4x4::operator()(int row, int column) const      Returns a constant reference to the element at position     (\a row, \a column) in this matrix.      \sa column(), row() */
end_comment
begin_comment
comment|/*!     \fn float& QMatrix4x4::operator()(int row, int column)      Returns a reference to the element at position (\a row, \a column)     in this matrix so that the element can be assigned to.      \sa optimize(), setColumn(), setRow() */
end_comment
begin_comment
comment|/*!     \fn QVector4D QMatrix4x4::column(int index) const      Returns the elements of column \a index as a 4D vector.      \sa setColumn(), row() */
end_comment
begin_comment
comment|/*!     \fn void QMatrix4x4::setColumn(int index, const QVector4D& value)      Sets the elements of column \a index to the components of \a value.      \sa column(), setRow() */
end_comment
begin_comment
comment|/*!     \fn QVector4D QMatrix4x4::row(int index) const      Returns the elements of row \a index as a 4D vector.      \sa setRow(), column() */
end_comment
begin_comment
comment|/*!     \fn void QMatrix4x4::setRow(int index, const QVector4D& value)      Sets the elements of row \a index to the components of \a value.      \sa row(), setColumn() */
end_comment
begin_comment
comment|/*!     \fn bool QMatrix4x4::isIdentity() const      Returns true if this matrix is the identity; false otherwise.      \sa setToIdentity() */
end_comment
begin_comment
comment|/*!     \fn void QMatrix4x4::setToIdentity()      Sets this matrix to the identity.      \sa isIdentity() */
end_comment
begin_comment
comment|/*!     \fn void QMatrix4x4::fill(float value)      Fills all elements of this matrx with \a value. */
end_comment
begin_function
DECL|function|matrixDet2
specifier|static
specifier|inline
name|double
name|matrixDet2
parameter_list|(
specifier|const
name|double
name|m
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|int
name|col0
parameter_list|,
name|int
name|col1
parameter_list|,
name|int
name|row0
parameter_list|,
name|int
name|row1
parameter_list|)
block|{
return|return
name|m
index|[
name|col0
index|]
index|[
name|row0
index|]
operator|*
name|m
index|[
name|col1
index|]
index|[
name|row1
index|]
operator|-
name|m
index|[
name|col0
index|]
index|[
name|row1
index|]
operator|*
name|m
index|[
name|col1
index|]
index|[
name|row0
index|]
return|;
block|}
end_function
begin_comment
comment|// The 4x4 matrix inverse algorithm is based on that described at:
end_comment
begin_comment
comment|// http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q24
end_comment
begin_comment
comment|// Some optimization has been done to avoid making copies of 3x3
end_comment
begin_comment
comment|// sub-matrices and to unroll the loops.
end_comment
begin_comment
comment|// Calculate the determinant of a 3x3 sub-matrix.
end_comment
begin_comment
comment|//     | A B C |
end_comment
begin_comment
comment|// M = | D E F |   det(M) = A * (EI - HF) - B * (DI - GF) + C * (DH - GE)
end_comment
begin_comment
comment|//     | G H I |
end_comment
begin_function
DECL|function|matrixDet3
specifier|static
specifier|inline
name|double
name|matrixDet3
parameter_list|(
specifier|const
name|double
name|m
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|int
name|col0
parameter_list|,
name|int
name|col1
parameter_list|,
name|int
name|col2
parameter_list|,
name|int
name|row0
parameter_list|,
name|int
name|row1
parameter_list|,
name|int
name|row2
parameter_list|)
block|{
return|return
name|m
index|[
name|col0
index|]
index|[
name|row0
index|]
operator|*
name|matrixDet2
argument_list|(
name|m
argument_list|,
name|col1
argument_list|,
name|col2
argument_list|,
name|row1
argument_list|,
name|row2
argument_list|)
operator|-
name|m
index|[
name|col1
index|]
index|[
name|row0
index|]
operator|*
name|matrixDet2
argument_list|(
name|m
argument_list|,
name|col0
argument_list|,
name|col2
argument_list|,
name|row1
argument_list|,
name|row2
argument_list|)
operator|+
name|m
index|[
name|col2
index|]
index|[
name|row0
index|]
operator|*
name|matrixDet2
argument_list|(
name|m
argument_list|,
name|col0
argument_list|,
name|col1
argument_list|,
name|row1
argument_list|,
name|row2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Calculate the determinant of a 4x4 matrix.
end_comment
begin_function
DECL|function|matrixDet4
specifier|static
specifier|inline
name|double
name|matrixDet4
parameter_list|(
specifier|const
name|double
name|m
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
block|{
name|double
name|det
decl_stmt|;
name|det
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|matrixDet3
argument_list|(
name|m
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|det
operator|-=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|matrixDet3
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|det
operator|+=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|matrixDet3
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|det
operator|-=
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|*
name|matrixDet3
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|det
return|;
block|}
end_function
begin_function
DECL|function|copyToDoubles
specifier|static
specifier|inline
name|void
name|copyToDoubles
parameter_list|(
specifier|const
name|float
name|m
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
name|mm
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|double
argument_list|(
name|m
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the determinant of this matrix. */
end_comment
begin_function
DECL|function|determinant
name|double
name|QMatrix4x4
operator|::
name|determinant
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|(
name|flagBits
operator|&
operator|~
operator|(
name|Translation
operator||
name|Rotation2D
operator||
name|Rotation
operator|)
operator|)
operator|==
name|Identity
condition|)
return|return
literal|1.0
return|;
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
return|return
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
return|;
comment|// Translation | Scale
if|if
condition|(
name|flagBits
operator|<
name|Perspective
condition|)
return|return
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
return|;
return|return
name|matrixDet4
argument_list|(
name|mm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the inverse of this matrix.  Returns the identity if     this matrix cannot be inverted; i.e. determinant() is zero.     If \a invertible is not null, then true will be written to     that location if the matrix can be inverted; false otherwise.      If the matrix is recognized as the identity or an orthonormal     matrix, then this function will quickly invert the matrix     using optimized routines.      \sa determinant(), normalMatrix() */
end_comment
begin_function
DECL|function|inverted
name|QMatrix4x4
name|QMatrix4x4
operator|::
name|inverted
parameter_list|(
name|bool
modifier|*
name|invertible
parameter_list|)
specifier|const
block|{
comment|// Handle some of the easy cases first.
if|if
condition|(
name|flagBits
operator|==
name|Identity
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|QMatrix4x4
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Translation
condition|)
block|{
name|QMatrix4x4
name|inv
decl_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|flagBits
operator|=
name|Translation
expr_stmt|;
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|inv
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
comment|// Translation | Scale
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|false
expr_stmt|;
return|return
name|QMatrix4x4
argument_list|()
return|;
block|}
name|QMatrix4x4
name|inv
decl_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|*
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|*
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|*
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|flagBits
operator|=
name|flagBits
expr_stmt|;
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|inv
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flagBits
operator|&
operator|~
operator|(
name|Translation
operator||
name|Rotation2D
operator||
name|Rotation
operator|)
operator|)
operator|==
name|Identity
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|orthonormalInverse
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Perspective
condition|)
block|{
name|QMatrix4x4
name|inv
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|double
name|det
init|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|false
expr_stmt|;
return|return
name|QMatrix4x4
argument_list|()
return|;
block|}
name|det
operator|=
literal|1.0f
operator|/
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|-
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|inv
operator|.
name|flagBits
operator|=
name|flagBits
expr_stmt|;
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|inv
return|;
block|}
name|QMatrix4x4
name|inv
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|double
name|det
init|=
name|matrixDet4
argument_list|(
name|mm
argument_list|)
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|false
expr_stmt|;
return|return
name|QMatrix4x4
argument_list|()
return|;
block|}
name|det
operator|=
literal|1.0f
operator|/
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|det
expr_stmt|;
name|inv
operator|.
name|flagBits
operator|=
name|flagBits
expr_stmt|;
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
return|return
name|inv
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the normal matrix corresponding to this 4x4 transformation.     The normal matrix is the transpose of the inverse of the top-left     3x3 part of this 4x4 matrix.  If the 3x3 sub-matrix is not invertible,     this function returns the identity.      \sa inverted() */
end_comment
begin_function
DECL|function|normalMatrix
name|QMatrix3x3
name|QMatrix4x4
operator|::
name|normalMatrix
parameter_list|()
specifier|const
block|{
name|QMatrix3x3
name|inv
decl_stmt|;
comment|// Handle the simple cases first.
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
comment|// Translation
return|return
name|inv
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
comment|// Translation | Scale
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|0.0f
operator|||
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0.0f
operator|||
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|==
literal|0.0f
condition|)
return|return
name|inv
return|;
name|inv
operator|.
name|data
argument_list|()
index|[
literal|0
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|inv
operator|.
name|data
argument_list|()
index|[
literal|4
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|inv
operator|.
name|data
argument_list|()
index|[
literal|8
index|]
operator|=
literal|1.0f
operator|/
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
return|return
name|inv
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flagBits
operator|&
operator|~
operator|(
name|Translation
operator||
name|Rotation2D
operator||
name|Rotation
operator|)
operator|)
operator|==
name|Identity
condition|)
block|{
name|float
modifier|*
name|invm
init|=
name|inv
operator|.
name|data
argument_list|()
decl_stmt|;
name|invm
index|[
literal|0
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|invm
index|[
literal|0
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|invm
index|[
literal|0
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
return|return
name|inv
return|;
block|}
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|double
name|det
init|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0.0f
condition|)
return|return
name|inv
return|;
name|det
operator|=
literal|1.0f
operator|/
name|det
expr_stmt|;
name|float
modifier|*
name|invm
init|=
name|inv
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// Invert and transpose in a single step.
name|invm
index|[
literal|0
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
operator|(
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
operator|-
operator|(
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|0
operator|*
literal|3
index|]
operator|=
operator|(
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|0
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
operator|-
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|1
operator|*
literal|3
index|]
operator|=
operator|-
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|0
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|1
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
operator|-
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|det
expr_stmt|;
name|invm
index|[
literal|2
operator|+
literal|2
operator|*
literal|3
index|]
operator|=
operator|(
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|det
expr_stmt|;
return|return
name|inv
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this matrix, transposed about its diagonal. */
end_comment
begin_function
DECL|function|transposed
name|QMatrix4x4
name|QMatrix4x4
operator|::
name|transposed
parameter_list|()
specifier|const
block|{
name|QMatrix4x4
name|result
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
block|{
name|result
operator|.
name|m
index|[
name|col
index|]
index|[
name|row
index|]
operator|=
name|m
index|[
name|row
index|]
index|[
name|col
index|]
expr_stmt|;
block|}
block|}
comment|// When a translation is transposed, it becomes a perspective transformation.
name|result
operator|.
name|flagBits
operator|=
operator|(
name|flagBits
operator|&
name|Translation
condition|?
name|General
else|:
name|flagBits
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix4x4& QMatrix4x4::operator+=(const QMatrix4x4& other)      Adds the contents of \a other to this matrix. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4& QMatrix4x4::operator-=(const QMatrix4x4& other)      Subtracts the contents of \a other from this matrix. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4& QMatrix4x4::operator*=(const QMatrix4x4& other)      Multiplies the contents of \a other by this matrix. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4& QMatrix4x4::operator*=(float factor)     \overload      Multiplies all elements of this matrix by \a factor. */
end_comment
begin_comment
comment|/*!     \overload      Divides all elements of this matrix by \a divisor. */
end_comment
begin_function
DECL|function|operator /=
name|QMatrix4x4
modifier|&
name|QMatrix4x4
operator|::
name|operator
name|/=
parameter_list|(
name|float
name|divisor
parameter_list|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|/=
name|divisor
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|/=
name|divisor
expr_stmt|;
name|flagBits
operator|=
name|General
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMatrix4x4::operator==(const QMatrix4x4& other) const      Returns true if this matrix is identical to \a other; false otherwise.     This operator uses an exact floating-point comparison. */
end_comment
begin_comment
comment|/*!     \fn bool QMatrix4x4::operator!=(const QMatrix4x4& other) const      Returns true if this matrix is not identical to \a other; false otherwise.     This operator uses an exact floating-point comparison. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator+(const QMatrix4x4& m1, const QMatrix4x4& m2)     \relates QMatrix4x4      Returns the sum of \a m1 and \a m2. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator-(const QMatrix4x4& m1, const QMatrix4x4& m2)     \relates QMatrix4x4      Returns the difference of \a m1 and \a m2. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator*(const QMatrix4x4& m1, const QMatrix4x4& m2)     \relates QMatrix4x4      Returns the product of \a m1 and \a m2. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     \fn QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix)     \relates QMatrix4x4      Returns the result of transforming \a vector according to \a matrix,     with the matrix applied post-vector. */
end_comment
begin_comment
comment|/*!     \fn QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector)     \relates QMatrix4x4      Returns the result of transforming \a vector according to \a matrix,     with the matrix applied pre-vector. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR4D
end_ifndef
begin_comment
comment|/*!     \fn QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix)     \relates QMatrix4x4      Returns the result of transforming \a vector according to \a matrix,     with the matrix applied post-vector. */
end_comment
begin_comment
comment|/*!     \fn QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector)     \relates QMatrix4x4      Returns the result of transforming \a vector according to \a matrix,     with the matrix applied pre-vector. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QPoint operator*(const QPoint& point, const QMatrix4x4& matrix)     \relates QMatrix4x4      Returns the result of transforming \a point according to \a matrix,     with the matrix applied post-point. */
end_comment
begin_comment
comment|/*!     \fn QPointF operator*(const QPointF& point, const QMatrix4x4& matrix)     \relates QMatrix4x4      Returns the result of transforming \a point according to \a matrix,     with the matrix applied post-point. */
end_comment
begin_comment
comment|/*!     \fn QPoint operator*(const QMatrix4x4& matrix, const QPoint& point)     \relates QMatrix4x4      Returns the result of transforming \a point according to \a matrix,     with the matrix applied pre-point. */
end_comment
begin_comment
comment|/*!     \fn QPointF operator*(const QMatrix4x4& matrix, const QPointF& point)     \relates QMatrix4x4      Returns the result of transforming \a point according to \a matrix,     with the matrix applied pre-point. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator-(const QMatrix4x4& matrix)     \overload     \relates QMatrix4x4      Returns the negation of \a matrix. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator*(float factor, const QMatrix4x4& matrix)     \relates QMatrix4x4      Returns the result of multiplying all elements of \a matrix by \a factor. */
end_comment
begin_comment
comment|/*!     \fn QMatrix4x4 operator*(const QMatrix4x4& matrix, float factor)     \relates QMatrix4x4      Returns the result of multiplying all elements of \a matrix by \a factor. */
end_comment
begin_comment
comment|/*!     \relates QMatrix4x4      Returns the result of dividing all elements of \a matrix by \a divisor. */
end_comment
begin_function
DECL|function|operator /
name|QMatrix4x4
name|operator
name|/
parameter_list|(
specifier|const
name|QMatrix4x4
modifier|&
name|matrix
parameter_list|,
name|float
name|divisor
parameter_list|)
block|{
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
name|matrix
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|/
name|divisor
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|QMatrix4x4
operator|::
name|General
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool qFuzzyCompare(const QMatrix4x4& m1, const QMatrix4x4& m2)     \relates QMatrix4x4      Returns true if \a m1 and \a m2 are equal, allowing for a small     fuzziness factor for floating-point comparisons; false otherwise. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     Multiplies this matrix by another that scales coordinates by     the components of \a vector.      \sa translate(), rotate() */
end_comment
begin_function
DECL|function|scale
name|void
name|QMatrix4x4
operator|::
name|scale
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|vector
parameter_list|)
block|{
name|float
name|vx
init|=
name|vector
operator|.
name|x
argument_list|()
decl_stmt|;
name|float
name|vy
init|=
name|vector
operator|.
name|y
argument_list|()
decl_stmt|;
name|float
name|vz
init|=
name|vector
operator|.
name|z
argument_list|()
decl_stmt|;
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|vx
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|vy
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|vz
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*=
name|vx
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*=
name|vy
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*=
name|vz
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*=
name|vz
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|vz
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*=
name|vz
expr_stmt|;
block|}
name|flagBits
operator||=
name|Scale
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that scales coordinates by the     components \a x, and \a y.      \sa translate(), rotate() */
end_comment
begin_function
DECL|function|scale
name|void
name|QMatrix4x4
operator|::
name|scale
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*=
name|y
expr_stmt|;
block|}
name|flagBits
operator||=
name|Scale
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that scales coordinates by the     components \a x, \a y, and \a z.      \sa translate(), rotate() */
end_comment
begin_function
DECL|function|scale
name|void
name|QMatrix4x4
operator|::
name|scale
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|z
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*=
name|x
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*=
name|y
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*=
name|z
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*=
name|z
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|z
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*=
name|z
expr_stmt|;
block|}
name|flagBits
operator||=
name|Scale
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that scales coordinates by the     given \a factor.      \sa translate(), rotate() */
end_comment
begin_function
DECL|function|scale
name|void
name|QMatrix4x4
operator|::
name|scale
parameter_list|(
name|float
name|factor
parameter_list|)
block|{
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|factor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|factor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|factor
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*=
name|factor
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*=
name|factor
expr_stmt|;
block|}
name|flagBits
operator||=
name|Scale
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     Multiplies this matrix by another that translates coordinates by     the components of \a vector.      \sa scale(), rotate() */
end_comment
begin_function
DECL|function|translate
name|void
name|QMatrix4x4
operator|::
name|translate
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|vector
parameter_list|)
block|{
name|float
name|vx
init|=
name|vector
operator|.
name|x
argument_list|()
decl_stmt|;
name|float
name|vy
init|=
name|vector
operator|.
name|y
argument_list|()
decl_stmt|;
name|float
name|vz
init|=
name|vector
operator|.
name|z
argument_list|()
decl_stmt|;
if|if
condition|(
name|flagBits
operator|==
name|Identity
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|vx
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Translation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|vx
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Scale
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|vx
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
operator|(
name|Translation
operator||
name|Scale
operator|)
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|vx
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|vz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|vy
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|vz
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|vy
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|vz
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|vy
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|vz
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|vy
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|vz
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|vx
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|vy
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|vz
expr_stmt|;
block|}
name|flagBits
operator||=
name|Translation
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that translates coordinates     by the components \a x, and \a y.      \sa scale(), rotate() */
end_comment
begin_function
DECL|function|translate
name|void
name|QMatrix4x4
operator|::
name|translate
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
if|if
condition|(
name|flagBits
operator|==
name|Identity
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Translation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Scale
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
operator|(
name|Translation
operator||
name|Scale
operator|)
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|y
expr_stmt|;
block|}
name|flagBits
operator||=
name|Translation
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that translates coordinates     by the components \a x, \a y, and \a z.      \sa scale(), rotate() */
end_comment
begin_function
DECL|function|translate
name|void
name|QMatrix4x4
operator|::
name|translate
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
if|if
condition|(
name|flagBits
operator|==
name|Identity
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Translation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
name|Scale
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|==
operator|(
name|Translation
operator||
name|Scale
operator|)
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation
condition|)
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|z
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|z
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
expr_stmt|;
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|x
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|y
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|z
expr_stmt|;
block|}
name|flagBits
operator||=
name|Translation
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     Multiples this matrix by another that rotates coordinates through     \a angle degrees about \a vector.      \sa scale(), translate() */
end_comment
begin_function
DECL|function|rotate
name|void
name|QMatrix4x4
operator|::
name|rotate
parameter_list|(
name|float
name|angle
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|vector
parameter_list|)
block|{
name|rotate
argument_list|(
name|angle
argument_list|,
name|vector
operator|.
name|x
argument_list|()
argument_list|,
name|vector
operator|.
name|y
argument_list|()
argument_list|,
name|vector
operator|.
name|z
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that rotates coordinates through     \a angle degrees about the vector (\a x, \a y, \a z).      \sa scale(), translate() */
end_comment
begin_function
DECL|function|rotate
name|void
name|QMatrix4x4
operator|::
name|rotate
parameter_list|(
name|float
name|angle
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
if|if
condition|(
name|angle
operator|==
literal|0.0f
condition|)
return|return;
name|float
name|c
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|angle
operator|==
literal|90.0f
operator|||
name|angle
operator|==
operator|-
literal|270.0f
condition|)
block|{
name|s
operator|=
literal|1.0f
expr_stmt|;
name|c
operator|=
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|angle
operator|==
operator|-
literal|90.0f
operator|||
name|angle
operator|==
literal|270.0f
condition|)
block|{
name|s
operator|=
operator|-
literal|1.0f
expr_stmt|;
name|c
operator|=
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|angle
operator|==
literal|180.0f
operator|||
name|angle
operator|==
operator|-
literal|180.0f
condition|)
block|{
name|s
operator|=
literal|0.0f
expr_stmt|;
name|c
operator|=
operator|-
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
name|float
name|a
init|=
name|angle
operator|*
name|M_PI
operator|/
literal|180.0f
decl_stmt|;
name|c
operator|=
name|cosf
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|=
name|sinf
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|y
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|z
operator|!=
literal|0.0f
condition|)
block|{
comment|// Rotate around the Z axis.
if|if
condition|(
name|z
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|float
name|tmp
decl_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|flagBits
operator||=
name|Rotation2D
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|z
operator|==
literal|0.0f
condition|)
block|{
comment|// Rotate around the Y axis.
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|float
name|tmp
decl_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|flagBits
operator||=
name|Rotation
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|y
operator|==
literal|0.0f
operator|&&
name|z
operator|==
literal|0.0f
condition|)
block|{
comment|// Rotate around the X axis.
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|float
name|tmp
decl_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|flagBits
operator||=
name|Rotation
expr_stmt|;
return|return;
block|}
name|double
name|len
init|=
name|double
argument_list|(
name|x
argument_list|)
operator|*
name|double
argument_list|(
name|x
argument_list|)
operator|+
name|double
argument_list|(
name|y
argument_list|)
operator|*
name|double
argument_list|(
name|y
argument_list|)
operator|+
name|double
argument_list|(
name|z
argument_list|)
operator|*
name|double
argument_list|(
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyCompare
argument_list|(
name|len
argument_list|,
literal|1.0
argument_list|)
operator|&&
operator|!
name|qFuzzyIsNull
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|len
operator|=
name|sqrt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|x
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|x
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
name|y
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|y
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
name|z
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|z
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
block|}
name|float
name|ic
init|=
literal|1.0f
operator|-
name|c
decl_stmt|;
name|QMatrix4x4
name|rot
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|x
operator|*
name|x
operator|*
name|ic
operator|+
name|c
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|x
operator|*
name|y
operator|*
name|ic
operator|-
name|z
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|x
operator|*
name|z
operator|*
name|ic
operator|+
name|y
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|y
operator|*
name|x
operator|*
name|ic
operator|+
name|z
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|y
operator|*
name|y
operator|*
name|ic
operator|+
name|c
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|y
operator|*
name|z
operator|*
name|ic
operator|-
name|x
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|x
operator|*
name|z
operator|*
name|ic
operator|-
name|y
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|y
operator|*
name|z
operator|*
name|ic
operator|+
name|x
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|z
operator|*
name|z
operator|*
name|ic
operator|+
name|c
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|rot
operator|.
name|flagBits
operator|=
name|Rotation
expr_stmt|;
operator|*
name|this
operator|*=
name|rot
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|projectedRotate
name|void
name|QMatrix4x4
operator|::
name|projectedRotate
parameter_list|(
name|float
name|angle
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
comment|// Used by QGraphicsRotation::applyTo() to perform a rotation
comment|// and projection back to 2D in a single step.
if|if
condition|(
name|angle
operator|==
literal|0.0f
condition|)
return|return;
name|float
name|c
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|angle
operator|==
literal|90.0f
operator|||
name|angle
operator|==
operator|-
literal|270.0f
condition|)
block|{
name|s
operator|=
literal|1.0f
expr_stmt|;
name|c
operator|=
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|angle
operator|==
operator|-
literal|90.0f
operator|||
name|angle
operator|==
literal|270.0f
condition|)
block|{
name|s
operator|=
operator|-
literal|1.0f
expr_stmt|;
name|c
operator|=
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|angle
operator|==
literal|180.0f
operator|||
name|angle
operator|==
operator|-
literal|180.0f
condition|)
block|{
name|s
operator|=
literal|0.0f
expr_stmt|;
name|c
operator|=
operator|-
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
name|float
name|a
init|=
name|angle
operator|*
name|M_PI
operator|/
literal|180.0f
decl_stmt|;
name|c
operator|=
name|cosf
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|=
name|sinf
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|y
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|z
operator|!=
literal|0.0f
condition|)
block|{
comment|// Rotate around the Z axis.
if|if
condition|(
name|z
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|float
name|tmp
decl_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|tmp
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|)
operator|*
name|c
operator|+
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|-
name|tmp
operator|*
name|s
expr_stmt|;
name|flagBits
operator||=
name|Rotation2D
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|z
operator|==
literal|0.0f
condition|)
block|{
comment|// Rotate around the Y axis.
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|flagBits
operator|=
name|General
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|y
operator|==
literal|0.0f
operator|&&
name|z
operator|==
literal|0.0f
condition|)
block|{
comment|// Rotate around the X axis.
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|c
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|c
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|c
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|c
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|*
name|s
operator|*
name|inv_dist_to_plane
expr_stmt|;
name|flagBits
operator|=
name|General
expr_stmt|;
return|return;
block|}
name|double
name|len
init|=
name|double
argument_list|(
name|x
argument_list|)
operator|*
name|double
argument_list|(
name|x
argument_list|)
operator|+
name|double
argument_list|(
name|y
argument_list|)
operator|*
name|double
argument_list|(
name|y
argument_list|)
operator|+
name|double
argument_list|(
name|z
argument_list|)
operator|*
name|double
argument_list|(
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyCompare
argument_list|(
name|len
argument_list|,
literal|1.0
argument_list|)
operator|&&
operator|!
name|qFuzzyIsNull
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|len
operator|=
name|sqrt
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|x
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|x
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
name|y
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|y
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
name|z
operator|=
name|float
argument_list|(
name|double
argument_list|(
name|z
argument_list|)
operator|/
name|len
argument_list|)
expr_stmt|;
block|}
name|float
name|ic
init|=
literal|1.0f
operator|-
name|c
decl_stmt|;
name|QMatrix4x4
name|rot
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The "1" says to not load the identity.
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|x
operator|*
name|x
operator|*
name|ic
operator|+
name|c
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|x
operator|*
name|y
operator|*
name|ic
operator|-
name|z
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|y
operator|*
name|x
operator|*
name|ic
operator|+
name|z
operator|*
name|s
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|y
operator|*
name|y
operator|*
name|ic
operator|+
name|c
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|x
operator|*
name|z
operator|*
name|ic
operator|-
name|y
operator|*
name|s
operator|)
operator|*
operator|-
name|inv_dist_to_plane
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
operator|(
name|y
operator|*
name|z
operator|*
name|ic
operator|+
name|x
operator|*
name|s
operator|)
operator|*
operator|-
name|inv_dist_to_plane
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|rot
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|rot
operator|.
name|flagBits
operator|=
name|General
expr_stmt|;
operator|*
name|this
operator|*=
name|rot
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QUATERNION
end_ifndef
begin_comment
comment|/*!     Multiples this matrix by another that rotates coordinates according     to a specified \a quaternion.  The \a quaternion is assumed to have     been normalized.      \sa scale(), translate(), QQuaternion */
end_comment
begin_function
DECL|function|rotate
name|void
name|QMatrix4x4
operator|::
name|rotate
parameter_list|(
specifier|const
name|QQuaternion
modifier|&
name|quaternion
parameter_list|)
block|{
comment|// Algorithm from:
comment|// http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q54
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|float
name|xx
init|=
name|quaternion
operator|.
name|x
argument_list|()
operator|*
name|quaternion
operator|.
name|x
argument_list|()
decl_stmt|;
name|float
name|xy
init|=
name|quaternion
operator|.
name|x
argument_list|()
operator|*
name|quaternion
operator|.
name|y
argument_list|()
decl_stmt|;
name|float
name|xz
init|=
name|quaternion
operator|.
name|x
argument_list|()
operator|*
name|quaternion
operator|.
name|z
argument_list|()
decl_stmt|;
name|float
name|xw
init|=
name|quaternion
operator|.
name|x
argument_list|()
operator|*
name|quaternion
operator|.
name|scalar
argument_list|()
decl_stmt|;
name|float
name|yy
init|=
name|quaternion
operator|.
name|y
argument_list|()
operator|*
name|quaternion
operator|.
name|y
argument_list|()
decl_stmt|;
name|float
name|yz
init|=
name|quaternion
operator|.
name|y
argument_list|()
operator|*
name|quaternion
operator|.
name|z
argument_list|()
decl_stmt|;
name|float
name|yw
init|=
name|quaternion
operator|.
name|y
argument_list|()
operator|*
name|quaternion
operator|.
name|scalar
argument_list|()
decl_stmt|;
name|float
name|zz
init|=
name|quaternion
operator|.
name|z
argument_list|()
operator|*
name|quaternion
operator|.
name|z
argument_list|()
decl_stmt|;
name|float
name|zw
init|=
name|quaternion
operator|.
name|z
argument_list|()
operator|*
name|quaternion
operator|.
name|scalar
argument_list|()
decl_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0f
operator|-
literal|2
operator|*
operator|(
name|yy
operator|+
name|zz
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|xy
operator|-
name|zw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|xz
operator|+
name|yw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|xy
operator|+
name|zw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0f
operator|-
literal|2
operator|*
operator|(
name|xx
operator|+
name|zz
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|yz
operator|-
name|xw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|2
operator|*
operator|(
name|xz
operator|-
name|yw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|2
operator|*
operator|(
name|yz
operator|+
name|xw
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|1.0f
operator|-
literal|2
operator|*
operator|(
name|xx
operator|+
name|yy
operator|)
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|Rotation
expr_stmt|;
operator|*
name|this
operator|*=
name|m
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that applies an orthographic     projection for a window with boundaries specified by \a rect.     The near and far clipping planes will be -1 and 1 respectively.      \sa frustum(), perspective() */
end_comment
begin_function
DECL|function|ortho
name|void
name|QMatrix4x4
operator|::
name|ortho
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
comment|// Note: rect.right() and rect.bottom() subtract 1 in QRect,
comment|// which gives the location of a pixel within the rectangle,
comment|// instead of the extent of the rectangle.  We want the extent.
comment|// QRectF expresses the extent properly.
name|ortho
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Multiplies this matrix by another that applies an orthographic     projection for a window with boundaries specified by \a rect.     The near and far clipping planes will be -1 and 1 respectively.      \sa frustum(), perspective() */
end_comment
begin_function
DECL|function|ortho
name|void
name|QMatrix4x4
operator|::
name|ortho
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|ortho
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Multiplies this matrix by another that applies an orthographic     projection for a window with lower-left corner (\a left, \a bottom),     upper-right corner (\a right, \a top), and the specified \a nearPlane     and \a farPlane clipping planes.      \sa frustum(), perspective() */
end_comment
begin_function
DECL|function|ortho
name|void
name|QMatrix4x4
operator|::
name|ortho
parameter_list|(
name|float
name|left
parameter_list|,
name|float
name|right
parameter_list|,
name|float
name|bottom
parameter_list|,
name|float
name|top
parameter_list|,
name|float
name|nearPlane
parameter_list|,
name|float
name|farPlane
parameter_list|)
block|{
comment|// Bail out if the projection volume is zero-sized.
if|if
condition|(
name|left
operator|==
name|right
operator|||
name|bottom
operator|==
name|top
operator|||
name|nearPlane
operator|==
name|farPlane
condition|)
return|return;
comment|// Construct the projection.
name|float
name|width
init|=
name|right
operator|-
name|left
decl_stmt|;
name|float
name|invheight
init|=
name|top
operator|-
name|bottom
decl_stmt|;
name|float
name|clip
init|=
name|farPlane
operator|-
name|nearPlane
decl_stmt|;
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|2.0f
operator|/
name|width
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|left
operator|+
name|right
operator|)
operator|/
name|width
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|2.0f
operator|/
name|invheight
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
operator|(
name|top
operator|+
name|bottom
operator|)
operator|/
name|invheight
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
literal|2.0f
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|nearPlane
operator|+
name|farPlane
operator|)
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|Translation
operator||
name|Scale
expr_stmt|;
comment|// Apply the projection.
operator|*
name|this
operator|*=
name|m
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Multiplies this matrix by another that applies a perspective     frustum projection for a window with lower-left corner (\a left, \a bottom),     upper-right corner (\a right, \a top), and the specified \a nearPlane     and \a farPlane clipping planes.      \sa ortho(), perspective() */
end_comment
begin_function
DECL|function|frustum
name|void
name|QMatrix4x4
operator|::
name|frustum
parameter_list|(
name|float
name|left
parameter_list|,
name|float
name|right
parameter_list|,
name|float
name|bottom
parameter_list|,
name|float
name|top
parameter_list|,
name|float
name|nearPlane
parameter_list|,
name|float
name|farPlane
parameter_list|)
block|{
comment|// Bail out if the projection volume is zero-sized.
if|if
condition|(
name|left
operator|==
name|right
operator|||
name|bottom
operator|==
name|top
operator|||
name|nearPlane
operator|==
name|farPlane
condition|)
return|return;
comment|// Construct the projection.
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|float
name|width
init|=
name|right
operator|-
name|left
decl_stmt|;
name|float
name|invheight
init|=
name|top
operator|-
name|bottom
decl_stmt|;
name|float
name|clip
init|=
name|farPlane
operator|-
name|nearPlane
decl_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|2.0f
operator|*
name|nearPlane
operator|/
name|width
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
name|width
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|2.0f
operator|*
name|nearPlane
operator|/
name|invheight
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|top
operator|+
name|bottom
operator|)
operator|/
name|invheight
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|nearPlane
operator|+
name|farPlane
operator|)
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
literal|2.0f
operator|*
name|nearPlane
operator|*
name|farPlane
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|-
literal|1.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|General
expr_stmt|;
comment|// Apply the projection.
operator|*
name|this
operator|*=
name|m
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Multiplies this matrix by another that applies a perspective     projection. The vertical field of view will be \a verticalAngle degrees     within a window with a given \a aspectRatio that determines the horizontal     field of view.     The projection will have the specified \a nearPlane and \a farPlane clipping     planes which are the distances from the viewer to the corresponding planes.      \sa ortho(), frustum() */
end_comment
begin_function
DECL|function|perspective
name|void
name|QMatrix4x4
operator|::
name|perspective
parameter_list|(
name|float
name|verticalAngle
parameter_list|,
name|float
name|aspectRatio
parameter_list|,
name|float
name|nearPlane
parameter_list|,
name|float
name|farPlane
parameter_list|)
block|{
comment|// Bail out if the projection volume is zero-sized.
if|if
condition|(
name|nearPlane
operator|==
name|farPlane
operator|||
name|aspectRatio
operator|==
literal|0.0f
condition|)
return|return;
comment|// Construct the projection.
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|float
name|radians
init|=
operator|(
name|verticalAngle
operator|/
literal|2.0f
operator|)
operator|*
name|M_PI
operator|/
literal|180.0f
decl_stmt|;
name|float
name|sine
init|=
name|sinf
argument_list|(
name|radians
argument_list|)
decl_stmt|;
if|if
condition|(
name|sine
operator|==
literal|0.0f
condition|)
return|return;
name|float
name|cotan
init|=
name|cosf
argument_list|(
name|radians
argument_list|)
operator|/
name|sine
decl_stmt|;
name|float
name|clip
init|=
name|farPlane
operator|-
name|nearPlane
decl_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|cotan
operator|/
name|aspectRatio
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|cotan
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|nearPlane
operator|+
name|farPlane
operator|)
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
operator|(
literal|2.0f
operator|*
name|nearPlane
operator|*
name|farPlane
operator|)
operator|/
name|clip
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|-
literal|1.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|General
expr_stmt|;
comment|// Apply the projection.
operator|*
name|this
operator|*=
name|m
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     Multiplies this matrix by another that applies an \a eye position     transformation.  The \a center value indicates the center of the     view that the \a eye is looking at.  The \a up value indicates     which direction should be considered up with respect to the \a eye. */
end_comment
begin_function
DECL|function|lookAt
name|void
name|QMatrix4x4
operator|::
name|lookAt
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|eye
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|center
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|up
parameter_list|)
block|{
name|QVector3D
name|forward
init|=
operator|(
name|center
operator|-
name|eye
operator|)
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|QVector3D
name|side
init|=
name|QVector3D
operator|::
name|crossProduct
argument_list|(
name|forward
argument_list|,
name|up
argument_list|)
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|QVector3D
name|upVector
init|=
name|QVector3D
operator|::
name|crossProduct
argument_list|(
name|side
argument_list|,
name|forward
argument_list|)
decl_stmt|;
name|QMatrix4x4
name|m
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|side
operator|.
name|x
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|side
operator|.
name|y
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|side
operator|.
name|z
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|upVector
operator|.
name|x
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|upVector
operator|.
name|y
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|upVector
operator|.
name|z
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|forward
operator|.
name|x
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|forward
operator|.
name|y
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|forward
operator|.
name|z
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|m
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|m
operator|.
name|flagBits
operator|=
name|Rotation
expr_stmt|;
operator|*
name|this
operator|*=
name|m
expr_stmt|;
name|translate
argument_list|(
operator|-
name|eye
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \deprecated      Flips between right-handed and left-handed coordinate systems     by multiplying the y and z co-ordinates by -1.  This is normally     used to create a left-handed orthographic view without scaling     the viewport as ortho() does.      \sa ortho() */
end_comment
begin_function
DECL|function|flipCoordinates
name|void
name|QMatrix4x4
operator|::
name|flipCoordinates
parameter_list|()
block|{
comment|// Multiplying the y and z coordinates with -1 does NOT flip between right-handed and
comment|// left-handed coordinate systems, it just rotates 180 degrees around the x axis, so
comment|// I'm deprecating this function.
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
comment|// Translation | Scale
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
operator|-
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|-
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
expr_stmt|;
block|}
name|flagBits
operator||=
name|Scale
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Retrieves the 16 items in this matrix and copies them to \a values     in row-major order. */
end_comment
begin_function
DECL|function|copyDataTo
name|void
name|QMatrix4x4
operator|::
name|copyDataTo
parameter_list|(
name|float
modifier|*
name|values
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
name|values
index|[
name|row
operator|*
literal|4
operator|+
name|col
index|]
operator|=
name|float
argument_list|(
name|m
index|[
name|col
index|]
index|[
name|row
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the conventional Qt 2D affine transformation matrix that     corresponds to this matrix.  It is assumed that this matrix     only contains 2D affine transformation elements.      \sa toTransform() */
end_comment
begin_function
DECL|function|toAffine
name|QMatrix
name|QMatrix4x4
operator|::
name|toAffine
parameter_list|()
specifier|const
block|{
return|return
name|QMatrix
argument_list|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the conventional Qt 2D transformation matrix that     corresponds to this matrix.      The returned QTransform is formed by simply dropping the     third row and third column of the QMatrix4x4.  This is suitable     for implementing orthographic projections where the z co-ordinate     should be dropped rather than projected.      \sa toAffine() */
end_comment
begin_function
DECL|function|toTransform
name|QTransform
name|QMatrix4x4
operator|::
name|toTransform
parameter_list|()
specifier|const
block|{
return|return
name|QTransform
argument_list|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the conventional Qt 2D transformation matrix that     corresponds to this matrix.      If \a distanceToPlane is non-zero, it indicates a projection     factor to use to adjust for the z co-ordinate.  The value of     1024 corresponds to the projection factor used     by QTransform::rotate() for the x and y axes.      If \a distanceToPlane is zero, then the returned QTransform     is formed by simply dropping the third row and third column     of the QMatrix4x4.  This is suitable for implementing     orthographic projections where the z co-ordinate should     be dropped rather than projected.      \sa toAffine() */
end_comment
begin_function
DECL|function|toTransform
name|QTransform
name|QMatrix4x4
operator|::
name|toTransform
parameter_list|(
name|float
name|distanceToPlane
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|distanceToPlane
operator|==
literal|1024.0f
condition|)
block|{
comment|// Optimize the common case with constants.
return|return
name|QTransform
argument_list|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|inv_dist_to_plane
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|inv_dist_to_plane
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|*
name|inv_dist_to_plane
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|distanceToPlane
operator|!=
literal|0.0f
condition|)
block|{
comment|// The following projection matrix is pre-multiplied with "matrix":
comment|//      | 1 0 0 0 |
comment|//      | 0 1 0 0 |
comment|//      | 0 0 1 0 |
comment|//      | 0 0 d 1 |
comment|// where d = -1 / distanceToPlane.  After projection, row 3 and
comment|// column 3 are dropped to form the final QTransform.
name|float
name|d
init|=
literal|1.0f
operator|/
name|distanceToPlane
decl_stmt|;
return|return
name|QTransform
argument_list|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|d
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|d
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|-
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|*
name|d
argument_list|)
return|;
block|}
else|else
block|{
comment|// Orthographic projection: drop row 3 and column 3.
return|return
name|QTransform
argument_list|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QMatrix4x4::map(const QPoint& point) const      Maps \a point by multiplying this matrix by \a point.      \sa mapRect() */
end_comment
begin_comment
comment|/*!     \fn QPointF QMatrix4x4::map(const QPointF& point) const      Maps \a point by multiplying this matrix by \a point.      \sa mapRect() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR3D
end_ifndef
begin_comment
comment|/*!     \fn QVector3D QMatrix4x4::map(const QVector3D& point) const      Maps \a point by multiplying this matrix by \a point.      \sa mapRect(), mapVector() */
end_comment
begin_comment
comment|/*!     \fn QVector3D QMatrix4x4::mapVector(const QVector3D& vector) const      Maps \a vector by multiplying the top 3x3 portion of this matrix     by \a vector.  The translation and projection components of     this matrix are ignored.      \sa map() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VECTOR4D
end_ifndef
begin_comment
comment|/*!     \fn QVector4D QMatrix4x4::map(const QVector4D& point) const;      Maps \a point by multiplying this matrix by \a point.      \sa mapRect() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Maps \a rect by multiplying this matrix by the corners     of \a rect and then forming a new rectangle from the results.     The returned rectangle will be an ordinary 2D rectangle     with sides parallel to the horizontal and vertical axes.      \sa map() */
end_comment
begin_function
DECL|function|mapRect
name|QRect
name|QMatrix4x4
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
comment|// Translation
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|rect
operator|.
name|y
argument_list|()
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
comment|// Translation | Scale
name|float
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
operator|*
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
decl_stmt|;
name|float
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
decl_stmt|;
name|float
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
operator|*
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|float
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|w
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|h
argument_list|)
argument_list|)
return|;
block|}
name|QPoint
name|tl
init|=
name|map
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|tr
init|=
name|map
argument_list|(
name|QPoint
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPoint
name|bl
init|=
name|map
argument_list|(
name|QPoint
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPoint
name|br
init|=
name|map
argument_list|(
name|QPoint
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|xmin
init|=
name|qMin
argument_list|(
name|qMin
argument_list|(
name|tl
operator|.
name|x
argument_list|()
argument_list|,
name|tr
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|bl
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|xmax
init|=
name|qMax
argument_list|(
name|qMax
argument_list|(
name|tl
operator|.
name|x
argument_list|()
argument_list|,
name|tr
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|bl
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ymin
init|=
name|qMin
argument_list|(
name|qMin
argument_list|(
name|tl
operator|.
name|y
argument_list|()
argument_list|,
name|tr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|bl
operator|.
name|y
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ymax
init|=
name|qMax
argument_list|(
name|qMax
argument_list|(
name|tl
operator|.
name|y
argument_list|()
argument_list|,
name|tr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|bl
operator|.
name|y
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|QRect
argument_list|(
name|xmin
argument_list|,
name|ymin
argument_list|,
name|xmax
operator|-
name|xmin
argument_list|,
name|ymax
operator|-
name|ymin
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps \a rect by multiplying this matrix by the corners     of \a rect and then forming a new rectangle from the results.     The returned rectangle will be an ordinary 2D rectangle     with sides parallel to the horizontal and vertical axes.      \sa map() */
end_comment
begin_function
DECL|function|mapRect
name|QRectF
name|QMatrix4x4
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|flagBits
operator|<
name|Scale
condition|)
block|{
comment|// Translation
return|return
name|rect
operator|.
name|translated
argument_list|(
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flagBits
operator|<
name|Rotation2D
condition|)
block|{
comment|// Translation | Scale
name|float
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
operator|*
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
decl_stmt|;
name|float
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
decl_stmt|;
name|float
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
operator|*
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|float
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
return|return
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
name|QPointF
name|tl
init|=
name|map
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|tr
init|=
name|map
argument_list|(
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|bl
init|=
name|map
argument_list|(
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|br
init|=
name|map
argument_list|(
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|float
name|xmin
init|=
name|qMin
argument_list|(
name|qMin
argument_list|(
name|tl
operator|.
name|x
argument_list|()
argument_list|,
name|tr
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|bl
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|xmax
init|=
name|qMax
argument_list|(
name|qMax
argument_list|(
name|tl
operator|.
name|x
argument_list|()
argument_list|,
name|tr
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|bl
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|ymin
init|=
name|qMin
argument_list|(
name|qMin
argument_list|(
name|tl
operator|.
name|y
argument_list|()
argument_list|,
name|tr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|bl
operator|.
name|y
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|ymax
init|=
name|qMax
argument_list|(
name|qMax
argument_list|(
name|tl
operator|.
name|y
argument_list|()
argument_list|,
name|tr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|bl
operator|.
name|y
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|QPointF
argument_list|(
name|xmin
argument_list|,
name|ymin
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|xmax
argument_list|,
name|ymax
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn float *QMatrix4x4::data()      Returns a pointer to the raw data of this matrix.      \sa constData(), optimize() */
end_comment
begin_comment
comment|/*!     \fn const float *QMatrix4x4::data() const      Returns a constant pointer to the raw data of this matrix.     This raw data is stored in column-major format.      \sa constData() */
end_comment
begin_comment
comment|/*!     \fn const float *QMatrix4x4::constData() const      Returns a constant pointer to the raw data of this matrix.     This raw data is stored in column-major format.      \sa data() */
end_comment
begin_comment
comment|// Helper routine for inverting orthonormal matrices that consist
end_comment
begin_comment
comment|// of just rotations and translations.
end_comment
begin_function
DECL|function|orthonormalInverse
name|QMatrix4x4
name|QMatrix4x4
operator|::
name|orthonormalInverse
parameter_list|()
specifier|const
block|{
name|QMatrix4x4
name|result
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The '1' says not to load identity
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|0.0f
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
operator|(
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|result
operator|.
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|+
name|result
operator|.
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|result
operator|.
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|result
operator|.
name|flagBits
operator|=
name|flagBits
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Optimize the usage of this matrix from its current elements.      Some operations such as translate(), scale(), and rotate() can be     performed more efficiently if the matrix being modified is already     known to be the identity, a previous translate(), a previous     scale(), etc.      Normally the QMatrix4x4 class keeps track of this special type internally     as operations are performed.  However, if the matrix is modified     directly with operator()() or data(), then QMatrix4x4 will lose track of     the special type and will revert to the safest but least efficient     operations thereafter.      By calling optimize() after directly modifying the matrix,     the programmer can force QMatrix4x4 to recover the special type if     the elements appear to conform to one of the known optimized types.      \sa operator()(), data(), translate() */
end_comment
begin_function
DECL|function|optimize
name|void
name|QMatrix4x4
operator|::
name|optimize
parameter_list|()
block|{
comment|// If the last row is not (0, 0, 0, 1), the matrix is not a special type.
name|flagBits
operator|=
name|General
expr_stmt|;
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|m
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|m
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|m
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|!=
literal|1
condition|)
return|return;
name|flagBits
operator|&=
operator|~
name|Perspective
expr_stmt|;
comment|// If the last column is (0, 0, 0, 1), then there is no translation.
if|if
condition|(
name|m
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|m
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|flagBits
operator|&=
operator|~
name|Translation
expr_stmt|;
comment|// If the two first elements of row 3 and column 3 are 0, then any rotation must be about Z.
if|if
condition|(
operator|!
name|m
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|&&
operator|!
name|m
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|&&
operator|!
name|m
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|m
index|[
literal|2
index|]
index|[
literal|1
index|]
condition|)
block|{
name|flagBits
operator|&=
operator|~
name|Rotation
expr_stmt|;
comment|// If the six non-diagonal elements in the top left 3x3 matrix are 0, there is no rotation.
if|if
condition|(
operator|!
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|&&
operator|!
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
block|{
name|flagBits
operator|&=
operator|~
name|Rotation2D
expr_stmt|;
comment|// Check for identity.
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|1
operator|&&
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|==
literal|1
condition|)
name|flagBits
operator|&=
operator|~
name|Scale
expr_stmt|;
block|}
else|else
block|{
comment|// If the columns are orthonormal and form a right-handed system, then there is no scale.
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|double
name|det
init|=
name|matrixDet2
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|double
name|lenX
init|=
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
decl_stmt|;
name|double
name|lenY
init|=
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
decl_stmt|;
name|double
name|lenZ
init|=
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|det
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenX
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenY
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenZ
argument_list|,
literal|1.0
argument_list|)
condition|)
block|{
name|flagBits
operator|&=
operator|~
name|Scale
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// If the columns are orthonormal and form a right-handed system, then there is no scale.
name|double
name|mm
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|copyToDoubles
argument_list|(
name|m
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|double
name|det
init|=
name|matrixDet3
argument_list|(
name|mm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|double
name|lenX
init|=
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|0
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|lenY
init|=
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|1
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|lenZ
init|=
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|mm
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|det
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenX
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenY
argument_list|,
literal|1.0
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|lenZ
argument_list|,
literal|1.0
argument_list|)
condition|)
block|{
name|flagBits
operator|&=
operator|~
name|Scale
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the matrix as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QMatrix4x4
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Matrix4x4
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|&
name|m
parameter_list|)
block|{
comment|// Create a string that represents the matrix type.
name|QByteArray
name|bits
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|flagBits
operator|==
name|QMatrix4x4
operator|::
name|Identity
condition|)
block|{
name|bits
operator|=
literal|"Identity"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|flagBits
operator|==
name|QMatrix4x4
operator|::
name|General
condition|)
block|{
name|bits
operator|=
literal|"General"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|m
operator|.
name|flagBits
operator|&
name|QMatrix4x4
operator|::
name|Translation
operator|)
operator|!=
literal|0
condition|)
name|bits
operator|+=
literal|"Translation,"
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|.
name|flagBits
operator|&
name|QMatrix4x4
operator|::
name|Scale
operator|)
operator|!=
literal|0
condition|)
name|bits
operator|+=
literal|"Scale,"
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|.
name|flagBits
operator|&
name|QMatrix4x4
operator|::
name|Rotation2D
operator|)
operator|!=
literal|0
condition|)
name|bits
operator|+=
literal|"Rotation2D,"
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|.
name|flagBits
operator|&
name|QMatrix4x4
operator|::
name|Rotation
operator|)
operator|!=
literal|0
condition|)
name|bits
operator|+=
literal|"Rotation,"
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|.
name|flagBits
operator|&
name|QMatrix4x4
operator|::
name|Perspective
operator|)
operator|!=
literal|0
condition|)
name|bits
operator|+=
literal|"Perspective,"
expr_stmt|;
if|if
condition|(
name|bits
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|bits
operator|=
name|bits
operator|.
name|left
argument_list|(
name|bits
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Output in row-major order because it is more human-readable.
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QMatrix4x4(type:"
operator|<<
name|bits
operator|.
name|constData
argument_list|()
operator|<<
name|endl
operator|<<
name|qSetFieldWidth
argument_list|(
literal|10
argument_list|)
operator|<<
name|m
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<<
name|m
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|<<
name|m
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|<<
name|m
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|<<
name|endl
operator|<<
name|m
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|<<
name|m
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|<<
name|m
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|<<
name|m
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|<<
name|endl
operator|<<
name|m
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|<<
name|m
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|<<
name|m
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
operator|<<
name|m
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
operator|<<
name|endl
operator|<<
name|m
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|<<
name|m
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
operator|<<
name|m
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|<<
name|m
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
operator|<<
name|endl
operator|<<
name|qSetFieldWidth
argument_list|(
literal|0
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QMatrix4x4&matrix)     \relates QMatrix4x4      Writes the given \a matrix to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|&
name|matrix
parameter_list|)
block|{
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
name|stream
operator|<<
name|matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QMatrix4x4&matrix)     \relates QMatrix4x4      Reads a 4x4 matrix from the given \a stream into the given \a matrix     and returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QMatrix4x4
modifier|&
name|matrix
parameter_list|)
block|{
name|float
name|x
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
literal|4
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
operator|++
name|col
control|)
block|{
name|stream
operator|>>
name|x
expr_stmt|;
name|matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
block|}
name|matrix
operator|.
name|optimize
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MATRIX4X4
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
