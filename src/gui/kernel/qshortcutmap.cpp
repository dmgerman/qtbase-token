begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qshortcutmap_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qkeysequence.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|<private/qkeymapper_p.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// To enable verbose output uncomment below
end_comment
begin_comment
comment|//#define DEBUG_QSHORTCUTMAP
end_comment
begin_comment
comment|/* \internal     Entry data for QShortcutMap     Contains:         Keysequence for entry         Pointer to parent owning the sequence */
end_comment
begin_struct
DECL|struct|QShortcutEntry
struct|struct
name|QShortcutEntry
block|{
DECL|function|QShortcutEntry
name|QShortcutEntry
parameter_list|()
member_init_list|:
name|keyseq
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|context
argument_list|(
name|Qt
operator|::
name|WindowShortcut
argument_list|)
member_init_list|,
name|enabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autorepeat
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|id
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|owner
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contextMatcher
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|QShortcutEntry
name|QShortcutEntry
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|k
parameter_list|)
member_init_list|:
name|keyseq
argument_list|(
name|k
argument_list|)
member_init_list|,
name|context
argument_list|(
name|Qt
operator|::
name|WindowShortcut
argument_list|)
member_init_list|,
name|enabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autorepeat
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|id
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|owner
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contextMatcher
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|QShortcutEntry
name|QShortcutEntry
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|k
parameter_list|,
name|Qt
operator|::
name|ShortcutContext
name|c
parameter_list|,
name|int
name|i
parameter_list|,
name|bool
name|a
parameter_list|,
name|QShortcutMap
operator|::
name|ContextMatcher
name|m
parameter_list|)
member_init_list|:
name|keyseq
argument_list|(
name|k
argument_list|)
member_init_list|,
name|context
argument_list|(
name|c
argument_list|)
member_init_list|,
name|enabled
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|autorepeat
argument_list|(
name|a
argument_list|)
member_init_list|,
name|id
argument_list|(
name|i
argument_list|)
member_init_list|,
name|owner
argument_list|(
name|o
argument_list|)
member_init_list|,
name|contextMatcher
argument_list|(
name|m
argument_list|)
block|{}
DECL|function|correctContext
name|bool
name|correctContext
parameter_list|()
specifier|const
block|{
return|return
name|contextMatcher
argument_list|(
name|owner
argument_list|,
name|context
argument_list|)
return|;
block|}
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QShortcutEntry
modifier|&
name|f
parameter_list|)
specifier|const
block|{
return|return
name|keyseq
operator|<
name|f
operator|.
name|keyseq
return|;
block|}
DECL|member|keyseq
name|QKeySequence
name|keyseq
decl_stmt|;
DECL|member|context
name|Qt
operator|::
name|ShortcutContext
name|context
decl_stmt|;
DECL|member|enabled
name|bool
name|enabled
range|:
literal|1
decl_stmt|;
DECL|member|autorepeat
name|bool
name|autorepeat
range|:
literal|1
decl_stmt|;
DECL|member|id
name|signed
name|int
name|id
decl_stmt|;
DECL|member|owner
name|QObject
modifier|*
name|owner
decl_stmt|;
DECL|member|contextMatcher
name|QShortcutMap
operator|::
name|ContextMatcher
name|contextMatcher
decl_stmt|;
block|}
struct|;
end_struct
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|//ndef QT_NO_DEBUG_STREAM
end_comment
begin_comment
comment|/*! \internal     QDebug operator<< for easy debug output of the shortcut entries. */
end_comment
begin_endif
unit|static QDebug&operator<<(QDebug&dbg, const QShortcutEntry *se) {     if (!se)         return dbg<< "QShortcutEntry(0x0)";     dbg.nospace()<< "QShortcutEntry("<< se->keyseq<< "), id("<< se->id<< "), enabled("<< se->enabled<< "), autorepeat("<< se->autorepeat<< "), owner("<< se->owner<< ')';     return dbg.space(); }
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DEBUGSTREAM
end_comment
begin_comment
comment|/* \internal     Private data for QShortcutMap */
end_comment
begin_class
DECL|class|QShortcutMapPrivate
class|class
name|QShortcutMapPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QShortcutMap
parameter_list|)
specifier|public
private|:
DECL|function|QShortcutMapPrivate
name|QShortcutMapPrivate
parameter_list|(
name|QShortcutMap
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|q_ptr
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|currentId
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ambigCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentState
argument_list|(
name|QKeySequence
operator|::
name|NoMatch
argument_list|)
block|{
name|identicals
operator|.
name|reserve
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|currentSequences
operator|.
name|reserve
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|member|q_ptr
name|QShortcutMap
modifier|*
name|q_ptr
decl_stmt|;
comment|// Private's parent
DECL|member|sequences
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
name|sequences
decl_stmt|;
comment|// All sequences!
DECL|member|currentId
name|int
name|currentId
decl_stmt|;
comment|// Global shortcut ID number
DECL|member|ambigCount
name|int
name|ambigCount
decl_stmt|;
comment|// Index of last enabled ambiguous dispatch
DECL|member|currentState
name|QKeySequence
operator|::
name|SequenceMatch
name|currentState
decl_stmt|;
DECL|member|currentSequences
name|QVector
argument_list|<
name|QKeySequence
argument_list|>
name|currentSequences
decl_stmt|;
comment|// Sequence for the current state
DECL|member|newEntries
name|QVector
argument_list|<
name|QKeySequence
argument_list|>
name|newEntries
decl_stmt|;
DECL|member|prevSequence
name|QKeySequence
name|prevSequence
decl_stmt|;
comment|// Sequence for the previous identical match
DECL|member|identicals
name|QVector
argument_list|<
specifier|const
name|QShortcutEntry
modifier|*
argument_list|>
name|identicals
decl_stmt|;
comment|// Last identical matches
block|}
class|;
end_class
begin_comment
comment|/*! \internal     QShortcutMap constructor. */
end_comment
begin_constructor
DECL|function|QShortcutMap
name|QShortcutMap
operator|::
name|QShortcutMap
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QShortcutMapPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|resetState
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal     QShortcutMap destructor. */
end_comment
begin_destructor
DECL|function|~QShortcutMap
name|QShortcutMap
operator|::
name|~
name|QShortcutMap
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \internal     Adds a shortcut to the global map.     Returns the id of the newly added shortcut. */
end_comment
begin_function
DECL|function|addShortcut
name|int
name|QShortcutMap
operator|::
name|addShortcut
parameter_list|(
name|QObject
modifier|*
name|owner
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|,
name|Qt
operator|::
name|ShortcutContext
name|context
parameter_list|,
name|ContextMatcher
name|matcher
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|owner
argument_list|,
literal|"QShortcutMap::addShortcut"
argument_list|,
literal|"All shortcuts need an owner"
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"QShortcutMap::addShortcut"
argument_list|,
literal|"Cannot add keyless shortcuts to map"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|QShortcutEntry
name|newEntry
argument_list|(
name|owner
argument_list|,
name|key
argument_list|,
name|context
argument_list|,
operator|--
operator|(
name|d
operator|->
name|currentId
operator|)
argument_list|,
literal|true
argument_list|,
name|matcher
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
operator|::
name|iterator
name|it
init|=
name|std
operator|::
name|upper_bound
argument_list|(
name|d
operator|->
name|sequences
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|sequences
operator|.
name|end
argument_list|()
argument_list|,
name|newEntry
argument_list|)
decl_stmt|;
name|d
operator|->
name|sequences
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
comment|// Insert sorted
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::addShortcut("
operator|<<
name|owner
operator|<<
literal|", "
operator|<<
name|key
operator|<<
literal|", "
operator|<<
name|context
operator|<<
literal|") = "
operator|<<
name|d
operator|->
name|currentId
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|currentId
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Removes a shortcut from the global map.     If \a owner is 0, all entries in the map with the key sequence specified     is removed. If \a key is null, all sequences for \a owner is removed from     the map. If \a id is 0, any identical \a key sequences owned by \a owner     are removed.     Returns the number of sequences removed from the map. */
end_comment
begin_function
DECL|function|removeShortcut
name|int
name|QShortcutMap
operator|::
name|removeShortcut
parameter_list|(
name|int
name|id
parameter_list|,
name|QObject
modifier|*
name|owner
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|int
name|itemsRemoved
init|=
literal|0
decl_stmt|;
name|bool
name|allOwners
init|=
operator|(
name|owner
operator|==
literal|0
operator|)
decl_stmt|;
name|bool
name|allKeys
init|=
name|key
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|allIds
init|=
name|id
operator|==
literal|0
decl_stmt|;
comment|// Special case, remove everything
if|if
condition|(
name|allOwners
operator|&&
name|allKeys
operator|&&
name|id
operator|==
literal|0
condition|)
block|{
name|itemsRemoved
operator|=
name|d
operator|->
name|sequences
operator|.
name|size
argument_list|()
expr_stmt|;
name|d
operator|->
name|sequences
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|itemsRemoved
return|;
block|}
name|int
name|i
init|=
name|d
operator|->
name|sequences
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QShortcutEntry
modifier|&
name|entry
init|=
name|d
operator|->
name|sequences
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|entryId
init|=
name|entry
operator|.
name|id
decl_stmt|;
if|if
condition|(
operator|(
name|allOwners
operator|||
name|entry
operator|.
name|owner
operator|==
name|owner
operator|)
operator|&&
operator|(
name|allIds
operator|||
name|entry
operator|.
name|id
operator|==
name|id
operator|)
operator|&&
operator|(
name|allKeys
operator|||
name|entry
operator|.
name|keyseq
operator|==
name|key
operator|)
condition|)
block|{
name|d
operator|->
name|sequences
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|itemsRemoved
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|entryId
condition|)
return|return
name|itemsRemoved
return|;
operator|--
name|i
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::removeShortcut("
operator|<<
name|id
operator|<<
literal|", "
operator|<<
name|owner
operator|<<
literal|", "
operator|<<
name|key
operator|<<
literal|") = "
operator|<<
name|itemsRemoved
expr_stmt|;
endif|#
directive|endif
return|return
name|itemsRemoved
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Changes the enable state of a shortcut to \a enable.     If \a owner is 0, all entries in the map with the key sequence specified     is removed. If \a key is null, all sequences for \a owner is removed from     the map. If \a id is 0, any identical \a key sequences owned by \a owner     are changed.     Returns the number of sequences which are matched in the map. */
end_comment
begin_function
DECL|function|setShortcutEnabled
name|int
name|QShortcutMap
operator|::
name|setShortcutEnabled
parameter_list|(
name|bool
name|enable
parameter_list|,
name|int
name|id
parameter_list|,
name|QObject
modifier|*
name|owner
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|int
name|itemsChanged
init|=
literal|0
decl_stmt|;
name|bool
name|allOwners
init|=
operator|(
name|owner
operator|==
literal|0
operator|)
decl_stmt|;
name|bool
name|allKeys
init|=
name|key
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|allIds
init|=
name|id
operator|==
literal|0
decl_stmt|;
name|int
name|i
init|=
name|d
operator|->
name|sequences
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|QShortcutEntry
name|entry
init|=
name|d
operator|->
name|sequences
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|allOwners
operator|||
name|entry
operator|.
name|owner
operator|==
name|owner
operator|)
operator|&&
operator|(
name|allIds
operator|||
name|entry
operator|.
name|id
operator|==
name|id
operator|)
operator|&&
operator|(
name|allKeys
operator|||
name|entry
operator|.
name|keyseq
operator|==
name|key
operator|)
condition|)
block|{
name|d
operator|->
name|sequences
index|[
name|i
index|]
operator|.
name|enabled
operator|=
name|enable
expr_stmt|;
operator|++
name|itemsChanged
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|entry
operator|.
name|id
condition|)
return|return
name|itemsChanged
return|;
operator|--
name|i
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::setShortcutEnabled("
operator|<<
name|enable
operator|<<
literal|", "
operator|<<
name|id
operator|<<
literal|", "
operator|<<
name|owner
operator|<<
literal|", "
operator|<<
name|key
operator|<<
literal|") = "
operator|<<
name|itemsChanged
expr_stmt|;
endif|#
directive|endif
return|return
name|itemsChanged
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Changes the auto repeat state of a shortcut to \a enable.     If \a owner is 0, all entries in the map with the key sequence specified     is removed. If \a key is null, all sequences for \a owner is removed from     the map. If \a id is 0, any identical \a key sequences owned by \a owner     are changed.     Returns the number of sequences which are matched in the map. */
end_comment
begin_function
DECL|function|setShortcutAutoRepeat
name|int
name|QShortcutMap
operator|::
name|setShortcutAutoRepeat
parameter_list|(
name|bool
name|on
parameter_list|,
name|int
name|id
parameter_list|,
name|QObject
modifier|*
name|owner
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|int
name|itemsChanged
init|=
literal|0
decl_stmt|;
name|bool
name|allOwners
init|=
operator|(
name|owner
operator|==
literal|0
operator|)
decl_stmt|;
name|bool
name|allKeys
init|=
name|key
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|allIds
init|=
name|id
operator|==
literal|0
decl_stmt|;
name|int
name|i
init|=
name|d
operator|->
name|sequences
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|QShortcutEntry
name|entry
init|=
name|d
operator|->
name|sequences
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|allOwners
operator|||
name|entry
operator|.
name|owner
operator|==
name|owner
operator|)
operator|&&
operator|(
name|allIds
operator|||
name|entry
operator|.
name|id
operator|==
name|id
operator|)
operator|&&
operator|(
name|allKeys
operator|||
name|entry
operator|.
name|keyseq
operator|==
name|key
operator|)
condition|)
block|{
name|d
operator|->
name|sequences
index|[
name|i
index|]
operator|.
name|autorepeat
operator|=
name|on
expr_stmt|;
operator|++
name|itemsChanged
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|entry
operator|.
name|id
condition|)
return|return
name|itemsChanged
return|;
operator|--
name|i
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::setShortcutAutoRepeat("
operator|<<
name|on
operator|<<
literal|", "
operator|<<
name|id
operator|<<
literal|", "
operator|<<
name|owner
operator|<<
literal|", "
operator|<<
name|key
operator|<<
literal|") = "
operator|<<
name|itemsChanged
expr_stmt|;
endif|#
directive|endif
return|return
name|itemsChanged
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Resets the state of the statemachine to NoMatch */
end_comment
begin_function
DECL|function|resetState
name|void
name|QShortcutMap
operator|::
name|resetState
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentState
operator|=
name|QKeySequence
operator|::
name|NoMatch
expr_stmt|;
name|clearSequence
argument_list|(
name|d
operator|->
name|currentSequences
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the current state of the statemachine */
end_comment
begin_function
DECL|function|state
name|QKeySequence
operator|::
name|SequenceMatch
name|QShortcutMap
operator|::
name|state
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentState
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Uses ShortcutOverride event to see if any widgets want to override     the event. If not, uses nextState(QKeyEvent) to check for a grabbed     Shortcut, and dispatchEvent() is found and identical.     \sa nextState, dispatchEvent */
end_comment
begin_function
DECL|function|tryShortcutEvent
name|bool
name|QShortcutMap
operator|::
name|tryShortcutEvent
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_unknown
condition|)
return|return
literal|false
return|;
name|bool
name|wasAccepted
init|=
name|e
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|bool
name|wasSpontaneous
init|=
name|e
operator|->
name|spont
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|currentState
operator|==
name|QKeySequence
operator|::
name|NoMatch
condition|)
block|{
name|ushort
name|orgType
init|=
name|e
operator|->
name|t
decl_stmt|;
name|e
operator|->
name|t
operator|=
name|QEvent
operator|::
name|ShortcutOverride
expr_stmt|;
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|o
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|t
operator|=
name|orgType
expr_stmt|;
name|e
operator|->
name|spont
operator|=
name|wasSpontaneous
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|wasAccepted
condition|)
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|QKeySequence
operator|::
name|SequenceMatch
name|result
init|=
name|nextState
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|bool
name|stateWasAccepted
init|=
name|e
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasAccepted
condition|)
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
else|else
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|int
name|identicalMatches
init|=
name|d
operator|->
name|identicals
operator|.
name|count
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|QKeySequence
operator|::
name|NoMatch
case|:
return|return
name|stateWasAccepted
return|;
case|case
name|QKeySequence
operator|::
name|ExactMatch
case|:
name|resetState
argument_list|()
expr_stmt|;
name|dispatchEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
comment|// If nextState is QKeySequence::ExactMatch&& identicals.count == 0
comment|// we've only found disabled shortcuts
return|return
name|identicalMatches
operator|>
literal|0
operator|||
name|result
operator|==
name|QKeySequence
operator|::
name|PartialMatch
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the next state of the statemachine     If return value is SequenceMatch::ExactMatch, then a call to matches()     will return a QObjects* list of all matching objects for the last matching     sequence. */
end_comment
begin_function
DECL|function|nextState
name|QKeySequence
operator|::
name|SequenceMatch
name|QShortcutMap
operator|::
name|nextState
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
comment|// Modifiers can NOT be shortcuts...
if|if
condition|(
name|e
operator|->
name|key
argument_list|()
operator|>=
name|Qt
operator|::
name|Key_Shift
operator|&&
name|e
operator|->
name|key
argument_list|()
operator|<=
name|Qt
operator|::
name|Key_Alt
condition|)
return|return
name|d
operator|->
name|currentState
return|;
name|QKeySequence
operator|::
name|SequenceMatch
name|result
init|=
name|QKeySequence
operator|::
name|NoMatch
decl_stmt|;
comment|// We start fresh each time..
name|d
operator|->
name|identicals
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|find
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|QKeySequence
operator|::
name|NoMatch
operator|&&
operator|(
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|KeypadModifier
operator|)
condition|)
block|{
comment|// Try to find a match without keypad modifier
name|QKeyEvent
name|event
init|=
operator|*
name|e
decl_stmt|;
name|event
operator|.
name|setModifiers
argument_list|(
name|e
operator|->
name|modifiers
argument_list|()
operator|&
operator|~
name|Qt
operator|::
name|KeypadModifier
argument_list|)
expr_stmt|;
name|result
operator|=
name|find
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|QKeySequence
operator|::
name|NoMatch
operator|&&
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
condition|)
block|{
comment|// If Shift + Key_Backtab, also try Shift + Qt::Key_Tab
if|if
condition|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
condition|)
block|{
name|QKeyEvent
name|pe
init|=
name|QKeyEvent
argument_list|(
name|e
operator|->
name|type
argument_list|()
argument_list|,
name|Qt
operator|::
name|Key_Tab
argument_list|,
name|e
operator|->
name|modifiers
argument_list|()
argument_list|,
name|e
operator|->
name|text
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|=
name|find
argument_list|(
operator|&
name|pe
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Should we eat this key press?
if|if
condition|(
name|d
operator|->
name|currentState
operator|==
name|QKeySequence
operator|::
name|PartialMatch
operator|||
operator|(
name|d
operator|->
name|currentState
operator|==
name|QKeySequence
operator|::
name|ExactMatch
operator|&&
name|d
operator|->
name|identicals
operator|.
name|count
argument_list|()
operator|)
condition|)
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// Does the new state require us to clean up?
if|if
condition|(
name|result
operator|==
name|QKeySequence
operator|::
name|NoMatch
condition|)
name|clearSequence
argument_list|(
name|d
operator|->
name|currentSequences
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentState
operator|=
name|result
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::nextState("
operator|<<
name|e
operator|<<
literal|") = "
operator|<<
name|result
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Determines if an enabled shortcut has a matcing key sequence. */
end_comment
begin_function
DECL|function|hasShortcutForKeySequence
name|bool
name|QShortcutMap
operator|::
name|hasShortcutForKeySequence
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|seq
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QShortcutMap
argument_list|)
expr_stmt|;
name|QShortcutEntry
name|entry
argument_list|(
name|seq
argument_list|)
decl_stmt|;
comment|// needed for searching
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
operator|::
name|ConstIterator
name|itEnd
init|=
name|d
operator|->
name|sequences
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|d
operator|->
name|sequences
operator|.
name|constBegin
argument_list|()
argument_list|,
name|itEnd
argument_list|,
name|entry
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|itEnd
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|entry
operator|.
name|keyseq
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|keyseq
argument_list|)
operator|==
name|QKeySequence
operator|::
name|ExactMatch
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|correctContext
argument_list|()
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|enabled
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|//end of the loop: we didn't find anything
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the next state of the statemachine, based     on the new key event \a e.     Matches are appended to the vector of identicals,     which can be access through matches().     \sa matches */
end_comment
begin_function
DECL|function|find
name|QKeySequence
operator|::
name|SequenceMatch
name|QShortcutMap
operator|::
name|find
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|sequences
operator|.
name|count
argument_list|()
condition|)
return|return
name|QKeySequence
operator|::
name|NoMatch
return|;
name|createNewSequences
argument_list|(
name|e
argument_list|,
name|d
operator|->
name|newEntries
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Possible shortcut key sequences:"
operator|<<
name|d
operator|->
name|newEntries
expr_stmt|;
endif|#
directive|endif
comment|// Should never happen
if|if
condition|(
name|d
operator|->
name|newEntries
operator|==
name|d
operator|->
name|currentSequences
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|e
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_unknown
operator|||
name|e
operator|->
name|text
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
literal|"QShortcutMap::find"
argument_list|,
literal|"New sequence to find identical to previous"
argument_list|)
expr_stmt|;
return|return
name|QKeySequence
operator|::
name|NoMatch
return|;
block|}
comment|// Looking for new identicals, scrap old
name|d
operator|->
name|identicals
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bool
name|partialFound
init|=
literal|false
decl_stmt|;
name|bool
name|identicalDisabledFound
init|=
literal|false
decl_stmt|;
name|QVector
argument_list|<
name|QKeySequence
argument_list|>
name|okEntries
decl_stmt|;
name|int
name|result
init|=
name|QKeySequence
operator|::
name|NoMatch
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|newEntries
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QShortcutEntry
name|entry
argument_list|(
name|d
operator|->
name|newEntries
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|// needed for searching
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
operator|::
name|ConstIterator
name|itEnd
init|=
name|d
operator|->
name|sequences
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QShortcutEntry
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|d
operator|->
name|sequences
operator|.
name|constBegin
argument_list|()
argument_list|,
name|itEnd
argument_list|,
name|entry
argument_list|)
decl_stmt|;
name|int
name|oneKSResult
init|=
name|QKeySequence
operator|::
name|NoMatch
decl_stmt|;
name|int
name|tempRes
init|=
name|QKeySequence
operator|::
name|NoMatch
decl_stmt|;
do|do
block|{
if|if
condition|(
name|it
operator|==
name|itEnd
condition|)
break|break;
name|tempRes
operator|=
name|matches
argument_list|(
name|entry
operator|.
name|keyseq
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|keyseq
argument_list|)
expr_stmt|;
name|oneKSResult
operator|=
name|qMax
argument_list|(
name|oneKSResult
argument_list|,
name|tempRes
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempRes
operator|!=
name|QKeySequence
operator|::
name|NoMatch
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|correctContext
argument_list|()
condition|)
block|{
if|if
condition|(
name|tempRes
operator|==
name|QKeySequence
operator|::
name|ExactMatch
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|enabled
condition|)
name|d
operator|->
name|identicals
operator|.
name|append
argument_list|(
operator|&
operator|*
name|it
argument_list|)
expr_stmt|;
else|else
name|identicalDisabledFound
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tempRes
operator|==
name|QKeySequence
operator|::
name|PartialMatch
condition|)
block|{
comment|// We don't need partials, if we have identicals
if|if
condition|(
name|d
operator|->
name|identicals
operator|.
name|size
argument_list|()
condition|)
break|break;
comment|// We only care about enabled partials, so we don't consume
comment|// key events when all partials are disabled!
name|partialFound
operator||=
operator|(
operator|*
name|it
operator|)
operator|.
name|enabled
expr_stmt|;
block|}
block|}
operator|++
name|it
expr_stmt|;
comment|// If we got a valid match on this run, there might still be more keys to check against,
comment|// so we'll loop once more. If we get NoMatch, there's guaranteed no more possible
comment|// matches in the shortcutmap.
block|}
do|while
condition|(
name|tempRes
operator|!=
name|QKeySequence
operator|::
name|NoMatch
condition|)
do|;
comment|// If the type of match improves (ergo, NoMatch->Partial, or Partial->Exact), clear the
comment|// previous list. If this match is equal or better than the last match, append to the list
if|if
condition|(
name|oneKSResult
operator|>
name|result
condition|)
block|{
name|okEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Found better match ("
operator|<<
name|d
operator|->
name|newEntries
operator|<<
literal|"), clearing key sequence list"
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|oneKSResult
operator|&&
name|oneKSResult
operator|>=
name|result
condition|)
block|{
name|okEntries
operator|<<
name|d
operator|->
name|newEntries
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Added ok key sequence"
operator|<<
name|d
operator|->
name|newEntries
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|d
operator|->
name|identicals
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|=
name|QKeySequence
operator|::
name|ExactMatch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|partialFound
condition|)
block|{
name|result
operator|=
name|QKeySequence
operator|::
name|PartialMatch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|identicalDisabledFound
condition|)
block|{
name|result
operator|=
name|QKeySequence
operator|::
name|ExactMatch
expr_stmt|;
block|}
else|else
block|{
name|clearSequence
argument_list|(
name|d
operator|->
name|currentSequences
argument_list|)
expr_stmt|;
name|result
operator|=
name|QKeySequence
operator|::
name|NoMatch
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|QKeySequence
operator|::
name|NoMatch
condition|)
name|d
operator|->
name|currentSequences
operator|=
name|okEntries
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Returning shortcut match == "
operator|<<
name|result
expr_stmt|;
endif|#
directive|endif
return|return
name|QKeySequence
operator|::
name|SequenceMatch
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Clears \a seq to an empty QKeySequence.     Same as doing (the slower)     \snippet code/src_gui_kernel_qshortcutmap.cpp 0 */
end_comment
begin_function
DECL|function|clearSequence
name|void
name|QShortcutMap
operator|::
name|clearSequence
parameter_list|(
name|QVector
argument_list|<
name|QKeySequence
argument_list|>
modifier|&
name|ksl
parameter_list|)
block|{
name|ksl
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|newEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Alters \a seq to the new sequence state, based on the     current sequence state, and the new key event \a e. */
end_comment
begin_function
DECL|function|createNewSequences
name|void
name|QShortcutMap
operator|::
name|createNewSequences
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|,
name|QVector
argument_list|<
name|QKeySequence
argument_list|>
modifier|&
name|ksl
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|possibleKeys
init|=
name|QKeyMapper
operator|::
name|possibleKeys
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|int
name|pkTotal
init|=
name|possibleKeys
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pkTotal
condition|)
return|return;
name|int
name|ssActual
init|=
name|d
operator|->
name|currentSequences
operator|.
name|count
argument_list|()
decl_stmt|;
name|int
name|ssTotal
init|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|ssActual
argument_list|)
decl_stmt|;
comment|// Resize to possible permutations of the current sequence(s).
name|ksl
operator|.
name|resize
argument_list|(
name|pkTotal
operator|*
name|ssTotal
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|ssActual
condition|?
name|d
operator|->
name|currentSequences
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|count
argument_list|()
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pkNum
init|=
literal|0
init|;
name|pkNum
operator|<
name|pkTotal
condition|;
operator|++
name|pkNum
control|)
block|{
for|for
control|(
name|int
name|ssNum
init|=
literal|0
init|;
name|ssNum
operator|<
name|ssTotal
condition|;
operator|++
name|ssNum
control|)
block|{
name|int
name|i
init|=
operator|(
name|pkNum
operator|*
name|ssTotal
operator|)
operator|+
name|ssNum
decl_stmt|;
name|QKeySequence
modifier|&
name|curKsl
init|=
name|ksl
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ssActual
condition|)
block|{
specifier|const
name|QKeySequence
modifier|&
name|curSeq
init|=
name|d
operator|->
name|currentSequences
operator|.
name|at
argument_list|(
name|ssNum
argument_list|)
decl_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
name|curSeq
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
name|curSeq
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
name|curSeq
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
name|curSeq
index|[
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curKsl
operator|.
name|setKey
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|curKsl
operator|.
name|setKey
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|curKsl
operator|.
name|setKey
argument_list|(
name|possibleKeys
operator|.
name|at
argument_list|(
name|pkNum
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*! \internal     Basically the same function as QKeySequence::matches(const QKeySequence&seq) const     only that is specially handles Key_hyphen as Key_Minus, as people mix these up all the time and     they conceptually the same. */
end_comment
begin_function
DECL|function|matches
name|QKeySequence
operator|::
name|SequenceMatch
name|QShortcutMap
operator|::
name|matches
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|seq1
parameter_list|,
specifier|const
name|QKeySequence
modifier|&
name|seq2
parameter_list|)
specifier|const
block|{
name|uint
name|userN
init|=
name|seq1
operator|.
name|count
argument_list|()
decl_stmt|,
name|seqN
init|=
name|seq2
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|userN
operator|>
name|seqN
condition|)
return|return
name|QKeySequence
operator|::
name|NoMatch
return|;
comment|// If equal in length, we have a potential ExactMatch sequence,
comment|// else we already know it can only be partial.
name|QKeySequence
operator|::
name|SequenceMatch
name|match
init|=
operator|(
name|userN
operator|==
name|seqN
condition|?
name|QKeySequence
operator|::
name|ExactMatch
else|:
name|QKeySequence
operator|::
name|PartialMatch
operator|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|userN
condition|;
operator|++
name|i
control|)
block|{
name|int
name|userKey
init|=
name|seq1
index|[
name|i
index|]
decl_stmt|,
name|sequenceKey
init|=
name|seq2
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|userKey
operator|&
name|Qt
operator|::
name|Key_unknown
operator|)
operator|==
name|Qt
operator|::
name|Key_hyphen
condition|)
name|userKey
operator|=
operator|(
name|userKey
operator|&
name|Qt
operator|::
name|KeyboardModifierMask
operator|)
operator||
name|Qt
operator|::
name|Key_Minus
expr_stmt|;
if|if
condition|(
operator|(
name|sequenceKey
operator|&
name|Qt
operator|::
name|Key_unknown
operator|)
operator|==
name|Qt
operator|::
name|Key_hyphen
condition|)
name|sequenceKey
operator|=
operator|(
name|sequenceKey
operator|&
name|Qt
operator|::
name|KeyboardModifierMask
operator|)
operator||
name|Qt
operator|::
name|Key_Minus
expr_stmt|;
if|if
condition|(
name|userKey
operator|!=
name|sequenceKey
condition|)
return|return
name|QKeySequence
operator|::
name|NoMatch
return|;
block|}
return|return
name|match
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Converts keyboard button states into modifier states */
end_comment
begin_function
DECL|function|translateModifiers
name|int
name|QShortcutMap
operator|::
name|translateModifiers
parameter_list|(
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
condition|)
name|result
operator||=
name|Qt
operator|::
name|SHIFT
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
name|result
operator||=
name|Qt
operator|::
name|CTRL
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|MetaModifier
condition|)
name|result
operator||=
name|Qt
operator|::
name|META
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|AltModifier
condition|)
name|result
operator||=
name|Qt
operator|::
name|ALT
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the vector of QShortcutEntry's matching the last Identical state. */
end_comment
begin_function
DECL|function|matches
name|QVector
argument_list|<
specifier|const
name|QShortcutEntry
modifier|*
argument_list|>
name|QShortcutMap
operator|::
name|matches
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QShortcutMap
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|identicals
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Dispatches QShortcutEvents to widgets who grabbed the matched key sequence. */
end_comment
begin_function
DECL|function|dispatchEvent
name|void
name|QShortcutMap
operator|::
name|dispatchEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QShortcutMap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|identicals
operator|.
name|size
argument_list|()
condition|)
return|return;
specifier|const
name|QKeySequence
modifier|&
name|curKey
init|=
name|d
operator|->
name|identicals
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|keyseq
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|prevSequence
operator|!=
name|curKey
condition|)
block|{
name|d
operator|->
name|ambigCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|prevSequence
operator|=
name|curKey
expr_stmt|;
block|}
comment|// Find next
specifier|const
name|QShortcutEntry
modifier|*
name|current
init|=
literal|0
decl_stmt|,
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|enabledShortcuts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|d
operator|->
name|identicals
operator|.
name|size
argument_list|()
condition|)
block|{
name|current
operator|=
name|d
operator|->
name|identicals
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|enabled
operator|||
operator|!
name|next
condition|)
block|{
operator|++
name|enabledShortcuts
expr_stmt|;
if|if
condition|(
name|enabledShortcuts
operator|>
name|d
operator|->
name|ambigCount
operator|+
literal|1
condition|)
break|break;
name|next
operator|=
name|current
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
name|d
operator|->
name|ambigCount
operator|=
operator|(
name|d
operator|->
name|identicals
operator|.
name|size
argument_list|()
operator|==
name|i
condition|?
literal|0
else|:
name|d
operator|->
name|ambigCount
operator|+
literal|1
operator|)
expr_stmt|;
comment|// Don't trigger shortcut if we're autorepeating and the shortcut is
comment|// grabbed with not accepting autorepeats.
if|if
condition|(
operator|!
name|next
operator|||
operator|(
name|e
operator|->
name|isAutoRepeat
argument_list|()
operator|&&
operator|!
name|next
operator|->
name|autorepeat
operator|)
condition|)
return|return;
comment|// Dispatch next enabled
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_QSHORTCUTMAP
argument_list|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QShortcutMap::dispatchEvent(): Sending QShortcutEvent(\""
operator|<<
name|next
operator|->
name|keyseq
operator|.
name|toString
argument_list|()
operator|<<
literal|"\", "
operator|<<
name|next
operator|->
name|id
operator|<<
literal|", "
operator|<<
call|(
name|bool
call|)
argument_list|(
name|enabledShortcuts
operator|>
literal|1
argument_list|)
operator|<<
literal|") to object("
operator|<<
name|next
operator|->
name|owner
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|QShortcutEvent
name|se
argument_list|(
name|next
operator|->
name|keyseq
argument_list|,
name|next
operator|->
name|id
argument_list|,
name|enabledShortcuts
operator|>
literal|1
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|next
operator|->
name|owner
argument_list|)
argument_list|,
operator|&
name|se
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* \internal     QShortcutMap dump function, only available when DEBUG_QSHORTCUTMAP is     defined. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Dump_QShortcutMap
argument_list|)
end_if
begin_function
DECL|function|dumpMap
name|void
name|QShortcutMap
operator|::
name|dumpMap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QShortcutMap
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|sequences
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|qDebug
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
operator|&
operator|(
name|d
operator|->
name|sequences
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SHORTCUT
end_comment
end_unit
