begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/****************************************************************************  NB: This is not a header file, dispite the file name suffix. This file is  included directly into the source code of qcocoawindow_mac.mm and  qcocoapanel_mac.mm to avoid manually doing copy and paste of the exact  same code needed at both places. This solution makes it more difficult  to e.g fix a bug in qcocoawindow_mac.mm, but forget to do the same in  qcocoapanel_mac.mm.  The reason we need to do copy and paste in the first place, rather than  resolve to method overriding, is that QCocoaPanel needs to inherit from  NSPanel, while QCocoaWindow needs to inherit NSWindow rather than NSPanel). ****************************************************************************/
end_comment
begin_comment
comment|// WARNING: Don't include any header files from within this file. Put them
end_comment
begin_comment
comment|// directly into qcocoawindow_mac_p.h and qcocoapanel_mac_p.h
end_comment
begin_expr_stmt
name|QT_BEGIN_NAMESPACE
specifier|extern
name|Qt
operator|::
name|MouseButton
name|cocoaButton2QtButton
argument_list|(
argument|NSInteger buttonNum
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// qcocoaview.mm
end_comment
begin_extern
extern|extern QPointer<QWidget> qt_button_down;
end_extern
begin_comment
comment|//qapplication_mac.cpp
end_comment
begin_function_decl
specifier|extern
specifier|const
name|QStringList
modifier|&
name|qEnabledDraggedTypes
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|// qmime_mac.cpp
end_comment
begin_function_decl
specifier|extern
name|void
name|qt_event_request_window_change
parameter_list|(
name|QWidget
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// qapplication_mac.mm
end_comment
begin_function_decl
specifier|extern
name|void
name|qt_mac_send_posted_gl_updates
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// qapplication_mac.mm
end_comment
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QPointer
operator|<
name|QWidget
operator|>
argument_list|,
name|currentDragTarget
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
DECL|function|QT_END_NAMESPACE
name|QT_END_NAMESPACE
operator|-
operator|(
name|id
operator|)
name|initWithContentRect
operator|:
operator|(
name|NSRect
operator|)
name|contentRect
name|styleMask
operator|:
operator|(
name|NSUInteger
operator|)
name|windowStyle
name|backing
operator|:
operator|(
name|NSBackingStoreType
operator|)
name|bufferingType
name|defer
operator|:
operator|(
name|BOOL
operator|)
name|deferCreation
block|{
name|self
operator|=
index|[
name|super
name|initWithContentRect
operator|:
name|contentRect
name|styleMask
operator|:
name|windowStyle
name|backing
operator|:
name|bufferingType
name|defer
operator|:
name|deferCreation
index|]
block|;
if|if
condition|(
name|self
condition|)
block|{
name|currentCustomDragTypes
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt
begin_return
return|return
name|self
return|;
end_return
begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|dealloc
block|{
name|delete
name|currentCustomDragTypes
block|;
index|[
name|super
name|dealloc
index|]
block|; }
operator|-
operator|(
name|BOOL
operator|)
name|canBecomeKeyWindow
block|{
name|QWidget
operator|*
name|widget
operator|=
index|[
name|self
name|QT_MANGLE_NAMESPACE
argument_list|(
name|qt_qwidget
argument_list|)
index|]
block|;
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|NO
return|;
end_expr_stmt
begin_comment
comment|// This should happen only for qt_root_win
end_comment
begin_if
if|if
condition|(
name|QApplicationPrivate
operator|::
name|isBlockedByModal
argument_list|(
name|widget
argument_list|)
condition|)
return|return
name|NO
return|;
end_if
begin_decl_stmt
name|bool
name|isToolTip
init|=
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|ToolTip
operator|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|bool
name|isPopup
init|=
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
decl_stmt|;
end_decl_stmt
begin_return
return|return
operator|!
operator|(
name|isPopup
operator|||
name|isToolTip
operator|)
return|;
end_return
begin_expr_stmt
unit|}  -
operator|(
name|BOOL
operator|)
name|canBecomeMainWindow
block|{
name|QWidget
operator|*
name|widget
operator|=
index|[
name|self
name|QT_MANGLE_NAMESPACE
argument_list|(
name|qt_qwidget
argument_list|)
index|]
block|;
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|NO
return|;
end_expr_stmt
begin_comment
comment|// This should happen only for qt_root_win
end_comment
begin_if
if|if
condition|(
index|[
name|self
name|isSheet
index|]
condition|)
return|return
name|NO
return|;
end_if
begin_decl_stmt
name|bool
name|isToolTip
init|=
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|ToolTip
operator|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|bool
name|isPopup
init|=
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|bool
name|isTool
init|=
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Tool
operator|)
decl_stmt|;
end_decl_stmt
begin_return
return|return
operator|!
operator|(
name|isPopup
operator|||
name|isToolTip
operator|||
name|isTool
operator|)
return|;
end_return
begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|becomeMainWindow
block|{
index|[
name|super
name|becomeMainWindow
index|]
block|;
comment|// Cocoa sometimes tell a hidden window to become the
comment|// main window (and as such, show it). This can e.g
comment|// happend when the application gets activated. If
comment|// this is the case, we tell it to hide again:
if|if
condition|(
operator|!
index|[
name|self
name|isVisible
index|]
condition|)
index|[
name|self
name|orderOut
operator|:
name|self
index|]
expr_stmt|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|toggleToolbarShown
operator|-
operator|(
name|void
operator|)
name|toggleToolbarShown
operator|:
operator|(
name|id
operator|)
name|sender
block|{
name|macSendToolbarChangeEvent
argument_list|(
argument|[self QT_MANGLE_NAMESPACE(qt_qwidget)]
argument_list|)
block|;
index|[
name|super
name|toggleToolbarShown
operator|:
name|sender
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|flagsChanged
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|theEvent
block|{
name|qt_dispatchModifiersChanged
argument_list|(
argument|theEvent
argument_list|,
argument|[self QT_MANGLE_NAMESPACE(qt_qwidget)]
argument_list|)
block|;
index|[
name|super
name|flagsChanged
operator|:
name|theEvent
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|tabletProximity
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|tabletEvent
block|{
name|qt_dispatchTabletProximityEvent
argument_list|(
name|tabletEvent
argument_list|)
block|; }
DECL|function|terminate
operator|-
operator|(
name|void
operator|)
name|terminate
operator|:
operator|(
name|id
operator|)
name|sender
block|{
comment|// This function is called from the quit item in the menubar when this window
comment|// is in the first responder chain (see also qtDispatcherToQAction above)
index|[
name|NSApp
name|terminate
operator|:
name|sender
index|]
block|; }
DECL|function|setLevel
operator|-
operator|(
name|void
operator|)
name|setLevel
operator|:
operator|(
name|NSInteger
operator|)
name|windowLevel
block|{
comment|// Cocoa will upon activating/deactivating applications level modal
comment|// windows up and down, regardsless of any explicit set window level.
comment|// To ensure that modal stays-on-top dialogs actually stays on top after
comment|// the application is activated (and therefore stacks in front of
comment|// other stays-on-top windows), we need to add this little special-case override:
name|QWidget
operator|*
name|widget
operator|=
index|[
index|[
name|QT_MANGLE_NAMESPACE
argument_list|(
argument|QCocoaWindowDelegate
argument_list|)
name|sharedDelegate
index|]
name|qt_qwidgetForWindow
operator|:
name|self
index|]
block|;
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|isModal
argument_list|()
operator|&&
operator|(
name|widget
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|WindowStaysOnTopHint
operator|)
condition|)
index|[
name|super
name|setLevel
operator|:
name|NSPopUpMenuWindowLevel
index|]
expr_stmt|;
else|else
index|[
name|super
name|setLevel
operator|:
name|windowLevel
index|]
expr_stmt|;
block|}
end_expr_stmt
begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|sendEvent
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
index|[
name|self
name|retain
index|]
block|;
name|bool
name|handled
operator|=
name|false
block|;
switch|switch
condition|(
index|[
name|event
name|type
index|]
condition|)
block|{
case|case
name|NSMouseMoved
case|:
comment|// Cocoa sends move events to a parent and all its children under the mouse, much
comment|// like Qt handles hover events. But we only want to handle the move event once, so
comment|// to optimize a bit (since we subscribe for move event for all views), we handle it
comment|// here before this logic happends. Note: it might be tempting to do this shortcut for
comment|// all mouse events. The problem is that Cocoa does more than just find the correct view
comment|// when sending the event, like raising windows etc. So avoid it as much as possible:
name|handled
operator|=
name|qt_mac_handleMouseEvent
argument_list|(
name|event
argument_list|,
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|handled
condition|)
block|{
index|[
name|super
name|sendEvent
operator|:
name|event
index|]
expr_stmt|;
name|qt_mac_handleNonClientAreaMouseEvent
argument_list|(
name|self
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
index|[
name|self
name|release
index|]
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|setInitialFirstResponder
operator|:
operator|(
name|NSView
operator|*
operator|)
name|view
block|{
comment|// This method is called the first time the window is placed on screen and
comment|// is the earliest point in time we can connect OpenGL contexts to NSViews.
name|QWidget
operator|*
name|qwidget
operator|=
index|[
index|[
name|QT_MANGLE_NAMESPACE
argument_list|(
argument|QCocoaWindowDelegate
argument_list|)
name|sharedDelegate
index|]
name|qt_qwidgetForWindow
operator|:
name|self
index|]
block|;
if|if
condition|(
name|qwidget
condition|)
block|{
name|qt_event_request_window_change
argument_list|(
name|qwidget
argument_list|)
expr_stmt|;
name|qt_mac_send_posted_gl_updates
argument_list|(
name|qwidget
argument_list|)
expr_stmt|;
block|}
index|[
name|super
name|setInitialFirstResponder
operator|:
name|view
index|]
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|}  -
operator|(
name|BOOL
operator|)
name|makeFirstResponder
operator|:
operator|(
name|NSResponder
operator|*
operator|)
name|responder
block|{
comment|// For some reason Cocoa wants to flip the first responder
comment|// when Qt doesn't want to, sorry, but "No" :-)
if|if
condition|(
name|responder
operator|==
name|nil
operator|&&
name|qApp
operator|->
name|focusWidget
argument_list|()
condition|)
return|return
name|NO
return|;
end_expr_stmt
begin_return
return|return
index|[
name|super
name|makeFirstResponder
operator|:
name|responder
index|]
return|;
end_return
begin_expr_stmt
unit|}  +
DECL|function|frameViewClassForStyleMask
operator|(
name|Class
operator|)
name|frameViewClassForStyleMask
operator|:
operator|(
name|NSUInteger
operator|)
name|styleMask
block|{
if|if
condition|(
name|styleMask
operator|&
name|QtMacCustomizeWindow
condition|)
return|return
index|[
name|QT_MANGLE_NAMESPACE
argument_list|(
argument|QCocoaWindowCustomThemeFrame
argument_list|)
name|class
index|]
return|;
end_expr_stmt
begin_return
return|return
index|[
name|super
name|frameViewClassForStyleMask
operator|:
name|styleMask
index|]
return|;
end_return
begin_if
unit|}
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_6
end_if
begin_expr_stmt
unit|-
operator|(
name|void
operator|)
name|touchesBeganWithEvent
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
expr_stmt|;
end_expr_stmt
begin_block
block|{
name|QPoint
name|qlocal
decl_stmt|,
name|qglobal
decl_stmt|;
name|QWidget
modifier|*
name|widgetToGetTouch
init|=
literal|0
decl_stmt|;
name|qt_mac_getTargetForMouseEvent
argument_list|(
name|event
argument_list|,
name|QEvent
operator|::
name|Gesture
argument_list|,
name|qlocal
argument_list|,
name|qglobal
argument_list|,
literal|0
argument_list|,
operator|&
name|widgetToGetTouch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widgetToGetTouch
condition|)
return|return;
name|bool
name|all
init|=
name|widgetToGetTouch
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TouchPadAcceptSingleTouchEvents
argument_list|)
decl_stmt|;
name|qt_translateRawTouchEvent
argument_list|(
name|widgetToGetTouch
argument_list|,
name|QTouchEvent
operator|::
name|TouchPad
argument_list|,
name|QCocoaTouch
operator|::
name|getCurrentTouchPointList
argument_list|(
name|event
argument_list|,
name|all
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|touchesMovedWithEvent
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
expr_stmt|;
end_expr_stmt
begin_block
block|{
name|QPoint
name|qlocal
decl_stmt|,
name|qglobal
decl_stmt|;
name|QWidget
modifier|*
name|widgetToGetTouch
init|=
literal|0
decl_stmt|;
name|qt_mac_getTargetForMouseEvent
argument_list|(
name|event
argument_list|,
name|QEvent
operator|::
name|Gesture
argument_list|,
name|qlocal
argument_list|,
name|qglobal
argument_list|,
literal|0
argument_list|,
operator|&
name|widgetToGetTouch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widgetToGetTouch
condition|)
return|return;
name|bool
name|all
init|=
name|widgetToGetTouch
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TouchPadAcceptSingleTouchEvents
argument_list|)
decl_stmt|;
name|qt_translateRawTouchEvent
argument_list|(
name|widgetToGetTouch
argument_list|,
name|QTouchEvent
operator|::
name|TouchPad
argument_list|,
name|QCocoaTouch
operator|::
name|getCurrentTouchPointList
argument_list|(
name|event
argument_list|,
name|all
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|touchesEndedWithEvent
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
expr_stmt|;
end_expr_stmt
begin_block
block|{
name|QPoint
name|qlocal
decl_stmt|,
name|qglobal
decl_stmt|;
name|QWidget
modifier|*
name|widgetToGetTouch
init|=
literal|0
decl_stmt|;
name|qt_mac_getTargetForMouseEvent
argument_list|(
name|event
argument_list|,
name|QEvent
operator|::
name|Gesture
argument_list|,
name|qlocal
argument_list|,
name|qglobal
argument_list|,
literal|0
argument_list|,
operator|&
name|widgetToGetTouch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widgetToGetTouch
condition|)
return|return;
name|bool
name|all
init|=
name|widgetToGetTouch
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TouchPadAcceptSingleTouchEvents
argument_list|)
decl_stmt|;
name|qt_translateRawTouchEvent
argument_list|(
name|widgetToGetTouch
argument_list|,
name|QTouchEvent
operator|::
name|TouchPad
argument_list|,
name|QCocoaTouch
operator|::
name|getCurrentTouchPointList
argument_list|(
name|event
argument_list|,
name|all
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|touchesCancelledWithEvent
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
expr_stmt|;
end_expr_stmt
begin_block
block|{
name|QPoint
name|qlocal
decl_stmt|,
name|qglobal
decl_stmt|;
name|QWidget
modifier|*
name|widgetToGetTouch
init|=
literal|0
decl_stmt|;
name|qt_mac_getTargetForMouseEvent
argument_list|(
name|event
argument_list|,
name|QEvent
operator|::
name|Gesture
argument_list|,
name|qlocal
argument_list|,
name|qglobal
argument_list|,
literal|0
argument_list|,
operator|&
name|widgetToGetTouch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widgetToGetTouch
condition|)
return|return;
name|bool
name|all
init|=
name|widgetToGetTouch
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TouchPadAcceptSingleTouchEvents
argument_list|)
decl_stmt|;
name|qt_translateRawTouchEvent
argument_list|(
name|widgetToGetTouch
argument_list|,
name|QTouchEvent
operator|::
name|TouchPad
argument_list|,
name|QCocoaTouch
operator|::
name|getCurrentTouchPointList
argument_list|(
name|event
argument_list|,
name|all
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// MAC_OS_X_VERSION_MAX_ALLOWED>= MAC_OS_X_VERSION_10_6
end_comment
begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|registerDragTypes
block|{
comment|// Calling registerForDraggedTypes below is slow, so only do
comment|// it once for each window, or when the custom types change.
name|QMacCocoaAutoReleasePool
name|pool
block|;
specifier|const
name|QStringList
operator|&
name|customTypes
operator|=
name|qEnabledDraggedTypes
argument_list|()
block|;
if|if
condition|(
name|currentCustomDragTypes
operator|==
literal|0
operator|||
operator|*
name|currentCustomDragTypes
operator|!=
name|customTypes
condition|)
block|{
if|if
condition|(
name|currentCustomDragTypes
operator|==
literal|0
condition|)
name|currentCustomDragTypes
operator|=
name|new
name|QStringList
argument_list|()
expr_stmt|;
operator|*
name|currentCustomDragTypes
operator|=
name|customTypes
expr_stmt|;
specifier|const
name|NSString
modifier|*
name|mimeTypeGeneric
init|= @
literal|"com.trolltech.qt.MimeTypeName"
decl_stmt|;
name|NSMutableArray
modifier|*
name|supportedTypes
init|=
index|[
name|NSMutableArray
name|arrayWithObjects
operator|:
name|NSColorPboardType
operator|,
name|NSFilenamesPboardType
operator|,
name|NSStringPboardType
operator|,
name|NSFilenamesPboardType
operator|,
name|NSPostScriptPboardType
operator|,
name|NSTIFFPboardType
operator|,
name|NSRTFPboardType
operator|,
name|NSTabularTextPboardType
operator|,
name|NSFontPboardType
operator|,
name|NSRulerPboardType
operator|,
name|NSFileContentsPboardType
operator|,
name|NSColorPboardType
operator|,
name|NSRTFDPboardType
operator|,
name|NSHTMLPboardType
operator|,
name|NSPICTPboardType
operator|,
name|NSURLPboardType
operator|,
name|NSPDFPboardType
operator|,
name|NSVCardPboardType
operator|,
name|NSFilesPromisePboardType
operator|,
name|NSInkTextPboardType
operator|,
name|NSMultipleTextSelectionPboardType
operator|,
name|mimeTypeGeneric
operator|,
name|nil
index|]
decl_stmt|;
comment|// Add custom types supported by the application.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|customTypes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
index|[
name|supportedTypes
name|addObject
operator|:
name|qt_mac_QStringToNSString
argument_list|(
name|customTypes
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
block|}
index|[
name|self
name|registerForDraggedTypes
operator|:
name|supportedTypes
index|]
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|} }
operator|-
operator|(
name|void
operator|)
name|removeDropData
block|{
if|if
condition|(
name|dropData
condition|)
block|{
name|delete
name|dropData
decl_stmt|;
name|dropData
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|addDropData
operator|:
operator|(
name|id
operator|<
name|NSDraggingInfo
operator|>
operator|)
name|sender
block|{
index|[
name|self
name|removeDropData
index|]
block|;
name|CFStringRef
name|dropPasteboard
operator|=
operator|(
name|CFStringRef
operator|)
index|[
index|[
name|sender
name|draggingPasteboard
index|]
name|name
index|]
block|;
name|dropData
operator|=
name|new
name|QCocoaDropData
argument_list|(
name|dropPasteboard
argument_list|)
block|; }
DECL|function|changeDraggingCursor
operator|-
operator|(
name|void
operator|)
name|changeDraggingCursor
operator|:
operator|(
name|NSDragOperation
operator|)
name|newOperation
block|{
specifier|static
name|SEL
name|action
operator|=
name|nil
block|;
specifier|static
name|bool
name|operationSupported
operator|=
name|false
block|;
if|if
condition|(
name|action
operator|==
name|nil
condition|)
block|{
name|action
operator|=
name|NSSelectorFromString
argument_list|(
argument|@
literal|"operationNotAllowedCursor"
argument_list|)
expr_stmt|;
if|if
condition|(
index|[
name|NSCursor
name|respondsToSelector
operator|:
name|action
index|]
condition|)
block|{
name|operationSupported
operator|=
name|true
expr_stmt|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}     if
operator|(
name|operationSupported
operator|)
block|{
name|NSCursor
operator|*
name|notAllowedCursor
operator|=
index|[
name|NSCursor
name|performSelector
operator|:
name|action
index|]
block|;
name|bool
name|isNotAllowedCursor
operator|=
operator|(
index|[
name|NSCursor
name|currentCursor
index|]
operator|==
name|notAllowedCursor
operator|)
block|;
if|if
condition|(
name|newOperation
operator|==
name|NSDragOperationNone
operator|&&
operator|!
name|isNotAllowedCursor
condition|)
block|{
index|[
name|notAllowedCursor
name|push
index|]
expr_stmt|;
block|}
end_expr_stmt
begin_elseif
elseif|else
if|if
condition|(
name|newOperation
operator|!=
name|NSDragOperationNone
operator|&&
name|isNotAllowedCursor
condition|)
block|{
index|[
name|notAllowedCursor
name|pop
index|]
expr_stmt|;
block|}
end_elseif
begin_expr_stmt
unit|} }
operator|-
operator|(
name|NSDragOperation
operator|)
name|draggingEntered
operator|:
operator|(
name|id
operator|<
name|NSDraggingInfo
operator|>
operator|)
name|sender
block|{
comment|// The user dragged something into the window. Send a draggingEntered message
comment|// to the QWidget under the mouse. As the drag moves over the window, and over
comment|// different widgets, we will handle enter and leave events from within
comment|// draggingUpdated below. The reason why we handle this ourselves rather than
comment|// subscribing for drag events directly in QCocoaView is that calling
comment|// registerForDraggedTypes on the views will severly degrade initialization time
comment|// for an application that uses a lot of drag subscribing widgets.
name|NSPoint
name|nswindowPoint
operator|=
index|[
name|sender
name|draggingLocation
index|]
block|;
name|NSPoint
name|nsglobalPoint
operator|=
index|[
index|[
name|sender
name|draggingDestinationWindow
index|]
name|convertBaseToScreen
operator|:
name|nswindowPoint
index|]
block|;
name|QPoint
name|globalPoint
operator|=
name|flipPoint
argument_list|(
name|nsglobalPoint
argument_list|)
operator|.
name|toPoint
argument_list|()
block|;
name|QWidget
operator|*
name|qwidget
operator|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|globalPoint
argument_list|)
block|;
operator|*
name|currentDragTarget
argument_list|()
operator|=
name|qwidget
block|;
if|if
condition|(
operator|!
name|qwidget
condition|)
return|return
index|[
name|super
name|draggingEntered
operator|:
name|sender
index|]
return|;
end_expr_stmt
begin_if
if|if
condition|(
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
operator|==
name|false
condition|)
return|return
name|NSDragOperationNone
return|;
end_if
begin_expr_stmt
index|[
name|self
name|addDropData
operator|:
name|sender
index|]
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|QMimeData
modifier|*
name|mimeData
init|=
name|dropData
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|source
argument_list|()
condition|)
name|mimeData
operator|=
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dragPrivate
argument_list|()
operator|->
name|data
expr_stmt|;
end_if
begin_decl_stmt
name|NSDragOperation
name|nsActions
init|=
index|[
name|sender
name|draggingSourceOperationMask
index|]
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|Qt
operator|::
name|DropActions
name|qtAllowed
operator|=
name|qt_mac_mapNSDragOperations
argument_list|(
name|nsActions
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
operator|.
name|lastOperation
argument_list|)
operator|=
name|nsActions
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
operator|=
name|Qt
operator|::
name|NoModifier
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
index|[
name|sender
name|draggingSource
index|]
operator|!=
name|nil
condition|)
block|{
comment|// modifier flags might have changed, update it here since we don't send any input events.
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|qt_cocoaModifiers2QtModifiers
argument_list|(
argument|[[NSApp currentEvent] modifierFlags]
argument_list|)
expr_stmt|;
name|modifiers
operator|=
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// when the source is from another application the above technique will not work.
name|modifiers
operator|=
name|qt_cocoaDragOperation2QtModifiers
argument_list|(
name|nsActions
argument_list|)
expr_stmt|;
block|}
end_if
begin_comment
comment|// send the drag enter event to the widget.
end_comment
begin_decl_stmt
name|QPoint
name|localPoint
argument_list|(
name|qwidget
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QDragEnterEvent
name|qDEEvent
argument_list|(
name|localPoint
argument_list|,
name|qtAllowed
argument_list|,
name|mimeData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|modifiers
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|qDEEvent
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|qDEEvent
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
comment|// The enter event was not accepted. We mark this by removing
comment|// the drop data so we don't send subsequent drag move events:
index|[
name|self
name|removeDropData
index|]
expr_stmt|;
index|[
name|self
name|changeDraggingCursor
operator|:
name|NSDragOperationNone
index|]
expr_stmt|;
return|return
name|NSDragOperationNone
return|;
block|}
else|else
block|{
comment|// Send a drag move event immediately after a drag enter event (as per documentation).
name|QDragMoveEvent
name|qDMEvent
argument_list|(
name|localPoint
argument_list|,
name|qtAllowed
argument_list|,
name|mimeData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|modifiers
argument_list|)
decl_stmt|;
name|qDMEvent
operator|.
name|setDropAction
argument_list|(
name|qDEEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
name|qDMEvent
operator|.
name|accept
argument_list|()
expr_stmt|;
comment|// accept by default, since enter event was accepted.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|qDMEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qDMEvent
operator|.
name|isAccepted
argument_list|()
operator|||
name|qDMEvent
operator|.
name|dropAction
argument_list|()
operator|==
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
comment|// Since we accepted the drag enter event, the widget expects
comment|// future drage move events.
name|nsActions
operator|=
name|NSDragOperationNone
expr_stmt|;
comment|// Save as ignored in the answer rect.
name|qDMEvent
operator|.
name|setDropAction
argument_list|(
name|Qt
operator|::
name|IgnoreAction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsActions
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_mapDropAction
argument_list|)
argument_list|(
name|qDMEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QT_PREPEND_NAMESPACE
function_decl|(
name|qt_mac_copy_answer_rect
function_decl|)
parameter_list|(
name|qDMEvent
parameter_list|)
function_decl|;
index|[
name|self
name|changeDraggingCursor
operator|:
name|nsActions
index|]
expr_stmt|;
return|return
name|nsActions
return|;
block|}
end_if
begin_expr_stmt
unit|}  -
operator|(
name|NSDragOperation
operator|)
name|draggingUpdated
operator|:
operator|(
name|id
operator|<
name|NSDraggingInfo
operator|>
operator|)
name|sender
block|{
name|NSPoint
name|nswindowPoint
operator|=
index|[
name|sender
name|draggingLocation
index|]
block|;
name|NSPoint
name|nsglobalPoint
operator|=
index|[
index|[
name|sender
name|draggingDestinationWindow
index|]
name|convertBaseToScreen
operator|:
name|nswindowPoint
index|]
block|;
name|QPoint
name|globalPoint
operator|=
name|flipPoint
argument_list|(
name|nsglobalPoint
argument_list|)
operator|.
name|toPoint
argument_list|()
block|;
name|QWidget
operator|*
name|qwidget
operator|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|globalPoint
argument_list|)
block|;
if|if
condition|(
operator|!
name|qwidget
condition|)
return|return
index|[
name|super
name|draggingEntered
operator|:
name|sender
index|]
return|;
end_expr_stmt
begin_comment
comment|// First, check if the widget under the mouse has changed since the
end_comment
begin_comment
comment|// last drag move events. If so, we need to change target, and dispatch
end_comment
begin_comment
comment|// syntetic drag enter/leave events:
end_comment
begin_if
if|if
condition|(
name|qwidget
operator|!=
operator|*
name|currentDragTarget
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|currentDragTarget
argument_list|()
operator|&&
name|dropData
condition|)
block|{
name|QDragLeaveEvent
name|de
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|*
name|currentDragTarget
argument_list|()
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
index|[
name|self
name|removeDropData
index|]
expr_stmt|;
block|}
return|return
index|[
name|self
name|draggingEntered
operator|:
name|sender
index|]
return|;
block|}
end_if
begin_if
if|if
condition|(
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
operator|==
name|false
condition|)
return|return
name|NSDragOperationNone
return|;
end_if
begin_comment
comment|// If we have no drop data (which will be assigned inside draggingEntered), it means
end_comment
begin_comment
comment|// that the current drag target did not accept the enter event. If so, we ignore
end_comment
begin_comment
comment|// subsequent move events as well:
end_comment
begin_if
if|if
condition|(
name|dropData
operator|==
literal|0
condition|)
block|{
index|[
name|self
name|changeDraggingCursor
operator|:
name|NSDragOperationNone
index|]
expr_stmt|;
return|return
name|NSDragOperationNone
return|;
block|}
end_if
begin_comment
comment|// If the mouse is still within the accepted rect (provided by
end_comment
begin_comment
comment|// the application on a previous event), we follow the optimization
end_comment
begin_comment
comment|// and just return the answer given at that point:
end_comment
begin_decl_stmt
name|NSDragOperation
name|nsActions
init|=
index|[
name|sender
name|draggingSourceOperationMask
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QPoint
name|localPoint
argument_list|(
name|qwidget
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|qt_mac_mouse_inside_answer_rect
argument_list|(
name|localPoint
argument_list|)
operator|&&
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
operator|.
name|lastOperation
argument_list|)
operator|==
name|nsActions
condition|)
block|{
name|NSDragOperation
name|operation
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_mapDropActions
argument_list|)
argument_list|(
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
operator|.
name|lastAction
argument_list|)
argument_list|)
decl_stmt|;
index|[
name|self
name|changeDraggingCursor
operator|:
name|operation
index|]
expr_stmt|;
return|return
name|operation
return|;
block|}
end_if
begin_expr_stmt
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
operator|.
name|lastOperation
argument_list|)
operator|=
name|nsActions
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Qt
operator|::
name|DropActions
name|qtAllowed
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_mapNSDragOperations
argument_list|)
argument_list|(
name|nsActions
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
operator|=
name|Qt
operator|::
name|NoModifier
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Update modifiers:
end_comment
begin_if
if|if
condition|(
index|[
name|sender
name|draggingSource
index|]
operator|!=
name|nil
condition|)
block|{
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|qt_cocoaModifiers2QtModifiers
argument_list|(
argument|[[NSApp currentEvent] modifierFlags]
argument_list|)
expr_stmt|;
name|modifiers
operator|=
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|modifiers
operator|=
name|qt_cocoaDragOperation2QtModifiers
argument_list|(
name|nsActions
argument_list|)
expr_stmt|;
block|}
end_if
begin_decl_stmt
name|QMimeData
modifier|*
name|mimeData
init|=
name|dropData
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|source
argument_list|()
condition|)
name|mimeData
operator|=
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dragPrivate
argument_list|()
operator|->
name|data
expr_stmt|;
end_if
begin_comment
comment|// Insert the same drop action on the event according to
end_comment
begin_comment
comment|// what the application told us it should be on the previous event:
end_comment
begin_decl_stmt
name|QDragMoveEvent
name|qDMEvent
argument_list|(
name|localPoint
argument_list|,
name|qtAllowed
argument_list|,
name|mimeData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|modifiers
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
argument_list|)
operator|.
name|lastAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
operator|&&
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
argument_list|)
operator|.
name|buttons
operator|==
name|qDMEvent
operator|.
name|mouseButtons
argument_list|()
operator|&&
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
argument_list|)
operator|.
name|modifiers
operator|==
name|qDMEvent
operator|.
name|keyboardModifiers
argument_list|()
condition|)
name|qDMEvent
operator|.
name|setDropAction
argument_list|(
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qt_mac_dnd_answer_rec
argument_list|)
operator|.
name|lastAction
argument_list|)
expr_stmt|;
end_if
begin_comment
comment|// Now, end the drag move event to the widget:
end_comment
begin_expr_stmt
name|qDMEvent
operator|.
name|accept
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|qDMEvent
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|NSDragOperation
name|operation
init|=
name|qt_mac_mapDropAction
argument_list|(
name|qDMEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
operator|!
name|qDMEvent
operator|.
name|isAccepted
argument_list|()
operator|||
name|qDMEvent
operator|.
name|dropAction
argument_list|()
operator|==
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
comment|// Ignore this event (we will still receive further
comment|// notifications), save as ignored in the answer rect:
name|operation
operator|=
name|NSDragOperationNone
expr_stmt|;
name|qDMEvent
operator|.
name|setDropAction
argument_list|(
name|Qt
operator|::
name|IgnoreAction
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|qt_mac_copy_answer_rect
argument_list|(
name|qDMEvent
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
index|[
name|self
name|changeDraggingCursor
operator|:
name|operation
index|]
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|operation
return|;
end_return
begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|draggingExited
operator|:
operator|(
name|id
operator|<
name|NSDraggingInfo
operator|>
operator|)
name|sender
block|{
name|NSPoint
name|nswindowPoint
operator|=
index|[
name|sender
name|draggingLocation
index|]
block|;
name|NSPoint
name|nsglobalPoint
operator|=
index|[
index|[
name|sender
name|draggingDestinationWindow
index|]
name|convertBaseToScreen
operator|:
name|nswindowPoint
index|]
block|;
name|QPoint
name|globalPoint
operator|=
name|flipPoint
argument_list|(
name|nsglobalPoint
argument_list|)
operator|.
name|toPoint
argument_list|()
block|;
name|QWidget
operator|*
name|qwidget
operator|=
operator|*
name|currentDragTarget
argument_list|()
block|;
if|if
condition|(
operator|!
name|qwidget
condition|)
return|return
index|[
name|super
name|draggingExited
operator|:
name|sender
index|]
return|;
end_expr_stmt
begin_if
if|if
condition|(
name|dropData
condition|)
block|{
name|QDragLeaveEvent
name|de
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
index|[
name|self
name|removeDropData
index|]
expr_stmt|;
block|}
end_if
begin_comment
comment|// Clean-up:
end_comment
begin_expr_stmt
index|[
name|self
name|removeDropData
index|]
expr_stmt|;
end_expr_stmt
begin_expr_stmt
operator|*
name|currentDragTarget
argument_list|()
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_expr_stmt
index|[
name|self
name|changeDraggingCursor
operator|:
name|NSDragOperationEvery
index|]
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|}  -
operator|(
name|BOOL
operator|)
name|performDragOperation
operator|:
operator|(
name|id
operator|<
name|NSDraggingInfo
operator|>
operator|)
name|sender
block|{
name|QWidget
operator|*
name|qwidget
operator|=
operator|*
name|currentDragTarget
argument_list|()
block|;
if|if
condition|(
operator|!
name|qwidget
condition|)
return|return
name|NO
return|;
operator|*
name|currentDragTarget
argument_list|()
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|NSPoint
name|nswindowPoint
init|=
index|[
name|sender
name|draggingLocation
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|NSPoint
name|nsglobalPoint
init|=
index|[
index|[
name|sender
name|draggingDestinationWindow
index|]
name|convertBaseToScreen
operator|:
name|nswindowPoint
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QPoint
name|globalPoint
init|=
name|flipPoint
argument_list|(
name|nsglobalPoint
argument_list|)
operator|.
name|toPoint
argument_list|()
decl_stmt|;
end_decl_stmt
begin_expr_stmt
index|[
name|self
name|addDropData
operator|:
name|sender
index|]
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|NSDragOperation
name|nsActions
init|=
index|[
name|sender
name|draggingSourceOperationMask
index|]
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|Qt
operator|::
name|DropActions
name|qtAllowed
operator|=
name|qt_mac_mapNSDragOperations
argument_list|(
name|nsActions
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|QMimeData
modifier|*
name|mimeData
init|=
name|dropData
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|source
argument_list|()
condition|)
name|mimeData
operator|=
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dragPrivate
argument_list|()
operator|->
name|data
expr_stmt|;
end_if
begin_if
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|object
condition|)
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dragPrivate
argument_list|()
operator|->
name|target
operator|=
name|qwidget
expr_stmt|;
end_if
begin_decl_stmt
name|QPoint
name|localPoint
argument_list|(
name|qwidget
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QDropEvent
name|de
argument_list|(
name|localPoint
argument_list|,
name|qtAllowed
argument_list|,
name|mimeData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|object
condition|)
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dragPrivate
argument_list|()
operator|->
name|executed_action
operator|=
name|de
operator|.
name|dropAction
argument_list|()
expr_stmt|;
end_if
begin_return
return|return
name|de
operator|.
name|isAccepted
argument_list|()
return|;
end_return
begin_comment
unit|}
comment|// This is a hack and it should be removed once we find the real cause for
end_comment
begin_comment
comment|// the painting problems.
end_comment
begin_comment
comment|// We have a static variable that signals if we have been called before or not.
end_comment
begin_decl_stmt
unit|static
DECL|variable|firstDrawingInvocation
name|bool
name|firstDrawingInvocation
init|=
name|true
decl_stmt|;
end_decl_stmt
begin_comment
comment|// The method below exists only as a workaround to draw/not draw the baseline
end_comment
begin_comment
comment|// in the title bar. This is to support unifiedToolbar look.
end_comment
begin_comment
comment|// This method is very special. To begin with, it is a
end_comment
begin_comment
comment|// method that will get called only if we enable documentMode.
end_comment
begin_comment
comment|// Furthermore, it won't get called as a normal method, we swap
end_comment
begin_comment
comment|// this method with the normal implementation of drawRect in
end_comment
begin_comment
comment|// _NSThemeFrame. When this method is active, its mission is to
end_comment
begin_comment
comment|// first call the original drawRect implementation so the widget
end_comment
begin_comment
comment|// gets proper painting. After that, it needs to detect if there
end_comment
begin_comment
comment|// is a toolbar or not, in order to decide how to handle the unified
end_comment
begin_comment
comment|// look. The distinction is important since the presence and
end_comment
begin_comment
comment|// visibility of a toolbar change the way we enter into unified mode.
end_comment
begin_comment
comment|// When there is a toolbar and that toolbar is visible, the problem
end_comment
begin_comment
comment|// is as simple as to tell the toolbar not to draw its baseline.
end_comment
begin_comment
comment|// However when there is not toolbar or the toolbar is not visible,
end_comment
begin_comment
comment|// we need to draw a line on top of the baseline, because the baseline
end_comment
begin_comment
comment|// in that case will belong to the title. For this case we need to draw
end_comment
begin_comment
comment|// a line on top of the baseline.
end_comment
begin_comment
comment|// As usual, there is a special case. When we first are called, we might
end_comment
begin_comment
comment|// need to repaint ourselves one more time. We only need that if we
end_comment
begin_comment
comment|// didn't get the activation, i.e. when we are launched via the command
end_comment
begin_comment
comment|// line. And this only if the toolbar is visible from the beginning,
end_comment
begin_comment
comment|// so we have a special flag that signals if we need to repaint or not.
end_comment
begin_expr_stmt
DECL|function|drawRectSpecial
operator|-
operator|(
name|void
operator|)
name|drawRectSpecial
operator|:
operator|(
name|NSRect
operator|)
name|rect
block|{
comment|// Call the original drawing method.
index|[
name|id
argument_list|(
argument|self
argument_list|)
name|drawRectOriginal
operator|:
name|rect
index|]
block|;
name|NSWindow
operator|*
name|window
operator|=
index|[
name|id
argument_list|(
argument|self
argument_list|)
name|window
index|]
block|;
name|NSToolbar
operator|*
name|toolbar
operator|=
index|[
name|window
name|toolbar
index|]
block|;
if|if
condition|(
operator|!
name|toolbar
condition|)
block|{
comment|// There is no toolbar, we have to draw a line on top of the line drawn by Cocoa.
name|macDrawRectOnTop
argument_list|(
operator|(
name|void
operator|*
operator|)
name|window
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_else
else|else
block|{
if|if
condition|(
index|[
name|toolbar
name|isVisible
index|]
condition|)
block|{
comment|// We tell Cocoa to avoid drawing the line at the end.
if|if
condition|(
name|firstDrawingInvocation
condition|)
block|{
name|firstDrawingInvocation
operator|=
name|false
expr_stmt|;
name|macSyncDrawingOnFirstInvocation
argument_list|(
operator|(
name|void
operator|*
operator|)
name|window
argument_list|)
expr_stmt|;
block|}
else|else
index|[
name|toolbar
name|setShowsBaselineSeparator
operator|:
name|NO
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// There is a toolbar but it is not visible so
comment|// we have to draw a line on top of the line drawn by Cocoa.
name|macDrawRectOnTop
argument_list|(
operator|(
name|void
operator|*
operator|)
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_else
begin_expr_stmt
unit|}  -
DECL|function|drawRectOriginal
operator|(
name|void
operator|)
name|drawRectOriginal
operator|:
operator|(
name|NSRect
operator|)
name|rect
block|{
name|Q_UNUSED
argument_list|(
argument|rect
argument_list|)
comment|// This method implementation is here to silenct the compiler.
comment|// See drawRectSpecial for information.
block|}
end_expr_stmt
end_unit
