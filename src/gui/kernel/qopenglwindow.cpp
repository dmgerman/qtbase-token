begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopenglwindow.h"
end_include
begin_include
include|#
directive|include
file|"qpaintdevicewindow_p.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLFramebufferObject>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLPaintDevice>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLFunctions>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopengltextureblitter_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QMatrix4x4>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOffscreenSurface>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class QOpenGLWindow   \inmodule QtGui   \since 5.4   \brief The QOpenGLWindow class is a convenience subclass of QWindow to perform OpenGL painting.    QOpenGLWindow is an enhanced QWindow that allows easily creating windows that   perform OpenGL rendering using an API that is compatible with QOpenGLWidget   and is similar to the legacy QGLWidget. Unlike QOpenGLWidget, QOpenGLWindow   has no dependency on the widgets module and offers better performance.    A typical application will subclass QOpenGLWindow and reimplement the following   virtual functions:    \list    \li initializeGL() to perform OpenGL resource initialization    \li resizeGL() to set up the transformation matrices and other window size dependent resources    \li paintGL() to issue OpenGL commands or draw using QPainter    \endlist    To schedule a repaint, call the update() function. Note that this will not   immediately result in a call to paintGL(). Calling update() multiple times in   a row will not change the behavior in any way.    This is a slot so it can be connected to a \l QTimer::timeout() signal to   perform animation. Note however that in the modern OpenGL world it is a much   better choice to rely on synchronization to the vertical refresh rate of the   display. See \l{QSurfaceFormat::setSwapInterval()}{setSwapInterval()} on a   description of the swap interval. With a swap interval of \c 1, which is the   case on most systems by default, the   \l{QOpenGLContext::swapBuffers()}{swapBuffers()} call, that is executed   internally by QOpenGLWindow after each repaint, will block and wait for   vsync. This means that whenever the swap is done, an update can be scheduled   again by calling update(), without relying on timers.    To request a specific configuration for the context, use setFormat()   like for any other QWindow. This allows, among others, requesting a   given OpenGL version and profile, or enabling depth and stencil   buffers.    Unlike QWindow, QOpenGLWindow allows opening a painter on itself and perform   QPainter-based drawing.    QOpenGLWindow supports multiple update behaviors. The default,   \c NoPartialUpdate is equivalent to a regular, OpenGL-based QWindow or the   legacy QGLWidget. In contrast, \c PartialUpdateBlit and \c PartialUpdateBlend are   more in line with QOpenGLWidget's way of working, where there is always an   extra, dedicated framebuffer object present. These modes allow, by   sacrificing some performance, redrawing only a smaller area on each paint and   having the rest of the content preserved from of the previous frame. This is   useful for applications than render incrementally using QPainter, because   this way they do not have to redraw the entire window content on each   paintGL() call.    For more information on graphics in Qt, see \l {Graphics}.  */
end_comment
begin_comment
comment|/*!   \enum QOpenGLWindow::UpdateBehavior    This enum describes the update strategy of the QOpenGLWindow.    \value NoPartialUpdate Indicates that the entire window surface will   redrawn on each update and so no additional framebuffers are needed.   This is the setting used in most cases and is equivalent to how drawing   directly via QWindow would function.    \value PartialUpdateBlit Indicates that the drawing performed in paintGL()   does not cover the entire window. In this case an extra framebuffer object   is created under the hood, and rendering performed in paintGL() will target   this framebuffer. This framebuffer is then blitted onto the window surface's   default framebuffer after each paint. This allows having QPainter-based drawing   code in paintGL() which only repaints a smaller area at a time, because, unlike   NoPartialUpdate, the previous content is preserved.    \value PartialUpdateBlend Similar to PartialUpdateBlit, but instead of using   framebuffer blits, the contents of the extra framebuffer is rendered by   drawing a textured quad with blending enabled. This, unlike PartialUpdateBlit,   allows alpha blended content and works even when the glBlitFramebuffer is   not available. Performance-wise this setting is likely to be somewhat slower   than PartialUpdateBlit.  */
end_comment
begin_comment
comment|/*!     \fn void QOpenGLWindow::frameSwapped()      This signal is emitted after the potentially blocking     \l{QOpenGLContext::swapBuffers()}{buffer swap} has been done. Applications     that wish to continuously repaint synchronized to the vertical refresh,     should issue an update() upon this signal. This allows for a much smoother     experience compared to the traditional usage of timers. */
end_comment
begin_comment
comment|// GLES2 builds won't have these constants with the suffixless names
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GL_READ_FRAMEBUFFER
end_ifndef
begin_define
DECL|macro|GL_READ_FRAMEBUFFER
define|#
directive|define
name|GL_READ_FRAMEBUFFER
value|0x8CA8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_DRAW_FRAMEBUFFER
end_ifndef
begin_define
DECL|macro|GL_DRAW_FRAMEBUFFER
define|#
directive|define
name|GL_DRAW_FRAMEBUFFER
value|0x8CA9
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QOpenGLWindowPaintDevice
class|class
name|QOpenGLWindowPaintDevice
super|:
specifier|public
name|QOpenGLPaintDevice
block|{
public|public:
DECL|function|QOpenGLWindowPaintDevice
name|QOpenGLWindowPaintDevice
parameter_list|(
name|QOpenGLWindow
modifier|*
name|window
parameter_list|)
member_init_list|:
name|m_window
argument_list|(
name|window
argument_list|)
block|{ }
DECL|member|Q_DECL_OVERRIDE
name|void
name|ensureActiveTarget
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|m_window
name|QOpenGLWindow
modifier|*
name|m_window
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QOpenGLWindowPrivate
class|class
name|QOpenGLWindowPrivate
super|:
specifier|public
name|QPaintDeviceWindowPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QOpenGLWindow
parameter_list|)
specifier|public
private|:
DECL|function|QOpenGLWindowPrivate
name|QOpenGLWindowPrivate
parameter_list|(
name|QOpenGLWindow
operator|::
name|UpdateBehavior
name|updateBehavior
parameter_list|)
member_init_list|:
name|updateBehavior
argument_list|(
name|updateBehavior
argument_list|)
member_init_list|,
name|hasFboBlit
argument_list|(
literal|false
argument_list|)
block|{     }
DECL|function|~QOpenGLWindowPrivate
name|~
name|QOpenGLWindowPrivate
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isValid
argument_list|()
condition|)
block|{
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
comment|// this works even when the platformwindow is destroyed
name|paintDevice
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fbo
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|blitter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|q
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|get
specifier|static
name|QOpenGLWindowPrivate
modifier|*
name|get
parameter_list|(
name|QOpenGLWindow
modifier|*
name|w
parameter_list|)
block|{
return|return
name|w
operator|->
name|d_func
argument_list|()
return|;
block|}
DECL|function|bindFBO
name|void
name|bindFBO
parameter_list|()
block|{
if|if
condition|(
name|updateBehavior
operator|>
name|QOpenGLWindow
operator|::
name|NoPartialUpdate
condition|)
name|fbo
operator|->
name|bind
argument_list|()
expr_stmt|;
else|else
name|QOpenGLFramebufferObject
operator|::
name|bindDefault
argument_list|()
expr_stmt|;
block|}
name|void
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|Q_UNUSED
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|context
operator|.
name|reset
argument_list|(
operator|new
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|context
operator|->
name|setFormat
argument_list|(
name|q
operator|->
name|requestedFormat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|create
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLWindow::beginPaint: Failed to create context"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|makeCurrent
argument_list|(
name|q
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLWindow::beginPaint: Failed to make context current"
argument_list|)
expr_stmt|;
name|paintDevice
operator|.
name|reset
argument_list|(
operator|new
name|QOpenGLWindowPaintDevice
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|==
name|QOpenGLWindow
operator|::
name|PartialUpdateBlit
condition|)
name|hasFboBlit
operator|=
name|QOpenGLFramebufferObject
operator|::
name|hasOpenGLFramebufferBlit
argument_list|()
expr_stmt|;
name|q
operator|->
name|initializeGL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|context
operator|->
name|makeCurrent
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateBehavior
operator|>
name|QOpenGLWindow
operator|::
name|NoPartialUpdate
condition|)
block|{
if|if
condition|(
operator|!
name|fbo
operator|||
name|fbo
operator|->
name|size
argument_list|()
operator|!=
name|q
operator|->
name|size
argument_list|()
condition|)
block|{
name|QOpenGLFramebufferObjectFormat
name|fboFormat
decl_stmt|;
name|fboFormat
operator|.
name|setAttachment
argument_list|(
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|requestedFormat
argument_list|()
operator|.
name|samples
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|updateBehavior
operator|!=
name|QOpenGLWindow
operator|::
name|PartialUpdateBlend
condition|)
name|fboFormat
operator|.
name|setSamples
argument_list|(
name|q
operator|->
name|requestedFormat
argument_list|()
operator|.
name|samples
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QOpenGLWindow: PartialUpdateBlend does not support multisampling"
argument_list|)
expr_stmt|;
block|}
name|fbo
operator|.
name|reset
argument_list|(
operator|new
name|QOpenGLFramebufferObject
argument_list|(
name|q
operator|->
name|size
argument_list|()
argument_list|,
name|fboFormat
argument_list|)
argument_list|)
expr_stmt|;
name|markWindowAsDirty
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|markWindowAsDirty
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|deviceWidth
init|=
name|q
operator|->
name|width
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
decl_stmt|;
specifier|const
name|int
name|deviceHeight
init|=
name|q
operator|->
name|height
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
decl_stmt|;
name|paintDevice
operator|->
name|setSize
argument_list|(
name|QSize
argument_list|(
name|deviceWidth
argument_list|,
name|deviceHeight
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|deviceWidth
argument_list|,
name|deviceHeight
argument_list|)
expr_stmt|;
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|context
operator|->
name|defaultFramebufferObject
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|paintUnderGL
argument_list|()
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|>
name|QOpenGLWindow
operator|::
name|NoPartialUpdate
condition|)
name|fbo
operator|->
name|bind
argument_list|()
expr_stmt|;
block|}
name|void
name|endPaint
parameter_list|()
name|Q_DECL_OVERRIDE
block|{
name|Q_Q
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|>
name|QOpenGLWindow
operator|::
name|NoPartialUpdate
condition|)
name|fbo
operator|->
name|release
argument_list|()
expr_stmt|;
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|context
operator|->
name|defaultFramebufferObject
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|==
name|QOpenGLWindow
operator|::
name|PartialUpdateBlit
operator|&&
name|hasFboBlit
condition|)
block|{
name|QOpenGLExtensions
name|extensions
argument_list|(
name|context
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|,
name|fbo
operator|->
name|handle
argument_list|()
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_DRAW_FRAMEBUFFER
argument_list|,
name|context
operator|->
name|defaultFramebufferObject
argument_list|()
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBlitFramebuffer
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|width
argument_list|()
argument_list|,
name|q
operator|->
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|width
argument_list|()
argument_list|,
name|q
operator|->
name|height
argument_list|()
argument_list|,
name|GL_COLOR_BUFFER_BIT
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|updateBehavior
operator|>
name|QOpenGLWindow
operator|::
name|NoPartialUpdate
condition|)
block|{
if|if
condition|(
name|updateBehavior
operator|==
name|QOpenGLWindow
operator|::
name|PartialUpdateBlend
condition|)
block|{
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glBlendFunc
argument_list|(
name|GL_SRC_ALPHA
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blitter
operator|.
name|isCreated
argument_list|()
condition|)
name|blitter
operator|.
name|create
argument_list|()
expr_stmt|;
name|QRect
name|windowRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QMatrix4x4
name|target
init|=
name|QOpenGLTextureBlitter
operator|::
name|targetTransform
argument_list|(
name|windowRect
argument_list|,
name|windowRect
argument_list|)
decl_stmt|;
name|blitter
operator|.
name|bind
argument_list|()
expr_stmt|;
name|blitter
operator|.
name|blit
argument_list|(
name|fbo
operator|->
name|texture
argument_list|()
argument_list|,
name|target
argument_list|,
name|QOpenGLTextureBlitter
operator|::
name|OriginBottomLeft
argument_list|)
expr_stmt|;
name|blitter
operator|.
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|==
name|QOpenGLWindow
operator|::
name|PartialUpdateBlend
condition|)
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glDisable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|paintOverGL
argument_list|()
expr_stmt|;
block|}
name|void
name|flush
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|Q_UNUSED
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
name|context
operator|->
name|swapBuffers
argument_list|(
name|q
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|frameSwapped
argument_list|()
emit|;
block|}
DECL|member|updateBehavior
name|QOpenGLWindow
operator|::
name|UpdateBehavior
name|updateBehavior
decl_stmt|;
DECL|member|hasFboBlit
name|bool
name|hasFboBlit
decl_stmt|;
DECL|member|context
name|QScopedPointer
argument_list|<
name|QOpenGLContext
argument_list|>
name|context
decl_stmt|;
DECL|member|fbo
name|QScopedPointer
argument_list|<
name|QOpenGLFramebufferObject
argument_list|>
name|fbo
decl_stmt|;
DECL|member|paintDevice
name|QScopedPointer
argument_list|<
name|QOpenGLWindowPaintDevice
argument_list|>
name|paintDevice
decl_stmt|;
DECL|member|blitter
name|QOpenGLTextureBlitter
name|blitter
decl_stmt|;
DECL|member|backgroundColor
name|QColor
name|backgroundColor
decl_stmt|;
DECL|member|offscreenSurface
name|QScopedPointer
argument_list|<
name|QOffscreenSurface
argument_list|>
name|offscreenSurface
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|ensureActiveTarget
name|void
name|QOpenGLWindowPaintDevice
operator|::
name|ensureActiveTarget
parameter_list|()
block|{
name|QOpenGLWindowPrivate
operator|::
name|get
argument_list|(
name|m_window
argument_list|)
operator|->
name|bindFBO
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Constructs a new QOpenGLWindow with the given \a parent and \a updateBehavior.    \sa QOpenGLWindow::UpdateBehavior  */
end_comment
begin_constructor
DECL|function|QOpenGLWindow
name|QOpenGLWindow
operator|::
name|QOpenGLWindow
parameter_list|(
name|QOpenGLWindow
operator|::
name|UpdateBehavior
name|updateBehavior
parameter_list|,
name|QWindow
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QPaintDeviceWindow
argument_list|(
operator|*
operator|(
operator|new
name|QOpenGLWindowPrivate
argument_list|(
name|updateBehavior
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|setSurfaceType
argument_list|(
name|QSurface
operator|::
name|OpenGLSurface
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \return the update behavior for this QOpenGLWindow. */
end_comment
begin_function
DECL|function|updateBehavior
name|QOpenGLWindow
operator|::
name|UpdateBehavior
name|QOpenGLWindow
operator|::
name|updateBehavior
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|updateBehavior
return|;
block|}
end_function
begin_comment
comment|/*!   \return \c true if the window's OpenGL resources, like the context, have   been successfully initialized. Note that the return value is always \c false   until the window becomes exposed (shown). */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLWindow
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|context
operator|&&
name|d
operator|->
name|context
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Prepares for rendering OpenGL content for this window by making the   corresponding context current and binding the framebuffer object, if there is   one, in that context context.    It is not necessary to call this function in most cases, because it is called   automatically before invoking paintGL(). It is provided nonetheless to support   advanced, multi-threaded scenarios where a thread different than the GUI or main   thread may want to update the surface or framebuffer contents. See QOpenGLContext   for more information on threading related issues.    This function is suitable for calling also when the underlying platform window   is already destroyed. This means that it is safe to call this function from   a QOpenGLWindow subclass' destructor. If there is no native window anymore,   an offscreen surface is used instead. This ensures that OpenGL resource   cleanup operations in the destructor will always work, as long as   this function is called first.    \sa QOpenGLContext, context(), paintGL(), doneCurrent()  */
end_comment
begin_function
DECL|function|makeCurrent
name|void
name|QOpenGLWindow
operator|::
name|makeCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
comment|// The platform window may be destroyed at this stage and therefore
comment|// makeCurrent() may not safely be called with 'this'.
if|if
condition|(
name|handle
argument_list|()
condition|)
block|{
name|d
operator|->
name|context
operator|->
name|makeCurrent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|offscreenSurface
condition|)
block|{
name|d
operator|->
name|offscreenSurface
operator|.
name|reset
argument_list|(
operator|new
name|QOffscreenSurface
argument_list|)
expr_stmt|;
name|d
operator|->
name|offscreenSurface
operator|->
name|setFormat
argument_list|(
name|d
operator|->
name|context
operator|->
name|format
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|offscreenSurface
operator|->
name|create
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|context
operator|->
name|makeCurrent
argument_list|(
name|d
operator|->
name|offscreenSurface
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|bindFBO
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Releases the context.    It is not necessary to call this function in most cases, since the widget   will make sure the context is bound and released properly when invoking   paintGL().    \sa makeCurrent()  */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QOpenGLWindow
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|d
operator|->
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \return The QOpenGLContext used by this window or \c 0 if not yet initialized.  */
end_comment
begin_function
DECL|function|context
name|QOpenGLContext
modifier|*
name|QOpenGLWindow
operator|::
name|context
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|context
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   The framebuffer object handle used by this window.    When the update behavior is set to \c NoPartialUpdate, there is no separate   framebuffer object. In this case the returned value is the ID of the   default framebuffer.    Otherwise the value of the ID of the framebuffer object or \c 0 if not   yet initialized.  */
end_comment
begin_function
DECL|function|defaultFramebufferObject
name|GLuint
name|QOpenGLWindow
operator|::
name|defaultFramebufferObject
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|updateBehavior
operator|>
name|NoPartialUpdate
operator|&&
name|d
operator|->
name|fbo
condition|)
return|return
name|d
operator|->
name|fbo
operator|->
name|handle
argument_list|()
return|;
elseif|else
if|if
condition|(
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
condition|)
return|return
name|ctx
operator|->
name|defaultFramebufferObject
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|Q_GUI_EXPORT
name|QImage
name|qt_gl_read_framebuffer
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!   Returns a 32-bit RGB image of the framebuffer.    \note This is a potentially expensive operation because it relies on   glReadPixels() to read back the pixels. This may be slow and can stall the   GPU pipeline.    \note When used together with update behavior \c NoPartialUpdate, the returned   image may not contain the desired content when called after the front and back   buffers have been swapped (unless preserved swap is enabled in the underlying   windowing system interface). In this mode the function reads from the back   buffer and the contents of that may not match the content on the screen (the   front buffer). In this case the only place where this function can safely be   used is paintGL() or paintOverGL().  */
end_comment
begin_function
DECL|function|grabFramebuffer
name|QImage
name|QOpenGLWindow
operator|::
name|grabFramebuffer
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QImage
argument_list|()
return|;
name|makeCurrent
argument_list|()
expr_stmt|;
return|return
name|qt_gl_read_framebuffer
argument_list|(
name|size
argument_list|()
operator|*
name|devicePixelRatio
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This virtual function is called once before the first call to paintGL() or   resizeGL(). Reimplement it in a subclass.    This function should set up any required OpenGL resources and state.    There is no need to call makeCurrent() because this has already been done   when this function is called. Note however that the framebuffer, in case   partial update mode is used, is not yet available at this stage, so avoid   issuing draw calls from here. Defer such calls to paintGL() instead.    \sa paintGL(), resizeGL()  */
end_comment
begin_function
DECL|function|initializeGL
name|void
name|QOpenGLWindow
operator|::
name|initializeGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   This virtual function is called whenever the widget has been resized.   Reimplement it in a subclass. The new size is passed in \a w and \a h.    \note This is merely a convenience function in order to provide an API that is   compatible with QOpenGLWidget. Unlike with QOpenGLWidget, derived classes are   free to choose to override resizeEvent() instead of this function.    \note Avoid issuing OpenGL commands from this function as there may not be a   context current when it is invoked. If it cannot be avoided, call makeCurrent().    \note Scheduling updates from here is not necessary. The windowing systems   will send expose events that trigger an update automatically.    \sa initializeGL(), paintGL()  */
end_comment
begin_function
DECL|function|resizeGL
name|void
name|QOpenGLWindow
operator|::
name|resizeGL
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This virtual function is called whenever the window contents needs to be   painted. Reimplement it in a subclass.    There is no need to call makeCurrent() because this has already   been done when this function is called.    Before invoking this function, the context and the framebuffer, if there is   one, are bound, and the viewport is set up by a call to glViewport(). No   other state is set and no clearing or drawing is performed by the framework.    \note When using a partial update behavior, like \c PartialUpdateBlend, the   output of the previous paintGL() call is preserved and, after the additional   drawing perfomed in the current invocation of the function, the content is   blitted or blended over the content drawn directly to the window in   paintUnderGL().    \sa initializeGL(), resizeGL(), paintUnderGL(), paintOverGL(), UpdateBehavior  */
end_comment
begin_function
DECL|function|paintGL
name|void
name|QOpenGLWindow
operator|::
name|paintGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   The virtual function is called before each invocation of paintGL().    When the update mode is set to \c NoPartialUpdate, there is no difference   between this function and paintGL(), performing rendering in either of them   leads to the same result.    The difference becomes significant when using \c PartialUpdateBlend, where an   extra framebuffer object is used. There, paintGL() targets this additional   framebuffer object, which preserves its contents, while paintUnderGL() and   paintOverGL() target the default framebuffer, i.e. directly the window   surface, the contents of which is lost after each displayed frame.    \note Avoid relying on this function when the update behavior is   \c PartialUpdateBlit. This mode involves blitting the extra framebuffer used by   paintGL() onto the default framebuffer after each invocation of paintGL(),   thus overwriting all drawing generated in this function.    \sa paintGL(), paintOverGL(), UpdateBehavior  */
end_comment
begin_function
DECL|function|paintUnderGL
name|void
name|QOpenGLWindow
operator|::
name|paintUnderGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   This virtual function is called after each invocation of paintGL().    When the update mode is set to NoPartialUpdate, there is no difference   between this function and paintGL(), performing rendering in either of them   leads to the same result.    Like paintUnderGL(), rendering in this function targets the default   framebuffer of the window, regardless of the update behavior. It gets called   after paintGL() has returned and the blit (PartialUpdateBlit) or quad drawing   (PartialUpdateBlend) has been done.    \sa paintGL(), paintUnderGL(), UpdateBehavior  */
end_comment
begin_function
DECL|function|paintOverGL
name|void
name|QOpenGLWindow
operator|::
name|paintOverGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   Paint \a event handler. Calls paintGL().    \sa paintGL()  */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QOpenGLWindow
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|paintGL
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Resize \a event handler. Calls resizeGL().    \sa resizeGL()  */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QOpenGLWindow
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|resizeGL
argument_list|(
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|metric
name|int
name|QOpenGLWindow
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmDepth
case|:
if|if
condition|(
name|d
operator|->
name|paintDevice
condition|)
return|return
name|d
operator|->
name|paintDevice
operator|->
name|depth
argument_list|()
return|;
break|break;
case|case
name|PdmDevicePixelRatio
case|:
if|if
condition|(
name|d
operator|->
name|paintDevice
condition|)
return|return
name|d
operator|->
name|paintDevice
operator|->
name|devicePixelRatio
argument_list|()
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|QPaintDeviceWindow
operator|::
name|metric
argument_list|(
name|metric
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|redirected
name|QPaintDevice
modifier|*
name|QOpenGLWindow
operator|::
name|redirected
parameter_list|(
name|QPoint
modifier|*
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|d
operator|->
name|context
operator|.
name|data
argument_list|()
condition|)
return|return
name|d
operator|->
name|paintDevice
operator|.
name|data
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
