begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindow.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformwindow.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|"qsurfaceformat.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENGL
end_ifndef
begin_include
include|#
directive|include
file|<qpa/qplatformopenglcontext.h>
end_include
begin_include
include|#
directive|include
file|"qopenglcontext.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qscreen.h"
end_include
begin_include
include|#
directive|include
file|"qwindow_p.h"
end_include
begin_include
include|#
directive|include
file|"qguiapplication_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qevent_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|<QStyleHints>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformcursor.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QWindow     \inmodule QtGui     \since 5.0     \brief The QWindow class represents a window in the underlying windowing system.      A window that is supplied a parent becomes a native child window of     their parent window.      An application will typically use QWidget or QQuickView for its UI, and not     QWindow directly. Still, it is possible to render directly to a QWindow     with QBackingStore or QOpenGLContext, when wanting to keep dependencies to     a minimum or when wanting to use OpenGL directly. The     \l{gui/rasterwindow}{Raster Window} and \l{gui/openglwindow}{OpenGL Window}     examples are useful reference examples for how to render to a QWindow using     either approach.      \section1 Resource management      Windows can potentially use a lot of memory. A usual measurement is     width times height times color depth. A window might also include multiple     buffers to support double and triple buffering, as well as depth and stencil     buffers. To release a window's memory resources, call the destroy() function.      \section1 Content orientation      QWindow has reportContentOrientationChange() that can be used to specify     the layout of the window contents in relation to the screen. The content     orientation is simply a hint to the windowing system about which     orientation the window contents are in.  It's useful when you wish to keep     the same window size, but rotate the contents instead, especially when     doing rotation animations between different orientations. The windowing     system might use this value to determine the layout of system popups or     dialogs.      \section1 Visibility and Windowing system exposure.      By default, the window is not visible, and you must call setVisible(true),     or show() or similar to make it visible. To make a window hidden again,     call setVisible(false) or hide(). The visible property describes the state     the application wants the window to be in. Depending on the underlying     system, a visible window might still not be shown on the screen. It could,     for instance, be covered by other opaque windows or moved outside the     physical area of the screen. On windowing systems that have exposure     notifications, the isExposed() accessor describes whether the window should     be treated as directly visible on screen. The exposeEvent() function is     called whenever the windows exposure in the windowing system changes.  On     windowing systems that do not make this information visible to the     application, isExposed() will simply return the same value as isVisible().      \section1 Rendering      There are two Qt APIs that can be used to render content into a window,     QBackingStore for rendering with a QPainter and flushing the contents     to a window with type QSurface::RasterSurface, and QOpenGLContext for     rendering with OpenGL to a window with type QSurface::OpenGLSurface.      The application can start rendering as soon as isExposed() returns true,     and can keep rendering until it isExposed() returns false. To find out when     isExposed() changes, reimplement exposeEvent(). The window will always get     a resize event before the first expose event. */
end_comment
begin_comment
comment|/*!     Creates a window as a top level on the \a targetScreen.      The window is not shown until setVisible(true), show(), or similar is called.      \sa setScreen() */
end_comment
begin_constructor
DECL|function|QWindow
name|QWindow
operator|::
name|QWindow
parameter_list|(
name|QScreen
modifier|*
name|targetScreen
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWindowPrivate
argument_list|()
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|QSurface
argument_list|(
name|QSurface
operator|::
name|Window
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|targetScreen
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
comment|//if your applications aborts here, then chances are your creating a QWindow before the
comment|//screen list is populated.
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|screen
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|screen
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|screenDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a window as a child of the given \a parent window.      The window will be embedded inside the parent window, its coordinates     relative to the parent.      The screen is inherited from the parent.      \sa setParent() */
end_comment
begin_constructor
DECL|function|QWindow
name|QWindow
operator|::
name|QWindow
parameter_list|(
name|QWindow
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWindowPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
member_init_list|,
name|QSurface
argument_list|(
name|QSurface
operator|::
name|Window
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|parentWindow
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|d
operator|->
name|screen
operator|=
name|parent
operator|->
name|screen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|screen
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|screenDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a window as a child of the given \a parent window with the \a dd     private implementation.      The window will be embedded inside the parent window, its coordinates     relative to the parent.      The screen is inherited from the parent.      \internal     \sa setParent() */
end_comment
begin_constructor
DECL|function|QWindow
name|QWindow
operator|::
name|QWindow
parameter_list|(
name|QWindowPrivate
modifier|&
name|dd
parameter_list|,
name|QWindow
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
member_init_list|,
name|QSurface
argument_list|(
name|QSurface
operator|::
name|Window
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|parentWindow
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|d
operator|->
name|screen
operator|=
name|parent
operator|->
name|screen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|screen
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|screenDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the window. */
end_comment
begin_destructor
DECL|function|~QWindow
name|QWindow
operator|::
name|~
name|QWindow
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|==
name|this
condition|)
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
operator|==
name|this
condition|)
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|destroy
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Set the \a surfaceType of the window.      Specifies whether the window is meant for raster rendering with     QBackingStore, or OpenGL rendering with QOpenGLContext.      The surfaceType will be used when the native surface is created     in the create() function. Calling this function after the native     surface has been created requires calling destroy() and create()     to release the old native surface and create a new one.      \sa QBackingStore, QOpenGLContext, create(), destroy() */
end_comment
begin_function
DECL|function|setSurfaceType
name|void
name|QWindow
operator|::
name|setSurfaceType
parameter_list|(
name|SurfaceType
name|surfaceType
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|surfaceType
operator|=
name|surfaceType
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the surface type of the window.      \sa setSurfaceType() */
end_comment
begin_function
DECL|function|surfaceType
name|QWindow
operator|::
name|SurfaceType
name|QWindow
operator|::
name|surfaceType
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|surfaceType
return|;
block|}
end_function
begin_comment
comment|/*!     \property QWindow::visible     \brief whether the window is visible or not      This property controls the visibility of the window in the windowing system.      By default, the window is not visible, you must call setVisible(true), or     show() or similar to make it visible.      \sa show() */
end_comment
begin_function
DECL|function|setVisible
name|void
name|QWindow
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|visible
operator|==
name|visible
condition|)
return|return;
name|d
operator|->
name|visible
operator|=
name|visible
expr_stmt|;
emit|emit
name|visibleChanged
argument_list|(
name|visible
argument_list|)
emit|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
comment|// remove posted quit events when showing a new window
name|QCoreApplication
operator|::
name|removePostedEvents
argument_list|(
name|qApp
argument_list|,
name|QEvent
operator|::
name|Quit
argument_list|)
expr_stmt|;
name|QShowEvent
name|showEvent
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|showEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isModal
argument_list|()
condition|)
block|{
if|if
condition|(
name|visible
condition|)
name|QGuiApplicationPrivate
operator|::
name|showModalWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|QGuiApplicationPrivate
operator|::
name|hideModalWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|visible
condition|)
name|d
operator|->
name|applyCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|platformWindow
operator|->
name|setVisible
argument_list|(
name|visible
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|visible
condition|)
block|{
name|QHideEvent
name|hideEvent
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|hideEvent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isVisible
name|bool
name|QWindow
operator|::
name|isVisible
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|visible
return|;
block|}
end_function
begin_comment
comment|/*!     Allocates the platform resources associated with the window.      It is at this point that the surface format set using setFormat() gets resolved     into an actual native surface. However, the window remains hidden until setVisible() is called.      Note that it is not usually necessary to call this function directly, as it will be implicitly     called by show(), setVisible(), and other functions that require access to the platform     resources.      Call destroy() to free the platform resources if necessary.      \sa destroy() */
end_comment
begin_function
DECL|function|create
name|void
name|QWindow
operator|::
name|create
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QObjectList
name|childObjects
init|=
name|children
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childObjects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QObject
modifier|*
name|object
init|=
name|childObjects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|isWindowType
argument_list|()
condition|)
block|{
name|QWindow
modifier|*
name|window
init|=
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|platformWindow
condition|)
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|platformWindow
operator|->
name|setParent
argument_list|(
name|d
operator|->
name|platformWindow
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the window's platform id.      For platforms where this id might be useful, the value returned     will uniquely represent the window inside the corresponding screen.      \sa screen() */
end_comment
begin_function
DECL|function|winId
name|WId
name|QWindow
operator|::
name|winId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
cast|const_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|create
argument_list|()
expr_stmt|;
name|WId
name|id
init|=
name|d
operator|->
name|platformWindow
operator|->
name|winId
argument_list|()
decl_stmt|;
comment|// See the QPlatformWindow::winId() documentation
name|Q_ASSERT
argument_list|(
name|id
operator|!=
name|WId
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parent window, if any.      A window without a parent is known as a top level window. */
end_comment
begin_function
DECL|function|parent
name|QWindow
modifier|*
name|QWindow
operator|::
name|parent
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|parentWindow
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a parent Window. This will lead to the windowing system managing     the clip of the window, so it will be clipped to the \a parent window.      Setting \a parent to be 0 will make the window become a top level window. */
end_comment
begin_function
DECL|function|setParent
name|void
name|QWindow
operator|::
name|setParent
parameter_list|(
name|QWindow
modifier|*
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setParent
argument_list|(
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|platformWindow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|parentWindow
operator|=
name|parent
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|updateBlockedStatus
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns whether the window is top level, i.e. has no parent window. */
end_comment
begin_function
DECL|function|isTopLevel
name|bool
name|QWindow
operator|::
name|isTopLevel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|parentWindow
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns whether the window is modal.      A modal window prevents other windows from getting any input.      \sa QWindow::modality */
end_comment
begin_function
DECL|function|isModal
name|bool
name|QWindow
operator|::
name|isModal
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|modality
operator|!=
name|Qt
operator|::
name|NonModal
return|;
block|}
end_function
begin_comment
comment|/*! \property QWindow::modality     \brief the modality of the window      A modal window prevents other windows from receiving input events. Qt     supports two types of modality: Qt::WindowModal and Qt::ApplicationModal.      By default, this property is Qt::NonModal      \sa Qt::WindowModality */
end_comment
begin_function
DECL|function|modality
name|Qt
operator|::
name|WindowModality
name|QWindow
operator|::
name|modality
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|modality
return|;
block|}
end_function
begin_function
DECL|function|setModality
name|void
name|QWindow
operator|::
name|setModality
parameter_list|(
name|Qt
operator|::
name|WindowModality
name|modality
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|modality
operator|==
name|modality
condition|)
return|return;
name|d
operator|->
name|modality
operator|=
name|modality
expr_stmt|;
emit|emit
name|modalityChanged
argument_list|(
name|modality
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*! \fn void QWindow::modalityChanged(Qt::WindowModality modality)      This signal is emitted when the Qwindow::modality property changes to \a modality. */
end_comment
begin_comment
comment|/*!     Sets the window's surface \a format.      The format determines properties such as color depth, alpha, depth and     stencil buffer size, etc. For example, to give a window a transparent     background (provided that the window system supports compositing, and     provided that other content in the window does not make it opaque again):      \code     QSurfaceFormat format;     format.setAlphaBufferSize(8);     window.setFormat(format);     \endcode      The surface format will be resolved in the create() function. Calling     this function after create() has been called will not re-resolve the     surface format of the native surface.      \sa create(), destroy() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QWindow
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestedFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the requested surfaceformat of this window.      If the requested format was not supported by the platform implementation,     the requestedFormat will differ from the actual window format.      This is the value set with setFormat().      \sa setFormat(), format()  */
end_comment
begin_function
DECL|function|requestedFormat
name|QSurfaceFormat
name|QWindow
operator|::
name|requestedFormat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|requestedFormat
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the actual format of this window.      After the window has been created, this function will return the actual surface format     of the window. It might differ from the requested format if the requested format could     not be fulfilled by the platform.      \sa create(), requestedFormat() */
end_comment
begin_function
DECL|function|format
name|QSurfaceFormat
name|QWindow
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|format
argument_list|()
return|;
return|return
name|d
operator|->
name|requestedFormat
return|;
block|}
end_function
begin_comment
comment|/*!     \property QWindow::flags     \brief the window flags of the window      The window flags control the window's appearance in the windowing system,     whether it's a dialog, popup, or a regular window, and whether it should     have a title bar, etc.      The actual window flags might differ from the flags set with setFlags()     if the requested flags could not be fulfilled. */
end_comment
begin_function
DECL|function|setFlags
name|void
name|QWindow
operator|::
name|setFlags
parameter_list|(
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|setWindowFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowFlags
operator|=
name|flags
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flags
name|Qt
operator|::
name|WindowFlags
name|QWindow
operator|::
name|flags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowFlags
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of the window.      This returns the part of the window flags that represents     whether the window is a dialog, tooltip, popup, regular window, etc.      \sa flags(), setFlags() */
end_comment
begin_function
DECL|function|type
name|Qt
operator|::
name|WindowType
name|QWindow
operator|::
name|type
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|Qt
operator|::
name|WindowType
argument_list|>
argument_list|(
name|int
argument_list|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|WindowType_Mask
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QWindow::title     \brief the window's title in the windowing system      The window title might appear in the title area of the window decorations,     depending on the windowing system and the window flags. It might also     be used by the windowing system to identify the window in other contexts,     such as in the task switcher.      \sa flags() */
end_comment
begin_function
DECL|function|setTitle
name|void
name|QWindow
operator|::
name|setTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowTitle
operator|=
name|title
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|setWindowTitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|title
name|QString
name|QWindow
operator|::
name|title
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowTitle
return|;
block|}
end_function
begin_comment
comment|/*!     \brief set the file name this window is representing.      The windowing system might use \a filePath to display the     path of the document this window is representing in the tile bar.  */
end_comment
begin_function
DECL|function|setFilePath
name|void
name|QWindow
operator|::
name|setFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowFilePath
operator|=
name|filePath
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|setWindowFilePath
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \brief the file name this window is representing.      \sa setFilePath() */
end_comment
begin_function
DECL|function|filePath
name|QString
name|QWindow
operator|::
name|filePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowFilePath
return|;
block|}
end_function
begin_comment
comment|/*!     \brief set the window's \a icon in the windowing system      The window icon might be used by the windowing system for example to     decorate the window, and/or in the task switcher. */
end_comment
begin_function
DECL|function|setIcon
name|void
name|QWindow
operator|::
name|setIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowIcon
operator|=
name|icon
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|setWindowIcon
argument_list|(
name|icon
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \brief set the window's icon in the windowing system      \sa setIcon() */
end_comment
begin_function
DECL|function|icon
name|QIcon
name|QWindow
operator|::
name|icon
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowIcon
return|;
block|}
end_function
begin_comment
comment|/*!     Raise the window in the windowing system.      Requests that the window be raised to appear above other windows. */
end_comment
begin_function
DECL|function|raise
name|void
name|QWindow
operator|::
name|raise
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Lower the window in the windowing system.      Requests that the window be lowered to appear below other windows. */
end_comment
begin_function
DECL|function|lower
name|void
name|QWindow
operator|::
name|lower
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|lower
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the window's opacity in the windowing system to \a level.      If the windowing system supports window opacity, this can be used to fade the     window in and out, or to make it semitransparent.      A value of 1.0 or above is treated as fully opaque, whereas a value of 0.0 or below     is treated as fully transparent. Values inbetween represent varying levels of     translucency between the two extremes. */
end_comment
begin_function
DECL|function|setOpacity
name|void
name|QWindow
operator|::
name|setOpacity
parameter_list|(
name|qreal
name|level
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setOpacity
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Requests the window to be activated, i.e. receive keyboard focus.      \sa isActive(), QGuiApplication::focusWindow() */
end_comment
begin_function
DECL|function|requestActivate
name|void
name|QWindow
operator|::
name|requestActivate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|requestActivateWindow
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns if this window is exposed in the windowing system.      When the window is not exposed, it is shown by the application     but it is still not showing in the windowing system, so the application     should minimize rendering and other graphical activities.      An exposeEvent() is sent every time this value changes.      \sa exposeEvent() */
end_comment
begin_function
DECL|function|isExposed
name|bool
name|QWindow
operator|::
name|isExposed
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exposed
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the window should appear active from a style perspective.      This is the case for the window that has input focus as well as windows     that are in the same parent / transient parent chain as the focus window.      To get the window that currently has focus, use QGuiApplication::focusWindow(). */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QWindow
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
return|return
literal|false
return|;
name|QWindow
modifier|*
name|focus
init|=
name|QGuiApplication
operator|::
name|focusWindow
argument_list|()
decl_stmt|;
comment|// Means the whole application lost the focus
if|if
condition|(
operator|!
name|focus
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|focus
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|parent
argument_list|()
operator|&&
operator|!
name|transientParent
argument_list|()
condition|)
block|{
return|return
name|isAncestorOf
argument_list|(
name|focus
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|parent
argument_list|()
operator|&&
name|parent
argument_list|()
operator|->
name|isActive
argument_list|()
operator|)
operator|||
operator|(
name|transientParent
argument_list|()
operator|&&
name|transientParent
argument_list|()
operator|->
name|isActive
argument_list|()
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QWindow::contentOrientation     \brief the orientation of the window's contents      This is a hint to the window manager in case it needs to display     additional content like popups, dialogs, status bars, or similar     in relation to the window.      The recommended orientation is QScreen::orientation() but     an application doesn't have to support all possible orientations,     and thus can opt to ignore the current screen orientation.      The difference between the window and the content orientation     determines how much to rotate the content by. QScreen::angleBetween(),     QScreen::transformBetween(), and QScreen::mapBetween() can be used     to compute the necessary transform.      The default value is Qt::PrimaryOrientation */
end_comment
begin_function
DECL|function|reportContentOrientationChange
name|void
name|QWindow
operator|::
name|reportContentOrientationChange
parameter_list|(
name|Qt
operator|::
name|ScreenOrientation
name|orientation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|contentOrientation
operator|==
name|orientation
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|platformWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|contentOrientation
operator|=
name|orientation
expr_stmt|;
name|d
operator|->
name|platformWindow
operator|->
name|handleContentOrientationChange
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
emit|emit
name|contentOrientationChanged
argument_list|(
name|orientation
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|contentOrientation
name|Qt
operator|::
name|ScreenOrientation
name|QWindow
operator|::
name|contentOrientation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|contentOrientation
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the ratio between physical pixels and device-independent pixels     for the window. This value is dependent on the screen the window is on,     and may change when the window is moved.      Common values are 1.0 on normal displays and 2.0 on Apple "retina" displays.      \sa QWindow::devicePixelRatio();     \sa QGuiApplicaiton::devicePixelRatio(); */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QWindow
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformWindow
condition|)
return|return
literal|1.0
return|;
return|return
name|d
operator|->
name|platformWindow
operator|->
name|devicePixelRatio
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \brief set the screen-occupation state of the window      The window \a state represents whether the window appears in the     windowing system as maximized, minimized, fullscreen, or normal.      The enum value Qt::WindowActive is not an accepted parameter.      \sa showNormal(), showFullScreen(), showMinimized(), showMaximized() */
end_comment
begin_function
DECL|function|setWindowState
name|void
name|QWindow
operator|::
name|setWindowState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|Qt
operator|::
name|WindowActive
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QWindow::setWindowState does not accept Qt::WindowActive"
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|setWindowState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowState
operator|=
name|state
expr_stmt|;
emit|emit
name|windowStateChanged
argument_list|(
name|d
operator|->
name|windowState
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \brief the screen-occupation state of the window      \sa setWindowState() */
end_comment
begin_function
DECL|function|windowState
name|Qt
operator|::
name|WindowState
name|QWindow
operator|::
name|windowState
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowState
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QWindow::windowStateChanged(Qt::WindowState windowState)      This signal is emitted when the \a windowState changes, either     by being set explicitly with setWindowState(), or automatically when     the user clicks one of the titlebar buttons or by other means. */
end_comment
begin_comment
comment|/*!     Sets the transient \a parent      This is a hint to the window manager that this window is a dialog or pop-up     on behalf of the given window.      \sa transientParent(), parent() */
end_comment
begin_function
DECL|function|setTransientParent
name|void
name|QWindow
operator|::
name|setTransientParent
parameter_list|(
name|QWindow
modifier|*
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|transientParent
operator|=
name|parent
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|updateBlockedStatus
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the transient parent of the window.      \sa setTransientParent(), parent() */
end_comment
begin_function
DECL|function|transientParent
name|QWindow
modifier|*
name|QWindow
operator|::
name|transientParent
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|transientParent
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QWindow::AncestorMode      This enum is used to control whether or not transient parents     should be considered ancestors.      \value ExcludeTransients Transient parents are not considered ancestors.     \value IncludeTransients Transient parents are considered ancestors. */
end_comment
begin_comment
comment|/*!     Returns true if the window is an ancestor of the given \a child. If \a mode     is IncludeTransients, then transient parents are also considered ancestors. */
end_comment
begin_function
DECL|function|isAncestorOf
name|bool
name|QWindow
operator|::
name|isAncestorOf
parameter_list|(
specifier|const
name|QWindow
modifier|*
name|child
parameter_list|,
name|AncestorMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|child
operator|->
name|parent
argument_list|()
operator|==
name|this
operator|||
operator|(
name|mode
operator|==
name|IncludeTransients
operator|&&
name|child
operator|->
name|transientParent
argument_list|()
operator|==
name|this
operator|)
condition|)
return|return
literal|true
return|;
return|return
operator|(
name|child
operator|->
name|parent
argument_list|()
operator|&&
name|isAncestorOf
argument_list|(
name|child
operator|->
name|parent
argument_list|()
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|mode
operator|==
name|IncludeTransients
operator|&&
name|child
operator|->
name|transientParent
argument_list|()
operator|&&
name|isAncestorOf
argument_list|(
name|child
operator|->
name|transientParent
argument_list|()
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum size of the window.      \sa setMinimumSize() */
end_comment
begin_function
DECL|function|minimumSize
name|QSize
name|QWindow
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minimumSize
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum size of the window.      \sa setMaximumSize() */
end_comment
begin_function
DECL|function|maximumSize
name|QSize
name|QWindow
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maximumSize
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the base size of the window.      \sa setBaseSize() */
end_comment
begin_function
DECL|function|baseSize
name|QSize
name|QWindow
operator|::
name|baseSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|baseSize
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size increment of the window.      \sa setSizeIncrement() */
end_comment
begin_function
DECL|function|sizeIncrement
name|QSize
name|QWindow
operator|::
name|sizeIncrement
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sizeIncrement
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the minimum size of the window.      This is a hint to the window manager to prevent resizing below the specified \a size.      \sa setMaximumSize(), minimumSize() */
end_comment
begin_function
DECL|function|setMinimumSize
name|void
name|QWindow
operator|::
name|setMinimumSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|QSize
name|adjustedSize
init|=
name|QSize
argument_list|(
name|qBound
argument_list|(
literal|0
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|QWINDOWSIZE_MAX
argument_list|)
argument_list|,
name|qBound
argument_list|(
literal|0
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|QWINDOWSIZE_MAX
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|minimumSize
operator|==
name|adjustedSize
condition|)
return|return;
name|QSize
name|oldSize
init|=
name|d
operator|->
name|minimumSize
decl_stmt|;
name|d
operator|->
name|minimumSize
operator|=
name|adjustedSize
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|isTopLevel
argument_list|()
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|propagateSizeHints
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|minimumSize
operator|.
name|width
argument_list|()
operator|!=
name|oldSize
operator|.
name|width
argument_list|()
condition|)
emit|emit
name|minimumWidthChanged
argument_list|(
name|d
operator|->
name|minimumSize
operator|.
name|width
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|minimumSize
operator|.
name|height
argument_list|()
operator|!=
name|oldSize
operator|.
name|height
argument_list|()
condition|)
emit|emit
name|minimumHeightChanged
argument_list|(
name|d
operator|->
name|minimumSize
operator|.
name|height
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|setMinimumWidth
name|void
name|QWindow
operator|::
name|setMinimumWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|setMinimumSize
argument_list|(
name|QSize
argument_list|(
name|w
argument_list|,
name|minimumHeight
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMinimumHeight
name|void
name|QWindow
operator|::
name|setMinimumHeight
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|setMinimumSize
argument_list|(
name|QSize
argument_list|(
name|minimumWidth
argument_list|()
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the maximum size of the window.      This is a hint to the window manager to prevent resizing above the specified \a size.      \sa setMinimumSize(), maximumSize() */
end_comment
begin_function
DECL|function|setMaximumSize
name|void
name|QWindow
operator|::
name|setMaximumSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|QSize
name|adjustedSize
init|=
name|QSize
argument_list|(
name|qBound
argument_list|(
literal|0
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|QWINDOWSIZE_MAX
argument_list|)
argument_list|,
name|qBound
argument_list|(
literal|0
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|QWINDOWSIZE_MAX
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|maximumSize
operator|==
name|adjustedSize
condition|)
return|return;
name|QSize
name|oldSize
init|=
name|d
operator|->
name|maximumSize
decl_stmt|;
name|d
operator|->
name|maximumSize
operator|=
name|adjustedSize
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|isTopLevel
argument_list|()
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|propagateSizeHints
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|maximumSize
operator|.
name|width
argument_list|()
operator|!=
name|oldSize
operator|.
name|width
argument_list|()
condition|)
emit|emit
name|maximumWidthChanged
argument_list|(
name|d
operator|->
name|maximumSize
operator|.
name|width
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|maximumSize
operator|.
name|height
argument_list|()
operator|!=
name|oldSize
operator|.
name|height
argument_list|()
condition|)
emit|emit
name|maximumHeightChanged
argument_list|(
name|d
operator|->
name|maximumSize
operator|.
name|height
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|setMaximumWidth
name|void
name|QWindow
operator|::
name|setMaximumWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|setMaximumSize
argument_list|(
name|QSize
argument_list|(
name|w
argument_list|,
name|maximumHeight
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMaximumHeight
name|void
name|QWindow
operator|::
name|setMaximumHeight
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|setMaximumSize
argument_list|(
name|QSize
argument_list|(
name|maximumWidth
argument_list|()
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the base \a size of the window.      The base size is used to calculate a proper window size if the     window defines sizeIncrement().      \sa setMinimumSize(), setMaximumSize(), setSizeIncrement(), baseSize() */
end_comment
begin_function
DECL|function|setBaseSize
name|void
name|QWindow
operator|::
name|setBaseSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|baseSize
operator|==
name|size
condition|)
return|return;
name|d
operator|->
name|baseSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|isTopLevel
argument_list|()
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|propagateSizeHints
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the size increment (\a size) of the window.      When the user resizes the window, the size will move in steps of     sizeIncrement().width() pixels horizontally and     sizeIncrement().height() pixels vertically, with baseSize() as the     basis.      By default, this property contains a size with zero width and height.      The windowing system might not support size increments.      \sa setBaseSize(), setMinimumSize(), setMaximumSize() */
end_comment
begin_function
DECL|function|setSizeIncrement
name|void
name|QWindow
operator|::
name|setSizeIncrement
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sizeIncrement
operator|==
name|size
condition|)
return|return;
name|d
operator|->
name|sizeIncrement
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|isTopLevel
argument_list|()
condition|)
name|d
operator|->
name|platformWindow
operator|->
name|propagateSizeHints
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWindow::setGeometry(int posx, int posy, int w, int h)      Sets the geometry of the window, excluding its window frame, to a     rectangle constructed from \a posx, \a posy, \a w and \a h.      \sa geometry() */
end_comment
begin_comment
comment|/*!     \brief Sets the geometry of the window, excluding its window frame, to \a rect.      \sa geometry() */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QWindow
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rect
operator|==
name|geometry
argument_list|()
condition|)
return|return;
name|QRect
name|oldRect
init|=
name|geometry
argument_list|()
decl_stmt|;
name|d
operator|->
name|positionPolicy
operator|=
name|QWindowPrivate
operator|::
name|WindowFrameExclusive
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|geometry
operator|=
name|rect
expr_stmt|;
block|}
if|if
condition|(
name|rect
operator|.
name|x
argument_list|()
operator|!=
name|oldRect
operator|.
name|x
argument_list|()
condition|)
emit|emit
name|xChanged
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|rect
operator|.
name|y
argument_list|()
operator|!=
name|oldRect
operator|.
name|y
argument_list|()
condition|)
emit|emit
name|yChanged
argument_list|(
name|rect
operator|.
name|y
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|rect
operator|.
name|width
argument_list|()
operator|!=
name|oldRect
operator|.
name|width
argument_list|()
condition|)
emit|emit
name|widthChanged
argument_list|(
name|rect
operator|.
name|width
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|rect
operator|.
name|height
argument_list|()
operator|!=
name|oldRect
operator|.
name|height
argument_list|()
condition|)
emit|emit
name|heightChanged
argument_list|(
name|rect
operator|.
name|height
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QWindow::x     \brief the x position of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::y     \brief the y position of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::width     \brief the width of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::height     \brief the height of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::minimumWidth     \brief the minimum width of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::minimumHeight     \brief the minimum height of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::maximumWidth     \brief the maximum width of the window's geometry */
end_comment
begin_comment
comment|/*!     \property QWindow::maximumHeight     \brief the maximum height of the window's geometry */
end_comment
begin_comment
comment|/*!     Returns the geometry of the window, excluding its window frame.      \sa frameMargins(), frameGeometry() */
end_comment
begin_function
DECL|function|geometry
name|QRect
name|QWindow
operator|::
name|geometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|geometry
argument_list|()
return|;
return|return
name|d
operator|->
name|geometry
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the window frame margins surrounding the window.      \sa geometry(), frameGeometry() */
end_comment
begin_function
DECL|function|frameMargins
name|QMargins
name|QWindow
operator|::
name|frameMargins
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|frameMargins
argument_list|()
return|;
return|return
name|QMargins
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the geometry of the window, including its window frame.      \sa geometry(), frameMargins() */
end_comment
begin_function
DECL|function|frameGeometry
name|QRect
name|QWindow
operator|::
name|frameGeometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|QMargins
name|m
init|=
name|frameMargins
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|platformWindow
operator|->
name|geometry
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
name|m
operator|.
name|left
argument_list|()
argument_list|,
operator|-
name|m
operator|.
name|top
argument_list|()
argument_list|,
name|m
operator|.
name|right
argument_list|()
argument_list|,
name|m
operator|.
name|bottom
argument_list|()
argument_list|)
return|;
block|}
return|return
name|d
operator|->
name|geometry
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the top left position of the window, including its window frame.      This returns the same value as frameGeometry().topLeft().      \sa geometry(), frameGeometry() */
end_comment
begin_function
DECL|function|framePosition
name|QPoint
name|QWindow
operator|::
name|framePosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|QMargins
name|margins
init|=
name|frameMargins
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|platformWindow
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
operator|-
name|QPoint
argument_list|(
name|margins
operator|.
name|left
argument_list|()
argument_list|,
name|margins
operator|.
name|top
argument_list|()
argument_list|)
return|;
block|}
return|return
name|d
operator|->
name|geometry
operator|.
name|topLeft
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the upper left position of the window (\a point) including its window frame.      \sa setGeometry(), frameGeometry() */
end_comment
begin_function
DECL|function|setFramePosition
name|void
name|QWindow
operator|::
name|setFramePosition
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|positionPolicy
operator|=
name|QWindowPrivate
operator|::
name|WindowFrameInclusive
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setGeometry
argument_list|(
name|QRect
argument_list|(
name|point
argument_list|,
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|geometry
operator|.
name|setTopLeft
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QWindow::setPosition(const QPoint&pt)     \brief set the position of the window on the desktop to \a pt      \sa position() */
end_comment
begin_comment
comment|/*!     \fn void QWindow::setPosition(int posx, int posy)     \brief set the position of the window on the desktop to \a posx, \a posy      \sa position() */
end_comment
begin_comment
comment|/*!     \fn QPoint QWindow::position() const     \brief get the position of the window on the desktop excluding any window frame      \sa setPosition() */
end_comment
begin_comment
comment|/*!     \fn QSize QWindow::size() const     \brief get the size of the window excluding any window frame      \sa resize() */
end_comment
begin_comment
comment|/*!     \fn void QWindow::resize(int w, int h)      set the size of the window, excluding any window frame, to a QSize     constructed from width \a w and height \a h      \sa size(), geometry() */
end_comment
begin_comment
comment|/*!     \brief set the size of the window, excluding any window frame, to \a newSize      \sa size(), geometry() */
end_comment
begin_function
DECL|function|resize
name|void
name|QWindow
operator|::
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|newSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
block|{
name|d
operator|->
name|platformWindow
operator|->
name|setGeometry
argument_list|(
name|QRect
argument_list|(
name|position
argument_list|()
argument_list|,
name|newSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|geometry
operator|.
name|setSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Releases the native platform resources associated with this window.      \sa create() */
end_comment
begin_function
DECL|function|destroy
name|void
name|QWindow
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|QObjectList
name|childrenWindows
init|=
name|children
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childrenWindows
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QObject
modifier|*
name|object
init|=
name|childrenWindows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|isWindowType
argument_list|()
condition|)
block|{
name|QWindow
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|removeAll
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|destroy
argument_list|()
expr_stmt|;
block|}
block|}
name|setVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|platformWindow
expr_stmt|;
name|d
operator|->
name|resizeEventPending
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|receivedExpose
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|exposed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|platformWindow
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the platform window corresponding to the window.      \internal */
end_comment
begin_function
DECL|function|handle
name|QPlatformWindow
modifier|*
name|QWindow
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformWindow
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the platform surface corresponding to the window.      \internal */
end_comment
begin_function
DECL|function|surfaceHandle
name|QPlatformSurface
modifier|*
name|QWindow
operator|::
name|surfaceHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformWindow
return|;
block|}
end_function
begin_comment
comment|/*!     Set whether keyboard grab should be enabled or not (\a grab).      If the return value is true, the window receives all key events until     setKeyboardGrabEnabled(false) is called; other windows get no key events at     all. Mouse events are not affected. Use setMouseGrabEnabled() if you want     to grab that.      \sa setMouseGrabEnabled() */
end_comment
begin_function
DECL|function|setKeyboardGrabEnabled
name|bool
name|QWindow
operator|::
name|setKeyboardGrabEnabled
parameter_list|(
name|bool
name|grab
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab
operator|&&
name|QGuiApplicationPrivate
operator|::
name|noGrab
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|setKeyboardGrabEnabled
argument_list|(
name|grab
argument_list|)
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether mouse grab should be enabled or not (\a grab).      If the return value is true, the window receives all mouse events until setMouseGrabEnabled(false) is     called; other windows get no mouse events at all. Keyboard events are not affected.     Use setKeyboardGrabEnabled() if you want to grab that.      \sa setKeyboardGrabEnabled() */
end_comment
begin_function
DECL|function|setMouseGrabEnabled
name|bool
name|QWindow
operator|::
name|setMouseGrabEnabled
parameter_list|(
name|bool
name|grab
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|grab
operator|&&
name|QGuiApplicationPrivate
operator|::
name|noGrab
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|platformWindow
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|setMouseGrabEnabled
argument_list|(
name|grab
argument_list|)
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the screen on which the window is shown.      The value returned will not change when the window is moved     between virtual screens (as returned by QScreen::virtualSiblings()).      \sa setScreen(), QScreen::virtualSiblings() */
end_comment
begin_function
DECL|function|screen
name|QScreen
modifier|*
name|QWindow
operator|::
name|screen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|screen
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the screen on which the window should be shown.      If the window has been created, it will be recreated on the \a newScreen.      Note that if the screen is part of a virtual desktop of multiple screens,     the window can appear on any of the screens returned by QScreen::virtualSiblings().      \sa screen(), QScreen::virtualSiblings() */
end_comment
begin_function
DECL|function|setScreen
name|void
name|QWindow
operator|::
name|setScreen
parameter_list|(
name|QScreen
modifier|*
name|newScreen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newScreen
condition|)
name|newScreen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|newScreen
operator|!=
name|screen
argument_list|()
condition|)
block|{
specifier|const
name|bool
name|wasCreated
init|=
name|d
operator|->
name|platformWindow
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|wasCreated
condition|)
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|screen
condition|)
name|disconnect
argument_list|(
name|d
operator|->
name|screen
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|screenDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|newScreen
expr_stmt|;
if|if
condition|(
name|newScreen
condition|)
block|{
name|connect
argument_list|(
name|d
operator|->
name|screen
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|screenDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasCreated
condition|)
name|create
argument_list|()
expr_stmt|;
block|}
emit|emit
name|screenChanged
argument_list|(
name|newScreen
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|screenDestroyed
name|void
name|QWindow
operator|::
name|screenDestroyed
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|screen
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|wasVisible
init|=
name|isVisible
argument_list|()
decl_stmt|;
name|setScreen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// destroy() might have hidden our window, show it again.
comment|// This might not be the best behavior if the new screen isn't a virtual sibling
comment|// of the old one. This can be removed once platform plugins have the power to
comment|// update the QScreen of its QWindows itself.
if|if
condition|(
name|wasVisible
operator|&&
name|d
operator|->
name|platformWindow
condition|)
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QWindow::screenChanged(QScreen *screen)      This signal is emitted when a window's \a screen changes, either     by being set explicitly with setScreen(), or automatically when     the window's screen is removed. */
end_comment
begin_comment
comment|/*!   Returns the accessibility interface for the object that the window represents   \internal   \sa QAccessible   */
end_comment
begin_function
DECL|function|accessibleRoot
name|QAccessibleInterface
modifier|*
name|QWindow
operator|::
name|accessibleRoot
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QWindow::focusObjectChanged(QObject *focusObject)      This signal is emitted when final receiver of events tied to focus is     changed to \a focusObject.      \sa focusObject() */
end_comment
begin_comment
comment|/*!     Returns the QObject that will be the final receiver of events tied focus, such     as key events. */
end_comment
begin_function
DECL|function|focusObject
name|QObject
modifier|*
name|QWindow
operator|::
name|focusObject
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Shows the window.      This equivalent to calling showFullScreen() or showNormal(), depending     on whether the platform defaults to windows being fullscreen or not.      \sa showFullScreen(), showNormal(), hide(), QStyleHints::showIsFullScreen() */
end_comment
begin_function
DECL|function|show
name|void
name|QWindow
operator|::
name|show
parameter_list|()
block|{
if|if
condition|(
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|showIsFullScreen
argument_list|()
condition|)
name|showFullScreen
argument_list|()
expr_stmt|;
else|else
name|showNormal
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Hides the window.      Equivalent to calling setVisible(false).      \sa show(), setVisible() */
end_comment
begin_function
DECL|function|hide
name|void
name|QWindow
operator|::
name|hide
parameter_list|()
block|{
name|setVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shows the window as minimized.      Equivalent to calling setWindowState(Qt::WindowMinimized) and then     setVisible(true).      \sa setWindowState(), setVisible() */
end_comment
begin_function
DECL|function|showMinimized
name|void
name|QWindow
operator|::
name|showMinimized
parameter_list|()
block|{
name|setWindowState
argument_list|(
name|Qt
operator|::
name|WindowMinimized
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shows the window as maximized.      Equivalent to calling setWindowState(Qt::WindowMaximized) and then     setVisible(true).      \sa setWindowState(), setVisible() */
end_comment
begin_function
DECL|function|showMaximized
name|void
name|QWindow
operator|::
name|showMaximized
parameter_list|()
block|{
name|setWindowState
argument_list|(
name|Qt
operator|::
name|WindowMaximized
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shows the window as fullscreen.      Equivalent to calling setWindowState(Qt::WindowFullScreen) and then     setVisible(true).      \sa setWindowState(), setVisible() */
end_comment
begin_function
DECL|function|showFullScreen
name|void
name|QWindow
operator|::
name|showFullScreen
parameter_list|()
block|{
name|setWindowState
argument_list|(
name|Qt
operator|::
name|WindowFullScreen
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|requestActivate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shows the window as normal, i.e. neither maximized, minimized, nor fullscreen.      Equivalent to calling setWindowState(Qt::WindowNoState) and then     setVisible(true).      \sa setWindowState(), setVisible() */
end_comment
begin_function
DECL|function|showNormal
name|void
name|QWindow
operator|::
name|showNormal
parameter_list|()
block|{
name|setWindowState
argument_list|(
name|Qt
operator|::
name|WindowNoState
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Close the window.      This closes the window, effectively calling destroy(), and potentially     quitting the application. Returns true on success, false if it has a parent     window (in which case the top level window should be closed instead).      \sa destroy(), QGuiApplication::quitOnLastWindowClosed() */
end_comment
begin_function
DECL|function|close
name|bool
name|QWindow
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
comment|// Do not close non top level windows
if|if
condition|(
name|parent
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|==
name|this
condition|)
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
operator|==
name|this
condition|)
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|window_list
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|destroy
argument_list|()
expr_stmt|;
name|d
operator|->
name|maybeQuitOnLastWindowClosed
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     The expose event (\a ev) is sent by the window system whenever the window's     exposure on screen changes.      The application can start rendering into the window with QBackingStore     and QOpenGLContext as soon as it gets an exposeEvent() such that     isExposed() is true.      If the window is moved off screen, is made totally obscured by another     window, iconified or similar, this function might be called and the     value of isExposed() might change to false. When this happens,     an application should stop its rendering as it is no longer visible     to the user.      A resize event will always be sent before the expose event the first time     a window is shown.      \sa isExposed() */
end_comment
begin_function
DECL|function|exposeEvent
name|void
name|QWindow
operator|::
name|exposeEvent
parameter_list|(
name|QExposeEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle mouse events (\a ev). */
end_comment
begin_function
DECL|function|moveEvent
name|void
name|QWindow
operator|::
name|moveEvent
parameter_list|(
name|QMoveEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle resize events (\a ev).      The resize event is called whenever the window is resized in the windowing system,     either directly through the windowing system acknowledging a setGeometry() or resize() request,     or indirectly through the user resizing the window manually. */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QWindow
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle show events (\a ev).      The function is called when the window has requested becoming visible.      If the window is successfully shown by the windowing system, this will     be followed by a resize and an expose event. */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QWindow
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle hide events (\a ev).      The function is called when the window has requested being hidden in the     windowing system. */
end_comment
begin_function
DECL|function|hideEvent
name|void
name|QWindow
operator|::
name|hideEvent
parameter_list|(
name|QHideEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle any event (\a ev) sent to the window.     Return \c true if the event was recognized and processed.      Remember to call the base class version if you wish for mouse events,     key events, resize events, etc to be dispatched as usual. */
end_comment
begin_function
DECL|function|event
name|bool
name|QWindow
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
switch|switch
condition|(
name|ev
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseMove
case|:
name|mouseMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
name|mousePressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
name|mouseReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
name|mouseDoubleClickEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
case|case
name|QEvent
operator|::
name|TouchCancel
case|:
name|touchEvent
argument_list|(
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Move
case|:
name|moveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMoveEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Resize
case|:
name|resizeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QResizeEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|KeyPress
case|:
name|keyPressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|keyReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusIn
case|:
block|{
name|focusInEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|State
name|state
decl_stmt|;
name|state
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|QAccessibleStateChangeEvent
name|event
argument_list|(
name|this
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|QEvent
operator|::
name|FocusOut
case|:
block|{
name|focusOutEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|State
name|state
decl_stmt|;
name|state
operator|.
name|active
operator|=
literal|true
expr_stmt|;
name|QAccessibleStateChangeEvent
name|event
argument_list|(
name|this
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
name|wheelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWheelEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|Close
case|:
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|bool
name|wasVisible
init|=
name|isVisible
argument_list|()
decl_stmt|;
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|wasVisible
condition|)
name|d
operator|->
name|maybeQuitOnLastWindowClosed
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|Expose
case|:
name|exposeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QExposeEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
name|showEvent
argument_list|(
cast|static_cast
argument_list|<
name|QShowEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
name|hideEvent
argument_list|(
cast|static_cast
argument_list|<
name|QHideEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowStateChange
case|:
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
emit|emit
name|windowStateChanged
argument_list|(
name|d
operator|->
name|windowState
argument_list|)
emit|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
name|tabletEvent
argument_list|(
cast|static_cast
argument_list|<
name|QTabletEvent
operator|*
argument_list|>
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|QObject
operator|::
name|event
argument_list|(
name|ev
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle key press events (\a ev).      \sa keyReleaseEvent() */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QWindow
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle key release events (\a ev).      \sa keyPressEvent() */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QWindow
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle focus in events (\a ev).      Focus in events are sent when the window receives keyboard focus.      \sa focusOutEvent() */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QWindow
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle focus out events (\a ev).      Focus out events are sent when the window loses keyboard focus.      \sa focusInEvent() */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QWindow
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle mouse press events (\a ev).      \sa mouseReleaseEvent() */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QWindow
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle mouse release events (\a ev).      \sa mousePressEvent() */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QWindow
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle mouse double click events (\a ev).      \sa mousePressEvent(), QStyleHints::mouseDoubleClickInterval() */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QWindow
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Override this to handle mouse move events (\a ev). */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QWindow
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_comment
comment|/*!     Override this to handle mouse wheel or other wheel events (\a ev). */
end_comment
begin_function
DECL|function|wheelEvent
name|void
name|QWindow
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_WHEELEVENT
end_comment
begin_comment
comment|/*!     Override this to handle touch events (\a ev). */
end_comment
begin_function
DECL|function|touchEvent
name|void
name|QWindow
operator|::
name|touchEvent
parameter_list|(
name|QTouchEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
end_ifndef
begin_comment
comment|/*!     Override this to handle tablet press, move, and release events (\a ev).      Proximity enter and leave events are not sent to windows, they are     delivered to the application instance. */
end_comment
begin_function
DECL|function|tabletEvent
name|void
name|QWindow
operator|::
name|tabletEvent
parameter_list|(
name|QTabletEvent
modifier|*
name|ev
parameter_list|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Override this to handle platform dependent events.     Will be given \a eventType, \a message and \a result.      This might make your application non-portable.      Should return true only if the event was handled. */
end_comment
begin_function
DECL|function|nativeEvent
name|bool
name|QWindow
operator|::
name|nativeEvent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|eventType
parameter_list|,
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|eventType
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QWindow::mapToGlobal(const QPoint&pos) const      Translates the window coordinate \a pos to global screen     coordinates. For example, \c{mapToGlobal(QPoint(0,0))} would give     the global coordinates of the top-left pixel of the window.      \sa mapFromGlobal() */
end_comment
begin_function
DECL|function|mapToGlobal
name|QPoint
name|QWindow
operator|::
name|mapToGlobal
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|d
operator|->
name|platformWindow
operator|->
name|isEmbedded
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|mapToGlobal
argument_list|(
name|pos
argument_list|)
return|;
else|else
return|return
name|pos
operator|+
name|d_func
argument_list|()
operator|->
name|globalPosition
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QWindow::mapFromGlobal(const QPoint&pos) const      Translates the global screen coordinate \a pos to window     coordinates.      \sa mapToGlobal() */
end_comment
begin_function
DECL|function|mapFromGlobal
name|QPoint
name|QWindow
operator|::
name|mapFromGlobal
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformWindow
operator|&&
name|d
operator|->
name|platformWindow
operator|->
name|isEmbedded
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|d
operator|->
name|platformWindow
operator|->
name|mapFromGlobal
argument_list|(
name|pos
argument_list|)
return|;
else|else
return|return
name|pos
operator|-
name|d_func
argument_list|()
operator|->
name|globalPosition
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qt_window_private
name|Q_GUI_EXPORT
name|QWindowPrivate
modifier|*
name|qt_window_private
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
return|return
name|window
operator|->
name|d_func
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|maybeQuitOnLastWindowClosed
name|void
name|QWindowPrivate
operator|::
name|maybeQuitOnLastWindowClosed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
comment|// Attempt to close the application only if this has WA_QuitOnClose set and a non-visible parent
name|bool
name|quitOnClose
init|=
name|QGuiApplication
operator|::
name|quitOnLastWindowClosed
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|quitOnClose
condition|)
block|{
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
name|bool
name|lastWindowClosed
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|isVisible
argument_list|()
operator|||
name|w
operator|->
name|transientParent
argument_list|()
condition|)
continue|continue;
name|lastWindowClosed
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lastWindowClosed
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|emitLastWindowClosed
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
modifier|*
name|applicationPrivate
init|=
cast|static_cast
argument_list|<
name|QCoreApplicationPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|applicationPrivate
operator|->
name|maybeQuit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_comment
comment|/*!     \brief set the cursor shape for this window      The mouse \a cursor will assume this shape when it is over this     window, unless an override cursor is set.     See the \l{Qt::CursorShape}{list of predefined cursor objects} for a     range of useful shapes.      By default, the cursor has the Qt::ArrowCursor shape.      Some underlying window implementations will reset the cursor if it     leaves a window even if the mouse is grabbed. If you want to have     a cursor set for all windows, even when outside the window, consider     QGuiApplication::setOverrideCursor().      \sa QGuiApplication::setOverrideCursor() */
end_comment
begin_function
DECL|function|setCursor
name|void
name|QWindow
operator|::
name|setCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|cursor
operator|=
name|cursor
expr_stmt|;
comment|// Only attempt to set cursor and emit signal if there is an actual platform cursor
if|if
condition|(
name|d
operator|->
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
block|{
name|d
operator|->
name|applyCursor
argument_list|()
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|CursorChange
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \brief Restores the default arrow cursor for this window.  */
end_comment
begin_function
DECL|function|unsetCursor
name|void
name|QWindow
operator|::
name|unsetCursor
parameter_list|()
block|{
name|setCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \brief the cursor shape for this window      \sa setCursor(), unsetCursor() */
end_comment
begin_function
DECL|function|cursor
name|QCursor
name|QWindow
operator|::
name|cursor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cursor
return|;
block|}
end_function
begin_function
DECL|function|applyCursor
name|void
name|QWindowPrivate
operator|::
name|applyCursor
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|platformWindow
condition|)
block|{
if|if
condition|(
name|QPlatformCursor
modifier|*
name|platformCursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
block|{
name|QCursor
modifier|*
name|oc
init|=
name|QGuiApplication
operator|::
name|overrideCursor
argument_list|()
decl_stmt|;
name|QCursor
name|c
init|=
name|oc
condition|?
operator|*
name|oc
else|:
name|cursor
decl_stmt|;
name|platformCursor
operator|->
name|changeCursor
argument_list|(
operator|&
name|c
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CURSOR
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
