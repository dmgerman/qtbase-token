begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qguiapplication.h"
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegrationfactory_p.h>
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"qfont.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformfontdatabase.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformwindow.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformnativeinterface.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformtheme.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformdrag.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QAbstractEventDispatcher>
end_include
begin_include
include|#
directive|include
file|<QtCore/QVariant>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qcoreapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qabstracteventdispatcher_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtDebug>
end_include
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_include
include|#
directive|include
file|<qpalette.h>
end_include
begin_include
include|#
directive|include
file|<qscreen.h>
end_include
begin_include
include|#
directive|include
file|"qsessionmanager.h"
end_include
begin_include
include|#
directive|include
file|<private/qscreen_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qgenericpluginfactory.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qstylehints.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatforminputcontext.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatforminputcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface_p.h>
end_include
begin_include
include|#
directive|include
file|"private/qwindow_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qcursor_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdnd_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformthemefactory_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_include
include|#
directive|include
file|<qpa/qplatformcursor.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtGui/QPixmap>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_include
include|#
directive|include
file|<QtGui/QClipboard>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"private/qcore_mac_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_is_gui_used
name|Q_GUI_EXPORT
name|bool
name|qt_is_gui_used
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mouse_buttons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplicationPrivate
operator|::
name|mouse_buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|modifier_buttons
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplicationPrivate
operator|::
name|modifier_buttons
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QPointF
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|tabletState
name|bool
name|QGuiApplicationPrivate
operator|::
name|tabletState
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|tabletPressTarget
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|tabletPressTarget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|currentMouseWindow
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_integration
name|QPlatformIntegration
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_integration
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_theme
name|QPlatformTheme
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_theme
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|generic_plugin_list
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|QGuiApplicationPrivate
operator|::
name|generic_plugin_list
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|ApplicationResourceFlags
enum|enum
name|ApplicationResourceFlags
block|{
DECL|enumerator|ApplicationPaletteExplicitlySet
name|ApplicationPaletteExplicitlySet
init|=
literal|0x1
block|,
DECL|enumerator|ApplicationFontExplicitlySet
name|ApplicationFontExplicitlySet
init|=
literal|0x2
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|applicationResourceFlags
specifier|static
name|unsigned
name|applicationResourceFlags
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_name
name|QString
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_name
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|displayName
name|QString
modifier|*
name|QGuiApplicationPrivate
operator|::
name|displayName
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_pal
name|QPalette
modifier|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_pal
comment|// default application palette
end_comment
begin_decl_stmt
DECL|member|buttons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplicationPrivate
operator|::
name|buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressTime
name|ulong
name|QGuiApplicationPrivate
operator|::
name|mousePressTime
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressButton
name|Qt
operator|::
name|MouseButton
name|QGuiApplicationPrivate
operator|::
name|mousePressButton
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressX
name|int
name|QGuiApplicationPrivate
operator|::
name|mousePressX
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressY
name|int
name|QGuiApplicationPrivate
operator|::
name|mousePressY
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mouse_double_click_distance
name|int
name|QGuiApplicationPrivate
operator|::
name|mouse_double_click_distance
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|layout_direction
specifier|static
name|Qt
operator|::
name|LayoutDirection
name|layout_direction
init|=
name|Qt
operator|::
name|LeftToRight
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_reverse
specifier|static
name|bool
name|force_reverse
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|self
name|QGuiApplicationPrivate
modifier|*
name|QGuiApplicationPrivate
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_fakeTouchDevice
name|QTouchDevice
modifier|*
name|QGuiApplicationPrivate
operator|::
name|m_fakeTouchDevice
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_fakeMouseSourcePointId
name|int
name|QGuiApplicationPrivate
operator|::
name|m_fakeMouseSourcePointId
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_decl_stmt
DECL|member|qt_clipboard
name|QClipboard
modifier|*
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|screen_list
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|QGuiApplicationPrivate
operator|::
name|screen_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|window_list
name|QWindowList
name|QGuiApplicationPrivate
operator|::
name|window_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|focus_window
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|focus_window
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|applicationFontMutex
specifier|static
name|QBasicMutex
name|applicationFontMutex
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_font
name|QFont
modifier|*
name|QGuiApplicationPrivate
operator|::
name|app_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|obey_desktop_settings
name|bool
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|noGrab
name|bool
name|QGuiApplicationPrivate
operator|::
name|noGrab
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fontSmoothingGamma
specifier|static
name|qreal
name|fontSmoothingGamma
init|=
literal|1.7
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
name|void
name|qRegisterGuiVariant
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qInitDrawhelperAsm
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qInitImageConversions
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qt_detectRTLLanguage
specifier|static
name|bool
name|qt_detectRTLLanguage
parameter_list|()
block|{
return|return
name|force_reverse
operator|^
operator|(
name|QCoreApplication
operator|::
name|tr
argument_list|(
literal|"QT_LAYOUT_DIRECTION"
argument_list|,
literal|"Translate this string to the string 'LTR' in left-to-right"
literal|" languages or to 'RTL' in right-to-left languages (such as Hebrew"
literal|" and Arabic) to get proper widget layout."
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"RTL"
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|initPalette
specifier|static
name|void
name|initPalette
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
if|if
condition|(
specifier|const
name|QPalette
modifier|*
name|themePalette
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
operator|->
name|palette
argument_list|()
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
operator|*
name|themePalette
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearPalette
specifier|static
specifier|inline
name|void
name|clearPalette
parameter_list|()
block|{
operator|delete
name|QGuiApplicationPrivate
operator|::
name|app_pal
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initFontUnlocked
specifier|static
name|void
name|initFontUnlocked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
block|{
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
if|if
condition|(
specifier|const
name|QFont
modifier|*
name|font
init|=
name|theme
operator|->
name|font
argument_list|(
name|QPlatformTheme
operator|::
name|SystemFont
argument_list|)
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
operator|*
name|font
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|fontDatabase
argument_list|()
operator|->
name|defaultFont
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearFontUnlocked
specifier|static
specifier|inline
name|void
name|clearFontUnlocked
parameter_list|()
block|{
operator|delete
name|QGuiApplicationPrivate
operator|::
name|app_font
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QGuiApplication     \brief The QGuiApplication class manages the GUI application's control     flow and main settings.      \inmodule QtGui     \since 5.0      QGuiApplication contains the main event loop, where all events from the window     system and other sources are processed and dispatched. It also handles the     application's initialization and finalization, and provides session management.     In addition, QGuiApplication handles most of the system-wide and application-wide     settings.      For any GUI application using Qt, there is precisely \b one QGuiApplication     object no matter whether the application has 0, 1, 2 or more windows at     any given time. For non-GUI Qt applications, use QCoreApplication instead,     as it does not depend on the \l QtGui library. For QWidget based Qt applications,     use QApplication instead, as it provides some functionality needed for creating     QWidget instances.      The QGuiApplication object is accessible through the instance() function, which     returns a pointer equivalent to the global \l qApp pointer.      QGuiApplication's main areas of responsibility are:         \list             \li  It initializes the application with the user's desktop settings,                 such as palette(), font() and styleHints(). It keeps                 track of these properties in case the user changes the desktop                 globally, for example, through some kind of control panel.              \li  It performs event handling, meaning that it receives events                 from the underlying window system and dispatches them to the                 relevant widgets. You can send your own events to windows by                 using sendEvent() and postEvent().              \li  It parses common command line arguments and sets its internal                 state accordingly. See the \l{QGuiApplication::QGuiApplication()}                 {constructor documentation} below for more details.              \li  It provides localization of strings that are visible to the                 user via translate().              \li  It provides some magical objects like the clipboard().              \li  It knows about the application's windows. You can ask which                 window is at a certain position using topLevelAt(), get a list of                 topLevelWindows(), etc.              \li  It manages the application's mouse cursor handling, see                 setOverrideCursor()              \li  It provides support for sophisticated \l{Session Management}                 {session management}. This makes it possible for applications                 to terminate gracefully when the user logs out, to cancel a                 shutdown process if termination isn't possible and even to                 preserve the entire application's state for a future session.                 See isSessionRestored(), sessionId() and commitDataRequest() and                 saveStateRequest() for details.         \endlist      Since the QGuiApplication object does so much initialization, it \e{must} be     created before any other objects related to the user interface are created.     QGuiApplication also deals with common command line arguments. Hence, it is     usually a good idea to create it \e before any interpretation or     modification of \c argv is done in the application itself.      \table     \header         \li{2,1} Groups of functions          \row         \li  System settings         \li  desktopSettingsAware(),             setDesktopSettingsAware(),             styleHints(),             palette(),             setPalette(),             font(),             setFont().          \row         \li  Event handling         \li  exec(),             processEvents(),             exit(),             quit().             sendEvent(),             postEvent(),             sendPostedEvents(),             removePostedEvents(),             hasPendingEvents(),             notify().          \row         \li  Windows         \li  allWindows(),             topLevelWindows(),             focusWindow(),             clipboard(),             topLevelAt().          \row         \li  Advanced cursor handling         \li  overrideCursor(),             setOverrideCursor(),             restoreOverrideCursor().          \row         \li  Session management         \li  isSessionRestored(),             sessionId(),             commitDataRequest(),             saveStateRequest().          \row         \li  Miscellaneous         \li  startingUp(),             closingDown(),             type().     \endtable      \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop */
end_comment
begin_comment
comment|/*!     Initializes the window system and constructs an application object with     \a argc command line arguments in \a argv.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QGuiApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      The global \c qApp pointer refers to this application object. Only one     application object should be created.      This application object must be constructed before any \l{QPaintDevice}     {paint devices} (including pixmaps, bitmaps etc.).      \note \a argc and \a argv might be changed as Qt removes command line     arguments that it recognizes.      All Qt programs automatically support the following command line options:     \list         \li  -reverse, sets the application's layout direction to             Qt::RightToLeft         \li  -qmljsdebugger=, activates the QML/JS debugger with a specified port.             The value must be of format port:1234[,block], where block is optional             and will make the application wait until a debugger connects to it.         \li  -session \e session, restores the application from an earlier             \l{Session Management}{session}.     \endlist      \sa arguments() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_macro
DECL|function|QGuiApplication
name|QGuiApplication
end_macro
begin_expr_stmt
DECL|function|QGuiApplication
operator|::
name|QGuiApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
else|#
directive|else
name|QGuiApplication
operator|::
name|QGuiApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
endif|#
directive|endif
operator|:
name|QCoreApplication
argument_list|(
argument|*new QGuiApplicationPrivate(argc, argv, flags)
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
block|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
block|; }
comment|/*!     \internal */
DECL|function|QGuiApplication
name|QGuiApplication
operator|::
name|QGuiApplication
argument_list|(
name|QGuiApplicationPrivate
operator|&
name|p
argument_list|)
operator|:
name|QCoreApplication
argument_list|(
argument|p
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
block|; }
comment|/*!     Destructs the application. */
DECL|function|~QGuiApplication
name|QGuiApplication
operator|::
name|~
name|QGuiApplication
operator|(
operator|)
block|{
name|Q_D
argument_list|(
name|QGuiApplication
argument_list|)
block|;
name|d
operator|->
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
block|;
name|d
operator|->
name|eventDispatcher
operator|=
literal|0
block|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
operator|delete
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
block|;
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|=
literal|0
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
operator|delete
name|d
operator|->
name|session_manager
block|;
name|d
operator|->
name|session_manager
operator|=
literal|0
block|;
endif|#
directive|endif
comment|//QT_NO_SESSIONMANAGER
name|clearPalette
argument_list|()
block|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|d
operator|->
name|cursor_list
operator|.
name|clear
argument_list|()
block|;
endif|#
directive|endif
operator|delete
name|QGuiApplicationPrivate
operator|::
name|platform_name
block|;
name|QGuiApplicationPrivate
operator|::
name|platform_name
operator|=
literal|0
block|;
operator|delete
name|QGuiApplicationPrivate
operator|::
name|displayName
block|;
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
literal|0
block|; }
DECL|function|QGuiApplicationPrivate
name|QGuiApplicationPrivate
operator|::
name|QGuiApplicationPrivate
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
operator|:
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|)
operator|,
name|styleHints
argument_list|(
literal|0
argument_list|)
operator|,
name|inputMethod
argument_list|(
literal|0
argument_list|)
operator|,
name|lastTouchType
argument_list|(
argument|QEvent::TouchEnd
argument_list|)
block|{
name|self
operator|=
name|this
block|;
name|application_type
operator|=
name|QCoreApplicationPrivate
operator|::
name|Gui
block|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
name|is_session_restored
operator|=
literal|false
block|;
name|is_saving_session
operator|=
literal|false
block|;
endif|#
directive|endif
block|}
comment|/*!     \property QGuiApplication::applicationDisplayName     \brief the user-visible name of this application     \since 5.0      This name is shown to the user, for instance in window titles.     It can be translated, if necessary.      If not set, the application display name defaults to the application name.      \sa applicationName */
DECL|function|setApplicationDisplayName
name|void
name|QGuiApplication
operator|::
name|setApplicationDisplayName
operator|(
specifier|const
name|QString
operator|&
name|name
operator|)
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|displayName
condition|)
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
operator|new
name|QString
expr_stmt|;
operator|*
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
name|name
expr_stmt|;
end_expr_stmt
begin_macro
unit|}  QString
DECL|function|applicationDisplayName
name|QGuiApplication
end_macro
begin_expr_stmt
DECL|function|applicationDisplayName
operator|::
name|applicationDisplayName
operator|(
operator|)
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|?
operator|*
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|:
name|applicationName
argument_list|()
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     Returns the most recently shown modal window. If no modal windows are     visible, this function returns zero.      A modal window is a window which has its     \l{QWindow::modality}{modality} property set to Qt::WindowModal     or Qt::ApplicationModal. A modal window must be closed before the user can     continue with other parts of the program.      Modal window are organized in a stack. This function returns the modal     window at the top of the stack.      \sa Qt::WindowModality, QWindow::setModality() */
end_comment
begin_function
DECL|function|modalWindow
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|modalWindow
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|modalWindowList
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|updateBlockedStatus
name|void
name|QGuiApplicationPrivate
operator|::
name|updateBlockedStatus
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|bool
name|shouldBeBlocked
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|window
operator|->
name|type
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|!=
name|Qt
operator|::
name|Popup
operator|&&
operator|!
name|self
operator|->
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
name|shouldBeBlocked
operator|=
name|self
operator|->
name|isWindowBlocked
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldBeBlocked
operator|!=
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|shouldBeBlocked
condition|?
name|QEvent
operator|::
name|WindowBlocked
else|:
name|QEvent
operator|::
name|WindowUnblocked
argument_list|)
decl_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
operator|=
name|shouldBeBlocked
expr_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|showModalWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|showModalWindow
parameter_list|(
name|QWindow
modifier|*
name|modal
parameter_list|)
block|{
name|self
operator|->
name|modalWindowList
operator|.
name|prepend
argument_list|(
name|modal
argument_list|)
expr_stmt|;
comment|// Send leave for currently entered window if it should be blocked
if|if
condition|(
name|currentMouseWindow
operator|&&
operator|(
name|currentMouseWindow
operator|->
name|type
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|!=
name|Qt
operator|::
name|Popup
condition|)
block|{
name|bool
name|shouldBeBlocked
init|=
name|self
operator|->
name|isWindowBlocked
argument_list|(
name|currentMouseWindow
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldBeBlocked
condition|)
block|{
comment|// Remove the new window from modalWindowList temporarily so leave can go through
name|self
operator|->
name|modalWindowList
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentMouseWindow
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|self
operator|->
name|modalWindowList
operator|.
name|prepend
argument_list|(
name|modal
argument_list|)
expr_stmt|;
block|}
block|}
name|QWindowList
name|windows
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
name|updateBlockedStatus
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
name|updateBlockedStatus
argument_list|(
name|modal
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hideModalWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|hideModalWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|self
operator|->
name|modalWindowList
operator|.
name|removeAll
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|QWindowList
name|windows
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
name|updateBlockedStatus
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     Returns true if \a window is blocked by a modal window. If \a     blockingWindow is non-zero, *blockingWindow will be set to the blocking     window (or to zero if \a window is not blocked). */
end_comment
begin_function
DECL|function|isWindowBlocked
name|bool
name|QGuiApplicationPrivate
operator|::
name|isWindowBlocked
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QWindow
modifier|*
modifier|*
name|blockingWindow
parameter_list|)
specifier|const
block|{
name|QWindow
modifier|*
name|unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|blockingWindow
condition|)
name|blockingWindow
operator|=
operator|&
name|unused
expr_stmt|;
if|if
condition|(
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modalWindowList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|modalWindow
init|=
name|modalWindowList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
block|{
comment|// check if the modal window is our window or a (transient) parent of our window
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|==
name|modalWindow
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
block|}
name|Qt
operator|::
name|WindowModality
name|windowModality
init|=
name|modalWindow
operator|->
name|modality
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|windowModality
condition|)
block|{
case|case
name|Qt
operator|::
name|ApplicationModal
case|:
block|{
if|if
condition|(
name|modalWindow
operator|!=
name|window
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|modalWindow
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
case|case
name|Qt
operator|::
name|WindowModal
case|:
block|{
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
do|do
block|{
name|QWindow
modifier|*
name|m
init|=
name|modalWindow
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|w
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|m
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|m
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|m
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|m
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
break|break;
block|}
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QGuiApplication"
argument_list|,
literal|"internal error, a modal widget cannot be modeless"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QWindow that receives events tied to focus,     such as key events. */
end_comment
begin_function
DECL|function|focusWindow
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|focusWindow
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|focus_window
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::focusObjectChanged(QObject *focusObject)      This signal is emitted when final receiver of events tied to focus is changed.     \a focusObject is the new receiver.      \sa focusObject() */
end_comment
begin_comment
comment|/*!     \fn QGuiApplication::focusWindowChanged(QWindow *focusWindow)      This signal is emitted when the focused window changes.     \a focusWindow is the new focused window.      \sa focusWindow() */
end_comment
begin_comment
comment|/*!     Returns the QObject in currently active window that will be final receiver of events     tied to focus, such as key events.  */
end_comment
begin_function
DECL|function|focusObject
name|QObject
modifier|*
name|QGuiApplication
operator|::
name|focusObject
parameter_list|()
block|{
if|if
condition|(
name|focusWindow
argument_list|()
condition|)
return|return
name|focusWindow
argument_list|()
operator|->
name|focusObject
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::allWindows()      Returns a list of all the windows in the application.      The list is empty if there are no windows.      \sa topLevelWindows()  */
end_comment
begin_function
DECL|function|allWindows
name|QWindowList
name|QGuiApplication
operator|::
name|allWindows
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|window_list
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::topLevelWindows()      Returns a list of the top-level windows in the application.      \sa allWindows()  */
end_comment
begin_function
DECL|function|topLevelWindows
name|QWindowList
name|QGuiApplication
operator|::
name|topLevelWindows
parameter_list|()
block|{
specifier|const
name|QWindowList
modifier|&
name|list
init|=
name|QGuiApplicationPrivate
operator|::
name|window_list
decl_stmt|;
name|QWindowList
name|topLevelWindows
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|parent
argument_list|()
condition|)
block|{
comment|// Top windows of embedded QAxServers do not have QWindow parents,
comment|// but they are not true top level windows, so do not include them.
specifier|const
name|bool
name|embedded
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
operator|&&
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
operator|->
name|isEmbedded
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|embedded
condition|)
name|topLevelWindows
operator|.
name|prepend
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|topLevelWindows
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary (or default) screen of the application.      This will be the screen where QWindows are shown, unless otherwise specified. */
end_comment
begin_function
DECL|function|primaryScreen
name|QScreen
modifier|*
name|QGuiApplication
operator|::
name|primaryScreen
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|screen_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|QGuiApplicationPrivate
operator|::
name|screen_list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the screens associated with the     windowing system the application is connected to. */
end_comment
begin_function
DECL|function|screens
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|QGuiApplication
operator|::
name|screens
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|screen_list
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::screenAdded(QScreen *screen)      This signal is emitted whenever a new screen \a screen has been added to the system.      \sa screens(), primaryScreen() */
end_comment
begin_comment
comment|/*!     Returns the highest screen device pixel ratio found on     the system. This is the ratio between physical pixels and     device-independent pixels.      Use this function only when you don't know which window you are targeting.     If you do know the target window use QWindow::devicePixelRatio() instead.      \sa QWindow::devicePixelRatio();     \sa QGuiApplicaiton::devicePixelRatio(); */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QGuiApplication
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
comment|// Cache topDevicePixelRatio, iterate through the screen list once only.
specifier|static
name|qreal
name|topDevicePixelRatio
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|topDevicePixelRatio
argument_list|)
condition|)
block|{
return|return
name|topDevicePixelRatio
return|;
block|}
name|topDevicePixelRatio
operator|=
literal|1.0
expr_stmt|;
comment|// make sure we never return 0.
foreach|foreach
control|(
name|QScreen
modifier|*
name|screen
decl|,
name|QGuiApplicationPrivate
operator|::
name|screen_list
control|)
block|{
name|topDevicePixelRatio
operator|=
name|qMax
argument_list|(
name|topDevicePixelRatio
argument_list|,
name|screen
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|topDevicePixelRatio
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the top level window at the given position, if any. */
end_comment
begin_function
DECL|function|topLevelAt
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|topLevelAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|screens
init|=
name|QGuiApplication
operator|::
name|screens
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
operator|::
name|const_iterator
name|screen
init|=
name|screens
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
operator|::
name|const_iterator
name|end
init|=
name|screens
operator|.
name|constEnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|screen
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|screen
operator|)
operator|->
name|geometry
argument_list|()
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return
operator|(
operator|*
name|screen
operator|)
operator|->
name|handle
argument_list|()
operator|->
name|topLevelAt
argument_list|(
name|pos
argument_list|)
return|;
operator|++
name|screen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGuiApplication::platformName     \brief The name of the underlying platform plugin.      Examples: "xcb" (for X11), "Cocoa" (for Mac OS X), "windows", "qnx",        "directfb", "kms", "MinimalEgl", "LinuxFb", "EglFS", "OpenWFD"... */
end_comment
begin_function
DECL|function|platformName
name|QString
name|QGuiApplication
operator|::
name|platformName
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|platform_name
condition|?
operator|*
name|QGuiApplicationPrivate
operator|::
name|platform_name
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|init_platform
specifier|static
name|void
name|init_platform
parameter_list|(
specifier|const
name|QString
modifier|&
name|pluginArgument
parameter_list|,
specifier|const
name|QString
modifier|&
name|platformPluginPath
parameter_list|)
block|{
comment|// Split into platform name and arguments
name|QStringList
name|arguments
init|=
name|pluginArgument
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|name
init|=
name|arguments
operator|.
name|takeFirst
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
comment|// Create the platform integration.
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|=
name|QPlatformIntegrationFactory
operator|::
name|create
argument_list|(
name|name
argument_list|,
name|arguments
argument_list|,
name|platformPluginPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_integration
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_name
operator|=
operator|new
name|QString
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|keys
init|=
name|QPlatformIntegrationFactory
operator|::
name|keys
argument_list|(
name|platformPluginPath
argument_list|)
decl_stmt|;
name|QString
name|fatalMessage
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Failed to load platform plugin \"%1\". Available platforms are: \n"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|key
decl|,
name|keys
control|)
block|{
name|fatalMessage
operator|.
name|append
argument_list|(
name|key
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qFatal
argument_list|(
literal|"%s"
argument_list|,
name|fatalMessage
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Create the platform theme:
comment|// 1) Ask the platform integration for a list of names.
specifier|const
name|QStringList
name|themeNames
init|=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|themeNames
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|themeName
decl|,
name|themeNames
control|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
name|QPlatformThemeFactory
operator|::
name|create
argument_list|(
name|themeName
argument_list|,
name|platformPluginPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
break|break;
block|}
comment|// 2) If none found, look for a theme plugin. Theme plugins are located in the
comment|// same directory as platform plugins.
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|themeName
decl|,
name|themeNames
control|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|createPlatformTheme
argument_list|(
name|themeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
break|break;
block|}
comment|// No error message; not having a theme plugin is allowed.
block|}
comment|// 3) Fall back on the built-in "null" platform theme.
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
operator|new
name|QPlatformTheme
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
comment|// Set arguments as dynamic properties on the native interface as
comment|// boolean 'foo' or strings: 'foo=bar'
if|if
condition|(
operator|!
name|arguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|QObject
modifier|*
name|nativeInterface
init|=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|nativeInterface
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|argument
decl|,
name|arguments
control|)
block|{
specifier|const
name|int
name|equalsPos
init|=
name|argument
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|name
init|=
name|equalsPos
operator|!=
operator|-
literal|1
condition|?
name|argument
operator|.
name|left
argument_list|(
name|equalsPos
argument_list|)
operator|.
name|toUtf8
argument_list|()
else|:
name|argument
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
specifier|const
name|QVariant
name|value
init|=
name|equalsPos
operator|!=
operator|-
literal|1
condition|?
name|QVariant
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|equalsPos
operator|+
literal|1
argument_list|)
argument_list|)
else|:
name|QVariant
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|nativeInterface
operator|->
name|setProperty
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|fontSmoothingGamma
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QPlatformIntegration
operator|::
name|FontSmoothingGamma
argument_list|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init_plugins
specifier|static
name|void
name|init_plugins
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|pluginList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pluginList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|pluginSpec
init|=
name|pluginList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|colonPos
init|=
name|pluginSpec
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|plugin
decl_stmt|;
if|if
condition|(
name|colonPos
operator|<
literal|0
condition|)
name|plugin
operator|=
name|QGenericPluginFactory
operator|::
name|create
argument_list|(
name|QLatin1String
argument_list|(
name|pluginSpec
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|plugin
operator|=
name|QGenericPluginFactory
operator|::
name|create
argument_list|(
name|QLatin1String
argument_list|(
name|pluginSpec
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
name|colonPos
argument_list|)
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
name|pluginSpec
operator|.
name|mid
argument_list|(
name|colonPos
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugin
condition|)
name|QGuiApplicationPrivate
operator|::
name|generic_plugin_list
operator|.
name|append
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createPlatformIntegration
name|void
name|QGuiApplicationPrivate
operator|::
name|createPlatformIntegration
parameter_list|()
block|{
comment|// Use the Qt menus by default. Platform plugins that
comment|// want to enable a native menu implementation can clear
comment|// this flag.
name|QCoreApplication
operator|::
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontUseNativeMenuBar
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Load the platform integration
name|QString
name|platformPluginPath
init|=
name|QLatin1String
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_QPA_PLATFORM_PLUGIN_PATH"
argument_list|)
argument_list|)
decl_stmt|;
comment|// On Mac, look inside the application bundle for the platform plugin.
comment|// TODO (msorvig): Create proper cross-platform solution for loading
comment|// deployed platform plugins
ifdef|#
directive|ifdef
name|Q_OS_MAC
specifier|const
name|QString
name|bundlePluginPath
init|=
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"../Plugins/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|platformPluginPath
operator|.
name|isEmpty
argument_list|()
operator|&&
name|QDir
argument_list|(
name|bundlePluginPath
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
name|platformPluginPath
operator|=
name|bundlePluginPath
expr_stmt|;
block|}
endif|#
directive|endif
name|QByteArray
name|platformName
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_QPA_DEFAULT_PLATFORM_NAME
name|platformName
operator|=
name|QT_QPA_DEFAULT_PLATFORM_NAME
expr_stmt|;
endif|#
directive|endif
name|QByteArray
name|platformNameEnv
init|=
name|qgetenv
argument_list|(
literal|"QT_QPA_PLATFORM"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|platformNameEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|platformName
operator|=
name|platformNameEnv
expr_stmt|;
block|}
comment|// Get command line params
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-platformpluginpath"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|platformPluginPath
operator|=
name|QLatin1String
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-platform"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|platformName
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
name|init_platform
argument_list|(
name|QLatin1String
argument_list|(
name|platformName
argument_list|)
argument_list|,
name|platformPluginPath
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createEventDispatcher
name|void
name|QGuiApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
if|if
condition|(
name|platform_integration
operator|==
literal|0
condition|)
name|createPlatformIntegration
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|eventDispatcher
condition|)
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|platform_integration
operator|->
name|guiThreadEventDispatcher
argument_list|()
decl_stmt|;
name|setEventDispatcher
argument_list|(
name|eventDispatcher
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setEventDispatcher
name|void
name|QGuiApplicationPrivate
operator|::
name|setEventDispatcher
parameter_list|(
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
name|eventDispatcher
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|setParent
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|threadData
operator|->
name|eventDispatcher
operator|=
name|eventDispatcher
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
end_if
begin_comment
comment|// Find out if our parent process is gdb by looking at the 'exe' symlink under /proc.
end_comment
begin_function
DECL|function|runningUnderDebugger
specifier|static
name|bool
name|runningUnderDebugger
parameter_list|()
block|{
specifier|const
name|QFileInfo
name|parentProcExe
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/proc/"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|getppid
argument_list|()
argument_list|)
operator|+
name|QStringLiteral
argument_list|(
literal|"/exe"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|parentProcExe
operator|.
name|isSymLink
argument_list|()
operator|&&
name|parentProcExe
operator|.
name|symLinkTarget
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/gdb"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|init
name|void
name|QGuiApplicationPrivate
operator|::
name|init
parameter_list|()
block|{
name|bool
name|doGrabUnderDebugger
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|pluginList
decl_stmt|;
comment|// Get command line params
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-plugin"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|pluginList
operator|<<
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-reverse"
condition|)
block|{
name|force_reverse
operator|=
literal|true
expr_stmt|;
name|QGuiApplication
operator|::
name|setLayoutDirection
argument_list|(
name|Qt
operator|::
name|RightToLeft
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"-psn_"
argument_list|)
condition|)
block|{
comment|// eat "-psn_xxxx" on Mac, which is passed when starting an app from Finder.
comment|// special hack to change working directory (for an app bundle) when running from finder
if|if
condition|(
name|QDir
operator|::
name|currentPath
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|QCFType
argument_list|<
name|CFURLRef
argument_list|>
name|bundleURL
argument_list|(
name|CFBundleCopyBundleURL
argument_list|(
name|CFBundleGetMainBundle
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|qbundlePath
init|=
name|QCFString
argument_list|(
name|CFURLCopyFileSystemPath
argument_list|(
name|bundleURL
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qbundlePath
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".app"
argument_list|)
argument_list|)
condition|)
name|QDir
operator|::
name|setCurrent
argument_list|(
name|qbundlePath
operator|.
name|section
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-nograb"
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|noGrab
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-dograb"
condition|)
block|{
name|doGrabUnderDebugger
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-session"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
condition|)
block|{
name|session_id
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|p
init|=
name|session_id
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|>=
literal|0
condition|)
block|{
name|session_key
operator|=
name|session_id
operator|.
name|mid
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|session_id
operator|=
name|session_id
operator|.
name|left
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|is_session_restored
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
if|if
condition|(
operator|!
name|doGrabUnderDebugger
operator|&&
operator|!
name|QGuiApplicationPrivate
operator|::
name|noGrab
operator|&&
name|runningUnderDebugger
argument_list|()
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|noGrab
operator|=
literal|true
expr_stmt|;
name|qDebug
argument_list|(
literal|"Qt: gdb: -nograb added to command-line options.\n"
literal|"\t Use the -dograb option to enforce grabbing."
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|doGrabUnderDebugger
argument_list|)
endif|#
directive|endif
comment|// Load environment exported generic plugins
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|plugin
decl|,
name|qgetenv
argument_list|(
literal|"QT_QPA_GENERIC_PLUGINS"
argument_list|)
operator|.
name|split
argument_list|(
literal|','
argument_list|)
control|)
name|pluginList
operator|<<
name|plugin
expr_stmt|;
if|if
condition|(
name|platform_integration
operator|==
literal|0
condition|)
name|createPlatformIntegration
argument_list|()
expr_stmt|;
comment|// Set up which span functions should be used in raster engine...
name|qInitDrawhelperAsm
argument_list|()
expr_stmt|;
comment|// and QImage conversion functions
name|qInitImageConversions
argument_list|()
expr_stmt|;
name|QFont
operator|::
name|initialize
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QCursorData
operator|::
name|initialize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// trigger registering of QVariant's GUI types
name|qRegisterGuiVariant
argument_list|()
expr_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|eventTime
operator|.
name|start
argument_list|()
expr_stmt|;
name|is_app_running
operator|=
literal|true
expr_stmt|;
name|init_plugins
argument_list|(
name|pluginList
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|flushWindowSystemEvents
argument_list|()
expr_stmt|;
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
comment|// connect to the session manager
name|session_manager
operator|=
operator|new
name|QSessionManager
argument_list|(
name|q
argument_list|,
name|session_id
argument_list|,
name|session_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function_decl
specifier|extern
name|void
name|qt_cleanupFontDatabase
parameter_list|()
function_decl|;
end_function_decl
begin_destructor
DECL|function|~QGuiApplicationPrivate
name|QGuiApplicationPrivate
operator|::
name|~
name|QGuiApplicationPrivate
parameter_list|()
block|{
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|is_app_running
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|generic_plugin_list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|generic_plugin_list
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|generic_plugin_list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|clearFontUnlocked
argument_list|()
expr_stmt|;
name|QFont
operator|::
name|cleanup
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QCursorData
operator|::
name|cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|layout_direction
operator|=
name|Qt
operator|::
name|LeftToRight
expr_stmt|;
name|cleanupThreadData
argument_list|()
expr_stmt|;
operator|delete
name|styleHints
expr_stmt|;
operator|delete
name|inputMethod
expr_stmt|;
name|qt_cleanupFontDatabase
argument_list|()
expr_stmt|;
name|QPixmapCache
operator|::
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|platform_theme
expr_stmt|;
name|platform_theme
operator|=
literal|0
expr_stmt|;
operator|delete
name|platform_integration
expr_stmt|;
name|platform_integration
operator|=
literal|0
expr_stmt|;
operator|delete
name|m_gammaTables
operator|.
name|load
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_if
if|#
directive|if
literal|0
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|QCursor *overrideCursor(); void setOverrideCursor(const QCursor&); void changeOverrideCursor(const QCursor&); void restoreOverrideCursor();
endif|#
directive|endif
end_endif
begin_ifndef
unit|static QFont font(); static QFont font(const QWidget*); static QFont font(const char *className); static void setFont(const QFont&, const char* className = 0); static QFontMetrics fontMetrics();
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_endif
unit|static QClipboard *clipboard();
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the current state of the modifier keys on the keyboard. The current     state is updated sychronously as the event queue is emptied of events that     will spontaneously change the keyboard state (QEvent::KeyPress and     QEvent::KeyRelease events).      It should be noted this may not reflect the actual keys held on the input     device at the time of calling but rather the modifiers as last reported in     one of the above events. If no keys are being held Qt::NoModifier is     returned.      \sa mouseButtons(), queryKeyboardModifiers() */
end_comment
begin_function
DECL|function|keyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplication
operator|::
name|keyboardModifiers
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|modifier_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     \fn Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers()      Queries and returns the state of the modifier keys on the keyboard.     Unlike keyboardModifiers, this method returns the actual keys held     on the input device at the time of calling the method.      It does not rely on the keypress events having been received by this     process, which makes it possible to check the modifiers while moving     a window, for instance. Note that in most cases, you should use     keyboardModifiers(), which is faster and more accurate since it contains     the state of the modifiers as they were when the currently processed     event was received.      \sa keyboardModifiers() */
end_comment
begin_function
DECL|function|queryKeyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplication
operator|::
name|queryKeyboardModifiers
parameter_list|()
block|{
name|QPlatformIntegration
modifier|*
name|pi
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
return|return
name|pi
operator|->
name|queryKeyboardModifiers
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the buttons on the mouse. The current state is     updated syncronously as the event queue is emptied of events that will     spontaneously change the mouse state (QEvent::MouseButtonPress and     QEvent::MouseButtonRelease events).      It should be noted this may not reflect the actual buttons held on the     input device at the time of calling but rather the mouse buttons as last     reported in one of the above events. If no mouse buttons are being held     Qt::NoButton is returned.      \sa keyboardModifiers() */
end_comment
begin_function
DECL|function|mouseButtons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplication
operator|::
name|mouseButtons
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|mouse_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the platform's native interface, for platform specific     functionality. */
end_comment
begin_function
DECL|function|platformNativeInterface
name|QPlatformNativeInterface
modifier|*
name|QGuiApplication
operator|::
name|platformNativeInterface
parameter_list|()
block|{
name|QPlatformIntegration
modifier|*
name|pi
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
return|return
name|pi
condition|?
name|pi
operator|->
name|nativeInterface
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called, and then     returns the value that was set to exit() (which is 0 if exit() is called     via quit()).      It is necessary to call this function to start event handling. The main     event loop receives events from the window system and dispatches these to     the application widgets.      Generally, no user interaction can take place before calling exec().      To make your application perform idle processing, e.g., executing a special     function whenever there are no pending events, use a QTimer with 0 timeout.     More advanced idle processing schemes can be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your     application's \c{main()} function. This is because, on some platforms, the     QApplication::exec() call may not return.      \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),         QCoreApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QGuiApplication
operator|::
name|exec
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|setRootObject
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QCoreApplication
operator|::
name|exec
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|notify
name|bool
name|QGuiApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
comment|// Try looking for a Shortcut before sending key events
name|QWindow
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|focus
init|=
name|w
condition|?
name|w
operator|->
name|focusObject
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|focus
condition|)
name|focus
operator|=
name|object
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|shortcutMap
operator|.
name|tryShortcutEvent
argument_list|(
name|focus
argument_list|,
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|object
operator|->
name|isWindowType
argument_list|()
condition|)
name|QGuiApplicationPrivate
operator|::
name|sendQWindowEventToQPlatformWindow
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
name|QCoreApplication
operator|::
name|notify
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QGuiApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
name|setLayoutDirection
argument_list|(
name|qt_detectRTLLanguage
argument_list|()
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
argument_list|)
expr_stmt|;
block|}
return|return
name|QCoreApplication
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QGuiApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
name|postedEvents
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendQWindowEventToQPlatformWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|sendQWindowEventToQPlatformWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QPlatformWindow
modifier|*
name|platformWindow
init|=
name|window
operator|->
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|platformWindow
condition|)
return|return;
comment|// spontaneous events come from the platform integration already, we don't need to send the events back
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
return|return;
comment|// let the platform window do any handling it needs to as well
name|platformWindow
operator|->
name|windowEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processNativeEvent
name|bool
name|QGuiApplicationPrivate
operator|::
name|processNativeEvent
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|eventType
parameter_list|,
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
return|return
name|window
operator|->
name|nativeEvent
argument_list|(
name|eventType
argument_list|,
name|message
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|processWindowSystemEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWindowSystemEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|FrameStrutMouse
case|:
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Mouse
case|:
name|QGuiApplicationPrivate
operator|::
name|processMouseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Wheel
case|:
name|QGuiApplicationPrivate
operator|::
name|processWheelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|WheelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Key
case|:
name|QGuiApplicationPrivate
operator|::
name|processKeyEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|KeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Touch
case|:
name|QGuiApplicationPrivate
operator|::
name|processTouchEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChange
case|:
name|QGuiApplicationPrivate
operator|::
name|processGeometryChangeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChangeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Enter
case|:
name|QGuiApplicationPrivate
operator|::
name|processEnterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|EnterEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Leave
case|:
name|QGuiApplicationPrivate
operator|::
name|processLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|LeaveEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindow
case|:
name|QGuiApplicationPrivate
operator|::
name|processActivatedEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindowEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChanged
case|:
name|QGuiApplicationPrivate
operator|::
name|processWindowStateChangedEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChangedEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Close
case|:
name|QGuiApplicationPrivate
operator|::
name|processCloseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|CloseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientation
case|:
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientationEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometry
case|:
name|QGuiApplicationPrivate
operator|::
name|reportGeometryChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometryEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenAvailableGeometry
case|:
name|QGuiApplicationPrivate
operator|::
name|reportAvailableGeometryChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenAvailableGeometryEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInch
case|:
name|QGuiApplicationPrivate
operator|::
name|reportLogicalDotsPerInchChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRate
case|:
name|QGuiApplicationPrivate
operator|::
name|reportRefreshRateChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRateEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChange
case|:
name|QGuiApplicationPrivate
operator|::
name|processThemeChanged
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChangeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Expose
case|:
name|QGuiApplicationPrivate
operator|::
name|processExposeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ExposeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Tablet
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximity
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletEnterProximityEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximityEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximity
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletLeaveProximityEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximityEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanel
case|:
name|QGuiApplicationPrivate
operator|::
name|processPlatformPanelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpen
case|:
name|QGuiApplicationPrivate
operator|::
name|processFileOpenEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpenEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenu
case|:
name|QGuiApplicationPrivate
operator|::
name|processContextMenuEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qWarning
argument_list|()
operator|<<
literal|"Unknown user input event type:"
operator|<<
name|e
operator|->
name|type
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|processMouseEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processMouseEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|QEvent
operator|::
name|Type
name|type
decl_stmt|;
comment|// move first
name|Qt
operator|::
name|MouseButtons
name|stateChange
init|=
name|e
operator|->
name|buttons
operator|^
name|buttons
decl_stmt|;
specifier|const
name|bool
name|frameStrut
init|=
name|e
operator|->
name|type
operator|==
name|QWindowSystemInterfacePrivate
operator|::
name|FrameStrutMouse
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|globalPos
operator|!=
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|&&
operator|(
name|stateChange
operator|!=
name|Qt
operator|::
name|NoButton
operator|)
condition|)
block|{
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
modifier|*
name|newMouseEvent
init|=
operator|new
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|e
operator|->
name|type
argument_list|,
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|,
name|e
operator|->
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|windowSystemEventQueue
operator|.
name|prepend
argument_list|(
name|newMouseEvent
argument_list|)
expr_stmt|;
comment|// just in case the move triggers a new event loop
name|stateChange
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
block|}
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
name|QPointF
name|localPoint
init|=
name|e
operator|->
name|localPos
decl_stmt|;
name|QPointF
name|globalPoint
init|=
name|e
operator|->
name|globalPos
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
name|QPointF
name|delta
init|=
name|globalPoint
operator|-
name|globalPoint
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|localPoint
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
name|bool
name|doubleClick
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|!=
name|globalPoint
condition|)
block|{
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseMove
else|:
name|QEvent
operator|::
name|MouseMove
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|=
name|globalPoint
expr_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|globalPoint
operator|.
name|x
argument_list|()
operator|-
name|mousePressX
argument_list|)
operator|>
name|mouse_double_click_distance
operator|||
name|qAbs
argument_list|(
name|globalPoint
operator|.
name|y
argument_list|()
operator|-
name|mousePressY
argument_list|)
operator|>
name|mouse_double_click_distance
condition|)
name|mousePressButton
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
block|}
else|else
block|{
comment|// Check to see if a new button has been pressed/released.
for|for
control|(
name|int
name|check
init|=
name|Qt
operator|::
name|LeftButton
init|;
name|check
operator|<=
name|int
argument_list|(
name|Qt
operator|::
name|MaxMouseButton
argument_list|)
condition|;
name|check
operator|=
name|check
operator|<<
literal|1
control|)
block|{
if|if
condition|(
name|check
operator|&
name|stateChange
condition|)
block|{
name|button
operator|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|check
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|button
operator|==
name|Qt
operator|::
name|NoButton
condition|)
block|{
comment|// Ignore mouse events that don't change the current state.
return|return;
block|}
name|mouse_buttons
operator|=
name|buttons
operator|=
name|e
operator|->
name|buttons
expr_stmt|;
if|if
condition|(
name|button
operator|&
name|e
operator|->
name|buttons
condition|)
block|{
name|ulong
name|doubleClickInterval
init|=
cast|static_cast
argument_list|<
name|ulong
argument_list|>
argument_list|(
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|mouseDoubleClickInterval
argument_list|()
argument_list|)
decl_stmt|;
name|doubleClick
operator|=
name|e
operator|->
name|timestamp
operator|-
name|mousePressTime
operator|<
name|doubleClickInterval
operator|&&
name|button
operator|==
name|mousePressButton
expr_stmt|;
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonPress
else|:
name|QEvent
operator|::
name|MouseButtonPress
expr_stmt|;
name|mousePressTime
operator|=
name|e
operator|->
name|timestamp
expr_stmt|;
name|mousePressButton
operator|=
name|button
expr_stmt|;
specifier|const
name|QPoint
name|point
init|=
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|mousePressX
operator|=
name|point
operator|.
name|x
argument_list|()
expr_stmt|;
name|mousePressY
operator|=
name|point
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonRelease
else|:
name|QEvent
operator|::
name|MouseButtonRelease
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow mouse events through
return|return;
block|}
name|QMouseEvent
name|ev
argument_list|(
name|type
argument_list|,
name|localPoint
argument_list|,
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|button
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|window
operator|->
name|screen
argument_list|()
condition|)
if|if
condition|(
name|QPlatformCursor
modifier|*
name|cursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
name|cursor
operator|->
name|pointerEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|synthetic
operator|&&
operator|!
name|ev
operator|.
name|isAccepted
argument_list|()
operator|&&
operator|!
name|frameStrut
operator|&&
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_SynthesizeTouchForUnhandledMouseEvents
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|m_fakeTouchDevice
condition|)
block|{
name|m_fakeTouchDevice
operator|=
operator|new
name|QTouchDevice
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|registerTouchDevice
argument_list|(
name|m_fakeTouchDevice
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QWindowSystemInterface
operator|::
name|TouchPoint
argument_list|>
name|points
decl_stmt|;
name|QWindowSystemInterface
operator|::
name|TouchPoint
name|point
decl_stmt|;
name|point
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|point
operator|.
name|area
operator|=
name|QRectF
argument_list|(
name|globalPoint
operator|.
name|x
argument_list|()
operator|-
literal|2
argument_list|,
name|globalPoint
operator|.
name|y
argument_list|()
operator|-
literal|2
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// only translate left button related events to
comment|// avoid strange touch event sequences when several
comment|// buttons are pressed
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|&&
name|button
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointPressed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
name|button
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointReleased
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
operator|(
name|buttons
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|points
operator|<<
name|point
expr_stmt|;
name|QEvent
operator|::
name|Type
name|type
decl_stmt|;
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|QWindowSystemInterfacePrivate
operator|::
name|convertTouchPoints
argument_list|(
name|points
argument_list|,
operator|&
name|type
argument_list|)
decl_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
name|fake
argument_list|(
name|window
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|type
argument_list|,
name|m_fakeTouchDevice
argument_list|,
name|touchPoints
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|fake
operator|.
name|synthetic
operator|=
literal|true
expr_stmt|;
name|processTouchEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doubleClick
condition|)
block|{
name|mousePressButton
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
specifier|const
name|QEvent
operator|::
name|Type
name|doubleClickType
init|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonDblClick
else|:
name|QEvent
operator|::
name|MouseButtonDblClick
decl_stmt|;
name|QMouseEvent
name|dblClickEvent
argument_list|(
name|doubleClickType
argument_list|,
name|localPoint
argument_list|,
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|button
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|dblClickEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|dblClickEvent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processWheelEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWheelEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WheelEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|QPointF
name|globalPoint
init|=
name|e
operator|->
name|globalPos
decl_stmt|;
name|QPointF
name|localPoint
init|=
name|e
operator|->
name|localPos
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
name|QPointF
name|delta
init|=
name|globalPoint
operator|-
name|globalPoint
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|localPoint
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|=
name|globalPoint
expr_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow wheel events through
return|return;
block|}
name|QWheelEvent
name|ev
argument_list|(
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|e
operator|->
name|pixelDelta
argument_list|,
name|e
operator|->
name|angleDelta
argument_list|,
name|e
operator|->
name|qt4Delta
argument_list|,
name|e
operator|->
name|qt4Orientation
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ifndef QT_NO_WHEELEVENT */
block|}
end_function
begin_comment
comment|// Remember, Qt convention is:  keyboard state is state *before*
end_comment
begin_function
DECL|function|processKeyEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processKeyEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|KeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
condition|)
name|window
operator|=
name|QGuiApplication
operator|::
name|focusWindow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow key events through
return|return;
block|}
name|QKeyEvent
name|ev
argument_list|(
name|e
operator|->
name|keyType
argument_list|,
name|e
operator|->
name|key
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|nativeScanCode
argument_list|,
name|e
operator|->
name|nativeVirtualKey
argument_list|,
name|e
operator|->
name|nativeModifiers
argument_list|,
name|e
operator|->
name|unicode
argument_list|,
name|e
operator|->
name|repeat
argument_list|,
name|e
operator|->
name|repeatCount
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processEnterEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processEnterEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|EnterEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|enter
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|enter
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow enter events through
return|return;
block|}
name|currentMouseWindow
operator|=
name|e
operator|->
name|enter
expr_stmt|;
name|QEnterEvent
name|event
argument_list|(
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|enter
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processLeaveEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processLeaveEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|LeaveEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|leave
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|leave
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow leave events through
return|return;
block|}
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|leave
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processActivatedEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processActivatedEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindowEvent
modifier|*
name|e
parameter_list|)
block|{
name|QWindow
modifier|*
name|previous
init|=
name|QGuiApplicationPrivate
operator|::
name|focus_window
decl_stmt|;
name|QWindow
modifier|*
name|newFocus
init|=
name|e
operator|->
name|activated
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
name|newFocus
condition|)
return|return;
name|QObject
modifier|*
name|previousFocusObject
init|=
name|previous
condition|?
name|previous
operator|->
name|focusObject
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|previous
condition|)
block|{
name|QFocusEvent
name|focusAboutToChange
argument_list|(
name|QEvent
operator|::
name|FocusAboutToChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|previous
argument_list|,
operator|&
name|focusAboutToChange
argument_list|)
expr_stmt|;
block|}
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|=
name|newFocus
expr_stmt|;
if|if
condition|(
name|previous
condition|)
block|{
name|QFocusEvent
name|focusOut
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|previous
argument_list|,
operator|&
name|focusOut
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|previous
argument_list|,
name|SIGNAL
argument_list|(
name|focusObjectChanged
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|qApp
argument_list|,
name|SLOT
argument_list|(
name|_q_updateFocusObject
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QEvent
name|appActivate
argument_list|(
name|QEvent
operator|::
name|ApplicationActivate
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appActivate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
condition|)
block|{
name|QFocusEvent
name|focusIn
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
argument_list|,
operator|&
name|focusIn
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
argument_list|,
name|SIGNAL
argument_list|(
name|focusObjectChanged
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|qApp
argument_list|,
name|SLOT
argument_list|(
name|_q_updateFocusObject
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QEvent
name|appActivate
argument_list|(
name|QEvent
operator|::
name|ApplicationDeactivate
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appActivate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|self
condition|)
block|{
name|self
operator|->
name|notifyActiveWindowChange
argument_list|(
name|previous
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousFocusObject
operator|!=
name|qApp
operator|->
name|focusObject
argument_list|()
condition|)
name|self
operator|->
name|_q_updateFocusObject
argument_list|(
name|qApp
operator|->
name|focusObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
emit|emit
name|qApp
operator|->
name|focusWindowChanged
argument_list|(
name|newFocus
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|processWindowStateChangedEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWindowStateChangedEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChangedEvent
modifier|*
name|wse
parameter_list|)
block|{
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|wse
operator|->
name|window
operator|.
name|data
argument_list|()
condition|)
block|{
name|QWindowStateChangeEvent
name|e
argument_list|(
name|window
operator|->
name|windowState
argument_list|()
argument_list|)
decl_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|windowState
operator|=
name|wse
operator|->
name|newState
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processThemeChanged
name|void
name|QGuiApplicationPrivate
operator|::
name|processThemeChanged
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChangeEvent
modifier|*
name|tce
parameter_list|)
block|{
if|if
condition|(
name|self
condition|)
name|self
operator|->
name|notifyThemeChanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|tce
operator|->
name|window
operator|.
name|data
argument_list|()
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ThemeChange
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processGeometryChangeEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processGeometryChangeEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChangeEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|tlw
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|tlw
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QRect
name|newRect
init|=
name|e
operator|->
name|newGeometry
decl_stmt|;
name|QRect
name|cr
init|=
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
decl_stmt|;
name|bool
name|isResize
init|=
name|cr
operator|.
name|size
argument_list|()
operator|!=
name|newRect
operator|.
name|size
argument_list|()
decl_stmt|;
name|bool
name|isMove
init|=
name|cr
operator|.
name|topLeft
argument_list|()
operator|!=
name|newRect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
operator|=
name|newRect
expr_stmt|;
if|if
condition|(
name|isResize
operator|||
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|resizeEventPending
condition|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|newRect
operator|.
name|size
argument_list|()
argument_list|,
name|cr
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|resizeEventPending
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|cr
operator|.
name|width
argument_list|()
operator|!=
name|newRect
operator|.
name|width
argument_list|()
condition|)
name|window
operator|->
name|widthChanged
argument_list|(
name|newRect
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|.
name|height
argument_list|()
operator|!=
name|newRect
operator|.
name|height
argument_list|()
condition|)
name|window
operator|->
name|heightChanged
argument_list|(
name|newRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isMove
condition|)
block|{
comment|//### frame geometry
name|QMoveEvent
name|e
argument_list|(
name|newRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|cr
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|.
name|x
argument_list|()
operator|!=
name|newRect
operator|.
name|x
argument_list|()
condition|)
name|window
operator|->
name|xChanged
argument_list|(
name|newRect
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|.
name|y
argument_list|()
operator|!=
name|newRect
operator|.
name|y
argument_list|()
condition|)
name|window
operator|->
name|yChanged
argument_list|(
name|newRect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processCloseEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processCloseEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|CloseEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|window
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow close events through
return|return;
block|}
name|QCloseEvent
name|event
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processFileOpenEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processFileOpenEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpenEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QFileOpenEvent
name|event
argument_list|(
name|e
operator|->
name|fileName
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processTabletEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QEvent
operator|::
name|Type
name|type
init|=
name|QEvent
operator|::
name|TabletMove
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|down
operator|!=
name|tabletState
condition|)
block|{
name|type
operator|=
name|e
operator|->
name|down
condition|?
name|QEvent
operator|::
name|TabletPress
else|:
name|QEvent
operator|::
name|TabletRelease
expr_stmt|;
name|tabletState
operator|=
name|e
operator|->
name|down
expr_stmt|;
block|}
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
name|bool
name|localValid
init|=
literal|true
decl_stmt|;
comment|// If window is null, pick one based on the global position and make sure all
comment|// subsequent events up to the release are delivered to that same window.
comment|// If window is given, just send to that.
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|TabletPress
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|nullWindow
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
name|localValid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|tabletPressTarget
operator|=
name|window
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|nullWindow
condition|)
block|{
name|window
operator|=
name|tabletPressTarget
expr_stmt|;
name|localValid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|TabletRelease
condition|)
name|tabletPressTarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
block|}
name|QPointF
name|local
init|=
name|e
operator|->
name|local
decl_stmt|;
if|if
condition|(
operator|!
name|localValid
condition|)
block|{
name|QPointF
name|delta
init|=
name|e
operator|->
name|global
operator|-
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|local
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
name|QTabletEvent
name|ev
argument_list|(
name|type
argument_list|,
name|local
argument_list|,
name|e
operator|->
name|global
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
name|e
operator|->
name|pressure
argument_list|,
name|e
operator|->
name|xTilt
argument_list|,
name|e
operator|->
name|yTilt
argument_list|,
name|e
operator|->
name|tangentialPressure
argument_list|,
name|e
operator|->
name|rotation
argument_list|,
name|e
operator|->
name|z
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|uid
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processTabletEnterProximityEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletEnterProximityEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximityEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QTabletEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|TabletEnterProximity
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|,
name|e
operator|->
name|uid
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qGuiApp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processTabletLeaveProximityEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletLeaveProximityEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximityEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QTabletEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|TabletLeaveProximity
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|,
name|e
operator|->
name|uid
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qGuiApp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processPlatformPanelEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processPlatformPanelEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanelEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|window
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow events through
return|return;
block|}
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|PlatformPanel
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_function
DECL|function|processContextMenuEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processContextMenuEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenuEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// Widgets do not care about mouse triggered context menu events. Also, do not forward event
comment|// to a window blocked by a modal window.
if|if
condition|(
operator|!
name|e
operator|->
name|window
operator|||
name|e
operator|->
name|mouseTriggered
operator|||
name|e
operator|->
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
return|return;
name|QContextMenuEvent
name|ev
argument_list|(
name|QContextMenuEvent
operator|::
name|Keyboard
argument_list|,
name|e
operator|->
name|pos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qHash
name|Q_GUI_EXPORT
name|uint
name|qHash
parameter_list|(
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|k
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|k
operator|.
name|device
argument_list|)
operator|+
name|k
operator|.
name|touchPointId
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|Q_GUI_EXPORT
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|a
parameter_list|,
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|device
operator|==
name|b
operator|.
name|device
operator|&&
name|a
operator|.
name|touchPointId
operator|==
name|b
operator|.
name|touchPointId
return|;
block|}
end_function
begin_function
DECL|function|processTouchEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTouchEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
modifier|*
name|e
parameter_list|)
block|{
name|QGuiApplicationPrivate
modifier|*
name|d
init|=
name|self
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|touchType
operator|==
name|QEvent
operator|::
name|TouchCancel
condition|)
block|{
comment|// The touch sequence has been canceled (e.g. by the compositor).
comment|// Send the TouchCancel to all windows with active touches and clean up.
name|QTouchEvent
name|touchEvent
argument_list|(
name|QEvent
operator|::
name|TouchCancel
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|ActiveTouchPointsKey
argument_list|,
name|ActiveTouchPointsValue
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|ite
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QWindow
modifier|*
argument_list|>
name|windowsNeedingCancel
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ite
condition|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|it
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
name|windowsNeedingCancel
operator|.
name|insert
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
for|for
control|(
name|QSet
argument_list|<
name|QWindow
operator|*
argument_list|>
operator|::
name|const_iterator
name|winIt
init|=
name|windowsNeedingCancel
operator|.
name|constBegin
argument_list|()
init|,
name|winItEnd
init|=
name|windowsNeedingCancel
operator|.
name|constEnd
argument_list|()
init|;
name|winIt
operator|!=
name|winItEnd
condition|;
operator|++
name|winIt
control|)
block|{
name|touchEvent
operator|.
name|setWindow
argument_list|(
operator|*
name|winIt
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
operator|*
name|winIt
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|e
operator|->
name|synthetic
condition|)
block|{
for|for
control|(
name|QHash
argument_list|<
name|QWindow
operator|*
argument_list|,
name|SynthesizedMouseData
argument_list|>
operator|::
name|const_iterator
name|synthIt
init|=
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|constBegin
argument_list|()
init|,
name|synthItEnd
init|=
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|constEnd
argument_list|()
init|;
name|synthIt
operator|!=
name|synthItEnd
condition|;
operator|++
name|synthIt
control|)
block|{
if|if
condition|(
operator|!
name|synthIt
operator|->
name|window
condition|)
continue|continue;
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
name|fake
argument_list|(
name|synthIt
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|synthIt
operator|->
name|pos
argument_list|,
name|synthIt
operator|->
name|screenPos
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|fake
operator|.
name|synthetic
operator|=
literal|true
expr_stmt|;
name|processMouseEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|self
operator|->
name|activeTouchPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|self
operator|->
name|lastTouchType
operator|=
name|e
operator|->
name|touchType
expr_stmt|;
return|return;
block|}
comment|// Prevent sending ill-formed event sequences: Cancel can only be followed by a Begin.
if|if
condition|(
name|self
operator|->
name|lastTouchType
operator|==
name|QEvent
operator|::
name|TouchCancel
operator|&&
name|e
operator|->
name|touchType
operator|!=
name|QEvent
operator|::
name|TouchBegin
condition|)
return|return;
name|self
operator|->
name|lastTouchType
operator|=
name|e
operator|->
name|touchType
expr_stmt|;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
typedef|typedef
name|QPair
argument_list|<
name|Qt
operator|::
name|TouchPointStates
argument_list|,
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
argument_list|>
name|StatesAndTouchPoints
typedef|;
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
name|windowsNeedingEvents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|points
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|e
operator|->
name|points
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// explicitly detach from the original touch point that we got, so even
comment|// if the touchpoint structs are reused, we will make a copy that we'll
comment|// deliver to the user (which might want to store the struct for later use).
name|touchPoint
operator|.
name|d
operator|=
name|touchPoint
operator|.
name|d
operator|->
name|detach
argument_list|()
expr_stmt|;
comment|// update state
name|QPointer
argument_list|<
name|QWindow
argument_list|>
name|w
decl_stmt|;
name|QTouchEvent
operator|::
name|TouchPoint
name|previousTouchPoint
decl_stmt|;
name|ActiveTouchPointsKey
name|touchInfoKey
argument_list|(
name|e
operator|->
name|device
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|ActiveTouchPointsValue
modifier|&
name|touchInfo
init|=
name|d
operator|->
name|activeTouchPoints
index|[
name|touchInfoKey
index|]
decl_stmt|;
switch|switch
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
if|if
condition|(
name|e
operator|->
name|device
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
comment|// on touch-pads, send all touch points to the same widget
name|w
operator|=
name|d
operator|->
name|activeTouchPoints
operator|.
name|isEmpty
argument_list|()
condition|?
name|QPointer
argument_list|<
name|QWindow
argument_list|>
argument_list|()
else|:
name|d
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
operator|.
name|value
argument_list|()
operator|.
name|window
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|w
condition|)
block|{
comment|// determine which window this event will go to
if|if
condition|(
operator|!
name|window
condition|)
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
continue|continue;
name|w
operator|=
name|window
expr_stmt|;
block|}
name|touchInfo
operator|.
name|window
operator|=
name|w
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
name|touchInfo
operator|.
name|touchPoint
operator|=
name|touchPoint
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|w
operator|=
name|touchInfo
operator|.
name|window
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
name|previousTouchPoint
operator|=
name|touchInfo
operator|.
name|touchPoint
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|0.
argument_list|)
expr_stmt|;
break|break;
default|default:
name|w
operator|=
name|touchInfo
operator|.
name|window
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
name|previousTouchPoint
operator|=
name|touchInfo
operator|.
name|touchPoint
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
comment|// Stationary points might not be delivered down to the receiving item
comment|// and get their position transformed, keep the old values instead.
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|!=
name|Qt
operator|::
name|TouchPointStationary
condition|)
name|touchInfo
operator|.
name|touchPoint
operator|=
name|touchPoint
expr_stmt|;
break|break;
block|}
name|Q_ASSERT
argument_list|(
name|w
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// make the *scene* functions return the same as the *screen* functions
name|touchPoint
operator|.
name|d
operator|->
name|sceneRect
operator|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScenePos
operator|=
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScenePos
operator|=
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
expr_stmt|;
name|StatesAndTouchPoints
modifier|&
name|maskAndPoints
init|=
name|windowsNeedingEvents
index|[
name|w
operator|.
name|data
argument_list|()
index|]
decl_stmt|;
name|maskAndPoints
operator|.
name|first
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
name|maskAndPoints
operator|.
name|second
operator|.
name|append
argument_list|(
name|touchPoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|windowsNeedingEvents
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|windowsNeedingEvents
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|end
init|=
name|windowsNeedingEvents
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|QEvent
operator|::
name|Type
name|eventType
decl_stmt|;
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchBegin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchEnd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointStationary
case|:
comment|// don't send the event if nothing changed
continue|continue;
default|default:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchUpdate
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow touch events through
continue|continue;
block|}
name|QTouchEvent
name|touchEvent
argument_list|(
name|eventType
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|second
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|w
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pointCount
init|=
name|touchEvent
operator|.
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|.
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
comment|// preserve the sub-pixel resolution
name|QRectF
name|rect
init|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|screenPos
init|=
name|rect
operator|.
name|center
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|delta
init|=
name|screenPos
operator|-
name|screenPos
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|screenPos
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointPressed
condition|)
block|{
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|synthetic
operator|&&
operator|!
name|touchEvent
operator|.
name|isAccepted
argument_list|()
operator|&&
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_SynthesizeMouseForUnhandledTouchEvents
argument_list|)
condition|)
block|{
comment|// exclude touchpads as those generate their own mouse events
if|if
condition|(
name|touchEvent
operator|.
name|device
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
name|Qt
operator|::
name|MouseButtons
name|b
init|=
name|eventType
operator|==
name|QEvent
operator|::
name|TouchEnd
condition|?
name|Qt
operator|::
name|NoButton
else|:
name|Qt
operator|::
name|LeftButton
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|Qt
operator|::
name|NoButton
condition|)
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|touchEvent
operator|.
name|touchPoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventType
operator|==
name|QEvent
operator|::
name|TouchBegin
condition|)
name|m_fakeMouseSourcePointId
operator|=
name|touchPoints
operator|.
name|first
argument_list|()
operator|.
name|id
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|id
argument_list|()
operator|==
name|m_fakeMouseSourcePointId
condition|)
block|{
if|if
condition|(
name|b
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|insert
argument_list|(
name|w
argument_list|,
name|SynthesizedMouseData
argument_list|(
name|touchPoint
operator|.
name|pos
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
name|fake
argument_list|(
name|w
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|touchPoint
operator|.
name|pos
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|,
name|b
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|fake
operator|.
name|synthetic
operator|=
literal|true
expr_stmt|;
name|processMouseEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|// Remove released points from the hash table only after the event is
comment|// delivered. When the receiver is a widget, QApplication will access
comment|// activeTouchPoints during delivery and therefore nothing can be removed
comment|// before sending the event.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|points
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|e
operator|->
name|points
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
name|d
operator|->
name|activeTouchPoints
operator|.
name|remove
argument_list|(
name|ActiveTouchPointsKey
argument_list|(
name|e
operator|->
name|device
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|reportScreenOrientationChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientationEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
operator|=
name|e
operator|->
name|orientation
expr_stmt|;
name|updateFilteredScreenOrientation
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateFilteredScreenOrientation
name|void
name|QGuiApplicationPrivate
operator|::
name|updateFilteredScreenOrientation
parameter_list|(
name|QScreen
modifier|*
name|s
parameter_list|)
block|{
name|Qt
operator|::
name|ScreenOrientation
name|o
init|=
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
name|o
operator|=
name|s
operator|->
name|primaryOrientation
argument_list|()
expr_stmt|;
name|o
operator|=
name|Qt
operator|::
name|ScreenOrientation
argument_list|(
name|o
operator|&
name|s
operator|->
name|orientationUpdateMask
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
return|return;
if|if
condition|(
name|o
operator|==
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|filteredOrientation
condition|)
return|return;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|filteredOrientation
operator|=
name|o
expr_stmt|;
name|reportScreenOrientationChange
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reportScreenOrientationChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
parameter_list|(
name|QScreen
modifier|*
name|s
parameter_list|)
block|{
emit|emit
name|s
operator|->
name|orientationChanged
argument_list|(
name|s
operator|->
name|orientation
argument_list|()
argument_list|)
emit|;
name|QScreenOrientationChangeEvent
name|event
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|orientation
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reportGeometryChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportGeometryChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometryEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
operator|=
name|e
operator|->
name|geometry
expr_stmt|;
name|Qt
operator|::
name|ScreenOrientation
name|primaryOrientation
init|=
name|s
operator|->
name|primaryOrientation
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|updatePrimaryOrientation
argument_list|()
expr_stmt|;
emit|emit
name|s
operator|->
name|geometryChanged
argument_list|(
name|s
operator|->
name|geometry
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|physicalSizeChanged
argument_list|(
name|s
operator|->
name|physicalSize
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|physicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|physicalDotsPerInch
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|logicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|logicalDotsPerInch
argument_list|()
argument_list|)
emit|;
foreach|foreach
control|(
name|QScreen
modifier|*
name|sibling
decl|,
name|s
operator|->
name|virtualSiblings
argument_list|()
control|)
emit|emit
name|sibling
operator|->
name|virtualGeometryChanged
argument_list|(
name|sibling
operator|->
name|virtualGeometry
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|s
operator|->
name|primaryOrientation
argument_list|()
operator|!=
name|primaryOrientation
condition|)
emit|emit
name|s
operator|->
name|primaryOrientationChanged
argument_list|(
name|s
operator|->
name|primaryOrientation
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
name|updateFilteredScreenOrientation
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reportAvailableGeometryChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportAvailableGeometryChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenAvailableGeometryEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|availableGeometry
operator|=
name|e
operator|->
name|availableGeometry
expr_stmt|;
foreach|foreach
control|(
name|QScreen
modifier|*
name|sibling
decl|,
name|s
operator|->
name|virtualSiblings
argument_list|()
control|)
emit|emit
name|sibling
operator|->
name|virtualGeometryChanged
argument_list|(
name|sibling
operator|->
name|virtualGeometry
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|reportLogicalDotsPerInchChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportLogicalDotsPerInchChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInchEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|logicalDpi
operator|=
name|QDpi
argument_list|(
name|e
operator|->
name|dpiX
argument_list|,
name|e
operator|->
name|dpiY
argument_list|)
expr_stmt|;
emit|emit
name|s
operator|->
name|logicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|logicalDotsPerInch
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|reportRefreshRateChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportRefreshRateChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRateEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|refreshRate
operator|=
name|e
operator|->
name|rate
expr_stmt|;
emit|emit
name|s
operator|->
name|refreshRateChanged
argument_list|(
name|s
operator|->
name|refreshRate
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|processExposeEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processExposeEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ExposeEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|exposed
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|exposed
operator|.
name|data
argument_list|()
decl_stmt|;
name|QWindowPrivate
modifier|*
name|p
init|=
name|qt_window_private
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|receivedExpose
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|resizeEventPending
condition|)
block|{
comment|// as a convenience for plugins, send a resize event before the first expose event if they haven't done so
name|QSize
name|size
init|=
name|p
operator|->
name|geometry
operator|.
name|size
argument_list|()
decl_stmt|;
name|QResizeEvent
name|e
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|p
operator|->
name|resizeEventPending
operator|=
literal|false
expr_stmt|;
block|}
name|p
operator|->
name|receivedExpose
operator|=
literal|true
expr_stmt|;
block|}
name|p
operator|->
name|exposed
operator|=
name|e
operator|->
name|isExposed
expr_stmt|;
name|QExposeEvent
name|exposeEvent
argument_list|(
name|e
operator|->
name|region
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|exposeEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_function
DECL|function|processDrag
name|QPlatformDragQtResponse
name|QGuiApplicationPrivate
operator|::
name|processDrag
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|dropData
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|Qt
operator|::
name|DropActions
name|supportedActions
parameter_list|)
block|{
specifier|static
name|QPointer
argument_list|<
name|QWindow
argument_list|>
name|currentDragWindow
decl_stmt|;
specifier|static
name|Qt
operator|::
name|DropAction
name|lastAcceptedDropAction
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
name|QPlatformDrag
modifier|*
name|platformDrag
init|=
name|platformIntegration
argument_list|()
operator|->
name|drag
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|platformDrag
condition|)
block|{
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
literal|false
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|QRect
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dropData
condition|)
block|{
if|if
condition|(
name|currentDragWindow
operator|.
name|data
argument_list|()
operator|==
name|w
condition|)
name|currentDragWindow
operator|=
literal|0
expr_stmt|;
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
literal|false
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|QRect
argument_list|()
argument_list|)
return|;
block|}
name|QDragMoveEvent
name|me
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|currentDragWindow
condition|)
block|{
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
if|if
condition|(
name|currentDragWindow
condition|)
block|{
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentDragWindow
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|currentDragWindow
operator|=
name|w
expr_stmt|;
name|QDragEnterEvent
name|e
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|isAccepted
argument_list|()
operator|&&
name|e
operator|.
name|dropAction
argument_list|()
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
name|lastAcceptedDropAction
operator|=
name|e
operator|.
name|dropAction
argument_list|()
expr_stmt|;
block|}
comment|// Handling 'DragEnter' should suffice for the application.
if|if
condition|(
name|lastAcceptedDropAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
operator|&&
operator|(
name|supportedActions
operator|&
name|lastAcceptedDropAction
operator|)
condition|)
block|{
name|me
operator|.
name|setDropAction
argument_list|(
name|lastAcceptedDropAction
argument_list|)
expr_stmt|;
name|me
operator|.
name|accept
argument_list|()
expr_stmt|;
block|}
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|me
argument_list|)
expr_stmt|;
name|lastAcceptedDropAction
operator|=
name|me
operator|.
name|isAccepted
argument_list|()
condition|?
name|me
operator|.
name|dropAction
argument_list|()
else|:
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
name|me
operator|.
name|isAccepted
argument_list|()
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|me
operator|.
name|answerRect
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|processDrop
name|QPlatformDropQtResponse
name|QGuiApplicationPrivate
operator|::
name|processDrop
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|dropData
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|Qt
operator|::
name|DropActions
name|supportedActions
parameter_list|)
block|{
name|QDropEvent
name|de
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|DropAction
name|acceptedAction
init|=
name|de
operator|.
name|isAccepted
argument_list|()
condition|?
name|de
operator|.
name|dropAction
argument_list|()
else|:
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
name|QPlatformDropQtResponse
name|response
argument_list|(
name|de
operator|.
name|isAccepted
argument_list|()
argument_list|,
name|acceptedAction
argument_list|)
decl_stmt|;
return|return
name|response
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_comment
comment|/*!     Returns the object for interacting with the clipboard. */
end_comment
begin_function
DECL|function|clipboard
name|QClipboard
modifier|*
name|QGuiApplication
operator|::
name|clipboard
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qApp
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGuiApplication: Must construct a QGuiApplication before accessing a QClipboard"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|=
operator|new
name|QClipboard
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the default application palette.      \sa setPalette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QGuiApplication
operator|::
name|palette
parameter_list|()
block|{
name|initPalette
argument_list|()
expr_stmt|;
return|return
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application palette to \a pal.      \sa palette() */
end_comment
begin_function
DECL|function|setPalette
name|void
name|QGuiApplication
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|)
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|&&
name|pal
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
else|else
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
name|pal
expr_stmt|;
name|applicationResourceFlags
operator||=
name|ApplicationPaletteExplicitlySet
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default application font.      \sa setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGuiApplication
operator|::
name|font
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
name|initFontUnlocked
argument_list|()
expr_stmt|;
return|return
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_font
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application font to \a font.      \sa font() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QGuiApplication
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
name|font
expr_stmt|;
name|applicationResourceFlags
operator||=
name|ApplicationFontExplicitlySet
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGuiApplication::isRightToLeft()      Returns true if the application's layout direction is     Qt::RightToLeft; otherwise returns false.      \sa layoutDirection(), isLeftToRight() */
end_comment
begin_comment
comment|/*!     \fn bool QGuiApplication::isLeftToRight()      Returns true if the application's layout direction is     Qt::LeftToRight; otherwise returns false.      \sa layoutDirection(), isRightToLeft() */
end_comment
begin_function
DECL|function|notifyLayoutDirectionChange
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyLayoutDirectionChange
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|notifyActiveWindowChange
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyActiveWindowChange
parameter_list|(
name|QWindow
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \property QGuiApplication::quitOnLastWindowClosed      \brief whether the application implicitly quits when the last window is     closed.      The default is true.      If this property is true, the applications quits when the last visible     primary window (i.e. window with no parent) is closed.      \sa quit(), QWindow::close()  */
end_comment
begin_function
DECL|function|setQuitOnLastWindowClosed
name|void
name|QGuiApplication
operator|::
name|setQuitOnLastWindowClosed
parameter_list|(
name|bool
name|quit
parameter_list|)
block|{
name|QCoreApplication
operator|::
name|setQuitLockEnabled
argument_list|(
name|quit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|quitOnLastWindowClosed
name|bool
name|QGuiApplication
operator|::
name|quitOnLastWindowClosed
parameter_list|()
block|{
return|return
name|QCoreApplication
operator|::
name|isQuitLockEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::lastWindowClosed()      This signal is emitted from exec() when the last visible     primary window (i.e. window with no parent) is closed.      By default, QGuiApplication quits after this signal is emitted. This feature     can be turned off by setting \l quitOnLastWindowClosed to false.      \sa QWindow::close(), QWindow::isTopLevel() */
end_comment
begin_function
DECL|function|emitLastWindowClosed
name|void
name|QGuiApplicationPrivate
operator|::
name|emitLastWindowClosed
parameter_list|()
block|{
if|if
condition|(
name|qGuiApp
operator|&&
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
condition|)
block|{
emit|emit
name|qGuiApp
operator|->
name|lastWindowClosed
argument_list|()
emit|;
block|}
block|}
end_function
begin_function
DECL|function|shouldQuit
name|bool
name|QGuiApplicationPrivate
operator|::
name|shouldQuit
parameter_list|()
block|{
comment|/* if there is no visible top-level window left, we allow the quit */
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|transientParent
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \fn void QGuiApplication::commitDataRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     emitted when the QSessionManager wants the application to commit all its     data.      Usually this means saving all open files, after getting permission from     the user. Furthermore you may want to provide a means by which the user     can cancel the shutdown.      You should not exit the application within this signal. Instead,     the session manager may or may not do this afterwards, depending on the     context.      \warning Within this signal, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details and example     usage.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), saveStateRequest(), {Session Management} */
end_comment
begin_comment
comment|/*!     \since 4.2     \fn void QGuiApplication::saveStateRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     invoked when the \l{QSessionManager}{session manager} wants the application     to preserve its state for a future session.      For example, a text editor would create a temporary file that includes the     current contents of its edit buffers, the location of the cursor and other     aspects of the current editing session.      You should never exit the application within this signal. Instead, the     session manager may or may not do this afterwards, depending on the     context. Futhermore, most session managers will very likely request a saved     state immediately after the application has been started. This permits the     session manager to learn about the application's restart policy.      \warning Within this signal, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), commitDataRequest(), {Session Management} */
end_comment
begin_comment
comment|/*!     \fn bool QGuiApplication::isSessionRestored() const      Returns true if the application has been restored from an earlier     \l{Session Management}{session}; otherwise returns false.      \sa sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \since 5.0     \fn bool QGuiApplication::isSavingSession() const      Returns true if the application is currently saving the     \l{Session Management}{session}; otherwise returns false.      This is true when commitDataRequest() and saveStateRequest() are emitted,     but also when the windows are closed afterwards by session management.      \sa sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \fn QString QGuiApplication::sessionId() const      Returns the current \l{Session Management}{session's} identifier.      If the application has been restored from an earlier session, this     identifier is the same as it was in that previous session. The session     identifier is guaranteed to be unique both for different applications     and for different instances of the same application.      \sa isSessionRestored(), sessionKey(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \fn QString QGuiApplication::sessionKey() const      Returns the session key in the current \l{Session Management}{session}.      If the application has been restored from an earlier session, this key is     the same as it was when the previous session ended.      The session key changes every time the session is saved. If the shutdown process     is cancelled, another session key will be used when shutting down again.      \sa isSessionRestored(), sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_function
DECL|function|isSessionRestored
name|bool
name|QGuiApplication
operator|::
name|isSessionRestored
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_session_restored
return|;
block|}
end_function
begin_function
DECL|function|sessionId
name|QString
name|QGuiApplication
operator|::
name|sessionId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_id
return|;
block|}
end_function
begin_function
DECL|function|sessionKey
name|QString
name|QGuiApplication
operator|::
name|sessionKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_key
return|;
block|}
end_function
begin_function
DECL|function|isSavingSession
name|bool
name|QGuiApplication
operator|::
name|isSavingSession
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_saving_session
return|;
block|}
end_function
begin_function
DECL|function|commitData
name|void
name|QGuiApplicationPrivate
operator|::
name|commitData
parameter_list|(
name|QSessionManager
modifier|&
name|manager
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|is_saving_session
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|commitDataRequest
argument_list|(
name|manager
argument_list|)
emit|;
if|if
condition|(
name|manager
operator|.
name|allowsInteraction
argument_list|()
condition|)
block|{
name|QWindowList
name|done
decl_stmt|;
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
name|bool
name|cancelled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|cancelled
operator|&&
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|done
operator|.
name|contains
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|cancelled
operator|=
operator|!
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cancelled
condition|)
name|done
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|list
operator|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cancelled
condition|)
name|manager
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
name|is_saving_session
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|saveState
name|void
name|QGuiApplicationPrivate
operator|::
name|saveState
parameter_list|(
name|QSessionManager
modifier|&
name|manager
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|is_saving_session
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|saveStateRequest
argument_list|(
name|manager
argument_list|)
emit|;
name|is_saving_session
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SESSIONMANAGER
end_comment
begin_comment
comment|/*!     \property QGuiApplication::layoutDirection     \brief the default layout direction for this application      On system start-up, the default layout direction depends on the     application's language.      \sa QWidget::layoutDirection, isLeftToRight(), isRightToLeft()  */
end_comment
begin_function
DECL|function|setLayoutDirection
name|void
name|QGuiApplication
operator|::
name|setLayoutDirection
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
if|if
condition|(
name|layout_direction
operator|==
name|direction
operator|||
name|direction
operator|==
name|Qt
operator|::
name|LayoutDirectionAuto
condition|)
return|return;
name|layout_direction
operator|=
name|direction
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|notifyLayoutDirectionChange
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|layoutDirection
name|Qt
operator|::
name|LayoutDirection
name|QGuiApplication
operator|::
name|layoutDirection
parameter_list|()
block|{
return|return
name|layout_direction
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QCursor *QGuiApplication::overrideCursor()      Returns the active application override cursor.      This function returns 0 if no application cursor has been defined (i.e. the     internal cursor stack is empty).      \sa setOverrideCursor(), restoreOverrideCursor() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|overrideCursor
name|QCursor
modifier|*
name|QGuiApplication
operator|::
name|overrideCursor
parameter_list|()
block|{
return|return
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|&
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the currently active application override cursor to \a cursor.      This function has no effect if setOverrideCursor() was not called.      \sa setOverrideCursor(), overrideCursor(), restoreOverrideCursor(),     QWidget::setCursor()  */
end_comment
begin_function
DECL|function|changeOverrideCursor
name|void
name|QGuiApplication
operator|::
name|changeOverrideCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|setOverrideCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|applyCursor
specifier|static
specifier|inline
name|void
name|applyCursor
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
name|QCursor
name|c
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|w
operator|->
name|screen
argument_list|()
condition|)
if|if
condition|(
name|QPlatformCursor
modifier|*
name|cursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
name|cursor
operator|->
name|changeCursor
argument_list|(
operator|&
name|c
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applyCursor
specifier|static
specifier|inline
name|void
name|applyCursor
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QWindow
modifier|*
argument_list|>
modifier|&
name|l
parameter_list|,
specifier|const
name|QCursor
modifier|&
name|c
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|handle
argument_list|()
operator|&&
name|w
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
name|applyCursor
argument_list|(
name|w
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|applyWindowCursor
specifier|static
specifier|inline
name|void
name|applyWindowCursor
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QWindow
modifier|*
argument_list|>
modifier|&
name|l
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|handle
argument_list|()
operator|&&
name|w
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
name|applyCursor
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::setOverrideCursor(const QCursor&cursor)      Sets the application override cursor to \a cursor.      Application override cursors are intended for showing the user that the     application is in a special state, for example during an operation that     might take some time.      This cursor will be displayed in all the application's widgets until     restoreOverrideCursor() or another setOverrideCursor() is called.      Application cursors are stored on an internal stack. setOverrideCursor()     pushes the cursor onto the stack, and restoreOverrideCursor() pops the     active cursor off the stack. changeOverrideCursor() changes the curently     active application override cursor.      Every setOverrideCursor() must eventually be followed by a corresponding     restoreOverrideCursor(), otherwise the stack will never be emptied.      Example:     \snippet code/src_gui_kernel_qapplication_x11.cpp 0      \sa overrideCursor(), restoreOverrideCursor(), changeOverrideCursor(),     QWidget::setCursor() */
end_comment
begin_function
DECL|function|setOverrideCursor
name|void
name|QGuiApplication
operator|::
name|setOverrideCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|prepend
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|applyCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::restoreOverrideCursor()      Undoes the last setOverrideCursor().      If setOverrideCursor() has been called twice, calling     restoreOverrideCursor() will activate the first cursor set. Calling this     function a second time restores the original widgets' cursors.      \sa setOverrideCursor(), overrideCursor() */
end_comment
begin_function
DECL|function|restoreOverrideCursor
name|void
name|QGuiApplication
operator|::
name|restoreOverrideCursor
parameter_list|()
block|{
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QCursor
name|c
argument_list|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|applyCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|applyWindowCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CURSOR
end_comment
begin_comment
comment|/*!   Returns the application's style hints.    The style hints encapsulate a set of platform dependent properties   such as double click intervals, full width selection and others.    The hints can be used to integrate tighter with the underlying platform.    \sa QStyleHints   */
end_comment
begin_function
DECL|function|styleHints
name|QStyleHints
modifier|*
name|QGuiApplication
operator|::
name|styleHints
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|styleHints
condition|)
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|styleHints
operator|=
operator|new
name|QStyleHints
argument_list|()
expr_stmt|;
return|return
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|styleHints
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether Qt should use the system's standard colors, fonts, etc., to     \a on. By default, this is true.      This function must be called before creating the QGuiApplication object, like     this:      \snippet code/src_gui_kernel_qapplication.cpp 6      \sa desktopSettingsAware() */
end_comment
begin_function
DECL|function|setDesktopSettingsAware
name|void
name|QGuiApplication
operator|::
name|setDesktopSettingsAware
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if Qt is set to use the system's standard colors, fonts, etc.;     otherwise returns false. The default is true.      \sa setDesktopSettingsAware() */
end_comment
begin_function
DECL|function|desktopSettingsAware
name|bool
name|QGuiApplication
operator|::
name|desktopSettingsAware
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
return|;
block|}
end_function
begin_comment
comment|/*!   returns the input method.    The input method returns properties about the state and position of   the virtual keyboard. It also provides information about the position of the   current focused input element.    \sa QInputMethod   */
end_comment
begin_function
DECL|function|inputMethod
name|QInputMethod
modifier|*
name|QGuiApplication
operator|::
name|inputMethod
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
condition|)
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
operator|=
operator|new
name|QInputMethod
argument_list|()
expr_stmt|;
return|return
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::fontDatabaseChanged()      This signal is emitted when application fonts are loaded or removed.      \sa QFontDatabase::addApplicationFont(),     QFontDatabase::addApplicationFontFromData(),     QFontDatabase::removeAllApplicationFonts(),     QFontDatabase::removeApplicationFont() */
end_comment
begin_comment
comment|// These pixmaps approximate the images in the Windows User Interface Guidelines.
end_comment
begin_comment
comment|// XPM
end_comment
begin_decl_stmt
DECL|variable|move_xpm
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|move_xpm
index|[]
init|=
block|{
literal|"11 20 3 1"
block|,
literal|".        c None"
block|,
literal|"a        c #FFFFFF"
block|,
literal|"X        c #000000"
block|,
comment|// X11 cursor is traditionally black
literal|"aa........."
block|,
literal|"aXa........"
block|,
literal|"aXXa......."
block|,
literal|"aXXXa......"
block|,
literal|"aXXXXa....."
block|,
literal|"aXXXXXa...."
block|,
literal|"aXXXXXXa..."
block|,
literal|"aXXXXXXXa.."
block|,
literal|"aXXXXXXXXa."
block|,
literal|"aXXXXXXXXXa"
block|,
literal|"aXXXXXXaaaa"
block|,
literal|"aXXXaXXa..."
block|,
literal|"aXXaaXXa..."
block|,
literal|"aXa..aXXa.."
block|,
literal|"aa...aXXa.."
block|,
literal|"a.....aXXa."
block|,
literal|"......aXXa."
block|,
literal|".......aXXa"
block|,
literal|".......aXXa"
block|,
literal|"........aa."
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* XPM */
end_comment
begin_decl_stmt
DECL|variable|copy_xpm
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|copy_xpm
index|[]
init|=
block|{
literal|"24 30 3 1"
block|,
literal|".        c None"
block|,
literal|"a        c #000000"
block|,
literal|"X        c #FFFFFF"
block|,
literal|"XX......................"
block|,
literal|"XaX....................."
block|,
literal|"XaaX...................."
block|,
literal|"XaaaX..................."
block|,
literal|"XaaaaX.................."
block|,
literal|"XaaaaaX................."
block|,
literal|"XaaaaaaX................"
block|,
literal|"XaaaaaaaX..............."
block|,
literal|"XaaaaaaaaX.............."
block|,
literal|"XaaaaaaaaaX............."
block|,
literal|"XaaaaaaXXXX............."
block|,
literal|"XaaaXaaX................"
block|,
literal|"XaaXXaaX................"
block|,
literal|"XaX..XaaX..............."
block|,
literal|"XX...XaaX..............."
block|,
literal|"X.....XaaX.............."
block|,
literal|"......XaaX.............."
block|,
literal|".......XaaX............."
block|,
literal|".......XaaX............."
block|,
literal|"........XX...aaaaaaaaaaa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aXXXXaXXXXa"
block|,
literal|".............aXXXXaXXXXa"
block|,
literal|".............aXXaaaaaXXa"
block|,
literal|".............aXXXXaXXXXa"
block|,
literal|".............aXXXXaXXXXa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aaaaaaaaaaa"
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* XPM */
end_comment
begin_decl_stmt
DECL|variable|link_xpm
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|link_xpm
index|[]
init|=
block|{
literal|"24 30 3 1"
block|,
literal|".        c None"
block|,
literal|"a        c #000000"
block|,
literal|"X        c #FFFFFF"
block|,
literal|"XX......................"
block|,
literal|"XaX....................."
block|,
literal|"XaaX...................."
block|,
literal|"XaaaX..................."
block|,
literal|"XaaaaX.................."
block|,
literal|"XaaaaaX................."
block|,
literal|"XaaaaaaX................"
block|,
literal|"XaaaaaaaX..............."
block|,
literal|"XaaaaaaaaX.............."
block|,
literal|"XaaaaaaaaaX............."
block|,
literal|"XaaaaaaXXXX............."
block|,
literal|"XaaaXaaX................"
block|,
literal|"XaaXXaaX................"
block|,
literal|"XaX..XaaX..............."
block|,
literal|"XX...XaaX..............."
block|,
literal|"X.....XaaX.............."
block|,
literal|"......XaaX.............."
block|,
literal|".......XaaX............."
block|,
literal|".......XaaX............."
block|,
literal|"........XX...aaaaaaaaaaa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aXXXaaaaXXa"
block|,
literal|".............aXXXXaaaXXa"
block|,
literal|".............aXXXaaaaXXa"
block|,
literal|".............aXXaaaXaXXa"
block|,
literal|".............aXXaaXXXXXa"
block|,
literal|".............aXXaXXXXXXa"
block|,
literal|".............aXXXaXXXXXa"
block|,
literal|".............aXXXXXXXXXa"
block|,
literal|".............aaaaaaaaaaa"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|getPixmapCursor
name|QPixmap
name|QGuiApplicationPrivate
operator|::
name|getPixmapCursor
parameter_list|(
name|Qt
operator|::
name|CursorShape
name|cshape
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|cshape
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|notifyThemeChanged
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyThemeChanged
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|applicationResourceFlags
operator|&
name|ApplicationPaletteExplicitlySet
operator|)
condition|)
block|{
name|clearPalette
argument_list|()
expr_stmt|;
name|initPalette
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|applicationResourceFlags
operator|&
name|ApplicationFontExplicitlySet
operator|)
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
name|clearFontUnlocked
argument_list|()
expr_stmt|;
name|initFontUnlocked
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_function
DECL|function|notifyDragStarted
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyDragStarted
parameter_list|(
specifier|const
name|QDrag
modifier|*
name|drag
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|drag
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|gammaTables
specifier|const
name|QDrawHelperGammaTables
modifier|*
name|QGuiApplicationPrivate
operator|::
name|gammaTables
parameter_list|()
block|{
name|QDrawHelperGammaTables
modifier|*
name|result
init|=
name|m_gammaTables
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|QDrawHelperGammaTables
modifier|*
name|tables
init|=
operator|new
name|QDrawHelperGammaTables
argument_list|(
name|fontSmoothingGamma
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_gammaTables
operator|.
name|testAndSetRelease
argument_list|(
literal|0
argument_list|,
name|tables
argument_list|)
condition|)
operator|delete
name|tables
expr_stmt|;
name|result
operator|=
name|m_gammaTables
operator|.
name|load
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|_q_updateFocusObject
name|void
name|QGuiApplicationPrivate
operator|::
name|_q_updateFocusObject
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|bool
name|enabled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|QInputMethodQueryEvent
name|query
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|object
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|query
operator|.
name|value
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
operator|.
name|toBool
argument_list|()
expr_stmt|;
block|}
name|QPlatformInputContextPrivate
operator|::
name|setInputMethodAccepted
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
name|QPlatformInputContext
modifier|*
name|inputContext
init|=
name|platformIntegration
argument_list|()
operator|->
name|inputContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputContext
condition|)
name|inputContext
operator|->
name|setFocusObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|focusObjectChanged
argument_list|(
name|object
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|mouseEventCaps
name|int
name|QGuiApplicationPrivate
operator|::
name|mouseEventCaps
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|event
operator|->
name|caps
return|;
block|}
end_function
begin_function
DECL|function|mouseEventVelocity
name|QVector2D
name|QGuiApplicationPrivate
operator|::
name|mouseEventVelocity
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|event
operator|->
name|velocity
return|;
block|}
end_function
begin_function
DECL|function|setMouseEventCapsAndVelocity
name|void
name|QGuiApplicationPrivate
operator|::
name|setMouseEventCapsAndVelocity
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|int
name|caps
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|velocity
parameter_list|)
block|{
name|event
operator|->
name|caps
operator|=
name|caps
expr_stmt|;
name|event
operator|->
name|velocity
operator|=
name|velocity
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMouseEventCapsAndVelocity
name|void
name|QGuiApplicationPrivate
operator|::
name|setMouseEventCapsAndVelocity
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|QMouseEvent
modifier|*
name|other
parameter_list|)
block|{
name|event
operator|->
name|caps
operator|=
name|other
operator|->
name|caps
expr_stmt|;
name|event
operator|->
name|velocity
operator|=
name|other
operator|->
name|velocity
expr_stmt|;
block|}
end_function
begin_include
include|#
directive|include
file|"moc_qguiapplication.cpp"
end_include
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
