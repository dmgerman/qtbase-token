begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qguiapplication.h"
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegrationfactory_p.h>
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"qfont.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformfontdatabase.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformwindow.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformnativeinterface.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformtheme.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformdrag.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QAbstractEventDispatcher>
end_include
begin_include
include|#
directive|include
file|<QtCore/QVariant>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qcoreapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qabstracteventdispatcher_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qlibraryinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qnumeric.h>
end_include
begin_include
include|#
directive|include
file|<QtDebug>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qpalette.h>
end_include
begin_include
include|#
directive|include
file|<qscreen.h>
end_include
begin_include
include|#
directive|include
file|"qsessionmanager.h"
end_include
begin_include
include|#
directive|include
file|<private/qscreen_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qgenericpluginfactory.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qstylehints.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatforminputcontext.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatforminputcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface_p.h>
end_include
begin_include
include|#
directive|include
file|"private/qwindow_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qcursor_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qopenglcontext_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qinputdevicemanager_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdnd_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformthemefactory_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_include
include|#
directive|include
file|<qpa/qplatformcursor.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtGui/QPixmap>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_include
include|#
directive|include
file|<QtGui/QClipboard>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/QLibrary>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|"private/qcore_mac_p.h"
end_include
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_elif
begin_include
include|#
directive|include
file|<QtCore/qt_windows.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QLibraryInfo>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WIN&& !Q_OS_WINCE
end_comment
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// Helper macro for static functions to check on the existence of the application class.
DECL|macro|CHECK_QAPP_INSTANCE
define|#
directive|define
name|CHECK_QAPP_INSTANCE
parameter_list|(
modifier|...
parameter_list|)
define|\
value|if (Q_LIKELY(QCoreApplication::instance())) { \     } else { \         qWarning("Must construct a QGuiApplication first."); \         return __VA_ARGS__; \     }
DECL|variable|qt_is_gui_used
name|Q_GUI_EXPORT
name|bool
name|qt_is_gui_used
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mouse_buttons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplicationPrivate
operator|::
name|mouse_buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|modifier_buttons
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplicationPrivate
operator|::
name|modifier_buttons
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QPointF
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
argument_list|(
name|qInf
argument_list|()
argument_list|,
name|qInf
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|tabletState
name|Qt
operator|::
name|MouseButtons
name|QGuiApplicationPrivate
operator|::
name|tabletState
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|tabletPressTarget
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|tabletPressTarget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|currentMouseWindow
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|currentMouseWindow
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|applicationState
name|Qt
operator|::
name|ApplicationState
name|QGuiApplicationPrivate
operator|::
name|applicationState
init|=
name|Qt
operator|::
name|ApplicationInactive
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_integration
name|QPlatformIntegration
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_integration
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_theme
name|QPlatformTheme
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_theme
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|generic_plugin_list
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|QGuiApplicationPrivate
operator|::
name|generic_plugin_list
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|ApplicationResourceFlags
enum|enum
name|ApplicationResourceFlags
block|{
DECL|enumerator|ApplicationPaletteExplicitlySet
name|ApplicationPaletteExplicitlySet
init|=
literal|0x1
block|,
DECL|enumerator|ApplicationFontExplicitlySet
name|ApplicationFontExplicitlySet
init|=
literal|0x2
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|applicationResourceFlags
specifier|static
name|unsigned
name|applicationResourceFlags
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_icon
name|QIcon
modifier|*
name|QGuiApplicationPrivate
operator|::
name|app_icon
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|platform_name
name|QString
modifier|*
name|QGuiApplicationPrivate
operator|::
name|platform_name
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|displayName
name|QString
modifier|*
name|QGuiApplicationPrivate
operator|::
name|displayName
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_pal
name|QPalette
modifier|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_pal
comment|// default application palette
end_comment
begin_decl_stmt
DECL|member|buttons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplicationPrivate
operator|::
name|buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressTime
name|ulong
name|QGuiApplicationPrivate
operator|::
name|mousePressTime
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressButton
name|Qt
operator|::
name|MouseButton
name|QGuiApplicationPrivate
operator|::
name|mousePressButton
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressX
name|int
name|QGuiApplicationPrivate
operator|::
name|mousePressX
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mousePressY
name|int
name|QGuiApplicationPrivate
operator|::
name|mousePressY
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|mouse_double_click_distance
name|int
name|QGuiApplicationPrivate
operator|::
name|mouse_double_click_distance
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|currentMousePressWindow
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|currentMousePressWindow
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|layout_direction
specifier|static
name|Qt
operator|::
name|LayoutDirection
name|layout_direction
init|=
name|Qt
operator|::
name|LeftToRight
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_reverse
specifier|static
name|bool
name|force_reverse
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|self
name|QGuiApplicationPrivate
modifier|*
name|QGuiApplicationPrivate
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_fakeTouchDevice
name|QTouchDevice
modifier|*
name|QGuiApplicationPrivate
operator|::
name|m_fakeTouchDevice
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_fakeMouseSourcePointId
name|int
name|QGuiApplicationPrivate
operator|::
name|m_fakeMouseSourcePointId
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_decl_stmt
DECL|member|qt_clipboard
name|QClipboard
modifier|*
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|screen_list
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|QGuiApplicationPrivate
operator|::
name|screen_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|window_list
name|QWindowList
name|QGuiApplicationPrivate
operator|::
name|window_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|focus_window
name|QWindow
modifier|*
name|QGuiApplicationPrivate
operator|::
name|focus_window
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|applicationFontMutex
specifier|static
name|QBasicMutex
name|applicationFontMutex
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_font
name|QFont
modifier|*
name|QGuiApplicationPrivate
operator|::
name|app_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|styleHints
name|QStyleHints
modifier|*
name|QGuiApplicationPrivate
operator|::
name|styleHints
init|=
name|Q_NULLPTR
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|obey_desktop_settings
name|bool
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_inputDeviceManager
name|QInputDeviceManager
modifier|*
name|QGuiApplicationPrivate
operator|::
name|m_inputDeviceManager
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fontSmoothingGamma
specifier|static
name|qreal
name|fontSmoothingGamma
init|=
literal|1.7
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
name|void
name|qRegisterGuiVariant
parameter_list|()
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_function_decl
specifier|extern
name|void
name|qRegisterGuiGetInterpolator
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|extern
name|void
name|qInitBlendFunctions
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qInitDrawhelperAsm
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qInitImageConversions
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qt_detectRTLLanguage
specifier|static
name|bool
name|qt_detectRTLLanguage
parameter_list|()
block|{
return|return
name|force_reverse
operator|^
operator|(
name|QGuiApplication
operator|::
name|tr
argument_list|(
literal|"QT_LAYOUT_DIRECTION"
argument_list|,
literal|"Translate this string to the string 'LTR' in left-to-right"
literal|" languages or to 'RTL' in right-to-left languages (such as Hebrew"
literal|" and Arabic) to get proper widget layout."
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"RTL"
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|initPalette
specifier|static
name|void
name|initPalette
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
if|if
condition|(
specifier|const
name|QPalette
modifier|*
name|themePalette
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
operator|->
name|palette
argument_list|()
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
operator|*
name|themePalette
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|Qt
operator|::
name|gray
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearPalette
specifier|static
specifier|inline
name|void
name|clearPalette
parameter_list|()
block|{
operator|delete
name|QGuiApplicationPrivate
operator|::
name|app_pal
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initFontUnlocked
specifier|static
name|void
name|initFontUnlocked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
block|{
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
if|if
condition|(
specifier|const
name|QFont
modifier|*
name|font
init|=
name|theme
operator|->
name|font
argument_list|(
name|QPlatformTheme
operator|::
name|SystemFont
argument_list|)
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
operator|*
name|font
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|fontDatabase
argument_list|()
operator|->
name|defaultFont
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearFontUnlocked
specifier|static
specifier|inline
name|void
name|clearFontUnlocked
parameter_list|()
block|{
operator|delete
name|QGuiApplicationPrivate
operator|::
name|app_font
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// Geometry specification for top level windows following the convention of the
end_comment
begin_comment
comment|// -geometry command line arguments in X11 (see XParseGeometry).
end_comment
begin_struct
DECL|struct|QWindowGeometrySpecification
struct|struct
name|QWindowGeometrySpecification
block|{
DECL|function|QWindowGeometrySpecification
name|QWindowGeometrySpecification
parameter_list|()
member_init_list|:
name|corner
argument_list|(
name|Qt
operator|::
name|TopLeftCorner
argument_list|)
member_init_list|,
name|xOffset
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|yOffset
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|width
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|height
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
specifier|static
name|QWindowGeometrySpecification
name|fromArgument
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|)
function_decl|;
name|void
name|applyTo
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
specifier|const
function_decl|;
DECL|member|corner
name|Qt
operator|::
name|Corner
name|corner
decl_stmt|;
DECL|member|xOffset
name|int
name|xOffset
decl_stmt|;
DECL|member|yOffset
name|int
name|yOffset
decl_stmt|;
DECL|member|width
name|int
name|width
decl_stmt|;
DECL|member|height
name|int
name|height
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// Parse a token of a X11 geometry specification "200x100+10-20".
end_comment
begin_function
DECL|function|nextGeometryToken
specifier|static
specifier|inline
name|int
name|nextGeometryToken
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|,
name|int
modifier|&
name|pos
parameter_list|,
name|char
modifier|*
name|op
parameter_list|)
block|{
operator|*
name|op
operator|=
literal|0
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|size
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op
operator|=
name|a
operator|.
name|at
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|==
literal|'+'
operator|||
operator|*
name|op
operator|==
literal|'-'
operator|||
operator|*
name|op
operator|==
literal|'x'
condition|)
name|pos
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|op
argument_list|)
condition|)
operator|*
name|op
operator|=
literal|'x'
expr_stmt|;
comment|// If it starts with a digit, it is supposed to be a width specification.
else|else
return|return
operator|-
literal|1
return|;
specifier|const
name|int
name|numberPos
init|=
name|pos
decl_stmt|;
for|for
control|(
init|;
name|pos
operator|<
name|size
operator|&&
name|isdigit
argument_list|(
name|a
operator|.
name|at
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|;
operator|++
name|pos
control|)
empty_stmt|;
name|bool
name|ok
decl_stmt|;
specifier|const
name|int
name|result
init|=
name|a
operator|.
name|mid
argument_list|(
name|numberPos
argument_list|,
name|pos
operator|-
name|numberPos
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
return|return
name|ok
condition|?
name|result
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fromArgument
name|QWindowGeometrySpecification
name|QWindowGeometrySpecification
operator|::
name|fromArgument
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|)
block|{
name|QWindowGeometrySpecification
name|result
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|char
name|op
decl_stmt|;
specifier|const
name|int
name|value
init|=
name|nextGeometryToken
argument_list|(
name|a
argument_list|,
name|pos
argument_list|,
operator|&
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'x'
case|:
operator|(
name|result
operator|.
name|width
operator|>=
literal|0
condition|?
name|result
operator|.
name|height
else|:
name|result
operator|.
name|width
operator|)
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|result
operator|.
name|xOffset
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|yOffset
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'-'
condition|)
name|result
operator|.
name|corner
operator|=
name|result
operator|.
name|corner
operator|==
name|Qt
operator|::
name|TopRightCorner
condition|?
name|Qt
operator|::
name|BottomRightCorner
else|:
name|Qt
operator|::
name|BottomLeftCorner
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|xOffset
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'-'
condition|)
name|result
operator|.
name|corner
operator|=
name|Qt
operator|::
name|TopRightCorner
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|applyTo
name|void
name|QWindowGeometrySpecification
operator|::
name|applyTo
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
specifier|const
block|{
name|QRect
name|windowGeometry
init|=
name|window
operator|->
name|frameGeometry
argument_list|()
decl_stmt|;
name|QSize
name|size
init|=
name|windowGeometry
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|>=
literal|0
operator|||
name|height
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QSize
name|windowMinimumSize
init|=
name|window
operator|->
name|minimumSize
argument_list|()
decl_stmt|;
specifier|const
name|QSize
name|windowMaximumSize
init|=
name|window
operator|->
name|maximumSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|>=
literal|0
condition|)
name|size
operator|.
name|setWidth
argument_list|(
name|qBound
argument_list|(
name|windowMinimumSize
operator|.
name|width
argument_list|()
argument_list|,
name|width
argument_list|,
name|windowMaximumSize
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|height
operator|>=
literal|0
condition|)
name|size
operator|.
name|setHeight
argument_list|(
name|qBound
argument_list|(
name|windowMinimumSize
operator|.
name|height
argument_list|()
argument_list|,
name|height
argument_list|,
name|windowMaximumSize
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|window
operator|->
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xOffset
operator|>=
literal|0
operator|||
name|yOffset
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QRect
name|availableGeometry
init|=
name|window
operator|->
name|screen
argument_list|()
operator|->
name|virtualGeometry
argument_list|()
decl_stmt|;
name|QPoint
name|topLeft
init|=
name|windowGeometry
operator|.
name|topLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|xOffset
operator|>=
literal|0
condition|)
block|{
name|topLeft
operator|.
name|setX
argument_list|(
name|corner
operator|==
name|Qt
operator|::
name|TopLeftCorner
operator|||
name|corner
operator|==
name|Qt
operator|::
name|BottomLeftCorner
condition|?
name|xOffset
else|:
name|qMax
argument_list|(
name|availableGeometry
operator|.
name|right
argument_list|()
operator|-
name|size
operator|.
name|width
argument_list|()
operator|-
name|xOffset
argument_list|,
name|availableGeometry
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yOffset
operator|>=
literal|0
condition|)
block|{
name|topLeft
operator|.
name|setY
argument_list|(
name|corner
operator|==
name|Qt
operator|::
name|TopLeftCorner
operator|||
name|corner
operator|==
name|Qt
operator|::
name|TopRightCorner
condition|?
name|yOffset
else|:
name|qMax
argument_list|(
name|availableGeometry
operator|.
name|bottom
argument_list|()
operator|-
name|size
operator|.
name|height
argument_list|()
operator|-
name|yOffset
argument_list|,
name|availableGeometry
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|window
operator|->
name|setFramePosition
argument_list|(
name|topLeft
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|windowGeometrySpecification
specifier|static
name|QWindowGeometrySpecification
name|windowGeometrySpecification
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \class QGuiApplication     \brief The QGuiApplication class manages the GUI application's control     flow and main settings.      \inmodule QtGui     \since 5.0      QGuiApplication contains the main event loop, where all events from the window     system and other sources are processed and dispatched. It also handles the     application's initialization and finalization, and provides session management.     In addition, QGuiApplication handles most of the system-wide and application-wide     settings.      For any GUI application using Qt, there is precisely \b one QGuiApplication     object no matter whether the application has 0, 1, 2 or more windows at     any given time. For non-GUI Qt applications, use QCoreApplication instead,     as it does not depend on the Qt GUI module. For QWidget based Qt applications,     use QApplication instead, as it provides some functionality needed for creating     QWidget instances.      The QGuiApplication object is accessible through the instance() function, which     returns a pointer equivalent to the global \l qApp pointer.      QGuiApplication's main areas of responsibility are:         \list             \li  It initializes the application with the user's desktop settings,                 such as palette(), font() and styleHints(). It keeps                 track of these properties in case the user changes the desktop                 globally, for example, through some kind of control panel.              \li  It performs event handling, meaning that it receives events                 from the underlying window system and dispatches them to the                 relevant widgets. You can send your own events to windows by                 using sendEvent() and postEvent().              \li  It parses common command line arguments and sets its internal                 state accordingly. See the \l{QGuiApplication::QGuiApplication()}                 {constructor documentation} below for more details.              \li  It provides localization of strings that are visible to the                 user via translate().              \li  It provides some magical objects like the clipboard().              \li  It knows about the application's windows. You can ask which                 window is at a certain position using topLevelAt(), get a list of                 topLevelWindows(), etc.              \li  It manages the application's mouse cursor handling, see                 setOverrideCursor()              \li  It provides support for sophisticated \l{Session Management}                 {session management}. This makes it possible for applications                 to terminate gracefully when the user logs out, to cancel a                 shutdown process if termination isn't possible and even to                 preserve the entire application's state for a future session.                 See isSessionRestored(), sessionId() and commitDataRequest() and                 saveStateRequest() for details.         \endlist      Since the QGuiApplication object does so much initialization, it \e{must} be     created before any other objects related to the user interface are created.     QGuiApplication also deals with common command line arguments. Hence, it is     usually a good idea to create it \e before any interpretation or     modification of \c argv is done in the application itself.      \table     \header         \li{2,1} Groups of functions          \row         \li  System settings         \li  desktopSettingsAware(),             setDesktopSettingsAware(),             styleHints(),             palette(),             setPalette(),             font(),             setFont().          \row         \li  Event handling         \li  exec(),             processEvents(),             exit(),             quit().             sendEvent(),             postEvent(),             sendPostedEvents(),             removePostedEvents(),             hasPendingEvents(),             notify().          \row         \li  Windows         \li  allWindows(),             topLevelWindows(),             focusWindow(),             clipboard(),             topLevelAt().          \row         \li  Advanced cursor handling         \li  overrideCursor(),             setOverrideCursor(),             restoreOverrideCursor().          \row         \li  Session management         \li  isSessionRestored(),             sessionId(),             commitDataRequest(),             saveStateRequest().          \row         \li  Miscellaneous         \li  startingUp(),             closingDown(),             type().     \endtable      \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop */
end_comment
begin_comment
comment|/*!     Initializes the window system and constructs an application object with     \a argc command line arguments in \a argv.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QGuiApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      The global \c qApp pointer refers to this application object. Only one     application object should be created.      This application object must be constructed before any \l{QPaintDevice}     {paint devices} (including pixmaps, bitmaps etc.).      \note \a argc and \a argv might be changed as Qt removes command line     arguments that it recognizes.      \section1 Supported Command Line Options      All Qt programs automatically support a set of command-line options that     allow modifying the way Qt will interact with the windowing system. Some of     the options are also accessible via environment variables, which are the     preferred form if the application can launch GUI sub-processes or other     applications (environment variables will be inherited by child processes).     When in doubt, use the environment variables.      The options currently supported are the following:     \list          \li \c{-platform} \e {platformName[:options]}, specifies the             \l{Qt Platform Abstraction} (QPA) plugin.              Overridden by the \c QT_QPA_PLATFORM environment variable.         \li \c{-platformpluginpath} \e path, specifies the path to platform             plugins.              Overridden by the \c QT_QPA_PLATFORM_PLUGIN_PATH environment             variable.          \li \c{-platformtheme} \e platformTheme, specifies the platform theme.              Overridden by the \c QT_QPA_PLATFORMTHEME environment variable.          \li \c{-plugin} \e plugin, specifies additional plugins to load. The argument             may appear multiple times.              Overridden by the \c QT_QPA_GENERIC_PLUGINS environment variable.          \li \c{-qmljsdebugger=}, activates the QML/JS debugger with a specified port.             The value must be of format \c{port:1234}\e{[,block]}, where             \e block is optional             and will make the application wait until a debugger connects to it.         \li \c {-qwindowgeometry} \e geometry, specifies window geometry for             the main window using the X11-syntax. For example:             \c {-qwindowgeometry 100x100+50+50}         \li \c {-qwindowicon}, sets the default window icon         \li \c {-qwindowtitle}, sets the title of the first window         \li \c{-reverse}, sets the application's layout direction to             Qt::RightToLeft. This option is intended to aid debugging and should             not be used in production. The default value is automatically detected             from the user's locale (see also QLocale::textDirection()).         \li \c{-session} \e session, restores the application from an earlier             \l{Session Management}{session}.     \endlist      The following standard command line options are available for X11:      \list         \li \c {-display} \e {hostname:screen_number}, switches displays on X11.               Overrides the \c DISPLAY environment variable.         \li \c {-geometry} \e geometry, same as \c {-qwindowgeometry}.     \endlist      \section1 Platform-Specific Arguments      You can specify platform-specific arguments for the \c{-platform} option.     Place them after the platform plugin name following a colon as a     comma-separated list. For example,     \c{-platform windows:dialogs=xp,fontengine=freetype}.      The following parameters are available for \c {-platform windows}:      \list         \li \c {dialogs=[xp|none]}, \c xp uses XP-style native dialogs and             \c none disables them.         \li \c {fontengine=freetype}, uses the FreeType font engine.     \endlist      For more information about the platform-specific arguments available for     embedded Linux platforms, see \l{Qt for Embedded Linux}.      \sa arguments() QGuiApplication::platformName */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_macro
DECL|function|QGuiApplication
name|QGuiApplication
end_macro
begin_expr_stmt
DECL|function|QGuiApplication
operator|::
name|QGuiApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
else|#
directive|else
name|QGuiApplication
operator|::
name|QGuiApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
endif|#
directive|endif
operator|:
name|QCoreApplication
argument_list|(
argument|*new QGuiApplicationPrivate(argc, argv, flags)
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
block|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
block|; }
comment|/*!     \internal */
DECL|function|QGuiApplication
name|QGuiApplication
operator|::
name|QGuiApplication
argument_list|(
name|QGuiApplicationPrivate
operator|&
name|p
argument_list|)
operator|:
name|QCoreApplication
argument_list|(
argument|p
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
block|; }
comment|/*!     Destructs the application. */
DECL|function|~QGuiApplication
name|QGuiApplication
operator|::
name|~
name|QGuiApplication
operator|(
operator|)
block|{
name|Q_D
argument_list|(
name|QGuiApplication
argument_list|)
block|;
name|d
operator|->
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
block|;
name|d
operator|->
name|eventDispatcher
operator|=
literal|0
block|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
operator|delete
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
block|;
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|=
literal|0
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
operator|delete
name|d
operator|->
name|session_manager
block|;
name|d
operator|->
name|session_manager
operator|=
literal|0
block|;
endif|#
directive|endif
comment|//QT_NO_SESSIONMANAGER
name|clearPalette
argument_list|()
block|;
name|QFontDatabase
operator|::
name|removeAllApplicationFonts
argument_list|()
block|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|d
operator|->
name|cursor_list
operator|.
name|clear
argument_list|()
block|;
endif|#
directive|endif
operator|delete
name|QGuiApplicationPrivate
operator|::
name|app_icon
block|;
name|QGuiApplicationPrivate
operator|::
name|app_icon
operator|=
literal|0
block|;
operator|delete
name|QGuiApplicationPrivate
operator|::
name|platform_name
block|;
name|QGuiApplicationPrivate
operator|::
name|platform_name
operator|=
literal|0
block|;
operator|delete
name|QGuiApplicationPrivate
operator|::
name|displayName
block|;
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
literal|0
block|; }
DECL|function|QGuiApplicationPrivate
name|QGuiApplicationPrivate
operator|::
name|QGuiApplicationPrivate
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
operator|:
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|)
operator|,
name|inputMethod
argument_list|(
literal|0
argument_list|)
operator|,
name|lastTouchType
argument_list|(
name|QEvent
operator|::
name|TouchEnd
argument_list|)
operator|,
name|ownGlobalShareContext
argument_list|(
literal|false
argument_list|)
block|{
name|self
operator|=
name|this
block|;
name|application_type
operator|=
name|QCoreApplicationPrivate
operator|::
name|Gui
block|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
name|is_session_restored
operator|=
literal|false
block|;
name|is_saving_session
operator|=
literal|false
block|;
endif|#
directive|endif
block|}
comment|/*!     \property QGuiApplication::applicationDisplayName     \brief the user-visible name of this application     \since 5.0      This name is shown to the user, for instance in window titles.     It can be translated, if necessary.      If not set, the application display name defaults to the application name.      \sa applicationName */
DECL|function|setApplicationDisplayName
name|void
name|QGuiApplication
operator|::
name|setApplicationDisplayName
operator|(
specifier|const
name|QString
operator|&
name|name
operator|)
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|displayName
condition|)
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
operator|new
name|QString
expr_stmt|;
operator|*
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|=
name|name
expr_stmt|;
end_expr_stmt
begin_macro
unit|}  QString
DECL|function|applicationDisplayName
name|QGuiApplication
end_macro
begin_expr_stmt
DECL|function|applicationDisplayName
operator|::
name|applicationDisplayName
operator|(
operator|)
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|?
operator|*
name|QGuiApplicationPrivate
operator|::
name|displayName
operator|:
name|applicationName
argument_list|()
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     Returns the most recently shown modal window. If no modal windows are     visible, this function returns zero.      A modal window is a window which has its     \l{QWindow::modality}{modality} property set to Qt::WindowModal     or Qt::ApplicationModal. A modal window must be closed before the user can     continue with other parts of the program.      Modal window are organized in a stack. This function returns the modal     window at the top of the stack.      \sa Qt::WindowModality, QWindow::setModality() */
end_comment
begin_function
DECL|function|modalWindow
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|modalWindow
parameter_list|()
block|{
name|CHECK_QAPP_INSTANCE
argument_list|(
argument|Q_NULLPTR
argument_list|)
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|modalWindowList
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|updateBlockedStatusRecursion
specifier|static
name|void
name|updateBlockedStatusRecursion
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|bool
name|shouldBeBlocked
parameter_list|)
block|{
name|QWindowPrivate
modifier|*
name|p
init|=
name|qt_window_private
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|blockedByModalWindow
operator|!=
name|shouldBeBlocked
condition|)
block|{
name|p
operator|->
name|blockedByModalWindow
operator|=
name|shouldBeBlocked
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|shouldBeBlocked
condition|?
name|QEvent
operator|::
name|WindowBlocked
else|:
name|QEvent
operator|::
name|WindowUnblocked
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QObject
modifier|*
name|c
decl|,
name|window
operator|->
name|children
argument_list|()
control|)
if|if
condition|(
name|c
operator|->
name|isWindowType
argument_list|()
condition|)
name|updateBlockedStatusRecursion
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|c
argument_list|)
argument_list|,
name|shouldBeBlocked
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateBlockedStatus
name|void
name|QGuiApplicationPrivate
operator|::
name|updateBlockedStatus
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|bool
name|shouldBeBlocked
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|QWindowPrivate
operator|::
name|get
argument_list|(
name|window
argument_list|)
operator|->
name|isPopup
argument_list|()
operator|&&
operator|!
name|self
operator|->
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
name|shouldBeBlocked
operator|=
name|self
operator|->
name|isWindowBlocked
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|updateBlockedStatusRecursion
argument_list|(
name|window
argument_list|,
name|shouldBeBlocked
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|showModalWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|showModalWindow
parameter_list|(
name|QWindow
modifier|*
name|modal
parameter_list|)
block|{
name|self
operator|->
name|modalWindowList
operator|.
name|prepend
argument_list|(
name|modal
argument_list|)
expr_stmt|;
comment|// Send leave for currently entered window if it should be blocked
if|if
condition|(
name|currentMouseWindow
operator|&&
operator|!
name|QWindowPrivate
operator|::
name|get
argument_list|(
name|currentMouseWindow
argument_list|)
operator|->
name|isPopup
argument_list|()
condition|)
block|{
name|bool
name|shouldBeBlocked
init|=
name|self
operator|->
name|isWindowBlocked
argument_list|(
name|currentMouseWindow
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldBeBlocked
condition|)
block|{
comment|// Remove the new window from modalWindowList temporarily so leave can go through
name|self
operator|->
name|modalWindowList
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentMouseWindow
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|self
operator|->
name|modalWindowList
operator|.
name|prepend
argument_list|(
name|modal
argument_list|)
expr_stmt|;
block|}
block|}
name|QWindowList
name|windows
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
name|updateBlockedStatus
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
name|updateBlockedStatus
argument_list|(
name|modal
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hideModalWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|hideModalWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|self
operator|->
name|modalWindowList
operator|.
name|removeAll
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|QWindowList
name|windows
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
name|updateBlockedStatus
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     Returns \c true if \a window is blocked by a modal window. If \a     blockingWindow is non-zero, *blockingWindow will be set to the blocking     window (or to zero if \a window is not blocked). */
end_comment
begin_function
DECL|function|isWindowBlocked
name|bool
name|QGuiApplicationPrivate
operator|::
name|isWindowBlocked
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QWindow
modifier|*
modifier|*
name|blockingWindow
parameter_list|)
specifier|const
block|{
name|QWindow
modifier|*
name|unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|blockingWindow
condition|)
name|blockingWindow
operator|=
operator|&
name|unused
expr_stmt|;
if|if
condition|(
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modalWindowList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|modalWindow
init|=
name|modalWindowList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
block|{
comment|// check if the modal window is our window or a (transient) parent of our window
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|==
name|modalWindow
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
block|}
name|Qt
operator|::
name|WindowModality
name|windowModality
init|=
name|modalWindow
operator|->
name|modality
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|windowModality
condition|)
block|{
case|case
name|Qt
operator|::
name|ApplicationModal
case|:
block|{
if|if
condition|(
name|modalWindow
operator|!=
name|window
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|modalWindow
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
case|case
name|Qt
operator|::
name|WindowModal
case|:
block|{
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
do|do
block|{
name|QWindow
modifier|*
name|m
init|=
name|modalWindow
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|w
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|m
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|m
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|m
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|m
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
break|break;
block|}
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QGuiApplication"
argument_list|,
literal|"internal error, a modal widget cannot be modeless"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QWindow that receives events tied to focus,     such as key events. */
end_comment
begin_function
DECL|function|focusWindow
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|focusWindow
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|focus_window
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::focusObjectChanged(QObject *focusObject)      This signal is emitted when final receiver of events tied to focus is changed.     \a focusObject is the new receiver.      \sa focusObject() */
end_comment
begin_comment
comment|/*!     \fn QGuiApplication::focusWindowChanged(QWindow *focusWindow)      This signal is emitted when the focused window changes.     \a focusWindow is the new focused window.      \sa focusWindow() */
end_comment
begin_comment
comment|/*!     Returns the QObject in currently active window that will be final receiver of events     tied to focus, such as key events.  */
end_comment
begin_function
DECL|function|focusObject
name|QObject
modifier|*
name|QGuiApplication
operator|::
name|focusObject
parameter_list|()
block|{
if|if
condition|(
name|focusWindow
argument_list|()
condition|)
return|return
name|focusWindow
argument_list|()
operator|->
name|focusObject
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::allWindows()      Returns a list of all the windows in the application.      The list is empty if there are no windows.      \sa topLevelWindows()  */
end_comment
begin_function
DECL|function|allWindows
name|QWindowList
name|QGuiApplication
operator|::
name|allWindows
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|window_list
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGuiApplication::topLevelWindows()      Returns a list of the top-level windows in the application.      \sa allWindows()  */
end_comment
begin_function
DECL|function|topLevelWindows
name|QWindowList
name|QGuiApplication
operator|::
name|topLevelWindows
parameter_list|()
block|{
specifier|const
name|QWindowList
modifier|&
name|list
init|=
name|QGuiApplicationPrivate
operator|::
name|window_list
decl_stmt|;
name|QWindowList
name|topLevelWindows
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|parent
argument_list|()
operator|&&
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
comment|// Top windows of embedded QAxServers do not have QWindow parents,
comment|// but they are not true top level windows, so do not include them.
specifier|const
name|bool
name|embedded
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
operator|&&
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
operator|->
name|isEmbedded
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|embedded
condition|)
name|topLevelWindows
operator|.
name|prepend
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|topLevelWindows
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary (or default) screen of the application, or null if there is none      This will be the screen where QWindows are initially shown, unless otherwise specified.      On some platforms, it may be null when there are actually no screens connected.     It is not possible to start a new QGuiApplication while there are no screens.     Applications which were running at the time the primary screen was removed     will stop rendering graphics until one or more screens are restored. */
end_comment
begin_function
DECL|function|primaryScreen
name|QScreen
modifier|*
name|QGuiApplication
operator|::
name|primaryScreen
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|screen_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|QGuiApplicationPrivate
operator|::
name|screen_list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the screens associated with the     windowing system the application is connected to. */
end_comment
begin_function
DECL|function|screens
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|QGuiApplication
operator|::
name|screens
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|screen_list
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::screenAdded(QScreen *screen)      This signal is emitted whenever a new screen \a screen has been added to the system.      \sa screens(), primaryScreen(), screenRemoved() */
end_comment
begin_comment
comment|/*!     \fn void QGuiApplication::screenRemoved(QScreen *screen)      This signal is emitted whenever a \a screen is removed from the system. It     provides an opportunity to manage the windows on the screen before Qt falls back     to moving them to the primary screen.      \sa screens(), screenAdded(), QObject::destroyed(), QWindow::setScreen()      \since 5.4 */
end_comment
begin_comment
comment|/*!     Returns the highest screen device pixel ratio found on     the system. This is the ratio between physical pixels and     device-independent pixels.      Use this function only when you don't know which window you are targeting.     If you do know the target window, use QWindow::devicePixelRatio() instead.      \sa QWindow::devicePixelRatio() */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QGuiApplication
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
comment|// Cache topDevicePixelRatio, iterate through the screen list once only.
specifier|static
name|qreal
name|topDevicePixelRatio
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|topDevicePixelRatio
argument_list|)
condition|)
block|{
return|return
name|topDevicePixelRatio
return|;
block|}
name|topDevicePixelRatio
operator|=
literal|1.0
expr_stmt|;
comment|// make sure we never return 0.
foreach|foreach
control|(
name|QScreen
modifier|*
name|screen
decl|,
name|QGuiApplicationPrivate
operator|::
name|screen_list
control|)
block|{
name|topDevicePixelRatio
operator|=
name|qMax
argument_list|(
name|topDevicePixelRatio
argument_list|,
name|screen
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|topDevicePixelRatio
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the top level window at the given position \a pos, if any. */
end_comment
begin_function
DECL|function|topLevelAt
name|QWindow
modifier|*
name|QGuiApplication
operator|::
name|topLevelAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|screens
init|=
name|QGuiApplication
operator|::
name|screens
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
operator|::
name|const_iterator
name|screen
init|=
name|screens
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
operator|::
name|const_iterator
name|end
init|=
name|screens
operator|.
name|constEnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|screen
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|screen
operator|)
operator|->
name|geometry
argument_list|()
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return
operator|(
operator|*
name|screen
operator|)
operator|->
name|handle
argument_list|()
operator|->
name|topLevelAt
argument_list|(
name|pos
argument_list|)
return|;
operator|++
name|screen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGuiApplication::platformName     \brief The name of the underlying platform plugin.      The QPA platform plugins are located in \c {qtbase\src\plugins\platforms}.     At the time of writing, the following platform plugin names are supported:      \list         \li \c android         \li \c cocoa is a platform plugin for OS X.         \li \c directfb         \li \c eglfs is a platform plugin for running Qt5 applications on top of             EGL and  OpenGL ES 2.0 without an actual windowing system (like X11             or Wayland). For more information, see \l{EGLFS}.         \li \c ios         \li \c kms is an experimental platform plugin using kernel modesetting             and \l{http://dri.freedesktop.org/wiki/DRM}{DRM} (Direct Rendering             Manager).         \li \c linuxfb writes directly to the framebuffer. For more information,             see \l{LinuxFB}.         \li \c minimal is provided as an examples for developers who want to             write their own platform plugins. However, you can use the plugin to             run GUI applications in environments without a GUI, such as servers.         \li \c minimalegl is an example plugin.         \li \c offscreen         \li \c openwfd         \li \c qnx         \li \c windows         \li \c xcb is the X11 plugin used on regular desktop Linux platforms.     \endlist      For more information about the platform plugins for embedded Linux devices,     see \l{Qt for Embedded Linux}. */
end_comment
begin_function
DECL|function|platformName
name|QString
name|QGuiApplication
operator|::
name|platformName
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|platform_name
condition|?
operator|*
name|QGuiApplicationPrivate
operator|::
name|platform_name
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|init_platform
specifier|static
name|void
name|init_platform
parameter_list|(
specifier|const
name|QString
modifier|&
name|pluginArgument
parameter_list|,
specifier|const
name|QString
modifier|&
name|platformPluginPath
parameter_list|,
specifier|const
name|QString
modifier|&
name|platformThemeName
parameter_list|,
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|// Split into platform name and arguments
name|QStringList
name|arguments
init|=
name|pluginArgument
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|name
init|=
name|arguments
operator|.
name|takeFirst
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QString
name|argumentsKey
init|=
name|name
decl_stmt|;
name|argumentsKey
index|[
literal|0
index|]
operator|=
name|argumentsKey
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|arguments
operator|.
name|append
argument_list|(
name|QLibraryInfo
operator|::
name|platformPluginArguments
argument_list|(
name|argumentsKey
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create the platform integration.
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|=
name|QPlatformIntegrationFactory
operator|::
name|create
argument_list|(
name|name
argument_list|,
name|arguments
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|platformPluginPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_integration
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_name
operator|=
operator|new
name|QString
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|keys
init|=
name|QPlatformIntegrationFactory
operator|::
name|keys
argument_list|(
name|platformPluginPath
argument_list|)
decl_stmt|;
name|QString
name|fatalMessage
init|=
name|QStringLiteral
argument_list|(
literal|"This application failed to start because it could not find or load the Qt platform plugin \"%1\".\n\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fatalMessage
operator|+=
name|QStringLiteral
argument_list|(
literal|"Available platform plugins are: %1.\n\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|keys
operator|.
name|join
argument_list|(
name|QStringLiteral
argument_list|(
literal|", "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fatalMessage
operator|+=
name|QStringLiteral
argument_list|(
literal|"Reinstalling the application may fix this problem."
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
comment|// Windows: Display message box unless it is a console application
comment|// or debug build showing an assert box.
if|if
condition|(
operator|!
name|QLibraryInfo
operator|::
name|isDebugBuild
argument_list|()
operator|&&
operator|!
name|GetConsoleWindow
argument_list|()
condition|)
name|MessageBox
argument_list|(
literal|0
argument_list|,
operator|(
name|LPCTSTR
operator|)
name|fatalMessage
operator|.
name|utf16
argument_list|()
argument_list|,
call|(
name|LPCTSTR
call|)
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|MB_OK
operator||
name|MB_ICONERROR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN&& !Q_OS_WINCE&& !Q_OS_WINRT
name|qFatal
argument_list|(
literal|"%s"
argument_list|,
name|qPrintable
argument_list|(
name|fatalMessage
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Create the platform theme:
comment|// 1) Fetch the platform name from the environment if present.
name|QStringList
name|themeNames
decl_stmt|;
if|if
condition|(
operator|!
name|platformThemeName
operator|.
name|isEmpty
argument_list|()
condition|)
name|themeNames
operator|.
name|append
argument_list|(
name|platformThemeName
argument_list|)
expr_stmt|;
comment|// 2) Ask the platform integration for a list of theme names
name|themeNames
operator|+=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|themeNames
argument_list|()
expr_stmt|;
comment|// 3) Look for a theme plugin.
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|themeName
decl|,
name|themeNames
control|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
name|QPlatformThemeFactory
operator|::
name|create
argument_list|(
name|themeName
argument_list|,
name|platformPluginPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
break|break;
block|}
comment|// 4) If no theme plugin was found ask the platform integration to
comment|// create a theme
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|themeName
decl|,
name|themeNames
control|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|createPlatformTheme
argument_list|(
name|themeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
break|break;
block|}
comment|// No error message; not having a theme plugin is allowed.
block|}
comment|// 5) Fall back on the built-in "null" platform theme.
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platform_theme
condition|)
name|QGuiApplicationPrivate
operator|::
name|platform_theme
operator|=
operator|new
name|QPlatformTheme
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
comment|// Set arguments as dynamic properties on the native interface as
comment|// boolean 'foo' or strings: 'foo=bar'
if|if
condition|(
operator|!
name|arguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|QObject
modifier|*
name|nativeInterface
init|=
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|nativeInterface
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|argument
decl|,
name|arguments
control|)
block|{
specifier|const
name|int
name|equalsPos
init|=
name|argument
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|name
init|=
name|equalsPos
operator|!=
operator|-
literal|1
condition|?
name|argument
operator|.
name|left
argument_list|(
name|equalsPos
argument_list|)
operator|.
name|toUtf8
argument_list|()
else|:
name|argument
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
specifier|const
name|QVariant
name|value
init|=
name|equalsPos
operator|!=
operator|-
literal|1
condition|?
name|QVariant
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|equalsPos
operator|+
literal|1
argument_list|)
argument_list|)
else|:
name|QVariant
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|nativeInterface
operator|->
name|setProperty
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|fontSmoothingGamma
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QPlatformIntegration
operator|::
name|FontSmoothingGamma
argument_list|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init_plugins
specifier|static
name|void
name|init_plugins
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|pluginList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pluginList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|pluginSpec
init|=
name|pluginList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|colonPos
init|=
name|pluginSpec
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|plugin
decl_stmt|;
if|if
condition|(
name|colonPos
operator|<
literal|0
condition|)
name|plugin
operator|=
name|QGenericPluginFactory
operator|::
name|create
argument_list|(
name|QLatin1String
argument_list|(
name|pluginSpec
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|plugin
operator|=
name|QGenericPluginFactory
operator|::
name|create
argument_list|(
name|QLatin1String
argument_list|(
name|pluginSpec
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
name|colonPos
argument_list|)
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
name|pluginSpec
operator|.
name|mid
argument_list|(
name|colonPos
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugin
condition|)
name|QGuiApplicationPrivate
operator|::
name|generic_plugin_list
operator|.
name|append
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|()
operator|<<
literal|"No such plugin for spec "
operator|<<
name|pluginSpec
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createPlatformIntegration
name|void
name|QGuiApplicationPrivate
operator|::
name|createPlatformIntegration
parameter_list|()
block|{
comment|// Use the Qt menus by default. Platform plugins that
comment|// want to enable a native menu implementation can clear
comment|// this flag.
name|QCoreApplication
operator|::
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontUseNativeMenuBar
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Load the platform integration
name|QString
name|platformPluginPath
init|=
name|QLatin1String
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_QPA_PLATFORM_PLUGIN_PATH"
argument_list|)
argument_list|)
decl_stmt|;
name|QByteArray
name|platformName
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_QPA_DEFAULT_PLATFORM_NAME
name|platformName
operator|=
name|QT_QPA_DEFAULT_PLATFORM_NAME
expr_stmt|;
endif|#
directive|endif
name|QByteArray
name|platformNameEnv
init|=
name|qgetenv
argument_list|(
literal|"QT_QPA_PLATFORM"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|platformNameEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|platformName
operator|=
name|platformNameEnv
expr_stmt|;
block|}
name|QString
name|platformThemeName
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_QPA_PLATFORMTHEME"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Get command line params
name|QString
name|icon
decl_stmt|;
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
specifier|const
name|bool
name|isXcb
init|=
name|platformName
operator|==
literal|"xcb"
decl_stmt|;
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"--"
argument_list|)
condition|)
name|arg
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-platformpluginpath"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|platformPluginPath
operator|=
name|QLatin1String
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-platform"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|platformName
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-platformtheme"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|platformThemeName
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-qwindowgeometry"
operator|||
operator|(
name|isXcb
operator|&&
name|arg
operator|==
literal|"-geometry"
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|windowGeometrySpecification
operator|=
name|QWindowGeometrySpecification
operator|::
name|fromArgument
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-qwindowtitle"
operator|||
operator|(
name|isXcb
operator|&&
name|arg
operator|==
literal|"-title"
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|firstWindowTitle
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-qwindowicon"
operator|||
operator|(
name|isXcb
operator|&&
name|arg
operator|==
literal|"-icon"
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
block|{
name|icon
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
name|init_platform
argument_list|(
name|QLatin1String
argument_list|(
name|platformName
argument_list|)
argument_list|,
name|platformPluginPath
argument_list|,
name|platformThemeName
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icon
operator|.
name|isEmpty
argument_list|()
condition|)
name|forcedWindowIcon
operator|=
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|icon
argument_list|)
condition|?
name|QIcon
argument_list|(
name|icon
argument_list|)
else|:
name|QIcon
operator|::
name|fromTheme
argument_list|(
name|icon
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Called from QCoreApplication::init()      Responsible for creating an event dispatcher when QCoreApplication     decides that it needs one (because a custom one has not been set). */
end_comment
begin_function
DECL|function|createEventDispatcher
name|void
name|QGuiApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|eventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|platform_integration
operator|==
literal|0
condition|)
name|createPlatformIntegration
argument_list|()
expr_stmt|;
comment|// The platform integration should not mess with the event dispatcher
name|Q_ASSERT
argument_list|(
operator|!
name|eventDispatcher
argument_list|)
expr_stmt|;
name|eventDispatcher
operator|=
name|platform_integration
operator|->
name|createEventDispatcher
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|eventDispatcherReady
name|void
name|QGuiApplicationPrivate
operator|::
name|eventDispatcherReady
parameter_list|()
block|{
if|if
condition|(
name|platform_integration
operator|==
literal|0
condition|)
name|createPlatformIntegration
argument_list|()
expr_stmt|;
name|platform_integration
operator|->
name|initialize
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QGuiApplicationPrivate
operator|::
name|init
parameter_list|()
block|{
name|QCoreApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
comment|// Starting up.
name|bool
name|loadTestability
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|pluginList
decl_stmt|;
comment|// Get command line params
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
name|QString
name|session_id
decl_stmt|;
name|QString
name|session_key
decl_stmt|;
endif|#
directive|endif
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"--"
argument_list|)
condition|)
name|arg
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-plugin"
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
name|pluginList
operator|<<
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-reverse"
condition|)
block|{
name|force_reverse
operator|=
literal|true
expr_stmt|;
name|QGuiApplication
operator|::
name|setLayoutDirection
argument_list|(
name|Qt
operator|::
name|RightToLeft
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"-psn_"
argument_list|)
condition|)
block|{
comment|// eat "-psn_xxxx" on Mac, which is passed when starting an app from Finder.
comment|// special hack to change working directory (for an app bundle) when running from finder
if|if
condition|(
name|QDir
operator|::
name|currentPath
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|QCFType
argument_list|<
name|CFURLRef
argument_list|>
name|bundleURL
argument_list|(
name|CFBundleCopyBundleURL
argument_list|(
name|CFBundleGetMainBundle
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|qbundlePath
init|=
name|QCFString
argument_list|(
name|CFURLCopyFileSystemPath
argument_list|(
name|bundleURL
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qbundlePath
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".app"
argument_list|)
argument_list|)
condition|)
name|QDir
operator|::
name|setCurrent
argument_list|(
name|qbundlePath
operator|.
name|section
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-session"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
condition|)
block|{
name|session_id
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|p
init|=
name|session_id
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|>=
literal|0
condition|)
block|{
name|session_key
operator|=
name|session_id
operator|.
name|mid
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|session_id
operator|=
name|session_id
operator|.
name|left
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|is_session_restored
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-testability"
condition|)
block|{
name|loadTestability
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
comment|// Load environment exported generic plugins
name|QByteArray
name|envPlugins
init|=
name|qgetenv
argument_list|(
literal|"QT_QPA_GENERIC_PLUGINS"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|envPlugins
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|plugin
decl|,
name|envPlugins
operator|.
name|split
argument_list|(
literal|','
argument_list|)
control|)
name|pluginList
operator|<<
name|plugin
expr_stmt|;
block|}
if|if
condition|(
name|platform_integration
operator|==
literal|0
condition|)
name|createPlatformIntegration
argument_list|()
expr_stmt|;
comment|// Set up blend function tables.
name|qInitBlendFunctions
argument_list|()
expr_stmt|;
comment|// Set up which span functions should be used in raster engine...
name|qInitDrawhelperAsm
argument_list|()
expr_stmt|;
comment|// and QImage conversion functions
name|qInitImageConversions
argument_list|()
expr_stmt|;
name|initPalette
argument_list|()
expr_stmt|;
name|QFont
operator|::
name|initialize
argument_list|()
expr_stmt|;
name|mouse_double_click_distance
operator|=
name|platformTheme
argument_list|()
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|MouseDoubleClickDistance
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QCursorData
operator|::
name|initialize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// trigger registering of QVariant's GUI types
name|qRegisterGuiVariant
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
comment|// trigger registering of animation interpolators
name|qRegisterGuiGetInterpolator
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// set a global share context when enabled unless there is already one
ifndef|#
directive|ifndef
name|QT_NO_OPENGL
if|if
condition|(
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_ShareOpenGLContexts
argument_list|)
operator|&&
operator|!
name|qt_gl_global_share_context
argument_list|()
condition|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
operator|new
name|QOpenGLContext
decl_stmt|;
name|ctx
operator|->
name|setFormat
argument_list|(
name|QSurfaceFormat
operator|::
name|defaultFormat
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|create
argument_list|()
expr_stmt|;
name|qt_gl_set_global_share_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ownGlobalShareContext
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
name|QWindowSystemInterfacePrivate
operator|::
name|eventTime
operator|.
name|start
argument_list|()
expr_stmt|;
name|is_app_running
operator|=
literal|true
expr_stmt|;
name|init_plugins
argument_list|(
name|pluginList
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|flushWindowSystemEvents
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
comment|// connect to the session manager
name|session_manager
operator|=
operator|new
name|QSessionManager
argument_list|(
name|q
argument_list|,
name|session_id
argument_list|,
name|session_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
name|loadTestability
condition|)
block|{
name|QLibrary
name|testLib
argument_list|(
name|QStringLiteral
argument_list|(
literal|"qttestability"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|testLib
operator|.
name|load
argument_list|()
condition|)
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|TasInitialize
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|TasInitialize
name|initFunction
init|=
operator|(
name|TasInitialize
operator|)
name|testLib
operator|.
name|resolve
argument_list|(
literal|"qt_testability_init"
argument_list|)
decl_stmt|;
if|if
condition|(
name|initFunction
condition|)
block|{
name|initFunction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qCritical
argument_list|()
operator|<<
literal|"Library qttestability resolve failed!"
expr_stmt|;
block|}
block|}
else|else
block|{
name|qCritical
argument_list|()
operator|<<
literal|"Library qttestability load failed:"
operator|<<
name|testLib
operator|.
name|errorString
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_LIBRARY
block|}
end_function
begin_function_decl
specifier|extern
name|void
name|qt_cleanupFontDatabase
parameter_list|()
function_decl|;
end_function_decl
begin_destructor
DECL|function|~QGuiApplicationPrivate
name|QGuiApplicationPrivate
operator|::
name|~
name|QGuiApplicationPrivate
parameter_list|()
block|{
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|is_app_running
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|generic_plugin_list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|generic_plugin_list
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|generic_plugin_list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|clearFontUnlocked
argument_list|()
expr_stmt|;
name|QFont
operator|::
name|cleanup
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QCursorData
operator|::
name|cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|layout_direction
operator|=
name|Qt
operator|::
name|LeftToRight
expr_stmt|;
name|cleanupThreadData
argument_list|()
expr_stmt|;
operator|delete
name|QGuiApplicationPrivate
operator|::
name|styleHints
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|styleHints
operator|=
name|Q_NULLPTR
expr_stmt|;
operator|delete
name|inputMethod
expr_stmt|;
name|qt_cleanupFontDatabase
argument_list|()
expr_stmt|;
name|QPixmapCache
operator|::
name|clear
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENGL
if|if
condition|(
name|ownGlobalShareContext
condition|)
block|{
operator|delete
name|qt_gl_global_share_context
argument_list|()
expr_stmt|;
name|qt_gl_set_global_share_context
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|platform_integration
operator|->
name|destroy
argument_list|()
expr_stmt|;
operator|delete
name|platform_theme
expr_stmt|;
name|platform_theme
operator|=
literal|0
expr_stmt|;
operator|delete
name|platform_integration
expr_stmt|;
name|platform_integration
operator|=
literal|0
expr_stmt|;
operator|delete
name|m_gammaTables
operator|.
name|load
argument_list|()
expr_stmt|;
name|window_list
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_if
if|#
directive|if
literal|0
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|QCursor *overrideCursor(); void setOverrideCursor(const QCursor&); void changeOverrideCursor(const QCursor&); void restoreOverrideCursor();
endif|#
directive|endif
end_endif
begin_ifndef
unit|static QFont font(); static QFont font(const QWidget*); static QFont font(const char *className); static void setFont(const QFont&, const char* className = 0); static QFontMetrics fontMetrics();
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_endif
unit|static QClipboard *clipboard();
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the current state of the modifier keys on the keyboard. The current     state is updated sychronously as the event queue is emptied of events that     will spontaneously change the keyboard state (QEvent::KeyPress and     QEvent::KeyRelease events).      It should be noted this may not reflect the actual keys held on the input     device at the time of calling but rather the modifiers as last reported in     one of the above events. If no keys are being held Qt::NoModifier is     returned.      \sa mouseButtons(), queryKeyboardModifiers() */
end_comment
begin_function
DECL|function|keyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplication
operator|::
name|keyboardModifiers
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|modifier_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     \fn Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers()      Queries and returns the state of the modifier keys on the keyboard.     Unlike keyboardModifiers, this method returns the actual keys held     on the input device at the time of calling the method.      It does not rely on the keypress events having been received by this     process, which makes it possible to check the modifiers while moving     a window, for instance. Note that in most cases, you should use     keyboardModifiers(), which is faster and more accurate since it contains     the state of the modifiers as they were when the currently processed     event was received.      \sa keyboardModifiers() */
end_comment
begin_function
DECL|function|queryKeyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QGuiApplication
operator|::
name|queryKeyboardModifiers
parameter_list|()
block|{
name|CHECK_QAPP_INSTANCE
argument_list|(
argument|Qt::KeyboardModifiers(
literal|0
argument|)
argument_list|)
name|QPlatformIntegration
modifier|*
name|pi
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
return|return
name|pi
operator|->
name|queryKeyboardModifiers
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the buttons on the mouse. The current state is     updated syncronously as the event queue is emptied of events that will     spontaneously change the mouse state (QEvent::MouseButtonPress and     QEvent::MouseButtonRelease events).      It should be noted this may not reflect the actual buttons held on the     input device at the time of calling but rather the mouse buttons as last     reported in one of the above events. If no mouse buttons are being held     Qt::NoButton is returned.      \sa keyboardModifiers() */
end_comment
begin_function
DECL|function|mouseButtons
name|Qt
operator|::
name|MouseButtons
name|QGuiApplication
operator|::
name|mouseButtons
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|mouse_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the platform's native interface, for platform specific     functionality. */
end_comment
begin_function
DECL|function|platformNativeInterface
name|QPlatformNativeInterface
modifier|*
name|QGuiApplication
operator|::
name|platformNativeInterface
parameter_list|()
block|{
name|QPlatformIntegration
modifier|*
name|pi
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
return|return
name|pi
condition|?
name|pi
operator|->
name|nativeInterface
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a function pointer from the platformplugin matching \a function */
end_comment
begin_function
DECL|function|platformFunction
name|QFunctionPointer
name|QGuiApplication
operator|::
name|platformFunction
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|function
parameter_list|)
block|{
name|QPlatformIntegration
modifier|*
name|pi
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pi
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QGuiApplication::platformFunction(): Must construct a QGuiApplication before accessing a platform function"
expr_stmt|;
return|return
name|Q_NULLPTR
return|;
block|}
return|return
name|pi
operator|->
name|nativeInterface
argument_list|()
condition|?
name|pi
operator|->
name|nativeInterface
argument_list|()
operator|->
name|platformFunction
argument_list|(
name|function
argument_list|)
else|:
name|Q_NULLPTR
return|;
block|}
end_function
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called, and then     returns the value that was set to exit() (which is 0 if exit() is called     via quit()).      It is necessary to call this function to start event handling. The main     event loop receives events from the window system and dispatches these to     the application widgets.      Generally, no user interaction can take place before calling exec().      To make your application perform idle processing, e.g., executing a special     function whenever there are no pending events, use a QTimer with 0 timeout.     More advanced idle processing schemes can be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your     application's \c{main()} function. This is because, on some platforms, the     QApplication::exec() call may not return.      \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),         QCoreApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QGuiApplication
operator|::
name|exec
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|setRootObject
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QCoreApplication
operator|::
name|exec
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|notify
name|bool
name|QGuiApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|object
operator|->
name|isWindowType
argument_list|()
condition|)
name|QGuiApplicationPrivate
operator|::
name|sendQWindowEventToQPlatformWindow
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
name|QCoreApplication
operator|::
name|notify
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QGuiApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
name|setLayoutDirection
argument_list|(
name|qt_detectRTLLanguage
argument_list|()
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
argument_list|)
expr_stmt|;
block|}
return|return
name|QCoreApplication
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QGuiApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
name|postedEvents
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendQWindowEventToQPlatformWindow
name|void
name|QGuiApplicationPrivate
operator|::
name|sendQWindowEventToQPlatformWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QPlatformWindow
modifier|*
name|platformWindow
init|=
name|window
operator|->
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|platformWindow
condition|)
return|return;
comment|// spontaneous events come from the platform integration already, we don't need to send the events back
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
return|return;
comment|// let the platform window do any handling it needs to as well
name|platformWindow
operator|->
name|windowEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processNativeEvent
name|bool
name|QGuiApplicationPrivate
operator|::
name|processNativeEvent
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|eventType
parameter_list|,
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
return|return
name|window
operator|->
name|nativeEvent
argument_list|(
name|eventType
argument_list|,
name|message
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|processWindowSystemEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWindowSystemEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|FrameStrutMouse
case|:
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Mouse
case|:
name|QGuiApplicationPrivate
operator|::
name|processMouseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Wheel
case|:
name|QGuiApplicationPrivate
operator|::
name|processWheelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|WheelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Key
case|:
name|QGuiApplicationPrivate
operator|::
name|processKeyEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|KeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Touch
case|:
name|QGuiApplicationPrivate
operator|::
name|processTouchEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChange
case|:
name|QGuiApplicationPrivate
operator|::
name|processGeometryChangeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChangeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Enter
case|:
name|QGuiApplicationPrivate
operator|::
name|processEnterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|EnterEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Leave
case|:
name|QGuiApplicationPrivate
operator|::
name|processLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|LeaveEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindow
case|:
name|QGuiApplicationPrivate
operator|::
name|processActivatedEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindowEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChanged
case|:
name|QGuiApplicationPrivate
operator|::
name|processWindowStateChangedEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChangedEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|WindowScreenChanged
case|:
name|QGuiApplicationPrivate
operator|::
name|processWindowScreenChangedEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|WindowScreenChangedEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ApplicationStateChanged
case|:
block|{
name|QWindowSystemInterfacePrivate
operator|::
name|ApplicationStateChangedEvent
modifier|*
name|changeEvent
init|=
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ApplicationStateChangedEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QGuiApplicationPrivate
operator|::
name|setApplicationState
argument_list|(
name|changeEvent
operator|->
name|newState
argument_list|,
name|changeEvent
operator|->
name|forcePropagate
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|FlushEvents
case|:
block|{
name|QWindowSystemInterfacePrivate
operator|::
name|FlushEventsEvent
modifier|*
name|flushEventsEvent
init|=
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|FlushEventsEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QWindowSystemInterface
operator|::
name|deferredFlushWindowSystemEvents
argument_list|(
name|flushEventsEvent
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Close
case|:
name|QGuiApplicationPrivate
operator|::
name|processCloseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|CloseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientation
case|:
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientationEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometry
case|:
name|QGuiApplicationPrivate
operator|::
name|reportGeometryChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometryEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInch
case|:
name|QGuiApplicationPrivate
operator|::
name|reportLogicalDotsPerInchChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRate
case|:
name|QGuiApplicationPrivate
operator|::
name|reportRefreshRateChange
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRateEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChange
case|:
name|QGuiApplicationPrivate
operator|::
name|processThemeChanged
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChangeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Expose
case|:
name|QGuiApplicationPrivate
operator|::
name|processExposeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ExposeEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Tablet
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximity
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletEnterProximityEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximityEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximity
case|:
name|QGuiApplicationPrivate
operator|::
name|processTabletLeaveProximityEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximityEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|Gesture
case|:
name|QGuiApplicationPrivate
operator|::
name|processGestureEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|GestureEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanel
case|:
name|QGuiApplicationPrivate
operator|::
name|processPlatformPanelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpen
case|:
name|QGuiApplicationPrivate
operator|::
name|processFileOpenEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpenEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenu
case|:
name|QGuiApplicationPrivate
operator|::
name|processContextMenuEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWindowSystemInterfacePrivate
operator|::
name|EnterWhatsThisMode
case|:
name|QGuiApplication
operator|::
name|postEvent
argument_list|(
name|QGuiApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|EnterWhatsThisMode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|()
operator|<<
literal|"Unknown user input event type:"
operator|<<
name|e
operator|->
name|type
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|processMouseEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processMouseEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|QEvent
operator|::
name|Type
name|type
decl_stmt|;
name|Qt
operator|::
name|MouseButtons
name|stateChange
init|=
name|e
operator|->
name|buttons
operator|^
name|buttons
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|globalPos
operator|!=
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|&&
operator|(
name|stateChange
operator|!=
name|Qt
operator|::
name|NoButton
operator|)
condition|)
block|{
comment|// A mouse event should not change both position and buttons at the same time. Instead we
comment|// should first send a move event followed by a button changed event. Since this is not the case
comment|// with the current event, we split it in two.
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
modifier|*
name|mouseButtonEvent
init|=
operator|new
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|e
operator|->
name|type
argument_list|,
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|,
name|e
operator|->
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
operator|::
name|Synthetic
condition|)
name|mouseButtonEvent
operator|->
name|flags
operator||=
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
operator|::
name|Synthetic
expr_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|windowSystemEventQueue
operator|.
name|prepend
argument_list|(
name|mouseButtonEvent
argument_list|)
expr_stmt|;
name|stateChange
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
block|}
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
name|QPointF
name|localPoint
init|=
name|e
operator|->
name|localPos
decl_stmt|;
name|QPointF
name|globalPoint
init|=
name|e
operator|->
name|globalPos
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
argument_list|()
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
comment|// Moves and the release following a press must go to the same
comment|// window, even if the cursor has moved on over another window.
if|if
condition|(
name|e
operator|->
name|buttons
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
block|{
if|if
condition|(
operator|!
name|currentMousePressWindow
condition|)
name|currentMousePressWindow
operator|=
name|window
expr_stmt|;
else|else
name|window
operator|=
name|currentMousePressWindow
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentMousePressWindow
condition|)
block|{
name|window
operator|=
name|currentMousePressWindow
expr_stmt|;
name|currentMousePressWindow
operator|=
literal|0
expr_stmt|;
block|}
name|QPointF
name|delta
init|=
name|globalPoint
operator|-
name|globalPoint
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|localPoint
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
name|bool
name|doubleClick
init|=
literal|false
decl_stmt|;
specifier|const
name|bool
name|frameStrut
init|=
name|e
operator|->
name|type
operator|==
name|QWindowSystemInterfacePrivate
operator|::
name|FrameStrutMouse
decl_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|!=
name|globalPoint
condition|)
block|{
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseMove
else|:
name|QEvent
operator|::
name|MouseMove
expr_stmt|;
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|=
name|globalPoint
expr_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|globalPoint
operator|.
name|x
argument_list|()
operator|-
name|mousePressX
argument_list|)
operator|>
name|mouse_double_click_distance
operator|||
name|qAbs
argument_list|(
name|globalPoint
operator|.
name|y
argument_list|()
operator|-
name|mousePressY
argument_list|)
operator|>
name|mouse_double_click_distance
condition|)
name|mousePressButton
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
block|}
else|else
block|{
comment|// Check to see if a new button has been pressed/released.
for|for
control|(
name|int
name|check
init|=
name|Qt
operator|::
name|LeftButton
init|;
name|check
operator|<=
name|int
argument_list|(
name|Qt
operator|::
name|MaxMouseButton
argument_list|)
condition|;
name|check
operator|=
name|check
operator|<<
literal|1
control|)
block|{
if|if
condition|(
name|check
operator|&
name|stateChange
condition|)
block|{
name|button
operator|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|check
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|button
operator|==
name|Qt
operator|::
name|NoButton
condition|)
block|{
comment|// Ignore mouse events that don't change the current state.
return|return;
block|}
name|mouse_buttons
operator|=
name|buttons
operator|=
name|e
operator|->
name|buttons
expr_stmt|;
if|if
condition|(
name|button
operator|&
name|e
operator|->
name|buttons
condition|)
block|{
name|ulong
name|doubleClickInterval
init|=
cast|static_cast
argument_list|<
name|ulong
argument_list|>
argument_list|(
name|QGuiApplication
operator|::
name|styleHints
argument_list|()
operator|->
name|mouseDoubleClickInterval
argument_list|()
argument_list|)
decl_stmt|;
name|doubleClick
operator|=
name|e
operator|->
name|timestamp
operator|-
name|mousePressTime
operator|<
name|doubleClickInterval
operator|&&
name|button
operator|==
name|mousePressButton
expr_stmt|;
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonPress
else|:
name|QEvent
operator|::
name|MouseButtonPress
expr_stmt|;
name|mousePressTime
operator|=
name|e
operator|->
name|timestamp
expr_stmt|;
name|mousePressButton
operator|=
name|button
expr_stmt|;
specifier|const
name|QPoint
name|point
init|=
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|mousePressX
operator|=
name|point
operator|.
name|x
argument_list|()
expr_stmt|;
name|mousePressY
operator|=
name|point
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonRelease
else|:
name|QEvent
operator|::
name|MouseButtonRelease
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QMouseEvent
name|ev
argument_list|(
name|type
argument_list|,
name|localPoint
argument_list|,
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|button
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|setMouseEventSource
argument_list|(
operator|&
name|ev
argument_list|,
name|e
operator|->
name|source
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
operator|!
name|e
operator|->
name|synthetic
argument_list|()
condition|)
block|{
if|if
condition|(
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|window
operator|->
name|screen
argument_list|()
condition|)
if|if
condition|(
name|QPlatformCursor
modifier|*
name|cursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
name|cursor
operator|->
name|pointerEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow mouse events through
return|return;
block|}
if|if
condition|(
name|doubleClick
operator|&&
operator|(
name|ev
operator|.
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|)
condition|)
block|{
comment|// QtBUG-25831, used to suppress delivery in qwidgetwindow.cpp
name|setMouseEventFlags
argument_list|(
operator|&
name|ev
argument_list|,
name|ev
operator|.
name|flags
argument_list|()
operator||
name|Qt
operator|::
name|MouseEventCreatedDoubleClick
argument_list|)
expr_stmt|;
block|}
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|synthetic
argument_list|()
operator|&&
operator|!
name|ev
operator|.
name|isAccepted
argument_list|()
operator|&&
operator|!
name|frameStrut
operator|&&
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_SynthesizeTouchForUnhandledMouseEvents
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|m_fakeTouchDevice
condition|)
block|{
name|m_fakeTouchDevice
operator|=
operator|new
name|QTouchDevice
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|registerTouchDevice
argument_list|(
name|m_fakeTouchDevice
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QWindowSystemInterface
operator|::
name|TouchPoint
argument_list|>
name|points
decl_stmt|;
name|QWindowSystemInterface
operator|::
name|TouchPoint
name|point
decl_stmt|;
name|point
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|point
operator|.
name|area
operator|=
name|QRectF
argument_list|(
name|globalPoint
operator|.
name|x
argument_list|()
operator|-
literal|2
argument_list|,
name|globalPoint
operator|.
name|y
argument_list|()
operator|-
literal|2
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// only translate left button related events to
comment|// avoid strange touch event sequences when several
comment|// buttons are pressed
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|&&
name|button
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointPressed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
name|button
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointReleased
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
operator|(
name|buttons
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
condition|)
block|{
name|point
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|points
operator|<<
name|point
expr_stmt|;
name|QEvent
operator|::
name|Type
name|type
decl_stmt|;
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|QWindowSystemInterfacePrivate
operator|::
name|convertTouchPoints
argument_list|(
name|points
argument_list|,
operator|&
name|type
argument_list|)
decl_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
name|fake
argument_list|(
name|window
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|type
argument_list|,
name|m_fakeTouchDevice
argument_list|,
name|touchPoints
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|fake
operator|.
name|flags
operator||=
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
operator|::
name|Synthetic
expr_stmt|;
name|processTouchEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doubleClick
condition|)
block|{
name|mousePressButton
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|window
operator|.
name|isNull
argument_list|()
operator|||
name|e
operator|->
name|nullWindow
argument_list|()
condition|)
block|{
comment|// QTBUG-36364, check if window closed in response to press
specifier|const
name|QEvent
operator|::
name|Type
name|doubleClickType
init|=
name|frameStrut
condition|?
name|QEvent
operator|::
name|NonClientAreaMouseButtonDblClick
else|:
name|QEvent
operator|::
name|MouseButtonDblClick
decl_stmt|;
name|QMouseEvent
name|dblClickEvent
argument_list|(
name|doubleClickType
argument_list|,
name|localPoint
argument_list|,
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|button
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|dblClickEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|setMouseEventSource
argument_list|(
operator|&
name|dblClickEvent
argument_list|,
name|e
operator|->
name|source
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|dblClickEvent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|processWheelEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWheelEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WheelEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|QPointF
name|globalPoint
init|=
name|e
operator|->
name|globalPos
decl_stmt|;
name|QPointF
name|localPoint
init|=
name|e
operator|->
name|localPos
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
argument_list|()
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
name|QPointF
name|delta
init|=
name|globalPoint
operator|-
name|globalPoint
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|localPoint
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|globalPoint
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QGuiApplicationPrivate
operator|::
name|lastCursorPosition
operator|=
name|globalPoint
expr_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow wheel events through
return|return;
block|}
name|QWheelEvent
name|ev
argument_list|(
name|localPoint
argument_list|,
name|globalPoint
argument_list|,
name|e
operator|->
name|pixelDelta
argument_list|,
name|e
operator|->
name|angleDelta
argument_list|,
name|e
operator|->
name|qt4Delta
argument_list|,
name|e
operator|->
name|qt4Orientation
argument_list|,
name|buttons
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|phase
argument_list|,
name|e
operator|->
name|source
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ifndef QT_NO_WHEELEVENT */
block|}
end_function
begin_comment
comment|// Remember, Qt convention is:  keyboard state is state *before*
end_comment
begin_function
DECL|function|processKeyEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processKeyEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|KeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|nullWindow
argument_list|()
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
operator|||
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Back
operator|||
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Menu
endif|#
directive|endif
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|focusWindow
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
comment|// On OS X the shortcut override is checked earlier, see: QWindowSystemInterface::handleKeyEvent()
specifier|const
name|bool
name|checkShortcut
init|=
name|e
operator|->
name|keyType
operator|==
name|QEvent
operator|::
name|KeyPress
operator|&&
name|window
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|checkShortcut
condition|)
block|{
name|QKeyEvent
name|override
argument_list|(
name|QEvent
operator|::
name|ShortcutOverride
argument_list|,
name|e
operator|->
name|key
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|nativeScanCode
argument_list|,
name|e
operator|->
name|nativeVirtualKey
argument_list|,
name|e
operator|->
name|nativeModifiers
argument_list|,
name|e
operator|->
name|unicode
argument_list|,
name|e
operator|->
name|repeat
argument_list|,
name|e
operator|->
name|repeatCount
argument_list|)
decl_stmt|;
name|override
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWindowSystemInterface
operator|::
name|tryHandleShortcutOverrideEvent
argument_list|(
name|window
argument_list|,
operator|&
name|override
argument_list|)
condition|)
return|return;
block|}
endif|#
directive|endif
comment|// Q_OS_OSX
name|QKeyEvent
name|ev
argument_list|(
name|e
operator|->
name|keyType
argument_list|,
name|e
operator|->
name|key
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|nativeScanCode
argument_list|,
name|e
operator|->
name|nativeVirtualKey
argument_list|,
name|e
operator|->
name|nativeModifiers
argument_list|,
name|e
operator|->
name|unicode
argument_list|,
name|e
operator|->
name|repeat
argument_list|,
name|e
operator|->
name|repeatCount
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|// only deliver key events when we have a window, and no modal window is blocking this window
if|if
condition|(
name|window
operator|&&
operator|!
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
else|else
name|ev
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
specifier|static
name|bool
name|backKeyPressAccepted
init|=
literal|false
decl_stmt|;
specifier|static
name|bool
name|menuKeyPressAccepted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|keyType
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
name|backKeyPressAccepted
operator|=
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Back
operator|&&
name|ev
operator|.
name|isAccepted
argument_list|()
expr_stmt|;
name|menuKeyPressAccepted
operator|=
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Menu
operator|&&
name|ev
operator|.
name|isAccepted
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|keyType
operator|==
name|QEvent
operator|::
name|KeyRelease
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Back
operator|&&
operator|!
name|backKeyPressAccepted
operator|&&
operator|!
name|ev
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
if|if
condition|(
name|window
condition|)
name|QWindowSystemInterface
operator|::
name|handleCloseEvent
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|key
operator|==
name|Qt
operator|::
name|Key_Menu
operator|&&
operator|!
name|menuKeyPressAccepted
operator|&&
operator|!
name|ev
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|platform_theme
operator|->
name|showPlatformMenuBar
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processEnterEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processEnterEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|EnterEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|enter
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|enter
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow enter events through
return|return;
block|}
name|currentMouseWindow
operator|=
name|e
operator|->
name|enter
expr_stmt|;
name|QEnterEvent
name|event
argument_list|(
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|localPos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|enter
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processLeaveEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processLeaveEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|LeaveEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|leave
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|leave
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow leave events through
return|return;
block|}
name|currentMouseWindow
operator|=
literal|0
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|leave
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processActivatedEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processActivatedEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ActivatedWindowEvent
modifier|*
name|e
parameter_list|)
block|{
name|QWindow
modifier|*
name|previous
init|=
name|QGuiApplicationPrivate
operator|::
name|focus_window
decl_stmt|;
name|QWindow
modifier|*
name|newFocus
init|=
name|e
operator|->
name|activated
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
name|newFocus
condition|)
return|return;
if|if
condition|(
name|newFocus
condition|)
if|if
condition|(
name|QPlatformWindow
modifier|*
name|platformWindow
init|=
name|newFocus
operator|->
name|handle
argument_list|()
condition|)
if|if
condition|(
name|platformWindow
operator|->
name|isAlertState
argument_list|()
condition|)
name|platformWindow
operator|->
name|setAlertState
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QObject
modifier|*
name|previousFocusObject
init|=
name|previous
condition|?
name|previous
operator|->
name|focusObject
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|previous
condition|)
block|{
name|QFocusEvent
name|focusAboutToChange
argument_list|(
name|QEvent
operator|::
name|FocusAboutToChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|previous
argument_list|,
operator|&
name|focusAboutToChange
argument_list|)
expr_stmt|;
block|}
name|QGuiApplicationPrivate
operator|::
name|focus_window
operator|=
name|newFocus
expr_stmt|;
if|if
condition|(
operator|!
name|qApp
condition|)
return|return;
if|if
condition|(
name|previous
condition|)
block|{
name|Qt
operator|::
name|FocusReason
name|r
init|=
name|e
operator|->
name|reason
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|==
name|Qt
operator|::
name|OtherFocusReason
operator|||
name|r
operator|==
name|Qt
operator|::
name|ActiveWindowFocusReason
operator|)
operator|&&
name|newFocus
operator|&&
operator|(
name|newFocus
operator|->
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|r
operator|=
name|Qt
operator|::
name|PopupFocusReason
expr_stmt|;
name|QFocusEvent
name|focusOut
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|previous
argument_list|,
operator|&
name|focusOut
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|previous
argument_list|,
name|SIGNAL
argument_list|(
name|focusObjectChanged
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|qApp
argument_list|,
name|SLOT
argument_list|(
name|_q_updateFocusObject
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ApplicationState
argument_list|)
condition|)
block|{
name|setApplicationState
argument_list|(
name|Qt
operator|::
name|ApplicationActive
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
condition|)
block|{
name|Qt
operator|::
name|FocusReason
name|r
init|=
name|e
operator|->
name|reason
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|==
name|Qt
operator|::
name|OtherFocusReason
operator|||
name|r
operator|==
name|Qt
operator|::
name|ActiveWindowFocusReason
operator|)
operator|&&
name|previous
operator|&&
operator|(
name|previous
operator|->
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|r
operator|=
name|Qt
operator|::
name|PopupFocusReason
expr_stmt|;
name|QFocusEvent
name|focusIn
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
argument_list|,
operator|&
name|focusIn
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|focus_window
argument_list|,
name|SIGNAL
argument_list|(
name|focusObjectChanged
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|qApp
argument_list|,
name|SLOT
argument_list|(
name|_q_updateFocusObject
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ApplicationState
argument_list|)
condition|)
block|{
name|setApplicationState
argument_list|(
name|Qt
operator|::
name|ApplicationInactive
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|self
condition|)
block|{
name|self
operator|->
name|notifyActiveWindowChange
argument_list|(
name|previous
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousFocusObject
operator|!=
name|qApp
operator|->
name|focusObject
argument_list|()
condition|)
name|self
operator|->
name|_q_updateFocusObject
argument_list|(
name|qApp
operator|->
name|focusObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
emit|emit
name|qApp
operator|->
name|focusWindowChanged
argument_list|(
name|newFocus
argument_list|)
emit|;
if|if
condition|(
name|previous
condition|)
emit|emit
name|previous
operator|->
name|activeChanged
argument_list|()
emit|;
if|if
condition|(
name|newFocus
condition|)
emit|emit
name|newFocus
operator|->
name|activeChanged
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|processWindowStateChangedEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWindowStateChangedEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WindowStateChangedEvent
modifier|*
name|wse
parameter_list|)
block|{
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|wse
operator|->
name|window
operator|.
name|data
argument_list|()
condition|)
block|{
name|QWindowStateChangeEvent
name|e
argument_list|(
name|window
operator|->
name|windowState
argument_list|()
argument_list|)
decl_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|windowState
operator|=
name|wse
operator|->
name|newState
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processWindowScreenChangedEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processWindowScreenChangedEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|WindowScreenChangedEvent
modifier|*
name|wse
parameter_list|)
block|{
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|wse
operator|->
name|window
operator|.
name|data
argument_list|()
condition|)
block|{
if|if
condition|(
name|QScreen
modifier|*
name|screen
init|=
name|wse
operator|->
name|screen
operator|.
name|data
argument_list|()
condition|)
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|setTopLevelScreen
argument_list|(
name|screen
argument_list|,
literal|false
comment|/* recreate */
argument_list|)
expr_stmt|;
else|else
comment|// Fall back to default behavior, and try to find some appropriate screen
name|window
operator|->
name|setScreen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processThemeChanged
name|void
name|QGuiApplicationPrivate
operator|::
name|processThemeChanged
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ThemeChangeEvent
modifier|*
name|tce
parameter_list|)
block|{
if|if
condition|(
name|self
condition|)
name|self
operator|->
name|notifyThemeChanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|tce
operator|->
name|window
operator|.
name|data
argument_list|()
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ThemeChange
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processGeometryChangeEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processGeometryChangeEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|GeometryChangeEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|tlw
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|tlw
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QRect
name|newRect
init|=
name|e
operator|->
name|newGeometry
decl_stmt|;
name|QRect
name|oldRect
init|=
name|e
operator|->
name|oldGeometry
operator|.
name|isNull
argument_list|()
condition|?
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
else|:
name|e
operator|->
name|oldGeometry
decl_stmt|;
name|bool
name|isResize
init|=
name|oldRect
operator|.
name|size
argument_list|()
operator|!=
name|newRect
operator|.
name|size
argument_list|()
decl_stmt|;
name|bool
name|isMove
init|=
name|oldRect
operator|.
name|topLeft
argument_list|()
operator|!=
name|newRect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
operator|=
name|newRect
expr_stmt|;
if|if
condition|(
name|isResize
operator|||
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|resizeEventPending
condition|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|newRect
operator|.
name|size
argument_list|()
argument_list|,
name|oldRect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|resizeEventPending
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|oldRect
operator|.
name|width
argument_list|()
operator|!=
name|newRect
operator|.
name|width
argument_list|()
condition|)
name|window
operator|->
name|widthChanged
argument_list|(
name|newRect
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRect
operator|.
name|height
argument_list|()
operator|!=
name|newRect
operator|.
name|height
argument_list|()
condition|)
name|window
operator|->
name|heightChanged
argument_list|(
name|newRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isMove
condition|)
block|{
comment|//### frame geometry
name|QMoveEvent
name|e
argument_list|(
name|newRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|oldRect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRect
operator|.
name|x
argument_list|()
operator|!=
name|newRect
operator|.
name|x
argument_list|()
condition|)
name|window
operator|->
name|xChanged
argument_list|(
name|newRect
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRect
operator|.
name|y
argument_list|()
operator|!=
name|newRect
operator|.
name|y
argument_list|()
condition|)
name|window
operator|->
name|yChanged
argument_list|(
name|newRect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processCloseEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processCloseEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|CloseEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|window
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow close events through
return|return;
block|}
name|QCloseEvent
name|event
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|accepted
condition|)
block|{
operator|*
operator|(
name|e
operator|->
name|accepted
operator|)
operator|=
name|event
operator|.
name|isAccepted
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processFileOpenEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processFileOpenEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|FileOpenEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QFileOpenEvent
name|event
argument_list|(
name|e
operator|->
name|url
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processTabletEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QEvent
operator|::
name|Type
name|type
init|=
name|QEvent
operator|::
name|TabletMove
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|buttons
operator|!=
name|tabletState
condition|)
name|type
operator|=
operator|(
name|e
operator|->
name|buttons
operator|>
name|tabletState
operator|)
condition|?
name|QEvent
operator|::
name|TabletPress
else|:
name|QEvent
operator|::
name|TabletRelease
expr_stmt|;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
name|bool
name|localValid
init|=
literal|true
decl_stmt|;
comment|// If window is null, pick one based on the global position and make sure all
comment|// subsequent events up to the release are delivered to that same window.
comment|// If window is given, just send to that.
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|TabletPress
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|nullWindow
argument_list|()
condition|)
block|{
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
name|localValid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|tabletPressTarget
operator|=
name|window
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|nullWindow
argument_list|()
condition|)
block|{
name|window
operator|=
name|tabletPressTarget
expr_stmt|;
name|localValid
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|TabletRelease
condition|)
name|tabletPressTarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
block|}
name|QPointF
name|local
init|=
name|e
operator|->
name|local
decl_stmt|;
if|if
condition|(
operator|!
name|localValid
condition|)
block|{
name|QPointF
name|delta
init|=
name|e
operator|->
name|global
operator|-
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|local
operator|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|e
operator|->
name|global
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
name|Qt
operator|::
name|MouseButtons
name|stateChange
init|=
name|e
operator|->
name|buttons
operator|^
name|tabletState
decl_stmt|;
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
for|for
control|(
name|int
name|check
init|=
name|Qt
operator|::
name|LeftButton
init|;
name|check
operator|<=
name|int
argument_list|(
name|Qt
operator|::
name|MaxMouseButton
argument_list|)
condition|;
name|check
operator|=
name|check
operator|<<
literal|1
control|)
block|{
if|if
condition|(
name|check
operator|&
name|stateChange
condition|)
block|{
name|button
operator|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|check
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|QTabletEvent
name|ev
argument_list|(
name|type
argument_list|,
name|local
argument_list|,
name|e
operator|->
name|global
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
name|e
operator|->
name|pressure
argument_list|,
name|e
operator|->
name|xTilt
argument_list|,
name|e
operator|->
name|yTilt
argument_list|,
name|e
operator|->
name|tangentialPressure
argument_list|,
name|e
operator|->
name|rotation
argument_list|,
name|e
operator|->
name|z
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|e
operator|->
name|uid
argument_list|,
name|button
argument_list|,
name|e
operator|->
name|buttons
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|tabletState
operator|=
name|e
operator|->
name|buttons
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processTabletEnterProximityEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletEnterProximityEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletEnterProximityEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QTabletEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|TabletEnterProximity
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|,
name|e
operator|->
name|uid
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|tabletState
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qGuiApp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processTabletLeaveProximityEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTabletLeaveProximityEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TabletLeaveProximityEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|QTabletEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|TabletLeaveProximity
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|pointerType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|,
name|e
operator|->
name|uid
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|tabletState
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qGuiApp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|e
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_function
DECL|function|processGestureEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processGestureEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|GestureEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|window
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QNativeGestureEvent
name|ev
argument_list|(
name|e
operator|->
name|type
argument_list|,
name|e
operator|->
name|pos
argument_list|,
name|e
operator|->
name|pos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|,
name|e
operator|->
name|realValue
argument_list|,
name|e
operator|->
name|sequenceId
argument_list|,
name|e
operator|->
name|intValue
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_function
DECL|function|processPlatformPanelEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processPlatformPanelEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|PlatformPanelEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|window
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow events through
return|return;
block|}
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|PlatformPanel
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_function
DECL|function|processContextMenuEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processContextMenuEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ContextMenuEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// Widgets do not care about mouse triggered context menu events. Also, do not forward event
comment|// to a window blocked by a modal window.
if|if
condition|(
operator|!
name|e
operator|->
name|window
operator|||
name|e
operator|->
name|mouseTriggered
operator|||
name|e
operator|->
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
return|return;
name|QContextMenuEvent
name|ev
argument_list|(
name|QContextMenuEvent
operator|::
name|Keyboard
argument_list|,
name|e
operator|->
name|pos
argument_list|,
name|e
operator|->
name|globalPos
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qHash
name|Q_GUI_EXPORT
name|uint
name|qHash
parameter_list|(
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|k
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|k
operator|.
name|device
argument_list|)
operator|+
name|k
operator|.
name|touchPointId
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|Q_GUI_EXPORT
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|a
parameter_list|,
specifier|const
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
modifier|&
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|device
operator|==
name|b
operator|.
name|device
operator|&&
name|a
operator|.
name|touchPointId
operator|==
name|b
operator|.
name|touchPointId
return|;
block|}
end_function
begin_function
DECL|function|processTouchEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processTouchEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|TouchEvent
modifier|*
name|e
parameter_list|)
block|{
name|QGuiApplicationPrivate
modifier|*
name|d
init|=
name|self
decl_stmt|;
name|modifier_buttons
operator|=
name|e
operator|->
name|modifiers
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|touchType
operator|==
name|QEvent
operator|::
name|TouchCancel
condition|)
block|{
comment|// The touch sequence has been canceled (e.g. by the compositor).
comment|// Send the TouchCancel to all windows with active touches and clean up.
name|QTouchEvent
name|touchEvent
argument_list|(
name|QEvent
operator|::
name|TouchCancel
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|ActiveTouchPointsKey
argument_list|,
name|ActiveTouchPointsValue
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|ite
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QWindow
modifier|*
argument_list|>
name|windowsNeedingCancel
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ite
condition|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|it
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
name|windowsNeedingCancel
operator|.
name|insert
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
for|for
control|(
name|QSet
argument_list|<
name|QWindow
operator|*
argument_list|>
operator|::
name|const_iterator
name|winIt
init|=
name|windowsNeedingCancel
operator|.
name|constBegin
argument_list|()
init|,
name|winItEnd
init|=
name|windowsNeedingCancel
operator|.
name|constEnd
argument_list|()
init|;
name|winIt
operator|!=
name|winItEnd
condition|;
operator|++
name|winIt
control|)
block|{
name|touchEvent
operator|.
name|setWindow
argument_list|(
operator|*
name|winIt
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
operator|*
name|winIt
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|e
operator|->
name|synthetic
argument_list|()
condition|)
block|{
for|for
control|(
name|QHash
argument_list|<
name|QWindow
operator|*
argument_list|,
name|SynthesizedMouseData
argument_list|>
operator|::
name|const_iterator
name|synthIt
init|=
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|constBegin
argument_list|()
init|,
name|synthItEnd
init|=
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|constEnd
argument_list|()
init|;
name|synthIt
operator|!=
name|synthItEnd
condition|;
operator|++
name|synthIt
control|)
block|{
if|if
condition|(
operator|!
name|synthIt
operator|->
name|window
condition|)
continue|continue;
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
name|fake
argument_list|(
name|synthIt
operator|->
name|window
operator|.
name|data
argument_list|()
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|synthIt
operator|->
name|pos
argument_list|,
name|synthIt
operator|->
name|screenPos
argument_list|,
name|buttons
operator|&
operator|~
name|Qt
operator|::
name|LeftButton
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|Qt
operator|::
name|MouseEventSynthesizedByQt
argument_list|)
decl_stmt|;
name|fake
operator|.
name|flags
operator||=
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
operator|::
name|Synthetic
expr_stmt|;
name|processMouseEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|self
operator|->
name|activeTouchPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|self
operator|->
name|lastTouchType
operator|=
name|e
operator|->
name|touchType
expr_stmt|;
return|return;
block|}
comment|// Prevent sending ill-formed event sequences: Cancel can only be followed by a Begin.
if|if
condition|(
name|self
operator|->
name|lastTouchType
operator|==
name|QEvent
operator|::
name|TouchCancel
operator|&&
name|e
operator|->
name|touchType
operator|!=
name|QEvent
operator|::
name|TouchBegin
condition|)
return|return;
name|self
operator|->
name|lastTouchType
operator|=
name|e
operator|->
name|touchType
expr_stmt|;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|window
operator|.
name|data
argument_list|()
decl_stmt|;
typedef|typedef
name|QPair
argument_list|<
name|Qt
operator|::
name|TouchPointStates
argument_list|,
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
argument_list|>
name|StatesAndTouchPoints
typedef|;
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
name|windowsNeedingEvents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|points
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|e
operator|->
name|points
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// explicitly detach from the original touch point that we got, so even
comment|// if the touchpoint structs are reused, we will make a copy that we'll
comment|// deliver to the user (which might want to store the struct for later use).
name|touchPoint
operator|.
name|d
operator|=
name|touchPoint
operator|.
name|d
operator|->
name|detach
argument_list|()
expr_stmt|;
comment|// update state
name|QPointer
argument_list|<
name|QWindow
argument_list|>
name|w
decl_stmt|;
name|QTouchEvent
operator|::
name|TouchPoint
name|previousTouchPoint
decl_stmt|;
name|ActiveTouchPointsKey
name|touchInfoKey
argument_list|(
name|e
operator|->
name|device
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|ActiveTouchPointsValue
modifier|&
name|touchInfo
init|=
name|d
operator|->
name|activeTouchPoints
index|[
name|touchInfoKey
index|]
decl_stmt|;
switch|switch
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
if|if
condition|(
name|e
operator|->
name|device
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
comment|// on touch-pads, send all touch points to the same widget
name|w
operator|=
name|d
operator|->
name|activeTouchPoints
operator|.
name|isEmpty
argument_list|()
condition|?
name|QPointer
argument_list|<
name|QWindow
argument_list|>
argument_list|()
else|:
name|d
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
operator|.
name|value
argument_list|()
operator|.
name|window
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|w
condition|)
block|{
comment|// determine which window this event will go to
if|if
condition|(
operator|!
name|window
condition|)
name|window
operator|=
name|QGuiApplication
operator|::
name|topLevelAt
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
continue|continue;
name|w
operator|=
name|window
expr_stmt|;
block|}
name|touchInfo
operator|.
name|window
operator|=
name|w
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
name|touchInfo
operator|.
name|touchPoint
operator|=
name|touchPoint
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|w
operator|=
name|touchInfo
operator|.
name|window
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
name|previousTouchPoint
operator|=
name|touchInfo
operator|.
name|touchPoint
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|0.
argument_list|)
expr_stmt|;
break|break;
default|default:
name|w
operator|=
name|touchInfo
operator|.
name|window
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
name|previousTouchPoint
operator|=
name|touchInfo
operator|.
name|touchPoint
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
comment|// Stationary points might not be delivered down to the receiving item
comment|// and get their position transformed, keep the old values instead.
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|!=
name|Qt
operator|::
name|TouchPointStationary
condition|)
name|touchInfo
operator|.
name|touchPoint
operator|=
name|touchPoint
expr_stmt|;
break|break;
block|}
name|Q_ASSERT
argument_list|(
name|w
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// make the *scene* functions return the same as the *screen* functions
name|touchPoint
operator|.
name|d
operator|->
name|sceneRect
operator|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScenePos
operator|=
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScenePos
operator|=
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
expr_stmt|;
name|StatesAndTouchPoints
modifier|&
name|maskAndPoints
init|=
name|windowsNeedingEvents
index|[
name|w
operator|.
name|data
argument_list|()
index|]
decl_stmt|;
name|maskAndPoints
operator|.
name|first
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
name|maskAndPoints
operator|.
name|second
operator|.
name|append
argument_list|(
name|touchPoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|windowsNeedingEvents
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|windowsNeedingEvents
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QWindow
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|end
init|=
name|windowsNeedingEvents
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|QEvent
operator|::
name|Type
name|eventType
decl_stmt|;
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchBegin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchEnd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointStationary
case|:
comment|// don't send the event if nothing changed
continue|continue;
default|default:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchUpdate
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|blockedByModalWindow
condition|)
block|{
comment|// a modal window is blocking this window, don't allow touch events through
comment|// QTBUG-37371 temporary fix; TODO: revisit in 5.4 when we have a forwarding solution
if|if
condition|(
name|eventType
operator|==
name|QEvent
operator|::
name|TouchEnd
condition|)
block|{
comment|// but don't leave dangling state: e.g.
comment|// QQuickWindowPrivate::itemForTouchPointId needs to be cleared.
name|QTouchEvent
name|touchEvent
argument_list|(
name|QEvent
operator|::
name|TouchCancel
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|modifiers
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|QTouchEvent
name|touchEvent
argument_list|(
name|eventType
argument_list|,
name|e
operator|->
name|device
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|second
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|e
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|w
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pointCount
init|=
name|touchEvent
operator|.
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|.
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
comment|// preserve the sub-pixel resolution
name|QRectF
name|rect
init|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|screenPos
init|=
name|rect
operator|.
name|center
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|delta
init|=
name|screenPos
operator|-
name|screenPos
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|screenPos
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointPressed
condition|)
block|{
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|synthetic
argument_list|()
operator|&&
operator|!
name|touchEvent
operator|.
name|isAccepted
argument_list|()
operator|&&
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_SynthesizeMouseForUnhandledTouchEvents
argument_list|)
condition|)
block|{
comment|// exclude devices which generate their own mouse events
if|if
condition|(
operator|!
operator|(
name|touchEvent
operator|.
name|device
argument_list|()
operator|->
name|capabilities
argument_list|()
operator|&
name|QTouchDevice
operator|::
name|MouseEmulation
operator|)
condition|)
block|{
name|Qt
operator|::
name|MouseButtons
name|b
init|=
name|eventType
operator|==
name|QEvent
operator|::
name|TouchEnd
condition|?
name|Qt
operator|::
name|NoButton
else|:
name|Qt
operator|::
name|LeftButton
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|Qt
operator|::
name|NoButton
condition|)
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|touchEvent
operator|.
name|touchPoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventType
operator|==
name|QEvent
operator|::
name|TouchBegin
condition|)
name|m_fakeMouseSourcePointId
operator|=
name|touchPoints
operator|.
name|first
argument_list|()
operator|.
name|id
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|id
argument_list|()
operator|==
name|m_fakeMouseSourcePointId
condition|)
block|{
if|if
condition|(
name|b
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
name|self
operator|->
name|synthesizedMousePoints
operator|.
name|insert
argument_list|(
name|w
argument_list|,
name|SynthesizedMouseData
argument_list|(
name|touchPoint
operator|.
name|pos
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|QWindowSystemInterfacePrivate
operator|::
name|MouseEvent
name|fake
argument_list|(
name|w
argument_list|,
name|e
operator|->
name|timestamp
argument_list|,
name|touchPoint
operator|.
name|pos
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|,
name|b
operator||
operator|(
name|buttons
operator|&
operator|~
name|Qt
operator|::
name|LeftButton
operator|)
argument_list|,
name|e
operator|->
name|modifiers
argument_list|,
name|Qt
operator|::
name|MouseEventSynthesizedByQt
argument_list|)
decl_stmt|;
name|fake
operator|.
name|flags
operator||=
name|QWindowSystemInterfacePrivate
operator|::
name|WindowSystemEvent
operator|::
name|Synthetic
expr_stmt|;
name|processMouseEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|// Remove released points from the hash table only after the event is
comment|// delivered. When the receiver is a widget, QApplication will access
comment|// activeTouchPoints during delivery and therefore nothing can be removed
comment|// before sending the event.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|points
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|e
operator|->
name|points
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
name|d
operator|->
name|activeTouchPoints
operator|.
name|remove
argument_list|(
name|ActiveTouchPointsKey
argument_list|(
name|e
operator|->
name|device
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|reportScreenOrientationChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenOrientationEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
operator|=
name|e
operator|->
name|orientation
expr_stmt|;
name|updateFilteredScreenOrientation
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateFilteredScreenOrientation
name|void
name|QGuiApplicationPrivate
operator|::
name|updateFilteredScreenOrientation
parameter_list|(
name|QScreen
modifier|*
name|s
parameter_list|)
block|{
name|Qt
operator|::
name|ScreenOrientation
name|o
init|=
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
name|o
operator|=
name|s
operator|->
name|primaryOrientation
argument_list|()
expr_stmt|;
name|o
operator|=
name|Qt
operator|::
name|ScreenOrientation
argument_list|(
name|o
operator|&
name|s
operator|->
name|orientationUpdateMask
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
return|return;
if|if
condition|(
name|o
operator|==
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|filteredOrientation
condition|)
return|return;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|filteredOrientation
operator|=
name|o
expr_stmt|;
name|reportScreenOrientationChange
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reportScreenOrientationChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportScreenOrientationChange
parameter_list|(
name|QScreen
modifier|*
name|s
parameter_list|)
block|{
emit|emit
name|s
operator|->
name|orientationChanged
argument_list|(
name|s
operator|->
name|orientation
argument_list|()
argument_list|)
emit|;
name|QScreenOrientationChangeEvent
name|event
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|orientation
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reportGeometryChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportGeometryChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenGeometryEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|bool
name|geometryChanged
init|=
name|e
operator|->
name|geometry
operator|!=
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|geometry
operator|=
name|e
operator|->
name|geometry
expr_stmt|;
name|bool
name|availableGeometryChanged
init|=
name|e
operator|->
name|availableGeometry
operator|!=
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|availableGeometry
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|availableGeometry
operator|=
name|e
operator|->
name|availableGeometry
expr_stmt|;
if|if
condition|(
name|geometryChanged
condition|)
block|{
name|Qt
operator|::
name|ScreenOrientation
name|primaryOrientation
init|=
name|s
operator|->
name|primaryOrientation
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|updatePrimaryOrientation
argument_list|()
expr_stmt|;
emit|emit
name|s
operator|->
name|geometryChanged
argument_list|(
name|s
operator|->
name|geometry
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|physicalSizeChanged
argument_list|(
name|s
operator|->
name|physicalSize
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|physicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|physicalDotsPerInch
argument_list|()
argument_list|)
emit|;
emit|emit
name|s
operator|->
name|logicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|logicalDotsPerInch
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|s
operator|->
name|primaryOrientation
argument_list|()
operator|!=
name|primaryOrientation
condition|)
emit|emit
name|s
operator|->
name|primaryOrientationChanged
argument_list|(
name|s
operator|->
name|primaryOrientation
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|PrimaryOrientation
condition|)
name|updateFilteredScreenOrientation
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|availableGeometryChanged
condition|)
emit|emit
name|s
operator|->
name|availableGeometryChanged
argument_list|(
name|s
operator|->
name|availableGeometry
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|geometryChanged
operator|||
name|availableGeometryChanged
condition|)
block|{
foreach|foreach
control|(
name|QScreen
modifier|*
name|sibling
decl|,
name|s
operator|->
name|virtualSiblings
argument_list|()
control|)
emit|emit
name|sibling
operator|->
name|virtualGeometryChanged
argument_list|(
name|sibling
operator|->
name|virtualGeometry
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|reportLogicalDotsPerInchChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportLogicalDotsPerInchChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenLogicalDotsPerInchEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|logicalDpi
operator|=
name|QDpi
argument_list|(
name|e
operator|->
name|dpiX
argument_list|,
name|e
operator|->
name|dpiY
argument_list|)
expr_stmt|;
emit|emit
name|s
operator|->
name|logicalDotsPerInchChanged
argument_list|(
name|s
operator|->
name|logicalDotsPerInch
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|reportRefreshRateChange
name|void
name|QGuiApplicationPrivate
operator|::
name|reportRefreshRateChange
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ScreenRefreshRateEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// This operation only makes sense after the QGuiApplication constructor runs
if|if
condition|(
name|QCoreApplication
operator|::
name|startingUp
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|e
operator|->
name|screen
condition|)
return|return;
name|QScreen
modifier|*
name|s
init|=
name|e
operator|->
name|screen
operator|.
name|data
argument_list|()
decl_stmt|;
name|qreal
name|rate
init|=
name|e
operator|->
name|rate
decl_stmt|;
comment|// safeguard ourselves against buggy platform behavior...
if|if
condition|(
name|rate
operator|<
literal|1.0
condition|)
name|rate
operator|=
literal|60.0
expr_stmt|;
if|if
condition|(
operator|!
name|qFuzzyCompare
argument_list|(
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|refreshRate
argument_list|,
name|rate
argument_list|)
condition|)
block|{
name|s
operator|->
name|d_func
argument_list|()
operator|->
name|refreshRate
operator|=
name|rate
expr_stmt|;
emit|emit
name|s
operator|->
name|refreshRateChanged
argument_list|(
name|s
operator|->
name|refreshRate
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|processExposeEvent
name|void
name|QGuiApplicationPrivate
operator|::
name|processExposeEvent
parameter_list|(
name|QWindowSystemInterfacePrivate
operator|::
name|ExposeEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|exposed
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|e
operator|->
name|exposed
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QWindowPrivate
modifier|*
name|p
init|=
name|qt_window_private
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|receivedExpose
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|resizeEventPending
condition|)
block|{
comment|// as a convenience for plugins, send a resize event before the first expose event if they haven't done so
comment|// window->geometry() should have a valid size as soon as a handle exists.
name|QResizeEvent
name|e
argument_list|(
name|window
operator|->
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|p
operator|->
name|geometry
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|p
operator|->
name|resizeEventPending
operator|=
literal|false
expr_stmt|;
block|}
name|p
operator|->
name|receivedExpose
operator|=
literal|true
expr_stmt|;
block|}
name|p
operator|->
name|exposed
operator|=
name|e
operator|->
name|isExposed
operator|&&
name|window
operator|->
name|screen
argument_list|()
expr_stmt|;
name|QExposeEvent
name|exposeEvent
argument_list|(
name|e
operator|->
name|region
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|window
argument_list|,
operator|&
name|exposeEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_function
DECL|function|processDrag
name|QPlatformDragQtResponse
name|QGuiApplicationPrivate
operator|::
name|processDrag
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|dropData
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|Qt
operator|::
name|DropActions
name|supportedActions
parameter_list|)
block|{
specifier|static
name|QPointer
argument_list|<
name|QWindow
argument_list|>
name|currentDragWindow
decl_stmt|;
specifier|static
name|Qt
operator|::
name|DropAction
name|lastAcceptedDropAction
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
name|QPlatformDrag
modifier|*
name|platformDrag
init|=
name|platformIntegration
argument_list|()
operator|->
name|drag
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|platformDrag
condition|)
block|{
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
literal|false
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|QRect
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dropData
condition|)
block|{
if|if
condition|(
name|currentDragWindow
operator|.
name|data
argument_list|()
operator|==
name|w
condition|)
name|currentDragWindow
operator|=
literal|0
expr_stmt|;
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
literal|false
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|QRect
argument_list|()
argument_list|)
return|;
block|}
name|QDragMoveEvent
name|me
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|currentDragWindow
condition|)
block|{
name|lastAcceptedDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
if|if
condition|(
name|currentDragWindow
condition|)
block|{
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentDragWindow
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|currentDragWindow
operator|=
name|w
expr_stmt|;
name|QDragEnterEvent
name|e
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|isAccepted
argument_list|()
operator|&&
name|e
operator|.
name|dropAction
argument_list|()
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
name|lastAcceptedDropAction
operator|=
name|e
operator|.
name|dropAction
argument_list|()
expr_stmt|;
block|}
comment|// Handling 'DragEnter' should suffice for the application.
if|if
condition|(
name|lastAcceptedDropAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
operator|&&
operator|(
name|supportedActions
operator|&
name|lastAcceptedDropAction
operator|)
condition|)
block|{
name|me
operator|.
name|setDropAction
argument_list|(
name|lastAcceptedDropAction
argument_list|)
expr_stmt|;
name|me
operator|.
name|accept
argument_list|()
expr_stmt|;
block|}
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|me
argument_list|)
expr_stmt|;
name|lastAcceptedDropAction
operator|=
name|me
operator|.
name|isAccepted
argument_list|()
condition|?
name|me
operator|.
name|dropAction
argument_list|()
else|:
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return
name|QPlatformDragQtResponse
argument_list|(
name|me
operator|.
name|isAccepted
argument_list|()
argument_list|,
name|lastAcceptedDropAction
argument_list|,
name|me
operator|.
name|answerRect
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|processDrop
name|QPlatformDropQtResponse
name|QGuiApplicationPrivate
operator|::
name|processDrop
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|dropData
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|Qt
operator|::
name|DropActions
name|supportedActions
parameter_list|)
block|{
name|QDropEvent
name|de
argument_list|(
name|p
argument_list|,
name|supportedActions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|DropAction
name|acceptedAction
init|=
name|de
operator|.
name|isAccepted
argument_list|()
condition|?
name|de
operator|.
name|dropAction
argument_list|()
else|:
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
name|QPlatformDropQtResponse
name|response
argument_list|(
name|de
operator|.
name|isAccepted
argument_list|()
argument_list|,
name|acceptedAction
argument_list|)
decl_stmt|;
return|return
name|response
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_comment
comment|/*!     Returns the object for interacting with the clipboard. */
end_comment
begin_function
DECL|function|clipboard
name|QClipboard
modifier|*
name|QGuiApplication
operator|::
name|clipboard
parameter_list|()
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qApp
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGuiApplication: Must construct a QGuiApplication before accessing a QClipboard"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
operator|=
operator|new
name|QClipboard
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|QGuiApplicationPrivate
operator|::
name|qt_clipboard
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 5.4     \fn void QGuiApplication::paletteChanged(const QPalette&palette)      This signal is emitted when the \a palette of the application changes.      \sa palette() */
end_comment
begin_comment
comment|/*!     Returns the default application palette.      \sa setPalette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QGuiApplication
operator|::
name|palette
parameter_list|()
block|{
name|initPalette
argument_list|()
expr_stmt|;
return|return
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application palette to \a pal.      \sa palette() */
end_comment
begin_function
DECL|function|setPalette
name|void
name|QGuiApplication
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|)
block|{
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|&&
name|pal
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_pal
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
else|else
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
operator|=
name|pal
expr_stmt|;
name|applicationResourceFlags
operator||=
name|ApplicationPaletteExplicitlySet
expr_stmt|;
name|QCoreApplication
operator|::
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_SetPalette
argument_list|)
expr_stmt|;
emit|emit
name|qGuiApp
operator|->
name|paletteChanged
argument_list|(
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_pal
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|applyWindowGeometrySpecificationTo
name|void
name|QGuiApplicationPrivate
operator|::
name|applyWindowGeometrySpecificationTo
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|windowGeometrySpecification
operator|.
name|applyTo
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default application font.      \sa setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGuiApplication
operator|::
name|font
parameter_list|()
block|{
name|Q_ASSERT_X
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|self
argument_list|,
literal|"QGuiApplication::font()"
argument_list|,
literal|"no QGuiApplication instance"
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
name|initFontUnlocked
argument_list|()
expr_stmt|;
return|return
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_font
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application font to \a font.      \sa font() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QGuiApplication
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_font
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_font
operator|=
name|font
expr_stmt|;
name|applicationResourceFlags
operator||=
name|ApplicationFontExplicitlySet
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGuiApplication::isRightToLeft()      Returns \c true if the application's layout direction is     Qt::RightToLeft; otherwise returns \c false.      \sa layoutDirection(), isLeftToRight() */
end_comment
begin_comment
comment|/*!     \fn bool QGuiApplication::isLeftToRight()      Returns \c true if the application's layout direction is     Qt::LeftToRight; otherwise returns \c false.      \sa layoutDirection(), isRightToLeft() */
end_comment
begin_function
DECL|function|notifyLayoutDirectionChange
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyLayoutDirectionChange
parameter_list|()
block|{
specifier|const
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|notifyActiveWindowChange
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyActiveWindowChange
parameter_list|(
name|QWindow
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \property QGuiApplication::windowIcon     \brief the default window icon      \sa QWindow::setIcon(), {Setting the Application Icon} */
end_comment
begin_function
DECL|function|windowIcon
name|QIcon
name|QGuiApplication
operator|::
name|windowIcon
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|app_icon
condition|?
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_icon
else|:
name|QIcon
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setWindowIcon
name|void
name|QGuiApplication
operator|::
name|setWindowIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|app_icon
condition|)
name|QGuiApplicationPrivate
operator|::
name|app_icon
operator|=
operator|new
name|QIcon
argument_list|()
expr_stmt|;
operator|*
name|QGuiApplicationPrivate
operator|::
name|app_icon
operator|=
name|icon
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|&&
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ApplicationIcon
argument_list|)
condition|)
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|setApplicationIcon
argument_list|(
name|icon
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QGuiApplicationPrivate
operator|::
name|is_app_closing
condition|)
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|notifyWindowIconChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notifyWindowIconChanged
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyWindowIconChanged
parameter_list|()
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|ApplicationWindowIconChange
argument_list|)
decl_stmt|;
specifier|const
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGuiApplication::quitOnLastWindowClosed      \brief whether the application implicitly quits when the last window is     closed.      The default is \c true.      If this property is \c true, the applications quits when the last visible     primary window (i.e. window with no parent) is closed.      \sa quit(), QWindow::close()  */
end_comment
begin_function
DECL|function|setQuitOnLastWindowClosed
name|void
name|QGuiApplication
operator|::
name|setQuitOnLastWindowClosed
parameter_list|(
name|bool
name|quit
parameter_list|)
block|{
name|QCoreApplication
operator|::
name|setQuitLockEnabled
argument_list|(
name|quit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|quitOnLastWindowClosed
name|bool
name|QGuiApplication
operator|::
name|quitOnLastWindowClosed
parameter_list|()
block|{
return|return
name|QCoreApplication
operator|::
name|isQuitLockEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::lastWindowClosed()      This signal is emitted from exec() when the last visible     primary window (i.e. window with no parent) is closed.      By default, QGuiApplication quits after this signal is emitted. This feature     can be turned off by setting \l quitOnLastWindowClosed to \c false.      \sa QWindow::close(), QWindow::isTopLevel() */
end_comment
begin_function
DECL|function|emitLastWindowClosed
name|void
name|QGuiApplicationPrivate
operator|::
name|emitLastWindowClosed
parameter_list|()
block|{
if|if
condition|(
name|qGuiApp
operator|&&
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
condition|)
block|{
emit|emit
name|qGuiApp
operator|->
name|lastWindowClosed
argument_list|()
emit|;
block|}
block|}
end_function
begin_function
DECL|function|shouldQuit
name|bool
name|QGuiApplicationPrivate
operator|::
name|shouldQuit
parameter_list|()
block|{
specifier|const
name|QWindowList
name|processedWindows
decl_stmt|;
return|return
name|shouldQuitInternal
argument_list|(
name|processedWindows
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|shouldQuitInternal
name|bool
name|QGuiApplicationPrivate
operator|::
name|shouldQuitInternal
parameter_list|(
specifier|const
name|QWindowList
modifier|&
name|processedWindows
parameter_list|)
block|{
comment|/* if there is no visible top-level window left, we allow the quit */
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|processedWindows
operator|.
name|contains
argument_list|(
name|w
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|transientParent
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|tryCloseAllWindows
name|bool
name|QGuiApplicationPrivate
operator|::
name|tryCloseAllWindows
parameter_list|()
block|{
return|return
name|tryCloseRemainingWindows
argument_list|(
name|QWindowList
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|tryCloseRemainingWindows
name|bool
name|QGuiApplicationPrivate
operator|::
name|tryCloseRemainingWindows
parameter_list|(
name|QWindowList
name|processedWindows
parameter_list|)
block|{
name|QWindowList
name|list
init|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|processedWindows
operator|.
name|contains
argument_list|(
name|w
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|close
argument_list|()
condition|)
return|return
literal|false
return|;
name|processedWindows
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|list
operator|=
name|QGuiApplication
operator|::
name|topLevelWindows
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2     \fn Qt::ApplicationState QGuiApplication::applicationState()       Returns the current state of the application.      You can react to application state changes to perform actions such as     stopping/resuming CPU-intensive tasks, freeing/loading resources or     saving/restoring application data.  */
end_comment
begin_function
DECL|function|applicationState
name|Qt
operator|::
name|ApplicationState
name|QGuiApplication
operator|::
name|applicationState
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|applicationState
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2     \fn void QGuiApplication::applicationStateChanged(Qt::ApplicationState state)      This signal is emitted when the \a state of the application changes.      \sa applicationState() */
end_comment
begin_function
DECL|function|setApplicationState
name|void
name|QGuiApplicationPrivate
operator|::
name|setApplicationState
parameter_list|(
name|Qt
operator|::
name|ApplicationState
name|state
parameter_list|,
name|bool
name|forcePropagate
parameter_list|)
block|{
if|if
condition|(
operator|(
name|applicationState
operator|==
name|state
operator|)
operator|&&
operator|!
name|forcePropagate
condition|)
return|return;
name|applicationState
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Qt
operator|::
name|ApplicationActive
case|:
block|{
name|QEvent
name|appActivate
argument_list|(
name|QEvent
operator|::
name|ApplicationActivate
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appActivate
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|ApplicationInactive
case|:
block|{
name|QEvent
name|appDeactivate
argument_list|(
name|QEvent
operator|::
name|ApplicationDeactivate
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appDeactivate
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|QApplicationStateChangeEvent
name|event
argument_list|(
name|applicationState
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
emit|emit
name|qApp
operator|->
name|applicationStateChanged
argument_list|(
name|applicationState
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \fn void QGuiApplication::commitDataRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     emitted when the QSessionManager wants the application to commit all its     data.      Usually this means saving all open files, after getting permission from     the user. Furthermore you may want to provide a means by which the user     can cancel the shutdown.      You should not exit the application within this signal. Instead,     the session manager may or may not do this afterwards, depending on the     context.      \warning Within this signal, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details and example     usage.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), saveStateRequest(), {Session Management} */
end_comment
begin_comment
comment|/*!     \since 4.2     \fn void QGuiApplication::saveStateRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     invoked when the \l{QSessionManager}{session manager} wants the application     to preserve its state for a future session.      For example, a text editor would create a temporary file that includes the     current contents of its edit buffers, the location of the cursor and other     aspects of the current editing session.      You should never exit the application within this signal. Instead, the     session manager may or may not do this afterwards, depending on the     context. Futhermore, most session managers will very likely request a saved     state immediately after the application has been started. This permits the     session manager to learn about the application's restart policy.      \warning Within this signal, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), commitDataRequest(), {Session Management} */
end_comment
begin_comment
comment|/*!     \fn bool QGuiApplication::isSessionRestored() const      Returns \c true if the application has been restored from an earlier     \l{Session Management}{session}; otherwise returns \c false.      \sa sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \since 5.0     \fn bool QGuiApplication::isSavingSession() const      Returns \c true if the application is currently saving the     \l{Session Management}{session}; otherwise returns \c false.      This is \c true when commitDataRequest() and saveStateRequest() are emitted,     but also when the windows are closed afterwards by session management.      \sa sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \fn QString QGuiApplication::sessionId() const      Returns the current \l{Session Management}{session's} identifier.      If the application has been restored from an earlier session, this     identifier is the same as it was in that previous session. The session     identifier is guaranteed to be unique both for different applications     and for different instances of the same application.      \sa isSessionRestored(), sessionKey(), commitDataRequest(), saveStateRequest() */
end_comment
begin_comment
comment|/*!     \fn QString QGuiApplication::sessionKey() const      Returns the session key in the current \l{Session Management}{session}.      If the application has been restored from an earlier session, this key is     the same as it was when the previous session ended.      The session key changes every time the session is saved. If the shutdown process     is cancelled, another session key will be used when shutting down again.      \sa isSessionRestored(), sessionId(), commitDataRequest(), saveStateRequest() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_function
DECL|function|isSessionRestored
name|bool
name|QGuiApplication
operator|::
name|isSessionRestored
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_session_restored
return|;
block|}
end_function
begin_function
DECL|function|sessionId
name|QString
name|QGuiApplication
operator|::
name|sessionId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_manager
operator|->
name|sessionId
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|sessionKey
name|QString
name|QGuiApplication
operator|::
name|sessionKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_manager
operator|->
name|sessionKey
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isSavingSession
name|bool
name|QGuiApplication
operator|::
name|isSavingSession
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGuiApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_saving_session
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Function that can be used to sync Qt state with the Window Systems state.      This function will first empty Qts events by calling QCoreApplication::processEvents(),     then the platform plugin will sync up with the windowsystem, and finally Qts events     will be delived by another call to QCoreApplication::processEvents();      This function is timeconsuming and its use is discouraged. */
end_comment
begin_function
DECL|function|sync
name|void
name|QGuiApplication
operator|::
name|sync
parameter_list|()
block|{
name|QCoreApplication
operator|::
name|processEvents
argument_list|()
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|&&
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|SyncState
argument_list|)
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|platform_integration
operator|->
name|sync
argument_list|()
expr_stmt|;
name|QCoreApplication
operator|::
name|processEvents
argument_list|()
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|flushWindowSystemEvents
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|commitData
name|void
name|QGuiApplicationPrivate
operator|::
name|commitData
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|is_saving_session
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|commitDataRequest
argument_list|(
operator|*
name|session_manager
argument_list|)
emit|;
if|if
condition|(
name|session_manager
operator|->
name|allowsInteraction
argument_list|()
operator|&&
operator|!
name|tryCloseAllWindows
argument_list|()
condition|)
name|session_manager
operator|->
name|cancel
argument_list|()
expr_stmt|;
name|is_saving_session
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|saveState
name|void
name|QGuiApplicationPrivate
operator|::
name|saveState
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|is_saving_session
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|saveStateRequest
argument_list|(
operator|*
name|session_manager
argument_list|)
emit|;
name|is_saving_session
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SESSIONMANAGER
end_comment
begin_comment
comment|/*!     \property QGuiApplication::layoutDirection     \brief the default layout direction for this application      On system start-up, the default layout direction depends on the     application's language.      The notifier signal was introduced in Qt 5.4.      \sa QWidget::layoutDirection, isLeftToRight(), isRightToLeft()  */
end_comment
begin_function
DECL|function|setLayoutDirection
name|void
name|QGuiApplication
operator|::
name|setLayoutDirection
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
if|if
condition|(
name|layout_direction
operator|==
name|direction
operator|||
name|direction
operator|==
name|Qt
operator|::
name|LayoutDirectionAuto
condition|)
return|return;
name|layout_direction
operator|=
name|direction
expr_stmt|;
if|if
condition|(
name|qGuiApp
condition|)
block|{
emit|emit
name|qGuiApp
operator|->
name|layoutDirectionChanged
argument_list|(
name|direction
argument_list|)
emit|;
name|QGuiApplicationPrivate
operator|::
name|self
operator|->
name|notifyLayoutDirectionChange
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|layoutDirection
name|Qt
operator|::
name|LayoutDirection
name|QGuiApplication
operator|::
name|layoutDirection
parameter_list|()
block|{
return|return
name|layout_direction
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QCursor *QGuiApplication::overrideCursor()      Returns the active application override cursor.      This function returns 0 if no application cursor has been defined (i.e. the     internal cursor stack is empty).      \sa setOverrideCursor(), restoreOverrideCursor() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|overrideCursor
name|QCursor
modifier|*
name|QGuiApplication
operator|::
name|overrideCursor
parameter_list|()
block|{
name|CHECK_QAPP_INSTANCE
argument_list|(
argument|Q_NULLPTR
argument_list|)
return|return
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|&
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the currently active application override cursor to \a cursor.      This function has no effect if setOverrideCursor() was not called.      \sa setOverrideCursor(), overrideCursor(), restoreOverrideCursor(),     QWidget::setCursor()  */
end_comment
begin_function
DECL|function|changeOverrideCursor
name|void
name|QGuiApplication
operator|::
name|changeOverrideCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|CHECK_QAPP_INSTANCE
argument_list|()
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|setOverrideCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|applyCursor
specifier|static
specifier|inline
name|void
name|applyCursor
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
name|QCursor
name|c
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|w
operator|->
name|screen
argument_list|()
condition|)
if|if
condition|(
name|QPlatformCursor
modifier|*
name|cursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
name|cursor
operator|->
name|changeCursor
argument_list|(
operator|&
name|c
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unsetCursor
specifier|static
specifier|inline
name|void
name|unsetCursor
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|w
operator|->
name|screen
argument_list|()
condition|)
if|if
condition|(
name|QPlatformCursor
modifier|*
name|cursor
init|=
name|screen
operator|->
name|handle
argument_list|()
operator|->
name|cursor
argument_list|()
condition|)
name|cursor
operator|->
name|changeCursor
argument_list|(
literal|0
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applyCursor
specifier|static
specifier|inline
name|void
name|applyCursor
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QWindow
modifier|*
argument_list|>
modifier|&
name|l
parameter_list|,
specifier|const
name|QCursor
modifier|&
name|c
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|handle
argument_list|()
operator|&&
name|w
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
name|applyCursor
argument_list|(
name|w
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|applyWindowCursor
specifier|static
specifier|inline
name|void
name|applyWindowCursor
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QWindow
modifier|*
argument_list|>
modifier|&
name|l
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|w
init|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|handle
argument_list|()
operator|&&
name|w
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
if|if
condition|(
name|qt_window_private
argument_list|(
name|w
argument_list|)
operator|->
name|hasCursor
condition|)
block|{
name|applyCursor
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsetCursor
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::setOverrideCursor(const QCursor&cursor)      Sets the application override cursor to \a cursor.      Application override cursors are intended for showing the user that the     application is in a special state, for example during an operation that     might take some time.      This cursor will be displayed in all the application's widgets until     restoreOverrideCursor() or another setOverrideCursor() is called.      Application cursors are stored on an internal stack. setOverrideCursor()     pushes the cursor onto the stack, and restoreOverrideCursor() pops the     active cursor off the stack. changeOverrideCursor() changes the curently     active application override cursor.      Every setOverrideCursor() must eventually be followed by a corresponding     restoreOverrideCursor(), otherwise the stack will never be emptied.      Example:     \snippet code/src_gui_kernel_qguiapplication_x11.cpp 0      \sa overrideCursor(), restoreOverrideCursor(), changeOverrideCursor(),     QWidget::setCursor() */
end_comment
begin_function
DECL|function|setOverrideCursor
name|void
name|QGuiApplication
operator|::
name|setOverrideCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|CHECK_QAPP_INSTANCE
argument_list|()
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|prepend
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|applyCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::restoreOverrideCursor()      Undoes the last setOverrideCursor().      If setOverrideCursor() has been called twice, calling     restoreOverrideCursor() will activate the first cursor set. Calling this     function a second time restores the original widgets' cursors.      \sa setOverrideCursor(), overrideCursor() */
end_comment
begin_function
DECL|function|restoreOverrideCursor
name|void
name|QGuiApplication
operator|::
name|restoreOverrideCursor
parameter_list|()
block|{
name|CHECK_QAPP_INSTANCE
argument_list|()
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QCursor
name|c
argument_list|(
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|applyCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|applyWindowCursor
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|window_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CURSOR
end_comment
begin_comment
comment|/*!   Returns the application's style hints.    The style hints encapsulate a set of platform dependent properties   such as double click intervals, full width selection and others.    The hints can be used to integrate tighter with the underlying platform.    \sa QStyleHints   */
end_comment
begin_function
DECL|function|styleHints
name|QStyleHints
modifier|*
name|QGuiApplication
operator|::
name|styleHints
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|styleHints
condition|)
name|QGuiApplicationPrivate
operator|::
name|styleHints
operator|=
operator|new
name|QStyleHints
argument_list|()
expr_stmt|;
return|return
name|QGuiApplicationPrivate
operator|::
name|styleHints
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether Qt should use the system's standard colors, fonts, etc., to     \a on. By default, this is \c true.      This function must be called before creating the QGuiApplication object, like     this:      \snippet code/src_gui_kernel_qguiapplication.cpp 0      \sa desktopSettingsAware() */
end_comment
begin_function
DECL|function|setDesktopSettingsAware
name|void
name|QGuiApplication
operator|::
name|setDesktopSettingsAware
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if Qt is set to use the system's standard colors, fonts, etc.;     otherwise returns \c false. The default is \c true.      \sa setDesktopSettingsAware() */
end_comment
begin_function
DECL|function|desktopSettingsAware
name|bool
name|QGuiApplication
operator|::
name|desktopSettingsAware
parameter_list|()
block|{
return|return
name|QGuiApplicationPrivate
operator|::
name|obey_desktop_settings
return|;
block|}
end_function
begin_comment
comment|/*!   returns the input method.    The input method returns properties about the state and position of   the virtual keyboard. It also provides information about the position of the   current focused input element.    \sa QInputMethod   */
end_comment
begin_function
DECL|function|inputMethod
name|QInputMethod
modifier|*
name|QGuiApplication
operator|::
name|inputMethod
parameter_list|()
block|{
name|CHECK_QAPP_INSTANCE
argument_list|(
argument|Q_NULLPTR
argument_list|)
if|if
condition|(
operator|!
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
condition|)
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
operator|=
operator|new
name|QInputMethod
argument_list|()
expr_stmt|;
return|return
name|qGuiApp
operator|->
name|d_func
argument_list|()
operator|->
name|inputMethod
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGuiApplication::fontDatabaseChanged()      This signal is emitted when application fonts are loaded or removed.      \sa QFontDatabase::addApplicationFont(),     QFontDatabase::addApplicationFontFromData(),     QFontDatabase::removeAllApplicationFonts(),     QFontDatabase::removeApplicationFont() */
end_comment
begin_function
DECL|function|getPixmapCursor
name|QPixmap
name|QGuiApplicationPrivate
operator|::
name|getPixmapCursor
parameter_list|(
name|Qt
operator|::
name|CursorShape
name|cshape
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|cshape
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|notifyThemeChanged
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyThemeChanged
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|applicationResourceFlags
operator|&
name|ApplicationPaletteExplicitlySet
operator|)
condition|)
block|{
name|clearPalette
argument_list|()
expr_stmt|;
name|initPalette
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|applicationResourceFlags
operator|&
name|ApplicationFontExplicitlySet
operator|)
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|applicationFontMutex
argument_list|)
decl_stmt|;
name|clearFontUnlocked
argument_list|()
expr_stmt|;
name|initFontUnlocked
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_function
DECL|function|notifyDragStarted
name|void
name|QGuiApplicationPrivate
operator|::
name|notifyDragStarted
parameter_list|(
specifier|const
name|QDrag
modifier|*
name|drag
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|drag
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|gammaTables
specifier|const
name|QDrawHelperGammaTables
modifier|*
name|QGuiApplicationPrivate
operator|::
name|gammaTables
parameter_list|()
block|{
name|QDrawHelperGammaTables
modifier|*
name|result
init|=
name|m_gammaTables
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|QDrawHelperGammaTables
modifier|*
name|tables
init|=
operator|new
name|QDrawHelperGammaTables
argument_list|(
name|fontSmoothingGamma
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_gammaTables
operator|.
name|testAndSetRelease
argument_list|(
literal|0
argument_list|,
name|tables
argument_list|)
condition|)
operator|delete
name|tables
expr_stmt|;
name|result
operator|=
name|m_gammaTables
operator|.
name|load
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|_q_updateFocusObject
name|void
name|QGuiApplicationPrivate
operator|::
name|_q_updateFocusObject
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGuiApplication
argument_list|)
expr_stmt|;
name|QPlatformInputContext
modifier|*
name|inputContext
init|=
name|platformIntegration
argument_list|()
operator|->
name|inputContext
argument_list|()
decl_stmt|;
name|bool
name|enabled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|object
operator|&&
name|inputContext
condition|)
block|{
name|QInputMethodQueryEvent
name|query
argument_list|(
name|Qt
operator|::
name|ImEnabled
operator||
name|Qt
operator|::
name|ImHints
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|object
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
name|enabled
operator|=
name|query
operator|.
name|value
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
operator|.
name|toBool
argument_list|()
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
specifier|static
specifier|const
name|bool
name|supportsHiddenText
init|=
name|inputContext
operator|->
name|hasCapability
argument_list|(
name|QPlatformInputContext
operator|::
name|HiddenTextCapability
argument_list|)
decl_stmt|;
specifier|const
name|Qt
operator|::
name|InputMethodHints
name|hints
init|=
cast|static_cast
argument_list|<
name|Qt
operator|::
name|InputMethodHints
argument_list|>
argument_list|(
name|query
operator|.
name|value
argument_list|(
name|Qt
operator|::
name|ImHints
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|hints
operator|&
name|Qt
operator|::
name|ImhHiddenText
operator|)
operator|&&
operator|!
name|supportsHiddenText
condition|)
name|enabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|QPlatformInputContextPrivate
operator|::
name|setInputMethodAccepted
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputContext
condition|)
name|inputContext
operator|->
name|setFocusObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|focusObjectChanged
argument_list|(
name|object
argument_list|)
emit|;
block|}
end_function
begin_enum
enum|enum
block|{
DECL|enumerator|MouseCapsMask
name|MouseCapsMask
init|=
literal|0xFF
block|,
DECL|enumerator|MouseSourceMaskDst
name|MouseSourceMaskDst
init|=
literal|0xFF00
block|,
DECL|enumerator|MouseSourceMaskSrc
name|MouseSourceMaskSrc
init|=
name|MouseCapsMask
block|,
DECL|enumerator|MouseSourceShift
name|MouseSourceShift
init|=
literal|8
block|,
DECL|enumerator|MouseFlagsCapsMask
name|MouseFlagsCapsMask
init|=
literal|0xFF0000
block|,
DECL|enumerator|MouseFlagsShift
name|MouseFlagsShift
init|=
literal|16
block|}
enum|;
end_enum
begin_function
DECL|function|mouseEventCaps
name|int
name|QGuiApplicationPrivate
operator|::
name|mouseEventCaps
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|event
operator|->
name|caps
operator|&
name|MouseCapsMask
return|;
block|}
end_function
begin_function
DECL|function|mouseEventVelocity
name|QVector2D
name|QGuiApplicationPrivate
operator|::
name|mouseEventVelocity
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|event
operator|->
name|velocity
return|;
block|}
end_function
begin_function
DECL|function|setMouseEventCapsAndVelocity
name|void
name|QGuiApplicationPrivate
operator|::
name|setMouseEventCapsAndVelocity
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|int
name|caps
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|velocity
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|caps
operator|<=
name|MouseCapsMask
argument_list|)
expr_stmt|;
name|event
operator|->
name|caps
operator|&=
operator|~
name|MouseCapsMask
expr_stmt|;
name|event
operator|->
name|caps
operator||=
name|caps
operator|&
name|MouseCapsMask
expr_stmt|;
name|event
operator|->
name|velocity
operator|=
name|velocity
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mouseEventSource
name|Qt
operator|::
name|MouseEventSource
name|QGuiApplicationPrivate
operator|::
name|mouseEventSource
parameter_list|(
specifier|const
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|Qt
operator|::
name|MouseEventSource
argument_list|(
operator|(
name|event
operator|->
name|caps
operator|&
name|MouseSourceMaskDst
operator|)
operator|>>
name|MouseSourceShift
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setMouseEventSource
name|void
name|QGuiApplicationPrivate
operator|::
name|setMouseEventSource
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|Qt
operator|::
name|MouseEventSource
name|source
parameter_list|)
block|{
comment|// Mouse event synthesization status is encoded in the caps field because
comment|// QTouchDevice::CapabilityFlag uses only 6 bits from it.
name|int
name|value
init|=
name|source
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|value
operator|<=
name|MouseSourceMaskSrc
argument_list|)
expr_stmt|;
name|event
operator|->
name|caps
operator|&=
operator|~
name|MouseSourceMaskDst
expr_stmt|;
name|event
operator|->
name|caps
operator||=
operator|(
name|value
operator|&
name|MouseSourceMaskSrc
operator|)
operator|<<
name|MouseSourceShift
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mouseEventFlags
name|Qt
operator|::
name|MouseEventFlags
name|QGuiApplicationPrivate
operator|::
name|mouseEventFlags
parameter_list|(
specifier|const
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|Qt
operator|::
name|MouseEventFlags
argument_list|(
operator|(
name|event
operator|->
name|caps
operator|&
name|MouseFlagsCapsMask
operator|)
operator|>>
name|MouseFlagsShift
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setMouseEventFlags
name|void
name|QGuiApplicationPrivate
operator|::
name|setMouseEventFlags
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|Qt
operator|::
name|MouseEventFlags
name|flags
parameter_list|)
block|{
comment|// use the 0x00FF0000 byte from caps (containing up to 7 mouse event flags)
name|unsigned
name|int
name|value
init|=
name|flags
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|value
operator|<=
name|Qt
operator|::
name|MouseEventFlagMask
argument_list|)
expr_stmt|;
name|event
operator|->
name|caps
operator|&=
operator|~
name|MouseFlagsCapsMask
expr_stmt|;
name|event
operator|->
name|caps
operator||=
operator|(
name|value
operator|&
name|Qt
operator|::
name|MouseEventFlagMask
operator|)
operator|<<
name|MouseFlagsShift
expr_stmt|;
block|}
end_function
begin_function
DECL|function|inputDeviceManager
name|QInputDeviceManager
modifier|*
name|QGuiApplicationPrivate
operator|::
name|inputDeviceManager
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|QGuiApplication
operator|::
name|instance
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_inputDeviceManager
condition|)
name|m_inputDeviceManager
operator|=
operator|new
name|QInputDeviceManager
argument_list|(
name|QGuiApplication
operator|::
name|instance
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|m_inputDeviceManager
return|;
block|}
end_function
begin_include
include|#
directive|include
file|"moc_qguiapplication.cpp"
end_include
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
