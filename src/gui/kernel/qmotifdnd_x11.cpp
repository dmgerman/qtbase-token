begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/* The following copyright notice pertains to the code as contributed to Qt, not to Nokia's modifications. It is replicated in doc/dnd.doc, where the documentation system can see it. */
end_comment
begin_comment
comment|/* Copyright 1996 Daniel Dardailler.     Permission to use, copy, modify, distribute, and sell this software    for any purpose is hereby granted without fee, provided that the above    copyright notice appear in all copies and that both that copyright    notice and this permission notice appear in supporting documentation,    and that the name of Daniel Dardailler not be used in advertising or    publicity pertaining to distribution of the software without specific,    written prior permission.  Daniel Dardailler makes no representations    about the suitability of this software for any purpose.  It is    provided "as is" without express or implied warranty.     Modifications Copyright 1999 Matt Koss, under the same license as    above. ************************************************************/
end_comment
begin_comment
comment|/***********************************************************/
end_comment
begin_comment
comment|/* Motif Drag&Drop Dynamic Protocol messaging API code */
end_comment
begin_comment
comment|/* Only requires Xlib layer - not MT safe */
end_comment
begin_comment
comment|/* Author: Daniel Dardailler, daniel@x.org */
end_comment
begin_comment
comment|/* Adapted by: Matt Koss, koss@napri.sk */
end_comment
begin_comment
comment|/* Further adaptions by: Nokia Corporation and/or its subsidiary(-ies) */
end_comment
begin_comment
comment|/***********************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qt_x11_p.h"
end_include
begin_include
include|#
directive|include
file|"qx11info_x11.h"
end_include
begin_include
include|#
directive|include
file|"qiodevice.h"
end_include
begin_include
include|#
directive|include
file|"qdnd_p.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|sourceWindow
specifier|static
name|Window
name|sourceWindow
init|=
name|XNone
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|dropWidget
specifier|static
name|QWidget
modifier|*
name|dropWidget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lastAcceptedAction
specifier|static
name|Qt
operator|::
name|DropAction
name|lastAcceptedAction
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|Dnd_selection
specifier|static
name|Atom
name|Dnd_selection
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|Dnd_selection_time
specifier|static
name|Time
name|Dnd_selection_time
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|src_targets
specifier|static
name|Atom
modifier|*
name|src_targets
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_src_targets
specifier|static
name|ushort
name|num_src_targets
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Motif definitions
end_comment
begin_define
DECL|macro|DndVersion
define|#
directive|define
name|DndVersion
value|1
end_define
begin_define
DECL|macro|DndRevision
define|#
directive|define
name|DndRevision
value|0
end_define
begin_define
DECL|macro|DndIncludeVersion
define|#
directive|define
name|DndIncludeVersion
value|(DndVersion * 10 + DndRevision)
end_define
begin_comment
comment|/* The following values are used in the DndData structure */
end_comment
begin_comment
comment|/* protocol style */
end_comment
begin_define
DECL|macro|DND_DRAG_NONE
define|#
directive|define
name|DND_DRAG_NONE
value|0
end_define
begin_define
DECL|macro|DND_DRAG_DROP_ONLY
define|#
directive|define
name|DND_DRAG_DROP_ONLY
value|1
end_define
begin_define
DECL|macro|DND_DRAG_DYNAMIC
define|#
directive|define
name|DND_DRAG_DYNAMIC
value|5
end_define
begin_comment
comment|/* message type */
end_comment
begin_define
DECL|macro|DND_TOP_LEVEL_ENTER
define|#
directive|define
name|DND_TOP_LEVEL_ENTER
value|0
end_define
begin_define
DECL|macro|DND_TOP_LEVEL_LEAVE
define|#
directive|define
name|DND_TOP_LEVEL_LEAVE
value|1
end_define
begin_define
DECL|macro|DND_DRAG_MOTION
define|#
directive|define
name|DND_DRAG_MOTION
value|2
end_define
begin_define
DECL|macro|DND_DROP_SITE_ENTER
define|#
directive|define
name|DND_DROP_SITE_ENTER
value|3
end_define
begin_define
DECL|macro|DND_DROP_SITE_LEAVE
define|#
directive|define
name|DND_DROP_SITE_LEAVE
value|4
end_define
begin_define
DECL|macro|DND_DROP_START
define|#
directive|define
name|DND_DROP_START
value|5
end_define
begin_define
DECL|macro|DND_OPERATION_CHANGED
define|#
directive|define
name|DND_OPERATION_CHANGED
value|8
end_define
begin_comment
comment|/* operation(s) */
end_comment
begin_define
DECL|macro|DND_NOOP
define|#
directive|define
name|DND_NOOP
value|0L
end_define
begin_define
DECL|macro|DND_MOVE
define|#
directive|define
name|DND_MOVE
value|(1L<< 0)
end_define
begin_define
DECL|macro|DND_COPY
define|#
directive|define
name|DND_COPY
value|(1L<< 1)
end_define
begin_define
DECL|macro|DND_LINK
define|#
directive|define
name|DND_LINK
value|(1L<< 2)
end_define
begin_function
DECL|function|DndOperationsToQtDropActions
specifier|static
name|Qt
operator|::
name|DropActions
name|DndOperationsToQtDropActions
parameter_list|(
name|uchar
name|op
parameter_list|)
block|{
name|Qt
operator|::
name|DropActions
name|actions
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
if|if
condition|(
name|op
operator||
name|DND_MOVE
condition|)
name|actions
operator||=
name|Qt
operator|::
name|MoveAction
expr_stmt|;
if|if
condition|(
name|op
operator||
name|DND_COPY
condition|)
name|actions
operator||=
name|Qt
operator|::
name|CopyAction
expr_stmt|;
if|if
condition|(
name|op
operator||
name|DND_LINK
condition|)
name|actions
operator||=
name|Qt
operator|::
name|LinkAction
expr_stmt|;
return|return
name|actions
return|;
block|}
end_function
begin_function
DECL|function|QtDropActionToDndOperation
specifier|static
name|uchar
name|QtDropActionToDndOperation
parameter_list|(
name|Qt
operator|::
name|DropAction
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|action
operator|&
name|Qt
operator|::
name|ActionMask
condition|)
block|{
case|case
name|Qt
operator|::
name|CopyAction
case|:
default|default:
return|return
name|DND_COPY
return|;
case|case
name|Qt
operator|::
name|MoveAction
case|:
return|return
name|DND_MOVE
return|;
case|case
name|Qt
operator|::
name|LinkAction
case|:
return|return
name|DND_LINK
return|;
block|}
block|}
end_function
begin_comment
comment|/* status */
end_comment
begin_define
DECL|macro|DND_NO_DROP_SITE
define|#
directive|define
name|DND_NO_DROP_SITE
value|1
end_define
begin_define
DECL|macro|DND_INVALID_DROP_SITE
define|#
directive|define
name|DND_INVALID_DROP_SITE
value|2
end_define
begin_define
DECL|macro|DND_VALID_DROP_SITE
define|#
directive|define
name|DND_VALID_DROP_SITE
value|3
end_define
begin_comment
comment|/* completion */
end_comment
begin_define
DECL|macro|DND_DROP
define|#
directive|define
name|DND_DROP
value|0
end_define
begin_define
DECL|macro|DND_DROP_HELP
define|#
directive|define
name|DND_DROP_HELP
value|1
end_define
begin_define
DECL|macro|DND_DROP_CANCEL
define|#
directive|define
name|DND_DROP_CANCEL
value|2
end_define
begin_define
DECL|macro|BYTE
define|#
directive|define
name|BYTE
value|unsigned char
end_define
begin_define
DECL|macro|CARD32
define|#
directive|define
name|CARD32
value|unsigned int
end_define
begin_define
DECL|macro|CARD16
define|#
directive|define
name|CARD16
value|unsigned short
end_define
begin_define
DECL|macro|INT16
define|#
directive|define
name|INT16
value|signed short
end_define
begin_comment
comment|/* Client side structure used in the API */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|reason
name|unsigned
name|char
name|reason
decl_stmt|;
comment|/* message type: DND_TOP_LEVEL_ENTER, etc */
DECL|member|time
name|Time
name|time
decl_stmt|;
DECL|member|operation
name|unsigned
name|char
name|operation
decl_stmt|;
DECL|member|operations
name|unsigned
name|char
name|operations
decl_stmt|;
DECL|member|status
name|unsigned
name|char
name|status
decl_stmt|;
DECL|member|completion
name|unsigned
name|char
name|completion
decl_stmt|;
DECL|member|x
name|short
name|x
decl_stmt|;
DECL|member|y
name|short
name|y
decl_stmt|;
DECL|member|src_window
name|Window
name|src_window
decl_stmt|;
DECL|member|property
name|Atom
name|property
decl_stmt|;
block|}
DECL|typedef|DndData
name|DndData
typedef|;
end_typedef
begin_typedef
DECL|struct|_DndSrcProp
typedef|typedef
struct|struct
name|_DndSrcProp
block|{
DECL|member|byte_order
name|BYTE
name|byte_order
decl_stmt|;
DECL|member|protocol_version
name|BYTE
name|protocol_version
decl_stmt|;
DECL|member|target_index
name|CARD16
name|target_index
decl_stmt|;
DECL|member|selection
name|CARD32
name|selection
decl_stmt|;
block|}
DECL|typedef|DndSrcProp
name|DndSrcProp
typedef|;
end_typedef
begin_typedef
DECL|struct|_DndReceiverProp
typedef|typedef
struct|struct
name|_DndReceiverProp
block|{
DECL|member|byte_order
name|BYTE
name|byte_order
decl_stmt|;
DECL|member|protocol_version
name|BYTE
name|protocol_version
decl_stmt|;
DECL|member|protocol_style
name|BYTE
name|protocol_style
decl_stmt|;
DECL|member|pad1
name|BYTE
name|pad1
decl_stmt|;
DECL|member|proxy_window
name|CARD32
name|proxy_window
decl_stmt|;
DECL|member|num_drop_sites
name|CARD16
name|num_drop_sites
decl_stmt|;
DECL|member|pad2
name|CARD16
name|pad2
decl_stmt|;
DECL|member|total_size
name|CARD32
name|total_size
decl_stmt|;
block|}
DECL|typedef|DndReceiverProp
name|DndReceiverProp
typedef|;
end_typedef
begin_comment
comment|/* need to use some union hack since window and property are in    different order depending on the message ... */
end_comment
begin_typedef
DECL|struct|_DndTop
typedef|typedef
struct|struct
name|_DndTop
block|{
DECL|member|src_window
name|CARD32
name|src_window
decl_stmt|;
DECL|member|property
name|CARD32
name|property
decl_stmt|;
block|}
DECL|typedef|DndTop
name|DndTop
typedef|;
end_typedef
begin_typedef
DECL|struct|_DndPot
typedef|typedef
struct|struct
name|_DndPot
block|{
DECL|member|x
name|INT16
name|x
decl_stmt|;
DECL|member|y
name|INT16
name|y
decl_stmt|;
DECL|member|property
name|CARD32
name|property
decl_stmt|;
DECL|member|src_window
name|CARD32
name|src_window
decl_stmt|;
block|}
DECL|typedef|DndPot
name|DndPot
typedef|;
end_typedef
begin_typedef
DECL|struct|_DndMessage
typedef|typedef
struct|struct
name|_DndMessage
block|{
DECL|member|reason
name|BYTE
name|reason
decl_stmt|;
DECL|member|byte_order
name|BYTE
name|byte_order
decl_stmt|;
DECL|member|flags
name|CARD16
name|flags
decl_stmt|;
DECL|member|time
name|CARD32
name|time
decl_stmt|;
union|union
block|{
DECL|member|top
name|DndTop
name|top
decl_stmt|;
DECL|member|pot
name|DndPot
name|pot
decl_stmt|;
DECL|member|data
block|}
name|data
union|;
block|}
DECL|typedef|DndMessage
name|DndMessage
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|byte_order
name|BYTE
name|byte_order
decl_stmt|;
DECL|member|protocol_version
name|BYTE
name|protocol_version
decl_stmt|;
DECL|member|num_target_lists
name|CARD16
name|num_target_lists
decl_stmt|;
DECL|member|data_size
name|CARD32
name|data_size
decl_stmt|;
comment|/* then come series of CARD16,CARD32,CARD32,CARD32... */
block|}
DECL|typedef|DndTargets
name|DndTargets
typedef|;
end_typedef
begin_comment
comment|/* protocol version */
end_comment
begin_define
DECL|macro|DND_PROTOCOL_VERSION
define|#
directive|define
name|DND_PROTOCOL_VERSION
value|0
end_define
begin_define
DECL|macro|DND_EVENT_TYPE_MASK
define|#
directive|define
name|DND_EVENT_TYPE_MASK
value|((BYTE)0x80)
end_define
begin_define
DECL|macro|DND_EVENT_TYPE_SHIFT
define|#
directive|define
name|DND_EVENT_TYPE_SHIFT
value|7
end_define
begin_define
DECL|macro|DND_CLEAR_EVENT_TYPE
define|#
directive|define
name|DND_CLEAR_EVENT_TYPE
value|((BYTE)0x7F)
end_define
begin_comment
comment|/* message_type is data[0] of the client_message    this return 1 (receiver bit up) or 0 (initiator) */
end_comment
begin_define
DECL|macro|DND_GET_EVENT_TYPE
define|#
directive|define
name|DND_GET_EVENT_TYPE
parameter_list|(
name|message_type
parameter_list|)
define|\
value|((char) (((message_type)& DND_EVENT_TYPE_MASK)>> DND_EVENT_TYPE_SHIFT))
end_define
begin_comment
comment|/* event_type can be 0 (initiator) or 1 (receiver) */
end_comment
begin_define
DECL|macro|DND_SET_EVENT_TYPE
define|#
directive|define
name|DND_SET_EVENT_TYPE
parameter_list|(
name|event_type
parameter_list|)
define|\
value|(((BYTE)(event_type)<< DND_EVENT_TYPE_SHIFT)& DND_EVENT_TYPE_MASK)
end_define
begin_define
DECL|macro|DND_OPERATION_MASK
define|#
directive|define
name|DND_OPERATION_MASK
value|((CARD16) 0x000F)
end_define
begin_define
DECL|macro|DND_OPERATION_SHIFT
define|#
directive|define
name|DND_OPERATION_SHIFT
value|0
end_define
begin_define
DECL|macro|DND_STATUS_MASK
define|#
directive|define
name|DND_STATUS_MASK
value|((CARD16) 0x00F0)
end_define
begin_define
DECL|macro|DND_STATUS_SHIFT
define|#
directive|define
name|DND_STATUS_SHIFT
value|4
end_define
begin_define
DECL|macro|DND_OPERATIONS_MASK
define|#
directive|define
name|DND_OPERATIONS_MASK
value|((CARD16) 0x0F00)
end_define
begin_define
DECL|macro|DND_OPERATIONS_SHIFT
define|#
directive|define
name|DND_OPERATIONS_SHIFT
value|8
end_define
begin_define
DECL|macro|DND_COMPLETION_MASK
define|#
directive|define
name|DND_COMPLETION_MASK
value|((CARD16) 0xF000)
end_define
begin_define
DECL|macro|DND_COMPLETION_SHIFT
define|#
directive|define
name|DND_COMPLETION_SHIFT
value|12
end_define
begin_define
DECL|macro|DND_GET_OPERATION
define|#
directive|define
name|DND_GET_OPERATION
parameter_list|(
name|flags
parameter_list|)
define|\
value|((unsigned char) \ (((flags)& DND_OPERATION_MASK)>> DND_OPERATION_SHIFT))
end_define
begin_define
DECL|macro|DND_SET_OPERATION
define|#
directive|define
name|DND_SET_OPERATION
parameter_list|(
name|operation
parameter_list|)
define|\
value|(((CARD16)(operation)<< DND_OPERATION_SHIFT)\& DND_OPERATION_MASK)
end_define
begin_define
DECL|macro|DND_GET_STATUS
define|#
directive|define
name|DND_GET_STATUS
parameter_list|(
name|flags
parameter_list|)
define|\
value|((unsigned char) \ (((flags)& DND_STATUS_MASK)>> DND_STATUS_SHIFT))
end_define
begin_define
DECL|macro|DND_SET_STATUS
define|#
directive|define
name|DND_SET_STATUS
parameter_list|(
name|status
parameter_list|)
define|\
value|(((CARD16)(status)<< DND_STATUS_SHIFT)\& DND_STATUS_MASK)
end_define
begin_define
DECL|macro|DND_GET_OPERATIONS
define|#
directive|define
name|DND_GET_OPERATIONS
parameter_list|(
name|flags
parameter_list|)
define|\
value|((unsigned char) \ (((flags)& DND_OPERATIONS_MASK)>> DND_OPERATIONS_SHIFT))
end_define
begin_define
DECL|macro|DND_SET_OPERATIONS
define|#
directive|define
name|DND_SET_OPERATIONS
parameter_list|(
name|operation
parameter_list|)
define|\
value|(((CARD16)(operation)<< DND_OPERATIONS_SHIFT)\& DND_OPERATIONS_MASK)
end_define
begin_define
DECL|macro|DND_GET_COMPLETION
define|#
directive|define
name|DND_GET_COMPLETION
parameter_list|(
name|flags
parameter_list|)
define|\
value|((unsigned char) \ (((flags)& DND_COMPLETION_MASK)>> DND_COMPLETION_SHIFT))
end_define
begin_define
DECL|macro|DND_SET_COMPLETION
define|#
directive|define
name|DND_SET_COMPLETION
parameter_list|(
name|completion
parameter_list|)
define|\
value|(((CARD16)(completion)<< DND_COMPLETION_SHIFT)\& DND_COMPLETION_MASK)
end_define
begin_define
DECL|macro|SWAP4BYTES
define|#
directive|define
name|SWAP4BYTES
parameter_list|(
name|l
parameter_list|)
value|{\ struct { unsigned t :32;} bit32;\ char n, *tp = (char *)&bit32;\ bit32.t = l;\ n = tp[0]; tp[0] = tp[3]; tp[3] = n;\ n = tp[1]; tp[1] = tp[2]; tp[2] = n;\ l = bit32.t;\ }
end_define
begin_define
DECL|macro|SWAP2BYTES
define|#
directive|define
name|SWAP2BYTES
parameter_list|(
name|s
parameter_list|)
value|{\ struct { unsigned t :16; } bit16;\ char n, *tp = (char *)&bit16;\ bit16.t = s;\ n = tp[0]; tp[0] = tp[1]; tp[1] = n;\ s = bit16.t;\ }
end_define
begin_comment
comment|/** Private extern functions */
end_comment
begin_function_decl
specifier|static
name|unsigned
name|char
name|DndByteOrder
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|/***** Targets/Index stuff */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|num_targets
name|int
name|num_targets
decl_stmt|;
DECL|member|targets
name|Atom
modifier|*
name|targets
decl_stmt|;
block|}
DECL|typedef|DndTargetsTableEntryRec
DECL|typedef|DndTargetsTableEntry
name|DndTargetsTableEntryRec
operator|,
typedef|*
name|DndTargetsTableEntry
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|num_entries
name|int
name|num_entries
decl_stmt|;
DECL|member|entries
name|DndTargetsTableEntry
name|entries
decl_stmt|;
block|}
DECL|typedef|DndTargetsTableRec
DECL|typedef|DndTargetsTable
name|DndTargetsTableRec
operator|,
typedef|*
name|DndTargetsTable
typedef|;
end_typedef
begin_function_decl
specifier|static
name|ushort
name|_DndIndexToTargets
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|int
name|index
parameter_list|,
name|Atom
modifier|*
modifier|*
name|targets
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qt_x11_intern_atom
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|Atom
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|DndByteOrder
specifier|static
name|unsigned
name|char
name|DndByteOrder
parameter_list|()
block|{
specifier|static
name|unsigned
name|char
name|byte_order
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|byte_order
condition|)
block|{
name|unsigned
name|int
name|endian
init|=
literal|1
decl_stmt|;
name|byte_order
operator|=
operator|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|endian
operator|)
operator|)
condition|?
literal|'l'
else|:
literal|'B'
expr_stmt|;
block|}
return|return
name|byte_order
return|;
block|}
end_function
begin_function
DECL|function|DndReadSourceProperty
specifier|static
name|void
name|DndReadSourceProperty
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|Window
name|window
parameter_list|,
name|Atom
name|dnd_selection
parameter_list|,
name|Atom
modifier|*
modifier|*
name|targets
parameter_list|,
name|unsigned
name|short
modifier|*
name|num_targets
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|retval
init|=
literal|0
decl_stmt|;
name|Atom
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|bytesafter
decl_stmt|,
name|lengthRtn
decl_stmt|;
if|if
condition|(
operator|(
name|XGetWindowProperty
argument_list|(
name|dpy
argument_list|,
name|window
argument_list|,
name|dnd_selection
argument_list|,
literal|0L
argument_list|,
literal|100000L
argument_list|,
name|False
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_INITIATOR_INFO
argument_list|)
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|lengthRtn
argument_list|,
operator|&
name|bytesafter
argument_list|,
operator|&
name|retval
argument_list|)
operator|!=
name|Success
operator|)
operator|||
operator|(
name|type
operator|==
name|XNone
operator|)
condition|)
block|{
operator|*
name|num_targets
operator|=
literal|0
expr_stmt|;
return|return ;
block|}
name|DndSrcProp
modifier|*
name|src_prop
init|=
operator|(
name|DndSrcProp
operator|*
operator|)
name|retval
decl_stmt|;
if|if
condition|(
name|src_prop
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
block|{
name|SWAP2BYTES
argument_list|(
name|src_prop
operator|->
name|target_index
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|src_prop
operator|->
name|selection
argument_list|)
expr_stmt|;
block|}
operator|*
name|num_targets
operator|=
name|_DndIndexToTargets
argument_list|(
name|dpy
argument_list|,
name|src_prop
operator|->
name|target_index
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src_prop
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Position the _MOTIF_DRAG_RECEIVER_INFO property on the dropsite window.    Called by the receiver of the drop to indicate the    supported protocol style : dynamic, drop_only or none */
end_comment
begin_function
DECL|function|DndWriteReceiverProperty
specifier|static
name|void
name|DndWriteReceiverProperty
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|Window
name|window
parameter_list|,
name|unsigned
name|char
name|protocol_style
parameter_list|)
block|{
name|DndReceiverProp
name|receiver_prop
decl_stmt|;
comment|// squelch potential valgrind errors about uninitialized reads
name|memset
argument_list|(
operator|&
name|receiver_prop
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|receiver_prop
argument_list|)
argument_list|)
expr_stmt|;
name|receiver_prop
operator|.
name|byte_order
operator|=
name|DndByteOrder
argument_list|()
expr_stmt|;
name|receiver_prop
operator|.
name|protocol_version
operator|=
name|DND_PROTOCOL_VERSION
expr_stmt|;
name|receiver_prop
operator|.
name|protocol_style
operator|=
name|protocol_style
expr_stmt|;
name|receiver_prop
operator|.
name|proxy_window
operator|=
name|XNone
expr_stmt|;
name|receiver_prop
operator|.
name|num_drop_sites
operator|=
literal|0
expr_stmt|;
name|receiver_prop
operator|.
name|total_size
operator|=
sizeof|sizeof
argument_list|(
name|DndReceiverProp
argument_list|)
expr_stmt|;
comment|/* write the buffer to the property */
name|XChangeProperty
argument_list|(
name|dpy
argument_list|,
name|window
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_RECEIVER_INFO
argument_list|)
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_RECEIVER_INFO
argument_list|)
argument_list|,
literal|8
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|receiver_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|DndReceiverProp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* protocol style equiv (preregister stuff really) */
end_comment
begin_define
DECL|macro|DND_DRAG_DROP_ONLY_EQUIV
define|#
directive|define
name|DND_DRAG_DROP_ONLY_EQUIV
value|3
end_define
begin_define
DECL|macro|DND_DRAG_DYNAMIC_EQUIV1
define|#
directive|define
name|DND_DRAG_DYNAMIC_EQUIV1
value|2
end_define
begin_define
DECL|macro|DND_DRAG_DYNAMIC_EQUIV2
define|#
directive|define
name|DND_DRAG_DYNAMIC_EQUIV2
value|4
end_define
begin_comment
comment|/* Produce a client message to be sent by the caller */
end_comment
begin_function
DECL|function|DndFillClientMessage
specifier|static
name|void
name|DndFillClientMessage
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|Window
name|window
parameter_list|,
name|XClientMessageEvent
modifier|*
name|cm
parameter_list|,
name|DndData
modifier|*
name|dnd_data
parameter_list|,
name|char
name|receiver
parameter_list|)
block|{
name|DndMessage
modifier|*
name|dnd_message
init|=
operator|(
name|DndMessage
operator|*
operator|)
operator|&
name|cm
operator|->
name|data
operator|.
name|b
index|[
literal|0
index|]
decl_stmt|;
name|cm
operator|->
name|display
operator|=
name|dpy
expr_stmt|;
name|cm
operator|->
name|type
operator|=
name|ClientMessage
expr_stmt|;
name|cm
operator|->
name|serial
operator|=
name|LastKnownRequestProcessed
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|cm
operator|->
name|send_event
operator|=
name|True
expr_stmt|;
name|cm
operator|->
name|window
operator|=
name|window
expr_stmt|;
name|cm
operator|->
name|format
operator|=
literal|8
expr_stmt|;
name|cm
operator|->
name|message_type
operator|=
name|ATOM
argument_list|(
name|_MOTIF_DRAG_AND_DROP_MESSAGE
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|reason
operator|=
name|dnd_data
operator|->
name|reason
operator||
name|DND_SET_EVENT_TYPE
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|byte_order
operator|=
name|DndByteOrder
argument_list|()
expr_stmt|;
comment|/* we're filling in flags with more stuff that necessary,        depending on the reason, but it doesn't matter */
name|dnd_message
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|dnd_message
operator|->
name|flags
operator||=
name|DND_SET_STATUS
argument_list|(
name|dnd_data
operator|->
name|status
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|flags
operator||=
name|DND_SET_OPERATION
argument_list|(
name|dnd_data
operator|->
name|operation
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|flags
operator||=
name|DND_SET_OPERATIONS
argument_list|(
name|dnd_data
operator|->
name|operations
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|flags
operator||=
name|DND_SET_COMPLETION
argument_list|(
name|dnd_data
operator|->
name|completion
argument_list|)
expr_stmt|;
name|dnd_message
operator|->
name|time
operator|=
name|dnd_data
operator|->
name|time
expr_stmt|;
switch|switch
condition|(
name|dnd_data
operator|->
name|reason
condition|)
block|{
case|case
name|DND_DROP_SITE_LEAVE
case|:
break|break ;
case|case
name|DND_TOP_LEVEL_ENTER
case|:
case|case
name|DND_TOP_LEVEL_LEAVE
case|:
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|src_window
operator|=
name|dnd_data
operator|->
name|src_window
expr_stmt|;
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|property
operator|=
name|dnd_data
operator|->
name|property
expr_stmt|;
break|break ;
comment|/* cannot fall through since the byte layout is different in                    both set of messages, see top and pot union stuff */
case|case
name|DND_DRAG_MOTION
case|:
case|case
name|DND_OPERATION_CHANGED
case|:
case|case
name|DND_DROP_SITE_ENTER
case|:
case|case
name|DND_DROP_START
case|:
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|x
operator|=
name|dnd_data
operator|->
name|x
expr_stmt|;
comment|/* mouse position */
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|y
operator|=
name|dnd_data
operator|->
name|y
expr_stmt|;
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|src_window
operator|=
name|dnd_data
operator|->
name|src_window
expr_stmt|;
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|property
operator|=
name|dnd_data
operator|->
name|property
expr_stmt|;
break|break ;
default|default:
break|break ;
block|}
block|}
end_function
begin_function
DECL|function|DndParseClientMessage
specifier|static
name|Bool
name|DndParseClientMessage
parameter_list|(
name|XClientMessageEvent
modifier|*
name|cm
parameter_list|,
name|DndData
modifier|*
name|dnd_data
parameter_list|,
name|char
modifier|*
name|receiver
parameter_list|)
block|{
name|DndMessage
modifier|*
name|dnd_message
init|=
operator|(
name|DndMessage
operator|*
operator|)
operator|&
name|cm
operator|->
name|data
operator|.
name|b
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|message_type
operator|!=
name|ATOM
argument_list|(
name|_MOTIF_DRAG_AND_DROP_MESSAGE
argument_list|)
condition|)
block|{
return|return
name|False
return|;
block|}
if|if
condition|(
name|dnd_message
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
block|{
name|SWAP2BYTES
argument_list|(
name|dnd_message
operator|->
name|flags
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|dnd_message
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
comment|/* do the rest in the switch */
name|dnd_data
operator|->
name|reason
operator|=
name|dnd_message
operator|->
name|reason
expr_stmt|;
if|if
condition|(
name|DND_GET_EVENT_TYPE
argument_list|(
name|dnd_data
operator|->
name|reason
argument_list|)
condition|)
operator|*
name|receiver
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|receiver
operator|=
literal|0
expr_stmt|;
name|dnd_data
operator|->
name|reason
operator|&=
name|DND_CLEAR_EVENT_TYPE
expr_stmt|;
name|dnd_data
operator|->
name|time
operator|=
name|dnd_message
operator|->
name|time
expr_stmt|;
comment|/* we're reading in more stuff that necessary. but who cares */
name|dnd_data
operator|->
name|status
operator|=
name|DND_GET_STATUS
argument_list|(
name|dnd_message
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dnd_data
operator|->
name|operation
operator|=
name|DND_GET_OPERATION
argument_list|(
name|dnd_message
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dnd_data
operator|->
name|operations
operator|=
name|DND_GET_OPERATIONS
argument_list|(
name|dnd_message
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dnd_data
operator|->
name|completion
operator|=
name|DND_GET_COMPLETION
argument_list|(
name|dnd_message
operator|->
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dnd_data
operator|->
name|reason
condition|)
block|{
case|case
name|DND_TOP_LEVEL_ENTER
case|:
case|case
name|DND_TOP_LEVEL_LEAVE
case|:
if|if
condition|(
name|dnd_message
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
block|{
name|SWAP4BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|src_window
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|property
argument_list|)
expr_stmt|;
block|}
name|dnd_data
operator|->
name|src_window
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|src_window
expr_stmt|;
name|dnd_data
operator|->
name|property
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|top
operator|.
name|property
expr_stmt|;
break|break ;
comment|/* cannot fall through, see above comment in write msg */
case|case
name|DND_DRAG_MOTION
case|:
case|case
name|DND_OPERATION_CHANGED
case|:
case|case
name|DND_DROP_SITE_ENTER
case|:
case|case
name|DND_DROP_START
case|:
if|if
condition|(
name|dnd_message
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
block|{
name|SWAP2BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|x
argument_list|)
expr_stmt|;
name|SWAP2BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|y
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|property
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|src_window
argument_list|)
expr_stmt|;
block|}
name|dnd_data
operator|->
name|x
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|x
expr_stmt|;
name|dnd_data
operator|->
name|y
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|y
expr_stmt|;
name|dnd_data
operator|->
name|property
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|property
expr_stmt|;
name|dnd_data
operator|->
name|src_window
operator|=
name|dnd_message
operator|->
name|data
operator|.
name|pot
operator|.
name|src_window
expr_stmt|;
break|break ;
case|case
name|DND_DROP_SITE_LEAVE
case|:
break|break;
default|default:
break|break ;
block|}
return|return
name|True
return|;
block|}
end_function
begin_function
DECL|function|MotifWindow
specifier|static
name|Window
name|MotifWindow
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|)
block|{
name|Atom
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|bytes_after
decl_stmt|;
name|unsigned
name|char
modifier|*
name|property
init|=
literal|0
decl_stmt|;
name|Window
name|motif_window
decl_stmt|;
comment|/* this version does no caching, so it's slow: round trip each time */
if|if
condition|(
operator|(
name|XGetWindowProperty
argument_list|(
name|display
argument_list|,
name|RootWindow
argument_list|(
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_WINDOW
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|100000L
argument_list|,
name|False
argument_list|,
name|AnyPropertyType
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|bytes_after
argument_list|,
operator|&
name|property
argument_list|)
operator|==
name|Success
operator|)
operator|&&
operator|(
name|type
operator|!=
name|XNone
operator|)
condition|)
block|{
name|motif_window
operator|=
operator|*
operator|(
name|Window
operator|*
operator|)
name|property
expr_stmt|;
block|}
else|else
block|{
name|XSetWindowAttributes
name|sAttributes
decl_stmt|;
comment|/* really, this should be done on a separate connection,            with XSetCloseDownMode (RetainPermanent), so that            others don't have to recreate it; hopefully, some real            Motif application will be around to do it */
name|sAttributes
operator|.
name|override_redirect
operator|=
name|True
expr_stmt|;
name|sAttributes
operator|.
name|event_mask
operator|=
name|PropertyChangeMask
expr_stmt|;
name|motif_window
operator|=
name|XCreateWindow
argument_list|(
name|display
argument_list|,
name|RootWindow
argument_list|(
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|170
argument_list|,
operator|-
literal|560
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|InputOnly
argument_list|,
name|CopyFromParent
argument_list|,
operator|(
name|CWOverrideRedirect
operator||
name|CWEventMask
operator|)
argument_list|,
operator|&
name|sAttributes
argument_list|)
expr_stmt|;
name|XMapWindow
argument_list|(
name|display
argument_list|,
name|motif_window
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
condition|)
block|{
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|property
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|motif_window
operator|)
return|;
block|}
end_function
begin_function
DECL|function|TargetsTable
specifier|static
name|DndTargetsTable
name|TargetsTable
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|)
block|{
name|Atom
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|bytes_after
decl_stmt|;
name|Window
name|motif_window
init|=
name|MotifWindow
argument_list|(
name|display
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|retval
decl_stmt|;
name|DndTargetsTable
name|targets_table
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|target_data
decl_stmt|;
comment|/* this version does no caching, so it's slow: round trip each time */
comment|/* ideally, register for property notify on this target_list        atom and update when necessary only */
if|if
condition|(
operator|(
name|XGetWindowProperty
argument_list|(
name|display
argument_list|,
name|motif_window
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_TARGETS
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|100000L
argument_list|,
name|False
argument_list|,
name|ATOM
argument_list|(
name|_MOTIF_DRAG_TARGETS
argument_list|)
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|bytes_after
argument_list|,
operator|&
name|retval
argument_list|)
operator|!=
name|Success
operator|)
operator|||
name|type
operator|==
name|XNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMotifDND: Cannot get property on Motif window"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DndTargets
modifier|*
name|target_prop
init|=
operator|(
name|DndTargets
operator|*
operator|)
name|retval
decl_stmt|;
if|if
condition|(
name|target_prop
operator|->
name|protocol_version
operator|!=
name|DND_PROTOCOL_VERSION
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMotifDND: Protocol mismatch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_prop
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
block|{
comment|/* need to swap num_target_lists and size */
name|SWAP2BYTES
argument_list|(
name|target_prop
operator|->
name|num_target_lists
argument_list|)
expr_stmt|;
name|SWAP4BYTES
argument_list|(
name|target_prop
operator|->
name|data_size
argument_list|)
expr_stmt|;
block|}
comment|/* now parse DndTarget prop data in a TargetsTable */
name|targets_table
operator|=
operator|(
name|DndTargetsTable
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DndTargetsTableRec
argument_list|)
argument_list|)
expr_stmt|;
name|targets_table
operator|->
name|num_entries
operator|=
name|target_prop
operator|->
name|num_target_lists
expr_stmt|;
name|targets_table
operator|->
name|entries
operator|=
operator|(
name|DndTargetsTableEntry
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DndTargetsTableEntryRec
argument_list|)
operator|*
name|target_prop
operator|->
name|num_target_lists
argument_list|)
expr_stmt|;
name|target_data
operator|=
operator|(
name|char
operator|*
operator|)
name|target_prop
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|target_prop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets_table
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|CARD16
name|num_targets
decl_stmt|;
name|CARD32
name|atom
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|num_targets
argument_list|,
name|target_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|target_data
operator|+=
literal|2
expr_stmt|;
comment|/* potential swap needed here */
if|if
condition|(
name|target_prop
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
name|SWAP2BYTES
argument_list|(
name|num_targets
argument_list|)
expr_stmt|;
name|targets_table
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|num_targets
operator|=
name|num_targets
expr_stmt|;
name|targets_table
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|targets
operator|=
operator|(
name|Atom
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Atom
argument_list|)
operator|*
name|targets_table
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|num_targets
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_targets
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|atom
argument_list|,
name|target_data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|target_data
operator|+=
literal|4
expr_stmt|;
comment|/* another potential swap needed here */
if|if
condition|(
name|target_prop
operator|->
name|byte_order
operator|!=
name|DndByteOrder
argument_list|()
condition|)
name|SWAP4BYTES
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|targets_table
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|targets
index|[
name|j
index|]
operator|=
operator|(
name|Atom
operator|)
name|atom
expr_stmt|;
block|}
block|}
if|if
condition|(
name|target_prop
condition|)
block|{
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target_prop
argument_list|)
expr_stmt|;
block|}
return|return
name|targets_table
return|;
block|}
end_function
begin_function
DECL|function|_DndIndexToTargets
specifier|static
name|ushort
name|_DndIndexToTargets
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|int
name|index
parameter_list|,
name|Atom
modifier|*
modifier|*
name|targets
parameter_list|)
block|{
name|DndTargetsTable
name|targets_table
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* again, slow: no caching here, alloc/free each time */
if|if
condition|(
operator|!
operator|(
name|targets_table
operator|=
name|TargetsTable
argument_list|(
name|display
argument_list|)
operator|)
operator|||
operator|(
name|index
operator|>=
name|targets_table
operator|->
name|num_entries
operator|)
condition|)
block|{
if|if
condition|(
name|targets_table
condition|)
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|targets_table
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* transfer the correct target list index */
operator|*
name|targets
operator|=
operator|(
name|Atom
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Atom
argument_list|)
operator|*
name|targets_table
operator|->
name|entries
index|[
name|index
index|]
operator|.
name|num_targets
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|targets
argument_list|,
operator|(
name|char
operator|*
operator|)
name|targets_table
operator|->
name|entries
index|[
name|index
index|]
operator|.
name|targets
argument_list|,
sizeof|sizeof
argument_list|(
name|Atom
argument_list|)
operator|*
name|targets_table
operator|->
name|entries
index|[
name|index
index|]
operator|.
name|num_targets
argument_list|)
expr_stmt|;
comment|/* free the target table and its guts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets_table
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|targets_table
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|targets
argument_list|)
expr_stmt|;
name|int
name|tmp
init|=
name|targets_table
operator|->
name|entries
index|[
name|index
index|]
operator|.
name|num_targets
decl_stmt|;
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|targets_table
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
comment|// targets_table->entries[index].num_targets;
block|}
end_function
begin_function
DECL|function|motifdndFormat
name|QByteArray
name|QX11Data
operator|::
name|motifdndFormat
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|motifdnd_active
condition|)
return|return
literal|0
return|;
comment|// should not happen
if|if
condition|(
name|n
operator|>=
name|num_src_targets
condition|)
return|return
literal|0
return|;
name|Atom
name|target
init|=
name|src_targets
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|XA_STRING
condition|)
return|return
literal|"text/plain;charset=ISO-8859-1"
return|;
if|if
condition|(
name|target
operator|==
name|ATOM
argument_list|(
name|UTF8_STRING
argument_list|)
condition|)
return|return
literal|"text/plain;charset=UTF-8"
return|;
if|if
condition|(
name|target
operator|==
name|ATOM
argument_list|(
name|COMPOUND_TEXT
argument_list|)
condition|)
return|return
name|QByteArray
argument_list|(
literal|"text/plain;charset="
argument_list|)
operator|+
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
operator|->
name|name
argument_list|()
return|;
if|if
condition|(
name|target
operator|==
name|ATOM
argument_list|(
name|TEXT
argument_list|)
condition|)
return|return
literal|"text/plain"
return|;
return|return
operator|(
literal|"x-motif-dnd/"
operator|+
name|X11
operator|->
name|xdndAtomToString
argument_list|(
name|target
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|motifdndObtainData
name|QVariant
name|QX11Data
operator|::
name|motifdndObtainData
parameter_list|(
specifier|const
name|char
modifier|*
name|mimeType
parameter_list|)
block|{
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
name|Dnd_selection
operator|==
literal|0
operator|||
operator|!
name|dropWidget
condition|)
return|return
name|result
return|;
comment|// try to convert the selection to the requested property
comment|// qDebug("trying to convert to '%s'", mimeType);
name|int
name|n
init|=
literal|0
decl_stmt|;
name|QByteArray
name|f
decl_stmt|;
do|do
block|{
name|f
operator|=
name|motifdndFormat
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|result
return|;
name|n
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|qstricmp
argument_list|(
name|mimeType
argument_list|,
name|f
operator|.
name|data
argument_list|()
argument_list|)
condition|)
do|;
name|Atom
name|conversion_type
init|=
name|XNone
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|"text/plain;charset=ISO-8859-1"
condition|)
block|{
name|conversion_type
operator|=
name|XA_STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
literal|"text/plain;charset=UTF-8"
condition|)
block|{
name|conversion_type
operator|=
name|ATOM
argument_list|(
name|UTF8_STRING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
operator|(
name|QByteArray
argument_list|(
literal|"text/plain;charset="
argument_list|)
operator|+
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
operator|->
name|name
argument_list|()
operator|)
condition|)
block|{
name|conversion_type
operator|=
name|ATOM
argument_list|(
name|COMPOUND_TEXT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
literal|"text/plain"
condition|)
block|{
name|conversion_type
operator|=
name|ATOM
argument_list|(
name|TEXT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
literal|"x-motif-dnd/"
argument_list|)
condition|)
block|{
comment|// strip off the "x-motif-dnd/" prefix
name|conversion_type
operator|=
name|X11
operator|->
name|xdndStringToAtom
argument_list|(
name|f
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XGetSelectionOwner
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|Dnd_selection
argument_list|)
operator|==
name|XNone
condition|)
block|{
return|return
name|result
return|;
comment|// should never happen?
block|}
name|QWidget
modifier|*
name|tw
init|=
name|dropWidget
decl_stmt|;
if|if
condition|(
operator|(
name|dropWidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
name|tw
operator|=
operator|new
name|QWidget
expr_stmt|;
block|}
comment|// convert selection to the appropriate type
name|XConvertSelection
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|Dnd_selection
argument_list|,
name|conversion_type
argument_list|,
name|Dnd_selection
argument_list|,
name|tw
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|Dnd_selection_time
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|X11
operator|->
name|display
argument_list|)
expr_stmt|;
name|XEvent
name|xevent
decl_stmt|;
name|bool
name|got
init|=
name|X11
operator|->
name|clipboardWaitForEvent
argument_list|(
name|tw
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|SelectionNotify
argument_list|,
operator|&
name|xevent
argument_list|,
literal|5000
argument_list|)
decl_stmt|;
if|if
condition|(
name|got
condition|)
block|{
name|Atom
name|type
decl_stmt|;
if|if
condition|(
name|X11
operator|->
name|clipboardReadProperty
argument_list|(
name|tw
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|Dnd_selection
argument_list|,
literal|true
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
literal|0
argument_list|)
condition|)
block|{         }
block|}
comment|//   we have to convert selection in order to indicate success to the initiator
name|XConvertSelection
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|Dnd_selection
argument_list|,
name|ATOM
argument_list|(
name|XmTRANSFER_SUCCESS
argument_list|)
argument_list|,
name|Dnd_selection
argument_list|,
name|tw
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|Dnd_selection_time
argument_list|)
expr_stmt|;
comment|// wait again for SelectionNotify event
name|X11
operator|->
name|clipboardWaitForEvent
argument_list|(
name|tw
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|SelectionNotify
argument_list|,
operator|&
name|xevent
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dropWidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
operator|delete
name|tw
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|motifdndEnable
name|void
name|QX11Data
operator|::
name|motifdndEnable
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|bool
parameter_list|)
block|{
name|DndWriteReceiverProperty
argument_list|(
name|display
argument_list|,
name|widget
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|DND_DRAG_DYNAMIC
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|motifdndHandle
name|void
name|QX11Data
operator|::
name|motifdndHandle
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|XEvent
modifier|*
name|xe
parameter_list|,
name|bool
comment|/* passive */
parameter_list|)
block|{
name|XEvent
name|event
init|=
operator|*
name|xe
decl_stmt|;
name|XClientMessageEvent
name|cm
decl_stmt|;
name|DndData
name|dnd_data
decl_stmt|;
name|char
name|receiver
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|DndParseClientMessage
argument_list|(
operator|(
name|XClientMessageEvent
operator|*
operator|)
operator|&
name|event
argument_list|,
operator|&
name|dnd_data
argument_list|,
operator|&
name|receiver
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|dnd_data
operator|.
name|reason
condition|)
block|{
case|case
name|DND_DRAG_MOTION
case|:
block|{
name|QPoint
name|p
init|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|QPoint
argument_list|(
name|dnd_data
operator|.
name|x
argument_list|,
name|dnd_data
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|c
init|=
name|widget
operator|->
name|childAt
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|!
name|c
operator|->
name|acceptDrops
argument_list|()
condition|)
block|{
comment|// not over a drop site
if|if
condition|(
name|dropWidget
condition|)
block|{
name|QDragLeaveEvent
name|dragLeaveEvent
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|dragLeaveEvent
argument_list|)
expr_stmt|;
name|dropWidget
operator|=
literal|0
expr_stmt|;
name|lastAcceptedAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DROP_SITE_LEAVE
expr_stmt|;
name|dnd_data
operator|.
name|time
operator|=
name|X11
operator|->
name|time
expr_stmt|;
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DRAG_MOTION
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_NO_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|time
operator|=
name|X11
operator|->
name|time
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|DND_NOOP
expr_stmt|;
name|dnd_data
operator|.
name|operations
operator|=
name|DND_NOOP
expr_stmt|;
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|c
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|c
operator|->
name|mapFrom
argument_list|(
name|widget
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dropWidget
operator|!=
name|c
condition|)
block|{
if|if
condition|(
name|dropWidget
condition|)
block|{
name|QDragLeaveEvent
name|le
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|le
argument_list|)
expr_stmt|;
block|}
name|dropWidget
operator|=
name|c
expr_stmt|;
name|lastAcceptedAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
specifier|const
name|Qt
operator|::
name|DropActions
name|possibleActions
init|=
name|DndOperationsToQtDropActions
argument_list|(
name|dnd_data
operator|.
name|operations
argument_list|)
decl_stmt|;
name|QDragEnterEvent
name|de
argument_list|(
name|p
argument_list|,
name|possibleActions
argument_list|,
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dropData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DROP_SITE_ENTER
expr_stmt|;
name|dnd_data
operator|.
name|time
operator|=
name|X11
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|de
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|lastAcceptedAction
operator|=
name|de
operator|.
name|dropAction
argument_list|()
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_VALID_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|QtDropActionToDndOperation
argument_list|(
name|lastAcceptedAction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnd_data
operator|.
name|status
operator|=
name|DND_INVALID_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|DND_NOOP
expr_stmt|;
name|dnd_data
operator|.
name|operations
operator|=
name|DND_NOOP
expr_stmt|;
block|}
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|Qt
operator|::
name|DropActions
name|possibleActions
init|=
name|DndOperationsToQtDropActions
argument_list|(
name|dnd_data
operator|.
name|operations
argument_list|)
decl_stmt|;
name|QDragMoveEvent
name|me
argument_list|(
name|p
argument_list|,
name|possibleActions
argument_list|,
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dropData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAcceptedAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
name|me
operator|.
name|setDropAction
argument_list|(
name|lastAcceptedAction
argument_list|)
expr_stmt|;
name|me
operator|.
name|accept
argument_list|()
expr_stmt|;
block|}
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|me
argument_list|)
expr_stmt|;
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DRAG_MOTION
expr_stmt|;
name|dnd_data
operator|.
name|time
operator|=
name|X11
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|me
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|lastAcceptedAction
operator|=
name|me
operator|.
name|dropAction
argument_list|()
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_VALID_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|QtDropActionToDndOperation
argument_list|(
name|lastAcceptedAction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnd_data
operator|.
name|status
operator|=
name|DND_INVALID_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|DND_NOOP
expr_stmt|;
name|dnd_data
operator|.
name|operations
operator|=
name|DND_NOOP
expr_stmt|;
block|}
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DND_TOP_LEVEL_ENTER
case|:
block|{
comment|/* get the size of our drop site for later use */
name|motifdnd_active
operator|=
literal|true
expr_stmt|;
name|sourceWindow
operator|=
name|dnd_data
operator|.
name|src_window
expr_stmt|;
comment|/* no answer needed, just read source property */
name|DndReadSourceProperty
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|dnd_data
operator|.
name|property
argument_list|,
operator|&
name|src_targets
argument_list|,
operator|&
name|num_src_targets
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DND_TOP_LEVEL_LEAVE
case|:
block|{
name|XEvent
name|nextEvent
decl_stmt|;
if|if
condition|(
name|XCheckTypedWindowEvent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|widget
operator|->
name|winId
argument_list|()
argument_list|,
name|ClientMessage
argument_list|,
operator|&
name|nextEvent
argument_list|)
condition|)
block|{
comment|// we just want to check, not eat (should use XPeekIfEvent)
name|XPutBackEvent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|&
name|nextEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|DndParseClientMessage
argument_list|(
operator|&
name|nextEvent
operator|.
name|xclient
argument_list|,
operator|&
name|dnd_data
argument_list|,
operator|&
name|receiver
argument_list|)
operator|&&
name|dnd_data
operator|.
name|reason
operator|==
name|DND_DROP_START
condition|)
block|{
comment|// expecting drop next, keeping DnD alive
break|break;
block|}
block|}
comment|// not expecting drop, need to send drag leave events and such here
if|if
condition|(
name|dropWidget
condition|)
block|{
name|QDragLeaveEvent
name|le
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|le
argument_list|)
expr_stmt|;
block|}
name|sourceWindow
operator|=
name|XNone
expr_stmt|;
name|dropWidget
operator|=
literal|0
expr_stmt|;
name|lastAcceptedAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|motifdnd_active
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|DND_OPERATION_CHANGED
case|:
comment|// ### need to echo
break|break;
case|case
name|DND_DROP_START
case|:
block|{
name|Q_ASSERT
argument_list|(
name|motifdnd_active
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sourceWindow
operator|==
name|dnd_data
operator|.
name|src_window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dropWidget
operator|||
name|lastAcceptedAction
operator|==
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
comment|// echo DROP_START
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DROP_START
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_NO_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|DND_NOOP
expr_stmt|;
name|dnd_data
operator|.
name|operations
operator|=
name|DND_NOOP
expr_stmt|;
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
comment|// we have to convert selection in order to indicate failure to the initiator
name|XConvertSelection
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|dnd_data
operator|.
name|property
argument_list|,
name|ATOM
argument_list|(
name|XmTRANSFER_FAILURE
argument_list|)
argument_list|,
name|dnd_data
operator|.
name|property
argument_list|,
name|dnd_data
operator|.
name|src_window
argument_list|,
name|dnd_data
operator|.
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|dropWidget
condition|)
block|{
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|motifdnd_active
operator|=
literal|false
expr_stmt|;
name|sourceWindow
operator|=
name|XNone
expr_stmt|;
name|dropWidget
operator|=
literal|0
expr_stmt|;
name|lastAcceptedAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
return|return;
block|}
comment|// store selection and its time
name|Dnd_selection
operator|=
name|dnd_data
operator|.
name|property
expr_stmt|;
name|Dnd_selection_time
operator|=
name|dnd_data
operator|.
name|time
expr_stmt|;
name|QPoint
name|p
argument_list|(
name|dnd_data
operator|.
name|x
argument_list|,
name|dnd_data
operator|.
name|y
argument_list|)
decl_stmt|;
name|QDropEvent
name|de
argument_list|(
name|dropWidget
operator|->
name|mapFromGlobal
argument_list|(
name|p
argument_list|)
argument_list|,
name|Qt
operator|::
name|CopyAction
argument_list|,
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|dropData
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAcceptedAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
name|de
operator|.
name|setDropAction
argument_list|(
name|lastAcceptedAction
argument_list|)
expr_stmt|;
name|de
operator|.
name|accept
argument_list|()
expr_stmt|;
block|}
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|dropWidget
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
comment|// reset
name|Dnd_selection
operator|=
name|XNone
expr_stmt|;
name|Dnd_selection_time
operator|=
literal|0
expr_stmt|;
comment|// echo DROP_START depending on the result of the dropEvent
if|if
condition|(
name|de
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DROP_START
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_VALID_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|QtDropActionToDndOperation
argument_list|(
name|de
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnd_data
operator|.
name|reason
operator|=
name|DND_DROP_START
expr_stmt|;
name|dnd_data
operator|.
name|status
operator|=
name|DND_NO_DROP_SITE
expr_stmt|;
name|dnd_data
operator|.
name|operation
operator|=
name|DND_NOOP
expr_stmt|;
name|dnd_data
operator|.
name|operations
operator|=
name|DND_NOOP
expr_stmt|;
block|}
name|DndFillClientMessage
argument_list|(
name|event
operator|.
name|xclient
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|dnd_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|event
operator|.
name|xbutton
operator|.
name|display
argument_list|,
name|sourceWindow
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|cm
argument_list|)
expr_stmt|;
name|sourceWindow
operator|=
name|XNone
expr_stmt|;
name|dropWidget
operator|=
literal|0
expr_stmt|;
name|lastAcceptedAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|motifdnd_active
operator|=
literal|false
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
comment|//  end of switch (dnd_data.reason)
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
end_unit
