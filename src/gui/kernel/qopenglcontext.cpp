begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qpa/qplatformopenglcontext.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|"qopenglcontext.h"
end_include
begin_include
include|#
directive|include
file|"qopenglcontext_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindow.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QThreadStorage>
end_include
begin_include
include|#
directive|include
file|<QtCore/QThread>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopengl_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qwindow_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QScreen>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QGuiGLThreadContext
class|class
name|QGuiGLThreadContext
block|{
public|public:
DECL|function|QGuiGLThreadContext
name|QGuiGLThreadContext
parameter_list|()
member_init_list|:
name|context
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|~QGuiGLThreadContext
name|~
name|QGuiGLThreadContext
parameter_list|()
block|{
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qwindow_context_storage
specifier|static
name|QThreadStorage
argument_list|<
name|QGuiGLThreadContext
modifier|*
argument_list|>
name|qwindow_context_storage
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_decl_stmt
DECL|member|makeCurrentTracker
name|QHash
argument_list|<
name|QOpenGLContext
modifier|*
argument_list|,
name|bool
argument_list|>
name|QOpenGLContextPrivate
operator|::
name|makeCurrentTracker
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|makeCurrentTrackerMutex
name|QMutex
name|QOpenGLContextPrivate
operator|::
name|makeCurrentTrackerMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QOpenGLContext     \inmodule QtGui     \since 5.0     \brief The QOpenGLContext class represents a native OpenGL context, enabling            OpenGL rendering on a QSurface.      QOpenGLContext represents the OpenGL state of an underlying OpenGL context.     To set up a context, set its screen and format such that they match those     of the surface or surfaces with which the context is meant to be used, if     necessary make it share resources with other contexts with     setShareContext(), and finally call create(). Use isValid() to check if the     context was successfully initialized.      A context can be made current against a given surface by calling     makeCurrent(). When OpenGL rendering is done, call swapBuffers() to swap     the front and back buffers of the surface, so that the newly rendered     content becomes visible. To be able to support certain platforms,     QOpenGLContext requires that you call makeCurrent() again before starting     rendering a new frame, after calling swapBuffers().      If the context is temporarily not needed, such as when the application is     not rendering, it can be useful to call destroy() to free resources.     However, if you do so you will need to call create() again before the     context can be used, and you might need to recreate any OpenGL resources     and reinitialize the OpenGL state. You can connect to the     aboutToBeDestroyed() signal to clean up any resources that have been     allocated with different ownership from the QOpenGLContext itself.      Once a QOpenGLContext has been made current, you can render to it in a     platform independent way by using Qt's OpenGL enablers such as     QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram, and     QOpenGLFramebufferObject. It is also possible to use the platform's OpenGL     API directly, without using the Qt enablers, although potentially at the     cost of portability. The latter is necessary when wanting to use OpenGL 1.x     or OpenGL ES 1.x.      For more information about the OpenGL API, refer to the official     \l{OpenGL documentation}.      For an example of how to use QOpenGLContext see the     \l{OpenGL Window Example}{OpenGL Window} example.      \section1 Thread affinity      QOpenGLContext can be moved to a different thread with moveToThread(). Do     not call makeCurrent() from a different thread than the one to which the     QOpenGLContext object belongs. A context can only be current in one thread     and against one surface at a time, and a thread only has one context     current at a time.      \section1 Context resource sharing      Resources, such as framebuffer objects, textures, and vertex buffer objects     can be shared between contexts.  Use setShareContext() before calling     create() to specify that the contexts should share these resources.     QOpenGLContext internally keeps track of a QOpenGLContextGroup object which     can be accessed with shareGroup(), and which can be used to find all the     contexts in a given share group. A share group consists of all contexts that     have been successfully initialized and are sharing with an existing context in     the share group. A non-sharing context has a share group consisting of a     single context.      \section1 Default framebuffer      On certain platforms, a framebuffer other than 0 might be the default frame     buffer depending on the current surface. Instead of calling     glBindFramebuffer(0), it is recommended that you use     glBindFramebuffer(ctx->defaultFramebufferObject()), to ensure that your     application is portable between different platforms. However, if you use     QOpenGLFunctions::glBindFramebuffer(), this is done automatically for you.      \sa QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram, QOpenGLFramebufferObject */
end_comment
begin_comment
comment|/*!     \internal      Set the current context. Returns the previously current context. */
end_comment
begin_function
DECL|function|setCurrentContext
name|QOpenGLContext
modifier|*
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|threadContext
condition|)
block|{
if|if
condition|(
operator|!
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"No QTLS available. currentContext wont work"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|threadContext
operator|=
operator|new
name|QGuiGLThreadContext
expr_stmt|;
name|qwindow_context_storage
operator|.
name|setLocalData
argument_list|(
name|threadContext
argument_list|)
expr_stmt|;
block|}
name|QOpenGLContext
modifier|*
name|previous
init|=
name|threadContext
operator|->
name|context
decl_stmt|;
name|threadContext
operator|->
name|context
operator|=
name|context
expr_stmt|;
return|return
name|previous
return|;
block|}
end_function
begin_function
DECL|function|maxTextureSize
name|int
name|QOpenGLContextPrivate
operator|::
name|maxTextureSize
parameter_list|()
block|{
if|if
condition|(
name|max_texture_size
operator|!=
operator|-
literal|1
condition|)
return|return
name|max_texture_size
return|;
name|glGetIntegerv
argument_list|(
name|GL_MAX_TEXTURE_SIZE
argument_list|,
operator|&
name|max_texture_size
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES
argument_list|)
return|return
name|max_texture_size
return|;
else|#
directive|else
name|GLenum
name|proxy
init|=
name|GL_PROXY_TEXTURE_2D
decl_stmt|;
name|GLint
name|size
decl_stmt|;
name|GLint
name|next
init|=
literal|64
decl_stmt|;
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|max_texture_size
return|;
block|}
do|do
block|{
name|size
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|size
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|max_texture_size
condition|)
break|break;
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|>
name|size
condition|)
do|;
name|max_texture_size
operator|=
name|size
expr_stmt|;
return|return
name|max_texture_size
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the last context which called makeCurrent in the current thread,     or 0, if no context is current. */
end_comment
begin_function
DECL|function|currentContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|currentContext
parameter_list|()
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
name|threadContext
condition|)
block|{
return|return
name|threadContext
operator|->
name|context
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the \a first and \a second contexts are sharing OpenGL resources. */
end_comment
begin_function
DECL|function|areSharing
name|bool
name|QOpenGLContext
operator|::
name|areSharing
parameter_list|(
name|QOpenGLContext
modifier|*
name|first
parameter_list|,
name|QOpenGLContext
modifier|*
name|second
parameter_list|)
block|{
return|return
name|first
operator|->
name|shareGroup
argument_list|()
operator|==
name|second
operator|->
name|shareGroup
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the underlying platform context.      \internal */
end_comment
begin_function
DECL|function|handle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the underlying platform context with which this context is sharing.      \internal */
end_comment
begin_function
DECL|function|shareHandle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareContext
condition|)
return|return
name|d
operator|->
name|shareContext
operator|->
name|handle
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new OpenGL context instance with parent object \a parent.      Before it can be used you need to set the proper format and call create().      \sa create(), makeCurrent() */
end_comment
begin_constructor
DECL|function|QOpenGLContext
name|QOpenGLContext
operator|::
name|QOpenGLContext
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Sets the \a format the OpenGL context should be compatible with. You need     to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QOpenGLContext
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestedFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Makes this context share textures, shaders, and other OpenGL resources     with \a shareContext. You need to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setShareContext
name|void
name|QOpenGLContext
operator|::
name|setShareContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|shareContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareContext
operator|=
name|shareContext
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a screen the OpenGL context should be valid for. You need to call     create() before it takes effect. */
end_comment
begin_function
DECL|function|setScreen
name|void
name|QOpenGLContext
operator|::
name|setScreen
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to create the OpenGL context with the current configuration.      The current configuration includes the format, the share context, and the     screen.      If the OpenGL implementation on your system does not support the requested     version of OpenGL context, then QOpenGLContext will try to create the closest     matching version. The actual created context properties can be queried     using the QSurfaceFormat returned by the format() function. For example, if     you request a context that supports OpenGL 4.3 Core profile but the driver     and/or hardware only supports version 3.2 Core profile contexts then you will     get a 3.2 Core profile context.      Returns true if the native context was successfully created and is ready to     be used with makeCurrent(), swapBuffers(), etc.      \sa makeCurrent(), destroy(), format() */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLContext
operator|::
name|create
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformOpenGLContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|platformGLContext
operator|->
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
operator|->
name|isSharing
argument_list|()
condition|)
name|d
operator|->
name|shareContext
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
name|d
operator|->
name|shareContext
condition|?
name|d
operator|->
name|shareContext
operator|->
name|shareGroup
argument_list|()
else|:
operator|new
name|QOpenGLContextGroup
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|addContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
return|;
block|}
end_function
begin_comment
comment|/*!     Destroy the underlying platform context associated with this context.      If any other context is directly or indirectly sharing resources with this     context, the shared resources, which includes vertex buffer objects, shader     objects, textures, and framebuffer objects, are not freed. However,     destroying the underlying platform context frees any state associated with     the context.      After destroy() has been called, you must call create() if you wish to     use the context again.      \note This implicitly calls doneCurrent() if the context is current.      \sa create() */
end_comment
begin_function
DECL|function|destroy
name|void
name|QOpenGLContext
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
condition|)
emit|emit
name|aboutToBeDestroyed
argument_list|()
emit|;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|doneCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareGroup
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|removeContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|platformGLContext
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|functions
expr_stmt|;
name|d
operator|->
name|functions
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QOpenGLContext::aboutToBeDestroyed()      This signal is emitted before the underlying native OpenGL context is     destroyed, such that users may clean up OpenGL resources that might     otherwise be left dangling in the case of shared OpenGL contexts.      If you wish to make the context current in order to do clean-up, make sure     to only connect to the signal using a direct connection. */
end_comment
begin_comment
comment|/*!     Destroys the QOpenGLContext object.      This implicitly calls destroy(), so if this is the current context for the     thread, doneCurrent() is also called.      \sa destroy() */
end_comment
begin_destructor
DECL|function|~QOpenGLContext
name|QOpenGLContext
operator|::
name|~
name|QOpenGLContext
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QOpenGLContextPrivate
operator|::
name|cleanMakeCurrentTracker
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Returns if this context is valid, i.e. has been successfully created.      \sa create() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLContext
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
operator|&&
name|d
operator|->
name|platformGLContext
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Get the QOpenGLFunctions instance for this context.      QOpenGLContext offers this as a convenient way to access QOpenGLFunctions     without having to manage it manually.      The context or a sharing context must be current. */
end_comment
begin_function
DECL|function|functions
name|QOpenGLFunctions
modifier|*
name|QOpenGLContext
operator|::
name|functions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|functions
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFunctions
operator|*
operator|&
argument_list|>
argument_list|(
name|d
operator|->
name|functions
argument_list|)
operator|=
operator|new
name|QOpenGLExtensions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|functions
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the set of OpenGL extensions supported by this context.      The context or a sharing context must be current.      \sa hasExtension() */
end_comment
begin_function
DECL|function|extensions
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QOpenGLContext
operator|::
name|extensions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extensionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QOpenGLExtensionMatcher
name|matcher
decl_stmt|;
name|d
operator|->
name|extensionNames
operator|=
name|matcher
operator|.
name|extensions
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|extensionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this OpenGL context supports the specified OpenGL     \a extension, false otherwise.      The context or a sharing context must be current.      \sa extensions() */
end_comment
begin_function
DECL|function|hasExtension
name|bool
name|QOpenGLContext
operator|::
name|hasExtension
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|extension
parameter_list|)
specifier|const
block|{
return|return
name|extensions
argument_list|()
operator|.
name|contains
argument_list|(
name|extension
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Call this to get the default framebuffer object for the current surface.      On some platforms the default framebuffer object depends on the surface     being rendered to, and might be different from 0. Thus, instead of calling     glBindFramebuffer(0), you should call     glBindFramebuffer(ctx->defaultFramebufferObject()) if you want your     application to work across different Qt platforms.      If you use the glBindFramebuffer() in QOpenGLFunctions you do not have to     worry about this, as it automatically binds the current context's     defaultFramebufferObject() when 0 is passed. */
end_comment
begin_function
DECL|function|defaultFramebufferObject
name|GLuint
name|QOpenGLContext
operator|::
name|defaultFramebufferObject
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|surface
operator|||
operator|!
name|d
operator|->
name|surface
operator|->
name|surfaceHandle
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|defaultFramebufferObject
argument_list|(
name|d
operator|->
name|surface
operator|->
name|surfaceHandle
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Makes the context current in the current thread, against the given     \a surface. Returns true if successful.      If \a surface is 0 this is equivalent to calling doneCurrent().      Do not call this function from a different thread than the one the     QOpenGLContext instance lives in. If you wish to use QOpenGLContext from a     different thread you should first call make sure it's not current in the     current thread, by calling doneCurrent() if necessary. Then call     moveToThread(otherThread) before using it in the other thread.      \sa functions(), doneCurrent() */
end_comment
begin_function
DECL|function|makeCurrent
name|bool
name|QOpenGLContext
operator|::
name|makeCurrent
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Cannot make QOpenGLContext current in a different thread"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|doneCurrent
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|surface
operator|->
name|surfaceHandle
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|surface
operator|->
name|surfaceType
argument_list|()
operator|!=
name|QSurface
operator|::
name|OpenGLSurface
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::makeCurrent() called with non-opengl surface"
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QOpenGLContext
modifier|*
name|previous
init|=
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
operator|->
name|makeCurrent
argument_list|(
name|surface
operator|->
name|surfaceHandle
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|surface
operator|=
name|surface
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QOpenGLContextPrivate
operator|::
name|toggleMakeCurrentTracker
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|previous
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Convenience function for calling makeCurrent with a 0 surface.      This results in no context being current in the current thread.      \sa makeCurrent(), currentContext() */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QOpenGLContext
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|surface
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the surface the context has been made current with.      This is the surface passed as an argument to makeCurrent(). */
end_comment
begin_function
DECL|function|surface
name|QSurface
modifier|*
name|QOpenGLContext
operator|::
name|surface
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|surface
return|;
block|}
end_function
begin_comment
comment|/*!     Swap the back and front buffers of \a surface.      Call this to finish a frame of OpenGL rendering, and make sure to     call makeCurrent() again before you begin a new frame. */
end_comment
begin_function
DECL|function|swapBuffers
name|void
name|QOpenGLContext
operator|::
name|swapBuffers
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with null argument"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|surface
operator|->
name|surfaceType
argument_list|()
operator|!=
name|QSurface
operator|::
name|OpenGLSurface
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with non-opengl surface"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|surface
operator|->
name|surfaceClass
argument_list|()
operator|==
name|QSurface
operator|::
name|Window
operator|&&
operator|!
name|qt_window_private
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
argument_list|)
operator|->
name|receivedExpose
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with non-exposed window, behavior is undefined"
expr_stmt|;
block|}
name|QPlatformSurface
modifier|*
name|surfaceHandle
init|=
name|surface
operator|->
name|surfaceHandle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|surfaceHandle
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContextPrivate
operator|::
name|toggleMakeCurrentTracker
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called without corresponding makeCurrent()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|surface
operator|->
name|format
argument_list|()
operator|.
name|swapBehavior
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|SingleBuffer
condition|)
name|glFlush
argument_list|()
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|swapBuffers
argument_list|(
name|surfaceHandle
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resolves the function pointer to an OpenGL extension function, identified by \a procName      Returns 0 if no such function can be found. */
end_comment
begin_function
DECL|function|getProcAddress
name|QFunctionPointer
name|QOpenGLContext
operator|::
name|getProcAddress
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|procName
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|getProcAddress
argument_list|(
name|procName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of the underlying platform context, if create() has been called.      Otherwise, returns the requested format. */
end_comment
begin_function
DECL|function|format
name|QSurfaceFormat
name|QOpenGLContext
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
name|d
operator|->
name|requestedFormat
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|format
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the share group this context belongs to. */
end_comment
begin_function
DECL|function|shareGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContext
operator|::
name|shareGroup
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareGroup
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the share context this context was created with.      If the underlying platform was not able to support the requested     sharing, this will return 0. */
end_comment
begin_function
DECL|function|shareContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareContext
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareContext
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the screen the context was created for. */
end_comment
begin_function
DECL|function|screen
name|QScreen
modifier|*
name|QOpenGLContext
operator|::
name|screen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|screen
return|;
block|}
end_function
begin_comment
comment|/*!     internal: Needs to have a pointer to qGLContext. But since this is in QtGui we cant     have any type information.      \internal */
end_comment
begin_function
DECL|function|qGLContextHandle
name|void
modifier|*
name|QOpenGLContext
operator|::
name|qGLContextHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qGLContextHandle
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setQGLContextHandle
name|void
name|QOpenGLContext
operator|::
name|setQGLContextHandle
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|void
function_decl|(
modifier|*
name|qGLContextDeleteFunction
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
name|handle
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
name|qGLContextDeleteFunction
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|deleteQGLContext
name|void
name|QOpenGLContext
operator|::
name|deleteQGLContext
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|qGLContextDeleteFunction
operator|&&
name|d
operator|->
name|qGLContextHandle
condition|)
block|{
name|d
operator|->
name|qGLContextDeleteFunction
argument_list|(
name|d
operator|->
name|qGLContextHandle
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLContextGroup     \since 5.0     \brief The QOpenGLContextGroup class represents a group of contexts sharing     OpenGL resources.     \inmodule QtGui      QOpenGLContextGroup is automatically created and managed by QOpenGLContext     instances.  Its purpose is to identify all the contexts that are sharing     resources.      \sa QOpenGLContext::shareGroup() */
end_comment
begin_constructor
DECL|function|QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|QOpenGLContextGroup
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextGroupPrivate
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|~
name|QOpenGLContextGroup
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns all the QOpenGLContext objects in this share group. */
end_comment
begin_function
DECL|function|shares
name|QList
argument_list|<
name|QOpenGLContext
modifier|*
argument_list|>
name|QOpenGLContextGroup
operator|::
name|shares
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_shares
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QOpenGLContextGroup corresponding to the current context.      \sa QOpenGLContext::currentContext() */
end_comment
begin_function
DECL|function|currentContextGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContextGroup
operator|::
name|currentContextGroup
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|shareGroup
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|addContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|addContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_refs
operator|.
name|ref
argument_list|()
expr_stmt|;
name|m_shares
operator|<<
name|ctx
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|removeContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|bool
name|deleteObject
init|=
literal|false
decl_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_shares
operator|.
name|removeOne
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|m_context
operator|&&
operator|!
name|m_shares
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_context
operator|=
name|m_shares
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_refs
operator|.
name|deref
argument_list|()
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|deleteObject
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteObject
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
operator|delete
name|q
expr_stmt|;
comment|// Delete directly to prevent leak, refer to QTBUG-29056
else|else
name|q
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|cleanup
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
block|{
name|QHash
argument_list|<
name|QOpenGLMultiGroupSharedResource
modifier|*
argument_list|,
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|,
name|end
decl_stmt|;
name|end
operator|=
name|m_resources
operator|.
name|constEnd
argument_list|()
expr_stmt|;
for|for
control|(
name|it
operator|=
name|m_resources
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|it
operator|.
name|key
argument_list|()
operator|->
name|cleanup
argument_list|(
name|q
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|m_resources
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|m_sharedResources
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|m_sharedResources
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
operator|(
operator|*
name|it
operator|)
operator|->
name|m_group
operator|=
literal|0
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|m_sharedResources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|m_pendingDeletion
operator|.
name|begin
argument_list|()
argument_list|,
name|m_pendingDeletion
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deletePendingResources
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|deletePendingResources
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|pending
init|=
name|m_pendingDeletion
decl_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|pending
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|pending
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|freeResource
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|delete
operator|*
name|it
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResource     \internal     \since 5.0     \brief The QOpenGLSharedResource class is used to keep track of resources     that are shared between OpenGL contexts (like textures, framebuffer     objects, shader programs, etc), and clean them up in a safe way when     they're no longer needed.     \inmodule QtGui      The QOpenGLSharedResource instance should never be deleted, instead free()     should be called when it's no longer needed. Thus it will be put on a queue     and freed at an appropriate time (when a context in the share group becomes     current).      The sub-class needs to implement two pure virtual functions. The first,     freeResource() must be implemented to actually do the freeing, for example     call glDeleteTextures() on a texture id. Qt makes sure a valid context in     the resource's share group is current at the time. The other,     invalidateResource(), is called by Qt in the circumstance when the last     context in the share group is destroyed before free() has been called. The     implementation of invalidateResource() should set any identifiers to 0 or     set a flag to prevent them from being used later on. */
end_comment
begin_constructor
DECL|function|QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|QOpenGLSharedResource
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|)
member_init_list|:
name|m_group
argument_list|(
name|group
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|<<
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|~
name|QOpenGLSharedResource
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|// schedule the resource for deletion at an appropriate time
end_comment
begin_function
DECL|function|free
name|void
name|QOpenGLSharedResource
operator|::
name|free
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_group
condition|)
block|{
operator|delete
name|this
expr_stmt|;
return|return;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|.
name|removeOne
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_pendingDeletion
operator|<<
name|this
expr_stmt|;
comment|// can we delete right away?
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|&&
name|current
operator|->
name|shareGroup
argument_list|()
operator|==
name|m_group
condition|)
block|{
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResourceGuard     \internal     \since 5.0     \brief The QOpenGLSharedResourceGuard class is a convenience sub-class of     QOpenGLSharedResource to be used to track a single OpenGL object with a     GLuint identifier. The constructor takes a function pointer to a function     that will be used to free the resource if and when necessary.     \inmodule QtGui  */
end_comment
begin_function
DECL|function|freeResource
name|void
name|QOpenGLSharedResourceGuard
operator|::
name|freeResource
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|m_id
condition|)
block|{
name|QOpenGLFunctions
name|functions
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|m_func
argument_list|(
operator|&
name|functions
argument_list|,
name|m_id
argument_list|)
expr_stmt|;
name|m_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLMultiGroupSharedResource     \internal     \since 5.0     \brief The QOpenGLMultiGroupSharedResource keeps track of a shared resource     that might be needed from multiple contexts, like a glyph cache or gradient     cache. One instance of the object is created for each group when necessary.     The shared resource instance should have a constructor that takes a     QOpenGLContext *. To get an instance for a given context one calls     T *QOpenGLMultiGroupSharedResource::value<T>(context), where T is a sub-class     of QOpenGLSharedResource.     \inmodule QtGui      You should not call free() on QOpenGLSharedResources owned by a     QOpenGLMultiGroupSharedResource instance. */
end_comment
begin_constructor
DECL|function|QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|QOpenGLMultiGroupSharedResource
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|0
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Creating context group resource object %p."
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|~
name|QOpenGLMultiGroupSharedResource
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Deleting context group resource %p. Group size: %d."
argument_list|,
name|this
argument_list|,
name|m_groups
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_groups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QOpenGLContext
modifier|*
name|context
init|=
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
name|value
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|resource
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|active
operator|.
name|load
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QtGui: Resources are still available at program shutdown.\n"
literal|"          This is possibly caused by a leaked QOpenGLWidget, \n"
literal|"          QOpenGLFramebufferObject or QOpenGLPixelBuffer."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|insert
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|insert
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Inserting context group resource %p for context %p, managed by %p."
argument_list|,
name|value
argument_list|,
name|context
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|contains
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|append
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|active
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|value
name|QOpenGLSharedResource
modifier|*
name|QOpenGLMultiGroupSharedResource
operator|::
name|value
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
return|return
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resources
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|QOpenGLMultiGroupSharedResource
operator|::
name|resources
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|result
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QOpenGLContextGroup
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_groups
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|m_groups
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
cast|const_cast
argument_list|<
name|QOpenGLMultiGroupSharedResource
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|result
operator|<<
name|resource
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|cleanup
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Cleaning up context group resource %p, for group %p in thread %p."
argument_list|,
name|this
argument_list|,
name|group
argument_list|,
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
name|value
operator|->
name|free
argument_list|()
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_groups
operator|.
name|contains
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|removeOne
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
