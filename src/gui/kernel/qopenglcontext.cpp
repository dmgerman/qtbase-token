begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qpa/qplatformopenglcontext.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|"qopenglcontext.h"
end_include
begin_include
include|#
directive|include
file|"qopenglcontext_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindow.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QThreadStorage>
end_include
begin_include
include|#
directive|include
file|<QtCore/QThread>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopengl_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qwindow_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QScreen>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformnativeinterface.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglversionfunctionsfactory_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopengltexturehelper_p.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
end_ifndef
begin_include
include|#
directive|include
file|<QOpenGLFunctions_1_0>
end_include
begin_include
include|#
directive|include
file|<QOpenGLFunctions_3_2_Core>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QOpenGLVersionProfilePrivate
class|class
name|QOpenGLVersionProfilePrivate
block|{
public|public:
DECL|function|QOpenGLVersionProfilePrivate
name|QOpenGLVersionProfilePrivate
parameter_list|()
member_init_list|:
name|majorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|minorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|profile
argument_list|(
name|QSurfaceFormat
operator|::
name|NoProfile
argument_list|)
block|{}
DECL|member|majorVersion
name|int
name|majorVersion
decl_stmt|;
DECL|member|minorVersion
name|int
name|minorVersion
decl_stmt|;
DECL|member|profile
name|QSurfaceFormat
operator|::
name|OpenGLContextProfile
name|profile
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QOpenGLVersionProfile     \inmodule QtGui     \since 5.1     \brief The QOpenGLVersionProfile class represents the version and if applicable            the profile of an OpenGL context.      An object of this class can be passed to QOpenGLContext::versionFunctions() to     request a functions object for a specific version and profile of OpenGL.      It also contains some helper functions to check if a version supports profiles     or is a legacy version. */
end_comment
begin_comment
comment|/*!     Creates a default invalid QOpenGLVersionProfile object. */
end_comment
begin_constructor
DECL|function|QOpenGLVersionProfile
name|QOpenGLVersionProfile
operator|::
name|QOpenGLVersionProfile
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QOpenGLVersionProfilePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Creates a QOpenGLVersionProfile object initialised with the version and profile     from \a format. */
end_comment
begin_constructor
DECL|function|QOpenGLVersionProfile
name|QOpenGLVersionProfile
operator|::
name|QOpenGLVersionProfile
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QOpenGLVersionProfilePrivate
argument_list|)
block|{
name|d
operator|->
name|majorVersion
operator|=
name|format
operator|.
name|majorVersion
argument_list|()
expr_stmt|;
name|d
operator|->
name|minorVersion
operator|=
name|format
operator|.
name|minorVersion
argument_list|()
expr_stmt|;
name|d
operator|->
name|profile
operator|=
name|format
operator|.
name|profile
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QOpenGLVersionProfile
name|QOpenGLVersionProfile
operator|::
name|QOpenGLVersionProfile
parameter_list|(
specifier|const
name|QOpenGLVersionProfile
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QOpenGLVersionProfilePrivate
argument_list|)
block|{
operator|*
name|d
operator|=
operator|*
operator|(
name|other
operator|.
name|d
operator|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QOpenGLVersionProfile object. */
end_comment
begin_destructor
DECL|function|~QOpenGLVersionProfile
name|QOpenGLVersionProfile
operator|::
name|~
name|QOpenGLVersionProfile
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns the version and profile of \a rhs to this QOpenGLVersionProfile object. */
end_comment
begin_function
DECL|function|operator =
name|QOpenGLVersionProfile
modifier|&
name|QOpenGLVersionProfile
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QOpenGLVersionProfile
modifier|&
name|rhs
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|rhs
condition|)
return|return
operator|*
name|this
return|;
operator|*
name|d
operator|=
operator|*
operator|(
name|rhs
operator|.
name|d
operator|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QPair<int,int> where the components represent the major and minor OpenGL     version numbers respectively.      \sa setVersion() */
end_comment
begin_function
DECL|function|version
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|QOpenGLVersionProfile
operator|::
name|version
parameter_list|()
specifier|const
block|{
return|return
name|qMakePair
argument_list|(
name|d
operator|->
name|majorVersion
argument_list|,
name|d
operator|->
name|minorVersion
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the major and minor version numbers to \a majorVersion and \a minorVersion respectively.      \sa version() */
end_comment
begin_function
DECL|function|setVersion
name|void
name|QOpenGLVersionProfile
operator|::
name|setVersion
parameter_list|(
name|int
name|majorVersion
parameter_list|,
name|int
name|minorVersion
parameter_list|)
block|{
name|d
operator|->
name|majorVersion
operator|=
name|majorVersion
expr_stmt|;
name|d
operator|->
name|minorVersion
operator|=
name|minorVersion
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the OpenGL profile. Only makes sense if profiles are supported by this version.      \sa setProfile() */
end_comment
begin_function
DECL|function|profile
name|QSurfaceFormat
operator|::
name|OpenGLContextProfile
name|QOpenGLVersionProfile
operator|::
name|profile
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|profile
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the OpenGL profile \a profile. Only makes sense if profiles are supported by     this version.      \sa profile() */
end_comment
begin_function
DECL|function|setProfile
name|void
name|QOpenGLVersionProfile
operator|::
name|setProfile
parameter_list|(
name|QSurfaceFormat
operator|::
name|OpenGLContextProfile
name|profile
parameter_list|)
block|{
name|d
operator|->
name|profile
operator|=
name|profile
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if profiles are supported by the OpenGL version returned by version(). Only     OpenGL versions>= 3.2 support profiles.      \sa profile(), version() */
end_comment
begin_function
DECL|function|hasProfiles
name|bool
name|QOpenGLVersionProfile
operator|::
name|hasProfiles
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|->
name|majorVersion
operator|>
literal|3
operator|||
operator|(
name|d
operator|->
name|majorVersion
operator|==
literal|3
operator|&&
name|d
operator|->
name|minorVersion
operator|>
literal|1
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true is the OpenGL version returned by version() contains deprecated functions     and does not support profiles i.e. if the OpenGL version is<= 3.1. */
end_comment
begin_function
DECL|function|isLegacyVersion
name|bool
name|QOpenGLVersionProfile
operator|::
name|isLegacyVersion
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|->
name|majorVersion
operator|<
literal|3
operator|||
operator|(
name|d
operator|->
name|majorVersion
operator|==
literal|3
operator|&&
name|d
operator|->
name|minorVersion
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the version number is valid. Note that for a default constructed     QOpenGLVersionProfile object this function will return \c false.      \sa setVersion(), version() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLVersionProfile
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|majorVersion
operator|>
literal|0
operator|&&
name|d
operator|->
name|minorVersion
operator|>=
literal|0
return|;
block|}
end_function
begin_class
DECL|class|QGuiGLThreadContext
class|class
name|QGuiGLThreadContext
block|{
public|public:
DECL|function|QGuiGLThreadContext
name|QGuiGLThreadContext
parameter_list|()
member_init_list|:
name|context
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|~QGuiGLThreadContext
name|~
name|QGuiGLThreadContext
parameter_list|()
block|{
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qwindow_context_storage
specifier|static
name|QThreadStorage
argument_list|<
name|QGuiGLThreadContext
modifier|*
argument_list|>
name|qwindow_context_storage
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|global_share_context
specifier|static
name|QOpenGLContext
modifier|*
name|global_share_context
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_decl_stmt
DECL|member|makeCurrentTracker
name|QHash
argument_list|<
name|QOpenGLContext
modifier|*
argument_list|,
name|bool
argument_list|>
name|QOpenGLContextPrivate
operator|::
name|makeCurrentTracker
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|makeCurrentTrackerMutex
name|QMutex
name|QOpenGLContextPrivate
operator|::
name|makeCurrentTrackerMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal      This function is used by Qt::AA_ShareOpenGLContexts and the Qt     WebEngine to set up context sharing across multiple windows. Do     not use it for any other purpose.      Please maintain the binary compatibility of these functions. */
end_comment
begin_function
DECL|function|qt_gl_set_global_share_context
name|void
name|qt_gl_set_global_share_context
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|global_share_context
operator|=
name|context
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_gl_global_share_context
name|QOpenGLContext
modifier|*
name|qt_gl_global_share_context
parameter_list|()
block|{
return|return
name|global_share_context
return|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLContext     \inmodule QtGui     \since 5.0     \brief The QOpenGLContext class represents a native OpenGL context, enabling            OpenGL rendering on a QSurface.      QOpenGLContext represents the OpenGL state of an underlying OpenGL context.     To set up a context, set its screen and format such that they match those     of the surface or surfaces with which the context is meant to be used, if     necessary make it share resources with other contexts with     setShareContext(), and finally call create(). Use the return value or isValid()     to check if the context was successfully initialized.      A context can be made current against a given surface by calling     makeCurrent(). When OpenGL rendering is done, call swapBuffers() to swap     the front and back buffers of the surface, so that the newly rendered     content becomes visible. To be able to support certain platforms,     QOpenGLContext requires that you call makeCurrent() again before starting     rendering a new frame, after calling swapBuffers().      If the context is temporarily not needed, such as when the application is     not rendering, it can be useful to delete it in order to free resources.     You can connect to the aboutToBeDestroyed() signal to clean up any     resources that have been allocated with different ownership from the     QOpenGLContext itself.      Once a QOpenGLContext has been made current, you can render to it in a     platform independent way by using Qt's OpenGL enablers such as     QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram, and     QOpenGLFramebufferObject. It is also possible to use the platform's OpenGL     API directly, without using the Qt enablers, although potentially at the     cost of portability. The latter is necessary when wanting to use OpenGL 1.x     or OpenGL ES 1.x.      For more information about the OpenGL API, refer to the official     \l{http://www.opengl.org}{OpenGL documentation}.      For an example of how to use QOpenGLContext see the     \l{OpenGL Window Example}{OpenGL Window} example.      \section1 Thread Affinity      QOpenGLContext can be moved to a different thread with moveToThread(). Do     not call makeCurrent() from a different thread than the one to which the     QOpenGLContext object belongs. A context can only be current in one thread     and against one surface at a time, and a thread only has one context     current at a time.      \section1 Context Resource Sharing      Resources, such as framebuffer objects, textures, and vertex buffer objects     can be shared between contexts.  Use setShareContext() before calling     create() to specify that the contexts should share these resources.     QOpenGLContext internally keeps track of a QOpenGLContextGroup object which     can be accessed with shareGroup(), and which can be used to find all the     contexts in a given share group. A share group consists of all contexts that     have been successfully initialized and are sharing with an existing context in     the share group. A non-sharing context has a share group consisting of a     single context.      \section1 Default Framebuffer      On certain platforms, a framebuffer other than 0 might be the default frame     buffer depending on the current surface. Instead of calling     glBindFramebuffer(0), it is recommended that you use     glBindFramebuffer(ctx->defaultFramebufferObject()), to ensure that your     application is portable between different platforms. However, if you use     QOpenGLFunctions::glBindFramebuffer(), this is done automatically for you.      \sa QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram, QOpenGLFramebufferObject */
end_comment
begin_comment
comment|/*!     \internal      Set the current context. Returns the previously current context. */
end_comment
begin_function
DECL|function|setCurrentContext
name|QOpenGLContext
modifier|*
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|threadContext
condition|)
block|{
if|if
condition|(
operator|!
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"No QTLS available. currentContext won't work"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|threadContext
operator|=
operator|new
name|QGuiGLThreadContext
expr_stmt|;
name|qwindow_context_storage
operator|.
name|setLocalData
argument_list|(
name|threadContext
argument_list|)
expr_stmt|;
block|}
name|QOpenGLContext
modifier|*
name|previous
init|=
name|threadContext
operator|->
name|context
decl_stmt|;
name|threadContext
operator|->
name|context
operator|=
name|context
expr_stmt|;
return|return
name|previous
return|;
block|}
end_function
begin_function
DECL|function|maxTextureSize
name|int
name|QOpenGLContextPrivate
operator|::
name|maxTextureSize
parameter_list|()
block|{
if|if
condition|(
name|max_texture_size
operator|!=
operator|-
literal|1
condition|)
return|return
name|max_texture_size
return|;
name|Q_Q
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|QOpenGLFunctions
modifier|*
name|funcs
init|=
name|q
operator|->
name|functions
argument_list|()
decl_stmt|;
name|funcs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_MAX_TEXTURE_SIZE
argument_list|,
operator|&
name|max_texture_size
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
if|if
condition|(
operator|!
name|q
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|GLenum
name|proxy
init|=
name|GL_PROXY_TEXTURE_2D
decl_stmt|;
name|GLint
name|size
decl_stmt|;
name|GLint
name|next
init|=
literal|64
decl_stmt|;
name|funcs
operator|->
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QOpenGLFunctions_1_0
modifier|*
name|gl1funcs
init|=
literal|0
decl_stmt|;
name|QOpenGLFunctions_3_2_Core
modifier|*
name|gl3funcs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|format
argument_list|()
operator|.
name|profile
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|CoreProfile
condition|)
block|{
name|gl3funcs
operator|=
name|q
operator|->
name|versionFunctions
argument_list|<
name|QOpenGLFunctions_3_2_Core
argument_list|>
argument_list|()
expr_stmt|;
name|gl3funcs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|gl1funcs
operator|=
name|q
operator|->
name|versionFunctions
argument_list|<
name|QOpenGLFunctions_1_0
argument_list|>
argument_list|()
expr_stmt|;
name|gl1funcs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|gl1funcs
operator|||
name|gl3funcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gl1funcs
condition|)
name|gl1funcs
operator|->
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
else|else
name|gl3funcs
operator|->
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|max_texture_size
return|;
block|}
do|do
block|{
name|size
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|size
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|max_texture_size
condition|)
break|break;
name|funcs
operator|->
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gl1funcs
condition|)
name|gl1funcs
operator|->
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
else|else
name|gl3funcs
operator|->
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|>
name|size
condition|)
do|;
name|max_texture_size
operator|=
name|size
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_OPENGL_ES
return|return
name|max_texture_size
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last context which called makeCurrent in the current thread,     or 0, if no context is current. */
end_comment
begin_function
DECL|function|currentContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|currentContext
parameter_list|()
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
name|threadContext
condition|)
block|{
return|return
name|threadContext
operator|->
name|context
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the \a first and \a second contexts are sharing OpenGL resources. */
end_comment
begin_function
DECL|function|areSharing
name|bool
name|QOpenGLContext
operator|::
name|areSharing
parameter_list|(
name|QOpenGLContext
modifier|*
name|first
parameter_list|,
name|QOpenGLContext
modifier|*
name|second
parameter_list|)
block|{
return|return
name|first
operator|->
name|shareGroup
argument_list|()
operator|==
name|second
operator|->
name|shareGroup
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the underlying platform context.      \internal */
end_comment
begin_function
DECL|function|handle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the underlying platform context with which this context is sharing.      \internal */
end_comment
begin_function
DECL|function|shareHandle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareContext
condition|)
return|return
name|d
operator|->
name|shareContext
operator|->
name|handle
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new OpenGL context instance with parent object \a parent.      Before it can be used you need to set the proper format and call create().      \sa create(), makeCurrent() */
end_comment
begin_constructor
DECL|function|QOpenGLContext
name|QOpenGLContext
operator|::
name|QOpenGLContext
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Sets the \a format the OpenGL context should be compatible with. You need     to call create() before it takes effect.      When the format is not explicitly set via this function, the format returned     by QSurfaceFormat::defaultFormat() will be used. This means that when having     multiple contexts, individual calls to this function can be replaced by one     single call to QSurfaceFormat::setDefaultFormat() before creating the first     context. */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QOpenGLContext
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestedFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Makes this context share textures, shaders, and other OpenGL resources     with \a shareContext. You need to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setShareContext
name|void
name|QOpenGLContext
operator|::
name|setShareContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|shareContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareContext
operator|=
name|shareContext
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a screen the OpenGL context should be valid for. You need to call     create() before it takes effect. */
end_comment
begin_function
DECL|function|setScreen
name|void
name|QOpenGLContext
operator|::
name|setScreen
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Set the native handles for this context. When create() is called and a     native handle is set, configuration settings, like format(), are ignored     since this QOpenGLContext will wrap an already created native context     instead of creating a new one from scratch.      On some platforms the native context handle is not sufficient and other     related handles (for example, for a window or display) have to be provided     in addition. Therefore \a handle is variant containing a platform-specific     value type. These classes can be found in the QtPlatformHeaders module.      When create() is called with native handles set, QOpenGLContext does not     take ownership of the handles, so destroying the QOpenGLContext does not     destroy the native context.      \note Some frameworks track the current context and surfaces internally.     Making the adopted QOpenGLContext current via Qt will have no effect on such     other frameworks' internal state. Therefore a subsequent makeCurrent done     via the other framework may have no effect. It is therefore advisable to     make explicit calls to make no context and surface current to reset the     other frameworks' internal state after performing OpenGL operations via Qt.      \note Using foreign contexts with Qt windows and Qt contexts with windows     and surfaces created by other frameworks may give unexpected results,     depending on the platform, due to potential mismatches in context and window     pixel formats. To make sure this does not happen, avoid making contexts and     surfaces from different frameworks current together. Instead, prefer     approaches based on context sharing where OpenGL resources like textures are     accessible both from Qt's and the foreign framework's contexts.      \since 5.4     \sa nativeHandle() */
end_comment
begin_function
DECL|function|setNativeHandle
name|void
name|QOpenGLContext
operator|::
name|setNativeHandle
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|handle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|nativeHandle
operator|=
name|handle
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the native handle for the context.      This function provides access to the QOpenGLContext's underlying native     context. The returned variant contains a platform-specific value type. These     classes can be found in the module QtPlatformHeaders.      On platforms where retrieving the native handle is not supported, or if     neither create() nor setNativeHandle() was called, a null variant is     returned.      \since 5.4     \sa setNativeHandle()  */
end_comment
begin_function
DECL|function|nativeHandle
name|QVariant
name|QOpenGLContext
operator|::
name|nativeHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeHandle
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to create the OpenGL context with the current configuration.      The current configuration includes the format, the share context, and the     screen.      If the OpenGL implementation on your system does not support the requested     version of OpenGL context, then QOpenGLContext will try to create the closest     matching version. The actual created context properties can be queried     using the QSurfaceFormat returned by the format() function. For example, if     you request a context that supports OpenGL 4.3 Core profile but the driver     and/or hardware only supports version 3.2 Core profile contexts then you will     get a 3.2 Core profile context.      Returns \c true if the native context was successfully created and is ready to     be used with makeCurrent(), swapBuffers(), etc.      \note If the context already exists, this function destroys the existing     context first, and then creates a new one.      \sa makeCurrent(), format() */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLContext
operator|::
name|create
parameter_list|()
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|destroy
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformOpenGLContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|platformGLContext
operator|->
name|initialize
argument_list|()
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
operator|->
name|isSharing
argument_list|()
condition|)
name|d
operator|->
name|shareContext
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
name|d
operator|->
name|shareContext
condition|?
name|d
operator|->
name|shareContext
operator|->
name|shareGroup
argument_list|()
else|:
operator|new
name|QOpenGLContextGroup
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|addContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Destroy the underlying platform context associated with this context.      If any other context is directly or indirectly sharing resources with this     context, the shared resources, which includes vertex buffer objects, shader     objects, textures, and framebuffer objects, are not freed. However,     destroying the underlying platform context frees any state associated with     the context.      After \c destroy() has been called, you must call create() if you wish to     use the context again.      \note This implicitly calls doneCurrent() if the context is current.      \sa create() */
end_comment
begin_function
DECL|function|destroy
name|void
name|QOpenGLContext
operator|::
name|destroy
parameter_list|()
block|{
name|deleteQGLContext
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
condition|)
emit|emit
name|aboutToBeDestroyed
argument_list|()
emit|;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|doneCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareGroup
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|removeContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|platformGLContext
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|functions
expr_stmt|;
name|d
operator|->
name|functions
operator|=
literal|0
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|versionFunctions
argument_list|)
expr_stmt|;
name|d
operator|->
name|versionFunctions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|versionFunctionsBackend
argument_list|)
expr_stmt|;
name|d
operator|->
name|versionFunctionsBackend
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|d
operator|->
name|textureFunctions
expr_stmt|;
name|d
operator|->
name|textureFunctions
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|nativeHandle
operator|=
name|QVariant
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QOpenGLContext::aboutToBeDestroyed()      This signal is emitted before the underlying native OpenGL context is     destroyed, such that users may clean up OpenGL resources that might     otherwise be left dangling in the case of shared OpenGL contexts.      If you wish to make the context current in order to do clean-up, make sure     to only connect to the signal using a direct connection. */
end_comment
begin_comment
comment|/*!     Destroys the QOpenGLContext object.      If this is the current context for the thread, doneCurrent() is also called. */
end_comment
begin_destructor
DECL|function|~QOpenGLContext
name|QOpenGLContext
operator|::
name|~
name|QOpenGLContext
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QOpenGLContextPrivate
operator|::
name|cleanMakeCurrentTracker
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Returns if this context is valid, i.e. has been successfully created.      \sa create() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLContext
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
operator|&&
name|d
operator|->
name|platformGLContext
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Get the QOpenGLFunctions instance for this context.      QOpenGLContext offers this as a convenient way to access QOpenGLFunctions     without having to manage it manually.      The context or a sharing context must be current.      The returned QOpenGLFunctions instance is ready to be used and it     does not need initializeOpenGLFunctions() to be called. */
end_comment
begin_function
DECL|function|functions
name|QOpenGLFunctions
modifier|*
name|QOpenGLContext
operator|::
name|functions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|functions
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFunctions
operator|*
operator|&
argument_list|>
argument_list|(
name|d
operator|->
name|functions
argument_list|)
operator|=
operator|new
name|QOpenGLExtensions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|functions
return|;
block|}
end_function
begin_comment
comment|/*!     \fn T *QOpenGLContext::versionFunctions() const      \overload versionFunctions()      Returns a pointer to an object that provides access to all functions for     the version and profile of this context. Before using any of the functions     they must be initialized by calling QAbstractOpenGLFunctions::initializeOpenGLFunctions()     with this context being the current context.      Usually one would use the template version of this function to automatically     have the result cast to the correct type.      \code         QOpenGLFunctions_3_3_Core* funcs = 0;         funcs = context->versionFunctions<QOpenGLFunctions_3_3_Core>();         if (!funcs) {             qWarning()<< "Could not obtain required OpenGL context version";             exit(1);         }         funcs->initializeOpenGLFunctions();     \endcode      It is possible to request a functions object for a different version and profile     than that for which the context was created. To do this either use the template     version of this function specifying the desired functions object type as the     template parameter or by passing in a QOpenGLVersionProfile object as an argument     to the non-template function.      Note that requests for function objects of other versions or profiles can fail and     in doing so will return a null pointer. Situations in which creation of the functions     object can fail are if the request cannot be satisfied due to asking for functions     that are not in the version or profile of this context. For example:      \list         \li Requesting a 3.3 core profile functions object would succeed.         \li Requesting a 3.3 compatibility profile functions object would fail. We would fail             to resolve the deprecated functions.         \li Requesting a 4.3 core profile functions object would fail. We would fail to resolve             the new core functions introduced in versions 4.0-4.3.         \li Requesting a 3.1 functions object would succeed. There is nothing in 3.1 that is not             also in 3.3 core.     \endlist      Note that if creating a functions object via this method that the QOpenGLContext     retains ownership of the object. This is to allow the object to be cached and shared. */
end_comment
begin_comment
comment|/*!     Returns a pointer to an object that provides access to all functions for the     \a versionProfile of this context. Before using any of the functions they must     be initialized by calling QAbstractOpenGLFunctions::initializeOpenGLFunctions()     with this context being the current context.      Usually one would use the template version of this function to automatically     have the result cast to the correct type. */
end_comment
begin_function
DECL|function|versionFunctions
name|QAbstractOpenGLFunctions
modifier|*
name|QOpenGLContext
operator|::
name|versionFunctions
parameter_list|(
specifier|const
name|QOpenGLVersionProfile
modifier|&
name|versionProfile
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
if|if
condition|(
name|isOpenGLES
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"versionFunctions: Not supported on OpenGL ES"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|// QT_OPENGL_ES_2
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
specifier|const
name|QSurfaceFormat
name|f
init|=
name|format
argument_list|()
decl_stmt|;
comment|// Ensure we have a valid version and profile. Default to context's if none specified
name|QOpenGLVersionProfile
name|vp
init|=
name|versionProfile
decl_stmt|;
if|if
condition|(
operator|!
name|vp
operator|.
name|isValid
argument_list|()
condition|)
name|vp
operator|=
name|QOpenGLVersionProfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|// Check that context is compatible with requested version
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|v
init|=
name|qMakePair
argument_list|(
name|f
operator|.
name|majorVersion
argument_list|()
argument_list|,
name|f
operator|.
name|minorVersion
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|<
name|vp
operator|.
name|version
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// If this context only offers core profile functions then we can't create
comment|// function objects for legacy or compatibility profile requests
if|if
condition|(
operator|(
operator|(
name|vp
operator|.
name|hasProfiles
argument_list|()
operator|&&
name|vp
operator|.
name|profile
argument_list|()
operator|!=
name|QSurfaceFormat
operator|::
name|CoreProfile
operator|)
operator|||
name|vp
operator|.
name|isLegacyVersion
argument_list|()
operator|)
operator|&&
name|f
operator|.
name|profile
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|CoreProfile
condition|)
return|return
literal|0
return|;
comment|// Create object if suitable one not cached
name|QAbstractOpenGLFunctions
modifier|*
name|funcs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|versionFunctions
operator|.
name|contains
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|funcs
operator|=
name|QOpenGLVersionFunctionsFactory
operator|::
name|create
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|funcs
operator|->
name|setOwningContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|versionFunctions
operator|.
name|insert
argument_list|(
name|vp
argument_list|,
name|funcs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|funcs
operator|=
name|d
operator|->
name|versionFunctions
operator|.
name|value
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
name|funcs
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the set of OpenGL extensions supported by this context.      The context or a sharing context must be current.      \sa hasExtension() */
end_comment
begin_function
DECL|function|extensions
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QOpenGLContext
operator|::
name|extensions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extensionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QOpenGLExtensionMatcher
name|matcher
decl_stmt|;
name|d
operator|->
name|extensionNames
operator|=
name|matcher
operator|.
name|extensions
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|extensionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this OpenGL context supports the specified OpenGL     \a extension, \c false otherwise.      The context or a sharing context must be current.      \sa extensions() */
end_comment
begin_function
DECL|function|hasExtension
name|bool
name|QOpenGLContext
operator|::
name|hasExtension
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|extension
parameter_list|)
specifier|const
block|{
return|return
name|extensions
argument_list|()
operator|.
name|contains
argument_list|(
name|extension
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Call this to get the default framebuffer object for the current surface.      On some platforms the default framebuffer object depends on the surface     being rendered to, and might be different from 0. Thus, instead of calling     glBindFramebuffer(0), you should call     glBindFramebuffer(ctx->defaultFramebufferObject()) if you want your     application to work across different Qt platforms.      If you use the glBindFramebuffer() in QOpenGLFunctions you do not have to     worry about this, as it automatically binds the current context's     defaultFramebufferObject() when 0 is passed. */
end_comment
begin_function
DECL|function|defaultFramebufferObject
name|GLuint
name|QOpenGLContext
operator|::
name|defaultFramebufferObject
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|surface
operator|||
operator|!
name|d
operator|->
name|surface
operator|->
name|surfaceHandle
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|defaultFramebufferObject
argument_list|(
name|d
operator|->
name|surface
operator|->
name|surfaceHandle
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Makes the context current in the current thread, against the given     \a surface. Returns \c true if successful.      If \a surface is 0 this is equivalent to calling doneCurrent().      Do not call this function from a different thread than the one the     QOpenGLContext instance lives in. If you wish to use QOpenGLContext from a     different thread you should first call make sure it's not current in the     current thread, by calling doneCurrent() if necessary. Then call     moveToThread(otherThread) before using it in the other thread.      \sa functions(), doneCurrent() */
end_comment
begin_function
DECL|function|makeCurrent
name|bool
name|QOpenGLContext
operator|::
name|makeCurrent
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Cannot make QOpenGLContext current in a different thread"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|doneCurrent
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|surface
operator|->
name|surfaceHandle
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|surface
operator|->
name|supportsOpenGL
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::makeCurrent() called with non-opengl surface"
operator|<<
name|surface
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QOpenGLContext
modifier|*
name|previous
init|=
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
operator|->
name|makeCurrent
argument_list|(
name|surface
operator|->
name|surfaceHandle
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|surface
operator|=
name|surface
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QOpenGLContextPrivate
operator|::
name|toggleMakeCurrentTracker
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|previous
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Convenience function for calling makeCurrent with a 0 surface.      This results in no context being current in the current thread.      \sa makeCurrent(), currentContext() */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QOpenGLContext
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|surface
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the surface the context has been made current with.      This is the surface passed as an argument to makeCurrent(). */
end_comment
begin_function
DECL|function|surface
name|QSurface
modifier|*
name|QOpenGLContext
operator|::
name|surface
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|surface
return|;
block|}
end_function
begin_comment
comment|/*!     Swap the back and front buffers of \a surface.      Call this to finish a frame of OpenGL rendering, and make sure to     call makeCurrent() again before you begin a new frame. */
end_comment
begin_function
DECL|function|swapBuffers
name|void
name|QOpenGLContext
operator|::
name|swapBuffers
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with null argument"
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|surface
operator|->
name|supportsOpenGL
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with non-opengl surface"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|surface
operator|->
name|surfaceClass
argument_list|()
operator|==
name|QSurface
operator|::
name|Window
operator|&&
operator|!
name|qt_window_private
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
argument_list|)
operator|->
name|receivedExpose
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with non-exposed window, behavior is undefined"
expr_stmt|;
block|}
name|QPlatformSurface
modifier|*
name|surfaceHandle
init|=
name|surface
operator|->
name|surfaceHandle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|surfaceHandle
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContextPrivate
operator|::
name|toggleMakeCurrentTracker
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called without corresponding makeCurrent()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|surface
operator|->
name|format
argument_list|()
operator|.
name|swapBehavior
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|SingleBuffer
condition|)
name|functions
argument_list|()
operator|->
name|glFlush
argument_list|()
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|swapBuffers
argument_list|(
name|surfaceHandle
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resolves the function pointer to an OpenGL extension function, identified by \a procName      Returns 0 if no such function can be found. */
end_comment
begin_function
DECL|function|getProcAddress
name|QFunctionPointer
name|QOpenGLContext
operator|::
name|getProcAddress
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|procName
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|getProcAddress
argument_list|(
name|procName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of the underlying platform context, if create() has been called.      Otherwise, returns the requested format.      The requested and the actual format may differ. Requesting a given OpenGL version does     not mean the resulting context will target exactly the requested version. It is only     guaranteed that the version/profile/options combination for the created context is     compatible with the request, as long as the driver is able to provide such a context.      For example, requesting an OpenGL version 3.x core profile context may result in an     OpenGL 4.x core profile context. Similarly, a request for OpenGL 2.1 may result in an     OpenGL 3.0 context with deprecated functions enabled. Finally, depending on the     driver, unsupported versions may result in either a context creation failure or in a     context for the highest supported version.      Similar differences are possible in the buffer sizes, for example, the resulting     context may have a larger depth buffer than requested. This is perfectly normal. */
end_comment
begin_function
DECL|function|format
name|QSurfaceFormat
name|QOpenGLContext
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
name|d
operator|->
name|requestedFormat
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|format
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the share group this context belongs to. */
end_comment
begin_function
DECL|function|shareGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContext
operator|::
name|shareGroup
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareGroup
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the share context this context was created with.      If the underlying platform was not able to support the requested     sharing, this will return 0. */
end_comment
begin_function
DECL|function|shareContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareContext
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareContext
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the screen the context was created for. */
end_comment
begin_function
DECL|function|screen
name|QScreen
modifier|*
name|QOpenGLContext
operator|::
name|screen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|screen
return|;
block|}
end_function
begin_comment
comment|/*!     internal: Needs to have a pointer to qGLContext. But since this is in Qt GUI we can't     have any type information.      \internal */
end_comment
begin_function
DECL|function|qGLContextHandle
name|void
modifier|*
name|QOpenGLContext
operator|::
name|qGLContextHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qGLContextHandle
return|;
block|}
end_function
begin_comment
comment|/*!     internal: If the delete function is specified QOpenGLContext "owns"     the passed context handle and will use the delete function to destroy it.      \internal */
end_comment
begin_function
DECL|function|setQGLContextHandle
name|void
name|QOpenGLContext
operator|::
name|setQGLContextHandle
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|void
function_decl|(
modifier|*
name|qGLContextDeleteFunction
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
name|handle
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
name|qGLContextDeleteFunction
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|deleteQGLContext
name|void
name|QOpenGLContext
operator|::
name|deleteQGLContext
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|qGLContextDeleteFunction
operator|&&
name|d
operator|->
name|qGLContextHandle
condition|)
block|{
name|d
operator|->
name|qGLContextDeleteFunction
argument_list|(
name|d
operator|->
name|qGLContextHandle
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns the platform-specific handle for the OpenGL implementation that   is currently in use. (for example, a HMODULE on Windows)    On platforms that do not use dynamic GL switch the return value is null.    The library might be GL-only, meaning that windowing system interface   functions (for example EGL) may live in another, separate library.    \note This function requires that the QGuiApplication instance is already created.    \sa openGLModuleType()    \since 5.3  */
end_comment
begin_function
DECL|function|openGLModuleHandle
name|void
modifier|*
name|QOpenGLContext
operator|::
name|openGLModuleHandle
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_DYNAMIC
name|QPlatformNativeInterface
modifier|*
name|ni
init|=
name|QGuiApplication
operator|::
name|platformNativeInterface
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ni
operator|->
name|nativeResourceForIntegration
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"glhandle"
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   \enum QOpenGLContext::OpenGLModuleType   This enum defines the type of the underlying OpenGL implementation.    \value LibGL   OpenGL   \value LibGLES OpenGL ES 2.0 or higher    \since 5.3 */
end_comment
begin_comment
comment|/*!   Returns the underlying OpenGL implementation type.    On platforms where the OpenGL implementation is not dynamically   loaded, the return value is determined during compile time and never   changes.    \note A desktop OpenGL implementation may be capable of creating   ES-compatible contexts too. Therefore in most cases it is more   appropriate to check QSurfaceFormat::renderableType() or using the   the convenience function isOpenGLES().    \note This function requires that the QGuiApplication instance is already created.    \since 5.3  */
end_comment
begin_function
DECL|function|openGLModuleType
name|QOpenGLContext
operator|::
name|OpenGLModuleType
name|QOpenGLContext
operator|::
name|openGLModuleType
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
name|Q_ASSERT
argument_list|(
name|qGuiApp
argument_list|)
expr_stmt|;
return|return
name|QGuiApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|platformIntegration
argument_list|()
operator|->
name|openGLModuleType
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
return|return
name|LibGLES
return|;
else|#
directive|else
return|return
name|LibGL
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Returns true if the context is an OpenGL ES context.    If the context has not yet been created, the result is based on the   requested format set via setFormat().    \sa create(), format(), setFormat()    \since 5.3   */
end_comment
begin_function
DECL|function|isOpenGLES
name|bool
name|QOpenGLContext
operator|::
name|isOpenGLES
parameter_list|()
specifier|const
block|{
return|return
name|format
argument_list|()
operator|.
name|renderableType
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|OpenGLES
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|functionsBackend
name|QOpenGLVersionFunctionsBackend
modifier|*
name|QOpenGLContext
operator|::
name|functionsBackend
parameter_list|(
specifier|const
name|QOpenGLVersionStatus
modifier|&
name|v
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|versionFunctionsBackend
operator|.
name|value
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|insertFunctionsBackend
name|void
name|QOpenGLContext
operator|::
name|insertFunctionsBackend
parameter_list|(
specifier|const
name|QOpenGLVersionStatus
modifier|&
name|v
parameter_list|,
name|QOpenGLVersionFunctionsBackend
modifier|*
name|backend
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|versionFunctionsBackend
operator|.
name|insert
argument_list|(
name|v
argument_list|,
name|backend
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|removeFunctionsBackend
name|void
name|QOpenGLContext
operator|::
name|removeFunctionsBackend
parameter_list|(
specifier|const
name|QOpenGLVersionStatus
modifier|&
name|v
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|versionFunctionsBackend
operator|.
name|remove
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|textureFunctions
name|QOpenGLTextureHelper
modifier|*
name|QOpenGLContext
operator|::
name|textureFunctions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textureFunctions
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setTextureFunctions
name|void
name|QOpenGLContext
operator|::
name|setTextureFunctions
parameter_list|(
name|QOpenGLTextureHelper
modifier|*
name|textureFuncs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|textureFunctions
operator|=
name|textureFuncs
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLContextGroup     \since 5.0     \brief The QOpenGLContextGroup class represents a group of contexts sharing     OpenGL resources.     \inmodule QtGui      QOpenGLContextGroup is automatically created and managed by QOpenGLContext     instances.  Its purpose is to identify all the contexts that are sharing     resources.      \sa QOpenGLContext::shareGroup() */
end_comment
begin_constructor
DECL|function|QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|QOpenGLContextGroup
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextGroupPrivate
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|~
name|QOpenGLContextGroup
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns all the QOpenGLContext objects in this share group. */
end_comment
begin_function
DECL|function|shares
name|QList
argument_list|<
name|QOpenGLContext
modifier|*
argument_list|>
name|QOpenGLContextGroup
operator|::
name|shares
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_shares
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QOpenGLContextGroup corresponding to the current context.      \sa QOpenGLContext::currentContext() */
end_comment
begin_function
DECL|function|currentContextGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContextGroup
operator|::
name|currentContextGroup
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|shareGroup
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|addContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|addContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_refs
operator|.
name|ref
argument_list|()
expr_stmt|;
name|m_shares
operator|<<
name|ctx
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|removeContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|bool
name|deleteObject
init|=
literal|false
decl_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_shares
operator|.
name|removeOne
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|m_context
operator|&&
operator|!
name|m_shares
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_context
operator|=
name|m_shares
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_refs
operator|.
name|deref
argument_list|()
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|deleteObject
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteObject
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
operator|delete
name|q
expr_stmt|;
comment|// Delete directly to prevent leak, refer to QTBUG-29056
else|else
name|q
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|cleanup
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
block|{
name|QHash
argument_list|<
name|QOpenGLMultiGroupSharedResource
modifier|*
argument_list|,
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|,
name|end
decl_stmt|;
name|end
operator|=
name|m_resources
operator|.
name|constEnd
argument_list|()
expr_stmt|;
for|for
control|(
name|it
operator|=
name|m_resources
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|it
operator|.
name|key
argument_list|()
operator|->
name|cleanup
argument_list|(
name|q
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|m_resources
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|m_sharedResources
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|m_sharedResources
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
operator|(
operator|*
name|it
operator|)
operator|->
name|m_group
operator|=
literal|0
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|m_sharedResources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|m_pendingDeletion
operator|.
name|begin
argument_list|()
argument_list|,
name|m_pendingDeletion
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deletePendingResources
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|deletePendingResources
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|pending
init|=
name|m_pendingDeletion
decl_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|pending
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|pending
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|freeResource
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|delete
operator|*
name|it
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResource     \internal     \since 5.0     \brief The QOpenGLSharedResource class is used to keep track of resources     that are shared between OpenGL contexts (like textures, framebuffer     objects, shader programs, etc), and clean them up in a safe way when     they're no longer needed.     \inmodule QtGui      The QOpenGLSharedResource instance should never be deleted, instead free()     should be called when it's no longer needed. Thus it will be put on a queue     and freed at an appropriate time (when a context in the share group becomes     current).      The sub-class needs to implement two pure virtual functions. The first,     freeResource() must be implemented to actually do the freeing, for example     call glDeleteTextures() on a texture id. Qt makes sure a valid context in     the resource's share group is current at the time. The other,     invalidateResource(), is called by Qt in the circumstance when the last     context in the share group is destroyed before free() has been called. The     implementation of invalidateResource() should set any identifiers to 0 or     set a flag to prevent them from being used later on. */
end_comment
begin_constructor
DECL|function|QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|QOpenGLSharedResource
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|)
member_init_list|:
name|m_group
argument_list|(
name|group
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|<<
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|~
name|QOpenGLSharedResource
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|// schedule the resource for deletion at an appropriate time
end_comment
begin_function
DECL|function|free
name|void
name|QOpenGLSharedResource
operator|::
name|free
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_group
condition|)
block|{
operator|delete
name|this
expr_stmt|;
return|return;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|.
name|removeOne
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_pendingDeletion
operator|<<
name|this
expr_stmt|;
comment|// can we delete right away?
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|&&
name|current
operator|->
name|shareGroup
argument_list|()
operator|==
name|m_group
condition|)
block|{
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResourceGuard     \internal     \since 5.0     \brief The QOpenGLSharedResourceGuard class is a convenience sub-class of     QOpenGLSharedResource to be used to track a single OpenGL object with a     GLuint identifier. The constructor takes a function pointer to a function     that will be used to free the resource if and when necessary.     \inmodule QtGui  */
end_comment
begin_function
DECL|function|freeResource
name|void
name|QOpenGLSharedResourceGuard
operator|::
name|freeResource
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|m_id
condition|)
block|{
name|QOpenGLFunctions
name|functions
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|m_func
argument_list|(
operator|&
name|functions
argument_list|,
name|m_id
argument_list|)
expr_stmt|;
name|m_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLMultiGroupSharedResource     \internal     \since 5.0     \brief The QOpenGLMultiGroupSharedResource keeps track of a shared resource     that might be needed from multiple contexts, like a glyph cache or gradient     cache. One instance of the object is created for each group when necessary.     The shared resource instance should have a constructor that takes a     QOpenGLContext *. To get an instance for a given context one calls     T *QOpenGLMultiGroupSharedResource::value<T>(context), where T is a sub-class     of QOpenGLSharedResource.     \inmodule QtGui      You should not call free() on QOpenGLSharedResources owned by a     QOpenGLMultiGroupSharedResource instance. */
end_comment
begin_constructor
DECL|function|QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|QOpenGLMultiGroupSharedResource
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_mutex
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Creating context group resource object %p."
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|~
name|QOpenGLMultiGroupSharedResource
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Deleting context group resource %p. Group size: %d."
argument_list|,
name|this
argument_list|,
name|m_groups
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_groups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QOpenGLContext
modifier|*
name|context
init|=
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
name|value
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|resource
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|active
operator|.
name|load
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QtGui: Resources are still available at program shutdown.\n"
literal|"          This is possibly caused by a leaked QOpenGLWidget, \n"
literal|"          QOpenGLFramebufferObject or QOpenGLPixelBuffer."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|insert
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|insert
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Inserting context group resource %p for context %p, managed by %p."
argument_list|,
name|value
argument_list|,
name|context
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|contains
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|append
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|active
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|value
name|QOpenGLSharedResource
modifier|*
name|QOpenGLMultiGroupSharedResource
operator|::
name|value
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
return|return
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resources
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|QOpenGLMultiGroupSharedResource
operator|::
name|resources
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|result
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QOpenGLContextGroup
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_groups
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|m_groups
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
cast|const_cast
argument_list|<
name|QOpenGLMultiGroupSharedResource
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|result
operator|<<
name|resource
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|cleanup
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Cleaning up context group resource %p, for group %p in thread %p."
argument_list|,
name|this
argument_list|,
name|group
argument_list|,
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
name|value
operator|->
name|free
argument_list|()
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_groups
operator|.
name|contains
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|removeOne
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
