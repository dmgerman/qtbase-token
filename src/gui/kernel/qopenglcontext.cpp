begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformopenglcontext_qpa.h"
end_include
begin_include
include|#
directive|include
file|"qopenglcontext.h"
end_include
begin_include
include|#
directive|include
file|"qopenglcontext_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindow.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QThreadStorage>
end_include
begin_include
include|#
directive|include
file|<QtCore/QThread>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QScreen>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QGuiGLThreadContext
class|class
name|QGuiGLThreadContext
block|{
public|public:
DECL|function|~QGuiGLThreadContext
name|~
name|QGuiGLThreadContext
parameter_list|()
block|{
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qwindow_context_storage
specifier|static
name|QThreadStorage
argument_list|<
name|QGuiGLThreadContext
modifier|*
argument_list|>
name|qwindow_context_storage
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|setCurrentContext
name|void
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|threadContext
condition|)
block|{
if|if
condition|(
operator|!
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"No QTLS available. currentContext wont work"
argument_list|)
expr_stmt|;
return|return;
block|}
name|threadContext
operator|=
operator|new
name|QGuiGLThreadContext
expr_stmt|;
name|qwindow_context_storage
operator|.
name|setLocalData
argument_list|(
name|threadContext
argument_list|)
expr_stmt|;
block|}
name|threadContext
operator|->
name|context
operator|=
name|context
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the last context which called makeCurrent. This function is thread aware. */
end_comment
begin_function
DECL|function|currentContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|currentContext
parameter_list|()
block|{
name|QGuiGLThreadContext
modifier|*
name|threadContext
init|=
name|qwindow_context_storage
operator|.
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
name|threadContext
condition|)
block|{
return|return
name|threadContext
operator|->
name|context
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|areSharing
name|bool
name|QOpenGLContext
operator|::
name|areSharing
parameter_list|(
name|QOpenGLContext
modifier|*
name|first
parameter_list|,
name|QOpenGLContext
modifier|*
name|second
parameter_list|)
block|{
return|return
name|first
operator|->
name|shareGroup
argument_list|()
operator|==
name|second
operator|->
name|shareGroup
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|handle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
return|;
block|}
end_function
begin_function
DECL|function|shareHandle
name|QPlatformOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareContext
condition|)
return|return
name|d
operator|->
name|shareContext
operator|->
name|handle
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Creates a new GL context instance, you need to call create() before it can be used. */
end_comment
begin_constructor
DECL|function|QOpenGLContext
name|QOpenGLContext
operator|::
name|QOpenGLContext
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Sets the format the GL context should be compatible with. You need to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QOpenGLContext
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestedFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the context to share textures, shaders, and other GL resources with. You need to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setShareContext
name|void
name|QOpenGLContext
operator|::
name|setShareContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|shareContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareContext
operator|=
name|shareContext
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the screen the GL context should be valid for. You need to call create() before it takes effect. */
end_comment
begin_function
DECL|function|setScreen
name|void
name|QOpenGLContext
operator|::
name|setScreen
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|screen
condition|)
name|d
operator|->
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Attempts to create the GL context with the desired parameters.    Returns true if the native context was successfully created and is ready to be used. */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLContext
operator|::
name|create
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformOpenGLContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
operator|->
name|isSharing
argument_list|()
condition|)
name|d
operator|->
name|shareContext
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
name|d
operator|->
name|shareContext
condition|?
name|d
operator|->
name|shareContext
operator|->
name|shareGroup
argument_list|()
else|:
operator|new
name|QOpenGLContextGroup
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|addContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
return|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QOpenGLContext
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
condition|)
emit|emit
name|aboutToBeDestroyed
argument_list|()
emit|;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|doneCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shareGroup
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|removeContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|platformGLContext
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|functions
expr_stmt|;
name|d
operator|->
name|functions
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QOpenGLContext::aboutToBeDestroyed()      This signal is emitted before the underlying native OpenGL context is     destroyed, such that users may clean up OpenGL resources that might otherwise     be left dangling in the case of shared OpenGL contexts.      If you wish to make the context current in order to do clean-up, make sure to     only connect to the signal using a direct connection. */
end_comment
begin_comment
comment|/*!   If this is the current context for the thread, doneCurrent is called */
end_comment
begin_destructor
DECL|function|~QOpenGLContext
name|QOpenGLContext
operator|::
name|~
name|QOpenGLContext
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Returns if this context is valid, i.e. has been successfully created. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLContext
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|platformGLContext
operator|&&
name|d
operator|->
name|platformGLContext
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Get the QOpenGLFunctions instance for this context.    The context or a sharing context must be current. */
end_comment
begin_function
DECL|function|functions
name|QOpenGLFunctions
modifier|*
name|QOpenGLContext
operator|::
name|functions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|functions
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFunctions
operator|*
operator|&
argument_list|>
argument_list|(
name|d
operator|->
name|functions
argument_list|)
operator|=
operator|new
name|QOpenGLExtensions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|functions
return|;
block|}
end_function
begin_comment
comment|/*!   If surface is 0 this is equivalent to calling doneCurrent().    Do not call this function from a different thread than the one the QOpenGLContext instance lives in. If   you wish to use QOpenGLContext from a different thread you should first call make sure it's not current   in the current thread, by calling doneCurrent() if necessary. Then call moveToThread(otherThread)   before using it in the other thread. */
end_comment
begin_function
DECL|function|makeCurrent
name|bool
name|QOpenGLContext
operator|::
name|makeCurrent
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Cannot make QOpenGLContext current in a different thread"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|doneCurrent
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|surface
operator|->
name|surfaceHandle
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|platformGLContext
operator|->
name|makeCurrent
argument_list|(
name|surface
operator|->
name|surfaceHandle
argument_list|()
argument_list|)
condition|)
block|{
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|surface
operator|=
name|surface
expr_stmt|;
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Convenience function for calling makeCurrent with a 0 surface. */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QOpenGLContext
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|==
name|this
condition|)
name|d
operator|->
name|shareGroup
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|platformGLContext
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|QOpenGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|surface
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the surface the context is current for. */
end_comment
begin_function
DECL|function|surface
name|QSurface
modifier|*
name|QOpenGLContext
operator|::
name|surface
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|surface
return|;
block|}
end_function
begin_function
DECL|function|swapBuffers
name|void
name|QOpenGLContext
operator|::
name|swapBuffers
parameter_list|(
name|QSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|surface
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLContext::swapBuffers() called with null argument"
expr_stmt|;
return|return;
block|}
name|QPlatformSurface
modifier|*
name|surfaceHandle
init|=
name|surface
operator|->
name|surfaceHandle
argument_list|()
decl_stmt|;
if|if
condition|(
name|surfaceHandle
condition|)
name|d
operator|->
name|platformGLContext
operator|->
name|swapBuffers
argument_list|(
name|surfaceHandle
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getProcAddress
name|QFunctionPointer
name|QOpenGLContext
operator|::
name|getProcAddress
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|procName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|getProcAddress
argument_list|(
name|procName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|format
name|QSurfaceFormat
name|QOpenGLContext
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|platformGLContext
condition|)
return|return
name|d
operator|->
name|requestedFormat
return|;
return|return
name|d
operator|->
name|platformGLContext
operator|->
name|format
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|shareGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContext
operator|::
name|shareGroup
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareGroup
return|;
block|}
end_function
begin_function
DECL|function|shareContext
name|QOpenGLContext
modifier|*
name|QOpenGLContext
operator|::
name|shareContext
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shareContext
return|;
block|}
end_function
begin_function
DECL|function|screen
name|QScreen
modifier|*
name|QOpenGLContext
operator|::
name|screen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|screen
return|;
block|}
end_function
begin_comment
comment|/*   internal: Needs to have a pointer to qGLContext. But since this is in QtGui we cant   have any type information. */
end_comment
begin_function
DECL|function|qGLContextHandle
name|void
modifier|*
name|QOpenGLContext
operator|::
name|qGLContextHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qGLContextHandle
return|;
block|}
end_function
begin_function
DECL|function|setQGLContextHandle
name|void
name|QOpenGLContext
operator|::
name|setQGLContextHandle
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|void
function_decl|(
modifier|*
name|qGLContextDeleteFunction
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
name|handle
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
name|qGLContextDeleteFunction
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deleteQGLContext
name|void
name|QOpenGLContext
operator|::
name|deleteQGLContext
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|qGLContextDeleteFunction
operator|&&
name|d
operator|->
name|qGLContextHandle
condition|)
block|{
name|d
operator|->
name|qGLContextDeleteFunction
argument_list|(
name|d
operator|->
name|qGLContextHandle
argument_list|)
expr_stmt|;
name|d
operator|->
name|qGLContextDeleteFunction
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|qGLContextHandle
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|QOpenGLContextGroup
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLContextGroupPrivate
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QOpenGLContextGroup
name|QOpenGLContextGroup
operator|::
name|~
name|QOpenGLContextGroup
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|shares
name|QList
argument_list|<
name|QOpenGLContext
modifier|*
argument_list|>
name|QOpenGLContextGroup
operator|::
name|shares
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_shares
return|;
block|}
end_function
begin_function
DECL|function|currentContextGroup
name|QOpenGLContextGroup
modifier|*
name|QOpenGLContextGroup
operator|::
name|currentContextGroup
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|shareGroup
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|addContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|addContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_refs
operator|.
name|ref
argument_list|()
expr_stmt|;
name|m_shares
operator|<<
name|ctx
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeContext
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|removeContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_shares
operator|.
name|removeOne
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|m_context
operator|&&
operator|!
name|m_shares
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_context
operator|=
name|m_shares
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_refs
operator|.
name|deref
argument_list|()
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|q
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|cleanup
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLContextGroup
argument_list|)
expr_stmt|;
block|{
name|QHash
argument_list|<
name|QOpenGLMultiGroupSharedResource
modifier|*
argument_list|,
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|,
name|end
decl_stmt|;
name|end
operator|=
name|m_resources
operator|.
name|constEnd
argument_list|()
expr_stmt|;
for|for
control|(
name|it
operator|=
name|m_resources
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|it
operator|.
name|key
argument_list|()
operator|->
name|cleanup
argument_list|(
name|q
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|m_resources
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|m_sharedResources
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|m_sharedResources
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
operator|(
operator|*
name|it
operator|)
operator|->
name|m_group
operator|=
literal|0
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|m_sharedResources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|m_pendingDeletion
operator|.
name|begin
argument_list|()
argument_list|,
name|m_pendingDeletion
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deletePendingResources
name|void
name|QOpenGLContextGroupPrivate
operator|::
name|deletePendingResources
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|pending
init|=
name|m_pendingDeletion
decl_stmt|;
name|m_pendingDeletion
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|pending
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
operator|::
name|iterator
name|end
init|=
name|pending
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|freeResource
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|delete
operator|*
name|it
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResource     \internal     \since 5.0     \brief The QOpenGLSharedResource class is used to keep track of resources that     are shared between OpenGL contexts (like textures, framebuffer objects, shader     programs, etc), and clean them up in a safe way when they're no longer needed.      The QOpenGLSharedResource instance should never be deleted, instead free()     should be called when it's no longer needed. Thus it will be put on a queue     and freed at an appropriate time (when a context in the share group becomes     current).      The sub-class needs to implement two pure virtual functions. The first,     freeResource() must be implemented to actually do the freeing, for example     call glDeleteTextures() on a texture id. Qt makes sure a valid context in     the resource's share group is current at the time. The other, invalidateResource(),     is called by Qt in the circumstance when the last context in the share group is     destroyed before free() has been called. The implementation of invalidateResource()     should set any identifiers to 0 or set a flag to prevent them from being used     later on. */
end_comment
begin_constructor
DECL|function|QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|QOpenGLSharedResource
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|)
member_init_list|:
name|m_group
argument_list|(
name|group
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|<<
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLSharedResource
name|QOpenGLSharedResource
operator|::
name|~
name|QOpenGLSharedResource
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|// schedule the resource for deletion at an appropriate time
end_comment
begin_function
DECL|function|free
name|void
name|QOpenGLSharedResource
operator|::
name|free
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_group
condition|)
block|{
operator|delete
name|this
expr_stmt|;
return|return;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_sharedResources
operator|.
name|removeOne
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|m_pendingDeletion
operator|<<
name|this
expr_stmt|;
comment|// can we delete right away?
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|&&
name|current
operator|->
name|shareGroup
argument_list|()
operator|==
name|m_group
condition|)
block|{
name|m_group
operator|->
name|d_func
argument_list|()
operator|->
name|deletePendingResources
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLSharedResourceGuard     \internal     \since 5.0     \brief The QOpenGLSharedResourceGuard class is a convenience sub-class of     QOpenGLSharedResource to be used to track a single OpenGL object with a     GLuint identifier. The constructor takes a function pointer to a function     that will be used to free the resource if and when necessary. */
end_comment
begin_function
DECL|function|freeResource
name|void
name|QOpenGLSharedResourceGuard
operator|::
name|freeResource
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|m_id
condition|)
block|{
name|QOpenGLFunctions
name|functions
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|m_func
argument_list|(
operator|&
name|functions
argument_list|,
name|m_id
argument_list|)
expr_stmt|;
name|m_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLMultiGroupSharedResource     \internal     \since 5.0     \brief The QOpenGLMultiGroupSharedResource keeps track of a shared resource     that might be needed from multiple contexts, like a glyph cache or gradient     cache. One instance of the object is created for each group when     necessary. The shared resource instance should have a constructor that     takes a QOpenGLContext *. To get an instance for a given context one calls     T *QOpenGLMultiGroupSharedResource::value<T>(context), where T is a sub-class     of QOpenGLSharedResource.      You should not call free() on QOpenGLSharedResources owned by a     QOpenGLMultiGroupSharedResource instance. */
end_comment
begin_constructor
DECL|function|QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|QOpenGLMultiGroupSharedResource
parameter_list|()
member_init_list|:
name|active
argument_list|(
literal|0
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Creating context group resource object %p."
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLMultiGroupSharedResource
name|QOpenGLMultiGroupSharedResource
operator|::
name|~
name|QOpenGLMultiGroupSharedResource
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Deleting context group resource %p. Group size: %d."
argument_list|,
name|this
argument_list|,
name|m_groups
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_groups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QOpenGLContext
modifier|*
name|context
init|=
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|shares
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
name|value
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|resource
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|active
operator|.
name|load
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QtGui: Resources are still available at program shutdown.\n"
literal|"          This is possibly caused by a leaked QOpenGLWidget, \n"
literal|"          QOpenGLFramebufferObject or QOpenGLPixelBuffer."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|insert
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|insert
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Inserting context group resource %p for context %p, managed by %p."
argument_list|,
name|value
argument_list|,
name|context
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|contains
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|insert
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|append
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|active
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|value
name|QOpenGLSharedResource
modifier|*
name|QOpenGLMultiGroupSharedResource
operator|::
name|value
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|QOpenGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|shareGroup
argument_list|()
decl_stmt|;
return|return
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resources
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|QOpenGLMultiGroupSharedResource
operator|::
name|resources
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QOpenGLSharedResource
modifier|*
argument_list|>
name|result
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QOpenGLContextGroup
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_groups
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|m_groups
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QOpenGLSharedResource
modifier|*
name|resource
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|d_func
argument_list|()
operator|->
name|m_resources
operator|.
name|value
argument_list|(
cast|const_cast
argument_list|<
name|QOpenGLMultiGroupSharedResource
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
name|result
operator|<<
name|resource
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|QOpenGLMultiGroupSharedResource
operator|::
name|cleanup
parameter_list|(
name|QOpenGLContextGroup
modifier|*
name|group
parameter_list|,
name|QOpenGLSharedResource
modifier|*
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_GL_CONTEXT_RESOURCE_DEBUG
name|qDebug
argument_list|(
literal|"Cleaning up context group resource %p, for group %p in thread %p."
argument_list|,
name|this
argument_list|,
name|group
argument_list|,
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|->
name|invalidateResource
argument_list|()
expr_stmt|;
name|value
operator|->
name|free
argument_list|()
expr_stmt|;
name|active
operator|.
name|deref
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_groups
operator|.
name|contains
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|m_groups
operator|.
name|removeOne
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
