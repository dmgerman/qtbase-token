begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_include
include|#
directive|include
file|"qmimedata.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QClipboard     \brief The QClipboard class provides access to the window system clipboard.     \inmodule QtGui      The clipboard offers a simple mechanism to copy and paste data     between applications.      QClipboard supports the same data types that QDrag does, and uses     similar mechanisms. For advanced clipboard usage read \l{Drag and     Drop}.      There is a single QClipboard object in an application, accessible     as QApplication::clipboard().      Example:     \snippet code/src_gui_kernel_qclipboard.cpp 0      QClipboard features some convenience functions to access common     data types: setText() allows the exchange of Unicode text and     setPixmap() and setImage() allows the exchange of QPixmaps and     QImages between applications. The setMimeData() function is the     ultimate in flexibility: it allows you to add any QMimeData into     the clipboard. There are corresponding getters for each of these,     e.g. text(), image() and pixmap(). You can clear the clipboard by     calling clear().      A typical example of the use of these functions follows:      \snippet droparea.cpp 0      \section1 Notes for X11 Users      \list      \li The X11 Window System has the concept of a separate selection     and clipboard.  When text is selected, it is immediately available     as the global mouse selection.  The global mouse selection may     later be copied to the clipboard.  By convention, the middle mouse     button is used to paste the global mouse selection.      \li X11 also has the concept of ownership; if you change the     selection within a window, X11 will only notify the owner and the     previous owner of the change, i.e. it will not notify all     applications that the selection or clipboard data changed.      \li Lastly, the X11 clipboard is event driven, i.e. the clipboard     will not function properly if the event loop is not running.     Similarly, it is recommended that the contents of the clipboard     are stored or retrieved in direct response to user-input events,     e.g. mouse button or key presses and releases.  You should not     store or retrieve the clipboard contents in response to timer or     non-user-input events.      \li Since there is no standard way to copy and paste files between     applications on X11, various MIME types and conventions are currently     in use. For instance, Nautilus expects files to be supplied with a     \c{x-special/gnome-copied-files} MIME type with data beginning with     the cut/copy action, a newline character, and the URL of the file.      \endlist      \section1 Notes for Mac OS X Users      Mac OS X supports a separate find buffer that holds the current     search string in Find operations. This find clipboard can be accessed     by specifying the FindBuffer mode.      \section1 Notes for Windows and Mac OS X Users      \list      \li Windows and Mac OS X do not support the global mouse     selection; they only supports the global clipboard, i.e. they     only add text to the clipboard when an explicit copy or cut is     made.      \li Windows and Mac OS X does not have the concept of ownership;     the clipboard is a fully global resource so all applications are     notified of changes.      \endlist      \sa QApplication */
end_comment
begin_comment
comment|/*!     \internal      Constructs a clipboard object.      Do not call this function.      Call QApplication::clipboard() instead to get a pointer to the     application's global clipboard object.      There is only one clipboard in the window system, and creating     more than one object to represent it is almost certainly an error. */
end_comment
begin_constructor
DECL|function|QClipboard
name|QClipboard
operator|::
name|QClipboard
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
block|{
comment|// nothing
block|}
end_constructor
begin_comment
comment|/*!     \internal      Destroys the clipboard.      You should never delete the clipboard. QApplication will do this     when the application terminates. */
end_comment
begin_destructor
DECL|function|~QClipboard
name|QClipboard
operator|::
name|~
name|QClipboard
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn void QClipboard::changed(QClipboard::Mode mode)     \since 4.2      This signal is emitted when the data for the given clipboard \a     mode is changed.      \sa dataChanged(), selectionChanged(), findBufferChanged() */
end_comment
begin_comment
comment|/*!     \fn void QClipboard::dataChanged()      This signal is emitted when the clipboard data is changed.      On Mac OS X and with Qt version 4.3 or higher, clipboard     changes made by other applications will only be detected     when the application is activated.      \sa findBufferChanged(), selectionChanged(), changed() */
end_comment
begin_comment
comment|/*!     \fn void QClipboard::selectionChanged()      This signal is emitted when the selection is changed. This only     applies to windowing systems that support selections, e.g. X11.     Windows and Mac OS X don't support selections.      \sa dataChanged(), findBufferChanged(), changed() */
end_comment
begin_comment
comment|/*!     \fn void QClipboard::findBufferChanged()     \since 4.2      This signal is emitted when the find buffer is changed. This only     applies to Mac OS X.      With Qt version 4.3 or higher, clipboard changes made by other     applications will only be detected when the application is activated.      \sa dataChanged(), selectionChanged(), changed() */
end_comment
begin_comment
comment|/*! \enum QClipboard::Mode     \keyword clipboard mode      This enum type is used to control which part of the system clipboard is     used by QClipboard::mimeData(), QClipboard::setMimeData() and related functions.      \value Clipboard  indicates that data should be stored and retrieved from     the global clipboard.      \value Selection  indicates that data should be stored and retrieved from     the global mouse selection. Support for \c Selection is provided only on     systems with a global mouse selection (e.g. X11).      \value FindBuffer indicates that data should be stored and retrieved from     the Find buffer. This mode is used for holding search strings on Mac OS X.      \omitvalue LastMode      \sa QClipboard::supportsSelection() */
end_comment
begin_comment
comment|/*!     \overload      Returns the clipboard text in subtype \a subtype, or an empty string     if the clipboard does not contain any text. If \a subtype is null,     any subtype is acceptable, and \a subtype is set to the chosen     subtype.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     text is retrieved from the global clipboard.  If \a mode is     QClipboard::Selection, the text is retrieved from the global     mouse selection.      Common values for \a subtype are "plain" and "html".      Note that calling this function repeatedly, for instance from a     key event handler, may be slow. In such cases, you should use the     \c dataChanged() signal instead.      \sa setText(), mimeData() */
end_comment
begin_function
DECL|function|text
name|QString
name|QClipboard
operator|::
name|text
parameter_list|(
name|QString
modifier|&
name|subtype
parameter_list|,
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QMimeData
modifier|*
specifier|const
name|data
init|=
name|mimeData
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|QStringList
name|formats
init|=
name|data
operator|->
name|formats
argument_list|()
decl_stmt|;
if|if
condition|(
name|subtype
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|formats
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
condition|)
name|subtype
operator|=
name|QLatin1String
argument_list|(
literal|"plain"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|formats
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|formats
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/"
argument_list|)
argument_list|)
condition|)
block|{
name|subtype
operator|=
name|formats
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mid
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subtype
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|formats
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/"
argument_list|)
operator|+
name|subtype
argument_list|)
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
specifier|const
name|QByteArray
name|rawData
init|=
name|data
operator|->
name|data
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/"
argument_list|)
operator|+
name|subtype
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|106
argument_list|)
decl_stmt|;
comment|// utf-8 is default
if|if
condition|(
name|subtype
operator|==
name|QLatin1String
argument_list|(
literal|"html"
argument_list|)
condition|)
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForHtml
argument_list|(
name|rawData
argument_list|,
name|codec
argument_list|)
expr_stmt|;
else|else
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForUtfText
argument_list|(
name|rawData
argument_list|,
name|codec
argument_list|)
expr_stmt|;
return|return
name|codec
operator|->
name|toUnicode
argument_list|(
name|rawData
argument_list|)
return|;
else|#
directive|else
comment|//QT_NO_TEXTCODEC
return|return
name|rawData
return|;
endif|#
directive|endif
comment|//QT_NO_TEXTCODEC
block|}
end_function
begin_comment
comment|/*!     Returns the clipboard text as plain text, or an empty string if the     clipboard does not contain any text.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     text is retrieved from the global clipboard.  If \a mode is     QClipboard::Selection, the text is retrieved from the global     mouse selection. If \a mode is QClipboard::FindBuffer, the     text is retrieved from the search string buffer.      \sa setText(), mimeData() */
end_comment
begin_function
DECL|function|text
name|QString
name|QClipboard
operator|::
name|text
parameter_list|(
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QMimeData
modifier|*
name|data
init|=
name|mimeData
argument_list|(
name|mode
argument_list|)
decl_stmt|;
return|return
name|data
condition|?
name|data
operator|->
name|text
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Copies \a text into the clipboard as plain text.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     text is stored in the global clipboard.  If \a mode is     QClipboard::Selection, the text is stored in the global     mouse selection. If \a mode is QClipboard::FindBuffer, the     text is stored in the search string buffer.      \sa text(), setMimeData() */
end_comment
begin_function
DECL|function|setText
name|void
name|QClipboard
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|Mode
name|mode
parameter_list|)
block|{
name|QMimeData
modifier|*
name|data
init|=
operator|new
name|QMimeData
decl_stmt|;
name|data
operator|->
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|setMimeData
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the clipboard image, or returns a null image if the     clipboard does not contain an image or if it contains an image in     an unsupported image format.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     image is retrieved from the global clipboard.  If \a mode is     QClipboard::Selection, the image is retrieved from the global     mouse selection.      \sa setImage(), pixmap(), mimeData(), QImage::isNull() */
end_comment
begin_function
DECL|function|image
name|QImage
name|QClipboard
operator|::
name|image
parameter_list|(
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QMimeData
modifier|*
name|data
init|=
name|mimeData
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|QImage
argument_list|()
return|;
return|return
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|data
operator|->
name|imageData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Copies the \a image into the clipboard.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     image is stored in the global clipboard.  If \a mode is     QClipboard::Selection, the data is stored in the global     mouse selection.      This is shorthand for:      \snippet code/src_gui_kernel_qclipboard.cpp 1      \sa image(), setPixmap(), setMimeData() */
end_comment
begin_function
DECL|function|setImage
name|void
name|QClipboard
operator|::
name|setImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Mode
name|mode
parameter_list|)
block|{
name|QMimeData
modifier|*
name|data
init|=
operator|new
name|QMimeData
decl_stmt|;
name|data
operator|->
name|setImageData
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|setMimeData
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the clipboard pixmap, or null if the clipboard does not     contain a pixmap. Note that this can lose information. For     example, if the image is 24-bit and the display is 8-bit, the     result is converted to 8 bits, and if the image has an alpha     channel, the result just has a mask.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     pixmap is retrieved from the global clipboard.  If \a mode is     QClipboard::Selection, the pixmap is retrieved from the global     mouse selection.      \sa setPixmap(), image(), mimeData(), QPixmap::convertFromImage() */
end_comment
begin_function
DECL|function|pixmap
name|QPixmap
name|QClipboard
operator|::
name|pixmap
parameter_list|(
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|QMimeData
modifier|*
name|data
init|=
name|mimeData
argument_list|(
name|mode
argument_list|)
decl_stmt|;
return|return
name|data
condition|?
name|qvariant_cast
argument_list|<
name|QPixmap
argument_list|>
argument_list|(
name|data
operator|->
name|imageData
argument_list|()
argument_list|)
else|:
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Copies \a pixmap into the clipboard. Note that this is slower     than setImage() because it needs to convert the QPixmap to a     QImage first.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     pixmap is stored in the global clipboard.  If \a mode is     QClipboard::Selection, the pixmap is stored in the global     mouse selection.      \sa pixmap(), setImage(), setMimeData() */
end_comment
begin_function
DECL|function|setPixmap
name|void
name|QClipboard
operator|::
name|setPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|Mode
name|mode
parameter_list|)
block|{
name|QMimeData
modifier|*
name|data
init|=
operator|new
name|QMimeData
decl_stmt|;
name|data
operator|->
name|setImageData
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
name|setMimeData
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QMimeData *QClipboard::mimeData(Mode mode) const      Returns a reference to a QMimeData representation of the current     clipboard data.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     data is retrieved from the global clipboard.  If \a mode is     QClipboard::Selection, the data is retrieved from the global     mouse selection. If \a mode is QClipboard::FindBuffer, the     data is retrieved from the search string buffer.      The text(), image(), and pixmap() functions are simpler     wrappers for retrieving text, image, and pixmap data.      \sa setMimeData() */
end_comment
begin_comment
comment|/*!     \fn void QClipboard::setMimeData(QMimeData *src, Mode mode)      Sets the clipboard data to \a src. Ownership of the data is     transferred to the clipboard. If you want to remove the data     either call clear() or call setMimeData() again with new data.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, the     data is stored in the global clipboard.  If \a mode is     QClipboard::Selection, the data is stored in the global     mouse selection. If \a mode is QClipboard::FindBuffer, the     data is stored in the search string buffer.      The setText(), setImage() and setPixmap() functions are simpler     wrappers for setting text, image and pixmap data respectively.      \sa mimeData() */
end_comment
begin_comment
comment|/*!     \fn void QClipboard::clear(Mode mode)     Clear the clipboard contents.      The \a mode argument is used to control which part of the system     clipboard is used.  If \a mode is QClipboard::Clipboard, this     function clears the global clipboard contents.  If \a mode is     QClipboard::Selection, this function clears the global mouse     selection contents. If \a mode is QClipboard::FindBuffer, this     function clears the search string buffer.      \sa QClipboard::Mode, supportsSelection() */
end_comment
begin_comment
comment|/*!     Returns true if the clipboard supports mouse selection; otherwise     returns false. */
end_comment
begin_function
DECL|function|supportsSelection
name|bool
name|QClipboard
operator|::
name|supportsSelection
parameter_list|()
specifier|const
block|{
return|return
name|supportsMode
argument_list|(
name|Selection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the clipboard supports a separate search buffer; otherwise     returns false. */
end_comment
begin_function
DECL|function|supportsFindBuffer
name|bool
name|QClipboard
operator|::
name|supportsFindBuffer
parameter_list|()
specifier|const
block|{
return|return
name|supportsMode
argument_list|(
name|FindBuffer
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this clipboard object owns the clipboard data;     otherwise returns false. */
end_comment
begin_function
DECL|function|ownsClipboard
name|bool
name|QClipboard
operator|::
name|ownsClipboard
parameter_list|()
specifier|const
block|{
return|return
name|ownsMode
argument_list|(
name|Clipboard
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this clipboard object owns the mouse selection     data; otherwise returns false. */
end_comment
begin_function
DECL|function|ownsSelection
name|bool
name|QClipboard
operator|::
name|ownsSelection
parameter_list|()
specifier|const
block|{
return|return
name|ownsMode
argument_list|(
name|Selection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if this clipboard object owns the find buffer data;     otherwise returns false. */
end_comment
begin_function
DECL|function|ownsFindBuffer
name|bool
name|QClipboard
operator|::
name|ownsFindBuffer
parameter_list|()
specifier|const
block|{
return|return
name|ownsMode
argument_list|(
name|FindBuffer
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \fn bool QClipboard::supportsMode(Mode mode) const;     Returns true if the clipboard supports the clipboard mode speacified by \a mode;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \internal     \fn bool QClipboard::ownsMode(Mode mode) const;     Returns true if the clipboard supports the clipboard data speacified by \a mode;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \internal     Emits the appropriate changed signal for \a mode. */
end_comment
begin_function
DECL|function|emitChanged
name|void
name|QClipboard
operator|::
name|emitChanged
parameter_list|(
name|Mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|Clipboard
case|:
emit|emit
name|dataChanged
argument_list|()
emit|;
break|break;
case|case
name|Selection
case|:
emit|emit
name|selectionChanged
argument_list|()
emit|;
break|break;
case|case
name|FindBuffer
case|:
emit|emit
name|findBufferChanged
argument_list|()
emit|;
break|break;
default|default:
break|break;
block|}
emit|emit
name|changed
argument_list|(
name|mode
argument_list|)
emit|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CLIPBOARD
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
