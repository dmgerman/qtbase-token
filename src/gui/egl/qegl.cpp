begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtGui/qpaintdevice.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpixmap.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qwidget.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qatomic.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qegl_p.h"
end_include
begin_include
include|#
directive|include
file|"qeglcontext_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*     QEglContextTracker is used to track the EGL contexts that we     create internally in Qt, so that we can call eglTerminate() to     free additional EGL resources when the last context is destroyed. */
end_comment
begin_class
DECL|class|QEglContextTracker
class|class
name|QEglContextTracker
block|{
public|public:
DECL|function|ref
specifier|static
name|void
name|ref
parameter_list|()
block|{
name|contexts
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
DECL|function|deref
specifier|static
name|void
name|deref
parameter_list|()
block|{
if|if
condition|(
operator|!
name|contexts
operator|.
name|deref
argument_list|()
condition|)
block|{
name|eglTerminate
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|)
expr_stmt|;
name|displayOpen
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|setDisplayOpened
specifier|static
name|void
name|setDisplayOpened
parameter_list|()
block|{
name|displayOpen
operator|=
literal|1
expr_stmt|;
block|}
DECL|function|displayOpened
specifier|static
name|bool
name|displayOpened
parameter_list|()
block|{
return|return
name|displayOpen
return|;
block|}
private|private:
DECL|member|contexts
specifier|static
name|QBasicAtomicInt
name|contexts
decl_stmt|;
DECL|member|displayOpen
specifier|static
name|QBasicAtomicInt
name|displayOpen
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|contexts
name|QBasicAtomicInt
name|QEglContextTracker
operator|::
name|contexts
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|displayOpen
name|QBasicAtomicInt
name|QEglContextTracker
operator|::
name|displayOpen
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Current GL and VG contexts.  These are used to determine if
end_comment
begin_comment
comment|// we can avoid an eglMakeCurrent() after a call to lazyDoneCurrent().
end_comment
begin_comment
comment|// If a background thread modifies the value, the worst that will
end_comment
begin_comment
comment|// happen is a redundant eglMakeCurrent() in the foreground thread.
end_comment
begin_decl_stmt
DECL|variable|currentGLContext
specifier|static
name|QEglContext
modifier|*
specifier|volatile
name|currentGLContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|currentVGContext
specifier|static
name|QEglContext
modifier|*
specifier|volatile
name|currentVGContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QEglContext
name|QEglContext
operator|::
name|QEglContext
parameter_list|()
member_init_list|:
name|apiType
argument_list|(
name|QEgl
operator|::
name|OpenGL
argument_list|)
member_init_list|,
name|ctx
argument_list|(
name|EGL_NO_CONTEXT
argument_list|)
member_init_list|,
name|cfg
argument_list|(
name|QEGL_NO_CONFIG
argument_list|)
member_init_list|,
name|currentSurface
argument_list|(
name|EGL_NO_SURFACE
argument_list|)
member_init_list|,
name|current
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|ownsContext
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|sharing
argument_list|(
literal|false
argument_list|)
block|{
name|QEglContextTracker
operator|::
name|ref
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QEglContext
name|QEglContext
operator|::
name|~
name|QEglContext
parameter_list|()
block|{
name|destroyContext
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentGLContext
operator|==
name|this
condition|)
name|currentGLContext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|currentVGContext
operator|==
name|this
condition|)
name|currentVGContext
operator|=
literal|0
expr_stmt|;
name|QEglContextTracker
operator|::
name|deref
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|isValid
name|bool
name|QEglContext
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|ctx
operator|!=
name|EGL_NO_CONTEXT
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isCurrent
name|bool
name|QEglContext
operator|::
name|isCurrent
parameter_list|()
specifier|const
block|{
return|return
name|current
return|;
block|}
end_function
begin_function
DECL|function|defaultConfig
name|EGLConfig
name|QEgl
operator|::
name|defaultConfig
parameter_list|(
name|int
name|devType
parameter_list|,
name|API
name|api
parameter_list|,
name|ConfigOptions
name|options
parameter_list|)
block|{
if|if
condition|(
operator|(
name|devType
operator|!=
name|QInternal
operator|::
name|Pixmap
operator|)
operator|&&
operator|(
operator|(
name|options
operator|&
name|Renderable
operator|)
operator|==
literal|0
operator|)
condition|)
name|qWarning
argument_list|(
literal|"QEgl::defaultConfig() - Only configs for pixmaps make sense to be read-only!"
argument_list|)
expr_stmt|;
name|EGLConfig
modifier|*
name|targetConfig
init|=
literal|0
decl_stmt|;
specifier|static
name|EGLConfig
name|defaultVGConfigs
index|[]
init|=
block|{
name|QEGL_NO_CONFIG
block|,
comment|// 0    Window  Renderable  Translucent
name|QEGL_NO_CONFIG
block|,
comment|// 1    Window  Renderable  Opaque
name|QEGL_NO_CONFIG
block|,
comment|// 2    Pixmap  Renderable  Translucent
name|QEGL_NO_CONFIG
block|,
comment|// 3    Pixmap  Renderable  Opaque
name|QEGL_NO_CONFIG
block|,
comment|// 4    Pixmap  ReadOnly    Translucent
name|QEGL_NO_CONFIG
comment|// 5    Pixmap  ReadOnly    Opaque
block|}
decl_stmt|;
if|if
condition|(
name|api
operator|==
name|OpenVG
condition|)
block|{
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Pixmap
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Renderable
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|2
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Read-only
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|4
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultVGConfigs
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|EGLConfig
name|defaultGLConfigs
index|[]
init|=
block|{
name|QEGL_NO_CONFIG
block|,
comment|// 0    Window  Renderable  Translucent
name|QEGL_NO_CONFIG
block|,
comment|// 1    Window  Renderable  Opaque
name|QEGL_NO_CONFIG
block|,
comment|// 2    PBuffer Renderable  Translucent
name|QEGL_NO_CONFIG
block|,
comment|// 3    PBuffer Renderable  Opaque
name|QEGL_NO_CONFIG
block|,
comment|// 4    Pixmap  Renderable  Translucent
name|QEGL_NO_CONFIG
block|,
comment|// 5    Pixmap  Renderable  Opaque
name|QEGL_NO_CONFIG
block|,
comment|// 6    Pixmap  ReadOnly    Translucent
name|QEGL_NO_CONFIG
comment|// 7    Pixmap  ReadOnly    Opaque
block|}
decl_stmt|;
if|if
condition|(
name|api
operator|==
name|OpenGL
condition|)
block|{
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Pbuffer
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|2
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Pixmap
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Renderable
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|4
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|5
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// ReadOnly
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|6
index|]
operator|)
expr_stmt|;
else|else
comment|// Opaque
name|targetConfig
operator|=
operator|&
operator|(
name|defaultGLConfigs
index|[
literal|7
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|targetConfig
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEgl::defaultConfig() - No default config for device/api/options combo"
argument_list|)
expr_stmt|;
return|return
name|QEGL_NO_CONFIG
return|;
block|}
if|if
condition|(
operator|*
name|targetConfig
operator|!=
name|QEGL_NO_CONFIG
condition|)
return|return
operator|*
name|targetConfig
return|;
comment|// We haven't found an EGL config for the target config yet, so do it now:
comment|// Allow overriding from an environment variable:
name|QByteArray
name|configId
decl_stmt|;
if|if
condition|(
name|api
operator|==
name|OpenVG
condition|)
name|configId
operator|=
name|qgetenv
argument_list|(
literal|"QT_VG_EGL_CONFIG"
argument_list|)
expr_stmt|;
else|else
name|configId
operator|=
name|qgetenv
argument_list|(
literal|"QT_GL_EGL_CONFIG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Overridden, so get the EGLConfig for the specified config ID:
name|EGLint
name|properties
index|[]
init|=
block|{
name|EGL_CONFIG_ID
block|,
operator|(
name|EGLint
operator|)
name|configId
operator|.
name|toInt
argument_list|()
block|,
name|EGL_NONE
block|}
decl_stmt|;
name|EGLint
name|configCount
init|=
literal|0
decl_stmt|;
name|eglChooseConfig
argument_list|(
name|display
argument_list|()
argument_list|,
name|properties
argument_list|,
name|targetConfig
argument_list|,
literal|1
argument_list|,
operator|&
name|configCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|configCount
operator|>
literal|0
condition|)
return|return
operator|*
name|targetConfig
return|;
name|qWarning
argument_list|()
operator|<<
literal|"QEgl::defaultConfig() -"
operator|<<
name|configId
operator|<<
literal|"appears to be invalid"
expr_stmt|;
block|}
name|QEglProperties
name|configAttribs
decl_stmt|;
name|configAttribs
operator|.
name|setRenderableType
argument_list|(
name|api
argument_list|)
expr_stmt|;
name|EGLint
name|surfaceType
decl_stmt|;
switch|switch
condition|(
name|devType
condition|)
block|{
case|case
name|QInternal
operator|::
name|Widget
case|:
name|surfaceType
operator|=
name|EGL_WINDOW_BIT
expr_stmt|;
break|break;
case|case
name|QInternal
operator|::
name|Pixmap
case|:
name|surfaceType
operator|=
name|EGL_PIXMAP_BIT
expr_stmt|;
break|break;
case|case
name|QInternal
operator|::
name|Pbuffer
case|:
name|surfaceType
operator|=
name|EGL_PBUFFER_BIT
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QEgl::defaultConfig() - Can't create EGL surface for %d device type"
argument_list|,
name|devType
argument_list|)
expr_stmt|;
return|return
name|QEGL_NO_CONFIG
return|;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|EGL_VG_ALPHA_FORMAT_PRE_BIT
comment|// For OpenVG, we try to create a surface using a pre-multiplied format if
comment|// the surface needs to have an alpha channel:
if|if
condition|(
name|api
operator|==
name|OpenVG
operator|&&
operator|(
name|options
operator|&
name|Translucent
operator|)
condition|)
name|surfaceType
operator||=
name|EGL_VG_ALPHA_FORMAT_PRE_BIT
expr_stmt|;
endif|#
directive|endif
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_SURFACE_TYPE
argument_list|,
name|surfaceType
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EGL_BIND_TO_TEXTURE_RGBA
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Pixmap
operator|||
name|devType
operator|==
name|QInternal
operator|::
name|Pbuffer
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGBA
argument_list|,
name|EGL_TRUE
argument_list|)
expr_stmt|;
else|else
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGB
argument_list|,
name|EGL_TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Add paint engine requirements
if|if
condition|(
name|api
operator|==
name|OpenVG
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
operator|&&
name|defined
argument_list|(
name|EGL_ALPHA_MASK_SIZE
argument_list|)
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_ALPHA_MASK_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// Both OpenGL paint engines need to have stencil and sample buffers
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_STENCIL_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_SAMPLE_BUFFERS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
comment|// Additionally, the GL1 engine likes to have a depth buffer for clipping
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_DEPTH_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|options
operator|&
name|Translucent
condition|)
name|configAttribs
operator|.
name|setValue
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|targetConfig
operator|=
name|chooseConfig
argument_list|(
operator|&
name|configAttribs
argument_list|,
name|QEgl
operator|::
name|BestPixelFormat
argument_list|)
expr_stmt|;
return|return
operator|*
name|targetConfig
return|;
block|}
end_function
begin_comment
comment|// Choose a configuration that matches "properties".
end_comment
begin_function
DECL|function|chooseConfig
name|EGLConfig
name|QEgl
operator|::
name|chooseConfig
parameter_list|(
specifier|const
name|QEglProperties
modifier|*
name|properties
parameter_list|,
name|QEgl
operator|::
name|PixelFormatMatch
name|match
parameter_list|)
block|{
name|QEglProperties
name|props
argument_list|(
operator|*
name|properties
argument_list|)
decl_stmt|;
name|EGLConfig
name|cfg
init|=
name|QEGL_NO_CONFIG
decl_stmt|;
do|do
block|{
comment|// Get the number of matching configurations for this set of properties.
name|EGLint
name|matching
init|=
literal|0
decl_stmt|;
name|EGLDisplay
name|dpy
init|=
name|QEgl
operator|::
name|display
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|eglChooseConfig
argument_list|(
name|dpy
argument_list|,
name|props
operator|.
name|properties
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|matching
argument_list|)
operator|||
operator|!
name|matching
condition|)
continue|continue;
comment|// If we want the best pixel format, then return the first
comment|// matching configuration.
if|if
condition|(
name|match
operator|==
name|QEgl
operator|::
name|BestPixelFormat
condition|)
block|{
name|eglChooseConfig
argument_list|(
name|display
argument_list|()
argument_list|,
name|props
operator|.
name|properties
argument_list|()
argument_list|,
operator|&
name|cfg
argument_list|,
literal|1
argument_list|,
operator|&
name|matching
argument_list|)
expr_stmt|;
if|if
condition|(
name|matching
operator|<
literal|1
condition|)
continue|continue;
return|return
name|cfg
return|;
block|}
comment|// Fetch all of the matching configurations and find the
comment|// first that matches the pixel format we wanted.
name|EGLint
name|size
init|=
name|matching
decl_stmt|;
name|EGLConfig
modifier|*
name|configs
init|=
operator|new
name|EGLConfig
index|[
name|size
index|]
decl_stmt|;
name|eglChooseConfig
argument_list|(
name|display
argument_list|()
argument_list|,
name|props
operator|.
name|properties
argument_list|()
argument_list|,
name|configs
argument_list|,
name|size
argument_list|,
operator|&
name|matching
argument_list|)
expr_stmt|;
for|for
control|(
name|EGLint
name|index
init|=
literal|0
init|;
name|index
operator|<
name|size
condition|;
operator|++
name|index
control|)
block|{
name|EGLint
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|,
name|alpha
decl_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|()
argument_list|,
name|configs
index|[
name|index
index|]
argument_list|,
name|EGL_RED_SIZE
argument_list|,
operator|&
name|red
argument_list|)
expr_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|()
argument_list|,
name|configs
index|[
name|index
index|]
argument_list|,
name|EGL_GREEN_SIZE
argument_list|,
operator|&
name|green
argument_list|)
expr_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|()
argument_list|,
name|configs
index|[
name|index
index|]
argument_list|,
name|EGL_BLUE_SIZE
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|()
argument_list|,
name|configs
index|[
name|index
index|]
argument_list|,
name|EGL_ALPHA_SIZE
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|props
operator|.
name|value
argument_list|(
name|EGL_RED_SIZE
argument_list|)
operator|&&
name|green
operator|==
name|props
operator|.
name|value
argument_list|(
name|EGL_GREEN_SIZE
argument_list|)
operator|&&
name|blue
operator|==
name|props
operator|.
name|value
argument_list|(
name|EGL_BLUE_SIZE
argument_list|)
operator|&&
operator|(
name|props
operator|.
name|value
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|)
operator|==
literal|0
operator|||
name|alpha
operator|==
name|props
operator|.
name|value
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|)
operator|)
condition|)
block|{
name|cfg
operator|=
name|configs
index|[
name|index
index|]
expr_stmt|;
operator|delete
index|[]
name|configs
expr_stmt|;
return|return
name|cfg
return|;
block|}
block|}
operator|delete
index|[]
name|configs
expr_stmt|;
block|}
do|while
condition|(
name|props
operator|.
name|reduceConfiguration
argument_list|()
condition|)
do|;
ifdef|#
directive|ifdef
name|EGL_BIND_TO_TEXTURE_RGBA
comment|// Don't report an error just yet if we failed to get a pbuffer
comment|// configuration with texture rendering.  Only report failure if
comment|// we cannot get any pbuffer configurations at all.
if|if
condition|(
name|props
operator|.
name|value
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGBA
argument_list|)
operator|==
name|EGL_DONT_CARE
operator|&&
name|props
operator|.
name|value
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGB
argument_list|)
operator|==
name|EGL_DONT_CARE
condition|)
endif|#
directive|endif
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::chooseConfig(): Could not find a suitable EGL configuration"
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
literal|"Requested:"
operator|<<
name|props
operator|.
name|toString
argument_list|()
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
literal|"Available:"
expr_stmt|;
name|QEgl
operator|::
name|dumpAllConfigs
argument_list|()
expr_stmt|;
block|}
return|return
name|QEGL_NO_CONFIG
return|;
block|}
end_function
begin_function
DECL|function|chooseConfig
name|bool
name|QEglContext
operator|::
name|chooseConfig
parameter_list|(
specifier|const
name|QEglProperties
modifier|&
name|properties
parameter_list|,
name|QEgl
operator|::
name|PixelFormatMatch
name|match
parameter_list|)
block|{
name|cfg
operator|=
name|QEgl
operator|::
name|chooseConfig
argument_list|(
operator|&
name|properties
argument_list|,
name|match
argument_list|)
expr_stmt|;
return|return
name|cfg
operator|!=
name|QEGL_NO_CONFIG
return|;
block|}
end_function
begin_function
DECL|function|createSurface
name|EGLSurface
name|QEglContext
operator|::
name|createSurface
parameter_list|(
name|QPaintDevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QEglProperties
modifier|*
name|properties
parameter_list|)
block|{
return|return
name|QEgl
operator|::
name|createSurface
argument_list|(
name|device
argument_list|,
name|cfg
argument_list|,
name|properties
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Create the EGLContext.
end_comment
begin_function
DECL|function|createContext
name|bool
name|QEglContext
operator|::
name|createContext
parameter_list|(
name|QEglContext
modifier|*
name|shareContext
parameter_list|,
specifier|const
name|QEglProperties
modifier|*
name|properties
parameter_list|)
block|{
comment|// We need to select the correct API before calling eglCreateContext().
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
ifdef|#
directive|ifdef
name|EGL_OPENGL_ES_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|EGL_OPENGL_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENGL_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|//defined(QT_OPENGL_ES)
ifdef|#
directive|ifdef
name|EGL_OPENVG_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenVG
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENVG_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Create a new context for the configuration.
name|QEglProperties
name|contextProps
decl_stmt|;
if|if
condition|(
name|properties
condition|)
name|contextProps
operator|=
operator|*
name|properties
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_ES_2
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|contextProps
operator|.
name|setValue
argument_list|(
name|EGL_CONTEXT_CLIENT_VERSION
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sharing
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|shareContext
operator|&&
name|shareContext
operator|->
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
name|shareContext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shareContext
condition|)
block|{
name|ctx
operator|=
name|eglCreateContext
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|cfg
argument_list|,
name|shareContext
operator|->
name|ctx
argument_list|,
name|contextProps
operator|.
name|properties
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::createContext(): Could not share context:"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
name|shareContext
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sharing
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
block|{
name|ctx
operator|=
name|eglCreateContext
argument_list|(
name|display
argument_list|()
argument_list|,
name|cfg
argument_list|,
name|EGL_NO_CONTEXT
argument_list|,
name|contextProps
operator|.
name|properties
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::createContext(): Unable to create EGL context:"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// Destroy an EGL surface object.  If it was current on this context
end_comment
begin_comment
comment|// then call doneCurrent() for it first.
end_comment
begin_function
DECL|function|destroySurface
name|void
name|QEglContext
operator|::
name|destroySurface
parameter_list|(
name|EGLSurface
name|surface
parameter_list|)
block|{
if|if
condition|(
name|surface
operator|!=
name|EGL_NO_SURFACE
condition|)
block|{
if|if
condition|(
name|surface
operator|==
name|currentSurface
condition|)
name|doneCurrent
argument_list|()
expr_stmt|;
name|eglDestroySurface
argument_list|(
name|display
argument_list|()
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Destroy the context.  Note: this does not destroy the surface.
end_comment
begin_function
DECL|function|destroyContext
name|void
name|QEglContext
operator|::
name|destroyContext
parameter_list|()
block|{
if|if
condition|(
name|ctx
operator|!=
name|EGL_NO_CONTEXT
operator|&&
name|ownsContext
condition|)
name|eglDestroyContext
argument_list|(
name|display
argument_list|()
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
name|cfg
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|makeCurrent
name|bool
name|QEglContext
operator|::
name|makeCurrent
parameter_list|(
name|EGLSurface
name|surface
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::makeCurrent(): Cannot make invalid context current"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|surface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::makeCurrent(): Cannot make invalid surface current"
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If lazyDoneCurrent() was called on the surface, then we may be able
comment|// to assume that it is still current within the thread.
if|if
condition|(
name|surface
operator|==
name|currentSurface
operator|&&
name|currentContext
argument_list|(
name|apiType
argument_list|)
operator|==
name|this
condition|)
block|{
name|current
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|current
operator|=
literal|true
expr_stmt|;
name|currentSurface
operator|=
name|surface
expr_stmt|;
name|setCurrentContext
argument_list|(
name|apiType
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Force the right API to be bound before making the context current.
comment|// The EGL implementation should be able to figure this out from ctx,
comment|// but some systems require the API to be explicitly set anyway.
ifdef|#
directive|ifdef
name|EGL_OPENGL_ES_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EGL_OPENVG_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenVG
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENVG_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|ok
init|=
name|eglMakeCurrent
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|surface
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::makeCurrent("
operator|<<
name|surface
operator|<<
literal|"):"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|doneCurrent
name|bool
name|QEglContext
operator|::
name|doneCurrent
parameter_list|()
block|{
comment|// If the context is invalid, we assume that an error was reported
comment|// when makeCurrent() was called.
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
return|return
literal|false
return|;
name|current
operator|=
literal|false
expr_stmt|;
name|currentSurface
operator|=
name|EGL_NO_SURFACE
expr_stmt|;
name|setCurrentContext
argument_list|(
name|apiType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// We need to select the correct API before calling eglMakeCurrent()
comment|// with EGL_NO_CONTEXT because threads can have both OpenGL and OpenVG
comment|// contexts active at the same time.
ifdef|#
directive|ifdef
name|EGL_OPENGL_ES_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EGL_OPENVG_API
if|if
condition|(
name|apiType
operator|==
name|QEgl
operator|::
name|OpenVG
condition|)
name|eglBindAPI
argument_list|(
name|EGL_OPENVG_API
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|ok
init|=
name|eglMakeCurrent
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|EGL_NO_SURFACE
argument_list|,
name|EGL_NO_SURFACE
argument_list|,
name|EGL_NO_CONTEXT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::doneCurrent():"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|// Act as though doneCurrent() was called, but keep the context
end_comment
begin_comment
comment|// and the surface active for the moment.  This allows makeCurrent()
end_comment
begin_comment
comment|// to skip a call to eglMakeCurrent() if we are using the same
end_comment
begin_comment
comment|// surface as the last set of painting operations.  We leave the
end_comment
begin_comment
comment|// currentContext() pointer as-is for now.
end_comment
begin_function
DECL|function|lazyDoneCurrent
name|bool
name|QEglContext
operator|::
name|lazyDoneCurrent
parameter_list|()
block|{
name|current
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|swapBuffers
name|bool
name|QEglContext
operator|::
name|swapBuffers
parameter_list|(
name|EGLSurface
name|surface
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|==
name|EGL_NO_CONTEXT
condition|)
return|return
literal|false
return|;
name|bool
name|ok
init|=
name|eglSwapBuffers
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::swapBuffers():"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|swapBuffersRegion2NOK
name|bool
name|QEglContext
operator|::
name|swapBuffersRegion2NOK
parameter_list|(
name|EGLSurface
name|surface
parameter_list|,
specifier|const
name|QRegion
modifier|*
name|region
parameter_list|)
block|{
name|QVector
argument_list|<
name|QRect
argument_list|>
name|qrects
init|=
name|region
operator|->
name|rects
argument_list|()
decl_stmt|;
name|EGLint
modifier|*
name|gl_rects
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|count
operator|=
name|qrects
operator|.
name|size
argument_list|()
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|EGLint
argument_list|>
name|arr
argument_list|(
literal|4
operator|*
name|count
argument_list|)
decl_stmt|;
name|gl_rects
operator|=
name|arr
operator|.
name|data
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|QRect
name|qrect
init|=
name|qrects
index|[
name|i
index|]
decl_stmt|;
name|gl_rects
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|qrect
operator|.
name|x
argument_list|()
expr_stmt|;
name|gl_rects
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|qrect
operator|.
name|y
argument_list|()
expr_stmt|;
name|gl_rects
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|=
name|qrect
operator|.
name|width
argument_list|()
expr_stmt|;
name|gl_rects
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|=
name|qrect
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
name|bool
name|ok
init|=
name|QEgl
operator|::
name|eglSwapBuffersRegion2NOK
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|count
argument_list|,
name|gl_rects
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QEglContext::swapBuffersRegion2NOK():"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|configAttrib
name|int
name|QEglContext
operator|::
name|configAttrib
parameter_list|(
name|int
name|name
parameter_list|)
specifier|const
block|{
name|EGLint
name|value
decl_stmt|;
name|EGLBoolean
name|success
init|=
name|eglGetConfigAttrib
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|cfg
argument_list|,
name|name
argument_list|,
operator|&
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
return|return
name|value
return|;
else|else
return|return
name|EGL_DONT_CARE
return|;
block|}
end_function
begin_typedef
DECL|typedef|_eglCreateImageKHR
typedef|typedef
name|EGLImageKHR
function_decl|(
name|EGLAPIENTRY
modifier|*
name|_eglCreateImageKHR
function_decl|)
parameter_list|(
name|EGLDisplay
parameter_list|,
name|EGLContext
parameter_list|,
name|EGLenum
parameter_list|,
name|EGLClientBuffer
parameter_list|,
specifier|const
name|EGLint
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|_eglDestroyImageKHR
typedef|typedef
name|EGLBoolean
function_decl|(
name|EGLAPIENTRY
modifier|*
name|_eglDestroyImageKHR
function_decl|)
parameter_list|(
name|EGLDisplay
parameter_list|,
name|EGLImageKHR
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|// Defined in qegl.cpp:
end_comment
begin_decl_stmt
DECL|variable|qt_eglCreateImageKHR
specifier|static
name|_eglCreateImageKHR
name|qt_eglCreateImageKHR
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_eglDestroyImageKHR
specifier|static
name|_eglDestroyImageKHR
name|qt_eglDestroyImageKHR
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|_eglSwapBuffersRegion2NOK
typedef|typedef
name|EGLBoolean
function_decl|(
name|EGLAPIENTRY
modifier|*
name|_eglSwapBuffersRegion2NOK
function_decl|)
parameter_list|(
name|EGLDisplay
parameter_list|,
name|EGLSurface
parameter_list|,
name|EGLint
parameter_list|,
specifier|const
name|EGLint
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|qt_eglSwapBuffersRegion2NOK
specifier|static
name|_eglSwapBuffersRegion2NOK
name|qt_eglSwapBuffersRegion2NOK
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|display
name|EGLDisplay
name|QEgl
operator|::
name|display
parameter_list|()
block|{
specifier|static
name|EGLDisplay
name|dpy
init|=
name|EGL_NO_DISPLAY
decl_stmt|;
if|if
condition|(
operator|!
name|QEglContextTracker
operator|::
name|displayOpened
argument_list|()
condition|)
block|{
name|dpy
operator|=
name|eglGetDisplay
argument_list|(
name|nativeDisplay
argument_list|()
argument_list|)
expr_stmt|;
name|QEglContextTracker
operator|::
name|setDisplayOpened
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpy
operator|==
name|EGL_NO_DISPLAY
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEgl::display(): Falling back to EGL_DEFAULT_DISPLAY"
argument_list|)
expr_stmt|;
name|dpy
operator|=
name|eglGetDisplay
argument_list|(
name|EGLNativeDisplayType
argument_list|(
name|EGL_DEFAULT_DISPLAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpy
operator|==
name|EGL_NO_DISPLAY
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEgl::display(): Can't even open the default display"
argument_list|)
expr_stmt|;
return|return
name|EGL_NO_DISPLAY
return|;
block|}
if|if
condition|(
operator|!
name|eglInitialize
argument_list|(
name|dpy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QEgl::display(): Cannot initialize EGL display:"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return
name|EGL_NO_DISPLAY
return|;
block|}
comment|// Resolve the egl extension function pointers:
if|#
directive|if
operator|(
name|defined
argument_list|(
name|EGL_KHR_image
argument_list|)
operator|||
name|defined
argument_list|(
name|EGL_KHR_image_base
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|EGL_EGLEXT_PROTOTYPES
argument_list|)
if|if
condition|(
name|QEgl
operator|::
name|hasExtension
argument_list|(
literal|"EGL_KHR_image"
argument_list|)
operator|||
name|QEgl
operator|::
name|hasExtension
argument_list|(
literal|"EGL_KHR_image_base"
argument_list|)
condition|)
block|{
name|qt_eglCreateImageKHR
operator|=
operator|(
name|_eglCreateImageKHR
operator|)
name|eglGetProcAddress
argument_list|(
literal|"eglCreateImageKHR"
argument_list|)
expr_stmt|;
name|qt_eglDestroyImageKHR
operator|=
operator|(
name|_eglDestroyImageKHR
operator|)
name|eglGetProcAddress
argument_list|(
literal|"eglDestroyImageKHR"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|QEgl
operator|::
name|hasExtension
argument_list|(
literal|"EGL_NOK_swap_region2"
argument_list|)
condition|)
block|{
name|qt_eglSwapBuffersRegion2NOK
operator|=
operator|(
name|_eglSwapBuffersRegion2NOK
operator|)
name|eglGetProcAddress
argument_list|(
literal|"eglSwapBuffersRegion2NOK"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dpy
return|;
block|}
end_function
begin_function
DECL|function|eglCreateImageKHR
name|EGLImageKHR
name|QEgl
operator|::
name|eglCreateImageKHR
parameter_list|(
name|EGLDisplay
name|dpy
parameter_list|,
name|EGLContext
name|ctx
parameter_list|,
name|EGLenum
name|target
parameter_list|,
name|EGLClientBuffer
name|buffer
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|attrib_list
parameter_list|)
block|{
if|if
condition|(
name|qt_eglCreateImageKHR
condition|)
return|return
name|qt_eglCreateImageKHR
argument_list|(
name|dpy
argument_list|,
name|ctx
argument_list|,
name|target
argument_list|,
name|buffer
argument_list|,
name|attrib_list
argument_list|)
return|;
name|QEgl
operator|::
name|display
argument_list|()
expr_stmt|;
comment|// Initialises function pointers
if|if
condition|(
name|qt_eglCreateImageKHR
condition|)
return|return
name|qt_eglCreateImageKHR
argument_list|(
name|dpy
argument_list|,
name|ctx
argument_list|,
name|target
argument_list|,
name|buffer
argument_list|,
name|attrib_list
argument_list|)
return|;
name|qWarning
argument_list|(
literal|"QEgl::eglCreateImageKHR() called but EGL_KHR_image(_base) extension not present"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|eglDestroyImageKHR
name|EGLBoolean
name|QEgl
operator|::
name|eglDestroyImageKHR
parameter_list|(
name|EGLDisplay
name|dpy
parameter_list|,
name|EGLImageKHR
name|img
parameter_list|)
block|{
if|if
condition|(
name|qt_eglDestroyImageKHR
condition|)
return|return
name|qt_eglDestroyImageKHR
argument_list|(
name|dpy
argument_list|,
name|img
argument_list|)
return|;
name|QEgl
operator|::
name|display
argument_list|()
expr_stmt|;
comment|// Initialises function pointers
if|if
condition|(
name|qt_eglDestroyImageKHR
condition|)
return|return
name|qt_eglDestroyImageKHR
argument_list|(
name|dpy
argument_list|,
name|img
argument_list|)
return|;
name|qWarning
argument_list|(
literal|"QEgl::eglDestroyImageKHR() called but EGL_KHR_image(_base) extension not present"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|eglSwapBuffersRegion2NOK
name|EGLBoolean
name|QEgl
operator|::
name|eglSwapBuffersRegion2NOK
parameter_list|(
name|EGLDisplay
name|dpy
parameter_list|,
name|EGLSurface
name|surface
parameter_list|,
name|EGLint
name|count
parameter_list|,
specifier|const
name|EGLint
modifier|*
name|rects
parameter_list|)
block|{
if|if
condition|(
name|qt_eglSwapBuffersRegion2NOK
condition|)
return|return
name|qt_eglSwapBuffersRegion2NOK
argument_list|(
name|dpy
argument_list|,
name|surface
argument_list|,
name|count
argument_list|,
name|rects
argument_list|)
return|;
name|QEgl
operator|::
name|display
argument_list|()
expr_stmt|;
comment|// Initialises function pointers
if|if
condition|(
name|qt_eglSwapBuffersRegion2NOK
condition|)
return|return
name|qt_eglSwapBuffersRegion2NOK
argument_list|(
name|dpy
argument_list|,
name|surface
argument_list|,
name|count
argument_list|,
name|rects
argument_list|)
return|;
name|qWarning
argument_list|(
literal|"QEgl::eglSwapBuffersRegion2NOK() called but EGL_NOK_swap_region2 extension not present"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|createSurface
name|EGLSurface
name|QEgl
operator|::
name|createSurface
parameter_list|(
name|QPaintDevice
modifier|*
name|device
parameter_list|,
name|EGLConfig
name|cfg
parameter_list|,
specifier|const
name|QEglProperties
modifier|*
name|properties
parameter_list|)
block|{
comment|// Create the native drawable for the paint device.
name|int
name|devType
init|=
name|device
operator|->
name|devType
argument_list|()
decl_stmt|;
name|EGLNativePixmapType
name|pixmapDrawable
init|=
literal|0
decl_stmt|;
name|EGLNativeWindowType
name|windowDrawable
init|=
literal|0
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Pixmap
condition|)
block|{
name|pixmapDrawable
operator|=
name|nativePixmap
argument_list|(
cast|static_cast
argument_list|<
name|QPixmap
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|(
name|pixmapDrawable
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|windowDrawable
operator|=
name|nativeWindow
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|(
name|windowDrawable
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEglContext::createSurface(): Cannot create the native EGL drawable"
argument_list|)
expr_stmt|;
return|return
name|EGL_NO_SURFACE
return|;
block|}
comment|// Create the EGL surface to draw into, based on the native drawable.
specifier|const
name|int
modifier|*
name|props
decl_stmt|;
if|if
condition|(
name|properties
condition|)
name|props
operator|=
name|properties
operator|->
name|properties
argument_list|()
expr_stmt|;
else|else
name|props
operator|=
literal|0
expr_stmt|;
name|EGLSurface
name|surf
decl_stmt|;
if|if
condition|(
name|devType
operator|==
name|QInternal
operator|::
name|Widget
condition|)
name|surf
operator|=
name|eglCreateWindowSurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|cfg
argument_list|,
name|windowDrawable
argument_list|,
name|props
argument_list|)
expr_stmt|;
else|else
name|surf
operator|=
name|eglCreatePixmapSurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|cfg
argument_list|,
name|pixmapDrawable
argument_list|,
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|surf
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEglContext::createSurface(): Unable to create EGL surface, error = 0x%x"
argument_list|,
name|eglGetError
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|surf
return|;
block|}
end_function
begin_comment
comment|// Return the error string associated with a specific code.
end_comment
begin_function
DECL|function|errorString
name|QString
name|QEgl
operator|::
name|errorString
parameter_list|(
name|EGLint
name|code
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|errors
index|[]
init|=
block|{
literal|"Success (0x3000)"
block|,
comment|// No tr
literal|"Not initialized (0x3001)"
block|,
comment|// No tr
literal|"Bad access (0x3002)"
block|,
comment|// No tr
literal|"Bad alloc (0x3003)"
block|,
comment|// No tr
literal|"Bad attribute (0x3004)"
block|,
comment|// No tr
literal|"Bad config (0x3005)"
block|,
comment|// No tr
literal|"Bad context (0x3006)"
block|,
comment|// No tr
literal|"Bad current surface (0x3007)"
block|,
comment|// No tr
literal|"Bad display (0x3008)"
block|,
comment|// No tr
literal|"Bad match (0x3009)"
block|,
comment|// No tr
literal|"Bad native pixmap (0x300A)"
block|,
comment|// No tr
literal|"Bad native window (0x300B)"
block|,
comment|// No tr
literal|"Bad parameter (0x300C)"
block|,
comment|// No tr
literal|"Bad surface (0x300D)"
block|,
comment|// No tr
literal|"Context lost (0x300E)"
comment|// No tr
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0x3000
operator|&&
name|code
operator|<=
literal|0x300E
condition|)
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|errors
index|[
name|code
operator|-
literal|0x3000
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QLatin1String
argument_list|(
literal|"0x"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|int
argument_list|(
name|code
argument_list|)
argument_list|,
literal|16
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|// Dump all of the EGL configurations supported by the system.
end_comment
begin_function
DECL|function|dumpAllConfigs
name|void
name|QEgl
operator|::
name|dumpAllConfigs
parameter_list|()
block|{
name|QEglProperties
name|props
decl_stmt|;
name|EGLint
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|eglGetConfigs
argument_list|(
name|display
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|count
argument_list|)
operator|||
name|count
operator|<
literal|1
condition|)
return|return;
name|EGLConfig
modifier|*
name|configs
init|=
operator|new
name|EGLConfig
index|[
name|count
index|]
decl_stmt|;
name|eglGetConfigs
argument_list|(
name|display
argument_list|()
argument_list|,
name|configs
argument_list|,
name|count
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|EGLint
name|index
init|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
operator|++
name|index
control|)
block|{
name|props
operator|=
name|QEglProperties
argument_list|(
name|configs
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
name|props
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
operator|delete
index|[]
name|configs
expr_stmt|;
block|}
end_function
begin_function
DECL|function|extensions
name|QString
name|QEgl
operator|::
name|extensions
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|exts
init|=
name|eglQueryString
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|EGL_EXTENSIONS
argument_list|)
decl_stmt|;
return|return
name|QString
argument_list|(
name|QLatin1String
argument_list|(
name|exts
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hasExtension
name|bool
name|QEgl
operator|::
name|hasExtension
parameter_list|(
specifier|const
name|char
modifier|*
name|extensionName
parameter_list|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|extensions
init|=
name|QByteArray
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|eglQueryString
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|EGL_EXTENSIONS
argument_list|)
argument_list|)
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
return|return
name|extensions
operator|.
name|contains
argument_list|(
name|extensionName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentContext
name|QEglContext
modifier|*
name|QEglContext
operator|::
name|currentContext
parameter_list|(
name|QEgl
operator|::
name|API
name|api
parameter_list|)
block|{
if|if
condition|(
name|api
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
return|return
name|currentGLContext
return|;
else|else
return|return
name|currentVGContext
return|;
block|}
end_function
begin_function
DECL|function|setCurrentContext
name|void
name|QEglContext
operator|::
name|setCurrentContext
parameter_list|(
name|QEgl
operator|::
name|API
name|api
parameter_list|,
name|QEglContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|api
operator|==
name|QEgl
operator|::
name|OpenGL
condition|)
name|currentGLContext
operator|=
name|context
expr_stmt|;
else|else
name|currentVGContext
operator|=
name|context
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
