begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopenglframebufferobject.h"
end_include
begin_include
include|#
directive|include
file|"qopenglframebufferobject_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<private/qopengl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<qwindow.h>
end_include
begin_include
include|#
directive|include
file|<qlibrary.h>
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
DECL|macro|QT_RESET_GLERROR
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
define|\
value|{                                                         \     while (glGetError() != GL_NO_ERROR) {}                \ }
DECL|macro|QT_CHECK_GLERROR
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
define|\
value|{                                                         \     GLenum err = glGetError();                            \     if (err != GL_NO_ERROR) {                             \         qDebug("[%s line %d] OpenGL Error: %d",           \                __FILE__, __LINE__, (int)err);             \     }                                                     \ }
else|#
directive|else
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
value|{}
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
value|{}
endif|#
directive|endif
comment|// ####TODO Properly #ifdef this class to use #define symbols actually defined
comment|// by OpenGL/ES includes
ifndef|#
directive|ifndef
name|GL_MAX_SAMPLES
DECL|macro|GL_MAX_SAMPLES
define|#
directive|define
name|GL_MAX_SAMPLES
value|0x8D57
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GL_RENDERBUFFER_SAMPLES
DECL|macro|GL_RENDERBUFFER_SAMPLES
define|#
directive|define
name|GL_RENDERBUFFER_SAMPLES
value|0x8CAB
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GL_DEPTH24_STENCIL8
DECL|macro|GL_DEPTH24_STENCIL8
define|#
directive|define
name|GL_DEPTH24_STENCIL8
value|0x88F0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GL_DEPTH_COMPONENT24
DECL|macro|GL_DEPTH_COMPONENT24
define|#
directive|define
name|GL_DEPTH_COMPONENT24
value|0x81A6
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GL_READ_FRAMEBUFFER
DECL|macro|GL_READ_FRAMEBUFFER
define|#
directive|define
name|GL_READ_FRAMEBUFFER
value|0x8CA8
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GL_DRAW_FRAMEBUFFER
DECL|macro|GL_DRAW_FRAMEBUFFER
define|#
directive|define
name|GL_DRAW_FRAMEBUFFER
value|0x8CA9
endif|#
directive|endif
comment|/*!     \class QOpenGLFramebufferObjectFormat     \brief The QOpenGLFramebufferObjectFormat class specifies the format of an OpenGL     framebuffer object.     \inmodule QtGui      \since 5.0      \ingroup painting-3D      A framebuffer object has several characteristics:     \list     \li \l{setSamples()}{Number of samples per pixels.}     \li \l{setAttachment()}{Depth and/or stencil attachments.}     \li \l{setTextureTarget()}{Texture target.}     \li \l{setInternalTextureFormat()}{Internal texture format.}     \endlist      Note that the desired attachments or number of samples per pixels might not     be supported by the hardware driver. Call QOpenGLFramebufferObject::format()     after creating a QOpenGLFramebufferObject to find the exact format that was     used to create the frame buffer object.      \sa QOpenGLFramebufferObject */
comment|/*!     \internal */
DECL|function|detach
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QOpenGLFramebufferObjectFormatPrivate
modifier|*
name|newd
init|=
operator|new
name|QOpenGLFramebufferObjectFormatPrivate
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|newd
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Creates a QOpenGLFramebufferObjectFormat object for specifying     the format of an OpenGL framebuffer object.      By default the format specifies a non-multisample framebuffer object with no     attachments, texture target \c GL_TEXTURE_2D, and internal format \c GL_RGBA8.     On OpenGL/ES systems, the default internal format is \c GL_RGBA.      \sa samples(), attachment(), internalTextureFormat() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|QOpenGLFramebufferObjectFormat
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QOpenGLFramebufferObjectFormatPrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|QOpenGLFramebufferObjectFormat
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QOpenGLFramebufferObjectFormat
modifier|&
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QOpenGLFramebufferObjectFormat. */
end_comment
begin_destructor
DECL|function|~QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|~
name|QOpenGLFramebufferObjectFormat
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the number of samples per pixel for a multisample framebuffer object     to \a samples.  The default sample count of 0 represents a regular     non-multisample framebuffer object.      If the desired amount of samples per pixel is not supported by the hardware     then the maximum number of samples per pixel will be used. Note that     multisample framebuffer objects can not be bound as textures. Also, the     \c{GL_EXT_framebuffer_multisample} extension is required to create a     framebuffer with more than one sample per pixel.      \sa samples() */
end_comment
begin_function
DECL|function|setSamples
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setSamples
parameter_list|(
name|int
name|samples
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|samples
operator|=
name|samples
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of samples per pixel if a framebuffer object     is a multisample framebuffer object. Otherwise, returns 0.     The default value is 0.      \sa setSamples() */
end_comment
begin_function
DECL|function|samples
name|int
name|QOpenGLFramebufferObjectFormat
operator|::
name|samples
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|samples
return|;
block|}
end_function
begin_comment
comment|/*!     Enables mipmapping if \a enabled is true; otherwise disables it.      Mipmapping is disabled by default.      If mipmapping is enabled, additional memory will be allocated for     the mipmap levels. The mipmap levels can be updated by binding the     texture and calling glGenerateMipmap(). Mipmapping cannot be enabled     for multisampled framebuffer objects.      \sa mipmap(), QOpenGLFramebufferObject::texture() */
end_comment
begin_function
DECL|function|setMipmap
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setMipmap
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|mipmap
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if mipmapping is enabled.      \sa setMipmap() */
end_comment
begin_function
DECL|function|mipmap
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|mipmap
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|mipmap
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attachment configuration of a framebuffer object to \a attachment.      \sa attachment() */
end_comment
begin_function
DECL|function|setAttachment
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setAttachment
parameter_list|(
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|attachment
operator|=
name|attachment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the configuration of the depth and stencil buffers attached to     a framebuffer object.  The default is QOpenGLFramebufferObject::NoAttachment.      \sa setAttachment() */
end_comment
begin_function
DECL|function|attachment
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|QOpenGLFramebufferObjectFormat
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|attachment
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the texture target of the texture attached to a framebuffer object to     \a target. Ignored for multisample framebuffer objects.      \sa textureTarget(), samples() */
end_comment
begin_function
DECL|function|setTextureTarget
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setTextureTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|target
operator|=
name|target
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the texture target of the texture attached to a framebuffer object.     Ignored for multisample framebuffer objects.  The default is     \c GL_TEXTURE_2D.      \sa setTextureTarget(), samples() */
end_comment
begin_function
DECL|function|textureTarget
name|GLenum
name|QOpenGLFramebufferObjectFormat
operator|::
name|textureTarget
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|target
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer to     \a internalTextureFormat.      \sa internalTextureFormat() */
end_comment
begin_function
DECL|function|setInternalTextureFormat
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setInternalTextureFormat
parameter_list|(
name|GLenum
name|internalTextureFormat
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|internal_format
operator|=
name|internalTextureFormat
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer.  The default is     \c GL_RGBA8 on desktop OpenGL systems, and \c GL_RGBA on     OpenGL/ES systems.      \sa setInternalTextureFormat() */
end_comment
begin_function
DECL|function|internalTextureFormat
name|GLenum
name|QOpenGLFramebufferObjectFormat
operator|::
name|internalTextureFormat
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|internal_format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all the options of this framebuffer object format     are the same as \a other; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
else|else
return|return
name|d
operator|->
name|equals
argument_list|(
name|other
operator|.
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns false if all the options of this framebuffer object format     are the same as \a other; otherwise returns true. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_function
DECL|function|checkFramebufferStatus
name|bool
name|QOpenGLFramebufferObjectPrivate
operator|::
name|checkFramebufferStatus
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
name|GLenum
name|status
init|=
name|ctx
operator|->
name|functions
argument_list|()
operator|->
name|glCheckFramebufferStatus
argument_list|(
name|GL_FRAMEBUFFER
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|GL_NO_ERROR
case|:
case|case
name|GL_FRAMEBUFFER_COMPLETE
case|:
return|return
literal|true
return|;
case|case
name|GL_FRAMEBUFFER_UNSUPPORTED
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Unsupported framebuffer format."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete attachment."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing attachment."
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, duplicate attachment."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attached images must have same dimensions."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_FORMATS
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_FORMATS
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attached images must have same format."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing draw buffer."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing read buffer."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attachments must have same number of samples per pixel."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qDebug
argument_list|()
operator|<<
literal|"QOpenGLFramebufferObject: An undefined error has occurred: "
operator|<<
name|status
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|freeFramebufferFunc
name|void
name|freeFramebufferFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeRenderbufferFunc
name|void
name|freeRenderbufferFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeTextureFunc
name|void
name|freeTextureFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_function
DECL|function|init
name|void
name|QOpenGLFramebufferObjectPrivate
operator|::
name|init
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
parameter_list|,
specifier|const
name|QSize
modifier|&
name|sz
parameter_list|,
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|texture_target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|,
name|GLint
name|samples
parameter_list|,
name|bool
name|mipmap
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
name|funcs
operator|.
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|funcs
operator|.
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|Framebuffers
argument_list|)
condition|)
return|return;
name|size
operator|=
name|sz
expr_stmt|;
name|target
operator|=
name|texture_target
expr_stmt|;
comment|// texture dimensions
name|QT_RESET_GLERROR
argument_list|()
expr_stmt|;
comment|// reset error state
name|GLuint
name|fbo
init|=
literal|0
decl_stmt|;
name|funcs
operator|.
name|glGenFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|fbo
argument_list|)
expr_stmt|;
name|GLuint
name|texture
init|=
literal|0
decl_stmt|;
name|GLuint
name|color_buffer
init|=
literal|0
decl_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
comment|// init texture
if|if
condition|(
name|samples
operator|==
literal|0
condition|)
block|{
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glTexImage2D
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mipmap
condition|)
block|{
name|int
name|width
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|width
operator|>
literal|1
operator|||
name|height
operator|>
literal|1
condition|)
block|{
name|width
operator|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|height
operator|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
literal|1
argument_list|)
expr_stmt|;
operator|++
name|level
expr_stmt|;
name|glTexImage2D
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internal_format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|funcs
operator|.
name|glFramebufferTexture2D
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|target
argument_list|,
name|texture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|color_buffer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mipmap
operator|=
literal|false
expr_stmt|;
name|GLint
name|maxSamples
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_MAX_SAMPLES
argument_list|,
operator|&
name|maxSamples
argument_list|)
expr_stmt|;
name|samples
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|int
argument_list|(
name|samples
argument_list|)
argument_list|,
name|int
argument_list|(
name|maxSamples
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
operator|&&
name|samples
operator|>
literal|0
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|samples
operator|=
literal|0
expr_stmt|;
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
name|funcs
operator|.
name|glGetRenderbufferParameteriv
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_RENDERBUFFER_SAMPLES
argument_list|,
operator|&
name|samples
argument_list|)
expr_stmt|;
block|}
name|format
operator|.
name|setTextureTarget
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSamples
argument_list|(
name|int
argument_list|(
name|samples
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|.
name|setInternalTextureFormat
argument_list|(
name|internal_format
argument_list|)
expr_stmt|;
name|format
operator|.
name|setMipmap
argument_list|(
name|mipmap
argument_list|)
expr_stmt|;
name|initAttachments
argument_list|(
name|ctx
argument_list|,
name|attachment
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|fbo_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|fbo
argument_list|,
name|freeFramebufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_buffer
condition|)
name|color_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|color_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
else|else
name|texture_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|texture
argument_list|,
name|freeTextureFunc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|color_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
else|else
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
block|}
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initAttachments
name|void
name|QOpenGLFramebufferObjectPrivate
operator|::
name|initAttachments
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|,
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|int
name|samples
init|=
name|format
operator|.
name|samples
argument_list|()
decl_stmt|;
comment|// free existing attachments
if|if
condition|(
name|depth_buffer_guard
condition|)
block|{
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|depth_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stencil_buffer_guard
condition|)
block|{
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer_guard
operator|!=
name|depth_buffer_guard
condition|)
name|stencil_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
name|depth_buffer_guard
operator|=
literal|0
expr_stmt|;
name|stencil_buffer_guard
operator|=
literal|0
expr_stmt|;
name|GLuint
name|depth_buffer
init|=
literal|0
decl_stmt|;
name|GLuint
name|stencil_buffer
init|=
literal|0
decl_stmt|;
comment|// In practice, a combined depth-stencil buffer is supported by all desktop platforms, while a
comment|// separate stencil buffer is not. On embedded devices however, a combined depth-stencil buffer
comment|// might not be supported while separate buffers are, according to QTBUG-12861.
if|if
condition|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|PackedDepthStencil
argument_list|)
condition|)
block|{
comment|// depth and stencil buffer needs another extension
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
expr_stmt|;
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|depth_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|||
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|Depth
operator|)
operator|)
condition|)
block|{
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|Depth24
argument_list|)
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT24
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|Depth24
argument_list|)
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT24
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stencil_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|)
condition|)
block|{
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|stencil_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// The FBO might have become valid after removing the depth or stencil buffer.
name|valid
operator|=
name|checkFramebufferStatus
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_buffer
operator|&&
name|stencil_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|Depth
expr_stmt|;
block|}
else|else
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|NoAttachment
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
block|{
if|if
condition|(
name|depth_buffer
condition|)
name|depth_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|depth_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
condition|)
block|{
if|if
condition|(
name|stencil_buffer
operator|==
name|depth_buffer
condition|)
name|stencil_buffer_guard
operator|=
name|depth_buffer_guard
expr_stmt|;
else|else
name|stencil_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|stencil_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|depth_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
operator|&&
name|depth_buffer
operator|!=
name|stencil_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
block|}
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|format
operator|.
name|setAttachment
argument_list|(
name|fbo_attachment
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLFramebufferObject     \brief The QOpenGLFramebufferObject class encapsulates an OpenGL framebuffer object.     \since 5.0     \inmodule QtGui      \ingroup painting-3D      The QOpenGLFramebufferObject class encapsulates an OpenGL framebuffer     object, defined by the \c{GL_EXT_framebuffer_object} extension. In     addition it provides a rendering surface that can be painted on     with a QPainter, rendered to using native OpenGL calls, or both. This     surface can be bound and used as a regular texture in your own OpenGL     drawing code.  By default, the QOpenGLFramebufferObject class     generates a 2D OpenGL texture (using the \c{GL_TEXTURE_2D} target),     which is used as the internal rendering target.      \b{It is important to have a current OpenGL context when creating a     QOpenGLFramebufferObject, otherwise initialization will fail.}      When using a QPainter to paint to a QOpenGLFramebufferObject you should take     care that the QOpenGLFramebufferObject is created with the CombinedDepthStencil     attachment for QPainter to be able to render correctly.     Note that you need to create a QOpenGLFramebufferObject with more than one     sample per pixel for primitives to be antialiased when drawing using a     QPainter. To create a multisample framebuffer object you should use one of     the constructors that take a QOpenGLFramebufferObject parameter, and set the     QOpenGLFramebufferObject::samples() property to a non-zero value.      For multisample framebuffer objects a color render buffer is created,     otherwise a texture with the specified texture target is created.     The color render buffer or texture will have the specified internal     format, and will be bound to the \c GL_COLOR_ATTACHMENT0     attachment in the framebuffer object.      If you want to use a framebuffer object with multisampling enabled     as a texture, you first need to copy from it to a regular framebuffer     object using QOpenGLContext::blitFramebuffer().      \section1 Threading      As of Qt 4.8, it's possible to draw into a QOpenGLFramebufferObject     using a QPainter in a separate thread. Note that OpenGL 2.0 or     OpenGL ES 2.0 is required for this to work. */
end_comment
begin_comment
comment|/*!     \enum QOpenGLFramebufferObject::Attachment      This enum type is used to configure the depth and stencil buffers     attached to the framebuffer object when it is created.      \value NoAttachment         No attachment is added to the framebuffer object. Note that the                                 OpenGL depth and stencil tests won't work when rendering to a                                 framebuffer object without any depth or stencil buffers.                                 This is the default value.      \value CombinedDepthStencil If the \c GL_EXT_packed_depth_stencil extension is present,                                 a combined depth and stencil buffer is attached.                                 If the extension is not present, only a depth buffer is attached.      \value Depth                A depth buffer is attached to the framebuffer object.      \sa attachment() */
end_comment
begin_comment
comment|/*! \fn QOpenGLFramebufferObject::QOpenGLFramebufferObject(const QSize&size, GLenum target)      Constructs an OpenGL framebuffer object and binds a 2D OpenGL texture     to the buffer of the size \a size. The texture is bound to the     \c GL_COLOR_ATTACHMENT0 target in the framebuffer object.      The \a target parameter is used to specify the OpenGL texture     target. The default target is \c GL_TEXTURE_2D. Keep in mind that     \c GL_TEXTURE_2D textures must have a power of 2 width and height     (e.g. 256x512), unless you are using OpenGL 2.0 or higher.      By default, no depth and stencil buffers are attached. This behavior     can be toggled using one of the overloaded constructors.      The default internal texture format is \c GL_RGBA8 for desktop     OpenGL, and \c GL_RGBA for OpenGL/ES.      It is important that you have a current OpenGL context set when     creating the QOpenGLFramebufferObject, otherwise the initialization     will fail.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a 2D OpenGL texture     to the buffer of the given \a width and \a height.      \sa size(), texture() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a size based on the     supplied \a format. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a width and \a height     based on the supplied \a format. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a width and \a height.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a size.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QOpenGLFramebufferObject::~QOpenGLFramebufferObject()      Destroys the framebuffer object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|~
name|QOpenGLFramebufferObject
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|texture_guard
condition|)
name|d
operator|->
name|texture_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|color_buffer_guard
condition|)
name|d
operator|->
name|color_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|depth_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stencil_buffer_guard
operator|&&
name|d
operator|->
name|stencil_buffer_guard
operator|!=
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|stencil_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fbo_guard
condition|)
name|d
operator|->
name|fbo_guard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::isValid() const      Returns true if the framebuffer object is valid.      The framebuffer can become invalid if the initialization process     fails, the user attaches an invalid buffer to the framebuffer     object, or a non-power of two width/height is specified as the     texture size if the texture target is \c{GL_TEXTURE_2D}.     The non-power of two limitation does not apply if the OpenGL version     is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension     is present.      The framebuffer can also become invalid if the QOpenGLContext that     the framebuffer was created within is destroyed and there are     no other shared contexts that can take over ownership of the     framebuffer. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLFramebufferObject
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|valid
operator|&&
name|d
operator|->
name|fbo_guard
operator|&&
name|d
operator|->
name|fbo_guard
operator|->
name|id
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::bind()      Switches rendering from the default, windowing system provided     framebuffer to this framebuffer object.     Returns true upon success, false otherwise.      \sa release() */
end_comment
begin_function
DECL|function|bind
name|bool
name|QOpenGLFramebufferObject
operator|::
name|bind
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return
literal|false
return|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|current
operator|->
name|shareGroup
argument_list|()
operator|!=
name|d
operator|->
name|fbo_guard
operator|->
name|group
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::bind() called from incompatible context"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|d
operator|->
name|fbo
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|d
operator|->
name|checkFramebufferStatus
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
operator|&&
name|current
condition|)
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|d
operator|->
name|fbo
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::release()      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind() */
end_comment
begin_function
DECL|function|release
name|bool
name|QOpenGLFramebufferObject
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return
literal|false
return|;
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|current
operator|->
name|shareGroup
argument_list|()
operator|!=
name|d
operator|->
name|fbo_guard
operator|->
name|group
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::release() called from incompatible context"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|current
operator|->
name|defaultFramebufferObject
argument_list|()
expr_stmt|;
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QOpenGLFramebufferObject::texture() const      Returns the texture id for the texture attached as the default     rendering target in this framebuffer object. This texture id can     be bound as a normal texture in your own OpenGL code.      If a multisample framebuffer object is used then the value returned     from this function will be invalid. */
end_comment
begin_function
DECL|function|texture
name|GLuint
name|QOpenGLFramebufferObject
operator|::
name|texture
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|texture_guard
condition|?
name|d
operator|->
name|texture_guard
operator|->
name|id
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QOpenGLFramebufferObject::size() const      Returns the size of the texture attached to this framebuffer     object. */
end_comment
begin_function
DECL|function|size
name|QSize
name|QOpenGLFramebufferObject
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|size
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QOpenGLFramebufferObject::width() const      Returns the width of the framebuffer object attachments. */
end_comment
begin_comment
comment|/*!     \fn int QOpenGLFramebufferObject::height() const      Returns the height of the framebuffer object attachments. */
end_comment
begin_comment
comment|/*!     Returns the format of this framebuffer object. */
end_comment
begin_function
DECL|function|format
name|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObject
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_function
DECL|function|qt_gl_read_framebuffer
name|Q_GUI_EXPORT
name|QImage
name|qt_gl_read_framebuffer
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|size
argument_list|,
operator|(
name|alpha_format
operator|&&
name|include_alpha
operator|)
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|GLint
name|fmt
init|=
name|GL_BGRA_EXT
decl_stmt|;
else|#
directive|else
name|GLint
name|fmt
init|=
name|GL_BGRA
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|glGetError
argument_list|()
condition|)
empty_stmt|;
name|glReadPixels
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|fmt
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|img
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|glGetError
argument_list|()
condition|)
block|{
name|glReadPixels
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|img
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
name|img
operator|=
name|img
operator|.
name|rgbSwapped
argument_list|()
expr_stmt|;
block|}
return|return
name|img
operator|.
name|mirrored
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QOpenGLFramebufferObject::toImage() const      Returns the contents of this framebuffer object as a QImage. */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QOpenGLFramebufferObject
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// qt_gl_read_framebuffer doesn't work on a multisample FBO
if|if
condition|(
name|format
argument_list|()
operator|.
name|samples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QOpenGLFramebufferObject
name|temp
argument_list|(
name|size
argument_list|()
argument_list|,
name|QOpenGLFramebufferObjectFormat
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|rect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|blitFramebuffer
argument_list|(
operator|&
name|temp
argument_list|,
name|rect
argument_list|,
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return
name|temp
operator|.
name|toImage
argument_list|()
return|;
block|}
name|bool
name|wasBound
init|=
name|isBound
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|bind
argument_list|()
expr_stmt|;
name|QImage
name|image
init|=
name|qt_gl_read_framebuffer
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|format
argument_list|()
operator|.
name|internalTextureFormat
argument_list|()
operator|!=
name|GL_RGB
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|release
argument_list|()
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::bindDefault()     \internal      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind(), release() */
end_comment
begin_function
DECL|function|bindDefault
name|bool
name|QOpenGLFramebufferObject
operator|::
name|bindDefault
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
cast|const_cast
argument_list|<
name|QOpenGLContext
operator|*
argument_list|>
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
name|QOpenGLFunctions
name|functions
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|ctx
operator|->
name|defaultFramebufferObject
argument_list|()
expr_stmt|;
name|functions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::bindDefault() called without current context."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ctx
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::hasOpenGLFramebufferObjects()      Returns true if the OpenGL \c{GL_EXT_framebuffer_object} extension     is present on this system; otherwise returns false. */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferObjects
name|bool
name|QOpenGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
parameter_list|()
block|{
return|return
name|QOpenGLFunctions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|.
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|Framebuffers
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QOpenGLFramebufferObject::handle() const      Returns the OpenGL framebuffer object handle for this framebuffer     object (returned by the \c{glGenFrameBuffersEXT()} function). This     handle can be used to attach new images or buffers to the     framebuffer. The user is responsible for cleaning up and     destroying these objects. */
end_comment
begin_function
DECL|function|handle
name|GLuint
name|QOpenGLFramebufferObject
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fbo
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the status of the depth and stencil buffers attached to     this framebuffer object. */
end_comment
begin_function
DECL|function|attachment
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|QOpenGLFramebufferObject
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
condition|)
return|return
name|d
operator|->
name|fbo_attachment
return|;
return|return
name|NoAttachment
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attachments of the framebuffer object to \a attachment.      This can be used to free or reattach the depth and stencil buffer     attachments as needed.  */
end_comment
begin_function
DECL|function|setAttachment
name|void
name|QOpenGLFramebufferObject
operator|::
name|setAttachment
parameter_list|(
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|attachment
operator|==
name|d
operator|->
name|fbo_attachment
operator|||
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|current
operator|->
name|shareGroup
argument_list|()
operator|!=
name|d
operator|->
name|fbo_guard
operator|->
name|group
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::setAttachment() called from incompatible context"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|d
operator|->
name|fbo
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|initAttachments
argument_list|(
name|current
argument_list|,
name|attachment
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|!=
name|d
operator|->
name|fbo
argument_list|()
condition|)
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the framebuffer object is currently bound to a context,     otherwise false is returned. */
end_comment
begin_function
DECL|function|isBound
name|bool
name|QOpenGLFramebufferObject
operator|::
name|isBound
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|==
name|d
operator|->
name|fbo
argument_list|()
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::hasOpenGLFramebufferBlit()      Returns true if the OpenGL \c{GL_EXT_framebuffer_blit} extension     is present on this system; otherwise returns false.      \sa blitFramebuffer() */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferBlit
name|bool
name|QOpenGLFramebufferObject
operator|::
name|hasOpenGLFramebufferBlit
parameter_list|()
block|{
return|return
name|QOpenGLExtensions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferBlit
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Convenience overload to blit between two framebuffer objects. */
end_comment
begin_function
DECL|function|blitFramebuffer
name|void
name|QOpenGLFramebufferObject
operator|::
name|blitFramebuffer
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
name|target
parameter_list|,
name|QOpenGLFramebufferObject
modifier|*
name|source
parameter_list|,
name|GLbitfield
name|buffers
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
operator|&&
operator|!
name|source
condition|)
return|return;
name|QSize
name|targetSize
decl_stmt|;
name|QSize
name|sourceSize
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|targetSize
operator|=
name|target
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|sourceSize
operator|=
name|source
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetSize
operator|.
name|isEmpty
argument_list|()
condition|)
name|targetSize
operator|=
name|sourceSize
expr_stmt|;
elseif|else
if|if
condition|(
name|sourceSize
operator|.
name|isEmpty
argument_list|()
condition|)
name|sourceSize
operator|=
name|targetSize
expr_stmt|;
name|blitFramebuffer
argument_list|(
name|target
argument_list|,
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|targetSize
argument_list|)
argument_list|,
name|source
argument_list|,
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sourceSize
argument_list|)
argument_list|,
name|buffers
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Blits from the \a sourceRect rectangle in the \a source framebuffer     object to the \a targetRect rectangle in the \a target framebuffer object.      If \a source or \a target is 0, the default framebuffer will be used     instead of a framebuffer object as source or target respectively.      The \a buffers parameter should be a mask consisting of any combination of     \c GL_COLOR_BUFFER_BIT, \c GL_DEPTH_BUFFER_BIT, and     \c GL_STENCIL_BUFFER_BIT.  Any buffer type that is not present both     in the source and target buffers is ignored.      The \a sourceRect and \a targetRect rectangles may have different sizes;     in this case \a buffers should not contain \c GL_DEPTH_BUFFER_BIT or     \c GL_STENCIL_BUFFER_BIT. The \a filter parameter should be set to     \c GL_LINEAR or \c GL_NEAREST, and specifies whether linear or nearest     interpolation should be used when scaling is performed.      If \a source equals \a target a copy is performed within the same buffer.     Results are undefined if the source and target rectangles overlap and     have different sizes. The sizes must also be the same if any of the     framebuffer objects are multisample framebuffers.      Note that the scissor test will restrict the blit area if enabled.      This function will have no effect unless hasOpenGLFramebufferBlit() returns     true.      \sa hasOpenGLFramebufferBlit() */
end_comment
begin_function
DECL|function|blitFramebuffer
name|void
name|QOpenGLFramebufferObject
operator|::
name|blitFramebuffer
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
name|target
parameter_list|,
specifier|const
name|QRect
modifier|&
name|targetRect
parameter_list|,
name|QOpenGLFramebufferObject
modifier|*
name|source
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sourceRect
parameter_list|,
name|GLbitfield
name|buffers
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return;
name|QOpenGLExtensions
name|extensions
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extensions
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferBlit
argument_list|)
condition|)
return|return;
specifier|const
name|int
name|sx0
init|=
name|sourceRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sx1
init|=
name|sourceRect
operator|.
name|left
argument_list|()
operator|+
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sy0
init|=
name|sourceRect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sy1
init|=
name|sourceRect
operator|.
name|top
argument_list|()
operator|+
name|sourceRect
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx0
init|=
name|targetRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx1
init|=
name|targetRect
operator|.
name|left
argument_list|()
operator|+
name|targetRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ty0
init|=
name|targetRect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ty1
init|=
name|targetRect
operator|.
name|top
argument_list|()
operator|+
name|targetRect
operator|.
name|height
argument_list|()
decl_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|,
name|source
condition|?
name|source
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_DRAW_FRAMEBUFFER
argument_list|,
name|target
condition|?
name|target
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBlitFramebuffer
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|tx0
argument_list|,
name|ty0
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
name|buffers
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
