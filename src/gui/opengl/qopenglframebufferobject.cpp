begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopenglframebufferobject.h"
end_include
begin_include
include|#
directive|include
file|"qopenglframebufferobject_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<private/qopengl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengineex_opengl2_p.h>
end_include
begin_include
include|#
directive|include
file|<qwindow.h>
end_include
begin_include
include|#
directive|include
file|<qlibrary.h>
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|QOPENGL_FUNC_CONTEXT
define|#
directive|define
name|QOPENGL_FUNC_CONTEXT
value|QOpenGLContext *ctx = QOpenGLContext::currentContext();
DECL|macro|QOPENGL_FUNCP_CONTEXT
define|#
directive|define
name|QOPENGL_FUNCP_CONTEXT
value|QOpenGLContext *ctx = QOpenGLContext::currentContext();
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
DECL|macro|QT_RESET_GLERROR
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
define|\
value|{                                                         \     while (glGetError() != GL_NO_ERROR) {}                \ }
DECL|macro|QT_CHECK_GLERROR
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
define|\
value|{                                                         \     GLenum err = glGetError();                            \     if (err != GL_NO_ERROR) {                             \         qDebug("[%s line %d] GL Error: %d",               \                __FILE__, __LINE__, (int)err);             \     }                                                     \ }
else|#
directive|else
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
value|{}
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
value|{}
endif|#
directive|endif
comment|/*!     \class QOpenGLFramebufferObjectFormat     \brief The QOpenGLFramebufferObjectFormat class specifies the format of an OpenGL     framebuffer object.      \since 4.6      \ingroup painting-3D      A framebuffer object has several characteristics:     \list     \i \link setSamples() Number of samples per pixels.\endlink     \i \link setAttachment() Depth and/or stencil attachments.\endlink     \i \link setTextureTarget() Texture target.\endlink     \i \link setInternalTextureFormat() Internal texture format.\endlink     \endlist      Note that the desired attachments or number of samples per pixels might not     be supported by the hardware driver. Call QOpenGLFramebufferObject::format()     after creating a QOpenGLFramebufferObject to find the exact format that was     used to create the frame buffer object.      \sa QOpenGLFramebufferObject */
comment|/*!     \internal */
DECL|function|detach
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|!=
literal|1
condition|)
block|{
name|QOpenGLFramebufferObjectFormatPrivate
modifier|*
name|newd
init|=
operator|new
name|QOpenGLFramebufferObjectFormatPrivate
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|newd
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Creates a QOpenGLFramebufferObjectFormat object for specifying     the format of an OpenGL framebuffer object.      By default the format specifies a non-multisample framebuffer object with no     attachments, texture target \c GL_TEXTURE_2D, and internal format \c GL_RGBA8.     On OpenGL/ES systems, the default internal format is \c GL_RGBA.      \sa samples(), attachment(), internalTextureFormat() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|QOpenGLFramebufferObjectFormat
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QOpenGLFramebufferObjectFormatPrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|QOpenGLFramebufferObjectFormat
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QOpenGLFramebufferObjectFormat
modifier|&
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QOpenGLFramebufferObjectFormat. */
end_comment
begin_destructor
DECL|function|~QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObjectFormat
operator|::
name|~
name|QOpenGLFramebufferObjectFormat
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the number of samples per pixel for a multisample framebuffer object     to \a samples.  The default sample count of 0 represents a regular     non-multisample framebuffer object.      If the desired amount of samples per pixel is not supported by the hardware     then the maximum number of samples per pixel will be used. Note that     multisample framebuffer objects can not be bound as textures. Also, the     \c{GL_EXT_framebuffer_multisample} extension is required to create a     framebuffer with more than one sample per pixel.      \sa samples() */
end_comment
begin_function
DECL|function|setSamples
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setSamples
parameter_list|(
name|int
name|samples
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|samples
operator|=
name|samples
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of samples per pixel if a framebuffer object     is a multisample framebuffer object. Otherwise, returns 0.     The default value is 0.      \sa setSamples() */
end_comment
begin_function
DECL|function|samples
name|int
name|QOpenGLFramebufferObjectFormat
operator|::
name|samples
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|samples
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Enables mipmapping if \a enabled is true; otherwise disables it.      Mipmapping is disabled by default.      If mipmapping is enabled, additional memory will be allocated for     the mipmap levels. The mipmap levels can be updated by binding the     texture and calling glGenerateMipmap(). Mipmapping cannot be enabled     for multisampled framebuffer objects.      \sa mipmap(), QOpenGLFramebufferObject::texture() */
end_comment
begin_function
DECL|function|setMipmap
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setMipmap
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|mipmap
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns true if mipmapping is enabled.      \sa setMipmap() */
end_comment
begin_function
DECL|function|mipmap
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|mipmap
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|mipmap
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attachment configuration of a framebuffer object to \a attachment.      \sa attachment() */
end_comment
begin_function
DECL|function|setAttachment
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setAttachment
parameter_list|(
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|attachment
operator|=
name|attachment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the configuration of the depth and stencil buffers attached to     a framebuffer object.  The default is QOpenGLFramebufferObject::NoAttachment.      \sa setAttachment() */
end_comment
begin_function
DECL|function|attachment
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|QOpenGLFramebufferObjectFormat
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|attachment
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the texture target of the texture attached to a framebuffer object to     \a target. Ignored for multisample framebuffer objects.      \sa textureTarget(), samples() */
end_comment
begin_function
DECL|function|setTextureTarget
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setTextureTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|target
operator|=
name|target
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the texture target of the texture attached to a framebuffer object.     Ignored for multisample framebuffer objects.  The default is     \c GL_TEXTURE_2D.      \sa setTextureTarget(), samples() */
end_comment
begin_function
DECL|function|textureTarget
name|GLenum
name|QOpenGLFramebufferObjectFormat
operator|::
name|textureTarget
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|target
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer to     \a internalTextureFormat.      \sa internalTextureFormat() */
end_comment
begin_function
DECL|function|setInternalTextureFormat
name|void
name|QOpenGLFramebufferObjectFormat
operator|::
name|setInternalTextureFormat
parameter_list|(
name|GLenum
name|internalTextureFormat
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|internal_format
operator|=
name|internalTextureFormat
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer.  The default is     \c GL_RGBA8 on desktop OpenGL systems, and \c GL_RGBA on     OpenGL/ES systems.      \sa setInternalTextureFormat() */
end_comment
begin_function
DECL|function|internalTextureFormat
name|GLenum
name|QOpenGLFramebufferObjectFormat
operator|::
name|internalTextureFormat
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|internal_format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all the options of this framebuffer object format     are the same as \a other; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
else|else
return|return
name|d
operator|->
name|equals
argument_list|(
name|other
operator|.
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns false if all the options of this framebuffer object format     are the same as \a other; otherwise returns true. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QOpenGLFramebufferObjectFormat
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setFBO
name|void
name|QOpenGLFBOGLPaintDevice
operator|::
name|setFBO
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
name|f
parameter_list|,
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|fbo
operator|=
name|f
expr_stmt|;
name|m_thisFBO
operator|=
name|fbo
operator|->
name|d_func
argument_list|()
operator|->
name|fbo
argument_list|()
expr_stmt|;
comment|// This shouldn't be needed
comment|// The context that the fbo was created in may not have depth
comment|// and stencil buffers, but the fbo itself might.
name|fboFormat
operator|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|format
argument_list|()
expr_stmt|;
if|if
condition|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
condition|)
block|{
name|fboFormat
operator|.
name|setDepthBufferSize
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencilBufferSize
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|Depth
condition|)
block|{
name|fboFormat
operator|.
name|setDepthBufferSize
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencilBufferSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fboFormat
operator|.
name|setDepthBufferSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencilBufferSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|format
init|=
name|f
operator|->
name|format
argument_list|()
operator|.
name|internalTextureFormat
argument_list|()
decl_stmt|;
name|reqAlpha
operator|=
operator|(
name|format
operator|!=
name|GL_RGB
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
operator|&&
name|format
operator|!=
name|GL_RGB5
operator|&&
name|format
operator|!=
name|GL_RGB8
endif|#
directive|endif
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|group
name|QOpenGLContextGroup
modifier|*
name|QOpenGLFBOGLPaintDevice
operator|::
name|group
parameter_list|()
specifier|const
block|{
name|QOpenGLSharedResourceGuard
modifier|*
name|fbo_guard
init|=
name|fbo
operator|->
name|d_func
argument_list|()
operator|->
name|fbo_guard
decl_stmt|;
return|return
name|fbo_guard
condition|?
name|fbo_guard
operator|->
name|group
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|checkFramebufferStatus
name|bool
name|QOpenGLFramebufferObjectPrivate
operator|::
name|checkFramebufferStatus
parameter_list|()
specifier|const
block|{
name|QOPENGL_FUNCP_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
name|GLenum
name|status
init|=
name|QOpenGLFunctions
argument_list|(
name|ctx
argument_list|)
operator|.
name|glCheckFramebufferStatus
argument_list|(
name|GL_FRAMEBUFFER
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|GL_NO_ERROR
case|:
case|case
name|GL_FRAMEBUFFER_COMPLETE
case|:
return|return
literal|true
return|;
break|break;
case|case
name|GL_FRAMEBUFFER_UNSUPPORTED
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Unsupported framebuffer format."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete attachment."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing attachment."
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, duplicate attachment."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attached images must have same dimensions."
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|1
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_FORMATS
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attached images must have same format."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing draw buffer."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, missing read buffer."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
case|:
name|qDebug
argument_list|(
literal|"QOpenGLFramebufferObject: Framebuffer incomplete, attachments must have same number of samples per pixel."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qDebug
argument_list|()
operator|<<
literal|"QOpenGLFramebufferObject: An undefined error has occurred: "
operator|<<
name|status
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|freeFramebufferFunc
name|void
name|freeFramebufferFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeRenderbufferFunc
name|void
name|freeRenderbufferFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeTextureFunc
name|void
name|freeTextureFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_function
DECL|function|init
name|void
name|QOpenGLFramebufferObjectPrivate
operator|::
name|init
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
name|q
parameter_list|,
specifier|const
name|QSize
modifier|&
name|sz
parameter_list|,
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|texture_target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|,
name|GLint
name|samples
parameter_list|,
name|bool
name|mipmap
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
name|funcs
operator|.
name|initializeGLFunctions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|funcs
operator|.
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|Framebuffers
argument_list|)
condition|)
return|return;
name|size
operator|=
name|sz
expr_stmt|;
name|target
operator|=
name|texture_target
expr_stmt|;
comment|// texture dimensions
name|QT_RESET_GLERROR
argument_list|()
expr_stmt|;
comment|// reset error state
name|GLuint
name|fbo
init|=
literal|0
decl_stmt|;
name|funcs
operator|.
name|glGenFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|fbo
argument_list|)
expr_stmt|;
name|GLuint
name|texture
init|=
literal|0
decl_stmt|;
name|GLuint
name|color_buffer
init|=
literal|0
decl_stmt|;
name|GLuint
name|depth_buffer
init|=
literal|0
decl_stmt|;
name|GLuint
name|stencil_buffer
init|=
literal|0
decl_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
comment|// init texture
if|if
condition|(
name|samples
operator|==
literal|0
condition|)
block|{
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
name|glTexImage2D
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mipmap
condition|)
name|funcs
operator|.
name|glGenerateMipmap
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
else|#
directive|else
name|glTexParameterf
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|funcs
operator|.
name|glFramebufferTexture2D
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|target
argument_list|,
name|texture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|color_buffer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mipmap
operator|=
literal|false
expr_stmt|;
name|GLint
name|maxSamples
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_MAX_SAMPLES
argument_list|,
operator|&
name|maxSamples
argument_list|)
expr_stmt|;
name|samples
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|int
argument_list|(
name|samples
argument_list|)
argument_list|,
name|int
argument_list|(
name|maxSamples
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
operator|&&
name|samples
operator|>
literal|0
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|samples
operator|=
literal|0
expr_stmt|;
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|valid
condition|)
name|funcs
operator|.
name|glGetRenderbufferParameteriv
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_RENDERBUFFER_SAMPLES
argument_list|,
operator|&
name|samples
argument_list|)
expr_stmt|;
block|}
comment|// In practice, a combined depth-stencil buffer is supported by all desktop platforms, while a
comment|// separate stencil buffer is not. On embedded devices however, a combined depth-stencil buffer
comment|// might not be supported while separate buffers are, according to QTBUG-12861.
if|if
condition|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|PackedDepthStencil
argument_list|)
condition|)
block|{
comment|// depth and stencil buffer needs another extension
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
expr_stmt|;
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|depth_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|||
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|Depth
operator|)
operator|)
condition|)
block|{
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|Depth24
argument_list|)
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT24
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|Depth24
argument_list|)
condition|)
block|{
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT24
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stencil_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|)
condition|)
block|{
name|funcs
operator|.
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|stencil_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|funcs
operator|.
name|glIsRenderbuffer
argument_list|(
name|stencil_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|funcs
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorageMultisample
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|funcs
operator|.
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|funcs
operator|.
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// The FBO might have become valid after removing the depth or stencil buffer.
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth_buffer
operator|&&
name|stencil_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|Depth
expr_stmt|;
block|}
else|else
block|{
name|fbo_attachment
operator|=
name|QOpenGLFramebufferObject
operator|::
name|NoAttachment
expr_stmt|;
block|}
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|fbo_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|fbo
argument_list|,
name|freeFramebufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_buffer
condition|)
name|color_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|color_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
else|else
name|texture_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|texture
argument_list|,
name|freeTextureFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_buffer
condition|)
name|depth_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|depth_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
condition|)
block|{
if|if
condition|(
name|stencil_buffer
operator|==
name|depth_buffer
condition|)
name|stencil_buffer_guard
operator|=
name|depth_buffer_guard
expr_stmt|;
else|else
name|stencil_buffer_guard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|stencil_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|color_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
else|else
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
operator|&&
name|depth_buffer
operator|!=
name|stencil_buffer
condition|)
name|funcs
operator|.
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|funcs
operator|.
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
block|}
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|format
operator|.
name|setTextureTarget
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSamples
argument_list|(
name|int
argument_list|(
name|samples
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|.
name|setAttachment
argument_list|(
name|fbo_attachment
argument_list|)
expr_stmt|;
name|format
operator|.
name|setInternalTextureFormat
argument_list|(
name|internal_format
argument_list|)
expr_stmt|;
name|format
operator|.
name|setMipmap
argument_list|(
name|mipmap
argument_list|)
expr_stmt|;
name|glDevice
operator|.
name|setFBO
argument_list|(
name|q
argument_list|,
name|attachment
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLFramebufferObject     \brief The QOpenGLFramebufferObject class encapsulates an OpenGL framebuffer object.     \since 4.2      \ingroup painting-3D      The QOpenGLFramebufferObject class encapsulates an OpenGL framebuffer     object, defined by the \c{GL_EXT_framebuffer_object} extension. In     addition it provides a rendering surface that can be painted on     with a QPainter, rendered to using native GL calls, or both. This     surface can be bound and used as a regular texture in your own GL     drawing code.  By default, the QOpenGLFramebufferObject class     generates a 2D GL texture (using the \c{GL_TEXTURE_2D} target),     which is used as the internal rendering target.      \bold{It is important to have a current GL context when creating a     QOpenGLFramebufferObject, otherwise initialization will fail.}      OpenGL framebuffer objects and pbuffers (see     \l{QOpenGLPixelBuffer}{QOpenGLPixelBuffer}) can both be used to render to     offscreen surfaces, but there are a number of advantages with     using framebuffer objects instead of pbuffers:      \list 1     \o A framebuffer object does not require a separate rendering     context, so no context switching will occur when switching     rendering targets. There is an overhead involved in switching     targets, but in general it is cheaper than a context switch to a     pbuffer.      \o Rendering to dynamic textures (i.e. render-to-texture     functionality) works on all platforms. No need to do explicit copy     calls from a render buffer into a texture, as was necessary on     systems that did not support the \c{render_texture} extension.      \o It is possible to attach several rendering buffers (or texture     objects) to the same framebuffer object, and render to all of them     without doing a context switch.      \o The OpenGL framebuffer extension is a pure GL extension with no     system dependant WGL, CGL, or GLX parts. This makes using     framebuffer objects more portable.     \endlist      When using a QPainter to paint to a QOpenGLFramebufferObject you should take     care that the QOpenGLFramebufferObject is created with the CombinedDepthStencil     attachment for QPainter to be able to render correctly.     Note that you need to create a QOpenGLFramebufferObject with more than one     sample per pixel for primitives to be antialiased when drawing using a     QPainter. To create a multisample framebuffer object you should use one of     the constructors that take a QOpenGLFramebufferObject parameter, and set the     QOpenGLFramebufferObject::samples() property to a non-zero value.      When painting to a QOpenGLFramebufferObject using QPainter, the state of     the current GL context will be altered by the paint engine to reflect     its needs.  Applications should not rely upon the GL state being reset     to its original conditions, particularly the current shader program,     GL viewport, texture units, and drawing modes.      For multisample framebuffer objects a color render buffer is created,     otherwise a texture with the specified texture target is created.     The color render buffer or texture will have the specified internal     format, and will be bound to the \c GL_COLOR_ATTACHMENT0     attachment in the framebuffer object.      If you want to use a framebuffer object with multisampling enabled     as a texture, you first need to copy from it to a regular framebuffer     object using QOpenGLContext::blitFramebuffer().      \section1 Threading      As of Qt 4.8, it's possible to draw into a QOpenGLFramebufferObject     using a QPainter in a separate thread. Note that OpenGL 2.0 or     OpenGL ES 2.0 is required for this to work.      \sa {Framebuffer Object Example} */
end_comment
begin_comment
comment|/*!     \enum QOpenGLFramebufferObject::Attachment     \since 4.3      This enum type is used to configure the depth and stencil buffers     attached to the framebuffer object when it is created.      \value NoAttachment         No attachment is added to the framebuffer object. Note that the                                 OpenGL depth and stencil tests won't work when rendering to a                                 framebuffer object without any depth or stencil buffers.                                 This is the default value.      \value CombinedDepthStencil If the \c GL_EXT_packed_depth_stencil extension is present,                                 a combined depth and stencil buffer is attached.                                 If the extension is not present, only a depth buffer is attached.      \value Depth                A depth buffer is attached to the framebuffer object.      \sa attachment() */
end_comment
begin_comment
comment|/*! \fn QOpenGLFramebufferObject::QOpenGLFramebufferObject(const QSize&size, GLenum target)      Constructs an OpenGL framebuffer object and binds a 2D GL texture     to the buffer of the size \a size. The texture is bound to the     \c GL_COLOR_ATTACHMENT0 target in the framebuffer object.      The \a target parameter is used to specify the GL texture     target. The default target is \c GL_TEXTURE_2D. Keep in mind that     \c GL_TEXTURE_2D textures must have a power of 2 width and height     (e.g. 256x512), unless you are using OpenGL 2.0 or higher.      By default, no depth and stencil buffers are attached. This behavior     can be toggled using one of the overloaded constructors.      The default internal texture format is \c GL_RGBA8 for desktop     OpenGL, and \c GL_RGBA for OpenGL/ES.      It is important that you have a current GL context set when     creating the QOpenGLFramebufferObject, otherwise the initialization     will fail.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a 2D GL texture     to the buffer of the given \a width and \a height.      \sa size(), texture() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a size based on the     supplied \a format. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a width and \a height     based on the supplied \a format. */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
specifier|const
name|QOpenGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a width and \a height.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a size.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|QOpenGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QOpenGLFramebufferObject::~QOpenGLFramebufferObject()      Destroys the framebuffer object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QOpenGLFramebufferObject
name|QOpenGLFramebufferObject
operator|::
name|~
name|QOpenGLFramebufferObject
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|engine
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|texture_guard
condition|)
name|d
operator|->
name|texture_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|color_buffer_guard
condition|)
name|d
operator|->
name|color_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|depth_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stencil_buffer_guard
operator|&&
name|d
operator|->
name|stencil_buffer_guard
operator|!=
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|stencil_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fbo_guard
condition|)
name|d
operator|->
name|fbo_guard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::isValid() const      Returns true if the framebuffer object is valid.      The framebuffer can become invalid if the initialization process     fails, the user attaches an invalid buffer to the framebuffer     object, or a non-power of two width/height is specified as the     texture size if the texture target is \c{GL_TEXTURE_2D}.     The non-power of two limitation does not apply if the OpenGL version     is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension     is present.      The framebuffer can also become invalid if the QOpenGLContext that     the framebuffer was created within is destroyed and there are     no other shared contexts that can take over ownership of the     framebuffer. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLFramebufferObject
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|valid
operator|&&
name|d
operator|->
name|fbo_guard
operator|&&
name|d
operator|->
name|fbo_guard
operator|->
name|id
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::bind()      Switches rendering from the default, windowing system provided     framebuffer to this framebuffer object.     Returns true upon success, false otherwise.      \sa release() */
end_comment
begin_function
DECL|function|bind
name|bool
name|QOpenGLFramebufferObject
operator|::
name|bind
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|QOPENGL_FUNC_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
operator|!
name|current
operator|||
name|current
operator|->
name|shareGroup
argument_list|()
operator|!=
name|d
operator|->
name|fbo_guard
operator|->
name|group
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::bind() called from incompatible context"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|d
operator|->
name|fbo
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|d
operator|->
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
operator|&&
name|current
condition|)
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|d
operator|->
name|fbo
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::release()      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind() */
end_comment
begin_function
DECL|function|release
name|bool
name|QOpenGLFramebufferObject
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QOPENGL_FUNC_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
name|Q_D
argument_list|(
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|||
name|current
operator|->
name|shareGroup
argument_list|()
operator|!=
name|d
operator|->
name|fbo_guard
operator|->
name|group
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::release() called from incompatible context"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|default_fbo
expr_stmt|;
name|d
operator|->
name|funcs
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|default_fbo
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QOpenGLFramebufferObject::texture() const      Returns the texture id for the texture attached as the default     rendering target in this framebuffer object. This texture id can     be bound as a normal texture in your own GL code.      If a multisample framebuffer object is used then the value returned     from this function will be invalid. */
end_comment
begin_function
DECL|function|texture
name|GLuint
name|QOpenGLFramebufferObject
operator|::
name|texture
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|texture_guard
condition|?
name|d
operator|->
name|texture_guard
operator|->
name|id
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QOpenGLFramebufferObject::size() const      Returns the size of the texture attached to this framebuffer     object. */
end_comment
begin_function
DECL|function|size
name|QSize
name|QOpenGLFramebufferObject
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|size
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of this framebuffer object. */
end_comment
begin_function
DECL|function|format
name|QOpenGLFramebufferObjectFormat
name|QOpenGLFramebufferObject
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
comment|/*    Read back the contents of the currently bound framebuffer, used in    QGLWidget::grabFrameBuffer(), QGLPixelbuffer::toImage() and    QGLFramebufferObject::toImage() */
DECL|function|convertFromGLImage
name|void
name|convertFromGLImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
comment|// OpenGL gives RGBA; Qt wants ARGB
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|bits
argument_list|()
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|w
operator|*
name|h
decl_stmt|;
if|if
condition|(
name|alpha_format
operator|&&
name|include_alpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|a
init|=
operator|*
name|p
operator|<<
literal|24
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator||
name|a
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is an old legacy fix for PowerPC based Macs, which
comment|// we shouldn't remove
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
literal|0xff000000
operator||
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// OpenGL gives ABGR (i.e. RGBA backwards); Qt wants ARGB
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|uint
name|pixel
init|=
operator|*
name|q
decl_stmt|;
if|if
condition|(
name|alpha_format
operator|&&
name|include_alpha
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
name|pixel
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|pixel
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|=
literal|0xff000000
operator||
operator|(
operator|(
name|pixel
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|pixel
operator|&
literal|0x00ff00
operator|)
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
block|}
name|img
operator|=
name|img
operator|.
name|mirrored
argument_list|()
expr_stmt|;
block|}
block|}
end_namespace
begin_function
DECL|function|qt_gl_read_framebuffer
name|Q_GUI_EXPORT
name|QImage
name|qt_gl_read_framebuffer
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|size
argument_list|,
operator|(
name|alpha_format
operator|&&
name|include_alpha
operator|)
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|glReadPixels
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|img
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
name|convertFromGLImage
argument_list|(
name|img
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alpha_format
argument_list|,
name|include_alpha
argument_list|)
expr_stmt|;
return|return
name|img
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QOpenGLFramebufferObject::toImage() const      Returns the contents of this framebuffer object as a QImage. */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QOpenGLFramebufferObject
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// qt_gl_read_framebuffer doesn't work on a multisample FBO
if|if
condition|(
name|format
argument_list|()
operator|.
name|samples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QOpenGLFramebufferObject
name|temp
argument_list|(
name|size
argument_list|()
argument_list|,
name|QOpenGLFramebufferObjectFormat
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|rect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|blitFramebuffer
argument_list|(
operator|&
name|temp
argument_list|,
name|rect
argument_list|,
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return
name|temp
operator|.
name|toImage
argument_list|()
return|;
block|}
name|bool
name|wasBound
init|=
name|isBound
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|bind
argument_list|()
expr_stmt|;
name|QImage
name|image
init|=
name|qt_gl_read_framebuffer
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|format
argument_list|()
operator|.
name|internalTextureFormat
argument_list|()
operator|!=
name|GL_RGB
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QOpenGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|release
argument_list|()
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QOpenGLEngineThreadStorage<QOpenGL2PaintEngineEx>
argument_list|,
argument|qt_buffer_2_engine
argument_list|)
end_macro
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QOpenGLFramebufferObject
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
condition|)
return|return
name|d
operator|->
name|engine
return|;
name|QPaintEngine
modifier|*
name|engine
init|=
name|qt_buffer_2_engine
argument_list|()
operator|->
name|engine
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|isActive
argument_list|()
operator|&&
name|engine
operator|->
name|paintDevice
argument_list|()
operator|!=
name|this
condition|)
block|{
name|d
operator|->
name|engine
operator|=
operator|new
name|QOpenGL2PaintEngineEx
expr_stmt|;
return|return
name|d
operator|->
name|engine
return|;
block|}
return|return
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::bindDefault()     \internal      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind(), release() */
end_comment
begin_function
DECL|function|bindDefault
name|bool
name|QOpenGLFramebufferObject
operator|::
name|bindDefault
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
cast|const_cast
argument_list|<
name|QOpenGLContext
operator|*
argument_list|>
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
name|QOpenGLFunctions
name|functions
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|default_fbo
expr_stmt|;
name|functions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|default_fbo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::bindDefault() called without current context."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ctx
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::hasOpenGLFramebufferObjects()      Returns true if the OpenGL \c{GL_EXT_framebuffer_object} extension     is present on this system; otherwise returns false. */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferObjects
name|bool
name|QOpenGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
parameter_list|()
block|{
return|return
name|QOpenGLFunctions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|.
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|Framebuffers
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|metric
name|int
name|QOpenGLFramebufferObject
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|float
name|dpmx
init|=
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
name|float
name|dpmy
init|=
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
name|int
name|w
init|=
name|d
operator|->
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmWidth
case|:
return|return
name|w
return|;
case|case
name|PdmHeight
case|:
return|return
name|h
return|;
case|case
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|w
operator|*
literal|1000
operator|/
name|dpmx
argument_list|)
return|;
case|case
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|h
operator|*
literal|1000
operator|/
name|dpmy
argument_list|)
return|;
case|case
name|PdmNumColors
case|:
return|return
literal|0
return|;
case|case
name|PdmDepth
case|:
return|return
literal|32
return|;
comment|//d->depth;
case|case
name|PdmDpiX
case|:
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmDpiY
case|:
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiX
case|:
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiY
case|:
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
default|default:
name|qWarning
argument_list|(
literal|"QOpenGLFramebufferObject::metric(), Unhandled metric type: %d.\n"
argument_list|,
name|metric
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QOpenGLFramebufferObject::handle() const      Returns the GL framebuffer object handle for this framebuffer     object (returned by the \c{glGenFrameBuffersEXT()} function). This     handle can be used to attach new images or buffers to the     framebuffer. The user is responsible for cleaning up and     destroying these objects. */
end_comment
begin_function
DECL|function|handle
name|GLuint
name|QOpenGLFramebufferObject
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fbo
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QOpenGLFramebufferObject::devType() const     \internal */
end_comment
begin_comment
comment|/*!     Returns the status of the depth and stencil buffers attached to     this framebuffer object. */
end_comment
begin_function
DECL|function|attachment
name|QOpenGLFramebufferObject
operator|::
name|Attachment
name|QOpenGLFramebufferObject
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
condition|)
return|return
name|d
operator|->
name|fbo_attachment
return|;
return|return
name|NoAttachment
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns true if the framebuffer object is currently bound to a context,     otherwise false is returned. */
end_comment
begin_function
DECL|function|isBound
name|bool
name|QOpenGLFramebufferObject
operator|::
name|isBound
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLFramebufferObject
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|current
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
operator|==
name|d
operator|->
name|fbo
argument_list|()
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QOpenGLFramebufferObject::hasOpenGLFramebufferBlit()      \since 4.6      Returns true if the OpenGL \c{GL_EXT_framebuffer_blit} extension     is present on this system; otherwise returns false.      \sa blitFramebuffer() */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferBlit
name|bool
name|QOpenGLFramebufferObject
operator|::
name|hasOpenGLFramebufferBlit
parameter_list|()
block|{
return|return
name|QOpenGLExtensions
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferBlit
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Blits from the \a sourceRect rectangle in the \a source framebuffer     object to the \a targetRect rectangle in the \a target framebuffer object.      If \a source or \a target is 0, the default framebuffer will be used     instead of a framebuffer object as source or target respectively.      The \a buffers parameter should be a mask consisting of any combination of     \c GL_COLOR_BUFFER_BIT, \c GL_DEPTH_BUFFER_BIT, and     \c GL_STENCIL_BUFFER_BIT.  Any buffer type that is not present both     in the source and target buffers is ignored.      The \a sourceRect and \a targetRect rectangles may have different sizes;     in this case \a buffers should not contain \c GL_DEPTH_BUFFER_BIT or     \c GL_STENCIL_BUFFER_BIT. The \a filter parameter should be set to     \c GL_LINEAR or \c GL_NEAREST, and specifies whether linear or nearest     interpolation should be used when scaling is performed.      If \a source equals \a target a copy is performed within the same buffer.     Results are undefined if the source and target rectangles overlap and     have different sizes. The sizes must also be the same if any of the     framebuffer objects are multisample framebuffers.      Note that the scissor test will restrict the blit area if enabled.      This function will have no effect unless hasOpenGLFramebufferBlit() returns     true.      \sa hasOpenGLFramebufferBlit() */
end_comment
begin_function
DECL|function|blitFramebuffer
name|void
name|QOpenGLFramebufferObject
operator|::
name|blitFramebuffer
parameter_list|(
name|QOpenGLFramebufferObject
modifier|*
name|target
parameter_list|,
specifier|const
name|QRect
modifier|&
name|targetRect
parameter_list|,
name|QOpenGLFramebufferObject
modifier|*
name|source
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sourceRect
parameter_list|,
name|GLbitfield
name|buffers
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return;
name|QOpenGLExtensions
name|extensions
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extensions
operator|.
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferBlit
argument_list|)
condition|)
return|return;
name|QSurface
modifier|*
name|surface
init|=
name|ctx
operator|->
name|surface
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sh
init|=
name|source
condition|?
name|source
operator|->
name|height
argument_list|()
else|:
name|height
decl_stmt|;
specifier|const
name|int
name|th
init|=
name|target
condition|?
name|target
operator|->
name|height
argument_list|()
else|:
name|height
decl_stmt|;
specifier|const
name|int
name|sx0
init|=
name|sourceRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sx1
init|=
name|sourceRect
operator|.
name|left
argument_list|()
operator|+
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sy0
init|=
name|sh
operator|-
operator|(
name|sourceRect
operator|.
name|top
argument_list|()
operator|+
name|sourceRect
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|int
name|sy1
init|=
name|sh
operator|-
name|sourceRect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx0
init|=
name|targetRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx1
init|=
name|targetRect
operator|.
name|left
argument_list|()
operator|+
name|targetRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ty0
init|=
name|th
operator|-
operator|(
name|targetRect
operator|.
name|top
argument_list|()
operator|+
name|targetRect
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|int
name|ty1
init|=
name|th
operator|-
name|targetRect
operator|.
name|top
argument_list|()
decl_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|,
name|source
condition|?
name|source
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_DRAW_FRAMEBUFFER
argument_list|,
name|target
condition|?
name|target
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBlitFramebuffer
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|tx0
argument_list|,
name|ty0
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
name|buffers
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|extensions
operator|.
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
