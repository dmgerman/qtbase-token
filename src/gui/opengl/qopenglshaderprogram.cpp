begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopenglshaderprogram.h"
end_include
begin_include
include|#
directive|include
file|"qopenglfunctions.h"
end_include
begin_include
include|#
directive|include
file|"private/qopenglcontext_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvector.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qtransform.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QColor>
end_include
begin_include
include|#
directive|include
file|<QtGui/QSurfaceFormat>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtGui/qopenglfunctions_4_0_core.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QOpenGLShaderProgram     \brief The QOpenGLShaderProgram class allows OpenGL shader programs to be linked and used.     \since 5.0     \ingroup painting-3D     \inmodule QtGui      \section1 Introduction      This class supports shader programs written in the OpenGL Shading     Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).      QOpenGLShader and QOpenGLShaderProgram shelter the programmer from the details of     compiling and linking vertex and fragment shaders.      The following example creates a vertex shader program using the     supplied source \c{code}.  Once compiled and linked, the shader     program is activated in the current QOpenGLContext by calling     QOpenGLShaderProgram::bind():      \snippet code/src_gui_qopenglshaderprogram.cpp 0      \section1 Writing portable shaders      Shader programs can be difficult to reuse across OpenGL implementations     because of varying levels of support for standard vertex attributes and     uniform variables.  In particular, GLSL/ES lacks all of the     standard variables that are present on desktop OpenGL systems:     \c{gl_Vertex}, \c{gl_Normal}, \c{gl_Color}, and so on.  Desktop OpenGL     lacks the variable qualifiers \c{highp}, \c{mediump}, and \c{lowp}.      The QOpenGLShaderProgram class makes the process of writing portable shaders     easier by prefixing all shader programs with the following lines on     desktop OpenGL:      \code     #define highp     #define mediump     #define lowp     \endcode      This makes it possible to run most GLSL/ES shader programs     on desktop systems.  The programmer should restrict themselves     to just features that are present in GLSL/ES, and avoid     standard variable names that only work on the desktop.      \section1 Simple shader example      \snippet code/src_gui_qopenglshaderprogram.cpp 1      With the above shader program active, we can draw a green triangle     as follows:      \snippet code/src_gui_qopenglshaderprogram.cpp 2      \section1 Binary shaders and programs      Binary shaders may be specified using \c{glShaderBinary()} on     the return value from QOpenGLShader::shaderId().  The QOpenGLShader instance     containing the binary can then be added to the shader program with     addShader() and linked in the usual fashion with link().      Binary programs may be specified using \c{glProgramBinaryOES()}     on the return value from programId().  Then the application should     call link(), which will notice that the program has already been     specified and linked, allowing other operations to be performed     on the shader program.      \sa QOpenGLShader */
end_comment
begin_comment
comment|/*!     \class QOpenGLShader     \brief The QOpenGLShader class allows OpenGL shaders to be compiled.     \since 5.0     \ingroup painting-3D     \inmodule QtGui      This class supports shaders written in the OpenGL Shading Language (GLSL)     and in the OpenGL/ES Shading Language (GLSL/ES).      QOpenGLShader and QOpenGLShaderProgram shelter the programmer from the details of     compiling and linking vertex and fragment shaders.      \sa QOpenGLShaderProgram */
end_comment
begin_comment
comment|/*!     \enum QOpenGLShader::ShaderTypeBit     This enum specifies the type of QOpenGLShader that is being created.      \value Vertex Vertex shader written in the OpenGL Shading Language (GLSL).     \value Fragment Fragment shader written in the OpenGL Shading Language (GLSL).     \value Geometry Geometry shaders written in the OpenGL Shading Language (GLSL)            based on the OpenGL core feature (requires OpenGL>= 3.2).     \value TessellationControl Tessellation control shaders written in the OpenGL            shading language (GLSL), based on the core feature (requires OpenGL>= 4.0).     \value TessellationEvaluation Tessellation evaluation shaders written in the OpenGL            shading language (GLSL), based on the core feature (requires OpenGL>= 4.0).     \value Compute Compute shaders written in the OpenGL shading language (GLSL),            based on the core feature (requires OpenGL>= 4.3). */
end_comment
begin_class
DECL|class|QOpenGLShaderPrivate
class|class
name|QOpenGLShaderPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QOpenGLShader
parameter_list|)
specifier|public
private|:
DECL|function|QOpenGLShaderPrivate
name|QOpenGLShaderPrivate
parameter_list|(
name|QOpenGLContext
modifier|*
name|ctx
parameter_list|,
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|)
member_init_list|:
name|shaderGuard
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|shaderType
argument_list|(
name|type
argument_list|)
member_init_list|,
name|compiled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|glfuncs
argument_list|(
operator|new
name|QOpenGLFunctions
argument_list|(
name|ctx
argument_list|)
argument_list|)
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
member_init_list|,
name|supportsGeometryShaders
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|supportsTessellationShaders
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
name|QSurfaceFormat
name|f
init|=
name|ctx
operator|->
name|format
argument_list|()
decl_stmt|;
comment|// Geometry shaders require OpenGL>= 3.2
if|if
condition|(
name|shaderType
operator|&
name|QOpenGLShader
operator|::
name|Geometry
condition|)
name|supportsGeometryShaders
operator|=
operator|(
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shaderType
operator|&
operator|(
name|QOpenGLShader
operator|::
name|TessellationControl
operator||
name|QOpenGLShader
operator|::
name|TessellationEvaluation
operator|)
condition|)
name|supportsTessellationShaders
operator|=
operator|(
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|~
name|QOpenGLShaderPrivate
parameter_list|()
destructor_decl|;
DECL|member|shaderGuard
name|QOpenGLSharedResourceGuard
modifier|*
name|shaderGuard
decl_stmt|;
DECL|member|shaderType
name|QOpenGLShader
operator|::
name|ShaderType
name|shaderType
decl_stmt|;
DECL|member|compiled
name|bool
name|compiled
decl_stmt|;
DECL|member|log
name|QString
name|log
decl_stmt|;
DECL|member|glfuncs
name|QOpenGLFunctions
modifier|*
name|glfuncs
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
comment|// Support for geometry shaders
DECL|member|supportsGeometryShaders
name|bool
name|supportsGeometryShaders
decl_stmt|;
comment|// Support for tessellation shaders
DECL|member|supportsTessellationShaders
name|bool
name|supportsTessellationShaders
decl_stmt|;
endif|#
directive|endif
name|bool
name|create
parameter_list|()
function_decl|;
name|bool
name|compile
parameter_list|(
name|QOpenGLShader
modifier|*
name|q
parameter_list|)
function_decl|;
name|void
name|deleteShader
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_namespace
namespace|namespace
block|{
DECL|function|freeShaderFunc
name|void
name|freeShaderFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteShader
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_destructor
DECL|function|~QOpenGLShaderPrivate
name|QOpenGLShaderPrivate
operator|::
name|~
name|QOpenGLShaderPrivate
parameter_list|()
block|{
operator|delete
name|glfuncs
expr_stmt|;
if|if
condition|(
name|shaderGuard
condition|)
name|shaderGuard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|create
name|bool
name|QOpenGLShaderPrivate
operator|::
name|create
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|context
init|=
cast|const_cast
argument_list|<
name|QOpenGLContext
operator|*
argument_list|>
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
literal|false
return|;
name|GLuint
name|shader
decl_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Vertex
condition|)
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_VERTEX_SHADER
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_3_2
argument_list|)
block|}
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Geometry
operator|&&
name|supportsGeometryShaders
condition|)
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_GEOMETRY_SHADER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
block|}
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|TessellationControl
operator|&&
name|supportsTessellationShaders
condition|)
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_TESS_CONTROL_SHADER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|TessellationEvaluation
operator|&&
name|supportsTessellationShaders
condition|)
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_TESS_EVALUATION_SHADER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4_3
argument_list|)
block|}
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Compute
condition|)
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_COMPUTE_SHADER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|shader
operator|=
name|glfuncs
operator|->
name|glCreateShader
argument_list|(
name|GL_FRAGMENT_SHADER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shader
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShader: could not create shader"
expr_stmt|;
return|return
literal|false
return|;
block|}
name|shaderGuard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|context
argument_list|,
name|shader
argument_list|,
name|freeShaderFunc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|compile
name|bool
name|QOpenGLShaderPrivate
operator|::
name|compile
parameter_list|(
name|QOpenGLShader
modifier|*
name|q
parameter_list|)
block|{
name|GLuint
name|shader
init|=
name|shaderGuard
condition|?
name|shaderGuard
operator|->
name|id
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|shader
condition|)
return|return
literal|false
return|;
comment|// Try to compile shader
name|glfuncs
operator|->
name|glCompileShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
name|GLint
name|value
init|=
literal|0
decl_stmt|;
comment|// Get compilation status
name|glfuncs
operator|->
name|glGetShaderiv
argument_list|(
name|shader
argument_list|,
name|GL_COMPILE_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|compiled
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiled
condition|)
block|{
comment|// Compilation failed, try to provide some information about the failure
name|QString
name|name
init|=
name|q
operator|->
name|objectName
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"Fragment"
block|,
literal|"Vertex"
block|,
literal|"Geometry"
block|,
literal|""
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|types
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Fragment
condition|)
name|type
operator|=
name|types
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Vertex
condition|)
name|type
operator|=
name|types
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|shaderType
operator|==
name|QOpenGLShader
operator|::
name|Geometry
condition|)
name|type
operator|=
name|types
index|[
literal|2
index|]
expr_stmt|;
comment|// Get info and source code lengths
name|GLint
name|infoLogLength
init|=
literal|0
decl_stmt|;
name|GLint
name|sourceCodeLength
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|logBuffer
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sourceCodeBuffer
init|=
literal|0
decl_stmt|;
comment|// Get the compilation info log
name|glfuncs
operator|->
name|glGetShaderiv
argument_list|(
name|shader
argument_list|,
name|GL_INFO_LOG_LENGTH
argument_list|,
operator|&
name|infoLogLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoLogLength
operator|>
literal|1
condition|)
block|{
name|GLint
name|temp
decl_stmt|;
name|logBuffer
operator|=
operator|new
name|char
index|[
name|infoLogLength
index|]
expr_stmt|;
name|glfuncs
operator|->
name|glGetShaderInfoLog
argument_list|(
name|shader
argument_list|,
name|infoLogLength
argument_list|,
operator|&
name|temp
argument_list|,
name|logBuffer
argument_list|)
expr_stmt|;
block|}
comment|// Get the source code
name|glfuncs
operator|->
name|glGetShaderiv
argument_list|(
name|shader
argument_list|,
name|GL_SHADER_SOURCE_LENGTH
argument_list|,
operator|&
name|sourceCodeLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceCodeLength
operator|>
literal|1
condition|)
block|{
name|GLint
name|temp
decl_stmt|;
name|sourceCodeBuffer
operator|=
operator|new
name|char
index|[
name|sourceCodeLength
index|]
expr_stmt|;
name|glfuncs
operator|->
name|glGetShaderSource
argument_list|(
name|shader
argument_list|,
name|sourceCodeLength
argument_list|,
operator|&
name|temp
argument_list|,
name|sourceCodeBuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logBuffer
condition|)
name|log
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|logBuffer
argument_list|)
expr_stmt|;
else|else
name|log
operator|=
name|QLatin1String
argument_list|(
literal|"failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLShader::compile(%s): %s"
argument_list|,
name|type
argument_list|,
name|qPrintable
argument_list|(
name|log
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QOpenGLShader::compile(%s)[%s]: %s"
argument_list|,
name|type
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|log
argument_list|)
argument_list|)
expr_stmt|;
comment|// Dump the source code if we got it
if|if
condition|(
name|sourceCodeBuffer
condition|)
block|{
name|qWarning
argument_list|(
literal|"*** Problematic %s shader source code ***"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|sourceCodeBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"***"
argument_list|)
expr_stmt|;
block|}
comment|// Cleanup
operator|delete
index|[]
name|logBuffer
expr_stmt|;
operator|delete
index|[]
name|sourceCodeBuffer
expr_stmt|;
block|}
return|return
name|compiled
return|;
block|}
end_function
begin_function
DECL|function|deleteShader
name|void
name|QOpenGLShaderPrivate
operator|::
name|deleteShader
parameter_list|()
block|{
if|if
condition|(
name|shaderGuard
condition|)
block|{
name|shaderGuard
operator|->
name|free
argument_list|()
expr_stmt|;
name|shaderGuard
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a new QOpenGLShader object of the specified \a type     and attaches it to \a parent.  If shader programs are not supported,     QOpenGLShaderProgram::hasOpenGLShaderPrograms() will return false.      This constructor is normally followed by a call to compileSourceCode()     or compileSourceFile().      The shader will be associated with the current QOpenGLContext.      \sa compileSourceCode(), compileSourceFile() */
end_comment
begin_constructor
DECL|function|QOpenGLShader
name|QOpenGLShader
operator|::
name|QOpenGLShader
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLShaderPrivate
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShader
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Deletes this shader.  If the shader has been attached to a     QOpenGLShaderProgram object, then the actual shader will stay around     until the QOpenGLShaderProgram is destroyed. */
end_comment
begin_destructor
DECL|function|~QOpenGLShader
name|QOpenGLShader
operator|::
name|~
name|QOpenGLShader
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the type of this shader. */
end_comment
begin_function
DECL|function|shaderType
name|QOpenGLShader
operator|::
name|ShaderType
name|QOpenGLShader
operator|::
name|shaderType
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shaderType
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|qualifierDefines
specifier|static
specifier|const
name|char
name|qualifierDefines
index|[]
init|=
literal|"#define lowp\n"
literal|"#define mediump\n"
literal|"#define highp\n"
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_OPENGL_FORCE_SHADER_DEFINES
argument_list|)
end_if
begin_comment
comment|// The "highp" qualifier doesn't exist in fragment shaders
end_comment
begin_comment
comment|// on all ES platforms.  When it doesn't exist, use "mediump".
end_comment
begin_define
DECL|macro|QOpenGL_REDEFINE_HIGHP
define|#
directive|define
name|QOpenGL_REDEFINE_HIGHP
value|1
end_define
begin_decl_stmt
DECL|variable|redefineHighp
specifier|static
specifier|const
name|char
name|redefineHighp
index|[]
init|=
literal|"#ifndef GL_FRAGMENT_PRECISION_HIGH\n"
literal|"#define highp mediump\n"
literal|"#endif\n"
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Sets the \a source code for this shader and compiles it.     Returns true if the source was successfully compiled, false otherwise.      \sa compileSourceFile() */
end_comment
begin_function
DECL|function|compileSourceCode
name|bool
name|QOpenGLShader
operator|::
name|compileSourceCode
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shaderGuard
operator|&&
name|d
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
condition|)
block|{
name|QVarLengthArray
argument_list|<
specifier|const
name|char
modifier|*
argument_list|,
literal|4
argument_list|>
name|src
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|GLint
argument_list|,
literal|4
argument_list|>
name|srclen
decl_stmt|;
name|int
name|headerLen
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|source
operator|&&
name|source
index|[
name|headerLen
index|]
operator|==
literal|'#'
condition|)
block|{
comment|// Skip #version and #extension directives at the start of
comment|// the shader code.  We need to insert the qualifierDefines
comment|// and redefineHighp just after them.
if|if
condition|(
name|qstrncmp
argument_list|(
name|source
operator|+
name|headerLen
argument_list|,
literal|"#version"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
operator|&&
name|qstrncmp
argument_list|(
name|source
operator|+
name|headerLen
argument_list|,
literal|"#extension"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
while|while
condition|(
name|source
index|[
name|headerLen
index|]
operator|!=
literal|'\0'
operator|&&
name|source
index|[
name|headerLen
index|]
operator|!=
literal|'\n'
condition|)
operator|++
name|headerLen
expr_stmt|;
if|if
condition|(
name|source
index|[
name|headerLen
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|headerLen
expr_stmt|;
block|}
if|if
condition|(
name|headerLen
operator|>
literal|0
condition|)
block|{
name|src
operator|.
name|append
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|srclen
operator|.
name|append
argument_list|(
name|GLint
argument_list|(
name|headerLen
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// The precision qualifiers are useful on OpenGL/ES systems,
comment|// but usually not present on desktop systems.
specifier|const
name|QSurfaceFormat
name|currentSurfaceFormat
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentSurfaceFormat
operator|.
name|renderableType
argument_list|()
operator|==
name|QSurfaceFormat
operator|::
name|OpenGL
ifdef|#
directive|ifdef
name|QT_OPENGL_FORCE_SHADER_DEFINES
operator|||
literal|true
endif|#
directive|endif
condition|)
block|{
name|src
operator|.
name|append
argument_list|(
name|qualifierDefines
argument_list|)
expr_stmt|;
name|srclen
operator|.
name|append
argument_list|(
name|GLint
argument_list|(
sizeof|sizeof
argument_list|(
name|qualifierDefines
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QOpenGL_REDEFINE_HIGHP
if|if
condition|(
name|d
operator|->
name|shaderType
operator|==
name|Fragment
condition|)
block|{
name|src
operator|.
name|append
argument_list|(
name|redefineHighp
argument_list|)
expr_stmt|;
name|srclen
operator|.
name|append
argument_list|(
name|GLint
argument_list|(
sizeof|sizeof
argument_list|(
name|redefineHighp
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|src
operator|.
name|append
argument_list|(
name|source
operator|+
name|headerLen
argument_list|)
expr_stmt|;
name|srclen
operator|.
name|append
argument_list|(
name|GLint
argument_list|(
name|qstrlen
argument_list|(
name|source
operator|+
name|headerLen
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glShaderSource
argument_list|(
name|d
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
argument_list|,
name|src
operator|.
name|size
argument_list|()
argument_list|,
name|src
operator|.
name|data
argument_list|()
argument_list|,
name|srclen
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|compile
argument_list|(
name|this
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the \a source code for this shader and compiles it.     Returns true if the source was successfully compiled, false otherwise.      \sa compileSourceFile() */
end_comment
begin_function
DECL|function|compileSourceCode
name|bool
name|QOpenGLShader
operator|::
name|compileSourceCode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|source
parameter_list|)
block|{
return|return
name|compileSourceCode
argument_list|(
name|source
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the \a source code for this shader and compiles it.     Returns true if the source was successfully compiled, false otherwise.      \sa compileSourceFile() */
end_comment
begin_function
DECL|function|compileSourceCode
name|bool
name|QOpenGLShader
operator|::
name|compileSourceCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|source
parameter_list|)
block|{
return|return
name|compileSourceCode
argument_list|(
name|source
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the source code for this shader to the contents of \a fileName     and compiles it.  Returns true if the file could be opened and the     source compiled, false otherwise.      \sa compileSourceCode() */
end_comment
begin_function
DECL|function|compileSourceFile
name|bool
name|QOpenGLShader
operator|::
name|compileSourceFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShader: Unable to open file"
operator|<<
name|fileName
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QByteArray
name|contents
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
return|return
name|compileSourceCode
argument_list|(
name|contents
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the source code for this shader.      \sa compileSourceCode() */
end_comment
begin_function
DECL|function|sourceCode
name|QByteArray
name|QOpenGLShader
operator|::
name|sourceCode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShader
argument_list|)
expr_stmt|;
name|GLuint
name|shader
init|=
name|d
operator|->
name|shaderGuard
condition|?
name|d
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|shader
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|GLint
name|size
init|=
literal|0
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetShaderiv
argument_list|(
name|shader
argument_list|,
name|GL_SHADER_SOURCE_LENGTH
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|GLint
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|source
init|=
operator|new
name|char
index|[
name|size
index|]
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetShaderSource
argument_list|(
name|shader
argument_list|,
name|size
argument_list|,
operator|&
name|len
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|QByteArray
name|src
argument_list|(
name|source
argument_list|)
decl_stmt|;
operator|delete
index|[]
name|source
expr_stmt|;
return|return
name|src
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this shader has been compiled; false otherwise.      \sa compileSourceCode(), compileSourceFile() */
end_comment
begin_function
DECL|function|isCompiled
name|bool
name|QOpenGLShader
operator|::
name|isCompiled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|compiled
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the errors and warnings that occurred during the last compile.      \sa compileSourceCode(), compileSourceFile() */
end_comment
begin_function
DECL|function|log
name|QString
name|QOpenGLShader
operator|::
name|log
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|log
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the OpenGL identifier associated with this shader.      \sa QOpenGLShaderProgram::programId() */
end_comment
begin_function
DECL|function|shaderId
name|GLuint
name|QOpenGLShader
operator|::
name|shaderId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shaderGuard
condition|?
name|d
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_class
DECL|class|QOpenGLShaderProgramPrivate
class|class
name|QOpenGLShaderProgramPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QOpenGLShaderProgram
parameter_list|)
specifier|public
private|:
DECL|function|QOpenGLShaderProgramPrivate
name|QOpenGLShaderProgramPrivate
parameter_list|()
member_init_list|:
name|programGuard
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|linked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inited
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|removingShaders
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|glfuncs
argument_list|(
operator|new
name|QOpenGLFunctions
argument_list|)
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
member_init_list|,
name|tessellationFuncs
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{     }
name|~
name|QOpenGLShaderProgramPrivate
parameter_list|()
destructor_decl|;
DECL|member|programGuard
name|QOpenGLSharedResourceGuard
modifier|*
name|programGuard
decl_stmt|;
DECL|member|linked
name|bool
name|linked
decl_stmt|;
DECL|member|inited
name|bool
name|inited
decl_stmt|;
DECL|member|removingShaders
name|bool
name|removingShaders
decl_stmt|;
DECL|member|log
name|QString
name|log
decl_stmt|;
DECL|member|shaders
name|QList
argument_list|<
name|QOpenGLShader
modifier|*
argument_list|>
name|shaders
decl_stmt|;
DECL|member|anonShaders
name|QList
argument_list|<
name|QOpenGLShader
modifier|*
argument_list|>
name|anonShaders
decl_stmt|;
DECL|member|glfuncs
name|QOpenGLFunctions
modifier|*
name|glfuncs
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
comment|// Tessellation shader support
DECL|member|tessellationFuncs
name|QOpenGLFunctions_4_0_Core
modifier|*
name|tessellationFuncs
decl_stmt|;
endif|#
directive|endif
name|bool
name|hasShader
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_namespace
namespace|namespace
block|{
DECL|function|freeProgramFunc
name|void
name|freeProgramFunc
parameter_list|(
name|QOpenGLFunctions
modifier|*
name|funcs
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|funcs
operator|->
name|glDeleteProgram
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_destructor
DECL|function|~QOpenGLShaderProgramPrivate
name|QOpenGLShaderProgramPrivate
operator|::
name|~
name|QOpenGLShaderProgramPrivate
parameter_list|()
block|{
operator|delete
name|glfuncs
expr_stmt|;
if|if
condition|(
name|programGuard
condition|)
name|programGuard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|hasShader
name|bool
name|QOpenGLShaderProgramPrivate
operator|::
name|hasShader
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|QOpenGLShader
modifier|*
name|shader
decl|,
name|shaders
control|)
block|{
if|if
condition|(
name|shader
operator|->
name|shaderType
argument_list|()
operator|==
name|type
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a new shader program and attaches it to \a parent.     The program will be invalid until addShader() is called.      The shader program will be associated with the current QOpenGLContext.      \sa addShader() */
end_comment
begin_constructor
DECL|function|QOpenGLShaderProgram
name|QOpenGLShaderProgram
operator|::
name|QOpenGLShaderProgram
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLShaderProgramPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Deletes this shader program. */
end_comment
begin_destructor
DECL|function|~QOpenGLShaderProgram
name|QOpenGLShaderProgram
operator|::
name|~
name|QOpenGLShaderProgram
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|init
name|bool
name|QOpenGLShaderProgram
operator|::
name|init
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
operator|)
operator|||
name|d
operator|->
name|inited
condition|)
return|return
literal|true
return|;
name|d
operator|->
name|inited
operator|=
literal|true
expr_stmt|;
name|QOpenGLContext
modifier|*
name|context
init|=
cast|const_cast
argument_list|<
name|QOpenGLContext
operator|*
argument_list|>
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|glfuncs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
comment|// Resolve OpenGL 4 functions for tessellation shader support
name|QSurfaceFormat
name|format
init|=
name|context
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|d
operator|->
name|tessellationFuncs
operator|=
name|context
operator|->
name|versionFunctions
argument_list|<
name|QOpenGLFunctions_4_0_Core
argument_list|>
argument_list|()
expr_stmt|;
name|d
operator|->
name|tessellationFuncs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|GLuint
name|program
init|=
name|d
operator|->
name|glfuncs
operator|->
name|glCreateProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShaderProgram: could not create shader program"
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|programGuard
condition|)
operator|delete
name|d
operator|->
name|programGuard
expr_stmt|;
name|d
operator|->
name|programGuard
operator|=
operator|new
name|QOpenGLSharedResourceGuard
argument_list|(
name|context
argument_list|,
name|program
argument_list|,
name|freeProgramFunc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Adds a compiled \a shader to this shader program.  Returns true     if the shader could be added, or false otherwise.      Ownership of the \a shader object remains with the caller.     It will not be deleted when this QOpenGLShaderProgram instance     is deleted.  This allows the caller to add the same shader     to multiple shader programs.      \sa addShaderFromSourceCode(), addShaderFromSourceFile()     \sa removeShader(), link(), removeAllShaders() */
end_comment
begin_function
DECL|function|addShader
name|bool
name|QOpenGLShaderProgram
operator|::
name|addShader
parameter_list|(
name|QOpenGLShader
modifier|*
name|shader
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|shaders
operator|.
name|contains
argument_list|(
name|shader
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// Already added to this shader program.
if|if
condition|(
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
operator|&&
name|shader
condition|)
block|{
if|if
condition|(
operator|!
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|||
operator|!
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|programGuard
operator|->
name|group
argument_list|()
operator|!=
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|->
name|group
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLShaderProgram::addShader: Program and shader are not associated with same context."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|glfuncs
operator|->
name|glAttachShader
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|linked
operator|=
literal|false
expr_stmt|;
comment|// Program needs to be relinked.
name|d
operator|->
name|shaders
operator|.
name|append
argument_list|(
name|shader
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|shader
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|shaderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Compiles \a source as a shader of the specified \a type and     adds it to this shader program.  Returns true if compilation     was successful, false otherwise.  The compilation errors     and warnings will be made available via log().      This function is intended to be a short-cut for quickly     adding vertex and fragment shaders to a shader program without     creating an instance of QOpenGLShader first.      \sa addShader(), addShaderFromSourceFile()     \sa removeShader(), link(), log(), removeAllShaders() */
end_comment
begin_function
DECL|function|addShaderFromSourceCode
name|bool
name|QOpenGLShaderProgram
operator|::
name|addShaderFromSourceCode
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
argument_list|()
condition|)
return|return
literal|false
return|;
name|QOpenGLShader
modifier|*
name|shader
init|=
operator|new
name|QOpenGLShader
argument_list|(
name|type
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shader
operator|->
name|compileSourceCode
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|d
operator|->
name|log
operator|=
name|shader
operator|->
name|log
argument_list|()
expr_stmt|;
operator|delete
name|shader
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|anonShaders
operator|.
name|append
argument_list|(
name|shader
argument_list|)
expr_stmt|;
return|return
name|addShader
argument_list|(
name|shader
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Compiles \a source as a shader of the specified \a type and     adds it to this shader program.  Returns true if compilation     was successful, false otherwise.  The compilation errors     and warnings will be made available via log().      This function is intended to be a short-cut for quickly     adding vertex and fragment shaders to a shader program without     creating an instance of QOpenGLShader first.      \sa addShader(), addShaderFromSourceFile()     \sa removeShader(), link(), log(), removeAllShaders() */
end_comment
begin_function
DECL|function|addShaderFromSourceCode
name|bool
name|QOpenGLShaderProgram
operator|::
name|addShaderFromSourceCode
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|source
parameter_list|)
block|{
return|return
name|addShaderFromSourceCode
argument_list|(
name|type
argument_list|,
name|source
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Compiles \a source as a shader of the specified \a type and     adds it to this shader program.  Returns true if compilation     was successful, false otherwise.  The compilation errors     and warnings will be made available via log().      This function is intended to be a short-cut for quickly     adding vertex and fragment shaders to a shader program without     creating an instance of QOpenGLShader first.      \sa addShader(), addShaderFromSourceFile()     \sa removeShader(), link(), log(), removeAllShaders() */
end_comment
begin_function
DECL|function|addShaderFromSourceCode
name|bool
name|QOpenGLShaderProgram
operator|::
name|addShaderFromSourceCode
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|)
block|{
return|return
name|addShaderFromSourceCode
argument_list|(
name|type
argument_list|,
name|source
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Compiles the contents of \a fileName as a shader of the specified     \a type and adds it to this shader program.  Returns true if     compilation was successful, false otherwise.  The compilation errors     and warnings will be made available via log().      This function is intended to be a short-cut for quickly     adding vertex and fragment shaders to a shader program without     creating an instance of QOpenGLShader first.      \sa addShader(), addShaderFromSourceCode() */
end_comment
begin_function
DECL|function|addShaderFromSourceFile
name|bool
name|QOpenGLShaderProgram
operator|::
name|addShaderFromSourceFile
parameter_list|(
name|QOpenGLShader
operator|::
name|ShaderType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
argument_list|()
condition|)
return|return
literal|false
return|;
name|QOpenGLShader
modifier|*
name|shader
init|=
operator|new
name|QOpenGLShader
argument_list|(
name|type
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shader
operator|->
name|compileSourceFile
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|d
operator|->
name|log
operator|=
name|shader
operator|->
name|log
argument_list|()
expr_stmt|;
operator|delete
name|shader
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|anonShaders
operator|.
name|append
argument_list|(
name|shader
argument_list|)
expr_stmt|;
return|return
name|addShader
argument_list|(
name|shader
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a shader from this shader program.  The object is not deleted.      The shader program must be valid in the current QOpenGLContext.      \sa addShader(), link(), removeAllShaders() */
end_comment
begin_function
DECL|function|removeShader
name|void
name|QOpenGLShaderProgram
operator|::
name|removeShader
parameter_list|(
name|QOpenGLShader
modifier|*
name|shader
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
operator|&&
name|shader
operator|&&
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glDetachShader
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|linked
operator|=
literal|false
expr_stmt|;
comment|// Program needs to be relinked.
if|if
condition|(
name|shader
condition|)
block|{
name|d
operator|->
name|shaders
operator|.
name|removeAll
argument_list|(
name|shader
argument_list|)
expr_stmt|;
name|d
operator|->
name|anonShaders
operator|.
name|removeAll
argument_list|(
name|shader
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|shader
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|shaderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of all shaders that have been added to this shader     program using addShader().      \sa addShader(), removeShader() */
end_comment
begin_function
DECL|function|shaders
name|QList
argument_list|<
name|QOpenGLShader
modifier|*
argument_list|>
name|QOpenGLShaderProgram
operator|::
name|shaders
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shaders
return|;
block|}
end_function
begin_comment
comment|/*!     Removes all of the shaders that were added to this program previously.     The QOpenGLShader objects for the shaders will not be deleted if they     were constructed externally.  QOpenGLShader objects that are constructed     internally by QOpenGLShaderProgram will be deleted.      \sa addShader(), removeShader() */
end_comment
begin_function
DECL|function|removeAllShaders
name|void
name|QOpenGLShaderProgram
operator|::
name|removeAllShaders
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|d
operator|->
name|removingShaders
operator|=
literal|true
expr_stmt|;
foreach|foreach
control|(
name|QOpenGLShader
modifier|*
name|shader
decl|,
name|d
operator|->
name|shaders
control|)
block|{
if|if
condition|(
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
operator|&&
name|shader
operator|&&
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glDetachShader
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|shader
operator|->
name|d_func
argument_list|()
operator|->
name|shaderGuard
operator|->
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
foreach|foreach
control|(
name|QOpenGLShader
modifier|*
name|shader
decl|,
name|d
operator|->
name|anonShaders
control|)
block|{
comment|// Delete shader objects that were created anonymously.
operator|delete
name|shader
expr_stmt|;
block|}
name|d
operator|->
name|shaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|anonShaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|linked
operator|=
literal|false
expr_stmt|;
comment|// Program needs to be relinked.
name|d
operator|->
name|removingShaders
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Links together the shaders that were added to this program with     addShader().  Returns true if the link was successful or     false otherwise.  If the link failed, the error messages can     be retrieved with log().      Subclasses can override this function to initialize attributes     and uniform variables for use in specific shader programs.      If the shader program was already linked, calling this     function again will force it to be re-linked.      \sa addShader(), log() */
end_comment
begin_function
DECL|function|link
name|bool
name|QOpenGLShaderProgram
operator|::
name|link
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|GLuint
name|program
init|=
name|d
operator|->
name|programGuard
condition|?
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
return|return
literal|false
return|;
name|GLint
name|value
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|shaders
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there are no explicit shaders, then it is possible that the
comment|// application added a program binary with glProgramBinaryOES(),
comment|// or otherwise populated the shaders itself.  Check to see if the
comment|// program is already linked and bail out if so.
name|value
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetProgramiv
argument_list|(
name|program
argument_list|,
name|GL_LINK_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|d
operator|->
name|linked
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|linked
condition|)
return|return
literal|true
return|;
block|}
name|d
operator|->
name|glfuncs
operator|->
name|glLinkProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetProgramiv
argument_list|(
name|program
argument_list|,
name|GL_LINK_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|d
operator|->
name|linked
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetProgramiv
argument_list|(
name|program
argument_list|,
name|GL_INFO_LOG_LENGTH
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|d
operator|->
name|log
operator|=
name|QString
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|logbuf
init|=
operator|new
name|char
index|[
name|value
index|]
decl_stmt|;
name|GLint
name|len
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glGetProgramInfoLog
argument_list|(
name|program
argument_list|,
name|value
argument_list|,
operator|&
name|len
argument_list|,
name|logbuf
argument_list|)
expr_stmt|;
name|d
operator|->
name|log
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|logbuf
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|objectName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShader::link:"
operator|<<
name|d
operator|->
name|log
expr_stmt|;
else|else
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShader::link["
operator|<<
name|name
operator|<<
literal|"]:"
operator|<<
name|d
operator|->
name|log
expr_stmt|;
operator|delete
index|[]
name|logbuf
expr_stmt|;
block|}
return|return
name|d
operator|->
name|linked
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this shader program has been linked; false otherwise.      \sa link() */
end_comment
begin_function
DECL|function|isLinked
name|bool
name|QOpenGLShaderProgram
operator|::
name|isLinked
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|linked
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the errors and warnings that occurred during the last link()     or addShader() with explicitly specified source code.      \sa link() */
end_comment
begin_function
DECL|function|log
name|QString
name|QOpenGLShaderProgram
operator|::
name|log
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|log
return|;
block|}
end_function
begin_comment
comment|/*!     Binds this shader program to the active QOpenGLContext and makes     it the current shader program.  Any previously bound shader program     is released.  This is equivalent to calling \c{glUseProgram()} on     programId().  Returns true if the program was successfully bound;     false otherwise.  If the shader program has not yet been linked,     or it needs to be re-linked, this function will call link().      \sa link(), release() */
end_comment
begin_function
DECL|function|bind
name|bool
name|QOpenGLShaderProgram
operator|::
name|bind
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|GLuint
name|program
init|=
name|d
operator|->
name|programGuard
condition|?
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|program
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|linked
operator|&&
operator|!
name|link
argument_list|()
condition|)
return|return
literal|false
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|d
operator|->
name|programGuard
operator|->
name|group
argument_list|()
operator|!=
name|QOpenGLContextGroup
operator|::
name|currentContextGroup
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLShaderProgram::bind: program is not valid in the current context."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
name|d
operator|->
name|glfuncs
operator|->
name|glUseProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Releases the active shader program from the current QOpenGLContext.     This is equivalent to calling \c{glUseProgram(0)}.      \sa bind() */
end_comment
begin_function
DECL|function|release
name|void
name|QOpenGLShaderProgram
operator|::
name|release
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|group
argument_list|()
operator|!=
name|QOpenGLContextGroup
operator|::
name|currentContextGroup
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLShaderProgram::release: program is not valid in the current context."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|glfuncs
operator|->
name|glUseProgram
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the OpenGL identifier associated with this shader program.      \sa QOpenGLShader::shaderId() */
end_comment
begin_function
DECL|function|programId
name|GLuint
name|QOpenGLShaderProgram
operator|::
name|programId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|GLuint
name|id
init|=
name|d
operator|->
name|programGuard
condition|?
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|id
condition|)
return|return
name|id
return|;
comment|// Create the identifier if we don't have one yet.  This is for
comment|// applications that want to create the attached shader configuration
comment|// themselves, particularly those using program binaries.
if|if
condition|(
operator|!
cast|const_cast
argument_list|<
name|QOpenGLShaderProgram
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|init
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|programGuard
condition|?
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Binds the attribute \a name to the specified \a location.  This     function can be called before or after the program has been linked.     Any attributes that have not been explicitly bound when the program     is linked will be assigned locations automatically.      When this function is called after the program has been linked,     the program will need to be relinked for the change to take effect.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|bindAttributeLocation
name|void
name|QOpenGLShaderProgram
operator|::
name|bindAttributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
argument_list|()
operator|||
operator|!
name|d
operator|->
name|programGuard
operator|||
operator|!
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
condition|)
return|return;
name|d
operator|->
name|glfuncs
operator|->
name|glBindAttribLocation
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|location
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|linked
operator|=
literal|false
expr_stmt|;
comment|// Program needs to be relinked.
block|}
end_function
begin_comment
comment|/*!     \overload      Binds the attribute \a name to the specified \a location.  This     function can be called before or after the program has been linked.     Any attributes that have not been explicitly bound when the program     is linked will be assigned locations automatically.      When this function is called after the program has been linked,     the program will need to be relinked for the change to take effect.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|bindAttributeLocation
name|void
name|QOpenGLShaderProgram
operator|::
name|bindAttributeLocation
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|bindAttributeLocation
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Binds the attribute \a name to the specified \a location.  This     function can be called before or after the program has been linked.     Any attributes that have not been explicitly bound when the program     is linked will be assigned locations automatically.      When this function is called after the program has been linked,     the program will need to be relinked for the change to take effect.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|bindAttributeLocation
name|void
name|QOpenGLShaderProgram
operator|::
name|bindAttributeLocation
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|bindAttributeLocation
argument_list|(
name|name
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the location of the attribute \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     attribute for this shader program.      \sa uniformLocation(), bindAttributeLocation() */
end_comment
begin_function
DECL|function|attributeLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|attributeLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|linked
operator|&&
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
condition|)
block|{
return|return
name|d
operator|->
name|glfuncs
operator|->
name|glGetAttribLocation
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShaderProgram::attributeLocation("
operator|<<
name|name
operator|<<
literal|"): shader program is not linked"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the location of the attribute \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     attribute for this shader program.      \sa uniformLocation(), bindAttributeLocation() */
end_comment
begin_function
DECL|function|attributeLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|attributeLocation
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|attributeLocation
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the location of the attribute \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     attribute for this shader program.      \sa uniformLocation(), bindAttributeLocation() */
end_comment
begin_function
DECL|function|attributeLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|attributeLocation
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|attributeLocation
argument_list|(
name|name
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib1fv
argument_list|(
name|location
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|value
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to     the 2D vector (\a x, \a y).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|2
index|]
init|=
block|{
name|x
block|,
name|y
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib2fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to     the 2D vector (\a x, \a y).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to     the 3D vector (\a x, \a y, \a z).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|3
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib3fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to     the 3D vector (\a x, \a y, \a z).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to     the 4D vector (\a x, \a y, \a z, \a w).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
name|w
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib4fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to     the 4D vector (\a x, \a y, \a z, \a w).      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib2fv
argument_list|(
name|location
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|value
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib3fv
argument_list|(
name|location
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|value
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector4D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib4fv
argument_list|(
name|location
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector4D
modifier|&
name|value
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QColor
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|value
operator|.
name|redF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|value
operator|.
name|greenF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|value
operator|.
name|blueF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|value.alphaF()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib4fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to \a value.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QColor
modifier|&
name|value
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute at \a location in the current context to the     contents of \a values, which contains \a columns elements, each     consisting of \a rows elements.  The \a rows value should be     1, 2, 3, or 4.  This function is typically used to set matrix     values and column vectors.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|columns
parameter_list|,
name|int
name|rows
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
argument_list|<
literal|1
operator|||
name|rows
argument_list|>
literal|4
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShaderProgram::setAttributeValue: rows"
operator|<<
name|rows
operator|<<
literal|"not supported"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|columns
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rows
operator|==
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib1fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rows
operator|==
literal|2
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib2fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rows
operator|==
literal|3
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib3fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttrib4fv
argument_list|(
name|location
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|values
operator|+=
name|rows
expr_stmt|;
operator|++
name|location
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the attribute called \a name in the current context to the     contents of \a values, which contains \a columns elements, each     consisting of \a rows elements.  The \a rows value should be     1, 2, 3, or 4.  This function is typically used to set matrix     values and column vectors.      \sa setUniformValue() */
end_comment
begin_function
DECL|function|setAttributeValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|columns
parameter_list|,
name|int
name|rows
parameter_list|)
block|{
name|setAttributeValue
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|columns
argument_list|,
name|rows
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets an array of vertex \a values on the attribute at \a location     in this shader program.  The \a tupleSize indicates the number of     components per vertex (1, 2, 3, or 4), and the \a stride indicates     the number of bytes between vertices.  A default \a stride value     of zero indicates that the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
name|tupleSize
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
name|stride
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets an array of 2D vertex \a values on the attribute at \a location     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector2D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
name|stride
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets an array of 3D vertex \a values on the attribute at \a location     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector3D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
literal|3
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
name|stride
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets an array of 4D vertex \a values on the attribute at \a location     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector4D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
literal|4
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
name|stride
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets an array of vertex \a values on the attribute at \a location     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The \a type indicates the type of elements in the \a values array,     usually \c{GL_FLOAT}, \c{GL_UNSIGNED_BYTE}, etc.  The \a tupleSize     indicates the number of components per vertex: 1, 2, 3, or 4.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      The setAttributeBuffer() function can be used to set the attribute     array to an offset within a vertex buffer.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray(), setAttributeBuffer() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
name|int
name|location
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|values
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
name|tupleSize
argument_list|,
name|type
argument_list|,
name|GL_TRUE
argument_list|,
name|stride
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of vertex \a values on the attribute called \a name     in this shader program.  The \a tupleSize indicates the number of     components per vertex (1, 2, 3, or 4), and the \a stride indicates     the number of bytes between vertices.  A default \a stride value     of zero indicates that the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on \a name.  Otherwise the value specified with setAttributeValue()     for \a name will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|tupleSize
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of 2D vertex \a values on the attribute called \a name     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on \a name.  Otherwise the value specified with setAttributeValue()     for \a name will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector2D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of 3D vertex \a values on the attribute called \a name     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on \a name.  Otherwise the value specified with setAttributeValue()     for \a name will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector3D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of 4D vertex \a values on the attribute called \a name     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The array will become active when enableAttributeArray() is called     on \a name.  Otherwise the value specified with setAttributeValue()     for \a name will be used.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector4D
modifier|*
name|values
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of vertex \a values on the attribute called \a name     in this shader program.  The \a stride indicates the number of bytes     between vertices.  A default \a stride value of zero indicates that     the vertices are densely packed in \a values.      The \a type indicates the type of elements in the \a values array,     usually \c{GL_FLOAT}, \c{GL_UNSIGNED_BYTE}, etc.  The \a tupleSize     indicates the number of components per vertex: 1, 2, 3, or 4.      The array will become active when enableAttributeArray() is called     on the \a name.  Otherwise the value specified with     setAttributeValue() for \a name will be used.      The setAttributeBuffer() function can be used to set the attribute     array to an offset within a vertex buffer.      \sa setAttributeValue(), setUniformValue(), enableAttributeArray()     \sa disableAttributeArray(), setAttributeBuffer() */
end_comment
begin_function
DECL|function|setAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|values
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|,
name|values
argument_list|,
name|tupleSize
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets an array of vertex values on the attribute at \a location in     this shader program, starting at a specific \a offset in the     currently bound vertex buffer.  The \a stride indicates the number     of bytes between vertices.  A default \a stride value of zero     indicates that the vertices are densely packed in the value array.      The \a type indicates the type of elements in the vertex value     array, usually \c{GL_FLOAT}, \c{GL_UNSIGNED_BYTE}, etc.  The \a     tupleSize indicates the number of components per vertex: 1, 2, 3,     or 4.      The array will become active when enableAttributeArray() is called     on the \a location.  Otherwise the value specified with     setAttributeValue() for \a location will be used.      \sa setAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeBuffer
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeBuffer
parameter_list|(
name|int
name|location
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|glfuncs
operator|->
name|glVertexAttribPointer
argument_list|(
name|location
argument_list|,
name|tupleSize
argument_list|,
name|type
argument_list|,
name|GL_TRUE
argument_list|,
name|stride
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets an array of vertex values on the attribute called \a name     in this shader program, starting at a specific \a offset in the     currently bound vertex buffer.  The \a stride indicates the number     of bytes between vertices.  A default \a stride value of zero     indicates that the vertices are densely packed in the value array.      The \a type indicates the type of elements in the vertex value     array, usually \c{GL_FLOAT}, \c{GL_UNSIGNED_BYTE}, etc.  The \a     tupleSize indicates the number of components per vertex: 1, 2, 3,     or 4.      The array will become active when enableAttributeArray() is called     on the \a name.  Otherwise the value specified with     setAttributeValue() for \a name will be used.      \sa setAttributeArray() */
end_comment
begin_function
DECL|function|setAttributeBuffer
name|void
name|QOpenGLShaderProgram
operator|::
name|setAttributeBuffer
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|tupleSize
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
name|setAttributeBuffer
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|,
name|offset
argument_list|,
name|tupleSize
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Enables the vertex array at \a location in this shader program     so that the value set by setAttributeArray() on \a location     will be used by the shader program.      \sa disableAttributeArray(), setAttributeArray(), setAttributeValue()     \sa setUniformValue() */
end_comment
begin_function
DECL|function|enableAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|enableAttributeArray
parameter_list|(
name|int
name|location
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glEnableVertexAttribArray
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Enables the vertex array called \a name in this shader program     so that the value set by setAttributeArray() on \a name     will be used by the shader program.      \sa disableAttributeArray(), setAttributeArray(), setAttributeValue()     \sa setUniformValue() */
end_comment
begin_function
DECL|function|enableAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|enableAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enableAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Disables the vertex array at \a location in this shader program     that was enabled by a previous call to enableAttributeArray().      \sa enableAttributeArray(), setAttributeArray(), setAttributeValue()     \sa setUniformValue() */
end_comment
begin_function
DECL|function|disableAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|disableAttributeArray
parameter_list|(
name|int
name|location
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glDisableVertexAttribArray
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Disables the vertex array called \a name in this shader program     that was enabled by a previous call to enableAttributeArray().      \sa enableAttributeArray(), setAttributeArray(), setAttributeValue()     \sa setUniformValue() */
end_comment
begin_function
DECL|function|disableAttributeArray
name|void
name|QOpenGLShaderProgram
operator|::
name|disableAttributeArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|disableAttributeArray
argument_list|(
name|attributeLocation
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the location of the uniform variable \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     uniform variable for this shader program.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|uniformLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|uniformLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|linked
operator|&&
name|d
operator|->
name|programGuard
operator|&&
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
condition|)
block|{
return|return
name|d
operator|->
name|glfuncs
operator|->
name|glGetUniformLocation
argument_list|(
name|d
operator|->
name|programGuard
operator|->
name|id
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShaderProgram::uniformLocation("
operator|<<
name|name
operator|<<
literal|"): shader program is not linked"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the location of the uniform variable \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     uniform variable for this shader program.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|uniformLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|uniformLocation
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|uniformLocation
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the location of the uniform variable \a name within this shader     program's parameter list.  Returns -1 if \a name is not a valid     uniform variable for this shader program.      \sa attributeLocation() */
end_comment
begin_function
DECL|function|uniformLocation
name|int
name|QOpenGLShaderProgram
operator|::
name|uniformLocation
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|uniformLocation
argument_list|(
name|name
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLint
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1i
argument_list|(
name|location
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLint
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.     This function should be used when setting sampler values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLuint
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1i
argument_list|(
name|location
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.  This function should be used when setting sampler values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLuint
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the 2D vector (\a x, \a y).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|2
index|]
init|=
block|{
name|x
block|,
name|y
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context to     the 2D vector (\a x, \a y).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the 3D vector (\a x, \a y, \a z).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|3
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context to     the 3D vector (\a x, \a y, \a z).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the 4D vector (\a x, \a y, \a z, \a w).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
name|w
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context to     the 4D vector (\a x, \a y, \a z, \a w).      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector2D
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector3D
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector4D
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector4D
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the red, green, blue, and alpha components of \a color.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|color
operator|.
name|redF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|color
operator|.
name|greenF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|color
operator|.
name|blueF
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|color.alphaF()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context to     the red, green, blue, and alpha components of \a color.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the x and y coordinates of \a point.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|point
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|point.y()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable associated with \a name in the current     context to the x and y coordinates of \a point.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the x and y coordinates of \a point.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|point
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|point.y()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable associated with \a name in the current     context to the x and y coordinates of \a point.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the width and height of the given \a size.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|size
operator|.
name|width
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|size.height()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable associated with \a name in the current     context to the width and height of the given \a size.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to     the width and height of the given \a size.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|values
index|[
literal|4
index|]
init|=
block|{
name|GLfloat
argument_list|(
name|size
operator|.
name|width
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|size.height()
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable associated with \a name in the current     context to the width and height of the given \a size.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 2x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x2
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 2x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x2
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 2x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x3
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
literal|2
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 2x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x3
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 2x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x4
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|2
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 2x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x4
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 3x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x2
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|3
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 3x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x2
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 3x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x3
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 3x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x3
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 3x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x4
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|3
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 3x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x4
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 4x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x2
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|4
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 4x2 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x2
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 4x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x3
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
literal|4
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 4x3 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x3
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context     to a 4x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 4x4 matrix \a value.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable at \a location in the current context     to a 2x2 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable at \a location in the current context     to a 3x3 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|3
index|]
index|[
literal|3
index|]
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable at \a location in the current context     to a 4x4 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 2x2 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 3x3 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|3
index|]
index|[
literal|3
index|]
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context     to a 4x4 matrix \a value.  The matrix elements must be specified     in column-major order.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
name|value
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable at \a location in the current context to a     3x3 transformation matrix \a value that is specified as a QTransform value.      To set a QTransform value as a 4x4 matrix in a shader, use     \c{setUniformValue(location, QMatrix4x4(value))}. */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
name|GLfloat
name|mat
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|GLfloat
argument_list|(
name|value
operator|.
name|m11
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|value
operator|.
name|m12
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|value.m13()
argument_list|)
block|}
block|,
block|{
name|GLfloat
argument_list|(
name|value
operator|.
name|m21
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|value
operator|.
name|m22
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|value.m23()
argument_list|)
block|}
block|,
block|{
name|GLfloat
argument_list|(
name|value
operator|.
name|m31
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
name|value
operator|.
name|m32
argument_list|()
argument_list|)
block|,
name|GLfloat
argument_list|(
argument|value.m33()
argument_list|)
block|}
block|}
decl_stmt|;
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|GL_FALSE
argument_list|,
name|mat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable called \a name in the current context to a     3x3 transformation matrix \a value that is specified as a QTransform value.      To set a QTransform value as a 4x4 matrix in a shader, use     \c{setUniformValue(name, QMatrix4x4(value))}. */
end_comment
begin_function
DECL|function|setUniformValue
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|value
parameter_list|)
block|{
name|setUniformValue
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLint
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count elements of \a values.  This overload     should be used when setting an array of sampler values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLint
operator|*
argument_list|>
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count elements of \a values.  This overload     should be used when setting an array of sampler values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count elements of \a values.  Each element     has \a tupleSize components.  The \a tupleSize must be 1, 2, 3, or 4.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|tupleSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tupleSize
operator|==
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform1fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tupleSize
operator|==
literal|2
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tupleSize
operator|==
literal|3
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tupleSize
operator|==
literal|4
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|values
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLShaderProgram::setUniformValue: size"
operator|<<
name|tupleSize
operator|<<
literal|"not supported"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count elements of \a values.  Each element     has \a tupleSize components.  The \a tupleSize must be 1, 2, 3, or 4.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|tupleSize
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|tupleSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 2D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector2D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 2D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector2D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 3D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector3D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 3D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector3D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 4D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QVector4D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLfloat
operator|*
argument_list|>
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 4D vector elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVector4D
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// We have to repack matrix arrays from qreal to GLfloat.
end_comment
begin_define
DECL|macro|setUniformMatrixArray
define|#
directive|define
name|setUniformMatrixArray
parameter_list|(
name|func
parameter_list|,
name|location
parameter_list|,
name|values
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|,
name|cols
parameter_list|,
name|rows
parameter_list|)
define|\
value|if (location == -1 || count<= 0) \         return; \     if (sizeof(type) == sizeof(GLfloat) * cols * rows) { \         func(location, count, GL_FALSE, \              reinterpret_cast<const GLfloat *>(values[0].constData())); \     } else { \         QVarLengthArray<GLfloat> temp(cols * rows * count); \         for (int index = 0; index< count; ++index) { \             for (int index2 = 0; index2< (cols * rows); ++index2) { \                 temp.data()[cols * rows * index + index2] = \                     values[index].constData()[index2]; \             } \         } \         func(location, count, GL_FALSE, temp.constData()); \     }
end_define
begin_define
DECL|macro|setUniformGenericMatrixArray
define|#
directive|define
name|setUniformGenericMatrixArray
parameter_list|(
name|colfunc
parameter_list|,
name|location
parameter_list|,
name|values
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|,
name|cols
parameter_list|,
name|rows
parameter_list|)
define|\
value|if (location == -1 || count<= 0) \         return; \     if (sizeof(type) == sizeof(GLfloat) * cols * rows) { \         const GLfloat *data = reinterpret_cast<const GLfloat *> \             (values[0].constData());  \         colfunc(location, count * cols, data); \     } else { \         QVarLengthArray<GLfloat> temp(cols * rows * count); \         for (int index = 0; index< count; ++index) { \             for (int index2 = 0; index2< (cols * rows); ++index2) { \                 temp.data()[cols * rows * index + index2] = \                     values[index].constData()[index2]; \             } \         } \         colfunc(location, count * cols, temp.constData()); \     }
end_define
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 2x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix2fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix2x2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 2x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 2x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix2x3
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 2x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 2x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix2x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix2x4
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 2x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix2x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 3x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix3x2
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 3x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 3x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix3fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix3x3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 3x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 3x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix3x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform4fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix3x4
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 3x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix3x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 4x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform2fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix4x2
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 4x2 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x2
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 4x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformGenericMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniform3fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix4x3
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 4x3 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x3
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the uniform variable array at \a location in the current     context to the \a count 4x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
name|int
name|location
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|setUniformMatrixArray
argument_list|(
name|d
operator|->
name|glfuncs
operator|->
name|glUniformMatrix4fv
argument_list|,
name|location
argument_list|,
name|values
argument_list|,
name|count
argument_list|,
name|QMatrix4x4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the uniform variable array called \a name in the current     context to the \a count 4x4 matrix elements of \a values.      \sa setAttributeValue() */
end_comment
begin_function
DECL|function|setUniformValueArray
name|void
name|QOpenGLShaderProgram
operator|::
name|setUniformValueArray
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QMatrix4x4
modifier|*
name|values
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|setUniformValueArray
argument_list|(
name|uniformLocation
argument_list|(
name|name
argument_list|)
argument_list|,
name|values
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the hardware limit for how many vertices a geometry shader     can output. */
end_comment
begin_function
DECL|function|maxGeometryOutputVertices
name|int
name|QOpenGLShaderProgram
operator|::
name|maxGeometryOutputVertices
parameter_list|()
specifier|const
block|{
name|GLint
name|n
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_3_2
argument_list|)
name|glGetIntegerv
argument_list|(
name|GL_MAX_GEOMETRY_OUTPUT_VERTICES
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Use this function to specify to OpenGL the number of vertices in     a patch to \a count. A patch is a custom OpenGL primitive whose interpretation     is entirely defined by the tessellation shader stages. Therefore, calling     this function only makes sense when using a QOpenGLShaderProgram     containing tessellation stage shaders. When using OpenGL tessellation,     the only primitive that can be rendered with \c{glDraw*()} functions is     \c{GL_PATCHES}.      This is equivalent to calling glPatchParameteri(GL_PATCH_VERTICES, count).      \note This modifies global OpenGL state and is not specific to this     QOpenGLShaderProgram instance. You should call this in your render     function when needed, as QOpenGLShaderProgram will not apply this for     you. This is purely a convenience function.      \sa patchVertexCount() */
end_comment
begin_function
DECL|function|setPatchVertexCount
name|void
name|QOpenGLShaderProgram
operator|::
name|setPatchVertexCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glPatchParameteri
argument_list|(
name|GL_PATCH_VERTICES
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the number of vertices per-patch to be used when rendering.      \note This returns the global OpenGL state value. It is not specific to     this QOpenGLShaderProgram instance.      \sa setPatchVertexCount() */
end_comment
begin_function
DECL|function|patchVertexCount
name|int
name|QOpenGLShaderProgram
operator|::
name|patchVertexCount
parameter_list|()
specifier|const
block|{
name|int
name|patchVertices
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_PATCH_VERTICES
argument_list|,
operator|&
name|patchVertices
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|patchVertices
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the default outer tessellation levels to be used by the tessellation     primitive generator in the event that the tessellation control shader     does not output them to \a levels. For more details on OpenGL and Tessellation     shaders see \l{OpenGL Tessellation Shaders}.      The \a levels argument should be a QVector consisting of 4 floats. Not all     of the values make sense for all tessellation modes. If you specify a vector with     fewer than 4 elements, the remaining elements will be given a default value of 1.      \note This modifies global OpenGL state and is not specific to this     QOpenGLShaderProgram instance. You should call this in your render     function when needed, as QOpenGLShaderProgram will not apply this for     you. This is purely a convenience function.      \sa defaultOuterTessellationLevels(), setDefaultInnerTessellationLevels() */
end_comment
begin_function
DECL|function|setDefaultOuterTessellationLevels
name|void
name|QOpenGLShaderProgram
operator|::
name|setDefaultOuterTessellationLevels
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|float
argument_list|>
modifier|&
name|levels
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|QVector
argument_list|<
name|float
argument_list|>
name|tessLevels
init|=
name|levels
decl_stmt|;
comment|// Ensure we have the required 4 outer tessellation levels
comment|// Use default of 1 for missing entries (same as spec)
specifier|const
name|int
name|argCount
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|tessLevels
operator|.
name|size
argument_list|()
operator|<
name|argCount
condition|)
block|{
name|tessLevels
operator|.
name|reserve
argument_list|(
name|argCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|tessLevels
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|argCount
condition|;
operator|++
name|i
control|)
name|tessLevels
operator|.
name|append
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glPatchParameterfv
argument_list|(
name|GL_PATCH_DEFAULT_OUTER_LEVEL
argument_list|,
name|tessLevels
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|levels
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the default outer tessellation levels to be used by the tessellation     primitive generator in the event that the tessellation control shader     does not output them. For more details on OpenGL and Tessellation shaders see     \l{OpenGL Tessellation Shaders}.      Returns a QVector of floats describing the outer tessellation levels. The vector     will always have four elements but not all of them make sense for every mode     of tessellation.      \note This returns the global OpenGL state value. It is not specific to     this QOpenGLShaderProgram instance.      \sa setDefaultOuterTessellationLevels(), defaultInnerTessellationLevels() */
end_comment
begin_function
DECL|function|defaultOuterTessellationLevels
name|QVector
argument_list|<
name|float
argument_list|>
name|QOpenGLShaderProgram
operator|::
name|defaultOuterTessellationLevels
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|float
argument_list|>
name|tessLevels
argument_list|(
literal|4
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glGetFloatv
argument_list|(
name|GL_PATCH_DEFAULT_OUTER_LEVEL
argument_list|,
name|tessLevels
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tessLevels
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the default outer tessellation levels to be used by the tessellation     primitive generator in the event that the tessellation control shader     does not output them to \a levels. For more details on OpenGL and Tessellation shaders see     \l{OpenGL Tessellation Shaders}.      The \a levels argument should be a QVector consisting of 2 floats. Not all     of the values make sense for all tessellation modes. If you specify a vector with     fewer than 2 elements, the remaining elements will be given a default value of 1.      \note This modifies global OpenGL state and is not specific to this     QOpenGLShaderProgram instance. You should call this in your render     function when needed, as QOpenGLShaderProgram will not apply this for     you. This is purely a convenience function.      \sa defaultInnerTessellationLevels(), setDefaultOuterTessellationLevels() */
end_comment
begin_function
DECL|function|setDefaultInnerTessellationLevels
name|void
name|QOpenGLShaderProgram
operator|::
name|setDefaultInnerTessellationLevels
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|float
argument_list|>
modifier|&
name|levels
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|QVector
argument_list|<
name|float
argument_list|>
name|tessLevels
init|=
name|levels
decl_stmt|;
comment|// Ensure we have the required 2 inner tessellation levels
comment|// Use default of 1 for missing entries (same as spec)
specifier|const
name|int
name|argCount
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|tessLevels
operator|.
name|size
argument_list|()
operator|<
name|argCount
condition|)
block|{
name|tessLevels
operator|.
name|reserve
argument_list|(
name|argCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|tessLevels
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|argCount
condition|;
operator|++
name|i
control|)
name|tessLevels
operator|.
name|append
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glPatchParameterfv
argument_list|(
name|GL_PATCH_DEFAULT_INNER_LEVEL
argument_list|,
name|tessLevels
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|levels
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the default inner tessellation levels to be used by the tessellation     primitive generator in the event that the tessellation control shader     does not output them. For more details on OpenGL and Tessellation shaders see     \l{OpenGL Tessellation Shaders}.      Returns a QVector of floats describing the inner tessellation levels. The vector     will always have two elements but not all of them make sense for every mode     of tessellation.      \note This returns the global OpenGL state value. It is not specific to     this QOpenGLShaderProgram instance.      \sa setDefaultInnerTessellationLevels(), defaultOuterTessellationLevels() */
end_comment
begin_function
DECL|function|defaultInnerTessellationLevels
name|QVector
argument_list|<
name|float
argument_list|>
name|QOpenGLShaderProgram
operator|::
name|defaultInnerTessellationLevels
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|float
argument_list|>
name|tessLevels
argument_list|(
literal|2
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4
argument_list|)
name|Q_D
argument_list|(
specifier|const
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tessellationFuncs
condition|)
name|d
operator|->
name|tessellationFuncs
operator|->
name|glGetFloatv
argument_list|(
name|GL_PATCH_DEFAULT_OUTER_LEVEL
argument_list|,
name|tessLevels
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tessLevels
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if shader programs written in the OpenGL Shading     Language (GLSL) are supported on this system; false otherwise.      The \a context is used to resolve the GLSL extensions.     If \a context is null, then QOpenGLContext::currentContext() is used. */
end_comment
begin_function
DECL|function|hasOpenGLShaderPrograms
name|bool
name|QOpenGLShaderProgram
operator|::
name|hasOpenGLShaderPrograms
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
literal|false
return|;
return|return
name|QOpenGLFunctions
argument_list|(
name|context
argument_list|)
operator|.
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|Shaders
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|shaderDestroyed
name|void
name|QOpenGLShaderProgram
operator|::
name|shaderDestroyed
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLShaderProgram
argument_list|)
expr_stmt|;
name|QOpenGLShader
modifier|*
name|shader
init|=
name|qobject_cast
argument_list|<
name|QOpenGLShader
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shader
operator|&&
operator|!
name|d
operator|->
name|removingShaders
condition|)
name|removeShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if shader programs of type \a type are supported on     this system; false otherwise.      The \a context is used to resolve the GLSL extensions.     If \a context is null, then QOpenGLContext::currentContext() is used. */
end_comment
begin_function
DECL|function|hasOpenGLShaders
name|bool
name|QOpenGLShader
operator|::
name|hasOpenGLShaders
parameter_list|(
name|ShaderType
name|type
parameter_list|,
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|type
operator|&
operator|~
operator|(
name|Geometry
operator||
name|Vertex
operator||
name|Fragment
operator||
name|TessellationControl
operator||
name|TessellationEvaluation
operator||
name|Compute
operator|)
operator|)
operator|||
name|type
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|QSurfaceFormat
name|format
init|=
name|context
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Geometry
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
comment|// Geometry shaders require OpenGL 3.2 or newer
name|QSurfaceFormat
name|format
init|=
name|context
operator|->
name|format
argument_list|()
decl_stmt|;
return|return
operator|(
name|format
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|)
return|;
else|#
directive|else
comment|// No geometry shader support in OpenGL ES2
return|return
literal|false
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TessellationControl
operator|||
name|type
operator|==
name|TessellationEvaluation
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
return|return
operator|(
name|format
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
operator|)
return|;
else|#
directive|else
comment|// No tessellation shader support in OpenGL ES2
return|return
literal|false
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Compute
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_4_3
argument_list|)
return|return
operator|(
name|format
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|)
operator|)
return|;
else|#
directive|else
comment|// No compute shader support without OpenGL 4.3 or newer
return|return
literal|false
return|;
endif|#
directive|endif
block|}
comment|// Unconditional support of vertex and fragment shaders implicitly assumes
comment|// a minimum OpenGL version of 2.0
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
