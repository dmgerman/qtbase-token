begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtriangulator_p.h"
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qdialog.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qevent.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainter.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainterpath.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qbezier_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qdatabuffer_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qqueue.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qglobal.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qpoint.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qalgorithms.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qrbtree_p.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|//#define Q_TRIANGULATOR_DEBUG
DECL|macro|Q_FIXED_POINT_SCALE
define|#
directive|define
name|Q_FIXED_POINT_SCALE
value|32
comment|// Quick sort.
specifier|template
type|<class
name|T
decl_stmt|,
name|class
name|LessThan
decl|>
ifdef|#
directive|ifdef
name|Q_CC_RVCT
comment|// RVCT 2.2 doesn't see recursive _static_ template function
DECL|function|sort
name|void
name|sort
argument_list|(
name|T
operator|*
name|array
argument_list|,
name|int
name|count
argument_list|,
name|LessThan
name|lessThan
argument_list|)
else|#
directive|else
decl|static
name|void
name|sort
argument_list|(
name|T
operator|*
name|array
argument_list|,
name|int
name|count
argument_list|,
name|LessThan
name|lessThan
argument_list|)
endif|#
directive|endif
argument_list|{
comment|// If the number of elements fall below some threshold, use insertion sort.
specifier|const
name|int
name|INSERTION_SORT_LIMIT
operator|=
literal|7
argument_list|;
comment|// About 7 is fastest on my computer...
argument_list|if
operator|(
name|count
operator|<=
name|INSERTION_SORT_LIMIT
operator|)
block|{
for|for
control|(
name|int
name|i
type|= 1
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|T
name|temp
operator|=
name|array
index|[
name|i
index|]
block|;
name|int
name|j
operator|=
name|i
block|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
name|lessThan
argument_list|(
name|temp
argument_list|,
name|array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|array
index|[
name|j
index|]
operator|=
name|array
index|[
name|j
operator|-
literal|1
index|]
block|;
operator|--
name|j
block|;             }
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
return|return;
block|}
name|int
name|high
operator|=
name|count
operator|-
literal|1
argument_list|;
name|int
name|low
operator|=
literal|0
argument_list|;
name|int
name|mid
operator|=
name|high
operator|/
literal|2
argument_list|;     if
operator|(
name|lessThan
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
operator|)
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
argument_list|;     if
operator|(
name|lessThan
argument_list|(
name|array
index|[
name|high
index|]
argument_list|,
name|array
index|[
name|mid
index|]
argument_list|)
operator|)
name|qSwap
argument_list|(
name|array
index|[
name|high
index|]
argument_list|,
name|array
index|[
name|mid
index|]
argument_list|)
argument_list|;     if
operator|(
name|lessThan
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
operator|)
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
argument_list|;
operator|--
name|high
argument_list|;
operator|++
name|low
argument_list|;
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|high
index|]
argument_list|)
argument_list|;
name|int
name|pivot
operator|=
name|high
argument_list|;
operator|--
name|high
argument_list|;      while
operator|(
name|low
operator|<=
name|high
operator|)
block|{
while|while
condition|(
operator|!
name|lessThan
argument_list|(
name|array
index|[
name|pivot
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
condition|)
block|{
operator|++
name|low
block|;
if|if
condition|(
name|low
operator|>
name|high
condition|)
goto|goto
name|sort_loop_end
goto|;
block|}
while|while
condition|(
operator|!
name|lessThan
argument_list|(
name|array
index|[
name|high
index|]
argument_list|,
name|array
index|[
name|pivot
index|]
argument_list|)
condition|)
block|{
operator|--
name|high
block|;
if|if
condition|(
name|low
operator|>
name|high
condition|)
goto|goto
name|sort_loop_end
goto|;
block|}
name|qSwap
argument_list|(
name|array
index|[
name|low
index|]
argument_list|,
name|array
index|[
name|high
index|]
argument_list|)
expr_stmt|;
operator|++
name|low
argument_list|;
operator|--
name|high
argument_list|;     }
name|sort_loop_end
range|:
end_decl_stmt
begin_if
if|if
condition|(
name|low
operator|!=
name|pivot
condition|)
name|qSwap
argument_list|(
name|array
index|[
name|pivot
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|sort
argument_list|(
name|array
argument_list|,
name|low
argument_list|,
name|lessThan
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|sort
argument_list|(
name|array
operator|+
name|low
operator|+
literal|1
argument_list|,
name|count
operator|-
name|low
operator|-
literal|1
argument_list|,
name|lessThan
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|// Quick sort.
end_comment
begin_expr_stmt
unit|template
operator|<
name|class
name|T
operator|>
ifdef|#
directive|ifdef
name|Q_CC_RVCT
DECL|function|sort
name|void
name|sort
argument_list|(
argument|T *array
argument_list|,
argument|int count
argument_list|)
comment|// RVCT 2.2 doesn't see recursive _static_ template function
else|#
directive|else
specifier|static
name|void
name|sort
argument_list|(
argument|T *array
argument_list|,
argument|int count
argument_list|)
endif|#
directive|endif
block|{
comment|// If the number of elements fall below some threshold, use insertion sort.
specifier|const
name|int
name|INSERTION_SORT_LIMIT
operator|=
literal|25
block|;
comment|// About 25 is fastest on my computer...
if|if
condition|(
name|count
operator|<=
name|INSERTION_SORT_LIMIT
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|T
name|temp
init|=
name|array
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
operator|(
name|temp
operator|<
name|array
index|[
name|j
operator|-
literal|1
index|]
operator|)
condition|)
block|{
name|array
index|[
name|j
index|]
operator|=
name|array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|j
expr_stmt|;
block|}
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
end_expr_stmt
begin_empty_stmt
unit|}         return
empty_stmt|;
end_empty_stmt
begin_expr_stmt
unit|}      int
name|high
operator|=
name|count
operator|-
literal|1
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|int
name|low
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|mid
init|=
name|high
operator|/
literal|2
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
operator|(
name|array
index|[
name|mid
index|]
operator|<
name|array
index|[
name|low
index|]
operator|)
condition|)
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
expr_stmt|;
end_if
begin_if
if|if
condition|(
operator|(
name|array
index|[
name|high
index|]
operator|<
name|array
index|[
name|mid
index|]
operator|)
condition|)
name|qSwap
argument_list|(
name|array
index|[
name|high
index|]
argument_list|,
name|array
index|[
name|mid
index|]
argument_list|)
expr_stmt|;
end_if
begin_if
if|if
condition|(
operator|(
name|array
index|[
name|mid
index|]
operator|<
name|array
index|[
name|low
index|]
operator|)
condition|)
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
operator|--
name|high
expr_stmt|;
end_expr_stmt
begin_expr_stmt
operator|++
name|low
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|qSwap
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|,
name|array
index|[
name|high
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|int
name|pivot
init|=
name|high
decl_stmt|;
end_decl_stmt
begin_expr_stmt
operator|--
name|high
expr_stmt|;
end_expr_stmt
begin_while
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|array
index|[
name|pivot
index|]
operator|<
name|array
index|[
name|low
index|]
operator|)
condition|)
block|{
operator|++
name|low
expr_stmt|;
if|if
condition|(
name|low
operator|>
name|high
condition|)
goto|goto
name|sort_loop_end
goto|;
block|}
while|while
condition|(
operator|!
operator|(
name|array
index|[
name|high
index|]
operator|<
name|array
index|[
name|pivot
index|]
operator|)
condition|)
block|{
operator|--
name|high
expr_stmt|;
if|if
condition|(
name|low
operator|>
name|high
condition|)
goto|goto
name|sort_loop_end
goto|;
block|}
name|qSwap
argument_list|(
name|array
index|[
name|low
index|]
argument_list|,
name|array
index|[
name|high
index|]
argument_list|)
expr_stmt|;
operator|++
name|low
expr_stmt|;
operator|--
name|high
expr_stmt|;
block|}
end_while
begin_label
name|sort_loop_end
label|:
end_label
begin_if
if|if
condition|(
name|low
operator|!=
name|pivot
condition|)
name|qSwap
argument_list|(
name|array
index|[
name|pivot
index|]
argument_list|,
name|array
index|[
name|low
index|]
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|sort
argument_list|(
name|array
argument_list|,
name|low
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|sort
argument_list|(
name|array
operator|+
name|low
operator|+
literal|1
argument_list|,
name|count
operator|-
name|low
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|}  template
operator|<
typename|typename
name|T
operator|>
expr|struct
DECL|struct|QVertexSet
name|QVertexSet
block|{
DECL|function|QVertexSet
specifier|inline
name|QVertexSet
argument_list|()
block|{ }
DECL|function|QVertexSet
specifier|inline
name|QVertexSet
argument_list|(
specifier|const
name|QVertexSet
argument_list|<
name|T
argument_list|>
operator|&
name|other
argument_list|)
operator|:
name|vertices
argument_list|(
name|other
operator|.
name|vertices
argument_list|)
block|,
name|indices
argument_list|(
argument|other.indices
argument_list|)
block|{ }
DECL|function|operator =
name|QVertexSet
argument_list|<
name|T
argument_list|>
operator|&
name|operator
name|=
operator|(
specifier|const
name|QVertexSet
argument_list|<
name|T
argument_list|>
operator|&
name|other
operator|)
block|{
name|vertices
operator|=
name|other
operator|.
name|vertices
block|;
name|indices
operator|=
name|other
operator|.
name|indices
block|;
return|return
operator|*
name|this
return|;
block|}
comment|// The vertices of a triangle are given by: (x[i[n]], y[i[n]]), (x[j[n]], y[j[n]]), (x[k[n]], y[k[n]]), n = 0, 1, ...
DECL|member|vertices
name|QVector
argument_list|<
name|qreal
argument_list|>
name|vertices
expr_stmt|;
end_expr_stmt
begin_comment
DECL|member|vertices
comment|// [x[0], y[0], x[1], y[1], x[2], ...]
end_comment
begin_decl_stmt
DECL|member|indices
name|QVector
argument_list|<
name|T
argument_list|>
name|indices
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|indices
comment|// [i[0], j[0], k[0], i[1], j[1], k[1], i[2], ...]
end_comment
begin_comment
unit|};
comment|//============================================================================//
end_comment
begin_comment
comment|//                                 QFraction                                  //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|// Fraction must be in the range [0, 1)
end_comment
begin_struct
DECL|struct|QFraction
struct|struct
name|QFraction
block|{
comment|// Comparison operators must not be called on invalid fractions.
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
DECL|function|operator !=
specifier|inline
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|operator >
specifier|inline
name|bool
name|operator
name|>
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|other
operator|<
operator|*
name|this
return|;
block|}
DECL|function|operator >=
specifier|inline
name|bool
name|operator
name|>=
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|other
operator|)
return|;
block|}
DECL|function|operator <=
specifier|inline
name|bool
name|operator
name|<=
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|>
name|other
operator|)
return|;
block|}
DECL|function|isValid
specifier|inline
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|denominator
operator|!=
literal|0
return|;
block|}
comment|// numerator and denominator must not have common denominators.
DECL|member|numerator
DECL|member|denominator
name|quint64
name|numerator
decl_stmt|,
name|denominator
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|gcd
specifier|static
specifier|inline
name|quint64
name|gcd
parameter_list|(
name|quint64
name|x
parameter_list|,
name|quint64
name|y
parameter_list|)
block|{
while|while
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|quint64
name|z
init|=
name|y
decl_stmt|;
name|y
operator|=
name|x
operator|%
name|y
expr_stmt|;
name|x
operator|=
name|z
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function
begin_function
DECL|function|compare
specifier|static
specifier|inline
name|int
name|compare
parameter_list|(
name|quint64
name|a
parameter_list|,
name|quint64
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>
name|b
operator|)
operator|-
operator|(
name|a
operator|<
name|b
operator|)
return|;
block|}
end_function
begin_comment
comment|// Compare a/b with c/d.
end_comment
begin_comment
comment|// Return negative if less, 0 if equal, positive if greater.
end_comment
begin_comment
comment|// a< b, c< d
end_comment
begin_function
DECL|function|qCompareFractions
specifier|static
name|int
name|qCompareFractions
parameter_list|(
name|quint64
name|a
parameter_list|,
name|quint64
name|b
parameter_list|,
name|quint64
name|c
parameter_list|,
name|quint64
name|d
parameter_list|)
block|{
specifier|const
name|quint64
name|LIMIT
init|=
name|Q_UINT64_C
argument_list|(
literal|0x100000000
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// If the products 'ad' and 'bc' fit into 64 bits, they can be directly compared.
if|if
condition|(
name|b
operator|<
name|LIMIT
operator|&&
name|d
operator|<
name|LIMIT
condition|)
return|return
name|compare
argument_list|(
name|a
operator|*
name|d
argument_list|,
name|b
operator|*
name|c
argument_list|)
return|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|c
operator|==
literal|0
condition|)
return|return
name|compare
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
return|;
comment|// a/b< c/d<=>  d/c< b/a
name|quint64
name|b_div_a
init|=
name|b
operator|/
name|a
decl_stmt|;
name|quint64
name|d_div_c
init|=
name|d
operator|/
name|c
decl_stmt|;
if|if
condition|(
name|b_div_a
operator|!=
name|d_div_c
condition|)
return|return
name|compare
argument_list|(
name|d_div_c
argument_list|,
name|b_div_a
argument_list|)
return|;
comment|// floor(d/c) == floor(b/a)
comment|// frac(d/c)< frac(b/a) ?
comment|// frac(x/y) = (x%y)/y
name|d
operator|-=
name|d_div_c
operator|*
name|c
expr_stmt|;
comment|//d %= c;
name|b
operator|-=
name|b_div_a
operator|*
name|a
expr_stmt|;
comment|//b %= a;
name|qSwap
argument_list|(
name|a
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Fraction must be in the range [0, 1)
end_comment
begin_comment
comment|// Assume input is valid.
end_comment
begin_function
DECL|function|qFraction
specifier|static
name|QFraction
name|qFraction
parameter_list|(
name|quint64
name|n
parameter_list|,
name|quint64
name|d
parameter_list|)
block|{
name|QFraction
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|numerator
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|denominator
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|quint64
name|g
init|=
name|gcd
argument_list|(
name|n
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|result
operator|.
name|numerator
operator|=
name|n
operator|/
name|g
expr_stmt|;
name|result
operator|.
name|denominator
operator|=
name|d
operator|/
name|g
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|QFraction
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|qCompareFractions
argument_list|(
name|numerator
argument_list|,
name|denominator
argument_list|,
name|other
operator|.
name|numerator
argument_list|,
name|other
operator|.
name|denominator
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_function
DECL|function|operator ==
specifier|inline
name|bool
name|QFraction
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QFraction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|numerator
operator|==
name|other
operator|.
name|numerator
operator|&&
name|denominator
operator|==
name|other
operator|.
name|denominator
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                                 QPodPoint                                  //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_struct
DECL|struct|QPodPoint
struct|struct
name|QPodPoint
block|{
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|y
operator|!=
name|other
operator|.
name|y
condition|)
return|return
name|y
operator|<
name|other
operator|.
name|y
return|;
return|return
name|x
operator|<
name|other
operator|.
name|x
return|;
block|}
DECL|function|operator >
specifier|inline
name|bool
name|operator
name|>
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|other
operator|<
operator|*
name|this
return|;
block|}
DECL|function|operator <=
specifier|inline
name|bool
name|operator
name|<=
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|>
name|other
operator|)
return|;
block|}
DECL|function|operator >=
specifier|inline
name|bool
name|operator
name|>=
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|other
operator|)
return|;
block|}
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|x
operator|==
name|other
operator|.
name|x
operator|&&
name|y
operator|==
name|other
operator|.
name|y
return|;
block|}
DECL|function|operator !=
specifier|inline
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|x
operator|!=
name|other
operator|.
name|x
operator|||
name|y
operator|!=
name|other
operator|.
name|y
return|;
block|}
DECL|function|operator +=
specifier|inline
name|QPodPoint
modifier|&
name|operator
name|+=
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
block|{
name|x
operator|+=
name|other
operator|.
name|x
expr_stmt|;
name|y
operator|+=
name|other
operator|.
name|y
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
DECL|function|operator -=
specifier|inline
name|QPodPoint
modifier|&
name|operator
name|-=
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
block|{
name|x
operator|-=
name|other
operator|.
name|x
expr_stmt|;
name|y
operator|-=
name|other
operator|.
name|y
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
DECL|function|operator +
specifier|inline
name|QPodPoint
name|operator
name|+
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
name|QPodPoint
name|result
init|=
block|{
name|x
operator|+
name|other
operator|.
name|x
block|,
name|y
operator|+
name|other
operator|.
name|y
block|}
decl_stmt|;
return|return
name|result
return|;
block|}
DECL|function|operator -
specifier|inline
name|QPodPoint
name|operator
name|-
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
name|QPodPoint
name|result
init|=
block|{
name|x
operator|-
name|other
operator|.
name|x
block|,
name|y
operator|-
name|other
operator|.
name|y
block|}
decl_stmt|;
return|return
name|result
return|;
block|}
DECL|member|x
name|int
name|x
decl_stmt|;
DECL|member|y
name|int
name|y
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|qCross
specifier|static
specifier|inline
name|qint64
name|qCross
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v
parameter_list|)
block|{
return|return
name|qint64
argument_list|(
name|u
operator|.
name|x
argument_list|)
operator|*
name|qint64
argument_list|(
name|v
operator|.
name|y
argument_list|)
operator|-
name|qint64
argument_list|(
name|u
operator|.
name|y
argument_list|)
operator|*
name|qint64
argument_list|(
name|v
operator|.
name|x
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qDot
specifier|static
specifier|inline
name|qint64
name|qDot
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v
parameter_list|)
block|{
return|return
name|qint64
argument_list|(
name|u
operator|.
name|x
argument_list|)
operator|*
name|qint64
argument_list|(
name|v
operator|.
name|x
argument_list|)
operator|+
name|qint64
argument_list|(
name|u
operator|.
name|y
argument_list|)
operator|*
name|qint64
argument_list|(
name|v
operator|.
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Return positive value if 'p' is to the right of the line 'v1'->'v2', negative if left of the
end_comment
begin_comment
comment|// line and zero if exactly on the line.
end_comment
begin_comment
comment|// The returned value is the z-component of the qCross product between 'v2-v1' and 'p-v1',
end_comment
begin_comment
comment|// which is twice the signed area of the triangle 'p'->'v1'->'v2' (positive for CW order).
end_comment
begin_function
DECL|function|qPointDistanceFromLine
specifier|static
specifier|inline
name|qint64
name|qPointDistanceFromLine
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v2
parameter_list|)
block|{
return|return
name|qCross
argument_list|(
name|v2
operator|-
name|v1
argument_list|,
name|p
operator|-
name|v1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qPointIsLeftOfLine
specifier|static
specifier|inline
name|bool
name|qPointIsLeftOfLine
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v2
parameter_list|)
block|{
return|return
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|p
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|// Return:
end_comment
begin_comment
comment|// -1 if u< v
end_comment
begin_comment
comment|//  0 if u == v
end_comment
begin_comment
comment|//  1 if u> v
end_comment
begin_function
DECL|function|comparePoints
specifier|static
name|int
name|comparePoints
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v
parameter_list|)
block|{
if|if
condition|(
name|u
operator|.
name|y
operator|<
name|v
operator|.
name|y
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|u
operator|.
name|y
operator|>
name|v
operator|.
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|u
operator|.
name|x
operator|<
name|v
operator|.
name|x
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|u
operator|.
name|x
operator|>
name|v
operator|.
name|x
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                             QIntersectionPoint                             //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_struct
DECL|struct|QIntersectionPoint
struct|struct
name|QIntersectionPoint
block|{
DECL|function|isValid
specifier|inline
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|xOffset
operator|.
name|isValid
argument_list|()
operator|&&
name|yOffset
operator|.
name|isValid
argument_list|()
return|;
block|}
name|QPodPoint
name|round
parameter_list|()
specifier|const
function_decl|;
DECL|function|isAccurate
specifier|inline
name|bool
name|isAccurate
parameter_list|()
specifier|const
block|{
return|return
name|xOffset
operator|.
name|numerator
operator|==
literal|0
operator|&&
name|yOffset
operator|.
name|numerator
operator|==
literal|0
return|;
block|}
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
DECL|function|operator !=
specifier|inline
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
DECL|function|operator >
specifier|inline
name|bool
name|operator
name|>
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|other
operator|<
operator|*
name|this
return|;
block|}
DECL|function|operator >=
specifier|inline
name|bool
name|operator
name|>=
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|other
operator|)
return|;
block|}
DECL|function|operator <=
specifier|inline
name|bool
name|operator
name|<=
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|>
name|other
operator|)
return|;
block|}
name|bool
name|isOnLine
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v
parameter_list|)
specifier|const
function_decl|;
DECL|member|upperLeft
name|QPodPoint
name|upperLeft
decl_stmt|;
DECL|member|xOffset
name|QFraction
name|xOffset
decl_stmt|;
DECL|member|yOffset
name|QFraction
name|yOffset
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|qIntersectionPoint
specifier|static
specifier|inline
name|QIntersectionPoint
name|qIntersectionPoint
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|point
parameter_list|)
block|{
comment|// upperLeft = point, xOffset = 0/1, yOffset = 0/1.
name|QIntersectionPoint
name|p
init|=
block|{
block|{
name|point
operator|.
name|x
block|,
name|point
operator|.
name|y
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|qIntersectionPoint
specifier|static
specifier|inline
name|QIntersectionPoint
name|qIntersectionPoint
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
comment|// upperLeft = (x, y), xOffset = 0/1, yOffset = 0/1.
name|QIntersectionPoint
name|p
init|=
block|{
block|{
name|x
block|,
name|y
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|qIntersectionPoint
specifier|static
name|QIntersectionPoint
name|qIntersectionPoint
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|u2
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v2
parameter_list|)
block|{
name|QIntersectionPoint
name|result
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|QPodPoint
name|u
init|=
name|u2
operator|-
name|u1
decl_stmt|;
name|QPodPoint
name|v
init|=
name|v2
operator|-
name|v1
decl_stmt|;
name|qint64
name|d1
init|=
name|qCross
argument_list|(
name|u
argument_list|,
name|v1
operator|-
name|u1
argument_list|)
decl_stmt|;
name|qint64
name|d2
init|=
name|qCross
argument_list|(
name|u
argument_list|,
name|v2
operator|-
name|u1
argument_list|)
decl_stmt|;
name|qint64
name|det
init|=
name|d2
operator|-
name|d1
decl_stmt|;
name|qint64
name|d3
init|=
name|qCross
argument_list|(
name|v
argument_list|,
name|u1
operator|-
name|v1
argument_list|)
decl_stmt|;
name|qint64
name|d4
init|=
name|d3
operator|-
name|det
decl_stmt|;
comment|//qCross(v, u2 - v1);
comment|// Check that the math is correct.
name|Q_ASSERT
argument_list|(
name|d4
operator|==
name|qCross
argument_list|(
name|v
argument_list|,
name|u2
operator|-
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// The intersection point can be expressed as:
comment|// v1 - v * d1/det
comment|// v2 - v * d2/det
comment|// u1 + u * d3/det
comment|// u2 + u * d4/det
comment|// I'm only interested in lines that are crossing, so ignore parallel lines even if they overlap.
if|if
condition|(
name|det
operator|==
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|det
operator|<
literal|0
condition|)
block|{
name|det
operator|=
operator|-
name|det
expr_stmt|;
name|d1
operator|=
operator|-
name|d1
expr_stmt|;
name|d2
operator|=
operator|-
name|d2
expr_stmt|;
name|d3
operator|=
operator|-
name|d3
expr_stmt|;
name|d4
operator|=
operator|-
name|d4
expr_stmt|;
block|}
comment|// I'm only interested in lines intersecting at their interior, not at their end points.
comment|// The lines intersect at their interior if and only if 'd1< 0', 'd2> 0', 'd3< 0' and 'd4> 0'.
if|if
condition|(
name|d1
operator|>=
literal|0
operator|||
name|d2
operator|<=
literal|0
operator|||
name|d3
operator|<=
literal|0
operator|||
name|d4
operator|>=
literal|0
condition|)
return|return
name|result
return|;
comment|// Calculate the intersection point as follows:
comment|// v1 - v * d1/det | v1<= v2 (component-wise)
comment|// v2 - v * d2/det | v2< v1 (component-wise)
comment|// Assuming 21 bits per vector component.
comment|// TODO: Make code path for 31 bits per vector component.
if|if
condition|(
name|v
operator|.
name|x
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|upperLeft
operator|.
name|x
operator|=
name|v1
operator|.
name|x
operator|+
operator|(
operator|-
name|v
operator|.
name|x
operator|*
name|d1
operator|)
operator|/
name|det
expr_stmt|;
name|result
operator|.
name|xOffset
operator|=
name|qFraction
argument_list|(
name|quint64
argument_list|(
operator|-
name|v
operator|.
name|x
operator|*
name|d1
argument_list|)
operator|%
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|,
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|upperLeft
operator|.
name|x
operator|=
name|v2
operator|.
name|x
operator|+
operator|(
operator|-
name|v
operator|.
name|x
operator|*
name|d2
operator|)
operator|/
name|det
expr_stmt|;
name|result
operator|.
name|xOffset
operator|=
name|qFraction
argument_list|(
name|quint64
argument_list|(
operator|-
name|v
operator|.
name|x
operator|*
name|d2
argument_list|)
operator|%
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|,
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|.
name|y
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|upperLeft
operator|.
name|y
operator|=
name|v1
operator|.
name|y
operator|+
operator|(
operator|-
name|v
operator|.
name|y
operator|*
name|d1
operator|)
operator|/
name|det
expr_stmt|;
name|result
operator|.
name|yOffset
operator|=
name|qFraction
argument_list|(
name|quint64
argument_list|(
operator|-
name|v
operator|.
name|y
operator|*
name|d1
argument_list|)
operator|%
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|,
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|upperLeft
operator|.
name|y
operator|=
name|v2
operator|.
name|y
operator|+
operator|(
operator|-
name|v
operator|.
name|y
operator|*
name|d2
operator|)
operator|/
name|det
expr_stmt|;
name|result
operator|.
name|yOffset
operator|=
name|qFraction
argument_list|(
name|quint64
argument_list|(
operator|-
name|v
operator|.
name|y
operator|*
name|d2
argument_list|)
operator|%
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|,
name|quint64
argument_list|(
name|det
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|result
operator|.
name|xOffset
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|result
operator|.
name|yOffset
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|round
name|QPodPoint
name|QIntersectionPoint
operator|::
name|round
parameter_list|()
specifier|const
block|{
name|QPodPoint
name|result
init|=
name|upperLeft
decl_stmt|;
if|if
condition|(
literal|2
operator|*
name|xOffset
operator|.
name|numerator
operator|>=
name|xOffset
operator|.
name|denominator
condition|)
operator|++
name|result
operator|.
name|x
expr_stmt|;
if|if
condition|(
literal|2
operator|*
name|yOffset
operator|.
name|numerator
operator|>=
name|yOffset
operator|.
name|denominator
condition|)
operator|++
name|result
operator|.
name|y
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|operator <
name|bool
name|QIntersectionPoint
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|upperLeft
operator|.
name|y
operator|!=
name|other
operator|.
name|upperLeft
operator|.
name|y
condition|)
return|return
name|upperLeft
operator|.
name|y
operator|<
name|other
operator|.
name|upperLeft
operator|.
name|y
return|;
if|if
condition|(
name|yOffset
operator|!=
name|other
operator|.
name|yOffset
condition|)
return|return
name|yOffset
operator|<
name|other
operator|.
name|yOffset
return|;
if|if
condition|(
name|upperLeft
operator|.
name|x
operator|!=
name|other
operator|.
name|upperLeft
operator|.
name|x
condition|)
return|return
name|upperLeft
operator|.
name|x
operator|<
name|other
operator|.
name|upperLeft
operator|.
name|x
return|;
return|return
name|xOffset
operator|<
name|other
operator|.
name|xOffset
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|QIntersectionPoint
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QIntersectionPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|upperLeft
operator|==
name|other
operator|.
name|upperLeft
operator|&&
name|xOffset
operator|==
name|other
operator|.
name|xOffset
operator|&&
name|yOffset
operator|==
name|other
operator|.
name|yOffset
return|;
block|}
end_function
begin_comment
comment|// Returns true if this point is on the infinite line passing through 'u' and 'v'.
end_comment
begin_function
DECL|function|isOnLine
name|bool
name|QIntersectionPoint
operator|::
name|isOnLine
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v
parameter_list|)
specifier|const
block|{
comment|// TODO: Make code path for coordinates with more than 21 bits.
specifier|const
name|QPodPoint
name|p
init|=
name|upperLeft
operator|-
name|u
decl_stmt|;
specifier|const
name|QPodPoint
name|q
init|=
name|v
operator|-
name|u
decl_stmt|;
name|bool
name|isHorizontal
init|=
name|p
operator|.
name|y
operator|==
literal|0
operator|&&
name|yOffset
operator|.
name|numerator
operator|==
literal|0
decl_stmt|;
name|bool
name|isVertical
init|=
name|p
operator|.
name|x
operator|==
literal|0
operator|&&
name|xOffset
operator|.
name|numerator
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|isHorizontal
operator|&&
name|isVertical
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|isHorizontal
condition|)
return|return
name|q
operator|.
name|y
operator|==
literal|0
return|;
if|if
condition|(
name|q
operator|.
name|y
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isVertical
condition|)
return|return
name|q
operator|.
name|x
operator|==
literal|0
return|;
if|if
condition|(
name|q
operator|.
name|x
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// At this point, 'p+offset' and 'q' cannot lie on the x or y axis.
if|if
condition|(
operator|(
operator|(
name|q
operator|.
name|x
operator|<
literal|0
operator|)
operator|==
operator|(
name|q
operator|.
name|y
operator|<
literal|0
operator|)
operator|)
operator|!=
operator|(
operator|(
name|p
operator|.
name|x
operator|<
literal|0
operator|)
operator|==
operator|(
name|p
operator|.
name|y
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
literal|false
return|;
comment|// 'p + offset' and 'q' pass through different quadrants.
comment|// Move all coordinates into the first quadrant.
name|quint64
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
operator|<
literal|0
condition|)
name|nx
operator|=
name|quint64
argument_list|(
operator|-
name|p
operator|.
name|x
argument_list|)
operator|*
name|xOffset
operator|.
name|denominator
operator|-
name|xOffset
operator|.
name|numerator
expr_stmt|;
else|else
name|nx
operator|=
name|quint64
argument_list|(
name|p
operator|.
name|x
argument_list|)
operator|*
name|xOffset
operator|.
name|denominator
operator|+
name|xOffset
operator|.
name|numerator
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|y
operator|<
literal|0
condition|)
name|ny
operator|=
name|quint64
argument_list|(
operator|-
name|p
operator|.
name|y
argument_list|)
operator|*
name|yOffset
operator|.
name|denominator
operator|-
name|yOffset
operator|.
name|numerator
expr_stmt|;
else|else
name|ny
operator|=
name|quint64
argument_list|(
name|p
operator|.
name|y
argument_list|)
operator|*
name|yOffset
operator|.
name|denominator
operator|+
name|yOffset
operator|.
name|numerator
expr_stmt|;
return|return
name|qFraction
argument_list|(
name|quint64
argument_list|(
name|qAbs
argument_list|(
name|q
operator|.
name|x
argument_list|)
argument_list|)
operator|*
name|xOffset
operator|.
name|denominator
argument_list|,
name|quint64
argument_list|(
name|qAbs
argument_list|(
name|q
operator|.
name|y
argument_list|)
argument_list|)
operator|*
name|yOffset
operator|.
name|denominator
argument_list|)
operator|==
name|qFraction
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                                  QMaxHeap                                  //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_class
template|template
parameter_list|<
name|class
name|T
parameter_list|>
class|class
DECL|class|QMaxHeap
name|QMaxHeap
block|{
public|public:
DECL|function|QMaxHeap
name|QMaxHeap
parameter_list|()
member_init_list|:
name|m_data
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|size
specifier|inline
name|int
name|size
parameter_list|()
specifier|const
block|{
return|return
name|m_data
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|empty
specifier|inline
name|bool
name|empty
parameter_list|()
specifier|const
block|{
return|return
name|m_data
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|function|isEmpty
specifier|inline
name|bool
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|m_data
operator|.
name|isEmpty
argument_list|()
return|;
block|}
name|void
name|push
parameter_list|(
specifier|const
name|T
modifier|&
name|x
parameter_list|)
function_decl|;
name|T
name|pop
parameter_list|()
function_decl|;
DECL|function|top
specifier|inline
specifier|const
name|T
modifier|&
name|top
parameter_list|()
specifier|const
block|{
return|return
name|m_data
operator|.
name|first
argument_list|()
return|;
block|}
private|private:
DECL|function|parent
specifier|static
specifier|inline
name|int
name|parent
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
return|;
block|}
DECL|function|left
specifier|static
specifier|inline
name|int
name|left
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
literal|2
operator|*
name|i
operator|+
literal|1
return|;
block|}
DECL|function|right
specifier|static
specifier|inline
name|int
name|right
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
literal|2
operator|*
name|i
operator|+
literal|2
return|;
block|}
DECL|member|m_data
name|QDataBuffer
argument_list|<
name|T
argument_list|>
name|m_data
decl_stmt|;
block|}
class|;
end_class
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|push
name|void
name|QMaxHeap
argument_list|<
name|T
argument_list|>
operator|::
name|push
parameter_list|(
specifier|const
name|T
modifier|&
name|x
parameter_list|)
block|{
name|int
name|current
init|=
name|m_data
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|parent
init|=
name|QMaxHeap
operator|::
name|parent
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|m_data
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|current
operator|!=
literal|0
operator|&&
name|m_data
operator|.
name|at
argument_list|(
name|parent
argument_list|)
operator|<
name|x
condition|)
block|{
name|m_data
operator|.
name|at
argument_list|(
name|current
argument_list|)
operator|=
name|m_data
operator|.
name|at
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|current
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|QMaxHeap
operator|::
name|parent
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
name|m_data
operator|.
name|at
argument_list|(
name|current
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|pop
name|T
name|QMaxHeap
argument_list|<
name|T
argument_list|>
operator|::
name|pop
parameter_list|()
block|{
name|T
name|result
init|=
name|m_data
operator|.
name|first
argument_list|()
decl_stmt|;
name|T
name|back
init|=
name|m_data
operator|.
name|last
argument_list|()
decl_stmt|;
name|m_data
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_data
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|current
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|left
init|=
name|QMaxHeap
operator|::
name|left
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|QMaxHeap
operator|::
name|right
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|m_data
operator|.
name|size
argument_list|()
condition|)
break|break;
name|int
name|greater
init|=
name|left
decl_stmt|;
if|if
condition|(
name|right
operator|<
name|m_data
operator|.
name|size
argument_list|()
operator|&&
name|m_data
operator|.
name|at
argument_list|(
name|left
argument_list|)
operator|<
name|m_data
operator|.
name|at
argument_list|(
name|right
argument_list|)
condition|)
name|greater
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|m_data
operator|.
name|at
argument_list|(
name|greater
argument_list|)
operator|<
name|back
condition|)
break|break;
name|m_data
operator|.
name|at
argument_list|(
name|current
argument_list|)
operator|=
name|m_data
operator|.
name|at
argument_list|(
name|greater
argument_list|)
expr_stmt|;
name|current
operator|=
name|greater
expr_stmt|;
block|}
name|m_data
operator|.
name|at
argument_list|(
name|current
argument_list|)
operator|=
name|back
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                                 QInt64Hash                                 //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|// Copied from qhash.cpp
end_comment
begin_decl_stmt
DECL|variable|prime_deltas
specifier|static
specifier|const
name|uchar
name|prime_deltas
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|3
block|,
literal|9
block|,
literal|25
block|,
literal|3
block|,
literal|1
block|,
literal|21
block|,
literal|3
block|,
literal|21
block|,
literal|7
block|,
literal|15
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|29
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Copied from qhash.cpp
end_comment
begin_function
DECL|function|primeForNumBits
specifier|static
specifier|inline
name|int
name|primeForNumBits
parameter_list|(
name|int
name|numBits
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|<<
name|numBits
operator|)
operator|+
name|prime_deltas
index|[
name|numBits
index|]
return|;
block|}
end_function
begin_function
DECL|function|primeForCount
specifier|static
specifier|inline
name|int
name|primeForCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
literal|32
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|int
name|mid
init|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|count
operator|>=
literal|1
operator|<<
name|mid
condition|)
name|low
operator|=
name|mid
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|primeForNumBits
argument_list|(
name|high
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Hash set of quint64s. Elements cannot be removed without clearing the
end_comment
begin_comment
comment|// entire set. A value of -1 is used to mark unused entries.
end_comment
begin_class
DECL|class|QInt64Set
class|class
name|QInt64Set
block|{
public|public:
specifier|inline
name|QInt64Set
parameter_list|(
name|int
name|capacity
init|=
literal|64
parameter_list|)
constructor_decl|;
DECL|function|~QInt64Set
specifier|inline
name|~
name|QInt64Set
parameter_list|()
block|{
if|if
condition|(
name|m_array
condition|)
operator|delete
index|[]
name|m_array
expr_stmt|;
block|}
DECL|function|isValid
specifier|inline
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|m_array
return|;
block|}
name|void
name|insert
parameter_list|(
name|quint64
name|key
parameter_list|)
function_decl|;
name|bool
name|contains
parameter_list|(
name|quint64
name|key
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|void
name|clear
parameter_list|()
function_decl|;
private|private:
name|bool
name|rehash
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
DECL|member|UNUSED
specifier|static
specifier|const
name|quint64
name|UNUSED
decl_stmt|;
DECL|member|m_array
name|quint64
modifier|*
name|m_array
decl_stmt|;
DECL|member|m_capacity
name|int
name|m_capacity
decl_stmt|;
DECL|member|m_count
name|int
name|m_count
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|UNUSED
specifier|const
name|quint64
name|QInt64Set
operator|::
name|UNUSED
init|=
name|quint64
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QInt64Set
specifier|inline
name|QInt64Set
operator|::
name|QInt64Set
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|m_capacity
operator|=
name|primeForCount
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
name|m_array
operator|=
operator|new
name|quint64
index|[
name|m_capacity
index|]
expr_stmt|;
if|if
condition|(
name|m_array
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
name|m_capacity
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|rehash
name|bool
name|QInt64Set
operator|::
name|rehash
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|quint64
modifier|*
name|oldArray
init|=
name|m_array
decl_stmt|;
name|int
name|oldCapacity
init|=
name|m_capacity
decl_stmt|;
name|m_capacity
operator|=
name|capacity
expr_stmt|;
name|m_array
operator|=
operator|new
name|quint64
index|[
name|m_capacity
index|]
expr_stmt|;
if|if
condition|(
name|m_array
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldArray
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldCapacity
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|oldArray
index|[
name|i
index|]
operator|!=
name|UNUSED
condition|)
name|insert
argument_list|(
name|oldArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|oldArray
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|m_capacity
operator|=
name|oldCapacity
expr_stmt|;
name|m_array
operator|=
name|oldArray
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|insert
name|void
name|QInt64Set
operator|::
name|insert
parameter_list|(
name|quint64
name|key
parameter_list|)
block|{
if|if
condition|(
name|m_count
operator|>
literal|3
operator|*
name|m_capacity
operator|/
literal|4
condition|)
name|rehash
argument_list|(
name|primeForCount
argument_list|(
literal|2
operator|*
name|m_capacity
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|m_array
argument_list|,
literal|"QInt64Hash<T>::insert"
argument_list|,
literal|"Hash set not allocated."
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|int
argument_list|(
name|key
operator|%
name|m_capacity
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_capacity
condition|;
operator|++
name|i
control|)
block|{
name|index
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|m_capacity
condition|)
name|index
operator|-=
name|m_capacity
expr_stmt|;
if|if
condition|(
name|m_array
index|[
name|index
index|]
operator|==
name|key
condition|)
return|return;
if|if
condition|(
name|m_array
index|[
name|index
index|]
operator|==
name|UNUSED
condition|)
block|{
operator|++
name|m_count
expr_stmt|;
name|m_array
index|[
name|index
index|]
operator|=
name|key
expr_stmt|;
return|return;
block|}
block|}
name|Q_ASSERT_X
argument_list|(
literal|0
argument_list|,
literal|"QInt64Hash<T>::insert"
argument_list|,
literal|"Hash set full."
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|contains
name|bool
name|QInt64Set
operator|::
name|contains
parameter_list|(
name|quint64
name|key
parameter_list|)
specifier|const
block|{
name|Q_ASSERT_X
argument_list|(
name|m_array
argument_list|,
literal|"QInt64Hash<T>::contains"
argument_list|,
literal|"Hash set not allocated."
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|int
argument_list|(
name|key
operator|%
name|m_capacity
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_capacity
condition|;
operator|++
name|i
control|)
block|{
name|index
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|m_capacity
condition|)
name|index
operator|-=
name|m_capacity
expr_stmt|;
if|if
condition|(
name|m_array
index|[
name|index
index|]
operator|==
name|key
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|m_array
index|[
name|index
index|]
operator|==
name|UNUSED
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|clear
specifier|inline
name|void
name|QInt64Set
operator|::
name|clear
parameter_list|()
block|{
name|Q_ASSERT_X
argument_list|(
name|m_array
argument_list|,
literal|"QInt64Hash<T>::clear"
argument_list|,
literal|"Hash set not allocated."
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_capacity
condition|;
operator|++
name|i
control|)
name|m_array
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|m_count
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                                QRingBuffer                                 //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|// T must be POD.
end_comment
begin_class
template|template
parameter_list|<
name|class
name|T
parameter_list|>
class|class
DECL|class|QRingBuffer
name|QRingBuffer
block|{
public|public:
DECL|function|QRingBuffer
specifier|inline
name|QRingBuffer
parameter_list|()
member_init_list|:
name|m_array
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_head
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_capacity
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~QRingBuffer
specifier|inline
name|~
name|QRingBuffer
parameter_list|()
block|{
if|if
condition|(
name|m_array
condition|)
operator|delete
index|[]
name|m_array
expr_stmt|;
block|}
name|bool
name|reallocate
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
DECL|function|head
specifier|inline
specifier|const
name|T
modifier|&
name|head
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|m_array
index|[
name|m_head
index|]
return|;
block|}
specifier|inline
specifier|const
name|T
modifier|&
name|dequeue
parameter_list|()
function_decl|;
specifier|inline
name|void
name|enqueue
parameter_list|(
specifier|const
name|T
modifier|&
name|x
parameter_list|)
function_decl|;
DECL|function|isEmpty
specifier|inline
name|bool
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|m_size
operator|==
literal|0
return|;
block|}
private|private:
DECL|member|m_array
name|T
modifier|*
name|m_array
decl_stmt|;
DECL|member|m_head
name|int
name|m_head
decl_stmt|;
DECL|member|m_size
name|int
name|m_size
decl_stmt|;
DECL|member|m_capacity
name|int
name|m_capacity
decl_stmt|;
block|}
class|;
end_class
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|reallocate
name|bool
name|QRingBuffer
argument_list|<
name|T
argument_list|>
operator|::
name|reallocate
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|T
modifier|*
name|oldArray
init|=
name|m_array
decl_stmt|;
name|m_array
operator|=
operator|new
name|T
index|[
name|capacity
index|]
expr_stmt|;
if|if
condition|(
name|m_array
condition|)
block|{
if|if
condition|(
name|oldArray
condition|)
block|{
if|if
condition|(
name|m_head
operator|+
name|m_size
operator|>
name|m_capacity
condition|)
block|{
name|memcpy
argument_list|(
name|m_array
argument_list|,
name|oldArray
operator|+
name|m_head
argument_list|,
operator|(
name|m_capacity
operator|-
name|m_head
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|m_array
operator|+
operator|(
name|m_capacity
operator|-
name|m_head
operator|)
argument_list|,
name|oldArray
argument_list|,
operator|(
name|m_head
operator|+
name|m_size
operator|-
name|m_capacity
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|m_array
argument_list|,
name|oldArray
operator|+
name|m_head
argument_list|,
name|m_size
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|oldArray
expr_stmt|;
block|}
name|m_capacity
operator|=
name|capacity
expr_stmt|;
name|m_head
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|m_array
operator|=
name|oldArray
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|dequeue
specifier|inline
specifier|const
name|T
modifier|&
name|QRingBuffer
argument_list|<
name|T
argument_list|>
operator|::
name|dequeue
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|m_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_array
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_capacity
operator|>=
name|m_size
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|m_head
decl_stmt|;
if|if
condition|(
operator|++
name|m_head
operator|>=
name|m_capacity
condition|)
name|m_head
operator|-=
name|m_capacity
expr_stmt|;
operator|--
name|m_size
expr_stmt|;
return|return
name|m_array
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|enqueue
specifier|inline
name|void
name|QRingBuffer
argument_list|<
name|T
argument_list|>
operator|::
name|enqueue
parameter_list|(
specifier|const
name|T
modifier|&
name|x
parameter_list|)
block|{
if|if
condition|(
name|m_size
operator|==
name|m_capacity
condition|)
name|reallocate
argument_list|(
name|qMax
argument_list|(
literal|2
operator|*
name|m_capacity
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|m_head
operator|+
name|m_size
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|m_capacity
condition|)
name|index
operator|-=
name|m_capacity
expr_stmt|;
name|m_array
index|[
name|index
index|]
operator|=
name|x
expr_stmt|;
operator|++
name|m_size
expr_stmt|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                               QTriangulator                                //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_class
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
class|class
DECL|class|QTriangulator
name|QTriangulator
block|{
public|public:
DECL|typedef|ShortArray
typedef|typedef
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|6
argument_list|>
name|ShortArray
typedef|;
comment|//================================//
comment|// QTriangulator::ComplexToSimple //
comment|//================================//
friend|friend
class_decl|class
name|ComplexToSimple
class_decl|;
DECL|class|ComplexToSimple
class|class
name|ComplexToSimple
block|{
public|public:
DECL|function|ComplexToSimple
specifier|inline
name|ComplexToSimple
parameter_list|(
name|QTriangulator
argument_list|<
name|T
argument_list|>
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_edges
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_events
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_splits
argument_list|(
literal|0
argument_list|)
block|{ }
name|void
name|decompose
parameter_list|()
function_decl|;
private|private:
DECL|struct|Edge
struct|struct
name|Edge
block|{
DECL|function|upper
specifier|inline
name|int
modifier|&
name|upper
parameter_list|()
block|{
return|return
name|pointingUp
condition|?
name|to
else|:
name|from
return|;
block|}
DECL|function|lower
specifier|inline
name|int
modifier|&
name|lower
parameter_list|()
block|{
return|return
name|pointingUp
condition|?
name|from
else|:
name|to
return|;
block|}
DECL|function|upper
specifier|inline
name|int
name|upper
parameter_list|()
specifier|const
block|{
return|return
name|pointingUp
condition|?
name|to
else|:
name|from
return|;
block|}
DECL|function|lower
specifier|inline
name|int
name|lower
parameter_list|()
specifier|const
block|{
return|return
name|pointingUp
condition|?
name|from
else|:
name|to
return|;
block|}
DECL|member|node
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|node
decl_stmt|;
DECL|member|from
DECL|member|to
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
comment|// vertex
DECL|member|next
DECL|member|previous
name|int
name|next
decl_stmt|,
name|previous
decl_stmt|;
comment|// edge
DECL|member|winding
name|int
name|winding
decl_stmt|;
DECL|member|mayIntersect
name|bool
name|mayIntersect
decl_stmt|;
DECL|member|pointingUp
DECL|member|originallyPointingUp
name|bool
name|pointingUp
decl_stmt|,
name|originallyPointingUp
decl_stmt|;
block|}
struct|;
friend|friend
class_decl|class
name|CompareEdges
class_decl|;
DECL|class|CompareEdges
class|class
name|CompareEdges
block|{
public|public:
DECL|function|CompareEdges
specifier|inline
name|CompareEdges
parameter_list|(
name|ComplexToSimple
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
block|{ }
name|bool
name|operator
name|()
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|m_parent
name|ComplexToSimple
modifier|*
name|m_parent
decl_stmt|;
block|}
class|;
DECL|struct|Intersection
struct|struct
name|Intersection
block|{
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Intersection
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|other
operator|.
name|intersectionPoint
operator|<
name|intersectionPoint
return|;
block|}
DECL|member|intersectionPoint
name|QIntersectionPoint
name|intersectionPoint
decl_stmt|;
DECL|member|vertex
name|int
name|vertex
decl_stmt|;
DECL|member|leftEdge
name|int
name|leftEdge
decl_stmt|;
DECL|member|rightEdge
name|int
name|rightEdge
decl_stmt|;
block|}
struct|;
DECL|struct|Split
struct|struct
name|Split
block|{
DECL|member|vertex
name|int
name|vertex
decl_stmt|;
DECL|member|edge
name|int
name|edge
decl_stmt|;
DECL|member|accurate
name|bool
name|accurate
decl_stmt|;
block|}
struct|;
DECL|struct|Event
struct|struct
name|Event
block|{
DECL|enum|Type
DECL|enumerator|Upper
DECL|enumerator|Lower
enum|enum
name|Type
block|{
name|Upper
block|,
name|Lower
block|}
enum|;
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Event
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
DECL|member|point
name|QPodPoint
name|point
decl_stmt|;
DECL|member|type
name|Type
name|type
decl_stmt|;
DECL|member|edge
name|int
name|edge
decl_stmt|;
block|}
struct|;
ifdef|#
directive|ifdef
name|Q_TRIANGULATOR_DEBUG
friend|friend
class_decl|class
name|DebugDialog
class_decl|;
friend|friend
class_decl|class
name|QTriangulator
class_decl|;
DECL|class|DebugDialog
class|class
name|DebugDialog
super|:
specifier|public
name|QDialog
block|{
public|public:
name|DebugDialog
parameter_list|(
name|ComplexToSimple
modifier|*
name|parent
parameter_list|,
name|int
name|currentVertex
parameter_list|)
constructor_decl|;
protected|protected:
name|void
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
function_decl|;
name|void
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
parameter_list|)
function_decl|;
name|void
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
parameter_list|)
function_decl|;
name|void
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
parameter_list|)
function_decl|;
private|private:
DECL|member|m_parent
name|ComplexToSimple
modifier|*
name|m_parent
decl_stmt|;
DECL|member|m_window
name|QRectF
name|m_window
decl_stmt|;
DECL|member|m_lastMousePos
name|QPoint
name|m_lastMousePos
decl_stmt|;
DECL|member|m_vertex
name|int
name|m_vertex
decl_stmt|;
block|}
class|;
endif|#
directive|endif
name|void
name|initEdges
parameter_list|()
function_decl|;
name|bool
name|calculateIntersection
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
function_decl|;
name|bool
name|edgeIsLeftOfEdge
parameter_list|(
name|int
name|leftEdgeIndex
parameter_list|,
name|int
name|rightEdgeIndex
parameter_list|)
specifier|const
function_decl|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|searchEdgeLeftOf
parameter_list|(
name|int
name|edgeIndex
parameter_list|)
specifier|const
function_decl|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|searchEdgeLeftOf
parameter_list|(
name|int
name|edgeIndex
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|after
parameter_list|)
specifier|const
function_decl|;
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|bounds
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|point
parameter_list|)
specifier|const
function_decl|;
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|outerBounds
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|point
parameter_list|)
specifier|const
function_decl|;
name|void
name|splitEdgeListRange
parameter_list|(
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftmost
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|rightmost
parameter_list|,
name|int
name|vertex
parameter_list|,
specifier|const
name|QIntersectionPoint
modifier|&
name|intersectionPoint
parameter_list|)
function_decl|;
name|void
name|reorderEdgeListRange
parameter_list|(
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftmost
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|rightmost
parameter_list|)
function_decl|;
name|void
name|sortEdgeList
parameter_list|(
specifier|const
name|QPodPoint
name|eventPoint
parameter_list|)
function_decl|;
name|void
name|fillPriorityQueue
parameter_list|()
function_decl|;
name|void
name|calculateIntersections
parameter_list|()
function_decl|;
name|int
name|splitEdge
parameter_list|(
name|int
name|splitIndex
parameter_list|)
function_decl|;
name|bool
name|splitEdgesAtIntersections
parameter_list|()
function_decl|;
name|void
name|insertEdgeIntoVectorIfWanted
parameter_list|(
name|ShortArray
modifier|&
name|orderedEdges
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
name|void
name|removeUnwantedEdgesAndConnect
parameter_list|()
function_decl|;
name|void
name|removeUnusedPoints
parameter_list|()
function_decl|;
DECL|member|m_parent
name|QTriangulator
modifier|*
name|m_parent
decl_stmt|;
DECL|member|m_edges
name|QDataBuffer
argument_list|<
name|Edge
argument_list|>
name|m_edges
decl_stmt|;
DECL|member|m_edgeList
name|QRBTree
argument_list|<
name|int
argument_list|>
name|m_edgeList
decl_stmt|;
DECL|member|m_events
name|QDataBuffer
argument_list|<
name|Event
argument_list|>
name|m_events
decl_stmt|;
DECL|member|m_splits
name|QDataBuffer
argument_list|<
name|Split
argument_list|>
name|m_splits
decl_stmt|;
DECL|member|m_topIntersection
name|QMaxHeap
argument_list|<
name|Intersection
argument_list|>
name|m_topIntersection
decl_stmt|;
DECL|member|m_processedEdgePairs
name|QInt64Set
name|m_processedEdgePairs
decl_stmt|;
DECL|member|m_initialPointCount
name|int
name|m_initialPointCount
decl_stmt|;
block|}
class|;
ifdef|#
directive|ifdef
name|Q_TRIANGULATOR_DEBUG
friend|friend
class_decl|class
name|ComplexToSimple
operator|::
name|DebugDialog
class_decl|;
endif|#
directive|endif
comment|//=================================//
comment|// QTriangulator::SimpleToMonotone //
comment|//=================================//
friend|friend
class_decl|class
name|SimpleToMonotone
class_decl|;
DECL|class|SimpleToMonotone
class|class
name|SimpleToMonotone
block|{
public|public:
DECL|function|SimpleToMonotone
specifier|inline
name|SimpleToMonotone
parameter_list|(
name|QTriangulator
argument_list|<
name|T
argument_list|>
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_edges
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_upperVertex
argument_list|(
literal|0
argument_list|)
block|{ }
name|void
name|decompose
parameter_list|()
function_decl|;
private|private:
DECL|enum|VertexType
DECL|enumerator|MergeVertex
DECL|enumerator|EndVertex
DECL|enumerator|RegularVertex
DECL|enumerator|StartVertex
DECL|enumerator|SplitVertex
enum|enum
name|VertexType
block|{
name|MergeVertex
block|,
name|EndVertex
block|,
name|RegularVertex
block|,
name|StartVertex
block|,
name|SplitVertex
block|}
enum|;
DECL|struct|Edge
struct|struct
name|Edge
block|{
DECL|member|node
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|node
decl_stmt|;
DECL|member|helper
DECL|member|twin
DECL|member|next
DECL|member|previous
name|int
name|helper
decl_stmt|,
name|twin
decl_stmt|,
name|next
decl_stmt|,
name|previous
decl_stmt|;
DECL|member|from
DECL|member|to
name|T
name|from
decl_stmt|,
name|to
decl_stmt|;
DECL|member|type
name|VertexType
name|type
decl_stmt|;
DECL|member|pointingUp
name|bool
name|pointingUp
decl_stmt|;
DECL|function|upper
name|int
name|upper
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|pointingUp
condition|?
name|to
else|:
name|from
operator|)
return|;
block|}
DECL|function|lower
name|int
name|lower
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|pointingUp
condition|?
name|from
else|:
name|to
operator|)
return|;
block|}
block|}
struct|;
friend|friend
class_decl|class
name|CompareVertices
class_decl|;
DECL|class|CompareVertices
class|class
name|CompareVertices
block|{
public|public:
DECL|function|CompareVertices
name|CompareVertices
parameter_list|(
name|SimpleToMonotone
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
block|{ }
name|bool
name|operator
name|()
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|m_parent
name|SimpleToMonotone
modifier|*
name|m_parent
decl_stmt|;
block|}
class|;
name|void
name|setupDataStructures
parameter_list|()
function_decl|;
name|void
name|removeZeroLengthEdges
parameter_list|()
function_decl|;
name|void
name|fillPriorityQueue
parameter_list|()
function_decl|;
name|bool
name|edgeIsLeftOfEdge
parameter_list|(
name|int
name|leftEdgeIndex
parameter_list|,
name|int
name|rightEdgeIndex
parameter_list|)
specifier|const
function_decl|;
comment|// Returns the rightmost edge not to the right of the given edge.
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|searchEdgeLeftOfEdge
parameter_list|(
name|int
name|edgeIndex
parameter_list|)
specifier|const
function_decl|;
comment|// Returns the rightmost edge left of the given point.
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|searchEdgeLeftOfPoint
parameter_list|(
name|int
name|pointIndex
parameter_list|)
specifier|const
function_decl|;
name|void
name|classifyVertex
parameter_list|(
name|int
name|i
parameter_list|)
function_decl|;
name|void
name|classifyVertices
parameter_list|()
function_decl|;
name|bool
name|pointIsInSector
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v2
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v3
parameter_list|)
function_decl|;
name|bool
name|pointIsInSector
parameter_list|(
name|int
name|vertex
parameter_list|,
name|int
name|sector
parameter_list|)
function_decl|;
name|int
name|findSector
parameter_list|(
name|int
name|edge
parameter_list|,
name|int
name|vertex
parameter_list|)
function_decl|;
name|void
name|createDiagonal
parameter_list|(
name|int
name|lower
parameter_list|,
name|int
name|upper
parameter_list|)
function_decl|;
name|void
name|monotoneDecomposition
parameter_list|()
function_decl|;
DECL|member|m_parent
name|QTriangulator
modifier|*
name|m_parent
decl_stmt|;
DECL|member|m_edgeList
name|QRBTree
argument_list|<
name|int
argument_list|>
name|m_edgeList
decl_stmt|;
DECL|member|m_edges
name|QDataBuffer
argument_list|<
name|Edge
argument_list|>
name|m_edges
decl_stmt|;
DECL|member|m_upperVertex
name|QDataBuffer
argument_list|<
name|int
argument_list|>
name|m_upperVertex
decl_stmt|;
DECL|member|m_clockwiseOrder
name|bool
name|m_clockwiseOrder
decl_stmt|;
block|}
class|;
comment|//====================================//
comment|// QTriangulator::MonotoneToTriangles //
comment|//====================================//
friend|friend
class_decl|class
name|MonotoneToTriangles
class_decl|;
DECL|class|MonotoneToTriangles
class|class
name|MonotoneToTriangles
block|{
public|public:
DECL|function|MonotoneToTriangles
specifier|inline
name|MonotoneToTriangles
parameter_list|(
name|QTriangulator
argument_list|<
name|T
argument_list|>
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
block|{ }
name|void
name|decompose
parameter_list|()
function_decl|;
private|private:
DECL|function|indices
specifier|inline
name|T
name|indices
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|index
operator|+
name|m_first
argument_list|)
return|;
block|}
DECL|function|next
specifier|inline
name|int
name|next
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
name|m_length
return|;
block|}
DECL|function|previous
specifier|inline
name|int
name|previous
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|index
operator|+
name|m_length
operator|-
literal|1
operator|)
operator|%
name|m_length
return|;
block|}
DECL|function|less
specifier|inline
name|bool
name|less
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
specifier|const
block|{
return|return
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|indices
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|indices
argument_list|(
name|j
argument_list|)
argument_list|)
return|;
block|}
DECL|function|leftOfEdge
specifier|inline
name|bool
name|leftOfEdge
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
specifier|const
block|{
return|return
name|qPointIsLeftOfLine
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|indices
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|indices
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|indices
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|member|m_parent
name|QTriangulator
argument_list|<
name|T
argument_list|>
modifier|*
name|m_parent
decl_stmt|;
DECL|member|m_first
name|int
name|m_first
decl_stmt|;
DECL|member|m_length
name|int
name|m_length
decl_stmt|;
block|}
class|;
DECL|function|QTriangulator
specifier|inline
name|QTriangulator
parameter_list|()
member_init_list|:
name|m_vertices
argument_list|(
literal|0
argument_list|)
block|{ }
comment|// Call this only once.
name|void
name|initialize
parameter_list|(
specifier|const
name|qreal
modifier|*
name|polygon
parameter_list|,
name|int
name|count
parameter_list|,
name|uint
name|hint
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
function_decl|;
comment|// Call this only once.
name|void
name|initialize
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
function_decl|;
comment|// Call this only once.
name|void
name|initialize
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
function_decl|;
comment|// Call either triangulate() or polyline() only once.
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|triangulate
parameter_list|()
function_decl|;
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|polyline
parameter_list|()
function_decl|;
private|private:
DECL|member|m_vertices
name|QDataBuffer
argument_list|<
name|QPodPoint
argument_list|>
name|m_vertices
decl_stmt|;
DECL|member|m_indices
name|QVector
argument_list|<
name|T
argument_list|>
name|m_indices
decl_stmt|;
DECL|member|m_hint
name|uint
name|m_hint
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                               QTriangulator                                //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|triangulate
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|triangulate
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
name|qAbs
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
operator|<
operator|(
literal|1
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qAbs
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
operator|<
operator|(
literal|1
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|m_hint
operator|&
operator|(
name|QVectorPath
operator|::
name|OddEvenFill
operator||
name|QVectorPath
operator|::
name|WindingFill
operator|)
operator|)
condition|)
name|m_hint
operator||=
name|QVectorPath
operator|::
name|OddEvenFill
expr_stmt|;
if|if
condition|(
name|m_hint
operator|&
name|QVectorPath
operator|::
name|NonConvexShapeMask
condition|)
block|{
name|ComplexToSimple
name|c2s
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|c2s
operator|.
name|decompose
argument_list|()
expr_stmt|;
name|SimpleToMonotone
name|s2m
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|s2m
operator|.
name|decompose
argument_list|()
expr_stmt|;
block|}
name|MonotoneToTriangles
name|m2t
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|m2t
operator|.
name|decompose
argument_list|()
expr_stmt|;
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|indices
operator|=
name|m_indices
expr_stmt|;
name|result
operator|.
name|vertices
operator|.
name|resize
argument_list|(
literal|2
operator|*
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|vertices
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|qreal
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
operator|/
name|Q_FIXED_POINT_SCALE
expr_stmt|;
name|result
operator|.
name|vertices
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|qreal
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
operator|/
name|Q_FIXED_POINT_SCALE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|polyline
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|polyline
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
name|qAbs
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
operator|<
operator|(
literal|1
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qAbs
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
operator|<
operator|(
literal|1
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|m_hint
operator|&
operator|(
name|QVectorPath
operator|::
name|OddEvenFill
operator||
name|QVectorPath
operator|::
name|WindingFill
operator|)
operator|)
condition|)
name|m_hint
operator||=
name|QVectorPath
operator|::
name|OddEvenFill
expr_stmt|;
if|if
condition|(
name|m_hint
operator|&
name|QVectorPath
operator|::
name|NonConvexShapeMask
condition|)
block|{
name|ComplexToSimple
name|c2s
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|c2s
operator|.
name|decompose
argument_list|()
expr_stmt|;
block|}
name|QVertexSet
argument_list|<
name|T
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|indices
operator|=
name|m_indices
expr_stmt|;
name|result
operator|.
name|vertices
operator|.
name|resize
argument_list|(
literal|2
operator|*
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|vertices
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|qreal
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
operator|/
name|Q_FIXED_POINT_SCALE
expr_stmt|;
name|result
operator|.
name|vertices
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|qreal
argument_list|(
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
operator|/
name|Q_FIXED_POINT_SCALE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|initialize
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|initialize
parameter_list|(
specifier|const
name|qreal
modifier|*
name|polygon
parameter_list|,
name|int
name|count
parameter_list|,
name|uint
name|hint
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|m_hint
operator|=
name|hint
expr_stmt|;
name|m_vertices
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|m_indices
operator|.
name|resize
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|polygon
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
name|polygon
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
operator|=
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
operator|=
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
name|m_indices
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|m_indices
index|[
name|count
index|]
operator|=
name|T
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//Q_TRIANGULATE_END_OF_POLYGON
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|initialize
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|initialize
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|m_hint
operator|=
name|path
operator|.
name|hints
argument_list|()
expr_stmt|;
comment|// Curved paths will be converted to complex polygons.
name|m_hint
operator|&=
operator|~
name|QVectorPath
operator|::
name|CurvedShapeMask
expr_stmt|;
specifier|const
name|qreal
modifier|*
name|p
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|ElementType
modifier|*
name|e
init|=
name|path
operator|.
name|elements
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
operator|,
operator|++
name|e
operator|,
name|p
operator|+=
literal|2
control|)
block|{
switch|switch
condition|(
operator|*
name|e
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
if|if
condition|(
operator|!
name|m_indices
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Q_TRIANGULATE_END_OF_POLYGON
comment|// Fall through.
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|resize
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|x
operator|=
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|y
operator|=
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|qreal
name|pts
index|[
literal|8
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|2
operator|*
name|i
operator|-
literal|2
index|]
argument_list|,
name|p
index|[
literal|2
operator|*
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|pts
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
operator|&
name|pts
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|pts
index|[
name|i
index|]
operator|*=
name|lod
expr_stmt|;
name|QBezier
name|bezier
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|QPointF
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|,
name|pts
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|pts
index|[
literal|4
index|]
argument_list|,
name|pts
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|pts
index|[
literal|6
index|]
argument_list|,
name|pts
index|[
literal|7
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|QPolygonF
name|poly
init|=
name|bezier
operator|.
name|toPolygon
argument_list|()
decl_stmt|;
comment|// Skip first point, it already exists in 'm_vertices'.
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|poly
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|resize
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|x
operator|=
name|qRound
argument_list|(
name|poly
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|x
argument_list|()
operator|*
name|Q_FIXED_POINT_SCALE
operator|/
name|lod
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|y
operator|=
name|qRound
argument_list|(
name|poly
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|y
argument_list|()
operator|*
name|Q_FIXED_POINT_SCALE
operator|/
name|lod
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|+=
literal|2
expr_stmt|;
name|e
operator|+=
literal|2
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|0
argument_list|,
literal|"QTriangulator::triangulate"
argument_list|,
literal|"Unexpected element type."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
operator|,
name|p
operator|+=
literal|2
control|)
block|{
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|resize
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|x
operator|=
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|last
argument_list|()
operator|.
name|y
operator|=
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
expr_stmt|;
block|}
block|}
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Q_TRIANGULATE_END_OF_POLYGON
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|initialize
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|initialize
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|initialize
argument_list|(
name|qtVectorPathForPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|matrix
argument_list|,
name|lod
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                       QTriangulator::ComplexToSimple                       //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|decompose
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|decompose
parameter_list|()
block|{
name|m_initialPointCount
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
expr_stmt|;
name|initEdges
argument_list|()
expr_stmt|;
do|do
block|{
name|calculateIntersections
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|splitEdgesAtIntersections
argument_list|()
condition|)
do|;
name|removeUnwantedEdgesAndConnect
argument_list|()
expr_stmt|;
name|removeUnusedPoints
argument_list|()
expr_stmt|;
name|m_parent
operator|->
name|m_indices
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QBitArray
name|processed
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|first
init|=
literal|0
init|;
name|first
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|first
control|)
block|{
comment|// If already processed, or if unused path, skip.
if|if
condition|(
name|processed
operator|.
name|at
argument_list|(
name|first
argument_list|)
operator|||
name|m_edges
operator|.
name|at
argument_list|(
name|first
argument_list|)
operator|.
name|next
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|int
name|i
init|=
name|first
decl_stmt|;
do|do
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|processed
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
operator|.
name|previous
operator|==
name|i
argument_list|)
expr_stmt|;
name|m_parent
operator|->
name|m_indices
operator|.
name|push_back
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
name|processed
operator|.
name|setBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
expr_stmt|;
comment|// CCW order
block|}
do|while
condition|(
name|i
operator|!=
name|first
condition|)
do|;
name|m_parent
operator|->
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Q_TRIANGULATE_END_OF_POLYGON
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|initEdges
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|initEdges
parameter_list|()
block|{
comment|// Initialize edge structure.
comment|// 'next' and 'previous' are not being initialized at this point.
name|int
name|first
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|T
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// Q_TRIANGULATE_END_OF_POLYGON
if|if
condition|(
name|m_edges
operator|.
name|size
argument_list|()
operator|!=
name|first
condition|)
name|m_edges
operator|.
name|last
argument_list|()
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|first
argument_list|)
operator|.
name|from
expr_stmt|;
name|first
operator|=
name|m_edges
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|+
literal|1
operator|<
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// {node, from, to, next, previous, winding, mayIntersect, pointingUp, originallyPointingUp}
name|Edge
name|edge
init|=
block|{
literal|0
block|,
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|i
argument_list|)
block|,
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|}
decl_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|!=
name|m_edges
operator|.
name|size
argument_list|()
condition|)
name|m_edges
operator|.
name|last
argument_list|()
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|first
argument_list|)
operator|.
name|from
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|originallyPointingUp
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Return true if new intersection was found
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|calculateIntersection
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|calculateIntersection
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
specifier|const
name|Edge
modifier|&
name|e1
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|left
argument_list|)
decl_stmt|;
specifier|const
name|Edge
modifier|&
name|e2
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|right
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|e1
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|e1
operator|.
name|to
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|e2
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|e2
operator|.
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|qMax
argument_list|(
name|u1
operator|.
name|x
argument_list|,
name|u2
operator|.
name|x
argument_list|)
operator|<=
name|qMin
argument_list|(
name|v1
operator|.
name|x
argument_list|,
name|v2
operator|.
name|x
argument_list|)
condition|)
return|return
literal|false
return|;
name|quint64
name|key
init|=
operator|(
name|left
operator|>
name|right
condition|?
operator|(
name|quint64
argument_list|(
name|right
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|quint64
argument_list|(
name|left
argument_list|)
else|:
operator|(
name|quint64
argument_list|(
name|left
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|quint64
argument_list|(
name|right
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|m_processedEdgePairs
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
return|return
literal|false
return|;
name|m_processedEdgePairs
operator|.
name|insert
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|Intersection
name|intersection
decl_stmt|;
name|intersection
operator|.
name|leftEdge
operator|=
name|left
expr_stmt|;
name|intersection
operator|.
name|rightEdge
operator|=
name|right
expr_stmt|;
name|intersection
operator|.
name|intersectionPoint
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qIntersectionPoint
argument_list|)
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intersection
operator|.
name|intersectionPoint
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|intersectionPoint
operator|.
name|isOnLine
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|intersectionPoint
operator|.
name|isOnLine
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
argument_list|)
expr_stmt|;
name|intersection
operator|.
name|vertex
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
expr_stmt|;
name|m_topIntersection
operator|.
name|push
argument_list|(
name|intersection
argument_list|)
expr_stmt|;
name|m_parent
operator|->
name|m_vertices
operator|.
name|add
argument_list|(
name|intersection
operator|.
name|intersectionPoint
operator|.
name|round
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|edgeIsLeftOfEdge
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|edgeIsLeftOfEdge
parameter_list|(
name|int
name|leftEdgeIndex
parameter_list|,
name|int
name|rightEdgeIndex
parameter_list|)
specifier|const
block|{
specifier|const
name|Edge
modifier|&
name|leftEdge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeIndex
argument_list|)
decl_stmt|;
specifier|const
name|Edge
modifier|&
name|rightEdge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|rightEdgeIndex
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|rightEdge
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|l
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|rightEdge
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|upper
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|leftEdge
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|upper
operator|.
name|x
operator|<
name|qMin
argument_list|(
name|l
operator|.
name|x
argument_list|,
name|u
operator|.
name|x
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|upper
operator|.
name|x
operator|>
name|qMax
argument_list|(
name|l
operator|.
name|x
argument_list|,
name|u
operator|.
name|x
argument_list|)
condition|)
return|return
literal|false
return|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|upper
argument_list|,
name|l
argument_list|,
name|u
argument_list|)
decl_stmt|;
comment|// d< 0: left, d> 0: right, d == 0: on top
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|leftEdge
operator|.
name|lower
argument_list|()
argument_list|)
argument_list|,
name|l
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
name|d
operator|<
literal|0
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|searchEdgeLeftOf
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|searchEdgeLeftOf
parameter_list|(
name|int
name|edgeIndex
parameter_list|)
specifier|const
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_edgeList
operator|.
name|root
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|edgeIsLeftOfEdge
argument_list|(
name|edgeIndex
argument_list|,
name|current
operator|->
name|data
argument_list|)
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|searchEdgeLeftOf
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|searchEdgeLeftOf
parameter_list|(
name|int
name|edgeIndex
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|after
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|m_edgeList
operator|.
name|root
condition|)
return|return
name|after
return|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|result
init|=
name|after
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
operator|(
name|after
condition|?
name|m_edgeList
operator|.
name|next
argument_list|(
name|after
argument_list|)
else|:
name|m_edgeList
operator|.
name|front
argument_list|(
name|m_edgeList
operator|.
name|root
argument_list|)
operator|)
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|edgeIsLeftOfEdge
argument_list|(
name|edgeIndex
argument_list|,
name|current
operator|->
name|data
argument_list|)
condition|)
return|return
name|result
return|;
name|result
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|bounds
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|bounds
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_edgeList
operator|.
name|root
decl_stmt|;
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|result
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|first
operator|=
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
break|break;
block|}
name|current
operator|=
operator|(
name|d
operator|<
literal|0
condition|?
name|current
operator|->
name|left
else|:
name|current
operator|->
name|right
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|==
literal|0
condition|)
return|return
name|result
return|;
name|current
operator|=
name|result
operator|.
name|first
operator|->
name|left
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|first
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
name|current
operator|=
name|result
operator|.
name|second
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|outerBounds
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|outerBounds
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_edgeList
operator|.
name|root
decl_stmt|;
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|result
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|first
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current
condition|)
return|return
name|result
return|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|mid
init|=
name|current
decl_stmt|;
name|current
operator|=
name|mid
operator|->
name|left
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|first
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
name|current
operator|=
name|mid
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|splitEdgeListRange
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|splitEdgeListRange
parameter_list|(
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftmost
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|rightmost
parameter_list|,
name|int
name|vertex
parameter_list|,
specifier|const
name|QIntersectionPoint
modifier|&
name|intersectionPoint
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|leftmost
operator|&&
name|rightmost
argument_list|)
expr_stmt|;
comment|// Split.
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|u
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|leftmost
operator|->
name|data
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|leftmost
operator|->
name|data
argument_list|)
operator|.
name|to
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|intersectionPoint
operator|.
name|isOnLine
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|Split
name|split
init|=
block|{
name|vertex
block|,
name|leftmost
operator|->
name|data
block|,
name|intersectionPoint
operator|.
name|isAccurate
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|intersectionPoint
operator|.
name|xOffset
operator|.
name|numerator
operator|!=
literal|0
operator|||
name|intersectionPoint
operator|.
name|yOffset
operator|.
name|numerator
operator|!=
literal|0
operator|||
operator|(
name|intersectionPoint
operator|.
name|upperLeft
operator|!=
name|u
operator|&&
name|intersectionPoint
operator|.
name|upperLeft
operator|!=
name|v
operator|)
condition|)
name|m_splits
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftmost
operator|==
name|rightmost
condition|)
break|break;
name|leftmost
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|leftmost
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|reorderEdgeListRange
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|reorderEdgeListRange
parameter_list|(
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftmost
parameter_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|rightmost
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|leftmost
operator|&&
name|rightmost
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|storeLeftmost
init|=
name|leftmost
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|storeRightmost
init|=
name|rightmost
decl_stmt|;
comment|// Reorder.
while|while
condition|(
name|leftmost
operator|!=
name|rightmost
condition|)
block|{
name|Edge
modifier|&
name|left
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|leftmost
operator|->
name|data
argument_list|)
decl_stmt|;
name|Edge
modifier|&
name|right
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|rightmost
operator|->
name|data
argument_list|)
decl_stmt|;
name|qSwap
argument_list|(
name|left
operator|.
name|node
argument_list|,
name|right
operator|.
name|node
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|leftmost
operator|->
name|data
argument_list|,
name|rightmost
operator|->
name|data
argument_list|)
expr_stmt|;
name|leftmost
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|leftmost
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftmost
operator|==
name|rightmost
condition|)
break|break;
name|rightmost
operator|=
name|m_edgeList
operator|.
name|previous
argument_list|(
name|rightmost
argument_list|)
expr_stmt|;
block|}
name|rightmost
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|storeRightmost
argument_list|)
expr_stmt|;
name|leftmost
operator|=
name|m_edgeList
operator|.
name|previous
argument_list|(
name|storeLeftmost
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftmost
condition|)
name|calculateIntersection
argument_list|(
name|leftmost
operator|->
name|data
argument_list|,
name|storeLeftmost
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightmost
condition|)
name|calculateIntersection
argument_list|(
name|storeRightmost
operator|->
name|data
argument_list|,
name|rightmost
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|sortEdgeList
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|sortEdgeList
parameter_list|(
specifier|const
name|QPodPoint
name|eventPoint
parameter_list|)
block|{
name|QIntersectionPoint
name|eventPoint2
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qIntersectionPoint
argument_list|)
argument_list|(
name|eventPoint
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|m_topIntersection
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_topIntersection
operator|.
name|top
argument_list|()
operator|.
name|intersectionPoint
operator|<
name|eventPoint2
condition|)
block|{
name|Intersection
name|intersection
init|=
name|m_topIntersection
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QIntersectionPoint
name|currentIntersectionPoint
init|=
name|intersection
operator|.
name|intersectionPoint
decl_stmt|;
name|int
name|currentVertex
init|=
name|intersection
operator|.
name|vertex
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftmost
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|intersection
operator|.
name|leftEdge
argument_list|)
operator|.
name|node
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|rightmost
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|intersection
operator|.
name|rightEdge
argument_list|)
operator|.
name|node
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|previous
init|=
name|m_edgeList
operator|.
name|previous
argument_list|(
name|leftmost
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|previous
condition|)
break|break;
specifier|const
name|Edge
modifier|&
name|edge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|previous
operator|->
name|data
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|edge
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|edge
operator|.
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentIntersectionPoint
operator|.
name|isOnLine
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|currentIntersectionPoint
operator|.
name|isAccurate
argument_list|()
operator|||
name|qCross
argument_list|(
name|currentIntersectionPoint
operator|.
name|upperLeft
operator|-
name|u
argument_list|,
name|v
operator|-
name|u
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|leftmost
operator|=
name|previous
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|next
init|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|rightmost
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
break|break;
specifier|const
name|Edge
modifier|&
name|edge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|next
operator|->
name|data
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|edge
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|qint32
operator|)
name|edge
operator|.
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentIntersectionPoint
operator|.
name|isOnLine
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|currentIntersectionPoint
operator|.
name|isAccurate
argument_list|()
operator|||
name|qCross
argument_list|(
name|currentIntersectionPoint
operator|.
name|upperLeft
operator|-
name|u
argument_list|,
name|v
operator|-
name|u
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|rightmost
operator|=
name|next
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|leftmost
operator|&&
name|rightmost
argument_list|)
expr_stmt|;
name|splitEdgeListRange
argument_list|(
name|leftmost
argument_list|,
name|rightmost
argument_list|,
name|currentVertex
argument_list|,
name|currentIntersectionPoint
argument_list|)
expr_stmt|;
name|reorderEdgeListRange
argument_list|(
name|leftmost
argument_list|,
name|rightmost
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|m_topIntersection
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_topIntersection
operator|.
name|top
argument_list|()
operator|.
name|intersectionPoint
operator|<=
name|currentIntersectionPoint
condition|)
name|m_topIntersection
operator|.
name|pop
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_TRIANGULATOR_DEBUG
name|DebugDialog
name|dialog
argument_list|(
name|this
argument_list|,
name|intersection
operator|.
name|vertex
argument_list|)
decl_stmt|;
name|dialog
operator|.
name|exec
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|fillPriorityQueue
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|fillPriorityQueue
parameter_list|()
block|{
name|m_events
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_events
operator|.
name|reserve
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
operator|==
operator|-
literal|1
operator|&&
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|==
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|originallyPointingUp
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|==
operator|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Ignore zero-length edges.
if|if
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|!=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
condition|)
block|{
name|QPodPoint
name|upper
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|QPodPoint
name|lower
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
name|Event
name|upperEvent
init|=
block|{
block|{
name|upper
operator|.
name|x
block|,
name|upper
operator|.
name|y
block|}
block|,
name|Event
operator|::
name|Upper
block|,
name|i
block|}
decl_stmt|;
name|Event
name|lowerEvent
init|=
block|{
block|{
name|lower
operator|.
name|x
block|,
name|lower
operator|.
name|y
block|}
block|,
name|Event
operator|::
name|Lower
block|,
name|i
block|}
decl_stmt|;
name|m_events
operator|.
name|add
argument_list|(
name|upperEvent
argument_list|)
expr_stmt|;
name|m_events
operator|.
name|add
argument_list|(
name|lowerEvent
argument_list|)
expr_stmt|;
block|}
block|}
comment|//qSort(m_events.data(), m_events.data() + m_events.size());
name|sort
argument_list|(
name|m_events
operator|.
name|data
argument_list|()
argument_list|,
name|m_events
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|calculateIntersections
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|calculateIntersections
parameter_list|()
block|{
name|fillPriorityQueue
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_topIntersection
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|root
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Find all intersection points.
while|while
condition|(
operator|!
name|m_events
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Event
name|event
init|=
name|m_events
operator|.
name|last
argument_list|()
decl_stmt|;
name|sortEdgeList
argument_list|(
name|event
operator|.
name|point
argument_list|)
expr_stmt|;
comment|// Find all edges in the edge list that contain the current vertex and mark them to be split later.
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|range
init|=
name|bounds
argument_list|(
name|event
operator|.
name|point
argument_list|)
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftNode
init|=
name|range
operator|.
name|first
condition|?
name|m_edgeList
operator|.
name|previous
argument_list|(
name|range
operator|.
name|first
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|vertex
init|=
operator|(
name|event
operator|.
name|type
operator|==
name|Event
operator|::
name|Upper
condition|?
name|m_edges
operator|.
name|at
argument_list|(
name|event
operator|.
name|edge
argument_list|)
operator|.
name|upper
argument_list|()
else|:
name|m_edges
operator|.
name|at
argument_list|(
name|event
operator|.
name|edge
argument_list|)
operator|.
name|lower
argument_list|()
operator|)
decl_stmt|;
name|QIntersectionPoint
name|eventPoint
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qIntersectionPoint
argument_list|)
argument_list|(
name|event
operator|.
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|first
operator|!=
literal|0
condition|)
block|{
name|splitEdgeListRange
argument_list|(
name|range
operator|.
name|first
argument_list|,
name|range
operator|.
name|second
argument_list|,
name|vertex
argument_list|,
name|eventPoint
argument_list|)
expr_stmt|;
name|reorderEdgeListRange
argument_list|(
name|range
operator|.
name|first
argument_list|,
name|range
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
comment|// Handle the edges with start or end point in the current vertex.
while|while
condition|(
operator|!
name|m_events
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_events
operator|.
name|last
argument_list|()
operator|.
name|point
operator|==
name|event
operator|.
name|point
condition|)
block|{
name|event
operator|=
name|m_events
operator|.
name|last
argument_list|()
expr_stmt|;
name|m_events
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|int
name|i
init|=
name|event
operator|.
name|edge
decl_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
condition|)
block|{
comment|// Remove edge from edge list.
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|type
operator|==
name|Event
operator|::
name|Lower
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|left
init|=
name|m_edgeList
operator|.
name|previous
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|right
init|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
decl_stmt|;
name|m_edgeList
operator|.
name|deleteNode
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left
operator|||
operator|!
name|right
condition|)
continue|continue;
name|calculateIntersection
argument_list|(
name|left
operator|->
name|data
argument_list|,
name|right
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert edge into edge list.
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|type
operator|==
name|Event
operator|::
name|Upper
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|left
init|=
name|searchEdgeLeftOf
argument_list|(
name|i
argument_list|,
name|leftNode
argument_list|)
decl_stmt|;
name|m_edgeList
operator|.
name|attachAfter
argument_list|(
name|left
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|=
name|m_edgeList
operator|.
name|newNode
argument_list|()
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|->
name|data
operator|=
name|i
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|right
init|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
condition|)
name|calculateIntersection
argument_list|(
name|left
operator|->
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
condition|)
name|calculateIntersection
argument_list|(
name|i
argument_list|,
name|right
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|m_topIntersection
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_topIntersection
operator|.
name|top
argument_list|()
operator|.
name|intersectionPoint
operator|<=
name|eventPoint
condition|)
name|m_topIntersection
operator|.
name|pop
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_TRIANGULATOR_DEBUG
name|DebugDialog
name|dialog
argument_list|(
name|this
argument_list|,
name|vertex
argument_list|)
decl_stmt|;
name|dialog
operator|.
name|exec
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|m_processedEdgePairs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Split an edge into two pieces at the given point.
end_comment
begin_comment
comment|// The upper piece is pushed to the end of the 'm_edges' vector.
end_comment
begin_comment
comment|// The lower piece replaces the old edge.
end_comment
begin_comment
comment|// Return the edge whose 'from' is 'pointIndex'.
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|splitEdge
name|int
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|splitEdge
parameter_list|(
name|int
name|splitIndex
parameter_list|)
block|{
specifier|const
name|Split
modifier|&
name|split
init|=
name|m_splits
operator|.
name|at
argument_list|(
name|splitIndex
argument_list|)
decl_stmt|;
name|Edge
modifier|&
name|lowerEdge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|split
operator|.
name|edge
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lowerEdge
operator|.
name|node
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|lowerEdge
operator|.
name|previous
operator|==
operator|-
literal|1
operator|&&
name|lowerEdge
operator|.
name|next
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerEdge
operator|.
name|from
operator|==
name|split
operator|.
name|vertex
condition|)
return|return
name|split
operator|.
name|edge
return|;
if|if
condition|(
name|lowerEdge
operator|.
name|to
operator|==
name|split
operator|.
name|vertex
condition|)
return|return
name|lowerEdge
operator|.
name|next
return|;
comment|// Check that angle>= 90 degrees.
comment|//Q_ASSERT(qDot(m_points.at(m_edges.at(edgeIndex).from) - m_points.at(pointIndex),
comment|//    m_points.at(m_edges.at(edgeIndex).to) - m_points.at(pointIndex))<= 0);
name|Edge
name|upperEdge
init|=
name|lowerEdge
decl_stmt|;
name|upperEdge
operator|.
name|mayIntersect
operator||=
operator|!
name|split
operator|.
name|accurate
expr_stmt|;
comment|// The edge may have been split before at an inaccurate split point.
name|lowerEdge
operator|.
name|mayIntersect
operator|=
operator|!
name|split
operator|.
name|accurate
expr_stmt|;
if|if
condition|(
name|lowerEdge
operator|.
name|pointingUp
condition|)
block|{
name|lowerEdge
operator|.
name|to
operator|=
name|upperEdge
operator|.
name|from
operator|=
name|split
operator|.
name|vertex
expr_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|upperEdge
argument_list|)
expr_stmt|;
return|return
name|m_edges
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
else|else
block|{
name|lowerEdge
operator|.
name|from
operator|=
name|upperEdge
operator|.
name|to
operator|=
name|split
operator|.
name|vertex
expr_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|upperEdge
argument_list|)
expr_stmt|;
return|return
name|split
operator|.
name|edge
return|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|splitEdgesAtIntersections
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|splitEdgesAtIntersections
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mayIntersect
operator|=
literal|false
expr_stmt|;
name|bool
name|checkForNewIntersections
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_splits
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|splitEdge
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|checkForNewIntersections
operator||=
operator|!
name|m_splits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|accurate
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|originallyPointingUp
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
name|m_splits
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|checkForNewIntersections
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|insertEdgeIntoVectorIfWanted
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|insertEdgeIntoVectorIfWanted
parameter_list|(
name|ShortArray
modifier|&
name|orderedEdges
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|// Edges with zero length should not reach this part.
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
operator|!=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
comment|// Skip edges with unwanted winding number.
name|int
name|windingNumber
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|winding
decl_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|originallyPointingUp
condition|)
operator|++
name|windingNumber
expr_stmt|;
comment|// Make sure exactly one fill rule is specified.
name|Q_ASSERT
argument_list|(
operator|(
operator|(
name|m_parent
operator|->
name|m_hint
operator|&
name|QVectorPath
operator|::
name|WindingFill
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|m_parent
operator|->
name|m_hint
operator|&
name|QVectorPath
operator|::
name|OddEvenFill
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_parent
operator|->
name|m_hint
operator|&
name|QVectorPath
operator|::
name|WindingFill
operator|)
operator|&&
name|windingNumber
operator|!=
literal|0
operator|&&
name|windingNumber
operator|!=
literal|1
condition|)
return|return;
comment|// Skip cancelling edges.
if|if
condition|(
operator|!
name|orderedEdges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|j
init|=
name|orderedEdges
index|[
name|orderedEdges
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
comment|// If the last edge is already connected in one end, it should not be cancelled.
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|next
operator|==
operator|-
literal|1
operator|&&
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|previous
operator|==
operator|-
literal|1
operator|&&
operator|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|to
argument_list|)
operator|)
operator|&&
operator|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|==
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|from
argument_list|)
operator|)
condition|)
block|{
name|orderedEdges
operator|.
name|removeLast
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|orderedEdges
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|removeUnwantedEdgesAndConnect
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|removeUnwantedEdgesAndConnect
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|root
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Initialize priority queue.
name|fillPriorityQueue
argument_list|()
expr_stmt|;
name|ShortArray
name|orderedEdges
decl_stmt|;
while|while
condition|(
operator|!
name|m_events
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Event
name|event
init|=
name|m_events
operator|.
name|last
argument_list|()
decl_stmt|;
name|int
name|edgeIndex
init|=
name|event
operator|.
name|edge
decl_stmt|;
comment|// Check that all the edges in the list crosses the current scanline
comment|//if (m_edgeList.root) {
comment|//    for (QRBTree<int>::Node *node = m_edgeList.front(m_edgeList.root); node; node = m_edgeList.next(node)) {
comment|//        Q_ASSERT(event.point<= m_points.at(m_edges.at(node->data).lower()));
comment|//    }
comment|//}
name|orderedEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QPair
argument_list|<
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|,
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
operator|*
argument_list|>
name|b
init|=
name|outerBounds
argument_list|(
name|event
operator|.
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_edgeList
operator|.
name|root
condition|)
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
operator|(
name|b
operator|.
name|first
condition|?
name|m_edgeList
operator|.
name|next
argument_list|(
name|b
operator|.
name|first
argument_list|)
else|:
name|m_edgeList
operator|.
name|front
argument_list|(
name|m_edgeList
operator|.
name|root
argument_list|)
operator|)
decl_stmt|;
comment|// Process edges that are going to be removed from the edge list at the current event point.
while|while
condition|(
name|current
operator|!=
name|b
operator|.
name|second
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|node
operator|==
name|current
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qIntersectionPoint
argument_list|)
argument_list|(
name|event
operator|.
name|point
argument_list|)
operator|.
name|isOnLine
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|from
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|event
operator|.
name|point
operator|||
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|to
argument_list|)
operator|==
name|event
operator|.
name|point
argument_list|)
expr_stmt|;
name|insertEdgeIntoVectorIfWanted
argument_list|(
name|orderedEdges
argument_list|,
name|current
operator|->
name|data
argument_list|)
expr_stmt|;
name|current
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove edges above the event point, insert edges below the event point.
do|do
block|{
name|event
operator|=
name|m_events
operator|.
name|last
argument_list|()
expr_stmt|;
name|m_events
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|edgeIndex
operator|=
name|event
operator|.
name|edge
expr_stmt|;
comment|// Edges with zero length should not reach this part.
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|from
argument_list|)
operator|!=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|node
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|type
operator|==
name|Event
operator|::
name|Lower
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|point
operator|==
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|event
operator|.
name|edge
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_edgeList
operator|.
name|deleteNode
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|type
operator|==
name|Event
operator|::
name|Upper
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
operator|.
name|point
operator|==
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|event
operator|.
name|edge
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|left
init|=
name|searchEdgeLeftOf
argument_list|(
name|edgeIndex
argument_list|,
name|b
operator|.
name|first
argument_list|)
decl_stmt|;
name|m_edgeList
operator|.
name|attachAfter
argument_list|(
name|left
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|node
operator|=
name|m_edgeList
operator|.
name|newNode
argument_list|()
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|edgeIndex
argument_list|)
operator|.
name|node
operator|->
name|data
operator|=
name|edgeIndex
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|m_events
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_events
operator|.
name|last
argument_list|()
operator|.
name|point
operator|==
name|event
operator|.
name|point
condition|)
do|;
if|if
condition|(
name|m_edgeList
operator|.
name|root
condition|)
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
operator|(
name|b
operator|.
name|first
condition|?
name|m_edgeList
operator|.
name|next
argument_list|(
name|b
operator|.
name|first
argument_list|)
else|:
name|m_edgeList
operator|.
name|front
argument_list|(
name|m_edgeList
operator|.
name|root
argument_list|)
operator|)
decl_stmt|;
comment|// Calculate winding number and turn counter-clockwise.
name|int
name|currentWindingNumber
init|=
operator|(
name|b
operator|.
name|first
condition|?
name|m_edges
operator|.
name|at
argument_list|(
name|b
operator|.
name|first
operator|->
name|data
argument_list|)
operator|.
name|winding
else|:
literal|0
operator|)
decl_stmt|;
while|while
condition|(
name|current
operator|!=
name|b
operator|.
name|second
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|//Q_ASSERT(b.second == 0 || m_edgeList.order(current, b.second)< 0);
name|int
name|i
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|==
name|current
argument_list|)
expr_stmt|;
comment|// Winding number.
name|int
name|ccwWindingNumber
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|winding
operator|=
name|currentWindingNumber
decl_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|originallyPointingUp
condition|)
block|{
operator|--
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|winding
expr_stmt|;
block|}
else|else
block|{
operator|++
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|winding
expr_stmt|;
operator|++
name|ccwWindingNumber
expr_stmt|;
block|}
name|currentWindingNumber
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|winding
expr_stmt|;
comment|// Turn counter-clockwise.
if|if
condition|(
operator|(
name|ccwWindingNumber
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
operator|==
operator|-
literal|1
operator|&&
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|=
operator|!
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
expr_stmt|;
block|}
name|current
operator|=
name|m_edgeList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|// Process edges that were inserted into the edge list at the current event point.
name|current
operator|=
operator|(
name|b
operator|.
name|second
condition|?
name|m_edgeList
operator|.
name|previous
argument_list|(
name|b
operator|.
name|second
argument_list|)
else|:
name|m_edgeList
operator|.
name|back
argument_list|(
name|m_edgeList
operator|.
name|root
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|b
operator|.
name|first
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|node
operator|==
name|current
argument_list|)
expr_stmt|;
name|insertEdgeIntoVectorIfWanted
argument_list|(
name|orderedEdges
argument_list|,
name|current
operator|->
name|data
argument_list|)
expr_stmt|;
name|current
operator|=
name|m_edgeList
operator|.
name|previous
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|orderedEdges
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
operator|(
name|orderedEdges
operator|.
name|size
argument_list|()
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Connect edges.
comment|// First make sure the first edge point towards the current point.
name|int
name|i
decl_stmt|;
if|if
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
literal|0
index|]
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|event
operator|.
name|point
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|int
name|copy
init|=
name|orderedEdges
index|[
literal|0
index|]
decl_stmt|;
comment|// Make copy in case the append() will cause a reallocation.
name|orderedEdges
operator|.
name|append
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
literal|0
index|]
argument_list|)
operator|.
name|to
argument_list|)
operator|==
name|event
operator|.
name|point
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|// Remove references to duplicate points. First find the point with lowest index.
name|int
name|pointIndex
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|orderedEdges
operator|.
name|size
argument_list|()
condition|;
name|j
operator|+=
literal|2
control|)
block|{
name|Q_ASSERT
argument_list|(
name|j
operator|+
literal|1
operator|<
name|orderedEdges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
index|]
argument_list|)
operator|.
name|to
argument_list|)
operator|==
name|event
operator|.
name|point
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|event
operator|.
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
index|]
argument_list|)
operator|.
name|to
operator|<
name|pointIndex
condition|)
name|pointIndex
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
index|]
argument_list|)
operator|.
name|to
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|.
name|from
operator|<
name|pointIndex
condition|)
name|pointIndex
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|.
name|from
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|orderedEdges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|// Remove references to duplicate points by making all edges reference one common point.
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
index|]
argument_list|)
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|.
name|from
operator|=
name|pointIndex
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
index|]
argument_list|)
operator|.
name|pointingUp
operator|||
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
index|]
argument_list|)
operator|.
name|previous
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|.
name|pointingUp
operator|||
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|.
name|next
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
index|]
argument_list|)
operator|.
name|next
operator|=
name|orderedEdges
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|orderedEdges
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|.
name|previous
operator|=
name|orderedEdges
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|// end while
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|removeUnusedPoints
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|removeUnusedPoints
parameter_list|()
block|{
name|QBitArray
name|used
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
operator|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
operator|==
operator|-
literal|1
operator|)
operator|==
operator|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|==
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|!=
operator|-
literal|1
condition|)
name|used
operator|.
name|setBit
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
name|newMapping
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|newMapping
operator|.
name|resize
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|used
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|count
argument_list|)
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|newMapping
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|=
name|count
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
name|m_parent
operator|->
name|m_vertices
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
operator|=
name|newMapping
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
operator|=
name|newMapping
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|operator ()
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|CompareEdges
operator|::
name|operator
name|()
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
specifier|const
block|{
name|int
name|cmp
init|=
name|comparePoints
argument_list|(
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|from
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|comparePoints
argument_list|(
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cmp
operator|>
literal|0
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|operator <
specifier|inline
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|Event
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|Event
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|point
operator|==
name|other
operator|.
name|point
condition|)
return|return
name|type
operator|<
name|other
operator|.
name|type
return|;
comment|// 'Lower' has higher priority than 'Upper'.
return|return
name|other
operator|.
name|point
operator|<
name|point
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                QTriangulator::ComplexToSimple::DebugDialog                 //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_TRIANGULATOR_DEBUG
end_ifdef
begin_constructor
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|DebugDialog
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|DebugDialog
operator|::
name|DebugDialog
parameter_list|(
name|ComplexToSimple
modifier|*
name|parent
parameter_list|,
name|int
name|currentVertex
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_vertex
argument_list|(
name|currentVertex
argument_list|)
block|{
name|QDataBuffer
argument_list|<
name|QPodPoint
argument_list|>
modifier|&
name|vertices
init|=
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
decl_stmt|;
if|if
condition|(
name|vertices
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|minX
decl_stmt|,
name|maxX
decl_stmt|,
name|minY
decl_stmt|,
name|maxY
decl_stmt|;
name|minX
operator|=
name|maxX
operator|=
name|vertices
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
expr_stmt|;
name|minY
operator|=
name|maxY
operator|=
name|vertices
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|minX
operator|=
name|qMin
argument_list|(
name|minX
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
expr_stmt|;
name|maxX
operator|=
name|qMax
argument_list|(
name|maxX
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|)
expr_stmt|;
name|minY
operator|=
name|qMin
argument_list|(
name|minY
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
expr_stmt|;
name|maxY
operator|=
name|qMax
argument_list|(
name|maxY
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|int
name|w
init|=
name|maxX
operator|-
name|minX
decl_stmt|;
name|int
name|h
init|=
name|maxY
operator|-
name|minY
decl_stmt|;
name|qreal
name|border
init|=
name|qMin
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|/
literal|10.0
decl_stmt|;
name|m_window
operator|=
name|QRectF
argument_list|(
name|minX
operator|-
name|border
argument_list|,
name|minY
operator|-
name|border
argument_list|,
operator|(
name|maxX
operator|-
name|minX
operator|+
literal|2
operator|*
name|border
operator|)
argument_list|,
operator|(
name|maxY
operator|-
name|minY
operator|+
literal|2
operator|*
name|border
operator|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|paintEvent
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|DebugDialog
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|rect
argument_list|()
argument_list|,
name|Qt
operator|::
name|black
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|QPodPoint
argument_list|>
modifier|&
name|vertices
init|=
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
decl_stmt|;
if|if
condition|(
name|vertices
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qreal
name|halfPointSize
init|=
name|qMin
argument_list|(
name|m_window
operator|.
name|width
argument_list|()
argument_list|,
name|m_window
operator|.
name|height
argument_list|()
argument_list|)
operator|/
literal|300.0
decl_stmt|;
name|p
operator|.
name|setWindow
argument_list|(
name|m_window
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|Edge
argument_list|>
modifier|&
name|edges
init|=
name|m_parent
operator|->
name|m_edges
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPodPoint
name|u
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
name|QPodPoint
name|v
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawLine
argument_list|(
name|u
operator|.
name|x
argument_list|,
name|u
operator|.
name|y
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPodPoint
name|q
init|=
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|q
operator|.
name|x
operator|-
name|halfPointSize
argument_list|,
name|q
operator|.
name|y
operator|-
name|halfPointSize
argument_list|,
literal|2
operator|*
name|halfPointSize
argument_list|,
literal|2
operator|*
name|halfPointSize
argument_list|)
argument_list|,
name|Qt
operator|::
name|red
argument_list|)
expr_stmt|;
block|}
name|Qt
operator|::
name|GlobalColor
name|colors
index|[
literal|6
index|]
init|=
block|{
name|Qt
operator|::
name|red
block|,
name|Qt
operator|::
name|green
block|,
name|Qt
operator|::
name|blue
block|,
name|Qt
operator|::
name|cyan
block|,
name|Qt
operator|::
name|magenta
block|,
name|Qt
operator|::
name|yellow
block|}
decl_stmt|;
name|p
operator|.
name|setOpacity
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m_parent
operator|->
name|m_edgeList
operator|.
name|root
condition|)
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_parent
operator|->
name|m_edgeList
operator|.
name|front
argument_list|(
name|m_parent
operator|->
name|m_edgeList
operator|.
name|root
argument_list|)
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|p
operator|.
name|setPen
argument_list|(
name|colors
index|[
name|count
operator|++
operator|%
literal|6
index|]
argument_list|)
expr_stmt|;
name|QPodPoint
name|u
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
name|QPodPoint
name|v
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|to
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawLine
argument_list|(
name|u
operator|.
name|x
argument_list|,
name|u
operator|.
name|y
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
name|current
operator|=
name|m_parent
operator|->
name|m_edgeList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|.
name|setOpacity
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|QPodPoint
name|q
init|=
name|vertices
operator|.
name|at
argument_list|(
name|m_vertex
argument_list|)
decl_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|q
operator|.
name|x
operator|-
name|halfPointSize
argument_list|,
name|q
operator|.
name|y
operator|-
name|halfPointSize
argument_list|,
literal|2
operator|*
name|halfPointSize
argument_list|,
literal|2
operator|*
name|halfPointSize
argument_list|)
argument_list|,
name|Qt
operator|::
name|green
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|Qt
operator|::
name|gray
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|Split
argument_list|>
modifier|&
name|splits
init|=
name|m_parent
operator|->
name|m_splits
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splits
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPodPoint
name|q
init|=
name|vertices
operator|.
name|at
argument_list|(
name|splits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|vertex
argument_list|)
decl_stmt|;
name|QPodPoint
name|u
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|splits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|edge
argument_list|)
operator|.
name|from
argument_list|)
operator|-
name|q
decl_stmt|;
name|QPodPoint
name|v
init|=
name|vertices
operator|.
name|at
argument_list|(
name|edges
operator|.
name|at
argument_list|(
name|splits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|edge
argument_list|)
operator|.
name|to
argument_list|)
operator|-
name|q
decl_stmt|;
name|qreal
name|uLen
init|=
name|sqrt
argument_list|(
name|qreal
argument_list|(
name|qDot
argument_list|(
name|u
argument_list|,
name|u
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|vLen
init|=
name|sqrt
argument_list|(
name|qreal
argument_list|(
name|qDot
argument_list|(
name|v
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|uLen
condition|)
block|{
name|u
operator|.
name|x
operator|*=
literal|2
operator|*
name|halfPointSize
operator|/
name|uLen
expr_stmt|;
name|u
operator|.
name|y
operator|*=
literal|2
operator|*
name|halfPointSize
operator|/
name|uLen
expr_stmt|;
block|}
if|if
condition|(
name|vLen
condition|)
block|{
name|v
operator|.
name|x
operator|*=
literal|2
operator|*
name|halfPointSize
operator|/
name|vLen
expr_stmt|;
name|v
operator|.
name|y
operator|*=
literal|2
operator|*
name|halfPointSize
operator|/
name|vLen
expr_stmt|;
block|}
name|u
operator|+=
name|q
expr_stmt|;
name|v
operator|+=
name|q
expr_stmt|;
name|p
operator|.
name|drawLine
argument_list|(
name|u
operator|.
name|x
argument_list|,
name|u
operator|.
name|y
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|wheelEvent
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|DebugDialog
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|event
parameter_list|)
block|{
name|qreal
name|scale
init|=
name|exp
argument_list|(
operator|-
literal|0.001
operator|*
name|event
operator|->
name|delta
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|center
init|=
name|m_window
operator|.
name|center
argument_list|()
decl_stmt|;
name|QPointF
name|delta
init|=
name|scale
operator|*
operator|(
name|m_window
operator|.
name|bottomRight
argument_list|()
operator|-
name|center
operator|)
decl_stmt|;
name|m_window
operator|=
name|QRectF
argument_list|(
name|center
operator|-
name|delta
argument_list|,
name|center
operator|+
name|delta
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|mouseMoveEvent
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|DebugDialog
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|QPointF
name|delta
init|=
name|event
operator|->
name|pos
argument_list|()
operator|-
name|m_lastMousePos
decl_stmt|;
name|delta
operator|.
name|setX
argument_list|(
name|delta
operator|.
name|x
argument_list|()
operator|*
name|m_window
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|delta
operator|.
name|setY
argument_list|(
name|delta
operator|.
name|y
argument_list|()
operator|*
name|m_window
operator|.
name|height
argument_list|()
operator|/
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|m_window
operator|.
name|translate
argument_list|(
operator|-
name|delta
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|delta
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|m_lastMousePos
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|mousePressEvent
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|ComplexToSimple
operator|::
name|DebugDialog
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
name|m_lastMousePos
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                      QTriangulator::SimpleToMonotone                       //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|decompose
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|decompose
parameter_list|()
block|{
name|setupDataStructures
argument_list|()
expr_stmt|;
name|removeZeroLengthEdges
argument_list|()
expr_stmt|;
name|monotoneDecomposition
argument_list|()
expr_stmt|;
name|m_parent
operator|->
name|m_indices
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QBitArray
name|processed
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|first
init|=
literal|0
init|;
name|first
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|first
control|)
block|{
if|if
condition|(
name|processed
operator|.
name|at
argument_list|(
name|first
argument_list|)
condition|)
continue|continue;
name|int
name|i
init|=
name|first
decl_stmt|;
do|do
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|processed
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
operator|.
name|previous
operator|==
name|i
argument_list|)
expr_stmt|;
name|m_parent
operator|->
name|m_indices
operator|.
name|push_back
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
name|processed
operator|.
name|setBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|first
condition|)
do|;
if|if
condition|(
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|m_parent
operator|->
name|m_indices
operator|.
name|back
argument_list|()
operator|!=
name|T
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
comment|// Q_TRIANGULATE_END_OF_POLYGON
name|m_parent
operator|->
name|m_indices
operator|.
name|push_back
argument_list|(
name|T
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Q_TRIANGULATE_END_OF_POLYGON
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|setupDataStructures
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|setupDataStructures
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Edge
name|e
decl_stmt|;
name|e
operator|.
name|node
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|twin
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|3
operator|<=
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|start
init|=
name|m_edges
operator|.
name|size
argument_list|()
decl_stmt|;
do|do
block|{
name|e
operator|.
name|from
operator|=
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|e
operator|.
name|type
operator|=
name|RegularVertex
expr_stmt|;
name|e
operator|.
name|next
operator|=
name|m_edges
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|e
operator|.
name|previous
operator|=
name|m_edges
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|<
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|T
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
do|;
comment|// Q_TRIANGULATE_END_OF_POLYGON
name|m_edges
operator|.
name|last
argument_list|()
operator|.
name|next
operator|=
name|start
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|start
argument_list|)
operator|.
name|previous
operator|=
name|m_edges
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
comment|// Skip Q_TRIANGULATE_END_OF_POLYGON.
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
operator|.
name|from
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Not initialized here.
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|removeZeroLengthEdges
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|removeZeroLengthEdges
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
condition|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
argument_list|)
operator|.
name|next
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
operator|.
name|previous
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
operator|.
name|from
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Mark as removed.
block|}
block|}
name|QDataBuffer
argument_list|<
name|int
argument_list|>
name|newMapping
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|newMapping
operator|.
name|resize
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|!=
operator|-
literal|1
condition|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|count
argument_list|)
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|newMapping
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|=
name|count
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
name|m_edges
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
operator|=
name|newMapping
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|next
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
operator|=
name|newMapping
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|fillPriorityQueue
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|fillPriorityQueue
parameter_list|()
block|{
name|m_upperVertex
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_upperVertex
operator|.
name|reserve
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|m_upperVertex
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|CompareVertices
name|cmp
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|//qSort(m_upperVertex.data(), m_upperVertex.data() + m_upperVertex.size(), cmp);
name|sort
argument_list|(
name|m_upperVertex
operator|.
name|data
argument_list|()
argument_list|,
name|m_upperVertex
operator|.
name|size
argument_list|()
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
comment|//for (int i = 1; i< m_upperVertex.size(); ++i) {
comment|//    Q_ASSERT(!cmp(m_upperVertex.at(i), m_upperVertex.at(i - 1)));
comment|//}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|edgeIsLeftOfEdge
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|edgeIsLeftOfEdge
parameter_list|(
name|int
name|leftEdgeIndex
parameter_list|,
name|int
name|rightEdgeIndex
parameter_list|)
specifier|const
block|{
specifier|const
name|Edge
modifier|&
name|leftEdge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeIndex
argument_list|)
decl_stmt|;
specifier|const
name|Edge
modifier|&
name|rightEdge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|rightEdgeIndex
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|u
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|rightEdge
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|l
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|rightEdge
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|leftEdge
operator|.
name|upper
argument_list|()
argument_list|)
argument_list|,
name|l
argument_list|,
name|u
argument_list|)
decl_stmt|;
comment|// d< 0: left, d> 0: right, d == 0: on top
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|leftEdge
operator|.
name|lower
argument_list|()
argument_list|)
argument_list|,
name|l
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
name|d
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|// Returns the rightmost edge not to the right of the given edge.
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|searchEdgeLeftOfEdge
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|searchEdgeLeftOfEdge
parameter_list|(
name|int
name|edgeIndex
parameter_list|)
specifier|const
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_edgeList
operator|.
name|root
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|edgeIsLeftOfEdge
argument_list|(
name|edgeIndex
argument_list|,
name|current
operator|->
name|data
argument_list|)
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// Returns the rightmost edge left of the given point.
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|searchEdgeLeftOfPoint
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|searchEdgeLeftOfPoint
parameter_list|(
name|int
name|pointIndex
parameter_list|)
specifier|const
block|{
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|current
init|=
name|m_edgeList
operator|.
name|root
decl_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|p1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|lower
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|p2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|current
operator|->
name|data
argument_list|)
operator|.
name|upper
argument_list|()
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|pointIndex
argument_list|)
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|classifyVertex
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|classifyVertex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|Edge
modifier|&
name|e2
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|Edge
modifier|&
name|e1
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|e2
operator|.
name|previous
argument_list|)
decl_stmt|;
name|bool
name|startOrSplit
init|=
operator|(
name|e1
operator|.
name|pointingUp
operator|&&
operator|!
name|e2
operator|.
name|pointingUp
operator|)
decl_stmt|;
name|bool
name|endOrMerge
init|=
operator|(
operator|!
name|e1
operator|.
name|pointingUp
operator|&&
name|e2
operator|.
name|pointingUp
operator|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|p1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|e1
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|p2
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|e2
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|p3
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|e2
operator|.
name|to
argument_list|)
decl_stmt|;
name|qint64
name|d
init|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qPointDistanceFromLine
argument_list|)
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|!=
literal|0
operator|||
operator|(
operator|!
name|startOrSplit
operator|&&
operator|!
name|endOrMerge
operator|)
argument_list|)
expr_stmt|;
name|e2
operator|.
name|type
operator|=
name|RegularVertex
expr_stmt|;
if|if
condition|(
name|m_clockwiseOrder
condition|)
block|{
if|if
condition|(
name|startOrSplit
condition|)
name|e2
operator|.
name|type
operator|=
operator|(
name|d
operator|<
literal|0
condition|?
name|SplitVertex
else|:
name|StartVertex
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endOrMerge
condition|)
name|e2
operator|.
name|type
operator|=
operator|(
name|d
operator|<
literal|0
condition|?
name|MergeVertex
else|:
name|EndVertex
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|startOrSplit
condition|)
name|e2
operator|.
name|type
operator|=
operator|(
name|d
operator|>
literal|0
condition|?
name|SplitVertex
else|:
name|StartVertex
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endOrMerge
condition|)
name|e2
operator|.
name|type
operator|=
operator|(
name|d
operator|>
literal|0
condition|?
name|MergeVertex
else|:
name|EndVertex
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|classifyVertices
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|classifyVertices
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|classifyVertex
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|pointIsInSector
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|pointIsInSector
parameter_list|(
specifier|const
name|QPodPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v2
parameter_list|,
specifier|const
name|QPodPoint
modifier|&
name|v3
parameter_list|)
block|{
name|bool
name|leftOfPreviousEdge
init|=
operator|!
name|qPointIsLeftOfLine
argument_list|(
name|p
argument_list|,
name|v2
argument_list|,
name|v1
argument_list|)
decl_stmt|;
name|bool
name|leftOfNextEdge
init|=
operator|!
name|qPointIsLeftOfLine
argument_list|(
name|p
argument_list|,
name|v3
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
name|qPointIsLeftOfLine
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
condition|)
return|return
name|leftOfPreviousEdge
operator|&&
name|leftOfNextEdge
return|;
else|else
return|return
name|leftOfPreviousEdge
operator|||
name|leftOfNextEdge
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|pointIsInSector
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|pointIsInSector
parameter_list|(
name|int
name|vertex
parameter_list|,
name|int
name|sector
parameter_list|)
block|{
specifier|const
name|QPodPoint
modifier|&
name|center
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|sector
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
comment|// Handle degenerate edges.
while|while
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|vertex
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|center
condition|)
name|vertex
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|vertex
argument_list|)
operator|.
name|next
expr_stmt|;
name|int
name|next
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|sector
argument_list|)
operator|.
name|next
decl_stmt|;
while|while
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|next
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|center
condition|)
name|next
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|next
argument_list|)
operator|.
name|next
expr_stmt|;
name|int
name|previous
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|sector
argument_list|)
operator|.
name|previous
decl_stmt|;
while|while
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|previous
argument_list|)
operator|.
name|from
argument_list|)
operator|==
name|center
condition|)
name|previous
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|previous
argument_list|)
operator|.
name|previous
expr_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|p
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|vertex
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v1
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|previous
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QPodPoint
modifier|&
name|v3
init|=
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|next
argument_list|)
operator|.
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_clockwiseOrder
condition|)
return|return
name|pointIsInSector
argument_list|(
name|p
argument_list|,
name|v3
argument_list|,
name|center
argument_list|,
name|v1
argument_list|)
return|;
else|else
return|return
name|pointIsInSector
argument_list|(
name|p
argument_list|,
name|v1
argument_list|,
name|center
argument_list|,
name|v3
argument_list|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|findSector
name|int
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|findSector
parameter_list|(
name|int
name|edge
parameter_list|,
name|int
name|vertex
parameter_list|)
block|{
while|while
condition|(
operator|!
name|pointIsInSector
argument_list|(
name|vertex
argument_list|,
name|edge
argument_list|)
condition|)
block|{
name|edge
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|edge
argument_list|)
operator|.
name|previous
argument_list|)
operator|.
name|twin
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|edge
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|edge
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|createDiagonal
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|createDiagonal
parameter_list|(
name|int
name|lower
parameter_list|,
name|int
name|upper
parameter_list|)
block|{
name|lower
operator|=
name|findSector
argument_list|(
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|upper
operator|=
name|findSector
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|)
expr_stmt|;
name|int
name|prevLower
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|lower
argument_list|)
operator|.
name|previous
decl_stmt|;
name|int
name|prevUpper
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|upper
argument_list|)
operator|.
name|previous
decl_stmt|;
name|Edge
name|e
decl_stmt|;
name|e
operator|.
name|twin
operator|=
name|m_edges
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|e
operator|.
name|next
operator|=
name|upper
expr_stmt|;
name|e
operator|.
name|previous
operator|=
name|prevLower
expr_stmt|;
name|e
operator|.
name|from
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|lower
argument_list|)
operator|.
name|from
expr_stmt|;
name|e
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|upper
argument_list|)
operator|.
name|from
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|upper
argument_list|)
operator|.
name|previous
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|prevLower
argument_list|)
operator|.
name|next
operator|=
name|int
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|twin
operator|=
name|m_edges
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|next
operator|=
name|lower
expr_stmt|;
name|e
operator|.
name|previous
operator|=
name|prevUpper
expr_stmt|;
name|e
operator|.
name|from
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|upper
argument_list|)
operator|.
name|from
expr_stmt|;
name|e
operator|.
name|to
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|lower
argument_list|)
operator|.
name|from
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|lower
argument_list|)
operator|.
name|previous
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|prevUpper
argument_list|)
operator|.
name|next
operator|=
name|int
argument_list|(
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|monotoneDecomposition
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|monotoneDecomposition
parameter_list|()
block|{
if|if
condition|(
name|m_edges
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|Q_ASSERT
argument_list|(
operator|!
name|m_edgeList
operator|.
name|root
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
name|diagonals
argument_list|(
name|m_upperVertex
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|1
init|;
name|index
operator|<
name|m_edges
operator|.
name|size
argument_list|()
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|from
argument_list|)
operator|<
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
condition|)
name|i
operator|=
name|index
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|j
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|j
operator|<
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_clockwiseOrder
operator|=
name|qPointIsLeftOfLine
argument_list|(
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|quint32
operator|)
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|quint32
operator|)
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|from
argument_list|)
argument_list|,
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
operator|(
name|quint32
operator|)
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|classifyVertices
argument_list|()
expr_stmt|;
name|fillPriorityQueue
argument_list|()
expr_stmt|;
comment|// debug: set helpers explicitly (shouldn't be necessary)
comment|//for (int i = 0; i< m_edges.size(); ++i)
comment|//    m_edges.at(i).helper = m_edges.at(i).upper();
while|while
condition|(
operator|!
name|m_upperVertex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|i
operator|=
name|m_upperVertex
operator|.
name|last
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|<
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_upperVertex
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|j
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|previous
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|j
operator|<
name|m_edges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|leftEdgeNode
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
condition|)
block|{
case|case
name|RegularVertex
case|:
comment|// If polygon interior is to the right of the vertex...
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pointingUp
operator|==
name|m_clockwiseOrder
condition|)
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|=
literal|0
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
operator|->
name|data
operator|=
name|j
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|=
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
operator|=
literal|0
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|->
name|data
operator|=
name|i
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#1)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|leftEdgeNode
operator|=
name|searchEdgeLeftOfPoint
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftEdgeNode
condition|)
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#2)"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SplitVertex
case|:
name|leftEdgeNode
operator|=
name|searchEdgeLeftOfPoint
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftEdgeNode
condition|)
block|{
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#3)"
argument_list|)
expr_stmt|;
block|}
comment|// Fall through.
case|case
name|StartVertex
case|:
if|if
condition|(
name|m_clockwiseOrder
condition|)
block|{
name|leftEdgeNode
operator|=
name|searchEdgeLeftOfEdge
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|node
init|=
name|m_edgeList
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|node
operator|->
name|data
operator|=
name|j
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
name|m_edgeList
operator|.
name|attachAfter
argument_list|(
name|leftEdgeNode
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|validate
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftEdgeNode
operator|=
name|searchEdgeLeftOfEdge
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QRBTree
argument_list|<
name|int
argument_list|>
operator|::
name|Node
modifier|*
name|node
init|=
name|m_edgeList
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|node
operator|->
name|data
operator|=
name|i
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
name|m_edgeList
operator|.
name|attachAfter
argument_list|(
name|leftEdgeNode
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|validate
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MergeVertex
case|:
name|leftEdgeNode
operator|=
name|searchEdgeLeftOfPoint
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftEdgeNode
condition|)
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|m_edges
operator|.
name|at
argument_list|(
name|leftEdgeNode
operator|->
name|data
argument_list|)
operator|.
name|helper
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#4)"
argument_list|)
expr_stmt|;
block|}
comment|// Fall through.
case|case
name|EndVertex
case|:
if|if
condition|(
name|m_clockwiseOrder
condition|)
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
condition|)
block|{
name|m_edgeList
operator|.
name|deleteNode
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|validate
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#5)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
argument_list|)
operator|.
name|type
operator|==
name|MergeVertex
condition|)
name|diagonals
operator|.
name|add
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|i
argument_list|,
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|helper
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
condition|)
block|{
name|m_edgeList
operator|.
name|deleteNode
argument_list|(
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|node
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_edgeList
operator|.
name|validate
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Inconsistent polygon. (#6)"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|diagonals
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|createDiagonal
argument_list|(
name|diagonals
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|,
name|diagonals
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|operator ()
name|bool
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|SimpleToMonotone
operator|::
name|CompareVertices
operator|::
name|operator
name|()
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
operator|==
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|from
condition|)
return|return
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|>
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|type
return|;
return|return
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|from
argument_list|)
operator|>
name|m_parent
operator|->
name|m_parent
operator|->
name|m_vertices
operator|.
name|at
argument_list|(
name|m_parent
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                     QTriangulator::MonotoneToTriangles                     //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|decompose
name|void
name|QTriangulator
argument_list|<
name|T
argument_list|>
operator|::
name|MonotoneToTriangles
operator|::
name|decompose
parameter_list|()
block|{
name|QVector
argument_list|<
name|T
argument_list|>
name|result
decl_stmt|;
name|QDataBuffer
argument_list|<
name|int
argument_list|>
name|stack
argument_list|(
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|m_first
operator|=
literal|0
expr_stmt|;
comment|// Require at least three more indices.
while|while
condition|(
name|m_first
operator|+
literal|3
operator|<=
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
condition|)
block|{
name|m_length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m_parent
operator|->
name|m_indices
operator|.
name|at
argument_list|(
name|m_first
operator|+
name|m_length
argument_list|)
operator|!=
name|T
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// Q_TRIANGULATE_END_OF_POLYGON
operator|++
name|m_length
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_first
operator|+
name|m_length
operator|<
name|m_parent
operator|->
name|m_indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_length
operator|<
literal|3
condition|)
block|{
name|m_first
operator|+=
name|m_length
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|int
name|minimum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|less
argument_list|(
name|next
argument_list|(
name|minimum
argument_list|)
argument_list|,
name|minimum
argument_list|)
condition|)
name|minimum
operator|=
name|next
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
while|while
condition|(
name|less
argument_list|(
name|previous
argument_list|(
name|minimum
argument_list|)
argument_list|,
name|minimum
argument_list|)
condition|)
name|minimum
operator|=
name|previous
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
name|stack
operator|.
name|reset
argument_list|()
expr_stmt|;
name|stack
operator|.
name|add
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
name|int
name|left
init|=
name|previous
argument_list|(
name|minimum
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|next
argument_list|(
name|minimum
argument_list|)
decl_stmt|;
name|bool
name|stackIsOnLeftSide
decl_stmt|;
name|bool
name|clockwiseOrder
init|=
name|leftOfEdge
argument_list|(
name|minimum
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|less
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
name|stack
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|previous
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|stackIsOnLeftSide
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|right
operator|=
name|next
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|stackIsOnLeftSide
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|+
literal|2
operator|<
name|m_length
condition|;
operator|++
name|count
control|)
block|{
name|Q_ASSERT
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|less
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|stackIsOnLeftSide
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|stack
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|first
argument_list|()
operator|=
name|stack
operator|.
name|last
argument_list|()
expr_stmt|;
name|stack
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|(
name|clockwiseOrder
operator|^
operator|!
name|leftOfEdge
argument_list|(
name|left
argument_list|,
name|stack
operator|.
name|at
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|,
name|stack
operator|.
name|last
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|last
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|stack
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|previous
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|stackIsOnLeftSide
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stackIsOnLeftSide
operator|==
literal|true
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|stack
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|first
argument_list|()
operator|=
name|stack
operator|.
name|last
argument_list|()
expr_stmt|;
name|stack
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|(
name|clockwiseOrder
operator|^
operator|!
name|leftOfEdge
argument_list|(
name|right
argument_list|,
name|stack
operator|.
name|last
argument_list|()
argument_list|,
name|stack
operator|.
name|at
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|last
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|push_back
argument_list|(
name|indices
argument_list|(
name|stack
operator|.
name|at
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
name|stack
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|right
operator|=
name|next
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|stackIsOnLeftSide
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|m_first
operator|+=
name|m_length
operator|+
literal|1
expr_stmt|;
block|}
name|m_parent
operator|->
name|m_indices
operator|=
name|result
expr_stmt|;
block|}
end_function
begin_comment
comment|//============================================================================//
end_comment
begin_comment
comment|//                                qTriangulate                                //
end_comment
begin_comment
comment|//============================================================================//
end_comment
begin_function
DECL|function|qTriangulate
name|Q_GUI_EXPORT
name|QTriangleSet
name|qTriangulate
parameter_list|(
specifier|const
name|qreal
modifier|*
name|polygon
parameter_list|,
name|int
name|count
parameter_list|,
name|uint
name|hint
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|QTriangleSet
name|triangleSet
decl_stmt|;
if|#
directive|if
literal|0
block|if (QOpenGLExtensions::glExtensions()& QOpenGLExtensions::ElementIndexUint) {         QTriangulator<quint32> triangulator;         triangulator.initialize(polygon, count, hint, matrix);         QVertexSet<quint32> vertexSet = triangulator.triangulate();         triangleSet.vertices = vertexSet.vertices;         triangleSet.indices.setDataUint(vertexSet.indices);      } else {
endif|#
directive|endif
name|QTriangulator
argument_list|<
name|quint16
argument_list|>
name|triangulator
decl_stmt|;
name|triangulator
operator|.
name|initialize
argument_list|(
name|polygon
argument_list|,
name|count
argument_list|,
name|hint
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
name|QVertexSet
argument_list|<
name|quint16
argument_list|>
name|vertexSet
init|=
name|triangulator
operator|.
name|triangulate
argument_list|()
decl_stmt|;
name|triangleSet
operator|.
name|vertices
operator|=
name|vertexSet
operator|.
name|vertices
expr_stmt|;
name|triangleSet
operator|.
name|indices
operator|.
name|setDataUshort
argument_list|(
name|vertexSet
operator|.
name|indices
argument_list|)
expr_stmt|;
comment|//    }
return|return
name|triangleSet
return|;
block|}
end_function
begin_function
DECL|function|qTriangulate
name|Q_GUI_EXPORT
name|QTriangleSet
name|qTriangulate
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|QTriangleSet
name|triangleSet
decl_stmt|;
if|#
directive|if
literal|0
block|if (QOpenGLExtensions::glExtensions()& QOpenGLExtensions::ElementIndexUint) {         QTriangulator<quint32> triangulator;         triangulator.initialize(path, matrix, lod);         QVertexSet<quint32> vertexSet = triangulator.triangulate();         triangleSet.vertices = vertexSet.vertices;         triangleSet.indices.setDataUint(vertexSet.indices);     } else {
endif|#
directive|endif
name|QTriangulator
argument_list|<
name|quint16
argument_list|>
name|triangulator
decl_stmt|;
name|triangulator
operator|.
name|initialize
argument_list|(
name|path
argument_list|,
name|matrix
argument_list|,
name|lod
argument_list|)
expr_stmt|;
name|QVertexSet
argument_list|<
name|quint16
argument_list|>
name|vertexSet
init|=
name|triangulator
operator|.
name|triangulate
argument_list|()
decl_stmt|;
name|triangleSet
operator|.
name|vertices
operator|=
name|vertexSet
operator|.
name|vertices
expr_stmt|;
name|triangleSet
operator|.
name|indices
operator|.
name|setDataUshort
argument_list|(
name|vertexSet
operator|.
name|indices
argument_list|)
expr_stmt|;
comment|//    }
return|return
name|triangleSet
return|;
block|}
end_function
begin_function
DECL|function|qTriangulate
name|QTriangleSet
name|qTriangulate
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|QTriangleSet
name|triangleSet
decl_stmt|;
if|#
directive|if
literal|0
block|if (QOpenGLExtensions::glExtensions()& QOpenGLExtensions::ElementIndexUint) {         QTriangulator<quint32> triangulator;         triangulator.initialize(path, matrix, lod);         QVertexSet<quint32> vertexSet = triangulator.triangulate();         triangleSet.vertices = vertexSet.vertices;         triangleSet.indices.setDataUint(vertexSet.indices);     } else {
endif|#
directive|endif
name|QTriangulator
argument_list|<
name|quint16
argument_list|>
name|triangulator
decl_stmt|;
name|triangulator
operator|.
name|initialize
argument_list|(
name|path
argument_list|,
name|matrix
argument_list|,
name|lod
argument_list|)
expr_stmt|;
name|QVertexSet
argument_list|<
name|quint16
argument_list|>
name|vertexSet
init|=
name|triangulator
operator|.
name|triangulate
argument_list|()
decl_stmt|;
name|triangleSet
operator|.
name|vertices
operator|=
name|vertexSet
operator|.
name|vertices
expr_stmt|;
name|triangleSet
operator|.
name|indices
operator|.
name|setDataUshort
argument_list|(
name|vertexSet
operator|.
name|indices
argument_list|)
expr_stmt|;
comment|//    }
return|return
name|triangleSet
return|;
block|}
end_function
begin_function
DECL|function|qPolyline
name|QPolylineSet
name|qPolyline
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|QPolylineSet
name|polyLineSet
decl_stmt|;
if|#
directive|if
literal|0
block|if (QOpenGLExtensions::glExtensions()& QOpenGLExtensions::ElementIndexUint) {         QTriangulator<quint32> triangulator;         triangulator.initialize(path, matrix, lod);         QVertexSet<quint32> vertexSet = triangulator.polyline();         polyLineSet.vertices = vertexSet.vertices;         polyLineSet.indices.setDataUint(vertexSet.indices);     } else {
endif|#
directive|endif
name|QTriangulator
argument_list|<
name|quint16
argument_list|>
name|triangulator
decl_stmt|;
name|triangulator
operator|.
name|initialize
argument_list|(
name|path
argument_list|,
name|matrix
argument_list|,
name|lod
argument_list|)
expr_stmt|;
name|QVertexSet
argument_list|<
name|quint16
argument_list|>
name|vertexSet
init|=
name|triangulator
operator|.
name|polyline
argument_list|()
decl_stmt|;
name|polyLineSet
operator|.
name|vertices
operator|=
name|vertexSet
operator|.
name|vertices
expr_stmt|;
name|polyLineSet
operator|.
name|indices
operator|.
name|setDataUshort
argument_list|(
name|vertexSet
operator|.
name|indices
argument_list|)
expr_stmt|;
comment|//    }
return|return
name|polyLineSet
return|;
block|}
end_function
begin_function
DECL|function|qPolyline
name|QPolylineSet
name|qPolyline
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|qreal
name|lod
parameter_list|)
block|{
name|QPolylineSet
name|polyLineSet
decl_stmt|;
if|#
directive|if
literal|0
block|if (QOpenGLExtensions::glExtensions()& QOpenGLExtensions::ElementIndexUint) {         QTriangulator<quint32> triangulator;         triangulator.initialize(path, matrix, lod);         QVertexSet<quint32> vertexSet = triangulator.polyline();         polyLineSet.vertices = vertexSet.vertices;         polyLineSet.indices.setDataUint(vertexSet.indices);     } else {
endif|#
directive|endif
name|QTriangulator
argument_list|<
name|quint16
argument_list|>
name|triangulator
decl_stmt|;
name|triangulator
operator|.
name|initialize
argument_list|(
name|path
argument_list|,
name|matrix
argument_list|,
name|lod
argument_list|)
expr_stmt|;
name|QVertexSet
argument_list|<
name|quint16
argument_list|>
name|vertexSet
init|=
name|triangulator
operator|.
name|polyline
argument_list|()
decl_stmt|;
name|polyLineSet
operator|.
name|vertices
operator|=
name|vertexSet
operator|.
name|vertices
expr_stmt|;
name|polyLineSet
operator|.
name|indices
operator|.
name|setDataUshort
argument_list|(
name|vertexSet
operator|.
name|indices
argument_list|)
expr_stmt|;
comment|//    }
return|return
name|polyLineSet
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
