begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Klaralvdalens Datakonsult AB (KDAB). ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopengltexture.h"
end_include
begin_include
include|#
directive|include
file|"qopengltexture_p.h"
end_include
begin_include
include|#
directive|include
file|"qopengltexturehelper_p.h"
end_include
begin_include
include|#
directive|include
file|"qopenglfunctions.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/qcolor.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qopenglcontext.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglcontext_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|//this is to work around GL_TEXTURE_WRAP_R_OES which also has 0x8072 as value
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GL_TEXTURE_WRAP_R
argument_list|)
end_if
begin_define
DECL|macro|GL_TEXTURE_WRAP_R
define|#
directive|define
name|GL_TEXTURE_WRAP_R
value|0x8072
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QOpenGLTexturePrivate
name|QOpenGLTexturePrivate
operator|::
name|QOpenGLTexturePrivate
parameter_list|(
name|QOpenGLTexture
operator|::
name|Target
name|textureTarget
parameter_list|,
name|QOpenGLTexture
modifier|*
name|qq
parameter_list|)
member_init_list|:
name|q_ptr
argument_list|(
name|qq
argument_list|)
member_init_list|,
name|context
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|target
argument_list|(
name|textureTarget
argument_list|)
member_init_list|,
name|textureId
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|format
argument_list|(
name|QOpenGLTexture
operator|::
name|NoFormat
argument_list|)
member_init_list|,
name|formatClass
argument_list|(
name|QOpenGLTexture
operator|::
name|NoFormatClass
argument_list|)
member_init_list|,
name|requestedMipLevels
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|mipLevels
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|layers
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|faces
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|samples
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fixedSamplePositions
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|baseLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLevel
argument_list|(
literal|1000
argument_list|)
member_init_list|,
name|depthStencilMode
argument_list|(
name|QOpenGLTexture
operator|::
name|DepthMode
argument_list|)
member_init_list|,
name|comparisonFunction
argument_list|(
name|QOpenGLTexture
operator|::
name|CompareLessEqual
argument_list|)
member_init_list|,
name|comparisonMode
argument_list|(
name|QOpenGLTexture
operator|::
name|CompareNone
argument_list|)
member_init_list|,
name|minFilter
argument_list|(
name|QOpenGLTexture
operator|::
name|Nearest
argument_list|)
member_init_list|,
name|magFilter
argument_list|(
name|QOpenGLTexture
operator|::
name|Nearest
argument_list|)
member_init_list|,
name|maxAnisotropy
argument_list|(
literal|1.0f
argument_list|)
member_init_list|,
name|minLevelOfDetail
argument_list|(
operator|-
literal|1000.0f
argument_list|)
member_init_list|,
name|maxLevelOfDetail
argument_list|(
literal|1000.0f
argument_list|)
member_init_list|,
name|levelOfDetailBias
argument_list|(
literal|0.0f
argument_list|)
member_init_list|,
name|textureView
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autoGenerateMipMaps
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|storageAllocated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|texFuncs
argument_list|(
literal|0
argument_list|)
block|{
name|dimensions
index|[
literal|0
index|]
operator|=
name|dimensions
index|[
literal|1
index|]
operator|=
name|dimensions
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget1D
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget1DArray
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget2D
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget2DArray
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget3D
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTargetCubeMap
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTargetCubeMapArray
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget2DMultisample
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTarget2DMultisampleArray
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTargetRectangle
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
name|bindingTarget
operator|=
name|QOpenGLTexture
operator|::
name|BindingTargetBuffer
expr_stmt|;
break|break;
block|}
name|swizzleMask
index|[
literal|0
index|]
operator|=
name|QOpenGLTexture
operator|::
name|RedValue
expr_stmt|;
name|swizzleMask
index|[
literal|1
index|]
operator|=
name|QOpenGLTexture
operator|::
name|GreenValue
expr_stmt|;
name|swizzleMask
index|[
literal|2
index|]
operator|=
name|QOpenGLTexture
operator|::
name|BlueValue
expr_stmt|;
name|swizzleMask
index|[
literal|3
index|]
operator|=
name|QOpenGLTexture
operator|::
name|AlphaValue
expr_stmt|;
name|wrapModes
index|[
literal|0
index|]
operator|=
name|wrapModes
index|[
literal|1
index|]
operator|=
name|wrapModes
index|[
literal|2
index|]
operator|=
name|target
operator|==
name|QOpenGLTexture
operator|::
name|TargetRectangle
condition|?
name|QOpenGLTexture
operator|::
name|ClampToEdge
else|:
name|QOpenGLTexture
operator|::
name|Repeat
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLTexturePrivate
name|QOpenGLTexturePrivate
operator|::
name|~
name|QOpenGLTexturePrivate
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|initializeOpenGLFunctions
name|void
name|QOpenGLTexturePrivate
operator|::
name|initializeOpenGLFunctions
parameter_list|()
block|{
comment|// If we already have a functions object, there is nothing to do
if|if
condition|(
name|texFuncs
condition|)
return|return;
comment|// See if the context already has a suitable resource we can use.
comment|// If not create a functions object and add it to the context in case
comment|// others wish to use it too
name|texFuncs
operator|=
name|context
operator|->
name|textureFunctions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|texFuncs
condition|)
block|{
name|texFuncs
operator|=
operator|new
name|QOpenGLTextureHelper
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|setTextureFunctions
argument_list|(
name|texFuncs
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create
name|bool
name|QOpenGLTexturePrivate
operator|::
name|create
parameter_list|()
block|{
if|if
condition|(
name|textureId
operator|!=
literal|0
condition|)
return|return
literal|true
return|;
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|qWarning
argument_list|(
literal|"Requires a valid current OpenGL context.\n"
literal|"Texture has not been created"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|context
operator|=
name|ctx
expr_stmt|;
comment|// Resolve any functions we will need based upon context version and create the texture
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
comment|// What features do we have?
name|QOpenGLTexture
operator|::
name|Feature
name|feature
init|=
name|QOpenGLTexture
operator|::
name|ImmutableStorage
decl_stmt|;
while|while
condition|(
name|feature
operator|!=
name|QOpenGLTexture
operator|::
name|MaxFeatureFlag
condition|)
block|{
if|if
condition|(
name|QOpenGLTexture
operator|::
name|hasFeature
argument_list|(
name|feature
argument_list|)
condition|)
name|features
operator||=
name|feature
expr_stmt|;
name|feature
operator|=
cast|static_cast
argument_list|<
name|QOpenGLTexture
operator|::
name|Feature
argument_list|>
argument_list|(
name|feature
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
name|texFuncs
operator|->
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|textureId
argument_list|)
expr_stmt|;
return|return
name|textureId
operator|!=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QOpenGLTexturePrivate
operator|::
name|destroy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|context
condition|)
block|{
comment|// not created or already destroyed
return|return;
block|}
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|!=
name|context
condition|)
block|{
name|qWarning
argument_list|(
literal|"Requires a valid current OpenGL context.\n"
literal|"Texture has not been destroyed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|texFuncs
operator|->
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|textureId
argument_list|)
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
name|textureId
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|QOpenGLTexture
operator|::
name|NoFormat
expr_stmt|;
name|formatClass
operator|=
name|QOpenGLTexture
operator|::
name|NoFormatClass
expr_stmt|;
name|requestedMipLevels
operator|=
literal|1
expr_stmt|;
name|mipLevels
operator|=
operator|-
literal|1
expr_stmt|;
name|layers
operator|=
literal|1
expr_stmt|;
name|faces
operator|=
literal|1
expr_stmt|;
name|samples
operator|=
literal|0
expr_stmt|;
name|fixedSamplePositions
operator|=
literal|true
operator|,
name|baseLevel
operator|=
literal|0
expr_stmt|;
name|maxLevel
operator|=
literal|1000
expr_stmt|;
name|depthStencilMode
operator|=
name|QOpenGLTexture
operator|::
name|DepthMode
expr_stmt|;
name|minFilter
operator|=
name|QOpenGLTexture
operator|::
name|Nearest
expr_stmt|;
name|magFilter
operator|=
name|QOpenGLTexture
operator|::
name|Nearest
expr_stmt|;
name|maxAnisotropy
operator|=
literal|1.0f
expr_stmt|;
name|minLevelOfDetail
operator|=
operator|-
literal|1000.0f
expr_stmt|;
name|maxLevelOfDetail
operator|=
literal|1000.0f
expr_stmt|;
name|levelOfDetailBias
operator|=
literal|0.0f
expr_stmt|;
name|textureView
operator|=
literal|false
expr_stmt|;
name|autoGenerateMipMaps
operator|=
literal|true
expr_stmt|;
name|storageAllocated
operator|=
literal|false
expr_stmt|;
name|texFuncs
operator|=
literal|0
expr_stmt|;
name|swizzleMask
index|[
literal|0
index|]
operator|=
name|QOpenGLTexture
operator|::
name|RedValue
expr_stmt|;
name|swizzleMask
index|[
literal|1
index|]
operator|=
name|QOpenGLTexture
operator|::
name|GreenValue
expr_stmt|;
name|swizzleMask
index|[
literal|2
index|]
operator|=
name|QOpenGLTexture
operator|::
name|BlueValue
expr_stmt|;
name|swizzleMask
index|[
literal|3
index|]
operator|=
name|QOpenGLTexture
operator|::
name|AlphaValue
expr_stmt|;
name|wrapModes
index|[
literal|0
index|]
operator|=
name|wrapModes
index|[
literal|1
index|]
operator|=
name|wrapModes
index|[
literal|2
index|]
operator|=
name|target
operator|==
name|QOpenGLTexture
operator|::
name|TargetRectangle
condition|?
name|QOpenGLTexture
operator|::
name|ClampToEdge
else|:
name|QOpenGLTexture
operator|::
name|Repeat
expr_stmt|;
block|}
end_function
begin_function
DECL|function|bind
name|void
name|QOpenGLTexturePrivate
operator|::
name|bind
parameter_list|()
block|{
name|texFuncs
operator|->
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|bind
name|void
name|QOpenGLTexturePrivate
operator|::
name|bind
parameter_list|(
name|uint
name|unit
parameter_list|,
name|QOpenGLTexture
operator|::
name|TextureUnitReset
name|reset
parameter_list|)
block|{
name|GLint
name|oldTextureUnit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reset
operator|==
name|QOpenGLTexture
operator|::
name|ResetTextureUnit
condition|)
name|texFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_ACTIVE_TEXTURE
argument_list|,
operator|&
name|oldTextureUnit
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|unit
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
operator|==
name|QOpenGLTexture
operator|::
name|ResetTextureUnit
condition|)
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|oldTextureUnit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QOpenGLTexturePrivate
operator|::
name|release
parameter_list|()
block|{
name|texFuncs
operator|->
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QOpenGLTexturePrivate
operator|::
name|release
parameter_list|(
name|uint
name|unit
parameter_list|,
name|QOpenGLTexture
operator|::
name|TextureUnitReset
name|reset
parameter_list|)
block|{
name|GLint
name|oldTextureUnit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reset
operator|==
name|QOpenGLTexture
operator|::
name|ResetTextureUnit
condition|)
name|texFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_ACTIVE_TEXTURE
argument_list|,
operator|&
name|oldTextureUnit
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|unit
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
operator|==
name|QOpenGLTexture
operator|::
name|ResetTextureUnit
condition|)
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|oldTextureUnit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isBound
name|bool
name|QOpenGLTexturePrivate
operator|::
name|isBound
parameter_list|()
specifier|const
block|{
name|GLint
name|boundTextureId
init|=
literal|0
decl_stmt|;
name|texFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|bindingTarget
argument_list|,
operator|&
name|boundTextureId
argument_list|)
expr_stmt|;
return|return
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|boundTextureId
argument_list|)
operator|==
name|textureId
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isBound
name|bool
name|QOpenGLTexturePrivate
operator|::
name|isBound
parameter_list|(
name|uint
name|unit
parameter_list|)
specifier|const
block|{
name|GLint
name|oldTextureUnit
init|=
literal|0
decl_stmt|;
name|texFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_ACTIVE_TEXTURE
argument_list|,
operator|&
name|oldTextureUnit
argument_list|)
expr_stmt|;
name|GLint
name|boundTextureId
init|=
literal|0
decl_stmt|;
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|unit
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glGetIntegerv
argument_list|(
name|bindingTarget
argument_list|,
operator|&
name|boundTextureId
argument_list|)
expr_stmt|;
name|bool
name|result
init|=
operator|(
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|boundTextureId
argument_list|)
operator|==
name|textureId
operator|)
decl_stmt|;
name|texFuncs
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|oldTextureUnit
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|evaluateMipLevels
name|int
name|QOpenGLTexturePrivate
operator|::
name|evaluateMipLevels
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
return|return
name|qMin
argument_list|(
name|maximumMipLevelCount
argument_list|()
argument_list|,
name|qMax
argument_list|(
literal|1
argument_list|,
name|requestedMipLevels
argument_list|)
argument_list|)
return|;
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|isSizedTextureFormat
specifier|static
name|bool
name|isSizedTextureFormat
parameter_list|(
name|QOpenGLTexture
operator|::
name|TextureFormat
name|internalFormat
parameter_list|)
block|{
switch|switch
condition|(
name|internalFormat
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|NoFormat
case|:
return|return
literal|false
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|R32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|R8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|R32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|R32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB9E5
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11B10F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG3B2
case|:
case|case
name|QOpenGLTexture
operator|::
name|R5G6B5
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB5A1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA4
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB10A2
case|:
case|case
name|QOpenGLTexture
operator|::
name|D16
case|:
case|case
name|QOpenGLTexture
operator|::
name|D24
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|D24S8
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32FS8X24
case|:
case|case
name|QOpenGLTexture
operator|::
name|S8
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNSIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_SIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_BP_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_ETC2_EAC
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8_ETC2_EAC
case|:
return|return
literal|true
return|;
case|case
name|QOpenGLTexture
operator|::
name|DepthFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|AlphaFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBAFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|LuminanceFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|LuminanceAlphaFormat
case|:
return|return
literal|false
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isTextureTargetMultisample
specifier|static
name|bool
name|isTextureTargetMultisample
parameter_list|(
name|QOpenGLTexture
operator|::
name|Target
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
return|return
literal|false
return|;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
return|return
literal|true
return|;
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
return|return
literal|false
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|allocateStorage
name|void
name|QOpenGLTexturePrivate
operator|::
name|allocateStorage
parameter_list|(
name|QOpenGLTexture
operator|::
name|PixelFormat
name|pixelFormat
parameter_list|,
name|QOpenGLTexture
operator|::
name|PixelType
name|pixelType
parameter_list|)
block|{
comment|// Resolve the actual number of mipmap levels we can use
name|mipLevels
operator|=
name|evaluateMipLevels
argument_list|()
expr_stmt|;
comment|// Use immutable storage whenever possible, falling back to mutable
comment|// Note that if multisample textures are not supported at all, we'll still fail into
comment|// the mutable storage allocation
specifier|const
name|bool
name|useImmutableStorage
init|=
name|isSizedTextureFormat
argument_list|(
name|format
argument_list|)
operator|&&
operator|(
name|isTextureTargetMultisample
argument_list|(
name|target
argument_list|)
condition|?
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|ImmutableMultisampleStorage
argument_list|)
else|:
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|ImmutableStorage
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|useImmutableStorage
condition|)
name|allocateImmutableStorage
argument_list|()
expr_stmt|;
else|else
name|allocateMutableStorage
argument_list|(
name|pixelFormat
argument_list|,
name|pixelType
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pixelFormatCompatibleWithInternalFormat
specifier|static
name|QOpenGLTexture
operator|::
name|PixelFormat
name|pixelFormatCompatibleWithInternalFormat
parameter_list|(
name|QOpenGLTexture
operator|::
name|TextureFormat
name|internalFormat
parameter_list|)
block|{
switch|switch
condition|(
name|internalFormat
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|NoFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|NoSourceFormat
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG8_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG16_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB16_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG8_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG16_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB16_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8U
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG8U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA8U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16U
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG16U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB16U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA16U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R32U
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG32U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB32U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA32U
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8I
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG8I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA8I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16I
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG16I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB16I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA16I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R32I
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG32I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB32I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA32I
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA_Integer
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG16F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB16F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA16F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB9E5
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG11B10F
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG3B2
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|R5G6B5
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB5A1
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA4
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB10A2
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|D16
case|:
case|case
name|QOpenGLTexture
operator|::
name|D24
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Depth
return|;
case|case
name|QOpenGLTexture
operator|::
name|D24S8
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32FS8X24
case|:
return|return
name|QOpenGLTexture
operator|::
name|DepthStencil
return|;
case|case
name|QOpenGLTexture
operator|::
name|S8
case|:
return|return
name|QOpenGLTexture
operator|::
name|Stencil
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNSIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_SIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_BP_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Red
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|RG
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_ETC2
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGB
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_PunchThrough_Alpha1_ETC2
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_ETC2_EAC
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8_ETC2_EAC
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|DepthFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|Depth
return|;
case|case
name|QOpenGLTexture
operator|::
name|AlphaFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|Alpha
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBAFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|RGBA
return|;
case|case
name|QOpenGLTexture
operator|::
name|LuminanceFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|Luminance
return|;
case|case
name|QOpenGLTexture
operator|::
name|LuminanceAlphaFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|LuminanceAlpha
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QOpenGLTexture
operator|::
name|NoSourceFormat
return|;
block|}
end_function
begin_function
DECL|function|pixelTypeCompatibleWithInternalFormat
specifier|static
name|QOpenGLTexture
operator|::
name|PixelType
name|pixelTypeCompatibleWithInternalFormat
parameter_list|(
name|QOpenGLTexture
operator|::
name|TextureFormat
name|internalFormat
parameter_list|)
block|{
switch|switch
condition|(
name|internalFormat
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|NoFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|NoPixelType
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_UNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16_SNorm
case|:
return|return
name|QOpenGLTexture
operator|::
name|Int8
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8U
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16U
case|:
case|case
name|QOpenGLTexture
operator|::
name|R32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32U
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32U
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8
return|;
case|case
name|QOpenGLTexture
operator|::
name|R8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8I
case|:
case|case
name|QOpenGLTexture
operator|::
name|R16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16I
case|:
case|case
name|QOpenGLTexture
operator|::
name|R32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32I
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32I
case|:
return|return
name|QOpenGLTexture
operator|::
name|Int8
return|;
case|case
name|QOpenGLTexture
operator|::
name|R16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB16F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA16F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Float16
return|;
case|case
name|QOpenGLTexture
operator|::
name|R32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB32F
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Float32
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB9E5
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt16_RGB5A1_Rev
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG11B10F
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt32_RG11B10F
return|;
case|case
name|QOpenGLTexture
operator|::
name|RG3B2
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8_RG3B2
return|;
case|case
name|QOpenGLTexture
operator|::
name|R5G6B5
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt16_R5G6B5
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB5A1
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt16_RGB5A1
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGBA4
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt16_RGBA4
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB10A2
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt32_RGB10A2
return|;
case|case
name|QOpenGLTexture
operator|::
name|D16
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt16
return|;
case|case
name|QOpenGLTexture
operator|::
name|D24
case|:
case|case
name|QOpenGLTexture
operator|::
name|D32
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt32
return|;
case|case
name|QOpenGLTexture
operator|::
name|D32F
case|:
return|return
name|QOpenGLTexture
operator|::
name|Float32
return|;
case|case
name|QOpenGLTexture
operator|::
name|D24S8
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt32_D24S8
return|;
case|case
name|QOpenGLTexture
operator|::
name|D32FS8X24
case|:
return|return
name|QOpenGLTexture
operator|::
name|Float32_D32_UInt32_S8_X24
return|;
case|case
name|QOpenGLTexture
operator|::
name|S8
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8
return|;
case|case
name|QOpenGLTexture
operator|::
name|RGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R_ATI1N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG_ATI2N_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNSIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_SIGNED_FLOAT
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB_BP_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT1
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT3
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT5
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB_BP_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_ETC2_EAC
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8_ETC2_EAC
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8
return|;
case|case
name|QOpenGLTexture
operator|::
name|DepthFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt32
return|;
case|case
name|QOpenGLTexture
operator|::
name|AlphaFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBAFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|LuminanceFormat
case|:
case|case
name|QOpenGLTexture
operator|::
name|LuminanceAlphaFormat
case|:
return|return
name|QOpenGLTexture
operator|::
name|UInt8
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QOpenGLTexture
operator|::
name|NoPixelType
return|;
block|}
end_function
begin_function
DECL|function|allocateMutableStorage
name|void
name|QOpenGLTexturePrivate
operator|::
name|allocateMutableStorage
parameter_list|(
name|QOpenGLTexture
operator|::
name|PixelFormat
name|pixelFormat
parameter_list|,
name|QOpenGLTexture
operator|::
name|PixelType
name|pixelType
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
comment|// Buffer textures get their storage from an external OpenGL buffer
name|qWarning
argument_list|(
literal|"Buffer textures do not allocate storage"
argument_list|)
expr_stmt|;
return|return;
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture1D
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage1D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"1D textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture1D
argument_list|)
operator|&&
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|layers
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"1D array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
block|{
comment|// Cubemaps are the odd one out. We have to allocate storage for each
comment|// face and miplevel using the special cubemap face targets rather than
comment|// GL_TARGET_CUBEMAP.
specifier|const
name|QOpenGLTexture
operator|::
name|CubeMapFace
name|faceTargets
index|[]
init|=
block|{
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
block|,
name|QOpenGLTexture
operator|::
name|CubeMapNegativeX
block|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveY
block|,
name|QOpenGLTexture
operator|::
name|CubeMapNegativeY
block|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveZ
block|,
name|QOpenGLTexture
operator|::
name|CubeMapNegativeZ
block|}
decl_stmt|;
for|for
control|(
name|int
name|faceTarget
init|=
literal|0
init|;
name|faceTarget
operator|<
literal|6
condition|;
operator|++
name|faceTarget
control|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
block|{
name|texFuncs
operator|->
name|glTextureImage2D
argument_list|(
name|textureId
argument_list|,
name|faceTargets
index|[
name|faceTarget
index|]
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|layers
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
comment|// Cubemap arrays must specify number of layer-faces (6 * layers) as depth parameter
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureCubeMapArrays
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|6
operator|*
name|layers
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Cubemap Array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture3D
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|mipLevels
condition|;
operator|++
name|level
control|)
name|texFuncs
operator|->
name|glTextureImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|level
argument_list|,
name|dimensions
index|[
literal|2
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pixelFormat
argument_list|,
name|pixelType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"3D textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureMultisample
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureImage2DMultisample
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|samples
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|fixedSamplePositions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Multisample textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureMultisample
argument_list|)
operator|&&
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureImage3DMultisample
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|samples
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|layers
argument_list|,
name|fixedSamplePositions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Multisample array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|storageAllocated
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allocateImmutableStorage
name|void
name|QOpenGLTexturePrivate
operator|::
name|allocateImmutableStorage
parameter_list|()
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
comment|// Buffer textures get their storage from an external OpenGL buffer
name|qWarning
argument_list|(
literal|"Buffer textures do not allocate storage"
argument_list|)
expr_stmt|;
return|return;
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture1D
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage1D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"1D textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture1D
argument_list|)
operator|&&
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|layers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"1D array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|texFuncs
operator|->
name|glTextureStorage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|layers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
comment|// Cubemap arrays must specify number of layer-faces (6 * layers) as depth parameter
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureCubeMapArrays
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
literal|6
operator|*
name|layers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Cubemap Array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|Texture3D
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevels
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|dimensions
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"3D textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|ImmutableMultisampleStorage
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage2DMultisample
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|samples
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|fixedSamplePositions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Multisample textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
if|if
condition|(
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|ImmutableMultisampleStorage
argument_list|)
operator|&&
name|features
operator|.
name|testFlag
argument_list|(
name|QOpenGLTexture
operator|::
name|TextureArrays
argument_list|)
condition|)
block|{
name|texFuncs
operator|->
name|glTextureStorage3DMultisample
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|samples
argument_list|,
name|format
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|layers
argument_list|,
name|fixedSamplePositions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Multisample array textures are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|storageAllocated
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setData
name|void
name|QOpenGLTexturePrivate
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|QOpenGLTexture
operator|::
name|CubeMapFace
name|cubeFace
parameter_list|,
name|QOpenGLTexture
operator|::
name|PixelFormat
name|sourceFormat
parameter_list|,
name|QOpenGLTexture
operator|::
name|PixelType
name|sourceType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage1D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|cubeFace
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
block|{
name|int
name|faceIndex
init|=
name|cubeFace
operator|-
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
decl_stmt|;
name|int
name|layerFace
init|=
literal|6
operator|*
name|layer
operator|+
name|faceIndex
decl_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerFace
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|Q_UNUSED
argument_list|(
name|mipLevel
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
comment|// We don't upload pixel data for these targets
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setData(): Texture target does not support pixel data upload"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// If requested perform automatic mip map generation
if|if
condition|(
name|mipLevel
operator|==
literal|0
operator|&&
name|autoGenerateMipMaps
operator|&&
name|mipLevels
operator|>
literal|1
condition|)
block|{
name|Q_Q
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|q
operator|->
name|generateMipMaps
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexturePrivate
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|QOpenGLTexture
operator|::
name|CubeMapFace
name|cubeFace
parameter_list|,
name|int
name|dataSize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage1D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|cubeFace
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
block|{
name|int
name|faceIndex
init|=
name|cubeFace
operator|-
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
decl_stmt|;
name|int
name|layerFace
init|=
literal|6
operator|*
name|layer
operator|+
name|faceIndex
decl_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage3D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|mipLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerFace
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mipLevelSize
argument_list|(
name|mipLevel
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|Q_UNUSED
argument_list|(
name|mipLevel
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|cubeFace
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glCompressedTextureSubImage2D
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dimensions
index|[
literal|0
index|]
argument_list|,
name|dimensions
index|[
literal|1
index|]
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
comment|// We don't upload pixel data for these targets
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setCompressedData(): Texture target does not support pixel data upload"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// If requested perform automatic mip map generation
if|if
condition|(
name|mipLevel
operator|==
literal|0
operator|&&
name|autoGenerateMipMaps
operator|&&
name|mipLevels
operator|>
literal|1
condition|)
block|{
name|Q_Q
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|q
operator|->
name|generateMipMaps
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setWrapMode
name|void
name|QOpenGLTexturePrivate
operator|::
name|setWrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|WrapMode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|wrapModes
index|[
literal|1
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|wrapModes
index|[
literal|1
index|]
operator|=
name|wrapModes
index|[
literal|2
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_R
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|setWrapMode
name|void
name|QOpenGLTexturePrivate
operator|::
name|setWrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|CoordinateDirection
name|direction
parameter_list|,
name|QOpenGLTexture
operator|::
name|WrapMode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setWrapMode() direction not valid for this texture target"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
name|wrapModes
index|[
literal|1
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setWrapMode() direction not valid for this texture target"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
name|wrapModes
index|[
literal|0
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
name|wrapModes
index|[
literal|1
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
name|wrapModes
index|[
literal|2
index|]
operator|=
name|mode
expr_stmt|;
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|textureId
argument_list|,
name|target
argument_list|,
name|bindingTarget
argument_list|,
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
end_function
begin_function
DECL|function|wrapMode
name|QOpenGLTexture
operator|::
name|WrapMode
name|QOpenGLTexturePrivate
operator|::
name|wrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|CoordinateDirection
name|direction
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
return|return
name|wrapModes
index|[
literal|0
index|]
return|;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
name|qWarning
argument_list|(
literal|"QOpenGLTexture::wrapMode() direction not valid for this texture target"
argument_list|)
expr_stmt|;
return|return
name|QOpenGLTexture
operator|::
name|Repeat
return|;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
return|return
name|wrapModes
index|[
literal|0
index|]
return|;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
return|return
name|wrapModes
index|[
literal|1
index|]
return|;
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
name|qWarning
argument_list|(
literal|"QOpenGLTexture::wrapMode() direction not valid for this texture target"
argument_list|)
expr_stmt|;
return|return
name|QOpenGLTexture
operator|::
name|Repeat
return|;
block|}
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|DirectionS
case|:
return|return
name|wrapModes
index|[
literal|0
index|]
return|;
case|case
name|QOpenGLTexture
operator|::
name|DirectionT
case|:
return|return
name|wrapModes
index|[
literal|1
index|]
return|;
case|case
name|QOpenGLTexture
operator|::
name|DirectionR
case|:
return|return
name|wrapModes
index|[
literal|2
index|]
return|;
block|}
break|break;
block|}
comment|// Should never get here
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|QOpenGLTexture
operator|::
name|Repeat
return|;
block|}
end_function
begin_function
DECL|function|createTextureView
name|QOpenGLTexture
modifier|*
name|QOpenGLTexturePrivate
operator|::
name|createTextureView
parameter_list|(
name|QOpenGLTexture
operator|::
name|Target
name|viewTarget
parameter_list|,
name|QOpenGLTexture
operator|::
name|TextureFormat
name|viewFormat
parameter_list|,
name|int
name|minimumMipmapLevel
parameter_list|,
name|int
name|maximumMipmapLevel
parameter_list|,
name|int
name|minimumLayer
parameter_list|,
name|int
name|maximumLayer
parameter_list|)
specifier|const
block|{
comment|// Do sanity checks - see http://www.opengl.org/wiki/GLAPI/glTextureView
comment|// Check the targets are compatible
name|bool
name|viewTargetCompatible
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target1D
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target1DArray
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2D
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2DArray
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target3D
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|TargetCubeMap
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2D
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2DArray
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2DMultisample
operator|||
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|viewTargetCompatible
operator|=
operator|(
name|viewTarget
operator|==
name|QOpenGLTexture
operator|::
name|TargetRectangle
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
comment|// Cannot be used with texture views
break|break;
block|}
if|if
condition|(
operator|!
name|viewTargetCompatible
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::createTextureView(): Incompatible source and view targets"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// Check the formats are compatible
name|bool
name|viewFormatCompatible
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|formatClass
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|NoFormatClass
case|:
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_128Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA32F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA32U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA32I
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_96Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB32F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB32U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB32I
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_64Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA16F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG32F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA16U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG32U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA16I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG32I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA16_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA16_SNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_48Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB16_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB16_SNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB16F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB16U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB16I
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_32Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG16F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG11B10F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R32F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB10A2
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA8U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG16U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R32U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA8I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG16I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R32I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA8_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG16_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA8_SNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG16_SNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB9E5
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_24Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB8_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB8_SNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB8
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB8U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB8I
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_16Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R16F
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG8U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R16U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG8I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R16I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG8_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R16_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG8_SNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R16_SNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_8Bit
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R8U
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R8I
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R8_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R8_SNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_RGTC1_R
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R_ATI1N_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|R_ATI1N_SNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_RGTC2_RG
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG_ATI2N_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RG_ATI2N_SNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_BPTC_Unorm
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB_BP_UNorm
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB_BP_UNorm
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_BPTC_Float
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB_BP_UNSIGNED_FLOAT
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB_BP_SIGNED_FLOAT
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_S3TC_DXT1_RGB
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGB_DXT1
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB_DXT1
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_S3TC_DXT1_RGBA
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA_DXT1
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT1
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_S3TC_DXT3_RGBA
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA_DXT3
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT3
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_S3TC_DXT5_RGBA
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|RGBA_DXT5
operator|||
name|viewFormat
operator|==
name|QOpenGLTexture
operator|::
name|SRGB_Alpha_DXT5
operator|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|FormatClass_Unique
case|:
name|viewFormatCompatible
operator|=
operator|(
name|viewFormat
operator|==
name|format
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|viewFormatCompatible
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::createTextureView(): Incompatible source and view formats"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// Create a view
name|QOpenGLTexture
modifier|*
name|view
init|=
operator|new
name|QOpenGLTexture
argument_list|(
name|viewTarget
argument_list|)
decl_stmt|;
name|view
operator|->
name|setFormat
argument_list|(
name|viewFormat
argument_list|)
expr_stmt|;
name|view
operator|->
name|create
argument_list|()
expr_stmt|;
name|view
operator|->
name|d_ptr
operator|->
name|textureView
operator|=
literal|true
expr_stmt|;
name|texFuncs
operator|->
name|glTextureView
argument_list|(
name|view
operator|->
name|textureId
argument_list|()
argument_list|,
name|viewTarget
argument_list|,
name|textureId
argument_list|,
name|viewFormat
argument_list|,
name|minimumMipmapLevel
argument_list|,
name|maximumMipmapLevel
operator|-
name|minimumMipmapLevel
operator|+
literal|1
argument_list|,
name|minimumLayer
argument_list|,
name|maximumLayer
operator|-
name|minimumLayer
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|view
return|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLTexture     \inmodule QtGui     \since 5.2     \wrapper     \brief The QOpenGLTexture class encapsulates an OpenGL texture object.      QOpenGLTexture makes it easy to work with OpenGL textures and the myriad features     and targets that they offer depending upon the capabilities of your OpenGL implementation.      The typical usage pattern for QOpenGLTexture is     \list         \li Instantiate the object specifying the texture target type         \li Set properties that affect the storage requirements e.g. storage format, dimensions         \li Allocate the server-side storage         \li Optionally upload pixel data         \li Optionally set any additional properties e.g. filtering and border options         \li Render with texture or render to texture     \endlist      In the common case of simply using a QImage as the source of texture pixel data     most of the above steps are performed automatically.      \code     // Prepare texture     QOpenGLTexture *texture = new QOpenGLTexture(QImage(fileName).mirrored());     texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);     texture->setMagnificationFilter(QOpenGLTexture::Linear);     ...     // Render with texture     texture->bind();     glDrawArrays(...);     \endcode      Note that the QImage is mirrored vertically to account for the fact that     OpenGL and QImage use opposite directions for the y axis. Another option     would be to transform your texture coordinates. */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::Filter     This enum defines the filtering parameters for a QOpenGLTexture object.     \value Nearest Equivalent to GL_NEAREST     \value Linear Equivalent to GL_LINEAR     \value NearestMipMapNearest Equivalent to GL_NEAREST_MIPMAP_NEAREST     \value NearestMipMapLinear Equivalent to GL_NEAREST_MIPMAP_LINEAR     \value LinearMipMapNearest Equivalent to GL_LINEAR_MIPMAP_NEAREST     \value LinearMipMapLinear Equivalent to GL_LINEAR_MIPMAP_LINEAR */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::Target     This enum defines the texture target of a QOpenGLTexture object.      \value Target1D A 1-dimensional texture.            Equivalent to GL_TEXTURE_1D.     \value Target1DArray An array of 1-dimensional textures.            Equivalent to GL_TEXTURE_1D_ARRAY     \value Target2D A 2-dimensional texture.            Equivalent to GL_TEXTURE_2D     \value Target2DArray An array of 1-dimensional textures.            Equivalent to GL_TEXTURE_2D_ARRAY     \value Target3D A 3-dimensional texture.            Equivalent to GL_TEXTURE_3D     \value TargetCubeMap A cubemap texture.            Equivalent to GL_TEXTURE_CUBE_MAP     \value TargetCubeMapArray An array of cubemap textures.            Equivalent to GL_TEXTURE_CUBE_MAP_ARRAY     \value Target2DMultisample A 2-dimensional texture with multisample support.            Equivalent to GL_TEXTURE_2D_MULTISAMPLE     \value Target2DMultisampleArray An array of 2-dimensional textures with multisample support.            Equivalent to GL_TEXTURE_2D_MULTISAMPLE_ARRAY     \value TargetRectangle A rectangular 2-dimensional texture.            Equivalent to GL_TEXTURE_RECTANGLE     \value TargetBuffer A texture with data from an OpenGL buffer object.            Equivalent to GL_TEXTURE_BUFFER */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::BindingTarget     This enum defines the possible binding targets of texture units.      \value BindingTarget1D Equivalent to GL_TEXTURE_BINDING_1D     \value BindingTarget1DArray Equivalent to GL_TEXTURE_BINDING_1D_ARRAY     \value BindingTarget2D Equivalent to GL_TEXTURE_BINDING_2D     \value BindingTarget2DArray Equivalent to GL_TEXTURE_BINDING_2D_ARRAY     \value BindingTarget3D Equivalent to GL_TEXTURE_BINDING_3D     \value BindingTargetCubeMap Equivalent to GL_TEXTURE_BINDING_CUBE_MAP     \value BindingTargetCubeMapArray Equivalent to GL_TEXTURE_BINDING_CUBE_MAP_ARRAY     \value BindingTarget2DMultisample Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE     \value BindingTarget2DMultisampleArray Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY     \value BindingTargetRectangle Equivalent to GL_TEXTURE_BINDING_RECTANGLE     \value BindingTargetBuffer Equivalent to GL_TEXTURE_BINDING_BUFFER */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::MipMapGeneration     This enum defines the options to control mipmap generation.      \value GenerateMipMaps Mipmaps should be generated     \value DontGenerateMipMaps Mipmaps should not be generated */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::TextureUnitReset     This enum defines options ot control texture unit activation.      \value ResetTextureUnit The previous active texture unit will be reset     \value DontResetTextureUnit The previous active texture unit will not be rest */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::TextureFormat     This enum defines the possible texture formats. Depending upon your OpenGL     implementation only a subset of these may be supported.      \value NoFormat Equivalent to GL_NONE      \value R8_UNorm Equivalent to GL_R8     \value RG8_UNorm Equivalent to GL_RG8     \value RGB8_UNorm Equivalent to GL_RGB8     \value RGBA8_UNorm Equivalent to GL_RGBA8      \value R16_UNorm Equivalent to GL_R16     \value RG16_UNorm Equivalent to GL_RG16     \value RGB16_UNorm Equivalent to GL_RGB16     \value RGBA16_UNorm Equivalent to GL_RGBA16      \value R8_SNorm Equivalent to GL_R8_SNORM     \value RG8_SNorm Equivalent to GL_RG8_SNORM     \value RGB8_SNorm Equivalent to GL_RGB8_SNORM     \value RGBA8_SNorm Equivalent to GL_RGBA8_SNORM      \value R16_SNorm Equivalent to GL_R16_SNORM     \value RG16_SNorm Equivalent to GL_RG16_SNORM     \value RGB16_SNorm Equivalent to GL_RGB16_SNORM     \value RGBA16_SNorm Equivalent to GL_RGBA16_SNORM      \value R8U Equivalent to GL_R8UI     \value RG8U Equivalent to GL_RG8UI     \value RGB8U Equivalent to GL_RGB8UI     \value RGBA8U Equivalent to GL_RGBA8UI      \value R16U Equivalent to GL_R16UI     \value RG16U Equivalent to GL_RG16UI     \value RGB16U Equivalent to GL_RGB16UI     \value RGBA16U Equivalent to GL_RGBA16UI      \value R32U Equivalent to GL_R32UI     \value RG32U Equivalent to GL_RG32UI     \value RGB32U Equivalent to GL_RGB32UI     \value RGBA32U Equivalent to GL_RGBA32UI      \value R8I Equivalent to GL_R8I     \value RG8I Equivalent to GL_RG8I     \value RGB8I Equivalent to GL_RGB8I     \value RGBA8I Equivalent to GL_RGBA8I      \value R16I Equivalent to GL_R16I     \value RG16I Equivalent to GL_RG16I     \value RGB16I Equivalent to GL_RGB16I     \value RGBA16I Equivalent to GL_RGBA16I      \value R32I Equivalent to GL_R32I     \value RG32I Equivalent to GL_RG32I     \value RGB32I Equivalent to GL_RGB32I     \value RGBA32I Equivalent to GL_RGBA32I      \value R16F Equivalent to GL_R16F     \value RG16F Equivalent to GL_RG16F     \value RGB16F Equivalent to GL_RGB16F     \value RGBA16F Equivalent to GL_RGBA16F      \value R32F Equivalent to GL_R32F     \value RG32F Equivalent to GL_RG32F     \value RGB32F Equivalent to GL_RGB32F     \value RGBA32F Equivalent to GL_RGBA32F      \value RGB9E5 Equivalent to GL_RGB9_E5     \value RG11B10F Equivalent to GL_R11F_G11F_B10F     \value RG3B2 Equivalent to GL_R3_G3_B2     \value R5G6B5 Equivalent to GL_RGB565     \value RGB5A1 Equivalent to GL_RGB5_A1     \value RGBA4 Equivalent to GL_RGBA4     \value RGB10A2 Equivalent to GL_RGB10_A2UI      \value D16 Equivalent to GL_DEPTH_COMPONENT16     \value D24 Equivalent to GL_DEPTH_COMPONENT24     \value D24S8 Equivalent to GL_DEPTH24_STENCIL8     \value D32 Equivalent to GL_DEPTH_COMPONENT32     \value D32F Equivalent to GL_DEPTH_COMPONENT32F     \value D32FS8X24 Equivalent to GL_DEPTH32F_STENCIL8     \value S8 Equivalent to GL_STENCIL_INDEX8. Introduced in Qt 5.4      \value RGB_DXT1 Equivalent to GL_COMPRESSED_RGB_S3TC_DXT1_EXT     \value RGBA_DXT1 Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT1_EXT     \value RGBA_DXT3 Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT3_EXT     \value RGBA_DXT5 Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT5_EXT     \value R_ATI1N_UNorm Equivalent to GL_COMPRESSED_RED_RGTC1     \value R_ATI1N_SNorm Equivalent to GL_COMPRESSED_SIGNED_RED_RGTC1     \value RG_ATI2N_UNorm Equivalent to GL_COMPRESSED_RG_RGTC2     \value RG_ATI2N_SNorm Equivalent to GL_COMPRESSED_SIGNED_RG_RGTC2     \value RGB_BP_UNSIGNED_FLOAT Equivalent to GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB     \value RGB_BP_SIGNED_FLOAT Equivalent to GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB     \value RGB_BP_UNorm Equivalent to GL_COMPRESSED_RGBA_BPTC_UNORM_ARB     \value R11_EAC_UNorm Equivalent to GL_COMPRESSED_R11_EAC     \value R11_EAC_SNorm Equivalent to GL_COMPRESSED_SIGNED_R11_EAC     \value RG11_EAC_UNorm Equivalent to GL_COMPRESSED_RG11_EAC     \value RG11_EAC_SNorm Equivalent to GL_COMPRESSED_SIGNED_RG11_EAC     \value RGB8_ETC2 Equivalent to GL_COMPRESSED_RGB8_ETC2     \value SRGB8_ETC2 Equivalent to GL_COMPRESSED_SRGB8_ETC2     \value RGB8_PunchThrough_Alpha1_ETC2 Equivalent to GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2     \value SRGB8_PunchThrough_Alpha1_ETC2 Equivalent to GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2     \value RGBA8_ETC2_EAC Equivalent to GL_COMPRESSED_RGBA8_ETC2_EAC     \value SRGB8_Alpha8_ETC2_EAC Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC      \value SRGB8 Equivalent to GL_SRGB8     \value SRGB8_Alpha8 Equivalent to GL_SRGB8_ALPHA8     \value SRGB_DXT1 Equivalent to GL_COMPRESSED_SRGB_S3TC_DXT1_EXT     \value SRGB_Alpha_DXT1 Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT     \value SRGB_Alpha_DXT3 Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT     \value SRGB_Alpha_DXT5 Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT     \value SRGB_BP_UNorm Equivalent to GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB      \value DepthFormat Equivalent to GL_DEPTH_COMPONENT (only OpenGL ES 3 or ES 2 with OES_depth_texture)     \value AlphaFormat Equivalent to GL_ALPHA (OpenGL ES 2 only)     \value RGBFormat Equivalent to GL_RGB (OpenGL ES 2 only)     \value RGBAFormat Equivalent to GL_RGBA (OpenGL ES 2 only)     \value LuminanceFormat Equivalent to GL_LUMINANCE (OpenGL ES 2 only)     \value LuminanceAlphaFormat Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only) */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::CubeMapFace     This enum defines the possible CubeMap faces.      \value CubeMapPositiveX Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_X     \value CubeMapNegativeX Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_X     \value CubeMapPositiveY Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Y     \value CubeMapNegativeY Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Y     \value CubeMapPositiveZ Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Z     \value CubeMapNegativeZ Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Z */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::PixelFormat     This enum defines the possible client-side pixel formats for a pixel     transfer operation.      \value NoSourceFormat Equivalent to GL_NONE     \value Red Equivalent to GL_RED     \value RG Equivalent to GL_RG     \value RGB Equivalent to GL_RGB     \value BGR Equivalent to GL_BGR     \value RGBA Equivalent to GL_RGBA     \value BGRA Equivalent to GL_BGRA     \value Red_Integer Equivalent to GL_RED_INTEGER     \value RG_Integer Equivalent to GL_RG_INTEGER     \value RGB_Integer Equivalent to GL_RGB_INTEGER     \value BGR_Integer Equivalent to GL_BGR_INTEGER     \value RGBA_Integer Equivalent to GL_RGBA_INTEGER     \value BGRA_Integer Equivalent to GL_BGRA_INTEGER     \value Stencil Equivalent to GL_STENCIL_INDEX. Introduced in Qt 5.4     \value Depth Equivalent to GL_DEPTH_COMPONENT     \value DepthStencil Equivalent to GL_DEPTH_STENCIL     \value Alpha Equivalent to GL_ALPHA (OpenGL ES 2 only)     \value Luminance Equivalent to GL_LUMINANCE (OpenGL ES 2 only)     \value LuminanceAlpha Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)  */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::PixelType     This enum defines the possible pixel data types for a pixel transfer operation      \value NoPixelType Equivalent to GL_NONE     \value Int8 Equivalent to GL_BYTE     \value UInt8 Equivalent to GL_UNSIGNED_BYTE     \value Int16 Equivalent to GL_SHORT     \value UInt16 Equivalent to GL_UNSIGNED_SHORT     \value Int32 Equivalent to GL_INT     \value UInt32 Equivalent to GL_UNSIGNED_INT     \value Float16 Equivalent to GL_HALF_FLOAT     \value Float16OES Equivalent to GL_HALF_FLOAT_OES     \value Float32 Equivalent to GL_FLOAT     \value UInt32_RGB9_E5 Equivalent to GL_UNSIGNED_INT_5_9_9_9_REV     \value UInt32_RG11B10F Equivalent to GL_UNSIGNED_INT_10F_11F_11F_REV     \value UInt8_RG3B2 Equivalent to GL_UNSIGNED_BYTE_3_3_2     \value UInt8_RG3B2_Rev Equivalent to GL_UNSIGNED_BYTE_2_3_3_REV     \value UInt16_RGB5A1 Equivalent to GL_UNSIGNED_SHORT_5_5_5_1     \value UInt16_RGB5A1_Rev Equivalent to GL_UNSIGNED_SHORT_1_5_5_5_REV     \value UInt16_R5G6B5 Equivalent to GL_UNSIGNED_SHORT_5_6_5     \value UInt16_R5G6B5_Rev Equivalent to GL_UNSIGNED_SHORT_5_6_5_REV     \value UInt16_RGBA4 Equivalent to GL_UNSIGNED_SHORT_4_4_4_4     \value UInt16_RGBA4_Rev Equivalent to GL_UNSIGNED_SHORT_4_4_4_4_REV     \value UInt32_RGBA8 Equivalent to GL_UNSIGNED_INT_8_8_8_8     \value UInt32_RGBA8_Rev Equivalent to GL_UNSIGNED_INT_8_8_8_8_REV     \value UInt32_RGB10A2 Equivalent to GL_UNSIGNED_INT_10_10_10_2     \value UInt32_RGB10A2_Rev Equivalent to GL_UNSIGNED_INT_2_10_10_10_REV     \value UInt32_D24S8 Equivalent to GL_UNSIGNED_INT_24_8. Introduced in Qt 5.4     \value Float32_D32_UInt32_S8_X24 Equivalent to GL_FLOAT_32_UNSIGNED_INT_24_8_REV. Introduced in Qt 5.4 */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::Feature     This enum defines the OpenGL texture-related features that can be tested for.      \value ImmutableStorage Support for immutable texture storage     \value ImmutableMultisampleStorage Support for immutable texture storage with            multisample targets     \value TextureRectangle Support for the GL_TEXTURE_RECTANGLE target     \value TextureArrays Support for texture targets with array layers     \value Texture3D Support for the 3 dimensional texture target     \value TextureMultisample Support for texture targets that have multisample capabilities     \value TextureBuffer Support for textures that use OpenGL buffer objects            as their data source     \value TextureCubeMapArrays Support for cubemap array texture target     \value Swizzle Support for texture component swizzle masks     \value StencilTexturing Support for stencil texturing (i.e. looking up depth or stencil            components of a combined depth/stencil format texture in GLSL shaders).     \value AnisotropicFiltering Support for anisotropic texture filtering     \value NPOTTextures Basic support for non-power-of-two textures     \value NPOTTextureRepeat Full support for non-power-of-two textures including texture            repeat modes     \value Texture1D Support for the 1 dimensional texture target     \value TextureComparisonOperators Support for texture comparison operators     \value TextureMipMapLevel Support for setting the base and maximum mipmap levels */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::SwizzleComponent     This enum defines the texture color components that can be assigned a swizzle mask.      \value SwizzleRed The red component. Equivalent to GL_TEXTURE_SWIZZLE_R     \value SwizzleGreen The green component. Equivalent to GL_TEXTURE_SWIZZLE_G     \value SwizzleBlue The blue component. Equivalent to GL_TEXTURE_SWIZZLE_B     \value SwizzleAlpha The alpha component. Equivalent to GL_TEXTURE_SWIZZLE_A */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::SwizzleValue     This enum defines the possible mask values for texture swizzling.      \value RedValue Maps the component to the red channel. Equivalent to GL_RED     \value GreenValue Maps the component to the green channel. Equivalent to GL_GREEN     \value BlueValue Maps the component to the blue channel. Equivalent to GL_BLUE     \value AlphaValue Maps the component to the alpha channel. Equivalent to GL_ALPHA     \value ZeroValue Maps the component to a fixed value of 0. Equivalent to GL_ZERO     \value OneValue Maps the component to a fixed value of 1. Equivalent to GL_ONE */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::WrapMode     This enum defines the possible texture coordinate wrapping modes.      \value Repeat Texture coordinate is repeated. Equivalent to GL_REPEAT     \value MirroredRepeat Texture coordinate is reflected about 0 and 1. Equivalent to GL_MIRRORED_REPEAT     \value ClampToEdge Clamps the texture coordinates to [0,1]. Equivalent to GL_CLAMP_TO_EDGE     \value ClampToBorder As for ClampToEdge but also blends samples at 0 and 1 with a            fixed border color. Equivalent to GL_CLAMP_TO_BORDER */
end_comment
begin_comment
comment|/*!     \enum QOpenGLTexture::CoordinateDirection     This enum defines the possible texture coordinate directions      \value DirectionS The horizontal direction. Equivalent to GL_TEXTURE_WRAP_S     \value DirectionT The vertical direction. Equivalent to GL_TEXTURE_WRAP_T     \value DirectionR The depth direction. Equivalent to GL_TEXTURE_WRAP_R */
end_comment
begin_comment
comment|/*!     Creates a QOpenGLTexture object that can later be bound to \a target.      This does not create the underlying OpenGL texture object. Therefore,     construction using this constructor does not require a valid current     OpenGL context. */
end_comment
begin_constructor
DECL|function|QOpenGLTexture
name|QOpenGLTexture
operator|::
name|QOpenGLTexture
parameter_list|(
name|Target
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLTexturePrivate
argument_list|(
name|target
argument_list|,
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Creates a QOpenGLTexture object that can later be bound to the 2D texture     target and contains the pixel data contained in \a image. If you wish     to have a chain of mipmaps generated then set \a genMipMaps to \c true (this     is the default).      This does create the underlying OpenGL texture object. Therefore,     construction using this constructor does require a valid current     OpenGL context. */
end_comment
begin_constructor
DECL|function|QOpenGLTexture
name|QOpenGLTexture
operator|::
name|QOpenGLTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|MipMapGeneration
name|genMipMaps
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QOpenGLTexturePrivate
argument_list|(
name|QOpenGLTexture
operator|::
name|Target2D
argument_list|,
name|this
argument_list|)
argument_list|)
block|{
name|setData
argument_list|(
name|image
argument_list|,
name|genMipMaps
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOpenGLTexture
name|QOpenGLTexture
operator|::
name|~
name|QOpenGLTexture
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the binding target of this texture.      \since 5.4 */
end_comment
begin_function
DECL|function|target
name|QOpenGLTexture
operator|::
name|Target
name|QOpenGLTexture
operator|::
name|target
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|target
return|;
block|}
end_function
begin_comment
comment|/*!     Creates the underlying OpenGL texture object. This requires a current valid     OpenGL context. If the texture object already exists, this function does     nothing.      Once the texture object is created you can obtain the object     name from the textureId() function. This may be useful if you wish to make     some raw OpenGL calls related to this texture.      Normally it should not be necessary to call this function directly as all     functions that set properties of the texture object implicitly call create()     on your behalf.      Returns \c true if the creation succeeded, otherwise returns \c false.      \sa destroy(), isCreated(), textureId() */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLTexture
operator|::
name|create
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|create
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the underlying OpenGL texture object. This requires a current valid     OpenGL context.      \sa create(), isCreated(), textureId() */
end_comment
begin_function
DECL|function|destroy
name|void
name|QOpenGLTexture
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|destroy
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the underlying OpenGL texture object has been created.      \sa create(), destroy(), textureId() */
end_comment
begin_function
DECL|function|isCreated
name|bool
name|QOpenGLTexture
operator|::
name|isCreated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textureId
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the underlying OpenGL texture object or 0 if it has     not yet been created.      \sa create(), destroy(), isCreated() */
end_comment
begin_function
DECL|function|textureId
name|GLuint
name|QOpenGLTexture
operator|::
name|textureId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textureId
return|;
block|}
end_function
begin_comment
comment|/*!     Binds this texture to the currently active texture unit ready for     rendering. Note that you do not need to bind QOpenGLTexture objects     in order to modify them as the implementation makes use of the     EXT_direct_state_access extension where available and simulates it     where it is not.      \sa release() */
end_comment
begin_function
DECL|function|bind
name|void
name|QOpenGLTexture
operator|::
name|bind
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|bind
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Binds this texture to texture unit \a unit ready for     rendering. Note that you do not need to bind QOpenGLTexture objects     in order to modify them as the implementation makes use of the     EXT_direct_state_access extension where available and simulates it     where it is not.      If parameter \a reset is \c true then this function will restore     the active unit to the texture unit that was active upon entry.      \sa release() */
end_comment
begin_function
DECL|function|bind
name|void
name|QOpenGLTexture
operator|::
name|bind
parameter_list|(
name|uint
name|unit
parameter_list|,
name|TextureUnitReset
name|reset
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|bind
argument_list|(
name|unit
argument_list|,
name|reset
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Unbinds this texture from the currently active texture unit.      \sa bind() */
end_comment
begin_function
DECL|function|release
name|void
name|QOpenGLTexture
operator|::
name|release
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Unbinds this texture from texture unit \a unit.      If parameter \a reset is \c true then this function     will restore the active unit to the texture unit that was active     upon entry. */
end_comment
begin_function
DECL|function|release
name|void
name|QOpenGLTexture
operator|::
name|release
parameter_list|(
name|uint
name|unit
parameter_list|,
name|TextureUnitReset
name|reset
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|release
argument_list|(
name|unit
argument_list|,
name|reset
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this texture is bound to the corresponding target     of the currently active texture unit.      \sa bind(), release() */
end_comment
begin_function
DECL|function|isBound
name|bool
name|QOpenGLTexture
operator|::
name|isBound
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isBound
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this texture is bound to the corresponding target     of texture unit \a unit.      \sa bind(), release() */
end_comment
begin_function
DECL|function|isBound
name|bool
name|QOpenGLTexture
operator|::
name|isBound
parameter_list|(
name|uint
name|unit
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isBound
argument_list|(
name|unit
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the textureId of the texture that is bound to the \a target     of the currently active texture unit. */
end_comment
begin_function
DECL|function|boundTextureId
name|GLuint
name|QOpenGLTexture
operator|::
name|boundTextureId
parameter_list|(
name|BindingTarget
name|target
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::boundTextureId() requires a valid current context"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|GLint
name|textureId
init|=
literal|0
decl_stmt|;
name|ctx
operator|->
name|functions
argument_list|()
operator|->
name|glGetIntegerv
argument_list|(
name|target
argument_list|,
operator|&
name|textureId
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|textureId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the textureId of the texture that is bound to the \a target     of the texture unit \a unit. */
end_comment
begin_function
DECL|function|boundTextureId
name|GLuint
name|QOpenGLTexture
operator|::
name|boundTextureId
parameter_list|(
name|uint
name|unit
parameter_list|,
name|BindingTarget
name|target
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::boundTextureId() requires a valid current context"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QOpenGLFunctions
modifier|*
name|funcs
init|=
name|ctx
operator|->
name|functions
argument_list|()
decl_stmt|;
name|funcs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
name|GLint
name|oldTextureUnit
init|=
literal|0
decl_stmt|;
name|funcs
operator|->
name|glGetIntegerv
argument_list|(
name|GL_ACTIVE_TEXTURE
argument_list|,
operator|&
name|oldTextureUnit
argument_list|)
expr_stmt|;
name|funcs
operator|->
name|glActiveTexture
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|GLint
name|textureId
init|=
literal|0
decl_stmt|;
name|funcs
operator|->
name|glGetIntegerv
argument_list|(
name|target
argument_list|,
operator|&
name|textureId
argument_list|)
expr_stmt|;
name|funcs
operator|->
name|glActiveTexture
argument_list|(
name|oldTextureUnit
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|textureId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the format of this texture object to \a format. This function     must be called before texture storage is allocated.      Note that all formats may not be supported. The exact set of supported     formats is dependent upon your OpenGL implementation and version.      \sa format(), allocateStorage() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QOpenGLTexture
operator|::
name|setFormat
parameter_list|(
name|TextureFormat
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setFormat(): Cannot change format once storage has been allocated"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|NoFormat
case|:
name|d
operator|->
name|formatClass
operator|=
name|NoFormatClass
expr_stmt|;
break|break;
case|case
name|RGBA32F
case|:
case|case
name|RGBA32U
case|:
case|case
name|RGBA32I
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_128Bit
expr_stmt|;
break|break;
case|case
name|RGB32F
case|:
case|case
name|RGB32U
case|:
case|case
name|RGB32I
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_96Bit
expr_stmt|;
break|break;
case|case
name|RGBA16F
case|:
case|case
name|RG32F
case|:
case|case
name|RGBA16U
case|:
case|case
name|RG32U
case|:
case|case
name|RGBA16I
case|:
case|case
name|RG32I
case|:
case|case
name|RGBA16_UNorm
case|:
case|case
name|RGBA16_SNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_64Bit
expr_stmt|;
break|break;
case|case
name|RGB16_UNorm
case|:
case|case
name|RGB16_SNorm
case|:
case|case
name|RGB16F
case|:
case|case
name|RGB16U
case|:
case|case
name|RGB16I
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_48Bit
expr_stmt|;
break|break;
case|case
name|RG16F
case|:
case|case
name|RG11B10F
case|:
case|case
name|R32F
case|:
case|case
name|RGB10A2
case|:
case|case
name|RGBA8U
case|:
case|case
name|RG16U
case|:
case|case
name|R32U
case|:
case|case
name|RGBA8I
case|:
case|case
name|RG16I
case|:
case|case
name|R32I
case|:
case|case
name|RGBA8_UNorm
case|:
case|case
name|RG16_UNorm
case|:
case|case
name|RGBA8_SNorm
case|:
case|case
name|RG16_SNorm
case|:
case|case
name|SRGB8_Alpha8
case|:
case|case
name|RGB9E5
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_32Bit
expr_stmt|;
break|break;
case|case
name|RGB8_UNorm
case|:
case|case
name|RGB8_SNorm
case|:
case|case
name|SRGB8
case|:
case|case
name|RGB8U
case|:
case|case
name|RGB8I
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_24Bit
expr_stmt|;
break|break;
case|case
name|R16F
case|:
case|case
name|RG8U
case|:
case|case
name|R16U
case|:
case|case
name|RG8I
case|:
case|case
name|R16I
case|:
case|case
name|RG8_UNorm
case|:
case|case
name|R16_UNorm
case|:
case|case
name|RG8_SNorm
case|:
case|case
name|R16_SNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_16Bit
expr_stmt|;
break|break;
case|case
name|R8U
case|:
case|case
name|R8I
case|:
case|case
name|R8_UNorm
case|:
case|case
name|R8_SNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_8Bit
expr_stmt|;
break|break;
case|case
name|R_ATI1N_UNorm
case|:
case|case
name|R_ATI1N_SNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_RGTC1_R
expr_stmt|;
break|break;
case|case
name|RG_ATI2N_UNorm
case|:
case|case
name|RG_ATI2N_SNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_RGTC2_RG
expr_stmt|;
break|break;
case|case
name|RGB_BP_UNorm
case|:
case|case
name|SRGB_BP_UNorm
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_BPTC_Unorm
expr_stmt|;
break|break;
case|case
name|RGB_BP_UNSIGNED_FLOAT
case|:
case|case
name|RGB_BP_SIGNED_FLOAT
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_BPTC_Float
expr_stmt|;
break|break;
case|case
name|RGB_DXT1
case|:
case|case
name|SRGB_DXT1
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_S3TC_DXT1_RGB
expr_stmt|;
break|break;
case|case
name|RGBA_DXT1
case|:
case|case
name|SRGB_Alpha_DXT1
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_S3TC_DXT1_RGBA
expr_stmt|;
break|break;
case|case
name|RGBA_DXT3
case|:
case|case
name|SRGB_Alpha_DXT3
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_S3TC_DXT3_RGBA
expr_stmt|;
break|break;
case|case
name|RGBA_DXT5
case|:
case|case
name|SRGB_Alpha_DXT5
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_S3TC_DXT5_RGBA
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|R11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_UNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RG11_EAC_SNorm
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_PunchThrough_Alpha1_ETC2
case|:
case|case
name|QOpenGLTexture
operator|::
name|RGBA8_ETC2_EAC
case|:
case|case
name|QOpenGLTexture
operator|::
name|SRGB8_Alpha8_ETC2_EAC
case|:
case|case
name|RG3B2
case|:
case|case
name|R5G6B5
case|:
case|case
name|RGB5A1
case|:
case|case
name|RGBA4
case|:
case|case
name|D16
case|:
case|case
name|D24
case|:
case|case
name|D24S8
case|:
case|case
name|D32
case|:
case|case
name|D32F
case|:
case|case
name|D32FS8X24
case|:
case|case
name|S8
case|:
case|case
name|DepthFormat
case|:
case|case
name|AlphaFormat
case|:
case|case
name|RGBFormat
case|:
case|case
name|RGBAFormat
case|:
case|case
name|LuminanceFormat
case|:
case|case
name|LuminanceAlphaFormat
case|:
name|d
operator|->
name|formatClass
operator|=
name|FormatClass_Unique
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the format of this texture object.      \sa setFormat() */
end_comment
begin_function
DECL|function|format
name|QOpenGLTexture
operator|::
name|TextureFormat
name|QOpenGLTexture
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the dimensions of this texture object to \a width,     \a height, and \a depth. The default for each dimension is 1.     The maximum allowable texture size is dependent upon your OpenGL     implementation. Allocating storage for a texture less than the     maximum size can still fail if your system is low on resources.      \sa width(), height(), depth() */
end_comment
begin_function
DECL|function|setSize
name|void
name|QOpenGLTexture
operator|::
name|setSize
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot resize a texture that already has storage allocated.\n"
literal|"To do so, destroy() the texture and then create() and setSize()"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
name|d
operator|->
name|dimensions
index|[
literal|0
index|]
operator|=
name|width
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|d
operator|->
name|dimensions
index|[
literal|0
index|]
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|dimensions
index|[
literal|1
index|]
operator|=
name|height
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
if|if
condition|(
name|width
operator|!=
name|height
condition|)
name|qWarning
argument_list|(
literal|"QAbstractOpenGLTexture::setSize(): Cube map textures must be square"
argument_list|)
expr_stmt|;
name|d
operator|->
name|dimensions
index|[
literal|0
index|]
operator|=
name|d
operator|->
name|dimensions
index|[
literal|1
index|]
operator|=
name|width
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|depth
argument_list|)
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|d
operator|->
name|dimensions
index|[
literal|0
index|]
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|dimensions
index|[
literal|1
index|]
operator|=
name|height
expr_stmt|;
name|d
operator|->
name|dimensions
index|[
literal|2
index|]
operator|=
name|depth
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the width of a 1D, 2D or 3D texture.      \sa height(), depth(), setSize() */
end_comment
begin_function
DECL|function|width
name|int
name|QOpenGLTexture
operator|::
name|width
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dimensions
index|[
literal|0
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the height of a 2D or 3D texture.      \sa width(), depth(), setSize() */
end_comment
begin_function
DECL|function|height
name|int
name|QOpenGLTexture
operator|::
name|height
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dimensions
index|[
literal|1
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the depth of a 3D texture.      \sa width(), height(), setSize() */
end_comment
begin_function
DECL|function|depth
name|int
name|QOpenGLTexture
operator|::
name|depth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dimensions
index|[
literal|2
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     For texture targets that support mipmaps, this function     sets the requested number of mipmap \a levels to allocate storage     for. This function should be called before storage is allocated     for the texture.      If the texture target does not support mipmaps this function     has no effect.      \sa mipLevels(), maximumMipLevels(), isStorageAllocated() */
end_comment
begin_function
DECL|function|setMipLevels
name|void
name|QOpenGLTexture
operator|::
name|setMipLevels
parameter_list|(
name|int
name|levels
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set mip levels on a texture that already has storage allocated.\n"
literal|"To do so, destroy() the texture and then create() and setMipLevels()"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
name|d
operator|->
name|requestedMipLevels
operator|=
name|levels
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|qWarning
argument_list|(
literal|"QAbstractOpenGLTexture::setMipLevels(): This texture target does not support mipmaps"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the number of mipmap levels for this texture. If storage     has not yet been allocated for this texture it returns the     requested number of mipmap levels.      \sa setMipLevels(), maximumMipLevels(), isStorageAllocated() */
end_comment
begin_function
DECL|function|mipLevels
name|int
name|QOpenGLTexture
operator|::
name|mipLevels
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|isStorageAllocated
argument_list|()
condition|?
name|d
operator|->
name|mipLevels
else|:
name|d
operator|->
name|requestedMipLevels
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum number of mipmap levels that this texture     can have given the current dimensions.      \sa setMipLevels(), mipLevels(), setSize() */
end_comment
begin_function
DECL|function|maximumMipLevels
name|int
name|QOpenGLTexture
operator|::
name|maximumMipLevels
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maximumMipLevelCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of array \a layers to allocate storage for. This     function should be called before storage is allocated for the texture.      For targets that do not support array layers this function has     no effect.      \sa layers(), isStorageAllocated() */
end_comment
begin_function
DECL|function|setLayers
name|void
name|QOpenGLTexture
operator|::
name|setLayers
parameter_list|(
name|int
name|layers
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set layers on a texture that already has storage allocated.\n"
literal|"To do so, destroy() the texture and then create() and setLayers()"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|d
operator|->
name|layers
operator|=
name|layers
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
name|qWarning
argument_list|(
literal|"Texture target does not support array layers"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the number of array layers for this texture. If     storage has not yet been allocated for this texture then     this function returns the requested number of array layers.      For texture targets that do not support array layers this     will return 1.      \sa setLayers(), isStorageAllocated() */
end_comment
begin_function
DECL|function|layers
name|int
name|QOpenGLTexture
operator|::
name|layers
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layers
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of faces for this texture. For cubemap     and cubemap array type targets this will be 6.      For non-cubemap type targets this will return 1. */
end_comment
begin_function
DECL|function|faces
name|int
name|QOpenGLTexture
operator|::
name|faces
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|faces
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of \a samples to allocate storage for when rendering to     a multisample capable texture target. This function should     be called before storage is allocated for the texture.      For targets that do not support multisampling this function has     no effect.      \sa samples(), isStorageAllocated() */
end_comment
begin_function
DECL|function|setSamples
name|void
name|QOpenGLTexture
operator|::
name|setSamples
parameter_list|(
name|int
name|samples
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set sample count on a texture that already has storage allocated.\n"
literal|"To do so, destroy() the texture and then create() and setSamples()"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|d
operator|->
name|samples
operator|=
name|samples
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|qWarning
argument_list|(
literal|"Texture target does not support multisampling"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the number of multisample sample points for this texture.     If storage has not yet been allocated for this texture then     this function returns the requested number of samples.      For texture targets that do not support multisampling this     will return 0.      \sa setSamples(), isStorageAllocated() */
end_comment
begin_function
DECL|function|samples
name|int
name|QOpenGLTexture
operator|::
name|samples
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|samples
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether the sample positions and number of samples used with     a multisample capable texture target to \a fixed. If set to \c true     the sample positions and number of samples used are the same for     all texels in the image and will not depend upon the image size or     internal format. This function should be called before storage is allocated     for the texture.      For targets that do not support multisampling this function has     no effect.      The default value is \c true.      \sa isFixedSamplePositions(), isStorageAllocated() */
end_comment
begin_function
DECL|function|setFixedSamplePositions
name|void
name|QOpenGLTexture
operator|::
name|setFixedSamplePositions
parameter_list|(
name|bool
name|fixed
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set sample positions on a texture that already has storage allocated.\n"
literal|"To do so, destroy() the texture and then create() and setFixedSamplePositions()"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|target
condition|)
block|{
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisample
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DMultisampleArray
case|:
name|d
operator|->
name|fixedSamplePositions
operator|=
name|fixed
expr_stmt|;
break|break;
case|case
name|QOpenGLTexture
operator|::
name|Target1D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target3D
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target1DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|Target2DArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMap
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetCubeMapArray
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetBuffer
case|:
case|case
name|QOpenGLTexture
operator|::
name|TargetRectangle
case|:
name|qWarning
argument_list|(
literal|"Texture target does not support multisampling"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns whether this texture uses a fixed pattern of multisample     samples. If storage has not yet been allocated for this texture then     this function returns the requested fixed sample position setting.      For texture targets that do not support multisampling this     will return \c true.      \sa setFixedSamplePositions(), isStorageAllocated() */
end_comment
begin_function
DECL|function|isFixedSamplePositions
name|bool
name|QOpenGLTexture
operator|::
name|isFixedSamplePositions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fixedSamplePositions
return|;
block|}
end_function
begin_comment
comment|/*!     Allocates server-side storage for this texture object taking     into account, the format, dimensions, mipmap levels, array     layers and cubemap faces.      Once storage has been allocated it is no longer possible to change     these properties.      If supported QOpenGLTexture makes use of immutable texture     storage.      Once storage has been allocated for the texture then pixel data     can be uploaded via one of the setData() overloads.      \note If immutable texture storage is not available,     then a default pixel format and pixel type will be used to     create the mutable storage. You can use the other     allocateStorage() overload to specify exactly the pixel format     and the pixel type to use when allocating mutable storage;     this is particulary useful under certain OpenGL ES implementations     (notably, OpenGL ES 2), where the pixel format and the pixel type     used at allocation time must perfectly match the format     and the type passed to any subsequent setData() call.      \sa isStorageAllocated(), setData() */
end_comment
begin_function
DECL|function|allocateStorage
name|void
name|QOpenGLTexture
operator|::
name|allocateStorage
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|create
argument_list|()
condition|)
block|{
specifier|const
name|QOpenGLTexture
operator|::
name|PixelFormat
name|pixelFormat
init|=
name|pixelFormatCompatibleWithInternalFormat
argument_list|(
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
specifier|const
name|QOpenGLTexture
operator|::
name|PixelType
name|pixelType
init|=
name|pixelTypeCompatibleWithInternalFormat
argument_list|(
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
name|d
operator|->
name|allocateStorage
argument_list|(
name|pixelFormat
argument_list|,
name|pixelType
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Allocates server-side storage for this texture object taking     into account, the format, dimensions, mipmap levels, array     layers and cubemap faces.      Once storage has been allocated it is no longer possible to change     these properties.      If supported QOpenGLTexture makes use of immutable texture     storage. However, if immutable texture storage is not available,     then the specified \a pixelFormat and \a pixelType will be used     to allocate mutable storage; note that in certain OpenGL implementations     (notably, OpenGL ES 2) they must perfectly match the format     and the type passed to any subsequent setData() call.      Once storage has been allocated for the texture then pixel data     can be uploaded via one of the setData() overloads.      \sa isStorageAllocated(), setData() */
end_comment
begin_function
DECL|function|allocateStorage
name|void
name|QOpenGLTexture
operator|::
name|allocateStorage
parameter_list|(
name|QOpenGLTexture
operator|::
name|PixelFormat
name|pixelFormat
parameter_list|,
name|QOpenGLTexture
operator|::
name|PixelType
name|pixelType
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|create
argument_list|()
condition|)
name|d
operator|->
name|allocateStorage
argument_list|(
name|pixelFormat
argument_list|,
name|pixelType
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if server-side storage for this texture as been     allocated.      The texture format, dimensions, mipmap levels and array layers     cannot be altered once storage ihas been allocated.      \sa allocateStorage(), setSize(), setMipLevels(), setLayers(), setFormat() */
end_comment
begin_function
DECL|function|isStorageAllocated
name|bool
name|QOpenGLTexture
operator|::
name|isStorageAllocated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|storageAllocated
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to create a texture view onto this texture. A texture     view is somewhat analogous to a view in SQL in that it presents     a restricted or reinterpreted view of the original data. Texture     views do not allocate any more server-side storage, insted relying     on the storage buffer of the source texture.      Texture views are only available when using immutable storage. For     more information on texture views see     http://www.opengl.org/wiki/Texture_Storage#Texture_views.      The \a target argument specifies the target to use for the view.     Only some targets can be used depending upon the target of the original     target. For e.g. a view onto a Target1DArray texture can specify     either Target1DArray or Target1D but for the latter the number of     array layers specified with \a minimumLayer and \a maximumLayer must     be exactly 1.      Simpliar constraints apply for the \a viewFormat. See the above link     and the specification for more details.      The \a minimumMipmapLevel, \a maximumMipmapLevel, \a minimumLayer,     and \a maximumLayer arguments serve to restrict the parts of the     texture accessible by the texture view.      If creation of the texture view fails this function will return     0. If the function succeeds it will return a pointer to a new     QOpenGLTexture object that will return \c true from its isTextureView()     function.      \sa isTextureView() */
end_comment
begin_function
DECL|function|createTextureView
name|QOpenGLTexture
modifier|*
name|QOpenGLTexture
operator|::
name|createTextureView
parameter_list|(
name|Target
name|target
parameter_list|,
name|TextureFormat
name|viewFormat
parameter_list|,
name|int
name|minimumMipmapLevel
parameter_list|,
name|int
name|maximumMipmapLevel
parameter_list|,
name|int
name|minimumLayer
parameter_list|,
name|int
name|maximumLayer
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set create a texture view of a texture that does not have storage allocated."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Q_ASSERT
argument_list|(
name|maximumMipmapLevel
operator|>=
name|minimumMipmapLevel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maximumLayer
operator|>=
name|minimumLayer
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|createTextureView
argument_list|(
name|target
argument_list|,
name|viewFormat
argument_list|,
name|minimumMipmapLevel
argument_list|,
name|maximumMipmapLevel
argument_list|,
name|minimumLayer
argument_list|,
name|maximumLayer
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this texture object is actually a view onto another     texture object.      \sa createTextureView() */
end_comment
begin_function
DECL|function|isTextureView
name|bool
name|QOpenGLTexture
operator|::
name|isTextureView
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textureView
return|;
block|}
end_function
begin_comment
comment|/*!     Uploads pixel \a data for this texture object \a mipLevel, array \a layer, and \a cubeFace.     Storage must have been allocated before uploading pixel data. Some overloads of setData()     will set appropriate dimensions, mipmap levels, and array layers and then allocate storage     for you if they have enough information to do so. This will be noted in the function     documentation.      The structure of the pixel data pointed to by \a data is specified by \a sourceFormat     and \a sourceType. The pixel data upload can optionally be controlled by \a options.      If using a compressed format() then you should use setCompressedData() instead of this     function.      \since 5.3     \sa setCompressedData() */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|CubeMapFace
name|cubeFace
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set data on a texture that does not have storage allocated.\n"
literal|"To do so call allocateStorage() before this function"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|cubeFace
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.3     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.3     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.3     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|3
argument_list|)
end_if
begin_comment
comment|/*!     \obsolete     \overload      \sa setCompressedData() */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|CubeMapFace
name|cubeFace
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set data on a texture that does not have storage allocated.\n"
literal|"To do so call allocateStorage() before this function"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|cubeFace
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
name|PixelFormat
name|sourceFormat
parameter_list|,
name|PixelType
name|sourceType
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|sourceFormat
argument_list|,
name|sourceType
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     This overload of setData() will allocate storage for you.     The pixel data is contained in \a image. Mipmaps are generated by default.     Set \a genMipMaps to \l DontGenerateMipMaps to turn off mipmap generation.      \overload */
end_comment
begin_function
DECL|function|setData
name|void
name|QOpenGLTexture
operator|::
name|setData
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|MipMapGeneration
name|genMipMaps
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|context
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setData() requires a valid current context"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|->
name|isOpenGLES
argument_list|()
operator|&&
name|context
operator|->
name|format
argument_list|()
operator|.
name|majorVersion
argument_list|()
operator|<
literal|3
condition|)
name|setFormat
argument_list|(
name|QOpenGLTexture
operator|::
name|RGBAFormat
argument_list|)
expr_stmt|;
else|else
name|setFormat
argument_list|(
name|QOpenGLTexture
operator|::
name|RGBA8_UNorm
argument_list|)
expr_stmt|;
name|setSize
argument_list|(
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|setMipLevels
argument_list|(
name|genMipMaps
operator|==
name|GenerateMipMaps
condition|?
name|maximumMipLevels
argument_list|()
else|:
literal|1
argument_list|)
expr_stmt|;
name|allocateStorage
argument_list|(
name|QOpenGLTexture
operator|::
name|RGBA
argument_list|,
name|QOpenGLTexture
operator|::
name|UInt8
argument_list|)
expr_stmt|;
comment|// Upload pixel data and generate mipmaps
name|QImage
name|glImage
init|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGBA8888
argument_list|)
decl_stmt|;
name|QOpenGLPixelTransferOptions
name|uploadOptions
decl_stmt|;
name|uploadOptions
operator|.
name|setAlignment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setData
argument_list|(
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|RGBA
argument_list|,
name|QOpenGLTexture
operator|::
name|UInt8
argument_list|,
name|glImage
operator|.
name|constBits
argument_list|()
argument_list|,
operator|&
name|uploadOptions
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Uploads compressed pixel \a data to \a mipLevel, array \a layer, and \a cubeFace.     The pixel transfer can optionally be controlled with \a options. The \a dataSize     argument should specify the size of the data pointed to by \a data.      If not using a compressed format() then you should use setData() instead of this     function.      \since 5.3 */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|CubeMapFace
name|cubeFace
parameter_list|,
name|int
name|dataSize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set data on a texture that does not have storage allocated.\n"
literal|"To do so call allocateStorage() before this function"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|cubeFace
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|int
name|dataSize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|dataSize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|dataSize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|3
argument_list|)
end_if
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|CubeMapFace
name|cubeFace
parameter_list|,
name|int
name|dataSize
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStorageAllocated
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot set data on a texture that does not have storage allocated.\n"
literal|"To do so call allocateStorage() before this function"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|cubeFace
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|layer
parameter_list|,
name|int
name|dataSize
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
name|layer
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|mipLevel
parameter_list|,
name|int
name|dataSize
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
name|mipLevel
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \overload */
end_comment
begin_function
DECL|function|setCompressedData
name|void
name|QOpenGLTexture
operator|::
name|setCompressedData
parameter_list|(
name|int
name|dataSize
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QOpenGLPixelTransferOptions
modifier|*
specifier|const
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCompressedData
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QOpenGLTexture
operator|::
name|CubeMapPositiveX
argument_list|,
name|dataSize
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns \c true if your OpenGL implementation and version supports the texture     feature \a feature. */
end_comment
begin_function
DECL|function|hasFeature
name|bool
name|QOpenGLTexture
operator|::
name|hasFeature
parameter_list|(
name|Feature
name|feature
parameter_list|)
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::hasFeature() requires a valid current context"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QSurfaceFormat
name|f
init|=
name|ctx
operator|->
name|format
argument_list|()
decl_stmt|;
name|bool
name|supported
init|=
literal|false
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|ctx
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|feature
condition|)
block|{
case|case
name|ImmutableMultisampleStorage
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_storage_multisample"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureBuffer
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_buffer_object"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|StencilTexturing
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_stencil_texturing"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ImmutableStorage
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_storage"
argument_list|)
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_texture_storage"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureCubeMapArrays
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"ARB_texture_cube_map_array"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Swizzle
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_swizzle"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureMultisample
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_multisample"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureArrays
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_texture_array"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureRectangle
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"ARB_texture_rectangle"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Texture3D
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|AnisotropicFiltering
case|:
name|supported
operator|=
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_texture_filter_anisotropic"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPOTTextures
case|:
case|case
name|NPOTTextureRepeat
case|:
name|supported
operator|=
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_non_power_of_two"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Texture1D
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureComparisonOperators
case|:
comment|// GL 1.4 and GL_ARB_shadow alone support only LEQUAL and GEQUAL;
comment|// since we're talking about history anyhow avoid to be extra pedantic
comment|// in the feature set, and simply claim supported if we have the full set of operators
comment|// (which has been added into 1.5 / GL_EXT_shadow_funcs).
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
operator|||
operator|(
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_shadow"
argument_list|)
argument_list|)
operator|&&
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_shadow_funcs"
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|TextureMipMapLevel
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MaxFeatureFlag
case|:
break|break;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|isOpenGLES
argument_list|()
condition|)
endif|#
directive|endif
block|{
specifier|const
name|char
modifier|*
name|renderer
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|ctx
operator|->
name|functions
argument_list|()
operator|->
name|glGetString
argument_list|(
name|GL_RENDERER
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|feature
condition|)
block|{
case|case
name|ImmutableStorage
case|:
name|supported
operator|=
operator|(
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"EXT_texture_storage"
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|renderer
operator|&&
name|strstr
argument_list|(
name|renderer
argument_list|,
literal|"Mali"
argument_list|)
operator|)
expr_stmt|;
comment|// do not use on Mali: QTBUG-45106
break|break;
case|case
name|ImmutableMultisampleStorage
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureRectangle
case|:
break|break;
case|case
name|TextureArrays
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|Texture3D
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_OES_texture_3D"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureMultisample
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureBuffer
case|:
break|break;
case|case
name|TextureCubeMapArrays
case|:
break|break;
case|case
name|Swizzle
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|StencilTexturing
case|:
break|break;
case|case
name|AnisotropicFiltering
case|:
name|supported
operator|=
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_texture_filter_anisotropic"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPOTTextures
case|:
case|case
name|NPOTTextureRepeat
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_OES_texture_npot"
argument_list|)
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_texture_non_power_of_two"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Texture1D
case|:
break|break;
case|case
name|TextureComparisonOperators
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|||
name|ctx
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_shadow_samplers"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TextureMipMapLevel
case|:
name|supported
operator|=
name|f
operator|.
name|version
argument_list|()
operator|>=
name|qMakePair
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MaxFeatureFlag
case|:
break|break;
block|}
block|}
return|return
name|supported
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the base mipmap level used for all texture lookups with this texture to \a baseLevel.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa mipBaseLevel(), setMipMaxLevel(), setMipLevelRange() */
end_comment
begin_function
DECL|function|setMipBaseLevel
name|void
name|QOpenGLTexture
operator|::
name|setMipBaseLevel
parameter_list|(
name|int
name|baseLevel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|TextureMipMapLevel
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setMipBaseLevel: requires OpenGL>= 1.2 or OpenGL ES>= 3.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|baseLevel
operator|<=
name|d
operator|->
name|maxLevel
argument_list|)
expr_stmt|;
name|d
operator|->
name|baseLevel
operator|=
name|baseLevel
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BASE_LEVEL
argument_list|,
name|baseLevel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the mipmap base level used for all texture lookups with this texture.     The default is 0.      \sa setMipBaseLevel(), mipMaxLevel(), mipLevelRange() */
end_comment
begin_function
DECL|function|mipBaseLevel
name|int
name|QOpenGLTexture
operator|::
name|mipBaseLevel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|baseLevel
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the maximum mipmap level used for all texture lookups with this texture to \a maxLevel.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa mipMaxLevel(), setMipBaseLevel(), setMipLevelRange() */
end_comment
begin_function
DECL|function|setMipMaxLevel
name|void
name|QOpenGLTexture
operator|::
name|setMipMaxLevel
parameter_list|(
name|int
name|maxLevel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|TextureMipMapLevel
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setMipMaxLevel: requires OpenGL>= 1.2 or OpenGL ES>= 3.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|baseLevel
operator|<=
name|maxLevel
argument_list|)
expr_stmt|;
name|d
operator|->
name|maxLevel
operator|=
name|maxLevel
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAX_LEVEL
argument_list|,
name|maxLevel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the mipmap maximum level used for all texture lookups with this texture.      \sa setMipMaxLevel(), mipBaseLevel(), mipLevelRange() */
end_comment
begin_function
DECL|function|mipMaxLevel
name|int
name|QOpenGLTexture
operator|::
name|mipMaxLevel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maxLevel
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the range of mipmap levels that can be used for texture lookups with this texture     to range from \a baseLevel to \a maxLevel.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa setMipBaseLevel(), setMipMaxLevel(), mipLevelRange() */
end_comment
begin_function
DECL|function|setMipLevelRange
name|void
name|QOpenGLTexture
operator|::
name|setMipLevelRange
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|int
name|maxLevel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|TextureMipMapLevel
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setMipLevelRange: requires OpenGL>= 1.2 or OpenGL ES>= 3.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|baseLevel
operator|<=
name|maxLevel
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BASE_LEVEL
argument_list|,
name|baseLevel
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAX_LEVEL
argument_list|,
name|maxLevel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the range of mipmap levels that can be used for texture lookups with this texture.      \sa mipBaseLevel(), mipMaxLevel() */
end_comment
begin_function
DECL|function|mipLevelRange
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|QOpenGLTexture
operator|::
name|mipLevelRange
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|qMakePair
argument_list|(
name|d
operator|->
name|baseLevel
argument_list|,
name|d
operator|->
name|maxLevel
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is \c true, enables automatic mipmap generation for this texture object     to occur whenever the level 0 mipmap data is set via setData().      The automatic mipmap generation is enabled by default.      \sa isAutoMipMapGenerationEnabled(), generateMipMaps() */
end_comment
begin_function
DECL|function|setAutoMipMapGenerationEnabled
name|void
name|QOpenGLTexture
operator|::
name|setAutoMipMapGenerationEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoGenerateMipMaps
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns whether auto mipmap generation is enabled for this texture object.      \sa setAutoMipMapGenerationEnabled(), generateMipMaps() */
end_comment
begin_function
DECL|function|isAutoMipMapGenerationEnabled
name|bool
name|QOpenGLTexture
operator|::
name|isAutoMipMapGenerationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoGenerateMipMaps
return|;
block|}
end_function
begin_comment
comment|/*!     Generates mipmaps for this texture object from mipmap level 0. If you are     using a texture target and filtering option that requires mipmaps and you     have disabled automatic mipmap generation then you need to call this function     or the overload to create the mipmap chain.      \sa setAutoMipMapGenerationEnabled(), setMipLevels(), mipLevels() */
end_comment
begin_function
DECL|function|generateMipMaps
name|void
name|QOpenGLTexture
operator|::
name|generateMipMaps
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glGenerateTextureMipmap
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Generates mipmaps for this texture object from mipmap level \a baseLevel. If you are     using a texture target and filtering option that requires mipmaps and you     have disabled automatic mipmap generation then you need to call this function     or the overload to create the mipmap chain.      The generation of mipmaps to above \a baseLevel is achieved by setting the mipmap     base level to \a baseLevel and then generating the mipmap chain. If \a resetBaseLevel     is \c true, then the baseLevel of the texture will be reset to its previous value.      \sa setAutoMipMapGenerationEnabled(), setMipLevels(), mipLevels() */
end_comment
begin_function
DECL|function|generateMipMaps
name|void
name|QOpenGLTexture
operator|::
name|generateMipMaps
parameter_list|(
name|int
name|baseLevel
parameter_list|,
name|bool
name|resetBaseLevel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|int
name|oldBaseLevel
decl_stmt|;
if|if
condition|(
name|resetBaseLevel
condition|)
name|oldBaseLevel
operator|=
name|mipBaseLevel
argument_list|()
expr_stmt|;
name|setMipBaseLevel
argument_list|(
name|baseLevel
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glGenerateTextureMipmap
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|resetBaseLevel
condition|)
name|setMipBaseLevel
argument_list|(
name|oldBaseLevel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     GLSL shaders are able to reorder the components of the vec4 returned by texture     functions. It is also desirable to be able to control this reordering from CPU     side code. This is made possible by swizzle masks since OpenGL 3.3.      Each component of the texture can be mapped to one of the SwizzleValue options.      This function maps \a component to the output \a value.      \note This function has no effect on Mac and Qt built for OpenGL ES 2.     \sa swizzleMask() */
end_comment
begin_function
DECL|function|setSwizzleMask
name|void
name|QOpenGLTexture
operator|::
name|setSwizzleMask
parameter_list|(
name|SwizzleComponent
name|component
parameter_list|,
name|SwizzleValue
name|value
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|Swizzle
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setSwizzleMask() requires OpenGL>= 3.3"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|swizzleMask
index|[
name|component
operator|-
name|SwizzleRed
index|]
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|component
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Texture swizzling is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parameters \a {r}, \a {g}, \a {b}, and \a {a}  are values used for setting     the colors red, green, blue, and the alpha value.     \overload */
end_comment
begin_function
DECL|function|setSwizzleMask
name|void
name|QOpenGLTexture
operator|::
name|setSwizzleMask
parameter_list|(
name|SwizzleValue
name|r
parameter_list|,
name|SwizzleValue
name|g
parameter_list|,
name|SwizzleValue
name|b
parameter_list|,
name|SwizzleValue
name|a
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|Swizzle
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setSwizzleMask() requires OpenGL>= 3.3"
argument_list|)
expr_stmt|;
return|return;
block|}
name|GLint
name|swizzleMask
index|[]
init|=
block|{
name|GLint
argument_list|(
name|r
argument_list|)
block|,
name|GLint
argument_list|(
name|g
argument_list|)
block|,
name|GLint
argument_list|(
name|b
argument_list|)
block|,
name|GLint
argument_list|(
argument|a
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|swizzleMask
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|d
operator|->
name|swizzleMask
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|d
operator|->
name|swizzleMask
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|swizzleMask
index|[
literal|3
index|]
operator|=
name|a
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteriv
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_SWIZZLE_RGBA
argument_list|,
name|swizzleMask
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Texture swizzling is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the swizzle mask for texture \a component. */
end_comment
begin_function
DECL|function|swizzleMask
name|QOpenGLTexture
operator|::
name|SwizzleValue
name|QOpenGLTexture
operator|::
name|swizzleMask
parameter_list|(
name|SwizzleComponent
name|component
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|swizzleMask
index|[
name|component
operator|-
name|SwizzleRed
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QOpenGLTexture::DepthStencilMode     \since 5.4     This enum specifies which component of a depth/stencil texture is     accessed when the texture is sampled.      \value DepthMode Equivalent to GL_DEPTH_COMPONENT.     \value StencilMode Equivalent to GL_STENCIL_INDEX. */
end_comment
begin_comment
comment|/*!     If using a texture that has a combined depth/stencil format this function sets     which component of the texture is accessed to \a mode.      When the parameter is set to DepthMode, then accessing it from the     shader will access the depth component as a single float, as normal. But when     the parameter is set to StencilMode, the shader will access the stencil component.      \note This function has no effect on Mac and Qt built for OpenGL ES 2.     \since 5.4     \sa depthStencilMode() */
end_comment
begin_function
DECL|function|setDepthStencilMode
name|void
name|QOpenGLTexture
operator|::
name|setDepthStencilMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|DepthStencilMode
name|mode
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|StencilTexturing
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setDepthStencilMode() requires OpenGL>= 4.3 or GL_ARB_stencil_texturing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|depthStencilMode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_DEPTH_STENCIL_TEXTURE_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: DepthStencil Mode is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the depth stencil mode for textures using a combined depth/stencil format.      \since 5.4     \sa setDepthStencilMode() */
end_comment
begin_function
DECL|function|depthStencilMode
name|QOpenGLTexture
operator|::
name|DepthStencilMode
name|QOpenGLTexture
operator|::
name|depthStencilMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|depthStencilMode
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QOpenGLTexture::ComparisonFunction     \since 5.5     This enum specifies which comparison operator is used when texture comparison     is enabled on this texture.      \value CompareLessEqual Equivalent to GL_LEQUAL.     \value CompareGreaterEqual Equivalent to GL_GEQUAL.     \value CompareLess Equivalent to GL_LESS.     \value CompareGreater Equivalent to GL_GREATER.     \value CompareEqual Equivalent to GL_EQUAL.     \value CommpareNotEqual Equivalent to GL_NOTEQUAL.     \value CompareAlways Equivalent to GL_ALWAYS.     \value CompareNever Equivalent to GL_NEVER.  */
end_comment
begin_comment
comment|/*     \since 5.5      Sets the texture comparison function on this texture to \a function. The texture     comparison function is used by shadow samplers when sampling a depth texture.      \sa comparisonFunction() */
end_comment
begin_function
DECL|function|setComparisonFunction
name|void
name|QOpenGLTexture
operator|::
name|setComparisonFunction
parameter_list|(
name|QOpenGLTexture
operator|::
name|ComparisonFunction
name|function
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|TextureComparisonOperators
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setComparisonFunction: requires OpenGL>= 1.5 or OpenGL ES>= 3.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|comparisonFunction
operator|=
name|function
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_COMPARE_FUNC
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Returns the texture comparison operator set on this texture. By default, a     texture has a CompareLessEqual comparison function.      \sa setComparisonFunction() */
end_comment
begin_function
DECL|function|comparisonFunction
name|QOpenGLTexture
operator|::
name|ComparisonFunction
name|QOpenGLTexture
operator|::
name|comparisonFunction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|comparisonFunction
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QOpenGLTexture::ComparisonMode     \since 5.5     This enum specifies which comparison mode is used when sampling this texture.      \value CompareRefToTexture Equivalent to GL_COMPARE_REF_TO_TEXTURE.     \value CompareNone Equivalent to GL_NONE. */
end_comment
begin_comment
comment|/*!     \since 5.5      Sets the texture comparison mode on this texture to \a mode. The texture     comparison mode is used by shadow samplers when sampling a depth texture.      \sa comparisonMode() */
end_comment
begin_function
DECL|function|setComparisonMode
name|void
name|QOpenGLTexture
operator|::
name|setComparisonMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|ComparisonMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|TextureComparisonOperators
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setComparisonMode: requires OpenGL>= 1.5 or OpenGL ES>= 3.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|comparisonMode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_COMPARE_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Returns the texture comparison mode set on this texture. By default, a     texture has a CompareNone comparison mode (i.e. comparisons are disabled).      \sa setComparisonMode() */
end_comment
begin_function
DECL|function|comparisonMode
name|QOpenGLTexture
operator|::
name|ComparisonMode
name|QOpenGLTexture
operator|::
name|comparisonMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|comparisonMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the filter used for minification to \a filter.      \sa minificationFilter(), setMagnificationFilter(), setMinMagFilters() */
end_comment
begin_function
DECL|function|setMinificationFilter
name|void
name|QOpenGLTexture
operator|::
name|setMinificationFilter
parameter_list|(
name|QOpenGLTexture
operator|::
name|Filter
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|minFilter
operator|=
name|filter
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the minification filter.      \sa setMinificationFilter() */
end_comment
begin_function
DECL|function|minificationFilter
name|QOpenGLTexture
operator|::
name|Filter
name|QOpenGLTexture
operator|::
name|minificationFilter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minFilter
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the magnification filter to \a filter.      \sa magnificationFilter(), setMinificationFilter(), setMinMagFilters() */
end_comment
begin_function
DECL|function|setMagnificationFilter
name|void
name|QOpenGLTexture
operator|::
name|setMagnificationFilter
parameter_list|(
name|QOpenGLTexture
operator|::
name|Filter
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|magFilter
operator|=
name|filter
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the magnification filter.      \sa setMagnificationFilter() */
end_comment
begin_function
DECL|function|magnificationFilter
name|QOpenGLTexture
operator|::
name|Filter
name|QOpenGLTexture
operator|::
name|magnificationFilter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|magFilter
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the minification filter to \a minificationFilter and the magnification filter     to \a magnificationFilter.      \sa minMagFilters(), setMinificationFilter(), setMagnificationFilter() */
end_comment
begin_function
DECL|function|setMinMagFilters
name|void
name|QOpenGLTexture
operator|::
name|setMinMagFilters
parameter_list|(
name|QOpenGLTexture
operator|::
name|Filter
name|minificationFilter
parameter_list|,
name|QOpenGLTexture
operator|::
name|Filter
name|magnificationFilter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|minFilter
operator|=
name|minificationFilter
expr_stmt|;
name|d
operator|->
name|magFilter
operator|=
name|magnificationFilter
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|minificationFilter
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|magnificationFilter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current minification and magnification filters.      \sa setMinMagFilters() */
end_comment
begin_function
DECL|function|minMagFilters
name|QPair
argument_list|<
name|QOpenGLTexture
operator|::
name|Filter
argument_list|,
name|QOpenGLTexture
operator|::
name|Filter
argument_list|>
name|QOpenGLTexture
operator|::
name|minMagFilters
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|QPair
argument_list|<
name|QOpenGLTexture
operator|::
name|Filter
argument_list|,
name|QOpenGLTexture
operator|::
name|Filter
argument_list|>
argument_list|(
name|d
operator|->
name|minFilter
argument_list|,
name|d
operator|->
name|magFilter
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If your OpenGL implementation supports the GL_EXT_texture_filter_anisotropic extension     this function sets the maximum anisotropy level to \a anisotropy.      \sa maximumAnisotropy() */
end_comment
begin_function
DECL|function|setMaximumAnisotropy
name|void
name|QOpenGLTexture
operator|::
name|setMaximumAnisotropy
parameter_list|(
name|float
name|anisotropy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|features
operator|.
name|testFlag
argument_list|(
name|AnisotropicFiltering
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTexture::setMaximumAnisotropy() requires GL_EXT_texture_filter_anisotropic"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|maxAnisotropy
operator|=
name|anisotropy
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteri
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
argument_list|,
name|anisotropy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum level of anisotropy to be accounted for when performing texture lookups.     This requires the GL_EXT_texture_filter_anisotropic extension.      \sa setMaximumAnisotropy() */
end_comment
begin_function
DECL|function|maximumAnisotropy
name|float
name|QOpenGLTexture
operator|::
name|maximumAnisotropy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maxAnisotropy
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the wrap (or repeat mode) for all texture dimentions to \a mode.      \sa wrapMode() */
end_comment
begin_function
DECL|function|setWrapMode
name|void
name|QOpenGLTexture
operator|::
name|setWrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|WrapMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWrapMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Holds the texture dimension \a direction.     \overload */
end_comment
begin_function
DECL|function|setWrapMode
name|void
name|QOpenGLTexture
operator|::
name|setWrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|CoordinateDirection
name|direction
parameter_list|,
name|QOpenGLTexture
operator|::
name|WrapMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWrapMode
argument_list|(
name|direction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the wrap mode for the texture dimension \a direction.      \sa setWrapMode() */
end_comment
begin_function
DECL|function|wrapMode
name|QOpenGLTexture
operator|::
name|WrapMode
name|QOpenGLTexture
operator|::
name|wrapMode
parameter_list|(
name|QOpenGLTexture
operator|::
name|CoordinateDirection
name|direction
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|wrapMode
argument_list|(
name|direction
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the border color of the texture to \a color.      \note This function has no effect on Mac and Qt built for OpenGL ES 2.     \sa borderColor() */
end_comment
begin_function
DECL|function|setBorderColor
name|void
name|QOpenGLTexture
operator|::
name|setBorderColor
parameter_list|(
name|QColor
name|color
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|float
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
expr_stmt|;
name|d
operator|->
name|borderColor
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|borderColor
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterfv
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BORDER_COLOR
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|color
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Border color is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the color red to \a {r}, green to \a {g}, blue to \a {b}, and \a {a} to the     alpha value.     \overload */
end_comment
begin_function
DECL|function|setBorderColor
name|void
name|QOpenGLTexture
operator|::
name|setBorderColor
parameter_list|(
name|float
name|r
parameter_list|,
name|float
name|g
parameter_list|,
name|float
name|b
parameter_list|,
name|float
name|a
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|float
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|a
expr_stmt|;
name|d
operator|->
name|borderColor
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|borderColor
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterfv
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BORDER_COLOR
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Border color is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the color red to \a {r}, green to \a {g}, blue to \a {b}, and the alpha     value to \a {a}.     \overload */
end_comment
begin_function
DECL|function|setBorderColor
name|void
name|QOpenGLTexture
operator|::
name|setBorderColor
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|a
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|int
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|a
expr_stmt|;
name|d
operator|->
name|borderColor
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|borderColor
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteriv
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BORDER_COLOR
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Border color is not supported"
argument_list|)
expr_stmt|;
comment|// TODO Handle case of using glTextureParameterIiv() based on format
block|}
end_function
begin_comment
comment|/*!     Sets the color red to \a {r}, green to \a {g}, blue to \a {b}, and the alpha     value to \a {a}.     \overload */
end_comment
begin_function
DECL|function|setBorderColor
name|void
name|QOpenGLTexture
operator|::
name|setBorderColor
parameter_list|(
name|uint
name|r
parameter_list|,
name|uint
name|g
parameter_list|,
name|uint
name|b
parameter_list|,
name|uint
name|a
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|int
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|int
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|int
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|int
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|int
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|d
operator|->
name|borderColor
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|borderColor
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameteriv
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_BORDER_COLOR
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Border color is not supported"
argument_list|)
expr_stmt|;
comment|// TODO Handle case of using glTextureParameterIuiv() based on format
block|}
end_function
begin_comment
comment|/*!     Returns the borderColor of this texture.      \sa setBorderColor() */
end_comment
begin_function
DECL|function|borderColor
name|QColor
name|QOpenGLTexture
operator|::
name|borderColor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|QColor
name|c
argument_list|(
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|borderColor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|c
operator|.
name|setRedF
argument_list|(
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toFloat
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setGreenF
argument_list|(
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toFloat
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setBlueF
argument_list|(
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toFloat
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setAlphaF
argument_list|(
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toFloat
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the texture border color into the first four elements     of the array pointed to by \a border.      \sa setBorderColor() */
end_comment
begin_function
DECL|function|borderColor
name|void
name|QOpenGLTexture
operator|::
name|borderColor
parameter_list|(
name|float
modifier|*
name|border
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|border
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|borderColor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
literal|0.0f
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toFloat
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Writes the texture border color into the first four elements     of the array pointed to by \a border.      \overload */
end_comment
begin_function
DECL|function|borderColor
name|void
name|QOpenGLTexture
operator|::
name|borderColor
parameter_list|(
name|int
modifier|*
name|border
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|border
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|borderColor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Writes the texture border color into the first four elements     of the array pointed to by \a border.      \overload */
end_comment
begin_function
DECL|function|borderColor
name|void
name|QOpenGLTexture
operator|::
name|borderColor
parameter_list|(
name|unsigned
name|int
modifier|*
name|border
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|border
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|borderColor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|border
index|[
name|i
index|]
operator|=
name|d
operator|->
name|borderColor
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUInt
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the minimum level of detail to \a value. This limits the selection of highest     resolution mipmap (lowest mipmap level). The default value is -1000.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa minimumLevelOfDetail(), setMaximumLevelOfDetail(), setLevelOfDetailRange() */
end_comment
begin_function
DECL|function|setMinimumLevelOfDetail
name|void
name|QOpenGLTexture
operator|::
name|setMinimumLevelOfDetail
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|value
operator|<
name|d
operator|->
name|maxLevelOfDetail
argument_list|)
expr_stmt|;
name|d
operator|->
name|minLevelOfDetail
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterf
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MIN_LOD
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Detail level is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum level of detail parameter.      \sa setMinimumLevelOfDetail(), maximumLevelOfDetail(), levelOfDetailRange() */
end_comment
begin_function
DECL|function|minimumLevelOfDetail
name|float
name|QOpenGLTexture
operator|::
name|minimumLevelOfDetail
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minLevelOfDetail
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the maximum level of detail to \a value. This limits the selection of lowest     resolution mipmap (highest mipmap level). The default value is 1000.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa maximumLevelOfDetail(), setMinimumLevelOfDetail(), setLevelOfDetailRange() */
end_comment
begin_function
DECL|function|setMaximumLevelOfDetail
name|void
name|QOpenGLTexture
operator|::
name|setMaximumLevelOfDetail
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|value
operator|>
name|d
operator|->
name|minLevelOfDetail
argument_list|)
expr_stmt|;
name|d
operator|->
name|maxLevelOfDetail
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterf
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAX_LOD
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Detail level is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum level of detail parameter.      \sa setMaximumLevelOfDetail(), minimumLevelOfDetail(), levelOfDetailRange() */
end_comment
begin_function
DECL|function|maximumLevelOfDetail
name|float
name|QOpenGLTexture
operator|::
name|maximumLevelOfDetail
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maxLevelOfDetail
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the minimum level of detail parameters to \a min and the maximum level     to \a max.     \note This function has no effect on Qt built for OpenGL ES 2.     \sa levelOfDetailRange(), setMinimumLevelOfDetail(), setMaximumLevelOfDetail() */
end_comment
begin_function
DECL|function|setLevelOfDetailRange
name|void
name|QOpenGLTexture
operator|::
name|setLevelOfDetailRange
parameter_list|(
name|float
name|min
parameter_list|,
name|float
name|max
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|min
operator|<
name|max
argument_list|)
expr_stmt|;
name|d
operator|->
name|minLevelOfDetail
operator|=
name|min
expr_stmt|;
name|d
operator|->
name|maxLevelOfDetail
operator|=
name|max
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterf
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MIN_LOD
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterf
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_MAX_LOD
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Detail level is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum and maximum level of detail parameters.      \sa setLevelOfDetailRange(), minimumLevelOfDetail(), maximumLevelOfDetail() */
end_comment
begin_function
DECL|function|levelOfDetailRange
name|QPair
argument_list|<
name|float
argument_list|,
name|float
argument_list|>
name|QOpenGLTexture
operator|::
name|levelOfDetailRange
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|qMakePair
argument_list|(
name|d
operator|->
name|minLevelOfDetail
argument_list|,
name|d
operator|->
name|maxLevelOfDetail
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the level of detail bias to \a bias.     Level of detail bias affects the point at which mipmapping levels change.     Increasing values for level of detail bias makes the overall images blurrier     or smoother. Decreasing values make the overall images sharper.      \note This function has no effect on Qt built for OpenGL ES 2.     \sa levelofDetailBias() */
end_comment
begin_function
DECL|function|setLevelofDetailBias
name|void
name|QOpenGLTexture
operator|::
name|setLevelofDetailBias
parameter_list|(
name|float
name|bias
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QOpenGLTexture
argument_list|)
expr_stmt|;
name|d
operator|->
name|create
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|texFuncs
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|levelOfDetailBias
operator|=
name|bias
expr_stmt|;
name|d
operator|->
name|texFuncs
operator|->
name|glTextureParameterf
argument_list|(
name|d
operator|->
name|textureId
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|bindingTarget
argument_list|,
name|GL_TEXTURE_LOD_BIAS
argument_list|,
name|bias
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|bias
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QOpenGLTexture: Detail level is not supported"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the level of detail bias parameter.      \sa setLevelofDetailBias() */
end_comment
begin_function
DECL|function|levelofDetailBias
name|float
name|QOpenGLTexture
operator|::
name|levelofDetailBias
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTexture
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|levelOfDetailBias
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
