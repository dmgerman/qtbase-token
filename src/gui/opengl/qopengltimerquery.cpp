begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Klaralvdalens Datakonsult AB (KDAB). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopengltimerquery.h"
end_include
begin_include
include|#
directive|include
file|"qopenglqueryhelper_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLContext>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// Helper class used as fallback if OpenGL<3.3 is being used with EXT_timer_query
end_comment
begin_class
DECL|class|QExtTimerQueryHelper
class|class
name|QExtTimerQueryHelper
block|{
public|public:
DECL|function|QExtTimerQueryHelper
name|QExtTimerQueryHelper
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|GetQueryObjectui64vEXT
operator|=
expr|reinterpret_cast
operator|<
name|void
argument_list|(
name|QOPENGLF_APIENTRYP
argument_list|)
argument_list|(
name|GLuint
argument_list|,
name|GLenum
argument_list|,
name|GLuint64EXT
operator|*
argument_list|)
operator|>
operator|(
name|context
operator|->
name|getProcAddress
argument_list|(
literal|"glGetQueryObjectui64vEXT"
argument_list|)
operator|)
expr_stmt|;
name|GetQueryObjecti64vEXT
operator|=
expr|reinterpret_cast
operator|<
name|void
argument_list|(
name|QOPENGLF_APIENTRYP
argument_list|)
argument_list|(
name|GLuint
argument_list|,
name|GLenum
argument_list|,
name|GLint64EXT
operator|*
argument_list|)
operator|>
operator|(
name|context
operator|->
name|getProcAddress
argument_list|(
literal|"glGetQueryObjecti64vEXT"
argument_list|)
operator|)
expr_stmt|;
block|}
DECL|function|glGetQueryObjectui64vEXT
specifier|inline
name|void
name|glGetQueryObjectui64vEXT
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint64EXT
modifier|*
name|params
parameter_list|)
block|{
name|GetQueryObjectui64vEXT
argument_list|(
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
DECL|function|glGetQueryObjecti64vEXT
specifier|inline
name|void
name|glGetQueryObjecti64vEXT
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint64EXT
modifier|*
name|params
parameter_list|)
block|{
name|GetQueryObjecti64vEXT
argument_list|(
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
private|private:
name|void
function_decl|(
name|QOPENGLF_APIENTRYP
name|GetQueryObjectui64vEXT
function_decl|)
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint64EXT
modifier|*
name|params
parameter_list|)
function_decl|;
name|void
function_decl|(
name|QOPENGLF_APIENTRYP
name|GetQueryObjecti64vEXT
function_decl|)
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint64EXT
modifier|*
name|params
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QOpenGLTimerQueryPrivate
class|class
name|QOpenGLTimerQueryPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
public|public:
DECL|function|QOpenGLTimerQueryPrivate
name|QOpenGLTimerQueryPrivate
parameter_list|()
member_init_list|:
name|QObjectPrivate
argument_list|()
member_init_list|,
name|context
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ext
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|timeInterval
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|timer
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|~QOpenGLTimerQueryPrivate
name|~
name|QOpenGLTimerQueryPrivate
parameter_list|()
block|{
operator|delete
name|core
expr_stmt|;
operator|delete
name|ext
expr_stmt|;
block|}
name|bool
name|create
parameter_list|()
function_decl|;
name|void
name|destroy
parameter_list|()
function_decl|;
name|void
name|begin
parameter_list|()
function_decl|;
name|void
name|end
parameter_list|()
function_decl|;
name|GLuint64
name|waitForTimeStamp
parameter_list|()
specifier|const
function_decl|;
name|void
name|recordTimestamp
parameter_list|()
function_decl|;
name|bool
name|isResultAvailable
parameter_list|()
specifier|const
function_decl|;
name|GLuint64
name|result
parameter_list|()
specifier|const
function_decl|;
comment|// There are several cases we must handle:
comment|//   OpenGL>=3.3 includes timer queries as a core feature
comment|//   ARB_timer_query has same functionality as above. Requires OpenGL 3.2
comment|//   EXT_timer_query offers limited support. Can be used with OpenGL>=1.5
comment|//
comment|// Note that some implementations (OS X) provide OpenGL 3.2 but do not expose the
comment|// ARB_timer_query extension. In such situations we must also be able to handle
comment|// using the EXT_timer_query extension with any version of OpenGL.
comment|//
comment|// OpenGL 1.5 or above contains the generic query API and OpenGL 3.3 and
comment|// ARB_timer_query provide the 64-bit query API. These are wrapped by
comment|// QOpenGLQueryHelper. All we need to handle in addition is the EXT_timer_query
comment|// case and to take care not to call the Core/ARB functions when we only
comment|// have EXT_timer_query available.
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
DECL|member|core
name|QOpenGLQueryHelper
modifier|*
name|core
decl_stmt|;
DECL|member|ext
name|QExtTimerQueryHelper
modifier|*
name|ext
decl_stmt|;
DECL|member|timeInterval
specifier|mutable
name|GLuint64
name|timeInterval
decl_stmt|;
DECL|member|timer
name|GLuint
name|timer
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|create
name|bool
name|QOpenGLTimerQueryPrivate
operator|::
name|create
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|timer
operator|&&
name|context
operator|==
name|ctx
condition|)
return|return
literal|true
return|;
name|context
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|qWarning
argument_list|(
literal|"A current OpenGL context is required to create timer query objects"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Resolve the functions provided by OpenGL 1.5 and OpenGL 3.3 or ARB_timer_query
name|core
operator|=
operator|new
name|QOpenGLQueryHelper
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|// Check to see if we also need to resolve the functions for EXT_timer_query
name|QSurfaceFormat
name|f
init|=
name|context
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|version
argument_list|()
operator|<=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_timer_query"
argument_list|)
argument_list|)
operator|&&
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_timer_query"
argument_list|)
argument_list|)
condition|)
block|{
name|ext
operator|=
operator|new
name|QExtTimerQueryHelper
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|version
argument_list|()
operator|<=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_timer_query"
argument_list|)
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_timer_query"
argument_list|)
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery requires one of:\n"
literal|"  OpenGL 3.3 or newer,\n"
literal|"  OpenGL 3.2 and the ARB_timer_query extension\n"
literal|"  or the EXT_timer query extension"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|core
operator|->
name|glGenQueries
argument_list|(
literal|1
argument_list|,
operator|&
name|timer
argument_list|)
expr_stmt|;
return|return
operator|(
name|timer
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QOpenGLTimerQueryPrivate
operator|::
name|destroy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|timer
condition|)
return|return;
name|core
operator|->
name|glDeleteQueries
argument_list|(
literal|1
argument_list|,
operator|&
name|timer
argument_list|)
expr_stmt|;
name|timer
operator|=
literal|0
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// GL_TIME_ELAPSED_EXT is not defined on OS X 10.6
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|)
end_if
begin_define
DECL|macro|GL_TIME_ELAPSED_EXT
define|#
directive|define
name|GL_TIME_ELAPSED_EXT
value|0x88BF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// GL_TIME_ELAPSED is not defined on OS X 10.7 or 10.8 yet
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GL_TIME_ELAPSED
argument_list|)
end_if
begin_define
DECL|macro|GL_TIME_ELAPSED
define|#
directive|define
name|GL_TIME_ELAPSED
value|GL_TIME_ELAPSED_EXT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|begin
name|void
name|QOpenGLTimerQueryPrivate
operator|::
name|begin
parameter_list|()
block|{
name|core
operator|->
name|glBeginQuery
argument_list|(
name|GL_TIME_ELAPSED
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end
name|void
name|QOpenGLTimerQueryPrivate
operator|::
name|end
parameter_list|()
block|{
name|core
operator|->
name|glEndQuery
argument_list|(
name|GL_TIME_ELAPSED
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recordTimestamp
name|void
name|QOpenGLTimerQueryPrivate
operator|::
name|recordTimestamp
parameter_list|()
block|{
comment|// Don't call glQueryCounter if we only have EXT_timer_query
if|#
directive|if
name|defined
argument_list|(
name|GL_TIMESTAMP
argument_list|)
if|if
condition|(
operator|!
name|ext
condition|)
name|core
operator|->
name|glQueryCounter
argument_list|(
name|timer
argument_list|,
name|GL_TIMESTAMP
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::recordTimestamp() requires OpenGL 3.3 or GL_ARB_timer_query"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::recordTimestamp() requires OpenGL 3.3 or GL_ARB_timer_query"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|waitForTimeStamp
name|GLuint64
name|QOpenGLTimerQueryPrivate
operator|::
name|waitForTimeStamp
parameter_list|()
specifier|const
block|{
name|GLint64
name|tmp
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GL_TIMESTAMP
argument_list|)
if|if
condition|(
operator|!
name|ext
condition|)
name|core
operator|->
name|glGetInteger64v
argument_list|(
name|GL_TIMESTAMP
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::waitForTimestamp() requires OpenGL 3.3 or GL_ARB_timer_query"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::waitForTimestamp() requires OpenGL 3.3 or GL_ARB_timer_query"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GLuint64
name|timestamp
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
return|return
name|timestamp
return|;
block|}
end_function
begin_function
DECL|function|isResultAvailable
name|bool
name|QOpenGLTimerQueryPrivate
operator|::
name|isResultAvailable
parameter_list|()
specifier|const
block|{
name|GLuint
name|available
init|=
name|GL_FALSE
decl_stmt|;
name|core
operator|->
name|glGetQueryObjectuiv
argument_list|(
name|timer
argument_list|,
name|GL_QUERY_RESULT_AVAILABLE
argument_list|,
operator|&
name|available
argument_list|)
expr_stmt|;
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|result
name|GLuint64
name|QOpenGLTimerQueryPrivate
operator|::
name|result
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|ext
condition|)
name|core
operator|->
name|glGetQueryObjectui64v
argument_list|(
name|timer
argument_list|,
name|GL_QUERY_RESULT
argument_list|,
operator|&
name|timeInterval
argument_list|)
expr_stmt|;
else|else
name|ext
operator|->
name|glGetQueryObjectui64vEXT
argument_list|(
name|timer
argument_list|,
name|GL_QUERY_RESULT
argument_list|,
operator|&
name|timeInterval
argument_list|)
expr_stmt|;
return|return
name|timeInterval
return|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLTimerQuery     \brief The QOpenGLTimerQuery class wraps an OpenGL timer query object.     \inmodule QtGui     \since 5.1     \ingroup painting-3D      OpenGL timer query objects are OpenGL managed resources to measure the     execution times of sequences of OpenGL commands on the GPU.      OpenGL offers various levels of support for timer queries, depending on     the version of OpenGL you have and the presence of the ARB_timer_query or     EXT_timer_query extensions. The support can be summarized as:      \list         \li OpenGL>=3.3 offers full support for all timer query functionality.         \li OpenGL 3.2 with the ARB_timer_query extension offers full support             for all timer query functionality.         \li OpenGL<=3.2 with the EXT_timer_query extension offers limited support             in that the timestamp of the GPU cannot be queried. Places where this             impacts functions provided by Qt classes will be highlighted in the             function documentation.         \li OpenGL ES 2 (and OpenGL ES 3) do not provide any support for OpenGL             timer queries.     \endlist      OpenGL represents time with a granularity of 1 nanosecond (1e-9 seconds). As a     consequence of this, 32-bit integers would only give a total possible duration     of approximately 4 seconds, which would not be difficult to exceed in poorly     performing or lengthy operations. OpenGL therefore uses 64 bit integer types     to represent times. A GLuint64 variable has enough width to contain a duration     of hundreds of years, which is plenty for real-time rendering needs.      As with the other Qt OpenGL classes, QOpenGLTimerQuery has a create()     function to create the underlying OpenGL object. This is to allow the developer to     ensure that there is a valid current OpenGL context at the time.      Once created, timer queries can be issued in one of several ways. The simplest     method is to delimit a block of commands with calls to begin() and end(). This     instructs OpenGL to measure the time taken from completing all commands issued     prior to begin() until the completion of all commands issued prior to end().      At the end of a frame we can retrieve the results by calling waitForResult().     As this function's name implies, it blocks CPU execution until OpenGL notifies     that the timer query result is available. To avoid blocking, you can check     if the query result is available by calling isResultAvailable(). Note that     modern GPUs are deeply pipelined and query results may not become availble for     between 1-5 frames after they were issued.      Note that OpenGL does not permit nesting or interleaving of multiple timer queries     using begin() and end(). Using multiple timer queries and recordTimestamp() avoids     this limitation. When using recordTimestamp() the result can be obtained at     some later time using isResultAvailable() and waitForResult(). Qt provides the     convenience class QOpenGLTimeMonitor that helps with using multiple query objects.      \sa QOpenGLTimeMonitor */
end_comment
begin_comment
comment|/*!     Creates a QOpenGLTimerQuery instance with the given \a parent. You must call create()     with a valid OpenGL context before using. */
end_comment
begin_constructor
DECL|function|QOpenGLTimerQuery
name|QOpenGLTimerQuery
operator|::
name|QOpenGLTimerQuery
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLTimerQueryPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QOpenGLTimerQuery and the underlying OpenGL resource. */
end_comment
begin_destructor
DECL|function|~QOpenGLTimerQuery
name|QOpenGLTimerQuery
operator|::
name|~
name|QOpenGLTimerQuery
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|oldContext
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|context
operator|!=
name|ctx
condition|)
block|{
name|oldContext
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|context
operator|->
name|makeCurrent
argument_list|(
name|oldContext
operator|->
name|surface
argument_list|()
argument_list|)
condition|)
block|{
name|ctx
operator|=
name|d
operator|->
name|context
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::~QOpenGLTimerQuery() failed to make query objects's context current"
argument_list|)
expr_stmt|;
name|ctx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
condition|)
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldContext
condition|)
block|{
if|if
condition|(
operator|!
name|oldContext
operator|->
name|makeCurrent
argument_list|(
name|oldContext
operator|->
name|surface
argument_list|()
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLTimerQuery::~QOpenGLTimerQuery() failed to restore current context"
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     Creates the underlying OpenGL timer query object. There must be a valid OpenGL context     that supports query objects current for this function to succeed.      Returns true if the OpenGL timer query object was successfully created. */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLTimerQuery
operator|::
name|create
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|create
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the underlying OpenGL timer query object. The context that was current when     create() was called must be current when calling this function. */
end_comment
begin_function
DECL|function|destroy
name|void
name|QOpenGLTimerQuery
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
name|d
operator|->
name|destroy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the underlying OpenGL query object has been created. If this     returns true and the associated OpenGL context is current, then you are able to issue     queries with this object. */
end_comment
begin_function
DECL|function|isCreated
name|bool
name|QOpenGLTimerQuery
operator|::
name|isCreated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|timer
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the id of the underlying OpenGL query object. */
end_comment
begin_function
DECL|function|objectId
name|GLuint
name|QOpenGLTimerQuery
operator|::
name|objectId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|timer
return|;
block|}
end_function
begin_comment
comment|/*!     Marks the start point in the OpenGL command queue for a sequence of commands to     be timed by this query object.      This is useful for simple use-cases. Usually it is better to use recordTimestamp().      \sa end(), isResultAvailable(), waitForResult(), recordTimestamp() */
end_comment
begin_function
DECL|function|begin
name|void
name|QOpenGLTimerQuery
operator|::
name|begin
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
name|d
operator|->
name|begin
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Marks the end point in the OpenGL command queue for a sequence of commands to     be timed by this query object.      This is useful for simple use-cases. Usually it is better to use recordTimestamp().      \sa begin(), isResultAvailable(), waitForResult(), recordTimestamp() */
end_comment
begin_function
DECL|function|end
name|void
name|QOpenGLTimerQuery
operator|::
name|end
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
name|d
operator|->
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Places a marker in the OpenGL command queue for the GPU to record the timestamp     when this marker is reached by the GPU. This function is non-blocking and the     result will become available at some later time.      The availability of the result can be checked with isResultAvailable(). The result     can be fetched with waitForResult() which will block if the result is not yet     available.      \sa waitForResult(), isResultAvailable(), begin(), end() */
end_comment
begin_function
DECL|function|recordTimestamp
name|void
name|QOpenGLTimerQuery
operator|::
name|recordTimestamp
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|recordTimestamp
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current timestamp of the GPU when all previously issued OpenGL     commands have been received but not necessarily executed by the GPU.      This function blocks until the result is returned.      \sa recordTimestamp() */
end_comment
begin_function
DECL|function|waitForTimestamp
name|GLuint64
name|QOpenGLTimerQuery
operator|::
name|waitForTimestamp
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|waitForTimeStamp
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the OpenGL timer query result is available.      This function is non-blocking and ideally should be used to check for the     availability of the query result before calling waitForResult().      \sa waitForResult() */
end_comment
begin_function
DECL|function|isResultAvailable
name|bool
name|QOpenGLTimerQuery
operator|::
name|isResultAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isResultAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the result of the OpenGL timer query.      This function will block until the result is made available by OpenGL. It is     recommended to call isResultAvailable() to ensure that the result is available     to avoid unnecessary blocking and stalling.      \sa isResultAvailable() */
end_comment
begin_function
DECL|function|waitForResult
name|GLuint64
name|QOpenGLTimerQuery
operator|::
name|waitForResult
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimerQuery
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|result
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QOpenGLTimeMonitorPrivate
class|class
name|QOpenGLTimeMonitorPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
public|public:
DECL|function|QOpenGLTimeMonitorPrivate
name|QOpenGLTimeMonitorPrivate
parameter_list|()
member_init_list|:
name|QObjectPrivate
argument_list|()
member_init_list|,
name|timers
argument_list|()
member_init_list|,
name|timeSamples
argument_list|()
member_init_list|,
name|context
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|core
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ext
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|requestedSampleCount
argument_list|(
literal|2
argument_list|)
member_init_list|,
name|currentSample
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|timerQueryActive
argument_list|(
literal|false
argument_list|)
block|{     }
DECL|function|~QOpenGLTimeMonitorPrivate
name|~
name|QOpenGLTimeMonitorPrivate
parameter_list|()
block|{
operator|delete
name|core
expr_stmt|;
operator|delete
name|ext
expr_stmt|;
block|}
name|bool
name|create
parameter_list|()
function_decl|;
name|void
name|destroy
parameter_list|()
function_decl|;
name|void
name|recordSample
parameter_list|()
function_decl|;
name|bool
name|isResultAvailable
parameter_list|()
specifier|const
function_decl|;
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|samples
parameter_list|()
specifier|const
function_decl|;
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|intervals
parameter_list|()
specifier|const
function_decl|;
name|void
name|reset
parameter_list|()
function_decl|;
DECL|member|timers
name|QVector
argument_list|<
name|GLuint
argument_list|>
name|timers
decl_stmt|;
DECL|member|timeSamples
specifier|mutable
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|timeSamples
decl_stmt|;
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
DECL|member|core
name|QOpenGLQueryHelper
modifier|*
name|core
decl_stmt|;
DECL|member|ext
name|QExtTimerQueryHelper
modifier|*
name|ext
decl_stmt|;
DECL|member|requestedSampleCount
name|int
name|requestedSampleCount
decl_stmt|;
DECL|member|currentSample
name|int
name|currentSample
decl_stmt|;
DECL|member|timerQueryActive
specifier|mutable
name|bool
name|timerQueryActive
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|create
name|bool
name|QOpenGLTimeMonitorPrivate
operator|::
name|create
parameter_list|()
block|{
if|if
condition|(
operator|!
name|timers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|timers
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|timers
operator|.
name|size
argument_list|()
operator|==
name|requestedSampleCount
condition|)
return|return
literal|true
return|;
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|context
operator|!=
name|ctx
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTimeMonitor: Attempting to use different OpenGL context to recreate timers.\n"
literal|"Please call destroy() first or use the same context to previously create"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|context
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|qWarning
argument_list|(
literal|"A current OpenGL context is required to create timer query objects"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Resize the vectors that hold the timers and the recorded samples
name|timers
operator|.
name|resize
argument_list|(
name|requestedSampleCount
argument_list|)
expr_stmt|;
name|timeSamples
operator|.
name|resize
argument_list|(
name|requestedSampleCount
argument_list|)
expr_stmt|;
comment|// Resolve the functions provided by OpenGL 1.5 and OpenGL 3.3 or ARB_timer_query
name|core
operator|=
operator|new
name|QOpenGLQueryHelper
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|// Check to see if we also need to resolve the functions for EXT_timer_query
name|QSurfaceFormat
name|f
init|=
name|context
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|version
argument_list|()
operator|<=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_timer_query"
argument_list|)
argument_list|)
operator|&&
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_timer_query"
argument_list|)
argument_list|)
condition|)
block|{
name|ext
operator|=
operator|new
name|QExtTimerQueryHelper
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|version
argument_list|()
operator|<=
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_timer_query"
argument_list|)
argument_list|)
operator|&&
operator|!
name|context
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_EXT_timer_query"
argument_list|)
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTimeMonitor requires one of:\n"
literal|"  OpenGL 3.3 or newer,\n"
literal|"  OpenGL 3.2 and the ARB_timer_query extension\n"
literal|"  or the EXT_timer query extension"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|core
operator|->
name|glGenQueries
argument_list|(
name|requestedSampleCount
argument_list|,
name|timers
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|timers
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QOpenGLTimeMonitorPrivate
operator|::
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|timers
operator|.
name|isEmpty
argument_list|()
operator|||
name|timers
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|core
operator|->
name|glDeleteQueries
argument_list|(
name|timers
operator|.
name|size
argument_list|()
argument_list|,
name|timers
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|timers
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|core
expr_stmt|;
name|core
operator|=
literal|0
expr_stmt|;
operator|delete
name|ext
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recordSample
name|void
name|QOpenGLTimeMonitorPrivate
operator|::
name|recordSample
parameter_list|()
block|{
comment|// Use glQueryCounter() and GL_TIMESTAMP where available.
comment|// Otherwise, simulate it with glBeginQuery()/glEndQuery()
if|if
condition|(
operator|!
name|ext
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|GL_TIMESTAMP
argument_list|)
name|core
operator|->
name|glQueryCounter
argument_list|(
name|timers
operator|.
name|at
argument_list|(
operator|++
name|currentSample
argument_list|)
argument_list|,
name|GL_TIMESTAMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|currentSample
operator|==
operator|-
literal|1
condition|)
block|{
name|core
operator|->
name|glBeginQuery
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|,
name|timers
operator|.
name|at
argument_list|(
operator|++
name|currentSample
argument_list|)
argument_list|)
expr_stmt|;
name|timerQueryActive
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentSample
operator|<
name|timers
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|core
operator|->
name|glEndQuery
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|)
expr_stmt|;
name|core
operator|->
name|glBeginQuery
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|,
name|timers
operator|.
name|at
argument_list|(
operator|++
name|currentSample
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|timerQueryActive
condition|)
block|{
name|core
operator|->
name|glEndQuery
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|)
expr_stmt|;
name|timerQueryActive
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|isResultAvailable
name|bool
name|QOpenGLTimeMonitorPrivate
operator|::
name|isResultAvailable
parameter_list|()
specifier|const
block|{
comment|// The OpenGL spec says that if a query result is ready then the results of all queries
comment|// of the same type issued before it must also be ready. Therefore we only need to check
comment|// the availability of the result for the last issued query
name|GLuint
name|available
init|=
name|GL_FALSE
decl_stmt|;
name|core
operator|->
name|glGetQueryObjectuiv
argument_list|(
name|timers
operator|.
name|at
argument_list|(
name|currentSample
argument_list|)
argument_list|,
name|GL_QUERY_RESULT_AVAILABLE
argument_list|,
operator|&
name|available
argument_list|)
expr_stmt|;
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|samples
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|QOpenGLTimeMonitorPrivate
operator|::
name|samples
parameter_list|()
specifier|const
block|{
comment|// For the Core and ARB options just ask for the timestamp for each timer query.
comment|// For the EXT implementation we cannot obtain timestamps so we defer any result
comment|// collection to the intervals() function
if|if
condition|(
operator|!
name|ext
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|currentSample
condition|;
operator|++
name|i
control|)
name|core
operator|->
name|glGetQueryObjectui64v
argument_list|(
name|timers
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|GL_QUERY_RESULT
argument_list|,
operator|&
name|timeSamples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTimeMonitor::samples() requires OpenGL>=3.3\n"
literal|"or OpenGL 3.2 and GL_ARB_timer_query"
argument_list|)
expr_stmt|;
block|}
return|return
name|timeSamples
return|;
block|}
end_function
begin_function
DECL|function|intervals
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|QOpenGLTimeMonitorPrivate
operator|::
name|intervals
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|intervals
argument_list|(
name|timers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ext
condition|)
block|{
comment|// Obtain the timestamp samples and calculate the interval durations
specifier|const
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|timeStamps
init|=
name|samples
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|intervals
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|intervals
index|[
name|i
index|]
operator|=
name|timeStamps
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|timeStamps
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// Stop the last timer if needed
if|if
condition|(
name|timerQueryActive
condition|)
block|{
name|core
operator|->
name|glEndQuery
argument_list|(
name|GL_TIME_ELAPSED_EXT
argument_list|)
expr_stmt|;
name|timerQueryActive
operator|=
literal|false
expr_stmt|;
block|}
comment|// Obtain the results from all timers apart from the redundant last one. In this
comment|// case the results actually are the intervals not timestamps
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentSample
condition|;
operator|++
name|i
control|)
name|ext
operator|->
name|glGetQueryObjectui64vEXT
argument_list|(
name|timers
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|GL_QUERY_RESULT
argument_list|,
operator|&
name|intervals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|intervals
return|;
block|}
end_function
begin_function
DECL|function|reset
name|void
name|QOpenGLTimeMonitorPrivate
operator|::
name|reset
parameter_list|()
block|{
name|currentSample
operator|=
operator|-
literal|1
expr_stmt|;
name|timeSamples
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QOpenGLTimeMonitor     \brief The QOpenGLTimeMonitor class wraps a sequence of OpenGL timer query objects.     \inmodule QtGui     \since 5.1     \ingroup painting-3D      The QOpenGLTimeMonitor class is a convenience wrapper around a collection of OpenGL     timer query objects used to measure intervals of time on the GPU to the level of     granularity required by your rendering application.      The OpenGL timer queries objects are queried in sequence to record the GPU     timestamps at positions of interest in your rendering code. Once the results for     all issues timer queries become available, the results can be fetched and     QOpenGLTimerMonitor will calculate the recorded time intervals for you.      The typical use case of this class is to either profile your application's rendering     algorithms or to adjust those algorithms in real-time for dynamic performance/quality     balancing.      Prior to using QOpenGLTimeMonitor in your rendering function you should set the     required number of sample points that you wish to record by calling setSamples(). Note     that measuring N sample points will produce N-1 time intervals. Once you have set the     number of sample points, call the create() function with a valid current OpenGL context     to create the necessary query timer objects. These steps are usually performed just     once in an initialization function.      Use the recordSample() function to delimit blocks of code containing OpenGL commands     that you wish to time. You can check availability of the resulting time     samples and time intervals with isResultAvailable(). The calculated time intervals and     the raw timestamp samples can be retrieved with the blocking waitForIntervals() and     waitForSamples() functions respectively.      After retrieving the results and before starting a new round of taking samples     (for example, in the next frame) be sure to call the reset() function which will clear     the cached results and reset the timer index back to the first timer object.      \sa QOpenGLTimerQuery */
end_comment
begin_comment
comment|/*!     Creates a QOpenGLTimeMonitor instance with the given \a parent. You must call create()     with a valid OpenGL context before using.      \sa setSampleCount(), create() */
end_comment
begin_constructor
DECL|function|QOpenGLTimeMonitor
name|QOpenGLTimeMonitor
operator|::
name|QOpenGLTimeMonitor
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QOpenGLTimeMonitorPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QOpenGLTimeMonitor and any underlying OpenGL resources. */
end_comment
begin_destructor
DECL|function|~QOpenGLTimeMonitor
name|QOpenGLTimeMonitor
operator|::
name|~
name|QOpenGLTimeMonitor
parameter_list|()
block|{
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|oldContext
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|context
operator|!=
name|ctx
condition|)
block|{
name|oldContext
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|context
operator|->
name|makeCurrent
argument_list|(
name|oldContext
operator|->
name|surface
argument_list|()
argument_list|)
condition|)
block|{
name|ctx
operator|=
name|d
operator|->
name|context
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOpenGLTimeMonitor::~QOpenGLTimeMonitor() failed to make time monitor's context current"
argument_list|)
expr_stmt|;
name|ctx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
condition|)
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldContext
condition|)
block|{
if|if
condition|(
operator|!
name|oldContext
operator|->
name|makeCurrent
argument_list|(
name|oldContext
operator|->
name|surface
argument_list|()
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"QOpenGLTimeMonitor::~QOpenGLTimeMonitor() failed to restore current context"
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     Sets the number of sample points to \a sampleCount. After setting the number     of samples with this function, you must call create() to instantiate the underlying     OpenGL timer query objects.      The new \a sampleCount must be at least 2.      \sa sampleCount(), create(), recordSample() */
end_comment
begin_function
DECL|function|setSampleCount
name|void
name|QOpenGLTimeMonitor
operator|::
name|setSampleCount
parameter_list|(
name|int
name|sampleCount
parameter_list|)
block|{
comment|// We need at least 2 samples to get an interval
if|if
condition|(
name|sampleCount
operator|<
literal|2
condition|)
return|return;
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestedSampleCount
operator|=
name|sampleCount
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of sample points that have been requested with     setSampleCount(). If create was successfully called following setSampleCount(),     then the value returned will be the actual number of sample points     that can be used.      The default value for sample count is 2, leading to the measurement of a     single interval.      \sa setSampleCount() */
end_comment
begin_function
DECL|function|sampleCount
name|int
name|QOpenGLTimeMonitor
operator|::
name|sampleCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|requestedSampleCount
return|;
block|}
end_function
begin_comment
comment|/*!     Instantiate sampleCount() OpenGL timer query objects that will be used     to track the amount of time taken to execute OpenGL commands between     successive calls to recordSample().      Returns true if the OpenGL timer query objects could be created.      \sa destroy(), setSampleCount(), recordSample() */
end_comment
begin_function
DECL|function|create
name|bool
name|QOpenGLTimeMonitor
operator|::
name|create
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|create
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys any OpenGL timer query objects used within this instance.      \sa create() */
end_comment
begin_function
DECL|function|destroy
name|void
name|QOpenGLTimeMonitor
operator|::
name|destroy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
name|d
operator|->
name|destroy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the underlying OpenGL query objects have been created. If this     returns true and the associated OpenGL context is current, then you are able to record     time samples with this object. */
end_comment
begin_function
DECL|function|isCreated
name|bool
name|QOpenGLTimeMonitor
operator|::
name|isCreated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|d
operator|->
name|timers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|timers
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QVector containing the object Ids of the OpenGL timer query objects. */
end_comment
begin_function
DECL|function|objectIds
name|QVector
argument_list|<
name|GLuint
argument_list|>
name|QOpenGLTimeMonitor
operator|::
name|objectIds
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|timers
return|;
block|}
end_function
begin_comment
comment|/*!     Issues an OpenGL timer query at this point in the OpenGL command queue. Calling this     function in a sequence in your application's rendering function, will build up     details of the GPU time taken to execute the OpenGL commands between successive     calls to this function.      \sa setSampleCount(), isResultAvailable(), waitForSamples(), waitForIntervals() */
end_comment
begin_function
DECL|function|recordSample
name|int
name|QOpenGLTimeMonitor
operator|::
name|recordSample
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
name|d
operator|->
name|recordSample
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|currentSample
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the OpenGL timer query results are available.      \sa waitForSamples(), waitForIntervals() */
end_comment
begin_function
DECL|function|isResultAvailable
name|bool
name|QOpenGLTimeMonitor
operator|::
name|isResultAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isResultAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QVector containing the GPU timestamps taken with recordSample().      This function will block until OpenGL indicates the results are available. It     is recommended to check the availability of the result prior to calling this     function with isResultAvailable().      \note This function only works on systems that have OpenGL>=3.3 or the           ARB_timer_query extension. See QOpenGLTimerQuery for more details.      \sa waitForIntervals(), isResultAvailable() */
end_comment
begin_function
DECL|function|waitForSamples
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|QOpenGLTimeMonitor
operator|::
name|waitForSamples
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|samples
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QVector containing the time intervals delimited by the calls to     recordSample(). The resulting vector will contain one fewer element as     this represents the intervening intervals rather than the actual timestamp     samples.      This function will block until OpenGL indicates the results are available. It     is recommended to check the availability of the result prior to calling this     function with isResultAvailable().      \sa waitForSamples(), isResultAvailable() */
end_comment
begin_function
DECL|function|waitForIntervals
name|QVector
argument_list|<
name|GLuint64
argument_list|>
name|QOpenGLTimeMonitor
operator|::
name|waitForIntervals
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|intervals
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the time monitor ready for use in another frame of rendering. Call     this once you have obtained the previous results and before calling     recordSample() for the first time on the next frame.      \sa recordSample() */
end_comment
begin_function
DECL|function|reset
name|void
name|QOpenGLTimeMonitor
operator|::
name|reset
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLTimeMonitor
argument_list|)
expr_stmt|;
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
