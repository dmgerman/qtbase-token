begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtriangulatingstroker_p.h"
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|CURVE_FLATNESS
define|#
directive|define
name|CURVE_FLATNESS
value|Q_PI / 8
DECL|function|endCapOrJoinClosed
name|void
name|QTriangulatingStroker
operator|::
name|endCapOrJoinClosed
parameter_list|(
specifier|const
name|qreal
modifier|*
name|start
parameter_list|,
specifier|const
name|qreal
modifier|*
name|cur
parameter_list|,
name|bool
name|implicitClose
parameter_list|,
name|bool
name|endsAtStart
parameter_list|)
block|{
if|if
condition|(
name|endsAtStart
condition|)
block|{
name|join
argument_list|(
name|start
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|implicitClose
condition|)
block|{
name|join
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|lineTo
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|start
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endCap
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
name|int
name|count
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Copy the (x, y) values because QDataBuffer::add(const float& t)
comment|// may resize the buffer, which will leave t pointing at the
comment|// previous buffer's memory region if we don't copy first.
name|float
name|x
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
decl_stmt|;
name|float
name|y
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
decl_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|skipDuplicatePoints
specifier|static
specifier|inline
name|void
name|skipDuplicatePoints
parameter_list|(
specifier|const
name|qreal
modifier|*
modifier|*
name|pts
parameter_list|,
specifier|const
name|qreal
modifier|*
name|endPts
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|pts
operator|+
literal|2
operator|)
operator|<
name|endPts
operator|&&
name|float
argument_list|(
operator|(
operator|*
name|pts
operator|)
index|[
literal|0
index|]
argument_list|)
operator|==
name|float
argument_list|(
operator|(
operator|*
name|pts
operator|)
index|[
literal|2
index|]
argument_list|)
operator|&&
name|float
argument_list|(
operator|(
operator|*
name|pts
operator|)
index|[
literal|1
index|]
argument_list|)
operator|==
name|float
argument_list|(
operator|(
operator|*
name|pts
operator|)
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
operator|*
name|pts
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|process
name|void
name|QTriangulatingStroker
operator|::
name|process
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QRectF
modifier|&
parameter_list|,
name|QPainter
operator|::
name|RenderHints
name|hints
parameter_list|)
block|{
specifier|const
name|qreal
modifier|*
name|pts
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|ElementType
modifier|*
name|types
init|=
name|path
operator|.
name|elements
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
return|return;
name|float
name|realWidth
init|=
name|qpen_widthf
argument_list|(
name|pen
argument_list|)
decl_stmt|;
if|if
condition|(
name|realWidth
operator|==
literal|0
condition|)
name|realWidth
operator|=
literal|1
expr_stmt|;
name|m_width
operator|=
name|realWidth
operator|/
literal|2
expr_stmt|;
name|bool
name|cosmetic
init|=
name|qt_pen_is_cosmetic
argument_list|(
name|pen
argument_list|,
name|hints
argument_list|)
decl_stmt|;
if|if
condition|(
name|cosmetic
condition|)
block|{
name|m_width
operator|=
name|m_width
operator|*
name|m_inv_scale
expr_stmt|;
block|}
name|m_join_style
operator|=
name|qpen_joinStyle
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|m_cap_style
operator|=
name|qpen_capStyle
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_miter_limit
operator|=
name|pen
operator|.
name|miterLimit
argument_list|()
operator|*
name|qpen_widthf
argument_list|(
name|pen
argument_list|)
expr_stmt|;
comment|// The curvyness is based on the notion that I originally wanted
comment|// roughly one line segment pr 4 pixels. This may seem little, but
comment|// because we sample at constantly incrementing B(t) E [0<t<1], we
comment|// will get longer segments where the curvature is small and smaller
comment|// segments when the curvature is high.
comment|//
comment|// To get a rough idea of the length of each curve, I pretend that
comment|// the curve is a 90 degree arc, whose radius is
comment|// qMax(curveBounds.width, curveBounds.height). Based on this
comment|// logic we can estimate the length of the outline edges based on
comment|// the radius + a pen width and adjusting for scale factors
comment|// depending on if the pen is cosmetic or not.
comment|//
comment|// The curvyness value of PI/14 was based on,
comment|// arcLength = 2*PI*r/4 = PI*r/2 and splitting length into somewhere
comment|// between 3 and 8 where 5 seemed to be give pretty good results
comment|// hence: Q_PI/14. Lower divisors will give more detail at the
comment|// direct cost of performance.
comment|// simplfy pens that are thin in device size (2px wide or less)
if|if
condition|(
name|realWidth
operator|<
literal|2.5
operator|&&
operator|(
name|cosmetic
operator|||
name|m_inv_scale
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|m_cap_style
operator|==
name|Qt
operator|::
name|RoundCap
condition|)
name|m_cap_style
operator|=
name|Qt
operator|::
name|SquareCap
expr_stmt|;
if|if
condition|(
name|m_join_style
operator|==
name|Qt
operator|::
name|RoundJoin
condition|)
name|m_join_style
operator|=
name|Qt
operator|::
name|MiterJoin
expr_stmt|;
name|m_curvyness_add
operator|=
literal|0.5
expr_stmt|;
name|m_curvyness_mul
operator|=
name|CURVE_FLATNESS
operator|/
name|m_inv_scale
expr_stmt|;
name|m_roundness
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cosmetic
condition|)
block|{
name|m_curvyness_add
operator|=
name|realWidth
operator|/
literal|2
expr_stmt|;
name|m_curvyness_mul
operator|=
name|CURVE_FLATNESS
expr_stmt|;
name|m_roundness
operator|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
name|realWidth
operator|*
name|CURVE_FLATNESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_curvyness_add
operator|=
name|m_width
expr_stmt|;
name|m_curvyness_mul
operator|=
name|CURVE_FLATNESS
operator|/
name|m_inv_scale
expr_stmt|;
name|m_roundness
operator|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|4
argument_list|,
name|realWidth
operator|*
name|m_curvyness_mul
argument_list|)
expr_stmt|;
block|}
comment|// Over this level of segmentation, there doesn't seem to be any
comment|// benefit, even for huge penWidth
if|if
condition|(
name|m_roundness
operator|>
literal|24
condition|)
name|m_roundness
operator|=
literal|24
expr_stmt|;
name|m_sin_theta
operator|=
name|qFastSin
argument_list|(
name|Q_PI
operator|/
name|m_roundness
argument_list|)
expr_stmt|;
name|m_cos_theta
operator|=
name|qFastCos
argument_list|(
name|Q_PI
operator|/
name|m_roundness
argument_list|)
expr_stmt|;
specifier|const
name|qreal
modifier|*
name|endPts
init|=
name|pts
operator|+
operator|(
name|count
operator|<<
literal|1
operator|)
decl_stmt|;
specifier|const
name|qreal
modifier|*
name|startPts
init|=
literal|0
decl_stmt|;
name|Qt
operator|::
name|PenCapStyle
name|cap
init|=
name|m_cap_style
decl_stmt|;
if|if
condition|(
operator|!
name|types
condition|)
block|{
name|skipDuplicatePoints
argument_list|(
operator|&
name|pts
argument_list|,
name|endPts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pts
operator|+
literal|2
operator|)
operator|==
name|endPts
condition|)
return|return;
name|startPts
operator|=
name|pts
expr_stmt|;
name|bool
name|endsAtStart
init|=
name|float
argument_list|(
name|startPts
index|[
literal|0
index|]
argument_list|)
operator|==
name|float
argument_list|(
name|endPts
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|float
argument_list|(
name|startPts
index|[
literal|1
index|]
argument_list|)
operator|==
name|float
argument_list|(
name|endPts
index|[
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|endsAtStart
operator|||
name|path
operator|.
name|hasImplicitClose
argument_list|()
condition|)
name|m_cap_style
operator|=
name|Qt
operator|::
name|FlatCap
expr_stmt|;
name|moveTo
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|m_cap_style
operator|=
name|cap
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
name|skipDuplicatePoints
argument_list|(
operator|&
name|pts
argument_list|,
name|endPts
argument_list|)
expr_stmt|;
name|lineTo
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
name|skipDuplicatePoints
argument_list|(
operator|&
name|pts
argument_list|,
name|endPts
argument_list|)
expr_stmt|;
while|while
condition|(
name|pts
operator|<
name|endPts
condition|)
block|{
name|join
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|lineTo
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
name|skipDuplicatePoints
argument_list|(
operator|&
name|pts
argument_list|,
name|endPts
argument_list|)
expr_stmt|;
block|}
name|endCapOrJoinClosed
argument_list|(
name|startPts
argument_list|,
name|pts
operator|-
literal|2
argument_list|,
name|path
operator|.
name|hasImplicitClose
argument_list|()
argument_list|,
name|endsAtStart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|endsAtStart
init|=
literal|false
decl_stmt|;
name|QPainterPath
operator|::
name|ElementType
name|previousType
init|=
name|QPainterPath
operator|::
name|MoveToElement
decl_stmt|;
specifier|const
name|qreal
modifier|*
name|previousPts
init|=
name|pts
decl_stmt|;
while|while
condition|(
name|pts
operator|<
name|endPts
condition|)
block|{
switch|switch
condition|(
operator|*
name|types
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
if|if
condition|(
name|previousType
operator|!=
name|QPainterPath
operator|::
name|MoveToElement
condition|)
name|endCapOrJoinClosed
argument_list|(
name|startPts
argument_list|,
name|previousPts
argument_list|,
name|path
operator|.
name|hasImplicitClose
argument_list|()
argument_list|,
name|endsAtStart
argument_list|)
expr_stmt|;
name|startPts
operator|=
name|pts
expr_stmt|;
name|skipDuplicatePoints
argument_list|(
operator|&
name|startPts
argument_list|,
name|endPts
argument_list|)
expr_stmt|;
comment|// Skip duplicates to find correct normal.
if|if
condition|(
name|startPts
operator|+
literal|2
operator|>=
name|endPts
condition|)
return|return;
comment|// Nothing to see here...
name|int
name|end
init|=
operator|(
name|endPts
operator|-
name|pts
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|i
init|=
literal|2
decl_stmt|;
comment|// Start looking to ahead since we never have two moveto's in a row
while|while
condition|(
name|i
operator|<
name|end
operator|&&
name|types
index|[
name|i
index|]
operator|!=
name|QPainterPath
operator|::
name|MoveToElement
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|endsAtStart
operator|=
name|float
argument_list|(
name|startPts
index|[
literal|0
index|]
argument_list|)
operator|==
name|float
argument_list|(
name|pts
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|float
argument_list|(
name|startPts
index|[
literal|1
index|]
argument_list|)
operator|==
name|float
argument_list|(
name|pts
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|endsAtStart
operator|||
name|path
operator|.
name|hasImplicitClose
argument_list|()
condition|)
name|m_cap_style
operator|=
name|Qt
operator|::
name|FlatCap
expr_stmt|;
name|moveTo
argument_list|(
name|startPts
argument_list|)
expr_stmt|;
name|m_cap_style
operator|=
name|cap
expr_stmt|;
name|previousType
operator|=
name|QPainterPath
operator|::
name|MoveToElement
expr_stmt|;
name|previousPts
operator|=
name|pts
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
operator|++
name|types
expr_stmt|;
break|break;
block|}
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
if|if
condition|(
name|float
argument_list|(
name|m_cx
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|m_cy
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|previousType
operator|!=
name|QPainterPath
operator|::
name|MoveToElement
condition|)
name|join
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|lineTo
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|previousType
operator|=
name|QPainterPath
operator|::
name|LineToElement
expr_stmt|;
name|previousPts
operator|=
name|pts
expr_stmt|;
block|}
name|pts
operator|+=
literal|2
expr_stmt|;
operator|++
name|types
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
if|if
condition|(
name|float
argument_list|(
name|m_cx
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|m_cy
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|3
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|4
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|pts
index|[
literal|3
index|]
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|float
argument_list|(
name|m_cx
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|)
operator|||
name|float
argument_list|(
name|m_cy
argument_list|)
operator|!=
name|float
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|previousType
operator|!=
name|QPainterPath
operator|::
name|MoveToElement
condition|)
name|join
argument_list|(
name|pts
argument_list|)
expr_stmt|;
block|}
name|cubicTo
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|previousType
operator|=
name|QPainterPath
operator|::
name|CurveToElement
expr_stmt|;
name|previousPts
operator|=
name|pts
operator|+
literal|4
expr_stmt|;
block|}
name|pts
operator|+=
literal|6
expr_stmt|;
name|types
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|previousType
operator|!=
name|QPainterPath
operator|::
name|MoveToElement
condition|)
name|endCapOrJoinClosed
argument_list|(
name|startPts
argument_list|,
name|previousPts
argument_list|,
name|path
operator|.
name|hasImplicitClose
argument_list|()
argument_list|,
name|endsAtStart
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|moveTo
name|void
name|QTriangulatingStroker
operator|::
name|moveTo
parameter_list|(
specifier|const
name|qreal
modifier|*
name|pts
parameter_list|)
block|{
name|m_cx
operator|=
name|pts
index|[
literal|0
index|]
expr_stmt|;
name|m_cy
operator|=
name|pts
index|[
literal|1
index|]
expr_stmt|;
name|float
name|x2
init|=
name|pts
index|[
literal|2
index|]
decl_stmt|;
name|float
name|y2
init|=
name|pts
index|[
literal|3
index|]
decl_stmt|;
name|normalVector
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|m_nvx
argument_list|,
operator|&
name|m_nvy
argument_list|)
expr_stmt|;
comment|// To acheive jumps we insert zero-area tringles. This is done by
comment|// adding two identical points in both the end of previous strip
comment|// and beginning of next strip
name|bool
name|invisibleJump
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|m_cap_style
condition|)
block|{
case|case
name|Qt
operator|::
name|FlatCap
case|:
if|if
condition|(
name|invisibleJump
condition|)
block|{
name|m_vertices
operator|.
name|add
argument_list|(
name|m_cx
operator|+
name|m_nvx
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|m_cy
operator|+
name|m_nvy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|SquareCap
case|:
block|{
name|float
name|sx
init|=
name|m_cx
operator|-
name|m_nvy
decl_stmt|;
name|float
name|sy
init|=
name|m_cy
operator|+
name|m_nvx
decl_stmt|;
if|if
condition|(
name|invisibleJump
condition|)
block|{
name|m_vertices
operator|.
name|add
argument_list|(
name|sx
operator|+
name|m_nvx
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|sy
operator|+
name|m_nvy
argument_list|)
expr_stmt|;
block|}
name|emitLineSegment
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|RoundCap
case|:
block|{
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
name|points
decl_stmt|;
name|arcPoints
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|m_cx
operator|+
name|m_nvx
argument_list|,
name|m_cy
operator|+
name|m_nvy
argument_list|,
name|m_cx
operator|-
name|m_nvx
argument_list|,
name|m_cy
operator|-
name|m_nvy
argument_list|,
name|points
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|resize
argument_list|(
name|m_vertices
operator|.
name|size
argument_list|()
operator|+
name|points
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|*
name|int
argument_list|(
name|invisibleJump
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|front
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|points
operator|.
name|size
argument_list|()
operator|/
literal|2
decl_stmt|;
while|while
condition|(
name|front
operator|!=
name|end
condition|)
block|{
name|m_vertices
operator|.
name|at
argument_list|(
operator|--
name|count
argument_list|)
operator|=
name|points
index|[
literal|2
operator|*
name|end
operator|-
literal|1
index|]
expr_stmt|;
name|m_vertices
operator|.
name|at
argument_list|(
operator|--
name|count
argument_list|)
operator|=
name|points
index|[
literal|2
operator|*
name|end
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|end
expr_stmt|;
if|if
condition|(
name|front
operator|==
name|end
condition|)
break|break;
name|m_vertices
operator|.
name|at
argument_list|(
operator|--
name|count
argument_list|)
operator|=
name|points
index|[
literal|2
operator|*
name|front
operator|+
literal|1
index|]
expr_stmt|;
name|m_vertices
operator|.
name|at
argument_list|(
operator|--
name|count
argument_list|)
operator|=
name|points
index|[
literal|2
operator|*
name|front
operator|+
literal|0
index|]
expr_stmt|;
operator|++
name|front
expr_stmt|;
block|}
if|if
condition|(
name|invisibleJump
condition|)
block|{
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|+
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
comment|// ssssh gcc...
block|}
name|emitLineSegment
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cubicTo
name|void
name|QTriangulatingStroker
operator|::
name|cubicTo
parameter_list|(
specifier|const
name|qreal
modifier|*
name|pts
parameter_list|)
block|{
specifier|const
name|QPointF
modifier|*
name|p
init|=
operator|(
specifier|const
name|QPointF
operator|*
operator|)
name|pts
decl_stmt|;
name|QBezier
name|bezier
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|QRectF
name|bounds
init|=
name|bezier
operator|.
name|bounds
argument_list|()
decl_stmt|;
name|float
name|rad
init|=
name|qMax
argument_list|(
name|bounds
operator|.
name|width
argument_list|()
argument_list|,
name|bounds
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|threshold
init|=
name|qMin
argument_list|<
name|float
argument_list|>
argument_list|(
literal|64
argument_list|,
operator|(
name|rad
operator|+
name|m_curvyness_add
operator|)
operator|*
name|m_curvyness_mul
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|4
condition|)
name|threshold
operator|=
literal|4
expr_stmt|;
name|qreal
name|threshold_minus_1
init|=
name|threshold
operator|-
literal|1
decl_stmt|;
name|float
name|vx
decl_stmt|,
name|vy
decl_stmt|;
name|float
name|cx
init|=
name|m_cx
decl_stmt|,
name|cy
init|=
name|m_cy
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|threshold
condition|;
operator|++
name|i
control|)
block|{
name|qreal
name|t
init|=
name|qreal
argument_list|(
name|i
argument_list|)
operator|/
name|threshold_minus_1
decl_stmt|;
name|QPointF
name|p
init|=
name|bezier
operator|.
name|pointAt
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
name|normalVector
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
expr_stmt|;
name|emitLineSegment
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|vx
argument_list|,
name|vy
argument_list|)
expr_stmt|;
name|cx
operator|=
name|x
expr_stmt|;
name|cy
operator|=
name|y
expr_stmt|;
block|}
name|m_cx
operator|=
name|cx
expr_stmt|;
name|m_cy
operator|=
name|cy
expr_stmt|;
name|m_nvx
operator|=
name|vx
expr_stmt|;
name|m_nvy
operator|=
name|vy
expr_stmt|;
block|}
end_function
begin_function
DECL|function|join
name|void
name|QTriangulatingStroker
operator|::
name|join
parameter_list|(
specifier|const
name|qreal
modifier|*
name|pts
parameter_list|)
block|{
comment|// Creates a join to the next segment (m_cx, m_cy) -> (pts[0], pts[1])
name|normalVector
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
operator|&
name|m_nvx
argument_list|,
operator|&
name|m_nvy
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m_join_style
condition|)
block|{
case|case
name|Qt
operator|::
name|BevelJoin
case|:
break|break;
case|case
name|Qt
operator|::
name|SvgMiterJoin
case|:
case|case
name|Qt
operator|::
name|MiterJoin
case|:
block|{
comment|// Find out on which side the join should be.
name|int
name|count
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
name|float
name|prevNvx
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
operator|-
name|m_cx
decl_stmt|;
name|float
name|prevNvy
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
operator|-
name|m_cy
decl_stmt|;
name|float
name|xprod
init|=
name|prevNvx
operator|*
name|m_nvy
operator|-
name|prevNvy
operator|*
name|m_nvx
decl_stmt|;
name|float
name|px
decl_stmt|,
name|py
decl_stmt|,
name|qx
decl_stmt|,
name|qy
decl_stmt|;
comment|// If the segments are parallel, use bevel join.
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|xprod
argument_list|)
condition|)
break|break;
comment|// Find the corners of the previous and next segment to join.
if|if
condition|(
name|xprod
operator|<
literal|0
condition|)
block|{
name|px
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
expr_stmt|;
name|py
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|qx
operator|=
name|m_cx
operator|-
name|m_nvx
expr_stmt|;
name|qy
operator|=
name|m_cy
operator|-
name|m_nvy
expr_stmt|;
block|}
else|else
block|{
name|px
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|4
argument_list|)
expr_stmt|;
name|py
operator|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|3
argument_list|)
expr_stmt|;
name|qx
operator|=
name|m_cx
operator|+
name|m_nvx
expr_stmt|;
name|qy
operator|=
name|m_cy
operator|+
name|m_nvy
expr_stmt|;
block|}
comment|// Find intersection point.
name|float
name|pu
init|=
name|px
operator|*
name|prevNvx
operator|+
name|py
operator|*
name|prevNvy
decl_stmt|;
name|float
name|qv
init|=
name|qx
operator|*
name|m_nvx
operator|+
name|qy
operator|*
name|m_nvy
decl_stmt|;
name|float
name|ix
init|=
operator|(
name|m_nvy
operator|*
name|pu
operator|-
name|prevNvy
operator|*
name|qv
operator|)
operator|/
name|xprod
decl_stmt|;
name|float
name|iy
init|=
operator|(
name|prevNvx
operator|*
name|qv
operator|-
name|m_nvx
operator|*
name|pu
operator|)
operator|/
name|xprod
decl_stmt|;
comment|// Check that the distance to the intersection point is less than the miter limit.
if|if
condition|(
operator|(
name|ix
operator|-
name|px
operator|)
operator|*
operator|(
name|ix
operator|-
name|px
operator|)
operator|+
operator|(
name|iy
operator|-
name|py
operator|)
operator|*
operator|(
name|iy
operator|-
name|py
operator|)
operator|<=
name|m_miter_limit
operator|*
name|m_miter_limit
condition|)
block|{
name|m_vertices
operator|.
name|add
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|iy
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|iy
argument_list|)
expr_stmt|;
block|}
comment|// else
comment|// Do a plain bevel join if the miter limit is exceeded or if
comment|// the lines are parallel. This is not what the raster
comment|// engine's stroker does, but it is both faster and similar to
comment|// what some other graphics API's do.
break|break;
block|}
case|case
name|Qt
operator|::
name|RoundJoin
case|:
block|{
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
name|points
decl_stmt|;
name|int
name|count
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
name|float
name|prevNvx
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
operator|-
name|m_cx
decl_stmt|;
name|float
name|prevNvy
init|=
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
operator|-
name|m_cy
decl_stmt|;
if|if
condition|(
name|m_nvx
operator|*
name|prevNvy
operator|-
name|m_nvy
operator|*
name|prevNvx
operator|<
literal|0
condition|)
block|{
name|arcPoints
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|,
operator|-
name|prevNvx
argument_list|,
operator|-
name|prevNvy
argument_list|,
name|points
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|points
operator|.
name|size
argument_list|()
operator|/
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|emitLineSegment
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|points
index|[
literal|2
operator|*
name|i
operator|-
literal|2
index|]
argument_list|,
name|points
index|[
literal|2
operator|*
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arcPoints
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
name|prevNvx
argument_list|,
operator|-
name|prevNvy
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|,
name|points
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
operator|/
literal|2
condition|;
operator|++
name|i
control|)
name|emitLineSegment
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|points
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
name|points
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
comment|// gcc warn--
block|}
name|emitLineSegment
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endCap
name|void
name|QTriangulatingStroker
operator|::
name|endCap
parameter_list|(
specifier|const
name|qreal
modifier|*
parameter_list|)
block|{
switch|switch
condition|(
name|m_cap_style
condition|)
block|{
case|case
name|Qt
operator|::
name|FlatCap
case|:
break|break;
case|case
name|Qt
operator|::
name|SquareCap
case|:
name|emitLineSegment
argument_list|(
name|m_cx
operator|+
name|m_nvy
argument_list|,
name|m_cy
operator|-
name|m_nvx
argument_list|,
name|m_nvx
argument_list|,
name|m_nvy
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RoundCap
case|:
block|{
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
name|points
decl_stmt|;
name|int
name|count
init|=
name|m_vertices
operator|.
name|size
argument_list|()
decl_stmt|;
name|arcPoints
argument_list|(
name|m_cx
argument_list|,
name|m_cy
argument_list|,
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|2
argument_list|)
argument_list|,
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|1
argument_list|)
argument_list|,
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|4
argument_list|)
argument_list|,
name|m_vertices
operator|.
name|at
argument_list|(
name|count
operator|-
literal|3
argument_list|)
argument_list|,
name|points
argument_list|)
expr_stmt|;
name|int
name|front
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|points
operator|.
name|size
argument_list|()
operator|/
literal|2
decl_stmt|;
while|while
condition|(
name|front
operator|!=
name|end
condition|)
block|{
name|m_vertices
operator|.
name|add
argument_list|(
name|points
index|[
literal|2
operator|*
name|end
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|points
index|[
literal|2
operator|*
name|end
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|--
name|end
expr_stmt|;
if|if
condition|(
name|front
operator|==
name|end
condition|)
break|break;
name|m_vertices
operator|.
name|add
argument_list|(
name|points
index|[
literal|2
operator|*
name|front
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
name|m_vertices
operator|.
name|add
argument_list|(
name|points
index|[
literal|2
operator|*
name|front
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|front
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
comment|// to shut gcc up...
block|}
block|}
end_function
begin_function
DECL|function|arcPoints
name|void
name|QTriangulatingStroker
operator|::
name|arcPoints
parameter_list|(
name|float
name|cx
parameter_list|,
name|float
name|cy
parameter_list|,
name|float
name|fromX
parameter_list|,
name|float
name|fromY
parameter_list|,
name|float
name|toX
parameter_list|,
name|float
name|toY
parameter_list|,
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
modifier|&
name|points
parameter_list|)
block|{
name|float
name|dx1
init|=
name|fromX
operator|-
name|cx
decl_stmt|;
name|float
name|dy1
init|=
name|fromY
operator|-
name|cy
decl_stmt|;
name|float
name|dx2
init|=
name|toX
operator|-
name|cx
decl_stmt|;
name|float
name|dy2
init|=
name|toY
operator|-
name|cy
decl_stmt|;
comment|// while more than 180 degrees left:
while|while
condition|(
name|dx1
operator|*
name|dy2
operator|-
name|dx2
operator|*
name|dy1
operator|<
literal|0
condition|)
block|{
name|float
name|tmpx
init|=
name|dx1
operator|*
name|m_cos_theta
operator|-
name|dy1
operator|*
name|m_sin_theta
decl_stmt|;
name|float
name|tmpy
init|=
name|dx1
operator|*
name|m_sin_theta
operator|+
name|dy1
operator|*
name|m_cos_theta
decl_stmt|;
name|dx1
operator|=
name|tmpx
expr_stmt|;
name|dy1
operator|=
name|tmpy
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cx
operator|+
name|dx1
argument_list|)
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cy
operator|+
name|dy1
argument_list|)
expr_stmt|;
block|}
comment|// while more than 90 degrees left:
while|while
condition|(
name|dx1
operator|*
name|dx2
operator|+
name|dy1
operator|*
name|dy2
operator|<
literal|0
condition|)
block|{
name|float
name|tmpx
init|=
name|dx1
operator|*
name|m_cos_theta
operator|-
name|dy1
operator|*
name|m_sin_theta
decl_stmt|;
name|float
name|tmpy
init|=
name|dx1
operator|*
name|m_sin_theta
operator|+
name|dy1
operator|*
name|m_cos_theta
decl_stmt|;
name|dx1
operator|=
name|tmpx
expr_stmt|;
name|dy1
operator|=
name|tmpy
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cx
operator|+
name|dx1
argument_list|)
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cy
operator|+
name|dy1
argument_list|)
expr_stmt|;
block|}
comment|// while more than 0 degrees left:
while|while
condition|(
name|dx1
operator|*
name|dy2
operator|-
name|dx2
operator|*
name|dy1
operator|>
literal|0
condition|)
block|{
name|float
name|tmpx
init|=
name|dx1
operator|*
name|m_cos_theta
operator|-
name|dy1
operator|*
name|m_sin_theta
decl_stmt|;
name|float
name|tmpy
init|=
name|dx1
operator|*
name|m_sin_theta
operator|+
name|dy1
operator|*
name|m_cos_theta
decl_stmt|;
name|dx1
operator|=
name|tmpx
expr_stmt|;
name|dy1
operator|=
name|tmpy
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cx
operator|+
name|dx1
argument_list|)
expr_stmt|;
name|points
operator|.
name|append
argument_list|(
name|cy
operator|+
name|dy1
argument_list|)
expr_stmt|;
block|}
comment|// remove last point which was rotated beyond [toX, toY].
if|if
condition|(
operator|!
name|points
operator|.
name|isEmpty
argument_list|()
condition|)
name|points
operator|.
name|resize
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qdashprocessor_moveTo
specifier|static
name|void
name|qdashprocessor_moveTo
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QDashedStrokeProcessor
operator|*
operator|)
name|data
operator|)
operator|->
name|addElement
argument_list|(
name|QPainterPath
operator|::
name|MoveToElement
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qdashprocessor_lineTo
specifier|static
name|void
name|qdashprocessor_lineTo
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QDashedStrokeProcessor
operator|*
operator|)
name|data
operator|)
operator|->
name|addElement
argument_list|(
name|QPainterPath
operator|::
name|LineToElement
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qdashprocessor_cubicTo
specifier|static
name|void
name|qdashprocessor_cubicTo
parameter_list|(
name|qreal
parameter_list|,
name|qreal
parameter_list|,
name|qreal
parameter_list|,
name|qreal
parameter_list|,
name|qreal
parameter_list|,
name|qreal
parameter_list|,
name|void
modifier|*
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// The dasher should not produce curves...
block|}
end_function
begin_constructor
DECL|function|QDashedStrokeProcessor
name|QDashedStrokeProcessor
operator|::
name|QDashedStrokeProcessor
parameter_list|()
member_init_list|:
name|m_points
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_types
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_dash_stroker
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_inv_scale
argument_list|(
literal|1
argument_list|)
block|{
name|m_dash_stroker
operator|.
name|setMoveToHook
argument_list|(
name|qdashprocessor_moveTo
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setLineToHook
argument_list|(
name|qdashprocessor_lineTo
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setCubicToHook
argument_list|(
name|qdashprocessor_cubicTo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|process
name|void
name|QDashedStrokeProcessor
operator|::
name|process
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|clip
parameter_list|,
name|QPainter
operator|::
name|RenderHints
name|hints
parameter_list|)
block|{
specifier|const
name|qreal
modifier|*
name|pts
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|ElementType
modifier|*
name|types
init|=
name|path
operator|.
name|elements
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
name|bool
name|cosmetic
init|=
name|qt_pen_is_cosmetic
argument_list|(
name|pen
argument_list|,
name|hints
argument_list|)
decl_stmt|;
name|m_points
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_types
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_points
operator|.
name|reserve
argument_list|(
name|path
operator|.
name|elementCount
argument_list|()
argument_list|)
expr_stmt|;
name|m_types
operator|.
name|reserve
argument_list|(
name|path
operator|.
name|elementCount
argument_list|()
argument_list|)
expr_stmt|;
name|qreal
name|width
init|=
name|qpen_widthf
argument_list|(
name|pen
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
literal|1
expr_stmt|;
name|m_dash_stroker
operator|.
name|setDashPattern
argument_list|(
name|pen
operator|.
name|dashPattern
argument_list|()
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setStrokeWidth
argument_list|(
name|cosmetic
condition|?
name|width
operator|*
name|m_inv_scale
else|:
name|width
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setDashOffset
argument_list|(
name|pen
operator|.
name|dashOffset
argument_list|()
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setMiterLimit
argument_list|(
name|pen
operator|.
name|miterLimit
argument_list|()
argument_list|)
expr_stmt|;
name|m_dash_stroker
operator|.
name|setClipRect
argument_list|(
name|clip
argument_list|)
expr_stmt|;
name|float
name|curvynessAdd
decl_stmt|,
name|curvynessMul
decl_stmt|;
comment|// simplify pens that are thin in device size (2px wide or less)
if|if
condition|(
name|width
operator|<
literal|2.5
operator|&&
operator|(
name|cosmetic
operator|||
name|m_inv_scale
operator|==
literal|1
operator|)
condition|)
block|{
name|curvynessAdd
operator|=
literal|0.5
expr_stmt|;
name|curvynessMul
operator|=
name|CURVE_FLATNESS
operator|/
name|m_inv_scale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cosmetic
condition|)
block|{
name|curvynessAdd
operator|=
name|width
operator|/
literal|2
expr_stmt|;
name|curvynessMul
operator|=
name|CURVE_FLATNESS
expr_stmt|;
block|}
else|else
block|{
name|curvynessAdd
operator|=
name|width
operator|*
name|m_inv_scale
expr_stmt|;
name|curvynessMul
operator|=
name|CURVE_FLATNESS
operator|/
name|m_inv_scale
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|2
condition|)
return|return;
specifier|const
name|qreal
modifier|*
name|endPts
init|=
name|pts
operator|+
operator|(
name|count
operator|<<
literal|1
operator|)
decl_stmt|;
name|m_dash_stroker
operator|.
name|begin
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types
condition|)
block|{
name|m_dash_stroker
operator|.
name|moveTo
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|pts
operator|<
name|endPts
condition|)
block|{
name|m_dash_stroker
operator|.
name|lineTo
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|pts
operator|<
name|endPts
condition|)
block|{
switch|switch
condition|(
operator|*
name|types
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
name|m_dash_stroker
operator|.
name|moveTo
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
operator|++
name|types
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|m_dash_stroker
operator|.
name|lineTo
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pts
operator|+=
literal|2
expr_stmt|;
operator|++
name|types
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|QBezier
name|b
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
operator|*
operator|(
operator|(
operator|(
specifier|const
name|QPointF
operator|*
operator|)
name|pts
operator|)
operator|-
literal|1
operator|)
argument_list|,
operator|*
operator|(
operator|(
operator|(
specifier|const
name|QPointF
operator|*
operator|)
name|pts
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
operator|(
specifier|const
name|QPointF
operator|*
operator|)
name|pts
operator|)
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
operator|(
operator|(
specifier|const
name|QPointF
operator|*
operator|)
name|pts
operator|)
operator|+
literal|2
operator|)
argument_list|)
decl_stmt|;
name|QRectF
name|bounds
init|=
name|b
operator|.
name|bounds
argument_list|()
decl_stmt|;
name|float
name|rad
init|=
name|qMax
argument_list|(
name|bounds
operator|.
name|width
argument_list|()
argument_list|,
name|bounds
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|threshold
init|=
name|qMin
argument_list|<
name|float
argument_list|>
argument_list|(
literal|64
argument_list|,
operator|(
name|rad
operator|+
name|curvynessAdd
operator|)
operator|*
name|curvynessMul
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|4
condition|)
name|threshold
operator|=
literal|4
expr_stmt|;
name|qreal
name|threshold_minus_1
init|=
name|threshold
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threshold
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pt
init|=
name|b
operator|.
name|pointAt
argument_list|(
name|i
operator|/
name|threshold_minus_1
argument_list|)
decl_stmt|;
name|m_dash_stroker
operator|.
name|lineTo
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|,
name|pt
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pts
operator|+=
literal|6
expr_stmt|;
name|types
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
block|}
name|m_dash_stroker
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
