begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qkbdqnx_qws.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qdebug.h"
end_include
begin_include
include|#
directive|include
file|<sys/dcmd_input.h>
end_include
begin_include
include|#
directive|include
file|<photon/keycodes.h>
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QWSQnxKeyboardHandler     \preliminary     \ingroup qws     \since 4.6     \internal      \brief The QWSQnxKeyboardHandler class implements a keyboard driver     for the QNX \c{devi-hid} input manager.      To be able to compile this mouse handler, \l{Qt for Embedded Linux}     must be configured with the \c -qt-kbd-qnx option, see the     \l{Qt for Embedded Linux Character Input} documentation for details.      In order to use this keyboard handler, the \c{devi-hid} input manager     must be set up and run with the resource manager interface (option \c{-r}).     Also, Photon must not be running.      Example invocation from command line: \c{/usr/photon/bin/devi-hid -Pr kbd mouse}     Note that after running \c{devi-hid}, you will not be able to use the local     shell anymore. It is suggested to run the command in a shell scrip, that launches     a Qt application after invocation of \c{devi-hid}.      To make \l{Qt for Embedded Linux} explicitly choose the qnx keyboard     handler, set the QWS_KEYBOARD environment variable to \c{qnx}. By default,     the first keyboard device (\c{/dev/devi/keyboard0}) is used. To override, pass a device     name as the first and only parameter, for example     \c{QWS_KEYBOARD=qnx:/dev/devi/keyboard1; export QWS_KEYBOARD}.      \sa {Qt for Embedded Linux Character Input}, {Qt for Embedded Linux} */
comment|/*!     Constructs a keyboard handler for the specified \a device, defaulting to     \c{/dev/devi/keyboard0}.      Note that you should never instanciate this class, instead let QKbdDriverFactory     handle the keyboard handlers.      \sa QKbdDriverFactory  */
DECL|function|QWSQnxKeyboardHandler
name|QWSQnxKeyboardHandler
operator|::
name|QWSQnxKeyboardHandler
parameter_list|(
specifier|const
name|QString
modifier|&
name|device
parameter_list|)
block|{
comment|// open the keyboard device
name|keyboardFD
operator|=
name|QT_OPEN
argument_list|(
name|device
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"/dev/devi/keyboard0"
else|:
name|device
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|QT_OPEN_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyboardFD
operator|==
operator|-
literal|1
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|errno
argument_list|,
literal|"QWSQnxKeyboardHandler: Unable to open device"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// create a socket notifier so we'll wake up whenever keyboard input is detected.
name|QSocketNotifier
modifier|*
name|notifier
init|=
operator|new
name|QSocketNotifier
argument_list|(
name|keyboardFD
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|connect
argument_list|(
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"QWSQnxKeyboardHandler: connected."
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys this keyboard handler and closes the connection to the keyboard device.  */
end_comment
begin_destructor
DECL|function|~QWSQnxKeyboardHandler
name|QWSQnxKeyboardHandler
operator|::
name|~
name|QWSQnxKeyboardHandler
parameter_list|()
block|{
name|QT_CLOSE
argument_list|(
name|keyboardFD
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \internal     Translates the QNX keyboard events to Qt keyboard events  */
end_comment
begin_function
DECL|function|socketActivated
name|void
name|QWSQnxKeyboardHandler
operator|::
name|socketActivated
parameter_list|()
block|{
name|_keyboard_packet
name|packet
decl_stmt|;
comment|// read one keyboard event
name|int
name|bytesRead
init|=
name|QT_READ
argument_list|(
name|keyboardFD
argument_list|,
operator|&
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|_keyboard_packet
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|==
operator|-
literal|1
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|errno
argument_list|,
literal|"QWSQnxKeyboardHandler::socketActivated(): Unable to read data."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// the bytes read must be the size of a keyboard packet
name|Q_ASSERT
argument_list|(
name|bytesRead
operator|==
sizeof|sizeof
argument_list|(
name|_keyboard_packet
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|qDebug()<< "keyboard got scancode"<< hex<< packet.data.modifiers<< packet.data.flags<< packet.data.key_cap<< packet.data.key_sym<< packet.data.key_scan;
endif|#
directive|endif
comment|// QNX is nice enough to translate the raw keyboard data into a QNX data structure
comment|// Now we just have to translate it into a format Qt understands.
comment|// figure out whether it's a press
name|bool
name|isPress
init|=
name|packet
operator|.
name|data
operator|.
name|key_cap
operator|&
name|KEY_DOWN
decl_stmt|;
comment|// figure out whether the key is still pressed and the key event is repeated
name|bool
name|isRepeat
init|=
name|packet
operator|.
name|data
operator|.
name|key_cap
operator|&
name|KEY_REPEAT
decl_stmt|;
name|Qt
operator|::
name|Key
name|key
init|=
name|Qt
operator|::
name|Key_unknown
decl_stmt|;
name|int
name|unicode
init|=
literal|0xffff
decl_stmt|;
comment|// TODO - this switch is not complete!
switch|switch
condition|(
name|packet
operator|.
name|data
operator|.
name|key_scan
condition|)
block|{
case|case
name|KEYCODE_SPACE
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Space
expr_stmt|;
name|unicode
operator|=
literal|0x20
expr_stmt|;
break|break;
case|case
name|KEYCODE_F1
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F1
expr_stmt|;
break|break;
case|case
name|KEYCODE_F2
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F2
expr_stmt|;
break|break;
case|case
name|KEYCODE_F3
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F3
expr_stmt|;
break|break;
case|case
name|KEYCODE_F4
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F4
expr_stmt|;
break|break;
case|case
name|KEYCODE_F5
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F5
expr_stmt|;
break|break;
case|case
name|KEYCODE_F6
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F6
expr_stmt|;
break|break;
case|case
name|KEYCODE_F7
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F7
expr_stmt|;
break|break;
case|case
name|KEYCODE_F8
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F8
expr_stmt|;
break|break;
case|case
name|KEYCODE_F9
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F9
expr_stmt|;
break|break;
case|case
name|KEYCODE_F10
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F10
expr_stmt|;
break|break;
case|case
name|KEYCODE_F11
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F11
expr_stmt|;
break|break;
case|case
name|KEYCODE_F12
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_F12
expr_stmt|;
break|break;
case|case
name|KEYCODE_BACKSPACE
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Backspace
expr_stmt|;
break|break;
case|case
name|KEYCODE_TAB
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Tab
expr_stmt|;
break|break;
case|case
name|KEYCODE_RETURN
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Return
expr_stmt|;
break|break;
case|case
name|KEYCODE_KP_ENTER
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Enter
expr_stmt|;
break|break;
case|case
name|KEYCODE_UP
case|:
case|case
name|KEYCODE_KP_UP
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Up
expr_stmt|;
break|break;
case|case
name|KEYCODE_DOWN
case|:
case|case
name|KEYCODE_KP_DOWN
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Down
expr_stmt|;
break|break;
case|case
name|KEYCODE_LEFT
case|:
case|case
name|KEYCODE_KP_LEFT
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Left
expr_stmt|;
break|break;
case|case
name|KEYCODE_RIGHT
case|:
case|case
name|KEYCODE_KP_RIGHT
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Right
expr_stmt|;
break|break;
case|case
name|KEYCODE_HOME
case|:
case|case
name|KEYCODE_KP_HOME
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Home
expr_stmt|;
break|break;
case|case
name|KEYCODE_END
case|:
case|case
name|KEYCODE_KP_END
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_End
expr_stmt|;
break|break;
case|case
name|KEYCODE_PG_UP
case|:
case|case
name|KEYCODE_KP_PG_UP
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_PageUp
expr_stmt|;
break|break;
case|case
name|KEYCODE_PG_DOWN
case|:
case|case
name|KEYCODE_KP_PG_DOWN
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_PageDown
expr_stmt|;
break|break;
case|case
name|KEYCODE_INSERT
case|:
case|case
name|KEYCODE_KP_INSERT
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Insert
expr_stmt|;
break|break;
case|case
name|KEYCODE_DELETE
case|:
case|case
name|KEYCODE_KP_DELETE
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Delete
expr_stmt|;
break|break;
case|case
name|KEYCODE_ESCAPE
case|:
name|key
operator|=
name|Qt
operator|::
name|Key_Escape
expr_stmt|;
break|break;
default|default:
comment|// none of the above, try the key_scan directly
name|unicode
operator|=
name|packet
operator|.
name|data
operator|.
name|key_scan
expr_stmt|;
break|break;
block|}
comment|// figure out the modifiers that are currently pressed
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
if|if
condition|(
name|packet
operator|.
name|data
operator|.
name|flags
operator|&
name|KEYMOD_SHIFT
condition|)
name|modifiers
operator||=
name|Qt
operator|::
name|ShiftModifier
expr_stmt|;
if|if
condition|(
name|packet
operator|.
name|data
operator|.
name|flags
operator|&
name|KEYMOD_CTRL
condition|)
name|modifiers
operator||=
name|Qt
operator|::
name|ControlModifier
expr_stmt|;
if|if
condition|(
name|packet
operator|.
name|data
operator|.
name|flags
operator|&
name|KEYMOD_ALT
condition|)
name|modifiers
operator||=
name|Qt
operator|::
name|AltModifier
expr_stmt|;
comment|// if the unicode value is not ascii, we ignore it.
comment|// TODO - do a complete mapping between all QNX scan codes and Qt codes
if|if
condition|(
name|unicode
operator|!=
literal|0xffff
operator|&&
operator|!
name|isascii
argument_list|(
name|unicode
argument_list|)
condition|)
return|return;
comment|// unprintable character
comment|// call processKeyEvent. This is where all the magic happens to insert a
comment|// key event into Qt's event loop.
comment|// Note that for repeated key events, isPress must be true
comment|// (on QNX, isPress is not set when the key event is repeated).
name|processKeyEvent
argument_list|(
name|unicode
argument_list|,
name|key
argument_list|,
name|modifiers
argument_list|,
name|isPress
operator|||
name|isRepeat
argument_list|,
name|isRepeat
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
