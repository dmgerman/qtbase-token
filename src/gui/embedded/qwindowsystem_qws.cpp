begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwsevent_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwscommand_qws_p.h"
end_include
begin_include
include|#
directive|include
file|"qtransportauth_qws_p.h"
end_include
begin_include
include|#
directive|include
file|"qwsutils_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwscursor_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwsdisplay_qws.h"
end_include
begin_include
include|#
directive|include
file|"qmouse_qws.h"
end_include
begin_include
include|#
directive|include
file|"qcopchannel_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwssocket_qws.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"private/qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qcursor.h"
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|"qscreen_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwindowdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qlock_p.h"
end_include
begin_include
include|#
directive|include
file|"qwslock_p.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|"qpen.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qinputcontext.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qkbddriverfactory_qws.h"
end_include
begin_include
include|#
directive|include
file|"qmousedriverfactory_qws.h"
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<private/qwindowsurface_qws_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_qpf_p.h>
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_p.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_include
include|#
directive|include
file|<sys/param.h>
end_include
begin_include
include|#
directive|include
file|<sys/mount.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SOUND
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_OLD_QWS_SOUND
end_ifdef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include
begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"qsoundqss_qws.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define QWS_DEBUG_FONTCLEANUP
end_comment
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qwsServer
name|QWSServer
name|Q_GUI_EXPORT
modifier|*
name|qwsServer
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qwsServerPrivate
specifier|static
name|QWSServerPrivate
modifier|*
name|qwsServerPrivate
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MOUSE
define|#
directive|define
name|MOUSE
value|0
end_define
begin_define
DECL|macro|KEY
define|#
directive|define
name|KEY
value|1
end_define
begin_comment
comment|//#define EVENT_BLOCK_DEBUG
end_comment
begin_destructor
DECL|function|~QWSScreenSaver
name|QWSScreenSaver
operator|::
name|~
name|QWSScreenSaver
parameter_list|()
block|{ }
end_destructor
begin_decl_stmt
specifier|extern
name|QByteArray
name|qws_display_spec
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
name|void
name|qt_init_display
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qapplication_qws.cpp
end_comment
begin_function_decl
specifier|extern
name|QString
name|qws_qtePipeFilename
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|qt_client_enqueue
parameter_list|(
specifier|const
name|QWSEvent
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//qapplication_qws.cpp
end_comment
begin_function_decl
specifier|extern
name|QList
argument_list|<
name|QWSCommand
modifier|*
argument_list|>
modifier|*
name|qt_get_server_queue
parameter_list|()
function_decl|;
end_function_decl
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QString
argument_list|,
argument|defaultMouse
argument_list|,
argument|(QLatin1String(
literal|"Auto"
argument|))
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QString
argument_list|,
argument|defaultKeyboard
argument_list|,
argument|(QLatin1String(
literal|"TTY"
argument|))
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|FontCleanupInterval
specifier|static
specifier|const
name|int
name|FontCleanupInterval
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qws_keyModifiers
specifier|static
name|int
name|qws_keyModifiers
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keyboardGrabber
specifier|static
name|QWSWindow
modifier|*
name|keyboardGrabber
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keyboardGrabbing
specifier|static
name|bool
name|keyboardGrabbing
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_object_id
specifier|static
name|int
name|get_object_id
parameter_list|(
name|int
name|count
init|=
literal|1
parameter_list|)
block|{
specifier|static
name|int
name|next
init|=
literal|1000
decl_stmt|;
name|int
name|n
init|=
name|next
decl_stmt|;
name|next
operator|+=
name|count
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
end_ifndef
begin_decl_stmt
DECL|variable|current_IM
specifier|static
name|QWSInputMethod
modifier|*
name|current_IM
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_IM_composing_win
specifier|static
name|QWSWindow
modifier|*
name|current_IM_composing_win
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_IM_winId
specifier|static
name|int
name|current_IM_winId
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_reject_strokeIM
specifier|static
name|bool
name|force_reject_strokeIM
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|cleanupFontsDir
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//#define QWS_REGION_DEBUG
end_comment
begin_comment
comment|/*!     \class QWSScreenSaver     \ingroup qws      \brief The QWSScreenSaver class is a base class for screensavers     in Qt for Embedded Linux.      When running \l{Qt for Embedded Linux} applications, it is the server     application that installs and controls the screensaver.     \l{Qt for Embedded Linux} supports multilevel screen saving; i.e., it is possible to     specify several different levels of screen responsiveness. For     example, you can choose to first turn off the light before you     fully activate the screensaver.      Note that there exists no default screensaver implementation.      To create a custom screensaver, derive from this class and     reimplement the restore() and save() functions. These functions     are called whenever the screensaver is activated or deactivated,     respectively. Once an instance of your custom screensaver is     created, you can use the QWSServer::setScreenSaver() function to     install it.      \sa QWSServer, QScreen, {Qt for Embedded Linux} */
end_comment
begin_comment
comment|/*!     \fn QWSScreenSaver::~QWSScreenSaver()      Reimplement this function to destroy the screensaver. */
end_comment
begin_comment
comment|/*!     \fn QWSScreenSaver::restore()      Implement this function to deactivate the screensaver, restoring     the previously saved screen.      \sa save(), QWSServer::screenSaverActivate() */
end_comment
begin_comment
comment|/*!     \fn QWSScreenSaver::save(int level)      Implement this function to activate the screensaver, saving the     current screen.      \l{Qt for Embedded Linux} supports multilevel screen saving; i.e., it is     possible to specify several different levels of screen     responsiveness. For example, you can choose to first turn off the     light before you fully activate the screensaver. Use the     QWSServer::setScreenSaverIntervals() to specify the time intervals     between the different levels.      This function should return true if the screensaver successfully     enters the given \a level; otherwise it should return false.      \sa restore(), QWSServer::screenSaverActivate() */
end_comment
begin_class
DECL|class|QWSWindowPrivate
class|class
name|QWSWindowPrivate
block|{
public|public:
name|QWSWindowPrivate
parameter_list|()
constructor_decl|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
DECL|member|directPaintRegion
name|QRegion
name|directPaintRegion
decl_stmt|;
endif|#
directive|endif
DECL|member|allocatedRegion
name|QRegion
name|allocatedRegion
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
DECL|member|embedded
name|QList
argument_list|<
name|QWSWindow
modifier|*
argument_list|>
name|embedded
decl_stmt|;
DECL|member|embedder
name|QWSWindow
modifier|*
name|embedder
decl_stmt|;
endif|#
directive|endif
DECL|member|state
name|QWSWindow
operator|::
name|State
name|state
decl_stmt|;
DECL|member|windowFlags
name|Qt
operator|::
name|WindowFlags
name|windowFlags
decl_stmt|;
DECL|member|dirtyOnScreen
name|QRegion
name|dirtyOnScreen
decl_stmt|;
DECL|member|painted
name|bool
name|painted
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWSWindowPrivate
name|QWSWindowPrivate
operator|::
name|QWSWindowPrivate
parameter_list|()
member_init_list|:
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
name|embedder
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QWSWindow
operator|::
name|NoState
argument_list|)
member_init_list|,
endif|#
directive|endif
name|painted
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \class QWSWindow     \ingroup qws      \brief The QWSWindow class encapsulates a top-level window in     Qt for Embedded Linux.      When you run a \l{Qt for Embedded Linux} application, it either runs as a     server or connects to an existing server. As applications add and     remove windows, the server process maintains information about     each window. In \l{Qt for Embedded Linux}, top-level windows are     encapsulated as QWSWindow objects. Note that you should never     construct the QWSWindow class yourself; the current top-level     windows can be retrieved using the QWSServer::clientWindows()     function.      With a window at hand, you can retrieve its caption, name, opacity     and ID using the caption(), name(), opacity() and winId()     functions, respectively. Use the client() function to retrieve a     pointer to the client that owns the window.      Use the isVisible() function to find out if the window is     visible. You can find out if the window is completely obscured by     another window or by the bounds of the screen, using the     isFullyObscured() function. The isOpaque() function returns true     if the window has an alpha channel equal to 255. Finally, the     requestedRegion() function returns the region of the display the     window wants to draw on.      \sa QWSServer, QWSClient, {Qt for Embedded Linux Architecture} */
end_comment
begin_comment
comment|/*!     \fn int QWSWindow::winId() const      Returns the window's ID.      \sa name(), caption() */
end_comment
begin_comment
comment|/*!     \fn const QString&QWSWindow::name() const      Returns the window's name, which is taken from the \l {QWidget::}{objectName()}     at the time of \l {QWidget::}{show()}.      \sa caption(), winId() */
end_comment
begin_comment
comment|/*!     \fn const QString&QWSWindow::caption() const      Returns the window's caption.      \sa name(), winId() */
end_comment
begin_comment
comment|/*!     \fn QWSClient* QWSWindow::client() const      Returns a reference to the QWSClient object that owns this window.      \sa requestedRegion() */
end_comment
begin_comment
comment|/*!     \fn QRegion QWSWindow::requestedRegion() const      Returns the region that the window has requested to draw onto,     including any window decorations.      \sa client() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindow::isVisible() const      Returns true if the window is visible; otherwise returns false.      \sa isFullyObscured() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindow::isOpaque() const      Returns true if the window is opaque, i.e., if its alpha channel     equals 255; otherwise returns false.      \sa opacity() */
end_comment
begin_comment
comment|/*!     \fn uint QWSWindow::opacity () const      Returns the window's alpha channel value.      \sa isOpaque() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindow::isPartiallyObscured() const     \internal      Returns true if the window is partially obsured by another window     or by the bounds of the screen; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindow::isFullyObscured() const      Returns true if the window is completely obsured by another window     or by the bounds of the screen; otherwise returns false.      \sa isVisible() */
end_comment
begin_comment
comment|/*!     \fn QWSWindowSurface* QWSWindow::windowSurface() const     \internal */
end_comment
begin_constructor
DECL|function|QWSWindow
name|QWSWindow
operator|::
name|QWSWindow
parameter_list|(
name|int
name|i
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
member_init_list|:
name|id
argument_list|(
name|i
argument_list|)
member_init_list|,
name|modified
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|onTop
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|c
argument_list|(
name|client
argument_list|)
member_init_list|,
name|last_focus_time
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_opacity
argument_list|(
literal|255
argument_list|)
member_init_list|,
name|opaque
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|d
argument_list|(
operator|new
name|QWSWindowPrivate
argument_list|)
block|{
name|surface
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \enum QWSWindow::State      This enum describes the state of a window. Most of the     transitional states are set just before a call to     QScreen::exposeRegion() and reset immediately afterwards.      \value NoState Initial state before the window is properly initialized.     \value Hidden The window is not visible.     \value Showing The window is being shown.     \value Visible The window is visible, and not in a transition.     \value Hiding The window is being hidden.     \value Raising The windoe is being raised.     \value Lowering The window is being raised.     \value Moving The window is being moved.     \value ChangingGeometry The window's geometry is being changed.     \value Destroyed  The window is destroyed.      \sa state(), QScreen::exposeRegion() */
end_comment
begin_comment
comment|/*!   Returns the current state of the window.    \since 4.3 */
end_comment
begin_function
DECL|function|state
name|QWSWindow
operator|::
name|State
name|QWSWindow
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the window flags of the window. This value is only available   after the first paint event.    \since 4.3 */
end_comment
begin_function
DECL|function|windowFlags
name|Qt
operator|::
name|WindowFlags
name|QWSWindow
operator|::
name|windowFlags
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|windowFlags
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the region that has been repainted since the previous   QScreen::exposeRegion(), and needs to be copied to the screen.   \since 4.3 */
end_comment
begin_function
DECL|function|dirtyOnScreen
name|QRegion
name|QWSWindow
operator|::
name|dirtyOnScreen
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|dirtyOnScreen
return|;
block|}
end_function
begin_function
DECL|function|createSurface
name|void
name|QWSWindow
operator|::
name|createSurface
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|surface
operator|&&
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
name|c
operator|->
name|removeUnbufferedSurface
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|delete
name|surface
expr_stmt|;
name|surface
operator|=
name|qt_screen
operator|->
name|createSurface
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|surface
operator|->
name|setPermanentState
argument_list|(
name|data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
name|c
operator|->
name|addUnbufferedSurface
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Raises the window above all other windows except "Stay on top" windows. */
end_comment
begin_function
DECL|function|raise
name|void
name|QWSWindow
operator|::
name|raise
parameter_list|()
block|{
name|qwsServerPrivate
operator|->
name|raiseWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|raise
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Lowers the window below other windows. */
end_comment
begin_function
DECL|function|lower
name|void
name|QWSWindow
operator|::
name|lower
parameter_list|()
block|{
name|qwsServerPrivate
operator|->
name|lowerWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|lower
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Shows the window. */
end_comment
begin_function
DECL|function|show
name|void
name|QWSWindow
operator|::
name|show
parameter_list|()
block|{
name|operation
argument_list|(
name|QWSWindowOperationEvent
operator|::
name|Show
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|show
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Hides the window. */
end_comment
begin_function
DECL|function|hide
name|void
name|QWSWindow
operator|::
name|hide
parameter_list|()
block|{
name|operation
argument_list|(
name|QWSWindowOperationEvent
operator|::
name|Hide
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|hide
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Make this the active window (i.e., sets the keyboard focus to this     window). */
end_comment
begin_function
DECL|function|setActiveWindow
name|void
name|QWSWindow
operator|::
name|setActiveWindow
parameter_list|()
block|{
name|qwsServerPrivate
operator|->
name|setFocus
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|setActiveWindow
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setName
name|void
name|QWSWindow
operator|::
name|setName
parameter_list|(
specifier|const
name|QString
modifier|&
name|n
parameter_list|)
block|{
name|rgnName
operator|=
name|n
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Sets the window's caption to \a c. */
end_comment
begin_function
DECL|function|setCaption
name|void
name|QWSWindow
operator|::
name|setCaption
parameter_list|(
specifier|const
name|QString
modifier|&
name|c
parameter_list|)
block|{
name|rgnCaption
operator|=
name|c
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|global_focus_time_counter
specifier|static
name|int
name|global_focus_time_counter
init|=
literal|100
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|focus
name|void
name|QWSWindow
operator|::
name|focus
parameter_list|(
name|bool
name|get
parameter_list|)
block|{
if|if
condition|(
name|get
condition|)
name|last_focus_time
operator|=
name|global_focus_time_counter
operator|++
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|QWSFocusEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|id
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|get_focus
operator|=
name|get
expr_stmt|;
name|c
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|operation
name|void
name|QWSWindow
operator|::
name|operation
parameter_list|(
name|QWSWindowOperationEvent
operator|::
name|Operation
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
return|return;
name|QWSWindowOperationEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|id
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|op
operator|=
name|o
expr_stmt|;
name|c
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Destructor. */
end_comment
begin_destructor
DECL|function|~QWSWindow
name|QWSWindow
operator|::
name|~
name|QWSWindow
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
if|if
condition|(
name|current_IM_composing_win
operator|==
name|this
condition|)
name|current_IM_composing_win
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
name|QWSWindow
modifier|*
name|embedder
init|=
name|d
operator|->
name|embedder
decl_stmt|;
if|if
condition|(
name|embedder
condition|)
block|{
name|embedder
operator|->
name|d
operator|->
name|embedded
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|embedder
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|d
operator|->
name|embedded
operator|.
name|isEmpty
argument_list|()
condition|)
name|stopEmbed
argument_list|(
name|d
operator|->
name|embedded
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|surface
operator|&&
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|d_func
argument_list|()
condition|)
comment|// d_func() will be 0 if client is deleted
name|c
operator|->
name|removeUnbufferedSurface
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
operator|delete
name|surface
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal      Returns the region that the window is allowed to draw onto,     including any window decorations but excluding regions covered by     other windows.      \sa paintedRegion(), requestedRegion() */
end_comment
begin_function
DECL|function|allocatedRegion
name|QRegion
name|QWSWindow
operator|::
name|allocatedRegion
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|allocatedRegion
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
end_ifdef
begin_function
DECL|function|directPaintRegion
name|QRegion
name|QWSWindow
operator|::
name|directPaintRegion
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|directPaintRegion
return|;
block|}
end_function
begin_function
DECL|function|setDirectPaintRegion
specifier|inline
name|void
name|QWSWindow
operator|::
name|setDirectPaintRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|d
operator|->
name|directPaintRegion
operator|=
name|r
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal      Returns the region that the window is known to have drawn into.      \sa allocatedRegion(), requestedRegion() */
end_comment
begin_function
DECL|function|paintedRegion
name|QRegion
name|QWSWindow
operator|::
name|paintedRegion
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|->
name|painted
condition|?
name|d
operator|->
name|allocatedRegion
else|:
name|QRegion
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setAllocatedRegion
specifier|inline
name|void
name|QWSWindow
operator|::
name|setAllocatedRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|d
operator|->
name|allocatedRegion
operator|=
name|region
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
end_ifndef
begin_function
DECL|function|startEmbed
specifier|inline
name|void
name|QWSWindow
operator|::
name|startEmbed
parameter_list|(
name|QWSWindow
modifier|*
name|w
parameter_list|)
block|{
name|d
operator|->
name|embedded
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|d
operator|->
name|embedder
operator|=
name|this
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stopEmbed
specifier|inline
name|void
name|QWSWindow
operator|::
name|stopEmbed
parameter_list|(
name|QWSWindow
modifier|*
name|w
parameter_list|)
block|{
name|w
operator|->
name|d
operator|->
name|embedder
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|client
argument_list|()
operator|->
name|sendEmbedEvent
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|QWSEmbedEvent
operator|::
name|Region
argument_list|,
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|embedded
operator|.
name|removeAll
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWSEMBEDWIDGET
end_comment
begin_comment
comment|/*********************************************************************  *  * Class: QWSClient  *  *********************************************************************/
end_comment
begin_class
DECL|class|QWSClientPrivate
class|class
name|QWSClientPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QWSClient
parameter_list|)
specifier|public
private|:
name|QWSClientPrivate
parameter_list|()
constructor_decl|;
name|~
name|QWSClientPrivate
parameter_list|()
destructor_decl|;
name|void
name|setLockId
parameter_list|(
name|int
name|id
parameter_list|)
function_decl|;
name|void
name|unlockCommunication
parameter_list|()
function_decl|;
private|private:
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
DECL|member|clientLock
name|QWSLock
modifier|*
name|clientLock
decl_stmt|;
DECL|member|shutdown
name|bool
name|shutdown
decl_stmt|;
DECL|member|numUnbufferedSurfaces
name|int
name|numUnbufferedSurfaces
decl_stmt|;
endif|#
directive|endif
DECL|member|usedFonts
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|usedFonts
decl_stmt|;
friend|friend
class_decl|class
name|QWSServerPrivate
class_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWSClientPrivate
name|QWSClientPrivate
operator|::
name|QWSClientPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
name|clientLock
operator|=
literal|0
expr_stmt|;
name|shutdown
operator|=
literal|false
expr_stmt|;
name|numUnbufferedSurfaces
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QWSClientPrivate
name|QWSClientPrivate
operator|::
name|~
name|QWSClientPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
operator|delete
name|clientLock
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|setLockId
name|void
name|QWSClientPrivate
operator|::
name|setLockId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QWS_MULTIPROCESS
name|Q_UNUSED
argument_list|(
name|id
argument_list|)
expr_stmt|;
else|#
directive|else
name|clientLock
operator|=
operator|new
name|QWSLock
argument_list|(
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unlockCommunication
name|void
name|QWSClientPrivate
operator|::
name|unlockCommunication
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|clientLock
condition|)
name|clientLock
operator|->
name|unlock
argument_list|(
name|QWSLock
operator|::
name|Communication
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \class QWSClient     \ingroup qws      \brief The QWSClient class encapsulates a client process in Qt for Embedded Linux.      When you run a \l{Qt for Embedded Linux} application, it either runs as a     server or connects to an existing server. The server and client     processes have different responsibilities: The client process     performs all application specific operations. The server process     is responsible for managing the clients as well as taking care of     the pointer handling, character input, and screen output. In     addition, the server provides functionality to handle input     methods.      As applications add and remove windows, the server process     maintains information about each window. In \l{Qt for Embedded Linux},     top-level windows are encapsulated as QWSWindow objects. A list of     the current windows can be retrieved using the     QWSServer::clientWindows() function, and each window can tell     which client that owns it through its QWSWindow::client()     function.      A QWSClient object has an unique ID that can be retrieved using     its clientId() function. QWSClient also provides the identity()     function which typically returns the name of this client's running     application.      \sa QWSServer, QWSWindow, {Qt for Embedded Linux Architecture} */
end_comment
begin_comment
comment|/*!    \internal */
end_comment
begin_comment
comment|//always use frame buffer
end_comment
begin_constructor
DECL|function|QWSClient
name|QWSClient
operator|::
name|QWSClient
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
name|QWS_SOCK_BASE
modifier|*
name|sock
parameter_list|,
name|int
name|id
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWSClientPrivate
argument_list|,
name|parent
argument_list|)
member_init_list|,
name|command
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cid
argument_list|(
name|id
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QWS_MULTIPROCESS
name|Q_UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|isClosed
operator|=
literal|false
expr_stmt|;
else|#
directive|else
name|csocket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sock
condition|)
block|{
name|socketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
name|isClosed
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|csocket
operator|=
cast|static_cast
argument_list|<
name|QWSSocket
operator|*
argument_list|>
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|//###
name|isClosed
operator|=
literal|false
expr_stmt|;
name|csocket
operator|->
name|flush
argument_list|()
expr_stmt|;
name|socketDescriptor
operator|=
name|csocket
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|csocket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|csocket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeHandler
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|csocket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|errorHandler
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_QWS_MULTIPROCESS
block|}
end_constructor
begin_comment
comment|/*!    \internal */
end_comment
begin_destructor
DECL|function|~QWSClient
name|QWSClient
operator|::
name|~
name|QWSClient
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|cursors
argument_list|)
expr_stmt|;
operator|delete
name|command
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
operator|delete
name|csocket
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_function
DECL|function|removeUnbufferedSurface
name|void
name|QWSClient
operator|::
name|removeUnbufferedSurface
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSClient
argument_list|)
expr_stmt|;
operator|--
name|d
operator|->
name|numUnbufferedSurfaces
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addUnbufferedSurface
name|void
name|QWSClient
operator|::
name|addUnbufferedSurface
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSClient
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|numUnbufferedSurfaces
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_MULTIPROCESS
end_comment
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|setIdentity
name|void
name|QWSClient
operator|::
name|setIdentity
parameter_list|(
specifier|const
name|QString
modifier|&
name|i
parameter_list|)
block|{
name|id
operator|=
name|i
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeHandler
name|void
name|QWSClient
operator|::
name|closeHandler
parameter_list|()
block|{
name|isClosed
operator|=
literal|true
expr_stmt|;
emit|emit
name|connectionClosed
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|errorHandler
name|void
name|QWSClient
operator|::
name|errorHandler
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QWS_SOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"Client %p error %s"
argument_list|,
name|this
argument_list|,
name|csocket
condition|?
name|csocket
operator|->
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
else|:
literal|"(no socket)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isClosed
operator|=
literal|true
expr_stmt|;
comment|//####Do we need to clean out the pipes?
emit|emit
name|connectionClosed
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|socket
name|int
name|QWSClient
operator|::
name|socket
parameter_list|()
specifier|const
block|{
return|return
name|socketDescriptor
return|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendEvent
name|void
name|QWSClient
operator|::
name|sendEvent
parameter_list|(
name|QWSEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|csocket
condition|)
block|{
comment|// qDebug()<< "QWSClient::sendEvent type "<< event->type<< " socket state "<< csocket->state();
if|if
condition|(
call|(
name|QAbstractSocket
operator|::
name|SocketState
call|)
argument_list|(
name|csocket
operator|->
name|state
argument_list|()
argument_list|)
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
name|event
operator|->
name|write
argument_list|(
name|csocket
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|qt_client_enqueue
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendRegionEvent
name|void
name|QWSClient
operator|::
name|sendRegionEvent
parameter_list|(
name|int
name|winid
parameter_list|,
name|QRegion
name|rgn
parameter_list|,
name|int
name|type
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
parameter_list|,
name|int
name|id
endif|#
directive|endif
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
name|Q_D
argument_list|(
name|QWSClient
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clientLock
condition|)
name|d
operator|->
name|clientLock
operator|->
name|lock
argument_list|(
name|QWSLock
operator|::
name|RegionEvent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QWSRegionEvent
name|event
decl_stmt|;
name|event
operator|.
name|setData
argument_list|(
name|winid
argument_list|,
name|rgn
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|event
operator|.
name|simpleData
operator|.
name|id
operator|=
name|id
expr_stmt|;
endif|#
directive|endif
comment|//    qDebug()<< "Sending Region event to"<< winid<< "rgn"<< rgn<< "type"<< type;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
specifier|extern
name|int
name|qt_servershmid
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendConnectedEvent
name|void
name|QWSClient
operator|::
name|sendConnectedEvent
parameter_list|(
specifier|const
name|char
modifier|*
name|display_spec
parameter_list|)
block|{
name|QWSConnectedEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|display_spec
argument_list|)
operator|+
literal|1
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|clientId
operator|=
name|cid
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|servershmid
operator|=
name|qt_servershmid
expr_stmt|;
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|display_spec
decl_stmt|;
name|event
operator|.
name|setData
argument_list|(
name|tmp
argument_list|,
name|event
operator|.
name|simpleData
operator|.
name|len
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendMaxWindowRectEvent
name|void
name|QWSClient
operator|::
name|sendMaxWindowRectEvent
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QWSMaxWindowRectEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|rect
operator|=
name|rect
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
end_ifndef
begin_function
DECL|function|sendPropertyNotifyEvent
name|void
name|QWSClient
operator|::
name|sendPropertyNotifyEvent
parameter_list|(
name|int
name|property
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|QWSPropertyNotifyEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
literal|0
expr_stmt|;
comment|// not used yet
name|event
operator|.
name|simpleData
operator|.
name|property
operator|=
name|property
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendPropertyReplyEvent
name|void
name|QWSClient
operator|::
name|sendPropertyReplyEvent
parameter_list|(
name|int
name|property
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|QWSPropertyReplyEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
literal|0
expr_stmt|;
comment|// not used yet
name|event
operator|.
name|simpleData
operator|.
name|property
operator|=
name|property
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|event
operator|.
name|setData
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_QWS_PROPERTIES
end_comment
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendSelectionClearEvent
name|void
name|QWSClient
operator|::
name|sendSelectionClearEvent
parameter_list|(
name|int
name|windowid
parameter_list|)
block|{
name|QWSSelectionClearEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|windowid
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendSelectionRequestEvent
name|void
name|QWSClient
operator|::
name|sendSelectionRequestEvent
parameter_list|(
name|QWSConvertSelectionCommand
modifier|*
name|cmd
parameter_list|,
name|int
name|windowid
parameter_list|)
block|{
name|QWSSelectionRequestEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|windowid
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|requestor
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|requestor
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|property
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|selection
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|mimeTypes
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|mimeTypes
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
end_ifndef
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|sendEmbedEvent
name|void
name|QWSClient
operator|::
name|sendEmbedEvent
parameter_list|(
name|int
name|windowid
parameter_list|,
name|QWSEmbedEvent
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QWSEmbedEvent
name|event
decl_stmt|;
name|event
operator|.
name|setData
argument_list|(
name|windowid
argument_list|,
name|type
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWSEMBEDWIDGET
end_comment
begin_comment
comment|/*!    \fn void QWSClient::connectionClosed()    \internal */
end_comment
begin_comment
comment|/*!     \fn void QWSClient::readyRead();     \internal */
end_comment
begin_comment
comment|/*!    \fn int QWSClient::clientId () const     Returns an integer uniquely identfying this client. */
end_comment
begin_comment
comment|/*!    \fn QString QWSClient::identity () const     Returns the name of this client's running application. */
end_comment
begin_comment
comment|/*********************************************************************  *  * Class: QWSServer  *  *********************************************************************/
end_comment
begin_comment
comment|/*!     \class QWSServer     \brief The QWSServer class encapsulates a server process in Qt for Embedded Linux.      \ingroup qws      When you run a \l{Qt for Embedded Linux} application, it either runs as a     server or connects to an existing server. The server and client     processes have different responsibilities: The client process     performs all application specific operations. The server process     is responsible for managing the clients as well as taking care of     the pointer handling, character input, and screen output. In     addition, the server provides functionality to handle input     methods.      In \l{Qt for Embedded Linux}, all system generated events are passed to the     server application which then propagates the event to the     appropriate client. See the \l{Qt for Embedded Linux Architecture}     documentation for details.      Note that this class is instantiated by QApplication for     \l{Qt for Embedded Linux} server processes; you should never construct this     class yourself. Use the instance() function to retrieve a pointer     to the server object.      Note that the static functions of the QWSServer class can only be     used in the server process.      \tableofcontents      \section1 Client Administration      As applications add and remove windows, the server process     maintains information about each window. In \l{Qt for Embedded Linux},     top-level windows are encapsulated as QWSWindow objects. Each     window can tell which client that owns it through its     QWSWindow::client() function. Use the clientWindows() function to     retrieve a list of the current top-level windows. Given a     particular position on the display, the window containing it can     be retrieved using the windowAt() function.      QWSServer also provides the windowEvent() signal which is emitted     whenever something happens to a top level window; the WindowEvent     enum describes the various types of events that the signal     recognizes. In addition, the server class provides the     markedText() signal which is emitted whenever some text has been     selected in any of the windows, passing the selection as     parameter.      The QCopChannel class and the QCOP communication protocol enable     transfer of messages between clients. QWSServer provides the     newChannel() and removedChannel() signals that is emitted whenever     a new QCopChannel object is created or destroyed, respectively.      See also: QWSWindow, QWSClient and QCopChannel.       \section1 Mouse Handling      The mouse driver (represented by an instance of the     QWSMouseHandler class) is loaded by the server application when it     starts running, using Qt's \l {How to Create Qt Plugins}{plugin     system}. A mouse driver receives mouse events from the device and     encapsulates each event with an instance of the QWSEvent class     which it then passes to the server.      The openMouse() function opens the mouse devices specified by the     QWS_MOUSE_PROTO environment variable, and the setMouseHandler()     functions sets the primary mouse driver. Alternatively, the static     setDefaultMouse() function provides means of specifying the mouse     driver to use if the QWS_MOUSE_PROTO variable is not defined (note     that the default is otherwise platform dependent). The primary     mouse driver can be retrieved using the static mouseHandler()     function. Use the closeMouse() function to delete the mouse     drivers.      In addition, the QWSServer class can control the flow of mouse     input using the suspendMouse() and resumeMouse() functions.      See also: QWSMouseHandler and \l{Qt for Embedded Linux Pointer Handling}.      \section1 Keyboard Handling      The keyboard driver (represented by an instance of the     QWSKeyboardHandler class) is loaded by the server application when     it starts running, using Qt's \l {How to Create Qt Plugins}{plugin     system}. A keyboard driver receives keyboard events from the     device and encapsulates each event with an instance of the     QWSEvent class which it then passes to the server.      The openKeyboard() function opens the keyboard devices specified     by the QWS_KEYBOARD environment variable, and the     setKeyboardHandler() functions sets the primary keyboard     driver. Alternatively, the static setDefaultKeyboard() function     provides means of specifying the keyboard driver to use if the     QWS_KEYBOARD variable is not defined (note again that the default     is otherwise platform dependent). The primary keyboard driver can     be retrieved using the static keyboardHandler() function. Use the     closeKeyboard() function to delete the keyboard drivers.      In addition, the QWSServer class can handle key events from both     physical and virtual keyboards using the processKeyEvent() and     sendKeyEvent() functions, respectively. Use the     addKeyboardFilter() function to filter the key events from     physical keyboard drivers, the most recently added filter can be     removed and deleted using the removeKeyboardFilter() function.      See also: QWSKeyboardHandler and \l{Qt for Embedded Linux Character Input}.      \section1 Display Handling      When a screen update is required, the server runs through all the     top-level windows that intersect with the region that is about to     be updated, and ensures that the associated clients have updated     their memory buffer. Then the server uses the screen driver     (represented by an instance of the QScreen class) to copy the     content of the memory to the screen.      In addition, the QWSServer class provides some means of managing     the screen output: Use the refresh() function to refresh the     entire display, or alternatively a specified region of it. The     enablePainting() function can be used to disable (and enable)     painting onto the screen. QWSServer also provide the     setMaxWindowRect() function restricting the area of the screen     which \l{Qt for Embedded Linux} applications will consider to be the     maximum area to use for windows. To set the brush used as the     background in the absence of obscuring windows, QWSServer provides     the static setBackground() function. The corresponding     backgroundBrush() function returns the currently set brush.      QWSServer also controls the screen saver: Use the setScreenSaver()     to install a custom screen saver derived from the QWSScreenSaver     class. Once installed, the screensaver can be activated using the     screenSaverActivate() function, and the screenSaverActive()     function returns its current status. Use the     setScreenSaverInterval() function to specify the timeout interval.     \l{Qt for Embedded Linux} also supports multilevel screen saving, use the     setScreenSaverIntervals() function to specify the various levels     and their timeout intervals.      Finally, the QWSServer class controls the cursor's appearance,     i.e., use the setCursorVisible() function to hide or show the     cursor, and the isCursorVisible() function to determine whether     the cursor is visible on the display or not.      See also: QScreen and \l{Qt for Embedded Linux Display Management}.      \section1 Input Method Handling      Whenever the server receives an event, it queries its stack of     top-level windows to find the window containing the event's     position (each window can identify the client application that     created it). Then the server forwards the event to the appropriate     client. If an input method is installed, it is used as a filter     between the server and the client application.      Derive from the QWSInputMethod class to create custom input     methods, and use the server's setCurrentInputMethod() function to     install it. Use the sendIMEvent() and sendIMQuery() functions to     send input method events and queries.      QWSServer provides the IMMouse enum describing the various mouse     events recognized by the QWSInputMethod::mouseHandler()     function. The latter function allows subclasses of QWSInputMethod     to handle mouse events within the preedit text.      \sa QWSInputMethod */
end_comment
begin_comment
comment|/*!     \enum QWSServer::IMState     \obsolete      This enum describes the various states of an input method.      \value IMCompose Composing.     \value IMStart Equivalent to IMCompose.     \value IMEnd Finished composing.      \sa QWSInputMethod::sendIMEvent() */
end_comment
begin_comment
comment|/*!     \enum QWSServer::IMMouse      This enum describes the various types of mouse events recognized     by the QWSInputMethod::mouseHandler() function.      \value MousePress An event generated by pressing a mouse button.     \value MouseRelease An event generated by relasing a mouse button.     \value MouseMove An event generated by moving the mouse cursor.     \value MouseOutside This value is only reserved, i.e., it is not used in                                     current implementations.      \sa QWSInputMethod, setCurrentInputMethod() */
end_comment
begin_comment
comment|/*!     \enum QWSServer::ServerFlags     \internal      This enum is used to pass various options to the window system     server.      \value DisableKeyboard Ignore all keyboard input.     \value DisableMouse Ignore all mouse input. */
end_comment
begin_comment
comment|/*!     \enum QWSServer::WindowEvent      This enum specifies the various events that can occur in a     top-level window.      \value Create A new window has been created (by the QWidget constructor).     \value Destroy The window has been closed and deleted (by the QWidget destructor).     \value Hide The window has been hidden using the QWidget::hide() function.     \value Show The window has been shown using the QWidget::show() function or similar.     \value Raise The window has been raised to the top of the desktop.     \value Lower The window has been lowered.     \value Geometry The window has changed size or position.     \value Active The window has become the active window (i.e., it has keyboard focus).     \value Name The window has been named.      \sa windowEvent() */
end_comment
begin_comment
comment|/*!     \fn void QWSServer::markedText(const QString&selection)      This signal is emitted whenever some text is selected in any of     the running applications, passing the selected text in the \a     selection parameter.      \sa windowEvent() */
end_comment
begin_comment
comment|/*!     \fn const QList<QWSWindow*>&QWSServer::clientWindows()      Returns the list of current top-level windows.      Note that the collection of top-level windows changes as     applications add and remove widgets so it should not be stored for     future use. The windows are sorted in stacking order from top-most     to bottom-most.      Use the QWSWindow::client() function to retrieve the client     application that owns a given window.      \sa windowAt(), instance() */
end_comment
begin_comment
comment|/*!     \fn void QWSServer::newChannel(const QString& channel)      This signal is emitted whenever a new QCopChannel object is     created, passing the channel's name in the \a channel parameter.      \sa removedChannel() */
end_comment
begin_comment
comment|/*!     \fn void QWSServer::removedChannel(const QString& channel)      This signal is emitted immediately after the given the QCopChannel     object specified by \a channel, is destroyed.      Note that a channel is not destroyed until all its listeners have     been unregistered.      \sa newChannel() */
end_comment
begin_comment
comment|/*!     \fn QWSServer::QWSServer(int flags, QObject *parent)     \internal      Construct a QWSServer object with the given \a parent.  The \a     flags are used for keyboard and mouse settings.      \warning This class is instantiated by QApplication for     \l{Qt for Embedded Linux} server processes. You should never construct     this class yourself.      \sa {Running Applications} */
end_comment
begin_comment
comment|/*!     \fn static QWSServer* QWSServer::instance()     \since 4.2      Returns a pointer to the server instance.      Note that the pointer will be 0 if the application is not the     server, i.e., if the QApplication::type() function doesn't return     QApplication::GuiServer.      \sa clientWindows(), windowAt() */
end_comment
begin_struct
DECL|struct|QWSCommandStruct
struct|struct
name|QWSCommandStruct
block|{
DECL|function|QWSCommandStruct
name|QWSCommandStruct
parameter_list|(
name|QWSCommand
modifier|*
name|c
parameter_list|,
name|QWSClient
modifier|*
name|cl
parameter_list|)
member_init_list|:
name|command
argument_list|(
name|c
argument_list|)
member_init_list|,
name|client
argument_list|(
name|cl
argument_list|)
block|{}
DECL|function|~QWSCommandStruct
name|~
name|QWSCommandStruct
parameter_list|()
block|{
operator|delete
name|command
expr_stmt|;
block|}
DECL|member|command
name|QWSCommand
modifier|*
name|command
decl_stmt|;
DECL|member|client
name|QWSClient
modifier|*
name|client
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QWSServer
name|QWSServer
operator|::
name|QWSServer
parameter_list|(
name|int
name|flags
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWSServerPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|initServer
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|qwsServer
operator|=
literal|0
expr_stmt|;
name|qwsServerPrivate
operator|=
literal|0
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_constructor
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_comment
comment|/*!     Use the two-argument overload and call the     QObject::setObjectName() function instead. */
end_comment
begin_constructor
DECL|function|QWSServer
name|QWSServer
operator|::
name|QWSServer
parameter_list|(
name|int
name|flags
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWSServerPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|setObjectName
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|initServer
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_function
DECL|function|ignoreSignal
specifier|static
name|void
name|ignoreSignal
parameter_list|(
name|int
parameter_list|)
block|{}
end_function
begin_comment
DECL|function|ignoreSignal
comment|// Used to eat SIGPIPE signals below
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|screensaverblockevent
name|bool
name|QWSServerPrivate
operator|::
name|screensaverblockevent
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|screensaverinterval
parameter_list|,
name|bool
name|isDown
parameter_list|)
block|{
specifier|static
name|bool
name|ignoreEvents
index|[
literal|2
index|]
init|=
block|{
literal|false
block|,
literal|false
block|}
decl_stmt|;
if|if
condition|(
name|isDown
condition|)
block|{
if|if
condition|(
operator|!
name|ignoreEvents
index|[
name|index
index|]
condition|)
block|{
name|bool
name|wake
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|screensaverintervals
condition|)
block|{
if|if
condition|(
name|screensaverinterval
operator|!=
name|screensaverintervals
condition|)
block|{
name|wake
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|screensaverblockevents
operator|&&
name|wake
condition|)
block|{
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|(
literal|"waking the screen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ignoreEvents
index|[
name|index
index|]
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|screensaverblockevents
condition|)
block|{
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|(
literal|"the screen was already awake"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ignoreEvents
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|ignoreEvents
index|[
name|index
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|(
literal|"mouseup?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ignoreEvents
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
name|ignoreEvents
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|initServer
name|void
name|QWSServerPrivate
operator|::
name|initServer
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|qwsServer
argument_list|)
expr_stmt|;
name|qwsServer
operator|=
name|q
expr_stmt|;
name|qwsServerPrivate
operator|=
name|this
expr_stmt|;
name|disablePainting
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
name|ssocket
operator|=
operator|new
name|QWSServerSocket
argument_list|(
name|qws_qtePipeFilename
argument_list|()
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|ssocket
argument_list|,
name|SIGNAL
argument_list|(
name|newConnection
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_newConnection
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssocket
operator|->
name|isListening
argument_list|()
condition|)
block|{
name|perror
argument_list|(
literal|"QWSServerPrivate::initServer: server socket not listening"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Failed to bind to %s"
argument_list|,
name|qws_qtePipeFilename
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|struct
name|linger
name|tmp
decl_stmt|;
name|tmp
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|l_linger
operator|=
literal|0
expr_stmt|;
name|setsockopt
argument_list|(
name|ssocket
operator|->
name|socketDescriptor
argument_list|()
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|ignoreSignal
argument_list|)
expr_stmt|;
comment|//we get it when we read
endif|#
directive|endif
name|focusw
operator|=
literal|0
expr_stmt|;
name|mouseGrabber
operator|=
literal|0
expr_stmt|;
name|mouseGrabbing
operator|=
literal|false
expr_stmt|;
name|inputMethodMouseGrabbed
operator|=
literal|false
expr_stmt|;
name|keyboardGrabber
operator|=
literal|0
expr_stmt|;
name|keyboardGrabbing
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
name|haveviscurs
operator|=
literal|false
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
name|nextCursor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
operator|!
name|geteuid
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
if|if
condition|(
name|mount
argument_list|(
literal|0
argument_list|,
literal|"/var/shm"
argument_list|,
literal|"shm"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This just confuses people with 2.2 kernels             if (errno != EBUSY)                 qDebug("Failed mounting shm fs on /var/shm: %s",strerror(errno));             */
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|// no selection yet
name|selectionOwner
operator|.
name|windowid
operator|=
operator|-
literal|1
expr_stmt|;
name|selectionOwner
operator|.
name|time
operator|.
name|set
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cleanupFontsDir
argument_list|()
expr_stmt|;
comment|// initialize the font database
comment|// from qfontdatabase_qws.cpp
specifier|extern
name|void
name|qt_qws_init_fontdb
argument_list|()
decl_stmt|;
name|qt_qws_init_fontdb
argument_list|()
expr_stmt|;
name|openDisplay
argument_list|()
expr_stmt|;
name|screensavertimer
operator|=
operator|new
name|QTimer
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|screensavertimer
operator|->
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|screensavertimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_screenSaverTimeout
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
name|clientMap
index|[
operator|-
literal|1
index|]
operator|=
operator|new
name|QWSClient
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bgBrush
condition|)
name|bgBrush
operator|=
operator|new
name|QBrush
argument_list|(
name|QColor
argument_list|(
literal|0x20
argument_list|,
literal|0xb0
argument_list|,
literal|0x50
argument_list|)
argument_list|)
expr_stmt|;
name|initializeCursor
argument_list|()
expr_stmt|;
comment|// input devices
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QWSServer
operator|::
name|DisableMouse
operator|)
condition|)
block|{
name|q
operator|->
name|openMouse
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QWSServer
operator|::
name|DisableKeyboard
operator|)
condition|)
block|{
name|q
operator|->
name|openKeyboard
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SOUND
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_EXTERNAL_SOUND_SERVER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
name|soundserver
operator|=
operator|new
name|QWSSoundServer
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Destructs this server. */
end_comment
begin_destructor
DECL|function|~QWSServer
name|QWSServer
operator|::
name|~
name|QWSServer
parameter_list|()
block|{
name|closeMouse
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
name|closeKeyboard
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d_func
argument_list|()
operator|->
name|cleanupFonts
argument_list|(
comment|/*force =*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QWSServer
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|fontCleanupTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|cleanupFonts
argument_list|()
expr_stmt|;
name|d
operator|->
name|fontCleanupTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QObject
operator|::
name|timerEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clientWindows
specifier|const
name|QList
argument_list|<
name|QWSWindow
modifier|*
argument_list|>
modifier|&
name|QWSServer
operator|::
name|clientWindows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windows
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|releaseMouse
name|void
name|QWSServerPrivate
operator|::
name|releaseMouse
parameter_list|(
name|QWSWindow
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
name|w
operator|&&
name|mouseGrabber
operator|==
name|w
condition|)
block|{
name|mouseGrabber
operator|=
literal|0
expr_stmt|;
name|mouseGrabbing
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|nextCursor
condition|)
block|{
comment|// Not grabbing -> set the correct cursor
name|setCursor
argument_list|(
name|nextCursor
argument_list|)
expr_stmt|;
name|nextCursor
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|releaseKeyboard
name|void
name|QWSServerPrivate
operator|::
name|releaseKeyboard
parameter_list|(
name|QWSWindow
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
name|keyboardGrabber
operator|==
name|w
condition|)
block|{
name|keyboardGrabber
operator|=
literal|0
expr_stmt|;
name|keyboardGrabbing
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleWindowClose
name|void
name|QWSServerPrivate
operator|::
name|handleWindowClose
parameter_list|(
name|QWSWindow
modifier|*
name|w
parameter_list|)
block|{
name|w
operator|->
name|shuttingDown
argument_list|()
expr_stmt|;
if|if
condition|(
name|focusw
operator|==
name|w
condition|)
name|setFocus
argument_list|(
name|w
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|mouseGrabber
operator|==
name|w
condition|)
name|releaseMouse
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyboardGrabber
operator|==
name|w
condition|)
name|releaseKeyboard
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|_q_newConnection
name|void
name|QWSServerPrivate
operator|::
name|_q_newConnection
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
while|while
condition|(
name|QWS_SOCK_BASE
modifier|*
name|sock
init|=
name|ssocket
operator|->
name|nextPendingConnection
argument_list|()
condition|)
block|{
name|int
name|socket
init|=
name|sock
operator|->
name|socketDescriptor
argument_list|()
decl_stmt|;
name|sock
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QWSClient
modifier|*
name|client
init|=
operator|new
name|QWSClient
argument_list|(
name|q
argument_list|,
name|sock
argument_list|,
name|get_object_id
argument_list|()
argument_list|)
decl_stmt|;
name|clientMap
index|[
name|socket
index|]
operator|=
name|client
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SXE
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|qDebug
argument_list|(
literal|"Transport auth connected: unix stream socket %d"
argument_list|,
name|socket
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// get a handle to the per-process authentication service
name|QTransportAuth
modifier|*
name|a
init|=
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
decl_stmt|;
comment|// assert that this transport is trusted
name|QTransportAuth
operator|::
name|Data
modifier|*
name|d
init|=
name|a
operator|->
name|connectTransport
argument_list|(
name|QTransportAuth
operator|::
name|UnixStreamSock
operator||
name|QTransportAuth
operator|::
name|Trusted
argument_list|,
name|socket
argument_list|)
decl_stmt|;
name|QAuthDevice
modifier|*
name|ad
init|=
name|a
operator|->
name|recvBuf
argument_list|(
name|d
argument_list|,
name|sock
argument_list|)
decl_stmt|;
name|ad
operator|->
name|setClient
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|ad
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_doClient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|connectionClosed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_clientClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|QObject
operator|::
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_doClient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|connectionClosed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_clientClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_SXE
name|client
operator|->
name|sendConnectedEvent
argument_list|(
name|qws_display_spec
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientMap
operator|.
name|contains
argument_list|(
name|socket
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|screens
init|=
name|qt_screen
operator|->
name|subScreens
argument_list|()
decl_stmt|;
if|if
condition|(
name|screens
operator|.
name|isEmpty
argument_list|()
condition|)
name|screens
operator|.
name|append
argument_list|(
name|qt_screen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|screens
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QApplicationPrivate
modifier|*
name|ap
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
name|QScreen
modifier|*
name|screen
init|=
name|screens
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|rect
init|=
name|ap
operator|->
name|maxWindowRect
argument_list|(
name|screen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
name|client
operator|->
name|sendMaxWindowRectEvent
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|isTransformed
argument_list|()
condition|)
block|{
name|QWSScreenTransformationEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|screen
operator|=
name|i
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|transformation
operator|=
name|screen
operator|->
name|transformOrientation
argument_list|()
expr_stmt|;
name|client
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// pre-provide some object id's
name|QWSCreateCommand
name|cmd
argument_list|(
literal|30
argument_list|)
decl_stmt|;
name|invokeCreate
argument_list|(
operator|&
name|cmd
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|_q_clientClosed
name|void
name|QWSServerPrivate
operator|::
name|_q_clientClosed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSClient
modifier|*
name|cl
init|=
operator|(
name|QWSClient
operator|*
operator|)
name|q
operator|->
name|sender
argument_list|()
decl_stmt|;
comment|// Remove any queued commands for this client
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|commandQueue
operator|.
name|size
argument_list|()
condition|)
block|{
name|QWSCommandStruct
modifier|*
name|cs
init|=
name|commandQueue
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|client
operator|==
name|cl
condition|)
block|{
name|commandQueue
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|delete
name|cs
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_COP
comment|// Enfore unsubscription from all channels.
name|QCopChannel
operator|::
name|detach
argument_list|(
name|cl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Shut down all windows for this client
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|forClient
argument_list|(
name|cl
argument_list|)
condition|)
name|w
operator|->
name|shuttingDown
argument_list|()
expr_stmt|;
block|}
comment|// Delete all windows for this client
name|QRegion
name|exposed
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|forClient
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|windows
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|w
operator|->
name|c
operator|=
literal|0
expr_stmt|;
comment|//so we don't send events to it anymore
name|releaseMouse
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|releaseKeyboard
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|exposed
operator|+=
name|w
operator|->
name|allocatedRegion
argument_list|()
expr_stmt|;
comment|//                rgnMan->remove(w->allocationIndex());
if|if
condition|(
name|focusw
operator|==
name|w
condition|)
name|setFocus
argument_list|(
name|focusw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mouseGrabber
operator|==
name|w
condition|)
name|releaseMouse
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nReserved
condition|)
operator|--
name|nReserved
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
name|propertyManager
operator|.
name|removeProperties
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|w
argument_list|,
name|QWSServer
operator|::
name|Destroy
argument_list|)
emit|;
name|w
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Destroyed
expr_stmt|;
comment|//???
name|deletedWindows
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deletedWindows
operator|.
name|count
argument_list|()
condition|)
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|0
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_deleteWindowsLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QWSClientPrivate
modifier|*
name|clientPrivate
init|=
name|cl
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|clientPrivate
operator|->
name|shutdown
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"client"
operator|<<
name|cl
operator|->
name|clientId
argument_list|()
operator|<<
literal|"crashed"
expr_stmt|;
endif|#
directive|endif
comment|// this would be the place to emit a signal to notify about the
comment|// crash of a client
name|crashedClientIds
operator|.
name|append
argument_list|(
name|cl
operator|->
name|clientId
argument_list|()
argument_list|)
expr_stmt|;
name|fontCleanupTimer
operator|.
name|start
argument_list|(
literal|10
argument_list|,
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clientPrivate
operator|->
name|shutdown
operator|=
literal|true
expr_stmt|;
while|while
condition|(
operator|!
name|clientPrivate
operator|->
name|usedFonts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QByteArray
name|font
init|=
operator|*
name|clientPrivate
operator|->
name|usedFonts
operator|.
name|begin
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"dereferencing font"
operator|<<
name|font
operator|<<
literal|"from disconnected client"
expr_stmt|;
endif|#
directive|endif
name|dereferenceFont
argument_list|(
name|clientPrivate
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
name|clientPrivate
operator|->
name|usedFonts
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//qDebug("removing client %d with socket %d", cl->clientId(), cl->socket());
name|clientMap
operator|.
name|remove
argument_list|(
name|cl
operator|->
name|socket
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|cursorClient
condition|)
name|cursorClient
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qt_screen
operator|->
name|clearCacheFunc
condition|)
call|(
name|qt_screen
operator|->
name|clearCacheFunc
call|)
argument_list|(
name|qt_screen
argument_list|,
name|cl
operator|->
name|clientId
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove any remaining cache entries.
name|cl
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|update_regions
argument_list|()
expr_stmt|;
name|exposeRegion
argument_list|(
name|exposed
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_deleteWindowsLater
name|void
name|QWSServerPrivate
operator|::
name|_q_deleteWindowsLater
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|deletedWindows
argument_list|)
expr_stmt|;
name|deletedWindows
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_QWS_MULTIPROCESS
end_comment
begin_function
DECL|function|referenceFont
name|void
name|QWSServerPrivate
operator|::
name|referenceFont
parameter_list|(
name|QWSClientPrivate
modifier|*
name|client
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|font
parameter_list|)
block|{
if|if
condition|(
operator|!
name|client
operator|->
name|usedFonts
operator|.
name|contains
argument_list|(
name|font
argument_list|)
condition|)
block|{
name|client
operator|->
name|usedFonts
operator|.
name|insert
argument_list|(
name|font
argument_list|)
expr_stmt|;
operator|++
name|fontReferenceCount
index|[
name|font
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Client"
operator|<<
name|client
operator|->
name|q_func
argument_list|()
operator|->
name|clientId
argument_list|()
operator|<<
literal|"added font"
operator|<<
name|font
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Refcount is"
operator|<<
name|fontReferenceCount
index|[
name|font
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|dereferenceFont
name|void
name|QWSServerPrivate
operator|::
name|dereferenceFont
parameter_list|(
name|QWSClientPrivate
modifier|*
name|client
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|font
parameter_list|)
block|{
if|if
condition|(
name|client
operator|->
name|usedFonts
operator|.
name|contains
argument_list|(
name|font
argument_list|)
condition|)
block|{
name|client
operator|->
name|usedFonts
operator|.
name|remove
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|fontReferenceCount
index|[
name|font
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|fontReferenceCount
index|[
name|font
index|]
operator|&&
operator|!
name|fontCleanupTimer
operator|.
name|isActive
argument_list|()
condition|)
name|fontCleanupTimer
operator|.
name|start
argument_list|(
name|FontCleanupInterval
argument_list|,
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Client"
operator|<<
name|client
operator|->
name|q_func
argument_list|()
operator|->
name|clientId
argument_list|()
operator|<<
literal|"removed font"
operator|<<
name|font
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Refcount is"
operator|<<
name|fontReferenceCount
index|[
name|font
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|cleanupFontsDir
specifier|static
name|void
name|cleanupFontsDir
parameter_list|()
block|{
specifier|static
name|bool
name|dontDelete
init|=
operator|!
name|qgetenv
argument_list|(
literal|"QWS_KEEP_FONTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|dontDelete
condition|)
return|return;
specifier|extern
name|QString
name|qws_fontCacheDir
argument_list|()
decl_stmt|;
name|QDir
name|dir
argument_list|(
name|qws_fontCacheDir
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"*.qsf"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dir
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"removing stale font file"
operator|<<
name|dir
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|dir
operator|.
name|remove
argument_list|(
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanupFonts
name|void
name|QWSServerPrivate
operator|::
name|cleanupFonts
parameter_list|(
name|bool
name|force
parameter_list|)
block|{
specifier|static
name|bool
name|dontDelete
init|=
operator|!
name|qgetenv
argument_list|(
literal|"QWS_KEEP_FONTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|dontDelete
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"cleanupFonts()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fontReferenceCount
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|fontReferenceCount
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|fontReferenceCount
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|&&
operator|!
name|force
condition|)
block|{
operator|++
name|it
expr_stmt|;
continue|continue;
block|}
specifier|const
name|QByteArray
modifier|&
name|fontName
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QWS_DEBUG_FONTCLEANUP
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"removing unused font file"
operator|<<
name|fontName
expr_stmt|;
endif|#
directive|endif
name|QT_TRY
block|{
name|QFile
operator|::
name|remove
argument_list|(
name|QFile
operator|::
name|decodeName
argument_list|(
name|fontName
argument_list|)
argument_list|)
expr_stmt|;
name|sendFontRemovedEvent
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|it
operator|=
name|fontReferenceCount
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// so we were not able to remove the font.
comment|// don't be angry and just continue with the next ones.
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|crashedClientIds
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|removedFonts
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_QWS_QPF2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_FONTS_ARE_RESOURCES
argument_list|)
name|removedFonts
operator|=
name|QFontEngineQPF
operator|::
name|cleanUpAfterClientCrash
argument_list|(
name|crashedClientIds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|crashedClientIds
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|removedFonts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|sendFontRemovedEvent
argument_list|(
name|removedFonts
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendFontRemovedEvent
name|void
name|QWSServerPrivate
operator|::
name|sendFontRemovedEvent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|font
parameter_list|)
block|{
name|QWSFontEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|type
operator|=
name|QWSFontEvent
operator|::
name|FontRemoved
expr_stmt|;
name|event
operator|.
name|setData
argument_list|(
name|font
operator|.
name|constData
argument_list|()
argument_list|,
name|font
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QWSClient
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|clientMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|clientMap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|readMoreCommand
name|QWSCommand
modifier|*
name|QWSClient
operator|::
name|readMoreCommand
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
name|QIODevice
modifier|*
name|socket
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SXE
if|if
condition|(
name|socketDescriptor
operator|!=
operator|-
literal|1
condition|)
comment|// not server socket
name|socket
operator|=
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|passThroughByClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|#
directive|if
name|QTRANSPORTAUTH_DEBUG
if|if
condition|(
name|socket
condition|)
block|{
name|char
name|displaybuf
index|[
literal|1024
index|]
decl_stmt|;
name|qint64
name|bytes
init|=
name|socket
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|511
condition|)
name|bytes
operator|=
literal|511
expr_stmt|;
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
cast|reinterpret_cast
argument_list|<
name|QAuthDevice
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|buffer
argument_list|()
operator|.
name|constData
argument_list|()
operator|)
operator|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"readMoreCommand: %lli bytes - %s"
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
name|displaybuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|// QT_NO_SXE
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
operator|!
name|socket
condition|)
name|socket
operator|=
name|csocket
expr_stmt|;
comment|// server socket
if|if
condition|(
name|socket
condition|)
block|{
comment|// read next command
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|int
name|command_type
init|=
name|qws_read_uint
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|command_type
operator|>=
literal|0
condition|)
name|command
operator|=
name|QWSCommand
operator|::
name|factory
argument_list|(
name|command_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|command
condition|)
block|{
if|if
condition|(
name|command
operator|->
name|read
argument_list|(
name|socket
argument_list|)
condition|)
block|{
comment|// Finished reading a whole command.
name|QWSCommand
modifier|*
name|result
init|=
name|command
decl_stmt|;
name|command
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|// Not finished reading a whole command.
return|return
literal|0
return|;
block|}
else|else
endif|#
directive|endif
comment|// QT_NO_QWS_MULTIPROCESS
block|{
name|QList
argument_list|<
name|QWSCommand
modifier|*
argument_list|>
modifier|*
name|serverQueue
init|=
name|qt_get_server_queue
argument_list|()
decl_stmt|;
return|return
name|serverQueue
operator|->
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|serverQueue
operator|->
name|takeFirst
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|processEventQueue
name|void
name|QWSServer
operator|::
name|processEventQueue
parameter_list|()
block|{
if|if
condition|(
name|qwsServerPrivate
condition|)
name|qwsServerPrivate
operator|->
name|doClient
argument_list|(
name|qwsServerPrivate
operator|->
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_function
DECL|function|_q_doClient
name|void
name|QWSServerPrivate
operator|::
name|_q_doClient
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSClient
modifier|*
name|client
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SXE
name|QAuthDevice
modifier|*
name|ad
init|=
name|qobject_cast
argument_list|<
name|QAuthDevice
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ad
condition|)
name|client
operator|=
operator|(
name|QWSClient
operator|*
operator|)
name|ad
operator|->
name|client
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|client
operator|=
operator|(
name|QWSClient
operator|*
operator|)
name|q
operator|->
name|sender
argument_list|()
expr_stmt|;
if|if
condition|(
name|doClientIsActive
condition|)
block|{
name|pendingDoClients
operator|.
name|append
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
name|doClientIsActive
operator|=
literal|true
expr_stmt|;
name|doClient
argument_list|(
name|client
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|pendingDoClients
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|doClient
argument_list|(
name|pendingDoClients
operator|.
name|takeFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doClientIsActive
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_MULTIPROCESS
end_comment
begin_function
DECL|function|doClient
name|void
name|QWSServerPrivate
operator|::
name|doClient
parameter_list|(
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QWSCommand
modifier|*
name|command
init|=
name|client
operator|->
name|readMoreCommand
argument_list|()
decl_stmt|;
while|while
condition|(
name|command
condition|)
block|{
name|QWSCommandStruct
modifier|*
name|cs
init|=
operator|new
name|QWSCommandStruct
argument_list|(
name|command
argument_list|,
name|client
argument_list|)
decl_stmt|;
name|commandQueue
operator|.
name|append
argument_list|(
name|cs
argument_list|)
expr_stmt|;
comment|// Try for some more...
name|command
operator|=
name|client
operator|->
name|readMoreCommand
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|commandQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QWSCommandStruct
modifier|*
name|cs
init|=
name|commandQueue
operator|.
name|takeAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|command
operator|->
name|type
condition|)
block|{
case|case
name|QWSCommand
operator|::
name|Identify
case|:
name|invokeIdentify
argument_list|(
operator|(
name|QWSIdentifyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|Create
case|:
name|invokeCreate
argument_list|(
operator|(
name|QWSCreateCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
case|case
name|QWSCommand
operator|::
name|Shutdown
case|:
name|cs
operator|->
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|shutdown
operator|=
literal|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWSCommand
operator|::
name|RegionName
case|:
name|invokeRegionName
argument_list|(
operator|(
name|QWSRegionNameCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|Region
case|:
name|invokeRegion
argument_list|(
operator|(
name|QWSRegionCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
name|cs
operator|->
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|unlockCommunication
argument_list|()
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|RegionMove
case|:
name|invokeRegionMove
argument_list|(
operator|(
name|QWSRegionMoveCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
name|cs
operator|->
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|unlockCommunication
argument_list|()
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|RegionDestroy
case|:
name|invokeRegionDestroy
argument_list|(
operator|(
name|QWSRegionDestroyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
case|case
name|QWSCommand
operator|::
name|AddProperty
case|:
name|invokeAddProperty
argument_list|(
operator|(
name|QWSAddPropertyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|SetProperty
case|:
name|invokeSetProperty
argument_list|(
operator|(
name|QWSSetPropertyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|RemoveProperty
case|:
name|invokeRemoveProperty
argument_list|(
operator|(
name|QWSRemovePropertyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|GetProperty
case|:
name|invokeGetProperty
argument_list|(
operator|(
name|QWSGetPropertyCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWSCommand
operator|::
name|SetSelectionOwner
case|:
name|invokeSetSelectionOwner
argument_list|(
operator|(
name|QWSSetSelectionOwnerCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|RequestFocus
case|:
name|invokeSetFocus
argument_list|(
operator|(
name|QWSRequestFocusCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|ChangeAltitude
case|:
name|invokeSetAltitude
argument_list|(
operator|(
name|QWSChangeAltitudeCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
name|cs
operator|->
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|unlockCommunication
argument_list|()
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|SetOpacity
case|:
name|invokeSetOpacity
argument_list|(
operator|(
name|QWSSetOpacityCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
case|case
name|QWSCommand
operator|::
name|DefineCursor
case|:
name|invokeDefineCursor
argument_list|(
operator|(
name|QWSDefineCursorCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|SelectCursor
case|:
name|invokeSelectCursor
argument_list|(
operator|(
name|QWSSelectCursorCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|PositionCursor
case|:
name|invokePositionCursor
argument_list|(
operator|(
name|QWSPositionCursorCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWSCommand
operator|::
name|GrabMouse
case|:
name|invokeGrabMouse
argument_list|(
operator|(
name|QWSGrabMouseCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|GrabKeyboard
case|:
name|invokeGrabKeyboard
argument_list|(
operator|(
name|QWSGrabKeyboardCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SOUND
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
case|case
name|QWSCommand
operator|::
name|PlaySound
case|:
name|invokePlaySound
argument_list|(
operator|(
name|QWSPlaySoundCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_COP
case|case
name|QWSCommand
operator|::
name|QCopRegisterChannel
case|:
name|invokeRegisterChannel
argument_list|(
operator|(
name|QWSQCopRegisterChannelCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|QCopSend
case|:
name|invokeQCopSend
argument_list|(
operator|(
name|QWSQCopSendCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
case|case
name|QWSCommand
operator|::
name|IMUpdate
case|:
name|invokeIMUpdate
argument_list|(
operator|(
name|QWSIMUpdateCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|IMResponse
case|:
name|invokeIMResponse
argument_list|(
operator|(
name|QWSIMResponseCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|IMMouse
case|:
block|{
if|if
condition|(
name|current_IM
condition|)
block|{
name|QWSIMMouseCommand
modifier|*
name|cmd
init|=
operator|(
name|QWSIMMouseCommand
operator|*
operator|)
name|cs
operator|->
name|command
decl_stmt|;
name|current_IM
operator|->
name|mouseHandler
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|index
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|QWSCommand
operator|::
name|Font
case|:
name|invokeFont
argument_list|(
operator|(
name|QWSFontCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSCommand
operator|::
name|RepaintRegion
case|:
name|invokeRepaintRegion
argument_list|(
operator|(
name|QWSRepaintRegionCommand
operator|*
operator|)
name|cs
operator|->
name|command
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
name|cs
operator|->
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|unlockCommunication
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
case|case
name|QWSCommand
operator|::
name|Embed
case|:
name|invokeEmbed
argument_list|(
cast|static_cast
argument_list|<
name|QWSEmbedCommand
operator|*
argument_list|>
argument_list|(
name|cs
operator|->
name|command
argument_list|)
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QWSCommand
operator|::
name|ScreenTransform
case|:
name|invokeScreenTransform
argument_list|(
cast|static_cast
argument_list|<
name|QWSScreenTransformCommand
operator|*
argument_list|>
argument_list|(
name|cs
operator|->
name|command
argument_list|)
argument_list|,
name|cs
operator|->
name|client
argument_list|)
expr_stmt|;
break|break;
block|}
operator|delete
name|cs
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|showCursor
name|void
name|QWSServerPrivate
operator|::
name|showCursor
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|show
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|hideCursor
name|void
name|QWSServerPrivate
operator|::
name|hideCursor
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|hide
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::enablePainting(bool enable)      Enables painting onto the screen if \a enable is true; otherwise     painting is disabled.      \sa {Qt for Embedded Linux Architecture#Drawing on Screen}{Qt for Embedded Linux     Architecture} */
end_comment
begin_function
DECL|function|enablePainting
name|void
name|QWSServer
operator|::
name|enablePainting
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|disablePainting
operator|==
operator|!
name|enable
condition|)
return|return;
name|d
operator|->
name|disablePainting
operator|=
operator|!
name|enable
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
comment|// Reset the server side allocated regions to ensure update_regions()
comment|// will send out region events.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|d
operator|->
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|w
operator|->
name|setAllocatedRegion
argument_list|(
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|w
operator|->
name|setDirectPaintRegion
argument_list|(
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|update_regions
argument_list|()
expr_stmt|;
name|d
operator|->
name|showCursor
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Disable painting by clients by taking away their allocated region.
comment|// To ensure mouse events are still delivered to the correct windows,
comment|// the allocated regions are not modified on the server.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|d
operator|->
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|w
operator|->
name|client
argument_list|()
operator|->
name|sendRegionEvent
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|QRegion
argument_list|()
argument_list|,
name|QWSRegionEvent
operator|::
name|Allocation
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|w
operator|->
name|client
argument_list|()
operator|->
name|sendRegionEvent
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|QRegion
argument_list|()
argument_list|,
name|QWSRegionEvent
operator|::
name|DirectPaint
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|hideCursor
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Refreshes the display by making the screen driver update the     entire display.      \sa QScreen::exposeRegion() */
end_comment
begin_function
DECL|function|refresh
name|void
name|QWSServer
operator|::
name|refresh
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|d
operator|->
name|exposeRegion
argument_list|(
name|QScreen
operator|::
name|instance
argument_list|()
operator|->
name|region
argument_list|()
argument_list|)
expr_stmt|;
comment|//### send repaint to non-buffered windows
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::refresh(QRegion& region)     \overload      Refreshes the given \a region of the display. */
end_comment
begin_function
DECL|function|refresh
name|void
name|QWSServer
operator|::
name|refresh
parameter_list|(
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|d
operator|->
name|exposeRegion
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|//### send repaint to non-buffered windows
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setMaxWindowRect(const QRect& rectangle)      Sets the maximum area of the screen that \l{Qt for Embedded Linux}     applications can use, to be the given \a rectangle.      Note that this function can only be used in the server process.      \sa QWidget::showMaximized() */
end_comment
begin_function
DECL|function|setMaxWindowRect
name|void
name|QWSServer
operator|::
name|setMaxWindowRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|subScreens
init|=
name|qt_screen
operator|->
name|subScreens
argument_list|()
decl_stmt|;
if|if
condition|(
name|subScreens
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qt_screen
operator|!=
literal|0
condition|)
name|subScreens
operator|.
name|append
argument_list|(
name|qt_screen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subScreens
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QScreen
modifier|*
name|screen
init|=
name|subScreens
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|r
init|=
operator|(
name|screen
operator|->
name|region
argument_list|()
operator|&
name|rect
operator|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QApplicationPrivate
modifier|*
name|ap
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|maxWindowRect
argument_list|(
name|screen
argument_list|)
operator|!=
name|r
condition|)
block|{
name|ap
operator|->
name|setMaxWindowRect
argument_list|(
name|screen
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|sendMaxWindowRectEvents
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|sendMaxWindowRectEvents
name|void
name|QWSServerPrivate
operator|::
name|sendMaxWindowRectEvents
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QWSClient
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|clientMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|clientMap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|->
name|sendMaxWindowRectEvent
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setDefaultMouse(const char *mouseDriver)      Sets the mouse driver that will be used if the QWS_MOUSE_PROTO     environment variable is not defined, to be the given \a     mouseDriver.      Note that the default is platform-dependent. This function can     only be used in the server process.       \sa setMouseHandler(), {Qt for Embedded Linux Pointer Handling} */
end_comment
begin_function
DECL|function|setDefaultMouse
name|void
name|QWSServer
operator|::
name|setDefaultMouse
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
operator|*
name|defaultMouse
argument_list|()
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setDefaultKeyboard(const char *keyboardDriver)      Sets the keyboard driver that will be used if the QWS_KEYBOARD     environment variable is not defined, to be the given \a     keyboardDriver.      Note that the default is platform-dependent. This function can     only be used in the server process.      \sa setKeyboardHandler(), {Qt for Embedded Linux Character Input} */
end_comment
begin_function
DECL|function|setDefaultKeyboard
name|void
name|QWSServer
operator|::
name|setDefaultKeyboard
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|)
block|{
operator|*
name|defaultKeyboard
argument_list|()
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
end_ifndef
begin_decl_stmt
DECL|variable|prevWin
specifier|static
name|bool
name|prevWin
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
specifier|extern
name|int
modifier|*
name|qt_last_x
decl_stmt|,
modifier|*
name|qt_last_y
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   \internal    Send a mouse event. \a pos is the screen position where the mouse   event occurred and \a state is a mask indicating which buttons are   pressed.    \a pos is in device coordinates */
end_comment
begin_function
DECL|function|sendMouseEvent
name|void
name|QWSServer
operator|::
name|sendMouseEvent
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|wheel
parameter_list|)
block|{
name|bool
name|block
init|=
name|qwsServerPrivate
operator|->
name|screensaverblockevent
argument_list|(
name|MOUSE
argument_list|,
name|qwsServerPrivate
operator|->
name|screensaverinterval
argument_list|,
name|state
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"sendMouseEvent"
operator|<<
name|pos
operator|.
name|x
argument_list|()
operator|<<
name|pos
operator|.
name|y
argument_list|()
operator|<<
name|state
operator|<<
operator|(
name|block
condition|?
literal|"block"
else|:
literal|"pass"
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|state
operator|||
name|wheel
condition|)
name|qwsServerPrivate
operator|->
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
condition|)
return|return;
name|QPoint
name|tpos
decl_stmt|;
comment|// transformations
if|if
condition|(
name|qt_screen
operator|->
name|isTransformed
argument_list|()
condition|)
block|{
name|QSize
name|s
init|=
name|QSize
argument_list|(
name|qt_screen
operator|->
name|deviceWidth
argument_list|()
argument_list|,
name|qt_screen
operator|->
name|deviceHeight
argument_list|()
argument_list|)
decl_stmt|;
name|tpos
operator|=
name|qt_screen
operator|->
name|mapFromDevice
argument_list|(
name|pos
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tpos
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|qt_last_x
condition|)
block|{
operator|*
name|qt_last_x
operator|=
name|tpos
operator|.
name|x
argument_list|()
expr_stmt|;
operator|*
name|qt_last_y
operator|=
name|tpos
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|QWSServer
operator|::
name|mousePosition
operator|=
name|tpos
expr_stmt|;
name|qwsServerPrivate
operator|->
name|mouseState
operator|=
name|state
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
specifier|const
name|int
name|btnMask
init|=
name|Qt
operator|::
name|LeftButton
operator||
name|Qt
operator|::
name|RightButton
operator||
name|Qt
operator|::
name|MidButton
decl_stmt|;
name|int
name|stroke_count
decl_stmt|;
comment|// number of strokes to keep shown.
if|if
condition|(
name|force_reject_strokeIM
operator|||
operator|!
name|current_IM
condition|)
block|{
name|stroke_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|stroke_count
operator|=
name|current_IM
operator|->
name|filter
argument_list|(
name|tpos
argument_list|,
name|state
argument_list|,
name|wheel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stroke_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|&
name|btnMask
condition|)
name|force_reject_strokeIM
operator|=
literal|true
expr_stmt|;
name|QWSServerPrivate
operator|::
name|sendMouseEventUnfiltered
argument_list|(
name|tpos
argument_list|,
name|state
argument_list|,
name|wheel
argument_list|)
expr_stmt|;
block|}
comment|// stop force reject after stroke ends.
if|if
condition|(
name|state
operator|&
name|btnMask
operator|&&
name|force_reject_strokeIM
condition|)
name|force_reject_strokeIM
operator|=
literal|false
expr_stmt|;
comment|// on end of stroke, force_rejct
comment|// and once a stroke is rejected, do not try again till pen is lifted
else|#
directive|else
name|QWSServerPrivate
operator|::
name|sendMouseEventUnfiltered
argument_list|(
name|tpos
argument_list|,
name|state
argument_list|,
name|wheel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// end QT_NO_QWS_FSIM
block|}
end_function
begin_function
DECL|function|sendMouseEventUnfiltered
name|void
name|QWSServerPrivate
operator|::
name|sendMouseEventUnfiltered
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|wheel
parameter_list|)
block|{
specifier|const
name|int
name|btnMask
init|=
name|Qt
operator|::
name|LeftButton
operator||
name|Qt
operator|::
name|RightButton
operator||
name|Qt
operator|::
name|MidButton
decl_stmt|;
name|QWSMouseEvent
name|event
decl_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
name|qwsServer
operator|->
name|windowAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|QWSClient
modifier|*
name|serverClient
init|=
name|qwsServerPrivate
operator|->
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QWSClient
modifier|*
name|winClient
init|=
name|win
condition|?
name|win
operator|->
name|client
argument_list|()
else|:
literal|0
decl_stmt|;
name|bool
name|imMouse
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
comment|// check for input method window
if|if
condition|(
name|current_IM
operator|&&
name|current_IM_winId
operator|!=
operator|-
literal|1
condition|)
block|{
name|QWSWindow
modifier|*
name|kbw
init|=
name|keyboardGrabber
condition|?
name|keyboardGrabber
else|:
name|qwsServerPrivate
operator|->
name|focusw
decl_stmt|;
name|imMouse
operator|=
name|kbw
operator|==
name|win
expr_stmt|;
if|if
condition|(
operator|!
name|imMouse
condition|)
block|{
name|QWidget
modifier|*
name|target
init|=
name|winClient
operator|==
name|serverClient
condition|?
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|pos
argument_list|)
else|:
literal|0
decl_stmt|;
name|imMouse
operator|=
name|target
operator|&&
operator|(
name|target
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodTransparent
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|//If grabbing window disappears, grab is still active until
comment|//after mouse release.
if|if
condition|(
name|qwsServerPrivate
operator|->
name|mouseGrabber
operator|&&
operator|(
operator|!
name|imMouse
operator|||
name|qwsServerPrivate
operator|->
name|inputMethodMouseGrabbed
operator|)
condition|)
block|{
name|win
operator|=
name|qwsServerPrivate
operator|->
name|mouseGrabber
expr_stmt|;
name|winClient
operator|=
name|win
condition|?
name|win
operator|->
name|client
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|win
condition|?
name|win
operator|->
name|id
else|:
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|move
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Arrow cursor over desktop
comment|// prevWin remembers if the last event was over a window
if|if
condition|(
operator|!
name|win
operator|&&
name|prevWin
condition|)
block|{
if|if
condition|(
operator|!
name|qwsServerPrivate
operator|->
name|mouseGrabber
condition|)
name|qwsServerPrivate
operator|->
name|setCursor
argument_list|(
name|QWSCursor
operator|::
name|systemCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|qwsServerPrivate
operator|->
name|nextCursor
operator|=
name|QWSCursor
operator|::
name|systemCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
expr_stmt|;
name|prevWin
operator|=
literal|false
expr_stmt|;
block|}
comment|// reset prevWin
if|if
condition|(
name|win
operator|&&
operator|!
name|prevWin
condition|)
name|prevWin
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|state
operator|&
name|btnMask
operator|)
operator|&&
operator|!
name|qwsServerPrivate
operator|->
name|mouseGrabbing
condition|)
block|{
name|qwsServerPrivate
operator|->
name|mouseGrabber
operator|=
name|win
expr_stmt|;
if|if
condition|(
name|imMouse
condition|)
name|qwsServerPrivate
operator|->
name|inputMethodMouseGrabbed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|btnMask
operator|)
condition|)
name|qwsServerPrivate
operator|->
name|inputMethodMouseGrabbed
operator|=
literal|false
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|x_root
operator|=
name|pos
operator|.
name|x
argument_list|()
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|y_root
operator|=
name|pos
operator|.
name|y
argument_list|()
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|state
operator|=
name|state
operator||
name|qws_keyModifiers
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|delta
operator|=
name|wheel
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|time
operator|=
name|qwsServerPrivate
operator|->
name|timer
operator|.
name|elapsed
argument_list|()
expr_stmt|;
specifier|static
name|int
name|oldstate
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
comment|//tell the input method if we click on a different window that is not IM transparent
name|bool
name|isPress
init|=
name|state
operator|>
name|oldstate
decl_stmt|;
if|if
condition|(
name|isPress
operator|&&
operator|!
name|imMouse
operator|&&
name|current_IM
operator|&&
name|current_IM_winId
operator|!=
operator|-
literal|1
condition|)
name|current_IM
operator|->
name|mouseHandler
argument_list|(
operator|-
literal|1
argument_list|,
name|QWSServer
operator|::
name|MouseOutside
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|serverClient
condition|)
name|serverClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|winClient
operator|&&
name|winClient
operator|!=
name|serverClient
condition|)
name|winClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imMouse
condition|)
block|{
comment|// Make sure that if we leave a window, that window gets one last mouse
comment|// event so that it knows the mouse has left.
name|QWSClient
modifier|*
name|oldClient
init|=
name|qwsServer
operator|->
name|d_func
argument_list|()
operator|->
name|cursorClient
decl_stmt|;
if|if
condition|(
name|oldClient
operator|&&
name|oldClient
operator|!=
name|winClient
operator|&&
name|oldClient
operator|!=
name|serverClient
condition|)
block|{
name|event
operator|.
name|simpleData
operator|.
name|state
operator|=
name|oldstate
operator||
name|qws_keyModifiers
expr_stmt|;
name|oldClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
name|oldstate
operator|=
name|state
expr_stmt|;
if|if
condition|(
operator|!
name|imMouse
condition|)
name|qwsServer
operator|->
name|d_func
argument_list|()
operator|->
name|cursorClient
operator|=
name|winClient
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|btnMask
operator|)
operator|&&
operator|!
name|qwsServerPrivate
operator|->
name|mouseGrabbing
condition|)
name|qwsServerPrivate
operator|->
name|releaseMouse
argument_list|(
name|qwsServerPrivate
operator|->
name|mouseGrabber
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary mouse driver.      Note that this function can only be used in the server process.      \sa setMouseHandler(), openMouse(), closeMouse() */
end_comment
begin_function
DECL|function|mouseHandler
name|QWSMouseHandler
modifier|*
name|QWSServer
operator|::
name|mouseHandler
parameter_list|()
block|{
if|if
condition|(
name|qwsServerPrivate
operator|->
name|mousehandlers
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|qwsServerPrivate
operator|->
name|mousehandlers
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns list of all mouse handlers      Note that this function can only be used in the server process.      \sa mouseHandler(), setMouseHandler(), openMouse(), closeMouse() */
end_comment
begin_function
DECL|function|mouseHandlers
specifier|const
name|QList
argument_list|<
name|QWSMouseHandler
modifier|*
argument_list|>
modifier|&
name|QWSServer
operator|::
name|mouseHandlers
parameter_list|()
block|{
return|return
name|qwsServerPrivate
operator|->
name|mousehandlers
return|;
block|}
end_function
begin_comment
comment|// called by QWSMouseHandler constructor, not user code.
end_comment
begin_comment
comment|/*!     \fn void QWSServer::setMouseHandler(QWSMouseHandler* driver)      Sets the primary mouse driver to be the given \a driver.      \l{Qt for Embedded Linux} provides several ready-made mouse drivers, and     custom drivers are typically added using Qt's plugin     mechanism. See the \l{Qt for Embedded Linux Pointer Handling} documentation     for details.      Note that this function can only be used in the server process.      \sa mouseHandler(), setDefaultMouse() */
end_comment
begin_function
DECL|function|setMouseHandler
name|void
name|QWSServer
operator|::
name|setMouseHandler
parameter_list|(
name|QWSMouseHandler
modifier|*
name|mh
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mh
condition|)
return|return;
name|qwsServerPrivate
operator|->
name|mousehandlers
operator|.
name|removeAll
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|mousehandlers
operator|.
name|prepend
argument_list|(
name|mh
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   \obsolete   Caller owns data in list, and must delete contents */
end_comment
begin_function
DECL|function|windowList
name|QList
argument_list|<
name|QWSInternalWindowInfo
modifier|*
argument_list|>
modifier|*
name|QWSServer
operator|::
name|windowList
parameter_list|()
block|{
name|QList
argument_list|<
name|QWSInternalWindowInfo
modifier|*
argument_list|>
modifier|*
name|ret
init|=
operator|new
name|QList
argument_list|<
name|QWSInternalWindowInfo
operator|*
argument_list|>
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qwsServerPrivate
operator|->
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|window
init|=
name|qwsServerPrivate
operator|->
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QWSInternalWindowInfo
modifier|*
name|qwi
init|=
operator|new
name|QWSInternalWindowInfo
argument_list|()
decl_stmt|;
name|qwi
operator|->
name|winid
operator|=
name|window
operator|->
name|winId
argument_list|()
expr_stmt|;
name|qwi
operator|->
name|clientid
operator|=
name|window
operator|->
name|client
argument_list|()
operator|->
name|clientId
argument_list|()
expr_stmt|;
name|ret
operator|->
name|append
argument_list|(
name|qwi
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COP
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|sendQCopEvent
name|void
name|QWSServerPrivate
operator|::
name|sendQCopEvent
parameter_list|(
name|QWSClient
modifier|*
name|c
parameter_list|,
specifier|const
name|QString
modifier|&
name|ch
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|bool
name|response
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|QWSQCopMessageEvent
name|event
decl_stmt|;
name|event
operator|.
name|channel
operator|=
name|ch
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|event
operator|.
name|message
operator|=
name|msg
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|event
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|is_response
operator|=
name|response
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|lchannel
operator|=
name|ch
operator|.
name|length
argument_list|()
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|lmessage
operator|=
name|msg
operator|.
name|length
argument_list|()
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|ldata
operator|=
name|data
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|l
init|=
name|event
operator|.
name|simpleData
operator|.
name|lchannel
operator|+
name|event
operator|.
name|simpleData
operator|.
name|lmessage
operator|+
name|event
operator|.
name|simpleData
operator|.
name|ldata
decl_stmt|;
comment|// combine channel, message and data into one block of raw bytes
name|char
modifier|*
name|tmp
init|=
operator|new
name|char
index|[
name|l
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|tmp
decl_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|event
operator|.
name|channel
operator|.
name|constData
argument_list|()
argument_list|,
name|event
operator|.
name|simpleData
operator|.
name|lchannel
argument_list|)
expr_stmt|;
name|d
operator|+=
name|event
operator|.
name|simpleData
operator|.
name|lchannel
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|event
operator|.
name|message
operator|.
name|constData
argument_list|()
argument_list|,
name|event
operator|.
name|simpleData
operator|.
name|lmessage
argument_list|)
expr_stmt|;
name|d
operator|+=
name|event
operator|.
name|simpleData
operator|.
name|lmessage
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|event
operator|.
name|simpleData
operator|.
name|ldata
argument_list|)
expr_stmt|;
name|event
operator|.
name|setDataDirect
argument_list|(
name|tmp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|c
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QWSWindow *QWSServer::windowAt(const QPoint& position)      Returns the window containing the given \a position.      Note that if there is no window under the specified point this     function returns 0.      \sa clientWindows(), instance() */
end_comment
begin_function
DECL|function|windowAt
name|QWSWindow
modifier|*
name|QWSServer
operator|::
name|windowAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|d
operator|->
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|allocatedRegion
argument_list|()
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return
name|w
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
end_ifndef
begin_function
DECL|function|keyUnicode
specifier|static
name|int
name|keyUnicode
parameter_list|(
name|int
name|keycode
parameter_list|)
block|{
name|int
name|code
init|=
literal|0xffff
decl_stmt|;
if|if
condition|(
name|keycode
operator|>=
name|Qt
operator|::
name|Key_A
operator|&&
name|keycode
operator|<=
name|Qt
operator|::
name|Key_Z
condition|)
name|code
operator|=
name|keycode
operator|-
name|Qt
operator|::
name|Key_A
operator|+
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|keycode
operator|>=
name|Qt
operator|::
name|Key_0
operator|&&
name|keycode
operator|<=
name|Qt
operator|::
name|Key_9
condition|)
name|code
operator|=
name|keycode
operator|-
name|Qt
operator|::
name|Key_0
operator|+
literal|'0'
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Sends the given key event. The key is identified by its \a unicode     value and the given \a keycode, \a modifiers, \a isPress and \a     autoRepeat parameters.      Use this function to send key events generated by "virtual     keyboards" (note that the processKeyEvent() function is     impelemented using this function).      The \a keycode parameter is the Qt keycode value as defined by the     Qt::Key enum. The \a modifiers is an OR combination of     Qt::KeyboardModifier values, indicating whether \gui     Shift/Alt/Ctrl keys are pressed. The \a isPress parameter is true     if the event is a key press event and \a autoRepeat is true if the     event is caused by an auto-repeat mechanism and not an actual key     press.      Note that this function can only be used in the server process.      \sa processKeyEvent(), {Qt for Embedded Linux Character Input} */
end_comment
begin_function
DECL|function|sendKeyEvent
name|void
name|QWSServer
operator|::
name|sendKeyEvent
parameter_list|(
name|int
name|unicode
parameter_list|,
name|int
name|keycode
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|,
name|bool
name|isPress
parameter_list|,
name|bool
name|autoRepeat
parameter_list|)
block|{
name|qws_keyModifiers
operator|=
name|modifiers
expr_stmt|;
if|if
condition|(
name|isPress
condition|)
block|{
if|if
condition|(
name|keycode
operator|!=
name|Qt
operator|::
name|Key_F34
operator|&&
name|keycode
operator|!=
name|Qt
operator|::
name|Key_F35
condition|)
name|qwsServerPrivate
operator|->
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
if|if
condition|(
operator|!
name|current_IM
operator|||
operator|!
name|current_IM
operator|->
name|filter
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
condition|)
name|QWSServerPrivate
operator|::
name|sendKeyEventUnfiltered
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
expr_stmt|;
else|#
directive|else
name|QWSServerPrivate
operator|::
name|sendKeyEventUnfiltered
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sendKeyEventUnfiltered
name|void
name|QWSServerPrivate
operator|::
name|sendKeyEventUnfiltered
parameter_list|(
name|int
name|unicode
parameter_list|,
name|int
name|keycode
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|,
name|bool
name|isPress
parameter_list|,
name|bool
name|autoRepeat
parameter_list|)
block|{
name|QWSKeyEvent
name|event
decl_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
name|keyboardGrabber
condition|?
name|keyboardGrabber
else|:
name|qwsServerPrivate
operator|->
name|focusw
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|win
condition|?
name|win
operator|->
name|winId
argument_list|()
else|:
literal|0
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|unicode
operator|=
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
name|unicode
operator|<
literal|0
condition|?
name|keyUnicode
argument_list|(
name|keycode
argument_list|)
else|:
endif|#
directive|endif
name|unicode
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|keycode
operator|=
name|keycode
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|modifiers
operator|=
name|modifiers
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|is_press
operator|=
name|isPress
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|is_auto_repeat
operator|=
name|autoRepeat
expr_stmt|;
name|QWSClient
modifier|*
name|serverClient
init|=
name|qwsServerPrivate
operator|->
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QWSClient
modifier|*
name|winClient
init|=
name|win
condition|?
name|win
operator|->
name|client
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|serverClient
condition|)
name|serverClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|winClient
operator|&&
name|winClient
operator|!=
name|serverClient
condition|)
name|winClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|beginDisplayReconfigure
name|void
name|QWSServer
operator|::
name|beginDisplayReconfigure
parameter_list|()
block|{
name|qwsServer
operator|->
name|enablePainting
argument_list|(
literal|false
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|hide
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QWSDisplay
operator|::
name|grab
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qt_screen
operator|->
name|disconnect
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|endDisplayReconfigure
name|void
name|QWSServer
operator|::
name|endDisplayReconfigure
parameter_list|()
block|{
name|qt_screen
operator|->
name|connect
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|swidth
operator|=
name|qt_screen
operator|->
name|deviceWidth
argument_list|()
expr_stmt|;
name|qwsServerPrivate
operator|->
name|sheight
operator|=
name|qt_screen
operator|->
name|deviceHeight
argument_list|()
expr_stmt|;
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|show
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QApplicationPrivate
modifier|*
name|ap
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
name|ap
operator|->
name|setMaxWindowRect
argument_list|(
name|qt_screen
argument_list|,
literal|0
argument_list|,
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qt_screen
operator|->
name|width
argument_list|()
argument_list|,
name|qt_screen
operator|->
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QSize
name|olds
init|=
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|size
argument_list|()
decl_stmt|;
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|resize
argument_list|(
name|qt_screen
operator|->
name|width
argument_list|()
argument_list|,
name|qt_screen
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|qApp
operator|->
name|postEvent
argument_list|(
name|qApp
operator|->
name|desktop
argument_list|()
argument_list|,
operator|new
name|QResizeEvent
argument_list|(
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|size
argument_list|()
argument_list|,
name|olds
argument_list|)
argument_list|)
expr_stmt|;
name|qwsServer
operator|->
name|enablePainting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qwsServer
operator|->
name|refresh
argument_list|()
expr_stmt|;
name|qDebug
argument_list|(
literal|"Desktop size: %dx%d"
argument_list|,
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|width
argument_list|()
argument_list|,
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resetEngine
name|void
name|QWSServerPrivate
operator|::
name|resetEngine
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
operator|!
name|qt_screencursor
condition|)
return|return;
name|qt_screencursor
operator|->
name|hide
argument_list|()
expr_stmt|;
name|qt_screencursor
operator|->
name|show
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
end_ifndef
begin_comment
comment|/*!     \fn void QWSServer::setCursorVisible(bool visible)      Shows the cursor if \a visible is true: otherwise the cursor is     hidden.      Note that this function can only be used in the server process.      \sa isCursorVisible() */
end_comment
begin_function
DECL|function|setCursorVisible
name|void
name|QWSServer
operator|::
name|setCursorVisible
parameter_list|(
name|bool
name|vis
parameter_list|)
block|{
if|if
condition|(
name|qwsServerPrivate
operator|&&
name|qwsServerPrivate
operator|->
name|haveviscurs
operator|!=
name|vis
condition|)
block|{
name|QWSCursor
modifier|*
name|c
init|=
name|qwsServerPrivate
operator|->
name|cursor
decl_stmt|;
name|qwsServerPrivate
operator|->
name|setCursor
argument_list|(
name|QWSCursor
operator|::
name|systemCursor
argument_list|(
name|Qt
operator|::
name|BlankCursor
argument_list|)
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|haveviscurs
operator|=
name|vis
expr_stmt|;
name|qwsServerPrivate
operator|->
name|setCursor
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if the cursor is visible; otherwise returns false.      Note that this function can only be used in the server process.      \sa setCursorVisible() */
end_comment
begin_function
DECL|function|isCursorVisible
name|bool
name|QWSServer
operator|::
name|isCursorVisible
parameter_list|()
block|{
return|return
name|qwsServerPrivate
condition|?
name|qwsServerPrivate
operator|->
name|haveviscurs
else|:
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
end_ifndef
begin_comment
comment|/*!     \fn void QWSServer::sendIMEvent(const QInputMethodEvent *event)      Sends the given input method \a event.      The \c QInputMethodEvent class is derived from QWSEvent, i.e., it     is a QWSEvent object of the QWSEvent::IMEvent type.      If there is a window actively composing the preedit string, the     event is sent to that window. Otherwise, the event is sent to the     window currently in focus.      \sa sendIMQuery(), QWSInputMethod::sendEvent() */
end_comment
begin_function
DECL|function|sendIMEvent
name|void
name|QWSServer
operator|::
name|sendIMEvent
parameter_list|(
specifier|const
name|QInputMethodEvent
modifier|*
name|ime
parameter_list|)
block|{
name|QWSIMEvent
name|event
decl_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
name|keyboardGrabber
condition|?
name|keyboardGrabber
else|:
name|qwsServerPrivate
operator|->
name|focusw
decl_stmt|;
comment|//if currently composing then event must go to the composing window
if|if
condition|(
name|current_IM_composing_win
condition|)
name|win
operator|=
name|current_IM_composing_win
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|win
condition|?
name|win
operator|->
name|winId
argument_list|()
else|:
literal|0
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|replaceFrom
operator|=
name|ime
operator|->
name|replacementStart
argument_list|()
expr_stmt|;
empty_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|replaceLength
operator|=
name|ime
operator|->
name|replacementLength
argument_list|()
expr_stmt|;
name|QBuffer
name|buffer
decl_stmt|;
name|buffer
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QDataStream
name|out
argument_list|(
operator|&
name|buffer
argument_list|)
decl_stmt|;
name|out
operator|<<
name|ime
operator|->
name|preeditString
argument_list|()
expr_stmt|;
name|out
operator|<<
name|ime
operator|->
name|commitString
argument_list|()
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
modifier|&
name|attributes
init|=
name|ime
operator|->
name|attributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QInputMethodEvent
operator|::
name|Attribute
modifier|&
name|a
init|=
name|attributes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|out
operator|<<
name|a
operator|.
name|type
operator|<<
name|a
operator|.
name|start
operator|<<
name|a
operator|.
name|length
operator|<<
name|a
operator|.
name|value
expr_stmt|;
block|}
name|event
operator|.
name|setData
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QWSClient
modifier|*
name|serverClient
init|=
name|qwsServerPrivate
operator|->
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverClient
condition|)
name|serverClient
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
name|win
operator|->
name|client
argument_list|()
operator|&&
name|win
operator|->
name|client
argument_list|()
operator|!=
name|serverClient
condition|)
name|win
operator|->
name|client
argument_list|()
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|current_IM_composing_win
operator|=
name|ime
operator|->
name|preeditString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|win
expr_stmt|;
name|current_IM_winId
operator|=
name|win
condition|?
name|win
operator|->
name|winId
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sends an input method query for the given \a property.      To receive responses to input method queries, the virtual     QWSInputMethod::queryResponse() function must be reimplemented in     a QWSInputMethod subclass that is activated using the     setCurrentInputMethod() function.      \sa sendIMEvent(), setCurrentInputMethod() */
end_comment
begin_function
DECL|function|sendIMQuery
name|void
name|QWSServer
operator|::
name|sendIMQuery
parameter_list|(
name|int
name|property
parameter_list|)
block|{
name|QWSIMQueryEvent
name|event
decl_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
name|keyboardGrabber
condition|?
name|keyboardGrabber
else|:
name|qwsServerPrivate
operator|->
name|focusw
decl_stmt|;
if|if
condition|(
name|current_IM_composing_win
condition|)
name|win
operator|=
name|current_IM_composing_win
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|window
operator|=
name|win
condition|?
name|win
operator|->
name|winId
argument_list|()
else|:
literal|0
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|property
operator|=
name|property
expr_stmt|;
if|if
condition|(
name|win
operator|&&
name|win
operator|->
name|client
argument_list|()
condition|)
name|win
operator|->
name|client
argument_list|()
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setCurrentInputMethod(QWSInputMethod *method)      Sets the current input method to be the given \a method.      Note that this function can only be used in the server process.      \sa sendIMQuery(), sendIMEvent() */
end_comment
begin_function
DECL|function|setCurrentInputMethod
name|void
name|QWSServer
operator|::
name|setCurrentInputMethod
parameter_list|(
name|QWSInputMethod
modifier|*
name|im
parameter_list|)
block|{
if|if
condition|(
name|current_IM
condition|)
name|current_IM
operator|->
name|reset
argument_list|()
expr_stmt|;
comment|//??? send an update event instead ?
name|current_IM
operator|=
name|im
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn static void QWSServer::resetInputMethod()      \internal */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_QWS_INPUTMETHODS
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|sendPropertyNotifyEvent
name|void
name|QWSServer
operator|::
name|sendPropertyNotifyEvent
parameter_list|(
name|int
name|property
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSServerPrivate
operator|::
name|ClientIterator
name|it
init|=
name|d
operator|->
name|clientMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|clientMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|QWSClient
modifier|*
name|cl
init|=
operator|*
name|it
decl_stmt|;
operator|++
name|it
expr_stmt|;
name|cl
operator|->
name|sendPropertyNotifyEvent
argument_list|(
name|property
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|invokeIdentify
name|void
name|QWSServerPrivate
operator|::
name|invokeIdentify
parameter_list|(
specifier|const
name|QWSIdentifyCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|client
operator|->
name|setIdentity
argument_list|(
name|cmd
operator|->
name|id
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|client
operator|->
name|clientId
argument_list|()
operator|>
literal|0
condition|)
name|client
operator|->
name|d_func
argument_list|()
operator|->
name|setLockId
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|idLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|invokeCreate
name|void
name|QWSServerPrivate
operator|::
name|invokeCreate
parameter_list|(
name|QWSCreateCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QWSCreationEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|objectid
operator|=
name|get_object_id
argument_list|(
name|cmd
operator|->
name|count
argument_list|)
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|count
operator|=
name|cmd
operator|->
name|count
expr_stmt|;
name|client
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeRegionName
name|void
name|QWSServerPrivate
operator|::
name|invokeRegionName
parameter_list|(
specifier|const
name|QWSRegionNameCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|client
argument_list|)
decl_stmt|;
if|if
condition|(
name|changingw
operator|&&
operator|(
name|changingw
operator|->
name|name
argument_list|()
operator|!=
name|cmd
operator|->
name|name
operator|||
name|changingw
operator|->
name|caption
argument_list|()
operator|!=
name|cmd
operator|->
name|caption
operator|)
condition|)
block|{
name|changingw
operator|->
name|setName
argument_list|(
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|changingw
operator|->
name|setCaption
argument_list|(
name|cmd
operator|->
name|caption
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Name
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|invokeRegion
name|void
name|QWSServerPrivate
operator|::
name|invokeRegion
parameter_list|(
name|QWSRegionCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QWS_REGION_DEBUG
name|qDebug
argument_list|(
literal|"QWSServer::invokeRegion %d rects (%d)"
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|nrectangles
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"Invalid window handle %08x"
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|changingw
operator|->
name|forClient
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Disabled: clients changing other client's window region"
argument_list|)
expr_stmt|;
return|return;
block|}
name|request_region
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|surfaceKey
argument_list|,
name|cmd
operator|->
name|surfaceData
argument_list|,
name|cmd
operator|->
name|region
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeRegionMove
name|void
name|QWSServerPrivate
operator|::
name|invokeRegionMove
parameter_list|(
specifier|const
name|QWSRegionMoveCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"invokeRegionMove: Invalid window handle %d"
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|changingw
operator|->
name|forClient
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Disabled: clients changing other client's window region"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//    changingw->setNeedAck(true);
name|moveWindowRegion
argument_list|(
name|changingw
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|dx
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|dy
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Geometry
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|invokeRegionDestroy
name|void
name|QWSServerPrivate
operator|::
name|invokeRegionDestroy
parameter_list|(
specifier|const
name|QWSRegionDestroyCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"invokeRegionDestroy: Invalid window handle %d"
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|changingw
operator|->
name|forClient
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Disabled: clients changing other client's window region"
argument_list|)
expr_stmt|;
return|return;
block|}
name|setWindowRegion
argument_list|(
name|changingw
argument_list|,
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
comment|//    rgnMan->remove(changingw->allocationIndex());
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|changingw
condition|)
block|{
name|windows
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nReserved
condition|)
operator|--
name|nReserved
expr_stmt|;
break|break;
block|}
block|}
name|handleWindowClose
argument_list|(
name|changingw
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
name|propertyManager
operator|.
name|removeProperties
argument_list|(
name|changingw
operator|->
name|winId
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Destroy
argument_list|)
emit|;
operator|delete
name|changingw
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeSetFocus
name|void
name|QWSServerPrivate
operator|::
name|invokeSetFocus
parameter_list|(
specifier|const
name|QWSRequestFocusCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|int
name|winId
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
decl_stmt|;
name|int
name|gain
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|flag
decl_stmt|;
if|if
condition|(
name|gain
operator|!=
literal|0
operator|&&
name|gain
operator|!=
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"Only 0(lose) and 1(gain) supported"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|winId
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
return|return;
if|if
condition|(
operator|!
name|changingw
operator|->
name|forClient
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Disabled: clients changing other client's focus"
argument_list|)
expr_stmt|;
return|return;
block|}
name|setFocus
argument_list|(
name|changingw
argument_list|,
name|gain
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFocus
name|void
name|QWSServerPrivate
operator|::
name|setFocus
parameter_list|(
name|QWSWindow
modifier|*
name|changingw
parameter_list|,
name|bool
name|gain
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
comment|/*       This is the logic:       QWSWindow *loser = 0;       if (gain&& focusw != changingw)          loser = focusw;       else if (!gain&& focusw == changingw)          loser = focusw;       But these five lines can be reduced to one:     */
if|if
condition|(
name|current_IM
condition|)
block|{
name|QWSWindow
modifier|*
name|loser
init|=
operator|(
operator|!
name|gain
operator|==
operator|(
name|focusw
operator|==
name|changingw
operator|)
operator|)
condition|?
name|focusw
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|loser
operator|&&
name|loser
operator|->
name|winId
argument_list|()
operator|==
name|current_IM_winId
condition|)
name|current_IM
operator|->
name|updateHandler
argument_list|(
name|QWSInputMethod
operator|::
name|FocusOut
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|gain
condition|)
block|{
if|if
condition|(
name|focusw
operator|!=
name|changingw
condition|)
block|{
if|if
condition|(
name|focusw
condition|)
name|focusw
operator|->
name|focus
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|focusw
operator|=
name|changingw
expr_stmt|;
name|focusw
operator|->
name|focus
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|focusw
argument_list|,
name|QWSServer
operator|::
name|Active
argument_list|)
emit|;
block|}
block|}
elseif|else
if|if
condition|(
name|focusw
operator|==
name|changingw
condition|)
block|{
if|if
condition|(
name|changingw
operator|->
name|client
argument_list|()
condition|)
name|changingw
operator|->
name|focus
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|focusw
operator|=
literal|0
expr_stmt|;
comment|// pass focus to window which most recently got it...
name|QWSWindow
modifier|*
name|bestw
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|changingw
operator|&&
operator|!
name|w
operator|->
name|hidden
argument_list|()
operator|&&
operator|(
operator|!
name|bestw
operator|||
name|bestw
operator|->
name|focusPriority
argument_list|()
operator|<
name|w
operator|->
name|focusPriority
argument_list|()
operator|)
condition|)
name|bestw
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bestw
operator|&&
name|changingw
operator|->
name|focusPriority
argument_list|()
condition|)
block|{
comment|// accept focus back?
name|bestw
operator|=
name|changingw
expr_stmt|;
comment|// must be the only one
block|}
name|focusw
operator|=
name|bestw
expr_stmt|;
if|if
condition|(
name|focusw
condition|)
block|{
name|focusw
operator|->
name|focus
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|focusw
argument_list|,
name|QWSServer
operator|::
name|Active
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|invokeSetOpacity
name|void
name|QWSServerPrivate
operator|::
name|invokeSetOpacity
parameter_list|(
specifier|const
name|QWSSetOpacityCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|int
name|winId
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
decl_stmt|;
name|int
name|opacity
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|opacity
decl_stmt|;
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|winId
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"invokeSetOpacity: Invalid window handle %d"
argument_list|,
name|winId
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|altitude
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|changingw
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|wasOpaque
init|=
name|changingw
operator|->
name|isOpaque
argument_list|()
decl_stmt|;
name|changingw
operator|->
name|_opacity
operator|=
name|opacity
expr_stmt|;
if|if
condition|(
name|wasOpaque
operator|!=
name|changingw
operator|->
name|isOpaque
argument_list|()
condition|)
name|update_regions
argument_list|()
expr_stmt|;
name|exposeRegion
argument_list|(
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|,
name|altitude
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeSetAltitude
name|void
name|QWSServerPrivate
operator|::
name|invokeSetAltitude
parameter_list|(
specifier|const
name|QWSChangeAltitudeCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|int
name|winId
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
decl_stmt|;
name|int
name|alt
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|altitude
decl_stmt|;
name|bool
name|fixed
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|fixed
decl_stmt|;
if|#
directive|if
literal|0
block|qDebug("QWSServer::invokeSetAltitude winId %d alt %d)", winId, alt);
endif|#
directive|endif
if|if
condition|(
name|alt
argument_list|<
operator|-
literal|1
operator|||
name|alt
argument_list|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWSServer::invokeSetAltitude Only lower, raise and stays-on-top supported"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|winId
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"invokeSetAltitude: Invalid window handle %d"
argument_list|,
name|winId
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fixed
operator|&&
name|alt
operator|>=
literal|1
condition|)
block|{
name|changingw
operator|->
name|onTop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|==
name|QWSChangeAltitudeCommand
operator|::
name|Lower
condition|)
name|changingw
operator|->
name|lower
argument_list|()
expr_stmt|;
else|else
name|changingw
operator|->
name|raise
argument_list|()
expr_stmt|;
comment|//      if (!changingw->forClient(client)) {
comment|//         refresh();
comment|//     }
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_PROPERTIES
end_ifndef
begin_function
DECL|function|invokeAddProperty
name|void
name|QWSServerPrivate
operator|::
name|invokeAddProperty
parameter_list|(
name|QWSAddPropertyCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|propertyManager
operator|.
name|addProperty
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeSetProperty
name|void
name|QWSServerPrivate
operator|::
name|invokeSetProperty
parameter_list|(
name|QWSSetPropertyCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|propertyManager
operator|.
name|setProperty
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|mode
argument_list|,
name|cmd
operator|->
name|data
argument_list|,
name|cmd
operator|->
name|rawLen
argument_list|)
condition|)
block|{
name|q
operator|->
name|sendPropertyNotifyEvent
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|QWSPropertyNotifyEvent
operator|::
name|PropertyNewValue
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
operator|==
name|QT_QWS_PROPERTY_MARKEDTEXT
condition|)
block|{
name|QString
name|s
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|cmd
operator|->
name|data
argument_list|,
name|cmd
operator|->
name|rawLen
operator|/
literal|2
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|markedText
argument_list|(
name|s
argument_list|)
emit|;
block|}
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|invokeRemoveProperty
name|void
name|QWSServerPrivate
operator|::
name|invokeRemoveProperty
parameter_list|(
name|QWSRemovePropertyCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|propertyManager
operator|.
name|removeProperty
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|)
condition|)
block|{
name|q
operator|->
name|sendPropertyNotifyEvent
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|QWSPropertyNotifyEvent
operator|::
name|PropertyDeleted
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|get_property
name|bool
name|QWSServerPrivate
operator|::
name|get_property
parameter_list|(
name|int
name|winId
parameter_list|,
name|int
name|property
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|data
parameter_list|,
name|int
modifier|&
name|len
parameter_list|)
block|{
return|return
name|propertyManager
operator|.
name|getProperty
argument_list|(
name|winId
argument_list|,
name|property
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|invokeGetProperty
name|void
name|QWSServerPrivate
operator|::
name|invokeGetProperty
parameter_list|(
name|QWSGetPropertyCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|propertyManager
operator|.
name|getProperty
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|client
operator|->
name|sendPropertyReplyEvent
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|client
operator|->
name|sendPropertyReplyEvent
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_QWS_PROPERTIES
end_comment
begin_function
DECL|function|invokeSetSelectionOwner
name|void
name|QWSServerPrivate
operator|::
name|invokeSetSelectionOwner
parameter_list|(
name|QWSSetSelectionOwnerCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|qDebug
argument_list|(
literal|"QWSServer::invokeSetSelectionOwner"
argument_list|)
expr_stmt|;
name|SelectionOwner
name|so
decl_stmt|;
name|so
operator|.
name|windowid
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
expr_stmt|;
name|so
operator|.
name|time
operator|.
name|set
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|hour
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|minute
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|sec
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectionOwner
operator|.
name|windowid
operator|!=
operator|-
literal|1
condition|)
block|{
name|QWSWindow
modifier|*
name|win
init|=
name|findWindow
argument_list|(
name|selectionOwner
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|win
condition|)
name|win
operator|->
name|client
argument_list|()
operator|->
name|sendSelectionClearEvent
argument_list|(
name|selectionOwner
operator|.
name|windowid
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"couldn't find window %d"
argument_list|,
name|selectionOwner
operator|.
name|windowid
argument_list|)
expr_stmt|;
block|}
name|selectionOwner
operator|=
name|so
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeConvertSelection
name|void
name|QWSServerPrivate
operator|::
name|invokeConvertSelection
parameter_list|(
name|QWSConvertSelectionCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|qDebug
argument_list|(
literal|"QWSServer::invokeConvertSelection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectionOwner
operator|.
name|windowid
operator|!=
operator|-
literal|1
condition|)
block|{
name|QWSWindow
modifier|*
name|win
init|=
name|findWindow
argument_list|(
name|selectionOwner
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|win
condition|)
name|win
operator|->
name|client
argument_list|()
operator|->
name|sendSelectionRequestEvent
argument_list|(
name|cmd
argument_list|,
name|selectionOwner
operator|.
name|windowid
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"couldn't find window %d"
argument_list|,
name|selectionOwner
operator|.
name|windowid
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
end_ifndef
begin_function
DECL|function|invokeDefineCursor
name|void
name|QWSServerPrivate
operator|::
name|invokeDefineCursor
parameter_list|(
name|QWSDefineCursorCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|height
operator|>
literal|64
operator|||
name|cmd
operator|->
name|simpleData
operator|.
name|width
operator|>
literal|64
condition|)
block|{
name|qDebug
argument_list|(
literal|"Cannot define cursor size> 64x64"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|delete
name|client
operator|->
name|cursors
operator|.
name|take
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|id
argument_list|)
expr_stmt|;
name|int
name|dataLen
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|height
operator|*
operator|(
operator|(
name|cmd
operator|->
name|simpleData
operator|.
name|width
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|dataLen
operator|>
literal|0
operator|&&
name|cmd
operator|->
name|data
condition|)
block|{
name|QWSCursor
modifier|*
name|curs
init|=
operator|new
name|QWSCursor
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|cmd
operator|->
name|data
operator|+
name|dataLen
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|width
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|height
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|hotX
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|hotY
argument_list|)
decl_stmt|;
name|client
operator|->
name|cursors
operator|.
name|insert
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|id
argument_list|,
name|curs
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokeSelectCursor
name|void
name|QWSServerPrivate
operator|::
name|invokeSelectCursor
parameter_list|(
name|QWSSelectCursorCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|int
name|id
init|=
name|cmd
operator|->
name|simpleData
operator|.
name|id
decl_stmt|;
name|QWSCursor
modifier|*
name|curs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|id
operator|<=
name|Qt
operator|::
name|LastCursor
condition|)
block|{
name|curs
operator|=
name|QWSCursor
operator|::
name|systemCursor
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QWSCursorMap
name|cursMap
init|=
name|client
operator|->
name|cursors
decl_stmt|;
name|QWSCursorMap
operator|::
name|Iterator
name|it
init|=
name|cursMap
operator|.
name|find
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|cursMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|curs
operator|=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curs
operator|==
literal|0
condition|)
block|{
name|curs
operator|=
name|QWSCursor
operator|::
name|systemCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
expr_stmt|;
block|}
name|QWSWindow
modifier|*
name|win
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mouseGrabber
condition|)
block|{
comment|// If the mouse is being grabbed, we don't want just anyone to
comment|// be able to change the cursor.  We do want the cursor to be set
comment|// correctly once mouse grabbing is stopped though.
if|if
condition|(
name|win
operator|!=
name|mouseGrabber
condition|)
name|nextCursor
operator|=
name|curs
expr_stmt|;
else|else
name|setCursor
argument_list|(
name|curs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|win
operator|&&
name|win
operator|->
name|allocatedRegion
argument_list|()
operator|.
name|contains
argument_list|(
name|QWSServer
operator|::
name|mousePosition
argument_list|)
condition|)
block|{
comment|//##################### cursor
comment|// A non-grabbing window can only set the cursor shape if the
comment|// cursor is within its allocated region.
name|setCursor
argument_list|(
name|curs
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokePositionCursor
name|void
name|QWSServerPrivate
operator|::
name|invokePositionCursor
parameter_list|(
name|QWSPositionCursorCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QPoint
name|newPos
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|newX
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|newY
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPos
operator|!=
name|QWSServer
operator|::
name|mousePosition
condition|)
name|q
operator|->
name|sendMouseEvent
argument_list|(
name|newPos
argument_list|,
name|qwsServer
operator|->
name|d_func
argument_list|()
operator|->
name|mouseState
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|invokeGrabMouse
name|void
name|QWSServerPrivate
operator|::
name|invokeGrabMouse
parameter_list|(
name|QWSGrabMouseCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QWSWindow
modifier|*
name|win
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
return|return;
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|grab
condition|)
block|{
if|if
condition|(
operator|!
name|mouseGrabber
operator|||
name|mouseGrabber
operator|->
name|client
argument_list|()
operator|==
name|client
condition|)
block|{
name|mouseGrabbing
operator|=
literal|true
expr_stmt|;
name|mouseGrabber
operator|=
name|win
expr_stmt|;
block|}
block|}
else|else
block|{
name|releaseMouse
argument_list|(
name|mouseGrabber
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokeGrabKeyboard
name|void
name|QWSServerPrivate
operator|::
name|invokeGrabKeyboard
parameter_list|(
name|QWSGrabKeyboardCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QWSWindow
modifier|*
name|win
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
return|return;
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|grab
condition|)
block|{
if|if
condition|(
operator|!
name|keyboardGrabber
operator|||
operator|(
name|keyboardGrabber
operator|->
name|client
argument_list|()
operator|==
name|client
operator|)
condition|)
block|{
name|keyboardGrabbing
operator|=
literal|true
expr_stmt|;
name|keyboardGrabber
operator|=
name|win
expr_stmt|;
block|}
block|}
else|else
block|{
name|releaseKeyboard
argument_list|(
name|keyboardGrabber
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SOUND
argument_list|)
end_if
begin_function
DECL|function|invokePlaySound
name|void
name|QWSServerPrivate
operator|::
name|invokePlaySound
parameter_list|(
name|QWSPlaySoundCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_EXTERNAL_SOUND_SERVER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
name|soundserver
operator|->
name|playFile
argument_list|(
literal|1
argument_list|,
name|cmd
operator|->
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COP
end_ifndef
begin_function
DECL|function|invokeRegisterChannel
name|void
name|QWSServerPrivate
operator|::
name|invokeRegisterChannel
parameter_list|(
name|QWSQCopRegisterChannelCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
comment|// QCopChannel will force us to emit the newChannel signal if this channel
comment|// didn't already exist.
name|QCopChannel
operator|::
name|registerChannel
argument_list|(
name|cmd
operator|->
name|channel
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeQCopSend
name|void
name|QWSServerPrivate
operator|::
name|invokeQCopSend
parameter_list|(
name|QWSQCopSendCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QCopChannel
operator|::
name|answer
argument_list|(
name|client
argument_list|,
name|cmd
operator|->
name|channel
argument_list|,
name|cmd
operator|->
name|message
argument_list|,
name|cmd
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
end_ifndef
begin_function
DECL|function|resetInputMethod
name|void
name|QWSServer
operator|::
name|resetInputMethod
parameter_list|()
block|{
if|if
condition|(
name|current_IM
operator|&&
name|qwsServer
condition|)
block|{
name|current_IM
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokeIMResponse
name|void
name|QWSServerPrivate
operator|::
name|invokeIMResponse
parameter_list|(
specifier|const
name|QWSIMResponseCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|current_IM
condition|)
name|current_IM
operator|->
name|queryResponse
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|property
argument_list|,
name|cmd
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeIMUpdate
name|void
name|QWSServerPrivate
operator|::
name|invokeIMUpdate
parameter_list|(
specifier|const
name|QWSIMUpdateCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|type
operator|==
name|QWSInputMethod
operator|::
name|FocusIn
condition|)
name|current_IM_winId
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
expr_stmt|;
if|if
condition|(
name|current_IM
operator|&&
operator|(
name|current_IM_winId
operator|==
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
operator|||
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
operator|==
operator|-
literal|1
operator|)
condition|)
name|current_IM
operator|->
name|updateHandler
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|invokeFont
name|void
name|QWSServerPrivate
operator|::
name|invokeFont
parameter_list|(
specifier|const
name|QWSFontCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|QWSClientPrivate
modifier|*
name|priv
init|=
name|client
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|type
operator|==
name|QWSFontCommand
operator|::
name|StartedUsingFont
condition|)
block|{
name|referenceFont
argument_list|(
name|priv
argument_list|,
name|cmd
operator|->
name|fontName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|type
operator|==
name|QWSFontCommand
operator|::
name|StoppedUsingFont
condition|)
block|{
name|dereferenceFont
argument_list|(
name|priv
argument_list|,
name|cmd
operator|->
name|fontName
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokeRepaintRegion
name|void
name|QWSServerPrivate
operator|::
name|invokeRepaintRegion
parameter_list|(
name|QWSRepaintRegionCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
parameter_list|)
block|{
name|QRegion
name|r
decl_stmt|;
name|r
operator|.
name|setRects
argument_list|(
name|cmd
operator|->
name|rectangles
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|nrectangles
argument_list|)
expr_stmt|;
name|repaint_region
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|windowid
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|windowFlags
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|opaque
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
end_ifndef
begin_function
DECL|function|invokeEmbed
name|void
name|QWSServerPrivate
operator|::
name|invokeEmbed
parameter_list|(
name|QWSEmbedCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
comment|// Should find these two windows in a single loop
name|QWSWindow
modifier|*
name|embedder
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|embedder
argument_list|,
name|client
argument_list|)
decl_stmt|;
name|QWSWindow
modifier|*
name|embedded
init|=
name|findWindow
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|embedded
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|embedder
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWSServer: Embed command from window %i failed: No such id."
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|embedder
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|embedded
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWSServer: Embed command on window %i failed: No such id."
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|embedded
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|cmd
operator|->
name|simpleData
operator|.
name|type
condition|)
block|{
case|case
name|QWSEmbedEvent
operator|::
name|StartEmbed
case|:
name|embedder
operator|->
name|startEmbed
argument_list|(
name|embedded
argument_list|)
expr_stmt|;
name|windows
operator|.
name|removeAll
argument_list|(
name|embedded
argument_list|)
expr_stmt|;
name|windows
operator|.
name|insert
argument_list|(
name|windows
operator|.
name|indexOf
argument_list|(
name|embedder
argument_list|)
argument_list|,
name|embedded
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSEmbedEvent
operator|::
name|StopEmbed
case|:
name|embedder
operator|->
name|stopEmbed
argument_list|(
name|embedded
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWSEmbedEvent
operator|::
name|Region
case|:
break|break;
block|}
name|embedded
operator|->
name|client
argument_list|()
operator|->
name|sendEmbedEvent
argument_list|(
name|embedded
operator|->
name|winId
argument_list|()
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|type
argument_list|,
name|cmd
operator|->
name|region
argument_list|)
expr_stmt|;
specifier|const
name|QRegion
name|oldAllocated
init|=
name|embedded
operator|->
name|allocatedRegion
argument_list|()
decl_stmt|;
name|update_regions
argument_list|()
expr_stmt|;
name|exposeRegion
argument_list|(
name|oldAllocated
operator|-
name|embedded
operator|->
name|allocatedRegion
argument_list|()
argument_list|,
name|windows
operator|.
name|indexOf
argument_list|(
name|embedded
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWSEMBEDWIDGET
end_comment
begin_function
DECL|function|invokeScreenTransform
name|void
name|QWSServerPrivate
operator|::
name|invokeScreenTransform
parameter_list|(
specifier|const
name|QWSScreenTransformCommand
modifier|*
name|cmd
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|QWSScreenTransformationEvent
name|event
decl_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|screen
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|screen
expr_stmt|;
name|event
operator|.
name|simpleData
operator|.
name|transformation
operator|=
name|cmd
operator|->
name|simpleData
operator|.
name|transformation
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QWSClient
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|clientMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|clientMap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|->
name|sendEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|newWindow
name|QWSWindow
modifier|*
name|QWSServerPrivate
operator|::
name|newWindow
parameter_list|(
name|int
name|id
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
comment|// Make a new window, put it on top.
name|QWSWindow
modifier|*
name|w
init|=
operator|new
name|QWSWindow
argument_list|(
name|id
argument_list|,
name|client
argument_list|)
decl_stmt|;
comment|// insert after "stays on top" windows
name|bool
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nReserved
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|win
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
operator|->
name|onTop
condition|)
block|{
name|windows
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
name|windows
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|w
argument_list|,
name|QWSServer
operator|::
name|Create
argument_list|)
emit|;
return|return
name|w
return|;
block|}
end_function
begin_function
DECL|function|findWindow
name|QWSWindow
modifier|*
name|QWSServerPrivate
operator|::
name|findWindow
parameter_list|(
name|int
name|windowid
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|winId
argument_list|()
operator|==
name|windowid
condition|)
return|return
name|w
return|;
block|}
if|if
condition|(
name|client
condition|)
return|return
name|newWindow
argument_list|(
name|windowid
argument_list|,
name|client
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|raiseWindow
name|void
name|QWSServerPrivate
operator|::
name|raiseWindow
parameter_list|(
name|QWSWindow
modifier|*
name|changingw
parameter_list|,
name|int
comment|/*alt*/
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|changingw
operator|==
name|windows
operator|.
name|first
argument_list|()
condition|)
return|return;
name|QWSWindow
operator|::
name|State
name|oldstate
init|=
name|changingw
operator|->
name|d
operator|->
name|state
decl_stmt|;
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Raising
expr_stmt|;
comment|// Expose regions previously overlapped by transparent windows
specifier|const
name|QRegion
name|bound
init|=
name|changingw
operator|->
name|allocatedRegion
argument_list|()
decl_stmt|;
name|QRegion
name|expose
decl_stmt|;
name|int
name|windowPos
init|=
literal|0
decl_stmt|;
comment|//change position in list:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|==
name|changingw
condition|)
block|{
name|windowPos
operator|=
name|i
expr_stmt|;
name|windows
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|w
operator|->
name|isOpaque
argument_list|()
condition|)
name|expose
operator|+=
operator|(
name|w
operator|->
name|allocatedRegion
argument_list|()
operator|&
name|bound
operator|)
expr_stmt|;
block|}
name|bool
name|onTop
init|=
name|changingw
operator|->
name|onTop
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
comment|// an embedded window is on top if the embedder is on top
name|QWSWindow
modifier|*
name|embedder
init|=
name|changingw
operator|->
name|d
operator|->
name|embedder
decl_stmt|;
while|while
condition|(
operator|!
name|onTop
operator|&&
name|embedder
condition|)
block|{
name|onTop
operator|=
name|embedder
operator|->
name|onTop
expr_stmt|;
name|embedder
operator|=
name|embedder
operator|->
name|d
operator|->
name|embedder
expr_stmt|;
block|}
endif|#
directive|endif
name|int
name|newPos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|onTop
condition|)
block|{
name|windows
operator|.
name|insert
argument_list|(
name|nReserved
argument_list|,
name|changingw
argument_list|)
expr_stmt|;
name|newPos
operator|=
name|nReserved
expr_stmt|;
block|}
else|else
block|{
comment|// insert after "stays on top" windows
name|bool
name|in
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nReserved
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|onTop
condition|)
block|{
name|windows
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|changingw
argument_list|)
expr_stmt|;
name|in
operator|=
literal|true
expr_stmt|;
name|newPos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|windows
operator|.
name|append
argument_list|(
name|changingw
argument_list|)
expr_stmt|;
name|newPos
operator|=
name|windows
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|windowPos
operator|!=
name|newPos
condition|)
block|{
name|update_regions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|expose
operator|.
name|isEmpty
argument_list|()
condition|)
name|exposeRegion
argument_list|(
name|expose
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|oldstate
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Raise
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|lowerWindow
name|void
name|QWSServerPrivate
operator|::
name|lowerWindow
parameter_list|(
name|QWSWindow
modifier|*
name|changingw
parameter_list|,
name|int
comment|/*alt*/
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|changingw
operator|==
name|windows
operator|.
name|last
argument_list|()
condition|)
return|return;
name|QWSWindow
operator|::
name|State
name|oldstate
init|=
name|changingw
operator|->
name|d
operator|->
name|state
decl_stmt|;
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Lowering
expr_stmt|;
name|int
name|i
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|changingw
argument_list|)
decl_stmt|;
name|int
name|newIdx
init|=
name|windows
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|windows
operator|.
name|move
argument_list|(
name|i
argument_list|,
name|newIdx
argument_list|)
expr_stmt|;
specifier|const
name|QRegion
name|bound
init|=
name|changingw
operator|->
name|allocatedRegion
argument_list|()
decl_stmt|;
name|update_regions
argument_list|()
expr_stmt|;
comment|// Expose regions previously overlapped by transparent window
if|if
condition|(
operator|!
name|changingw
operator|->
name|isOpaque
argument_list|()
condition|)
block|{
name|QRegion
name|expose
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|windows
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
operator|++
name|j
control|)
name|expose
operator|+=
operator|(
name|windows
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|->
name|allocatedRegion
argument_list|()
operator|&
name|bound
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expose
operator|.
name|isEmpty
argument_list|()
condition|)
name|exposeRegion
argument_list|(
name|expose
argument_list|,
name|newIdx
argument_list|)
expr_stmt|;
block|}
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|oldstate
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Lower
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|update_regions
name|void
name|QWSServerPrivate
operator|::
name|update_regions
parameter_list|()
block|{
if|if
condition|(
name|disablePainting
condition|)
return|return;
name|QRegion
name|available
init|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qt_screen
operator|->
name|width
argument_list|()
argument_list|,
name|qt_screen
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QRegion
name|transparentRegion
decl_stmt|;
comment|// only really needed if there are unbuffered surfaces...
specifier|const
name|bool
name|doLock
init|=
operator|(
name|clientMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|doLock
condition|)
name|QWSDisplay
operator|::
name|grab
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QRegion
name|r
init|=
operator|(
name|w
operator|->
name|requested_region
operator|&
name|available
operator|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWSEMBEDWIDGET
comment|// Subtract regions needed for embedded windows
specifier|const
name|int
name|n
init|=
name|w
operator|->
name|d
operator|->
name|embedded
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|r
operator|-=
name|w
operator|->
name|d
operator|->
name|embedded
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|allocatedRegion
argument_list|()
expr_stmt|;
comment|// Limited to the embedder region
if|if
condition|(
name|w
operator|->
name|d
operator|->
name|embedder
condition|)
name|r
operator|&=
name|w
operator|->
name|d
operator|->
name|embedder
operator|->
name|requested_region
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_QWSEMBEDWIDGET
name|QWSWindowSurface
modifier|*
name|surface
init|=
name|w
operator|->
name|windowSurface
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|opaque
init|=
name|w
operator|->
name|isOpaque
argument_list|()
operator|&&
operator|(
name|w
operator|->
name|d
operator|->
name|painted
operator|||
operator|!
name|surface
operator|||
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|opaque
condition|)
block|{
name|transparentRegion
operator|+=
name|r
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|surface
operator|&&
operator|(
name|surface
operator|->
name|isRegionReserved
argument_list|()
operator|||
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
operator|)
condition|)
name|r
operator|-=
name|transparentRegion
expr_stmt|;
name|available
operator|-=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|w
operator|->
name|allocatedRegion
argument_list|()
condition|)
block|{
name|w
operator|->
name|setAllocatedRegion
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|w
operator|->
name|client
argument_list|()
operator|->
name|sendRegionEvent
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|r
argument_list|,
name|QWSRegionEvent
operator|::
name|Allocation
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
ifdef|#
directive|ifdef
name|QT_NO_QWS_CURSOR
comment|// This optimization only really works when there isn't a crazy cursor
comment|// wizzing around.
name|QRegion
name|directPaint
init|=
operator|(
name|r
operator|-
name|transparentRegion
operator|)
decl_stmt|;
comment|// in gloal coords
if|if
condition|(
name|directPaint
operator|!=
name|w
operator|->
name|directPaintRegion
argument_list|()
condition|)
block|{
name|w
operator|->
name|setDirectPaintRegion
argument_list|(
name|directPaint
argument_list|)
expr_stmt|;
specifier|static
name|int
name|id
init|=
literal|0
decl_stmt|;
name|surface
operator|->
name|setDirectRegion
argument_list|(
name|directPaint
argument_list|,
operator|++
name|id
argument_list|)
expr_stmt|;
name|w
operator|->
name|client
argument_list|()
operator|->
name|sendRegionEvent
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|directPaint
argument_list|,
name|QWSRegionEvent
operator|::
name|DirectPaint
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|doLock
condition|)
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|moveWindowRegion
name|void
name|QWSServerPrivate
operator|::
name|moveWindowRegion
parameter_list|(
name|QWSWindow
modifier|*
name|changingw
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|changingw
condition|)
return|return;
name|QWSWindow
operator|::
name|State
name|oldState
init|=
name|changingw
operator|->
name|d
operator|->
name|state
decl_stmt|;
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Moving
expr_stmt|;
specifier|const
name|QRegion
name|oldRegion
argument_list|(
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|)
decl_stmt|;
name|changingw
operator|->
name|requested_region
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
comment|// hw: Even if the allocated region doesn't change, the requested region
comment|// region has changed and we need to send region events.
comment|// Resetting the allocated region to force update_regions to send events.
name|changingw
operator|->
name|setAllocatedRegion
argument_list|(
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
name|update_regions
argument_list|()
expr_stmt|;
specifier|const
name|QRegion
name|newRegion
argument_list|(
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|)
decl_stmt|;
name|QWSWindowSurface
modifier|*
name|surface
init|=
name|changingw
operator|->
name|windowSurface
argument_list|()
decl_stmt|;
name|QRegion
name|expose
decl_stmt|;
if|if
condition|(
name|surface
condition|)
name|expose
operator|=
name|surface
operator|->
name|move
argument_list|(
name|QPoint
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|,
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|expose
operator|=
name|oldRegion
operator|+
name|newRegion
expr_stmt|;
if|if
condition|(
operator|!
name|changingw
operator|->
name|d
operator|->
name|painted
operator|&&
operator|!
name|expose
operator|.
name|isEmpty
argument_list|()
condition|)
name|expose
operator|=
name|oldRegion
operator|-
name|newRegion
expr_stmt|;
name|int
name|idx
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|changingw
argument_list|)
decl_stmt|;
name|exposeRegion
argument_list|(
name|expose
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|oldState
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Changes the requested region of window \a changingw to \a r     If \a changingw is 0, the server's reserved region is changed. */
end_comment
begin_function
DECL|function|setWindowRegion
name|void
name|QWSServerPrivate
operator|::
name|setWindowRegion
parameter_list|(
name|QWSWindow
modifier|*
name|changingw
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
name|qWarning
argument_list|(
literal|"Not implemented in this release"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|changingw
operator|->
name|requested_region
operator|==
name|r
condition|)
return|return;
specifier|const
name|QRegion
name|oldRegion
argument_list|(
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|)
decl_stmt|;
name|changingw
operator|->
name|requested_region
operator|=
name|r
expr_stmt|;
name|update_regions
argument_list|()
expr_stmt|;
specifier|const
name|QRegion
name|newRegion
argument_list|(
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|changingw
argument_list|)
decl_stmt|;
name|exposeRegion
argument_list|(
name|oldRegion
operator|-
name|newRegion
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|exposeRegion
name|void
name|QWSServerPrivate
operator|::
name|exposeRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
name|int
name|changing
parameter_list|)
block|{
if|if
condition|(
name|disablePainting
condition|)
return|return;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|static
name|bool
name|initial
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|initial
condition|)
block|{
name|changing
operator|=
literal|0
expr_stmt|;
name|initial
operator|=
literal|false
expr_stmt|;
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|qt_screen
operator|->
name|region
argument_list|()
argument_list|,
name|changing
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|r
argument_list|,
name|changing
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Closes all pointer devices (specified by the QWS_MOUSE_PROTO     environment variable) by deleting the associated mouse drivers.      \sa openMouse(), mouseHandler() */
end_comment
begin_function
DECL|function|closeMouse
name|void
name|QWSServer
operator|::
name|closeMouse
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|mousehandlers
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousehandlers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens the mouse devices specified by the QWS_MOUSE_PROTO     environment variable. Be advised that closeMouse() is called first     to delete all the existing mouse handlers. This behaviour could be     the cause of problems if you were not expecting it.      \sa closeMouse(), mouseHandler() */
end_comment
begin_function
DECL|function|openMouse
name|void
name|QWSServer
operator|::
name|openMouse
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QString
name|mice
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|qgetenv
argument_list|(
literal|"QWS_MOUSE_PROTO"
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QWS_CASSIOPEIA
argument_list|)
if|if
condition|(
name|mice
operator|.
name|isEmpty
argument_list|()
condition|)
name|mice
operator|=
name|QLatin1String
argument_list|(
literal|"TPanel:/dev/tpanel"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mice
operator|.
name|isEmpty
argument_list|()
condition|)
name|mice
operator|=
operator|*
name|defaultMouse
argument_list|()
expr_stmt|;
name|closeMouse
argument_list|()
expr_stmt|;
name|bool
name|needviscurs
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|mice
operator|!=
name|QLatin1String
argument_list|(
literal|"None"
argument_list|)
condition|)
block|{
specifier|const
name|QStringList
name|mouse
init|=
name|mice
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|mouse
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QWSMouseHandler
modifier|*
name|handler
init|=
name|d
operator|->
name|newMouseHandler
argument_list|(
name|mouse
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|setMouseHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* XXX handle mouse cursor visibility sensibly                if (!h->inherits("QCalibratedMouseHandler"))                needviscurs = true;             */
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
name|setCursorVisible
argument_list|(
name|needviscurs
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|needviscurs
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Suspends pointer handling by deactivating all the mouse drivers     registered by the QWS_MOUSE_PROTO environment variable.       \sa resumeMouse(), QWSMouseHandler::suspend() */
end_comment
begin_function
DECL|function|suspendMouse
name|void
name|QWSServer
operator|::
name|suspendMouse
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|mousehandlers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|mousehandlers
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|suspend
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resumes pointer handling by reactivating all the mouse drivers     registered by the QWS_MOUSE_PROTO environment variable.      \sa suspendMouse(), QWSMouseHandler::resume() */
end_comment
begin_function
DECL|function|resumeMouse
name|void
name|QWSServer
operator|::
name|resumeMouse
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|mousehandlers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|mousehandlers
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|resume
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|newMouseHandler
name|QWSMouseHandler
modifier|*
name|QWSServerPrivate
operator|::
name|newMouseHandler
parameter_list|(
specifier|const
name|QString
modifier|&
name|spec
parameter_list|)
block|{
name|int
name|c
init|=
name|spec
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|mouseProto
decl_stmt|;
name|QString
name|mouseDev
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|mouseProto
operator|=
name|spec
operator|.
name|left
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mouseDev
operator|=
name|spec
operator|.
name|mid
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mouseProto
operator|=
name|spec
expr_stmt|;
block|}
name|int
name|screen
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|regexps
init|=
name|QList
argument_list|<
name|QRegExp
argument_list|>
argument_list|()
operator|<<
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|":screen=(\\d+)\\b"
argument_list|)
argument_list|)
operator|<<
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\bscreen=(\\d+):"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regexps
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRegExp
name|regexp
init|=
name|regexps
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regexp
operator|.
name|indexIn
argument_list|(
name|mouseDev
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|screen
operator|=
name|regexp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|mouseDev
operator|.
name|remove
argument_list|(
name|regexp
operator|.
name|pos
argument_list|(
literal|0
argument_list|)
argument_list|,
name|regexp
operator|.
name|matchedLength
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|QWSMouseHandler
modifier|*
name|handler
init|=
literal|0
decl_stmt|;
name|handler
operator|=
name|QMouseDriverFactory
operator|::
name|create
argument_list|(
name|mouseProto
argument_list|,
name|mouseDev
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|!=
operator|-
literal|1
condition|)
name|handler
operator|->
name|setScreen
argument_list|(
name|qt_screen
operator|->
name|subScreens
argument_list|()
operator|.
name|at
argument_list|(
name|screen
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|handler
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
end_ifndef
begin_comment
comment|/*!     Closes all the keyboard devices (specified by the QWS_KEYBOARD     environment variable) by deleting the associated keyboard     drivers.      \sa openKeyboard(),  keyboardHandler() */
end_comment
begin_function
DECL|function|closeKeyboard
name|void
name|QWSServer
operator|::
name|closeKeyboard
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|keyboardhandlers
argument_list|)
expr_stmt|;
name|d
operator|->
name|keyboardhandlers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary keyboard driver.      Note that this function can only be used in the server process.      \sa setKeyboardHandler(), openKeyboard(), closeKeyboard() */
end_comment
begin_function
DECL|function|keyboardHandler
name|QWSKeyboardHandler
modifier|*
name|QWSServer
operator|::
name|keyboardHandler
parameter_list|()
block|{
return|return
name|qwsServerPrivate
operator|->
name|keyboardhandlers
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setKeyboardHandler(QWSKeyboardHandler* driver)      Sets the primary keyboard driver to be the given \a driver.      \l{Qt for Embedded Linux} provides several ready-made keyboard drivers, and     custom drivers are typically added using Qt's plugin     mechanism. See the \l{Qt for Embedded Linux Character Input} documentation     for details.      Note that this function can only be used in the server process.      \sa keyboardHandler(), setDefaultKeyboard() */
end_comment
begin_function
DECL|function|setKeyboardHandler
name|void
name|QWSServer
operator|::
name|setKeyboardHandler
parameter_list|(
name|QWSKeyboardHandler
modifier|*
name|kh
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kh
condition|)
return|return;
name|qwsServerPrivate
operator|->
name|keyboardhandlers
operator|.
name|removeAll
argument_list|(
name|kh
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|keyboardhandlers
operator|.
name|prepend
argument_list|(
name|kh
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens the keyboard devices specified by the QWS_KEYBOARD     environment variable.      \sa closeKeyboard(), keyboardHandler() */
end_comment
begin_function
DECL|function|openKeyboard
name|void
name|QWSServer
operator|::
name|openKeyboard
parameter_list|()
block|{
name|QString
name|keyboards
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|qgetenv
argument_list|(
literal|"QWS_KEYBOARD"
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QWS_CASSIOPEIA
argument_list|)
if|if
condition|(
name|keyboards
operator|.
name|isEmpty
argument_list|()
condition|)
name|keyboards
operator|=
name|QLatin1String
argument_list|(
literal|"Buttons"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keyboards
operator|.
name|isEmpty
argument_list|()
condition|)
name|keyboards
operator|=
operator|*
name|defaultKeyboard
argument_list|()
expr_stmt|;
name|closeKeyboard
argument_list|()
expr_stmt|;
if|if
condition|(
name|keyboards
operator|==
name|QLatin1String
argument_list|(
literal|"None"
argument_list|)
condition|)
return|return;
name|QString
name|device
decl_stmt|;
name|QString
name|type
decl_stmt|;
name|QStringList
name|keyboard
init|=
name|keyboards
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|keyboard
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|QString
name|spec
init|=
name|keyboard
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|colon
init|=
name|spec
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|spec
operator|.
name|left
argument_list|(
name|colon
argument_list|)
expr_stmt|;
name|device
operator|=
name|spec
operator|.
name|mid
argument_list|(
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|spec
expr_stmt|;
name|device
operator|=
name|QString
argument_list|()
expr_stmt|;
block|}
name|QWSKeyboardHandler
modifier|*
name|handler
init|=
name|QKbdDriverFactory
operator|::
name|create
argument_list|(
name|type
argument_list|,
name|device
argument_list|)
decl_stmt|;
name|setKeyboardHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_QWS_KEYBOARD
end_comment
begin_decl_stmt
DECL|member|mousePosition
name|QPoint
name|QWSServer
operator|::
name|mousePosition
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|bgBrush
name|QBrush
modifier|*
name|QWSServerPrivate
operator|::
name|bgBrush
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|move_region
name|void
name|QWSServerPrivate
operator|::
name|move_region
parameter_list|(
specifier|const
name|QWSRegionMoveCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|QWSClient
modifier|*
name|serverClient
init|=
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|invokeRegionMove
argument_list|(
name|cmd
argument_list|,
name|serverClient
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_altitude
name|void
name|QWSServerPrivate
operator|::
name|set_altitude
parameter_list|(
specifier|const
name|QWSChangeAltitudeCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|QWSClient
modifier|*
name|serverClient
init|=
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|invokeSetAltitude
argument_list|(
name|cmd
argument_list|,
name|serverClient
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_opacity
name|void
name|QWSServerPrivate
operator|::
name|set_opacity
parameter_list|(
specifier|const
name|QWSSetOpacityCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|QWSClient
modifier|*
name|serverClient
init|=
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|invokeSetOpacity
argument_list|(
name|cmd
argument_list|,
name|serverClient
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|request_focus
name|void
name|QWSServerPrivate
operator|::
name|request_focus
parameter_list|(
specifier|const
name|QWSRequestFocusCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeSetFocus
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_identity
name|void
name|QWSServerPrivate
operator|::
name|set_identity
parameter_list|(
specifier|const
name|QWSIdentifyCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeIdentify
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|repaint_region
name|void
name|QWSServerPrivate
operator|::
name|repaint_region
parameter_list|(
name|int
name|wid
parameter_list|,
name|int
name|windowFlags
parameter_list|,
name|bool
name|opaque
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|wid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
block|{
return|return;
block|}
specifier|const
name|bool
name|isOpaque
init|=
name|changingw
operator|->
name|opaque
decl_stmt|;
specifier|const
name|bool
name|wasPainted
init|=
name|changingw
operator|->
name|d
operator|->
name|painted
decl_stmt|;
name|changingw
operator|->
name|opaque
operator|=
name|opaque
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|windowFlags
operator|=
name|QFlag
argument_list|(
name|windowFlags
argument_list|)
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|dirtyOnScreen
operator||=
name|region
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|painted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isOpaque
operator|!=
name|opaque
operator|||
operator|!
name|wasPainted
condition|)
name|update_regions
argument_list|()
expr_stmt|;
name|int
name|level
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|changingw
argument_list|)
decl_stmt|;
name|exposeRegion
argument_list|(
name|region
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|dirtyOnScreen
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reserve_region
name|QRegion
name|QWSServerPrivate
operator|::
name|reserve_region
parameter_list|(
name|QWSWindow
modifier|*
name|win
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QRegion
name|r
init|=
name|region
decl_stmt|;
name|int
name|oldPos
init|=
name|windows
operator|.
name|indexOf
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|newPos
init|=
name|oldPos
operator|<
name|nReserved
condition|?
name|nReserved
operator|-
literal|1
else|:
name|nReserved
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nReserved
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|oldPos
condition|)
block|{
name|QWSWindow
modifier|*
name|w
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|r
operator|-=
name|w
operator|->
name|requested_region
expr_stmt|;
block|}
block|}
name|windows
operator|.
name|move
argument_list|(
name|oldPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|nReserved
operator|=
name|newPos
operator|+
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|request_region
name|void
name|QWSServerPrivate
operator|::
name|request_region
parameter_list|(
name|int
name|wid
parameter_list|,
specifier|const
name|QString
modifier|&
name|surfaceKey
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|surfaceData
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QWSWindow
modifier|*
name|changingw
init|=
name|findWindow
argument_list|(
name|wid
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changingw
condition|)
return|return;
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSWindow
operator|::
name|State
name|windowState
init|=
name|QWSWindow
operator|::
name|NoState
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|windowState
operator|=
name|QWSWindow
operator|::
name|Hiding
expr_stmt|;
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Hide
argument_list|)
emit|;
block|}
specifier|const
name|bool
name|wasOpaque
init|=
name|changingw
operator|->
name|opaque
decl_stmt|;
name|changingw
operator|->
name|createSurface
argument_list|(
name|surfaceKey
argument_list|,
name|surfaceData
argument_list|)
expr_stmt|;
name|QWSWindowSurface
modifier|*
name|surface
init|=
name|changingw
operator|->
name|windowSurface
argument_list|()
decl_stmt|;
name|changingw
operator|->
name|opaque
operator|=
name|surface
operator|->
name|isOpaque
argument_list|()
expr_stmt|;
name|QRegion
name|r
decl_stmt|;
if|if
condition|(
name|surface
operator|->
name|isRegionReserved
argument_list|()
condition|)
name|r
operator|=
name|reserve_region
argument_list|(
name|changingw
argument_list|,
name|region
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|region
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|changingw
operator|->
name|isVisible
argument_list|()
condition|)
name|windowState
operator|=
name|QWSWindow
operator|::
name|ChangingGeometry
expr_stmt|;
else|else
name|windowState
operator|=
name|QWSWindow
operator|::
name|Showing
expr_stmt|;
block|}
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|windowState
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
operator|&&
name|wasOpaque
operator|!=
name|changingw
operator|->
name|opaque
operator|&&
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
name|changingw
operator|->
name|requested_region
operator|=
name|QRegion
argument_list|()
expr_stmt|;
comment|// XXX: force update_regions
specifier|const
name|QRegion
name|oldAllocated
init|=
name|changingw
operator|->
name|allocatedRegion
argument_list|()
decl_stmt|;
name|setWindowRegion
argument_list|(
name|changingw
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldAllocated
operator|==
name|changingw
operator|->
name|allocatedRegion
argument_list|()
condition|)
block|{
comment|// Always send region event to the requesting window even if the
comment|// region didn't change. This is necessary as the client will reset
comment|// the clip region until an event is received.
name|changingw
operator|->
name|client
argument_list|()
operator|->
name|sendRegionEvent
argument_list|(
name|wid
argument_list|,
name|changingw
operator|->
name|allocatedRegion
argument_list|()
argument_list|,
name|QWSRegionEvent
operator|::
name|Allocation
argument_list|)
expr_stmt|;
block|}
name|surface
operator|->
name|QWindowSurface
operator|::
name|setGeometry
argument_list|(
name|r
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|windowState
operator|==
name|QWSWindow
operator|::
name|Showing
condition|)
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Show
argument_list|)
emit|;
elseif|else
if|if
condition|(
name|windowState
operator|==
name|QWSWindow
operator|::
name|ChangingGeometry
condition|)
emit|emit
name|q
operator|->
name|windowEvent
argument_list|(
name|changingw
argument_list|,
name|QWSServer
operator|::
name|Geometry
argument_list|)
emit|;
if|if
condition|(
name|windowState
operator|==
name|QWSWindow
operator|::
name|Hiding
condition|)
block|{
name|handleWindowClose
argument_list|(
name|changingw
argument_list|)
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Hidden
expr_stmt|;
name|changingw
operator|->
name|d
operator|->
name|painted
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|changingw
operator|->
name|d
operator|->
name|state
operator|=
name|QWSWindow
operator|::
name|Visible
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|destroy_region
name|void
name|QWSServerPrivate
operator|::
name|destroy_region
parameter_list|(
specifier|const
name|QWSRegionDestroyCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeRegionDestroy
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|name_region
name|void
name|QWSServerPrivate
operator|::
name|name_region
parameter_list|(
specifier|const
name|QWSRegionNameCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeRegionName
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
end_ifndef
begin_function
DECL|function|im_response
name|void
name|QWSServerPrivate
operator|::
name|im_response
parameter_list|(
specifier|const
name|QWSIMResponseCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeIMResponse
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|im_update
name|void
name|QWSServerPrivate
operator|::
name|im_update
parameter_list|(
specifier|const
name|QWSIMUpdateCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|invokeIMUpdate
argument_list|(
name|cmd
argument_list|,
name|clientMap
operator|.
name|value
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|send_im_mouse
name|void
name|QWSServerPrivate
operator|::
name|send_im_mouse
parameter_list|(
specifier|const
name|QWSIMMouseCommand
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|current_IM
condition|)
name|current_IM
operator|->
name|mouseHandler
argument_list|(
name|cmd
operator|->
name|simpleData
operator|.
name|index
argument_list|,
name|cmd
operator|->
name|simpleData
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|openDisplay
name|void
name|QWSServerPrivate
operator|::
name|openDisplay
parameter_list|()
block|{
name|qt_init_display
argument_list|()
expr_stmt|;
comment|//    rgnMan = qt_fbdpy->regionManager();
name|swidth
operator|=
name|qt_screen
operator|->
name|deviceWidth
argument_list|()
expr_stmt|;
name|sheight
operator|=
name|qt_screen
operator|->
name|deviceHeight
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeDisplay
name|void
name|QWSServerPrivate
operator|::
name|closeDisplay
parameter_list|()
block|{
if|if
condition|(
name|qt_screen
condition|)
name|qt_screen
operator|->
name|shutdownDevice
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the brush used as background in the absence of obscuring     windows.      \sa setBackground() */
end_comment
begin_function
DECL|function|backgroundBrush
specifier|const
name|QBrush
modifier|&
name|QWSServer
operator|::
name|backgroundBrush
parameter_list|()
specifier|const
block|{
return|return
operator|*
name|QWSServerPrivate
operator|::
name|bgBrush
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the brush used as background in the absence of obscuring     windows, to be the given \a brush.      Note that this function can only be used in the server process.      \sa backgroundBrush() */
end_comment
begin_function
DECL|function|setBackground
name|void
name|QWSServer
operator|::
name|setBackground
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QWSServerPrivate
operator|::
name|bgBrush
condition|)
name|QWSServerPrivate
operator|::
name|bgBrush
operator|=
operator|new
name|QBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
else|else
operator|*
name|QWSServerPrivate
operator|::
name|bgBrush
operator|=
name|brush
expr_stmt|;
if|if
condition|(
operator|!
name|qwsServer
condition|)
return|return;
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qt_screen
operator|->
name|width
argument_list|()
argument_list|,
name|qt_screen
operator|->
name|height
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_comment
comment|/*!     \fn void QWSServer::setDesktopBackground(const QImage&image)      Sets the image used as background in the absence of obscuring     windows, to be the given \a image.      Use the setBackground() function instead.      \oldcode         QImage image;         setDesktopBackground(image);     \newcode         QImage image;         setBackground(QBrush(image));     \endcode */
end_comment
begin_function
DECL|function|setDesktopBackground
name|void
name|QWSServer
operator|::
name|setDesktopBackground
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|)
block|{
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
name|setBackground
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
else|else
name|setBackground
argument_list|(
name|QBrush
argument_list|(
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|img
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setDesktopBackground(const QColor&color)     \overload      Sets the color used as background in the absence of obscuring     windows, to be the given \a color.      Use the setBackground() function instead.      \oldcode         QColor color;         setDesktopBackground(color);     \newcode         QColor color;         setBackground(QBrush(color));     \endcode */
end_comment
begin_function
DECL|function|setDesktopBackground
name|void
name|QWSServer
operator|::
name|setDesktopBackground
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
block|{
name|setBackground
argument_list|(
name|QBrush
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT3_SUPPORT
end_comment
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|startup
name|void
name|QWSServer
operator|::
name|startup
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|qwsServer
condition|)
return|return;
name|unlink
argument_list|(
name|qws_qtePipeFilename
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QWSServer
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|closedown
name|void
name|QWSServer
operator|::
name|closedown
parameter_list|()
block|{
name|QScopedPointer
argument_list|<
name|QWSServer
argument_list|>
name|server
argument_list|(
name|qwsServer
argument_list|)
decl_stmt|;
name|qwsServer
operator|=
literal|0
expr_stmt|;
name|QT_TRY
block|{
name|unlink
argument_list|(
name|qws_qtePipeFilename
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// ### TODO - what to do when we run out of memory
comment|// when calling toLatin1?
block|}
block|}
end_function
begin_function
DECL|function|emergency_cleanup
name|void
name|QWSServerPrivate
operator|::
name|emergency_cleanup
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
if|if
condition|(
name|qwsServer
condition|)
name|qwsServer
operator|->
name|closeKeyboard
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
end_ifndef
begin_decl_stmt
DECL|variable|keyFilters
specifier|static
name|QList
argument_list|<
name|QWSServer
operator|::
name|KeyboardFilter
operator|*
argument_list|>
modifier|*
name|keyFilters
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Processes the given key event. The key is identified by its \a     unicode value and the given \a keycode, \a modifiers, \a isPress     and \a autoRepeat parameters.      The \a keycode parameter is the Qt keycode value as defined by the     Qt::Key enum. The \a modifiers is an OR combination of     Qt::KeyboardModifier values, indicating whether \gui     Shift/Alt/Ctrl keys are pressed. The \a isPress parameter is true     if the event is a key press event and \a autoRepeat is true if the     event is caused by an auto-repeat mechanism and not an actual key     press.      This function is typically called internally by keyboard drivers.     Note that this function can only be used in the server process.      \sa sendKeyEvent(), {Qt for Embedded Linux Character Input} */
end_comment
begin_function
DECL|function|processKeyEvent
name|void
name|QWSServer
operator|::
name|processKeyEvent
parameter_list|(
name|int
name|unicode
parameter_list|,
name|int
name|keycode
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|,
name|bool
name|isPress
parameter_list|,
name|bool
name|autoRepeat
parameter_list|)
block|{
name|bool
name|block
decl_stmt|;
comment|// Don't block the POWER or LIGHT keys
if|if
condition|(
name|keycode
operator|==
name|Qt
operator|::
name|Key_F34
operator|||
name|keycode
operator|==
name|Qt
operator|::
name|Key_F35
condition|)
name|block
operator|=
literal|false
expr_stmt|;
else|else
name|block
operator|=
name|qwsServerPrivate
operator|->
name|screensaverblockevent
argument_list|(
name|KEY
argument_list|,
name|qwsServerPrivate
operator|->
name|screensaverinterval
argument_list|,
name|isPress
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"processKeyEvent"
operator|<<
name|unicode
operator|<<
name|keycode
operator|<<
name|modifiers
operator|<<
name|isPress
operator|<<
name|autoRepeat
operator|<<
operator|(
name|block
condition|?
literal|"block"
else|:
literal|"pass"
operator|)
expr_stmt|;
endif|#
directive|endif
comment|// If we press a key and it's going to be blocked, wake up the screen
if|if
condition|(
name|block
operator|&&
name|isPress
condition|)
name|qwsServerPrivate
operator|->
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
condition|)
return|return;
if|if
condition|(
name|keyFilters
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyFilters
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSServer
operator|::
name|KeyboardFilter
modifier|*
name|keyFilter
init|=
name|keyFilters
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyFilter
operator|->
name|filter
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
condition|)
return|return;
block|}
block|}
name|sendKeyEvent
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::addKeyboardFilter(KeyboardFilter *filter)      Activates the given keyboard \a filter all key events generated by     physical keyboard drivers (i.e., events sent using the     processKeyEvent() function).      Note that the filter is not invoked for keys generated by \e     virtual keyboard drivers (i.e., events sent using the     sendKeyEvent() function).      Note that this function can only be used in the server process.      \sa removeKeyboardFilter() */
end_comment
begin_function
DECL|function|addKeyboardFilter
name|void
name|QWSServer
operator|::
name|addKeyboardFilter
parameter_list|(
name|KeyboardFilter
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
operator|!
name|keyFilters
condition|)
name|keyFilters
operator|=
operator|new
name|QList
argument_list|<
name|QWSServer
operator|::
name|KeyboardFilter
operator|*
argument_list|>
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|keyFilters
operator|->
name|prepend
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* //#######  We should probably obsolete the whole keyboard filter thing since  it's not useful for input methods anyway   We could do removeKeyboardFilter(KeyboardFilter *f), but  the "remove and delete the filter" concept does not match "user  remembers the pointer". */
end_comment
begin_comment
comment|/*!     Removes and deletes the most recently added filter.      Note that the programmer is responsible for removing each added     keyboard filter.      Note that this function can only be used in the server process.      \sa addKeyboardFilter() */
end_comment
begin_function
DECL|function|removeKeyboardFilter
name|void
name|QWSServer
operator|::
name|removeKeyboardFilter
parameter_list|()
block|{
if|if
condition|(
operator|!
name|keyFilters
operator|||
name|keyFilters
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
operator|delete
name|keyFilters
operator|->
name|takeAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_KEYBOARD
end_comment
begin_comment
comment|/*!     \fn void QWSServer::setScreenSaverIntervals(int* intervals)      Specifies the time \a intervals (in milliseconds) between the     different levels of screen responsiveness.      \l{Qt for Embedded Linux} supports multilevel screen saving, i.e., it is     possible to specify several different levels of screen     responsiveness by implementing the QWSScreenSaver::save()     function. For example, you can choose to first turn off the light     before you fully activate the screensaver. See the QWSScreenSaver     documentation for details.      Note that an interval of 0 milliseconds will turn off the     screensaver, and that the \a intervals array must be 0-terminated.     This function can only be used in the server process.      \sa setScreenSaverInterval(), setScreenSaverBlockLevel() */
end_comment
begin_function
DECL|function|setScreenSaverIntervals
name|void
name|QWSServer
operator|::
name|setScreenSaverIntervals
parameter_list|(
name|int
modifier|*
name|ms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qwsServerPrivate
condition|)
return|return;
operator|delete
index|[]
name|qwsServerPrivate
operator|->
name|screensaverintervals
expr_stmt|;
if|if
condition|(
name|ms
condition|)
block|{
name|int
modifier|*
name|t
init|=
name|ms
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|++
expr_stmt|;
comment|// the 0
name|qwsServerPrivate
operator|->
name|screensaverintervals
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|qwsServerPrivate
operator|->
name|screensaverintervals
argument_list|,
name|ms
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qwsServerPrivate
operator|->
name|screensaverintervals
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|qwsServerPrivate
operator|->
name|screensaverintervals
operator|=
literal|0
expr_stmt|;
block|}
name|qwsServerPrivate
operator|->
name|screensaverinterval
operator|=
literal|0
expr_stmt|;
name|qwsServerPrivate
operator|->
name|screensavertimer
operator|->
name|stop
argument_list|()
expr_stmt|;
name|qt_screen
operator|->
name|blank
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qwsServerPrivate
operator|->
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setScreenSaverInterval(int milliseconds)      Sets the timeout interval for the screensaver to the specified \a     milliseconds. To turn off the screensaver, set the timout interval     to 0.      Note that this function can only be used in the server process.      \sa setScreenSaverIntervals(), setScreenSaverBlockLevel() */
end_comment
begin_function
DECL|function|setScreenSaverInterval
name|void
name|QWSServer
operator|::
name|setScreenSaverInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|int
name|v
index|[
literal|2
index|]
decl_stmt|;
name|v
index|[
literal|0
index|]
operator|=
name|ms
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|setScreenSaverIntervals
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Block the key or mouse event that wakes the system from level \a eventBlockLevel or higher.   To completely disable event blocking (the default behavior), set \a eventBlockLevel to -1.    The algorithm blocks the "down", "up" as well as any "repeat" events for the same key   but will not block other key events after the initial "down" event. For mouse events, the   algorithm blocks all mouse events until an event with no buttons pressed is received.    There are 2 keys that are never blocked, Qt::Key_F34 (POWER) and Qt::Key_F35 (LIGHT).    Example usage:    \snippet doc/src/snippets/code/src_gui_embedded_qwindowsystem_qws.cpp 0      Note that this function can only be used in the server process.    \sa setScreenSaverIntervals(), setScreenSaverInterval() */
end_comment
begin_function
DECL|function|setScreenSaverBlockLevel
name|void
name|QWSServer
operator|::
name|setScreenSaverBlockLevel
parameter_list|(
name|int
name|eventBlockLevel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qwsServerPrivate
condition|)
return|return;
name|qwsServerPrivate
operator|->
name|screensavereventblocklevel
operator|=
name|eventBlockLevel
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWSServer::setScreenSaverBlockLevel() "
operator|<<
name|eventBlockLevel
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
specifier|extern
name|bool
name|qt_disable_lowpriority_timers
decl_stmt|;
end_decl_stmt
begin_comment
comment|//in qeventloop_unix.cpp
end_comment
begin_function
DECL|function|_q_screenSaverWake
name|void
name|QWSServerPrivate
operator|::
name|_q_screenSaverWake
parameter_list|()
block|{
if|if
condition|(
name|screensaverintervals
condition|)
block|{
if|if
condition|(
name|screensaverinterval
operator|!=
name|screensaverintervals
condition|)
block|{
if|if
condition|(
name|saver
condition|)
name|saver
operator|->
name|restore
argument_list|()
expr_stmt|;
name|screensaverinterval
operator|=
name|screensaverintervals
expr_stmt|;
name|screensaverblockevents
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|screensavertimer
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|qt_screen
operator|->
name|blank
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|saver
condition|)
name|saver
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
name|screensavertimer
operator|->
name|start
argument_list|(
operator|*
name|screensaverinterval
argument_list|)
expr_stmt|;
name|screensavertime
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|qt_disable_lowpriority_timers
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_screenSaverSleep
name|void
name|QWSServerPrivate
operator|::
name|_q_screenSaverSleep
parameter_list|()
block|{
name|qt_screen
operator|->
name|blank
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_QWS_IPAQ
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_QWS_EBX
argument_list|)
name|screensavertimer
operator|->
name|stop
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|screensaverinterval
condition|)
block|{
name|screensavertimer
operator|->
name|start
argument_list|(
operator|*
name|screensaverinterval
argument_list|)
expr_stmt|;
name|screensavertime
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|screensavertimer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|qt_disable_lowpriority_timers
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSServer::setScreenSaver(QWSScreenSaver* screenSaver)      Installs the given \a screenSaver, deleting the current screen     saver.      Note that this function can only be used in the server process.      \sa screenSaverActivate(), setScreenSaverInterval(), setScreenSaverIntervals(), setScreenSaverBlockLevel() */
end_comment
begin_function
DECL|function|setScreenSaver
name|void
name|QWSServer
operator|::
name|setScreenSaver
parameter_list|(
name|QWSScreenSaver
modifier|*
name|ss
parameter_list|)
block|{
name|QWSServerPrivate
modifier|*
name|qd
init|=
name|qwsServer
operator|->
name|d_func
argument_list|()
decl_stmt|;
operator|delete
name|qd
operator|->
name|saver
expr_stmt|;
name|qd
operator|->
name|saver
operator|=
name|ss
expr_stmt|;
block|}
end_function
begin_function
DECL|function|screenSave
name|void
name|QWSServerPrivate
operator|::
name|screenSave
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|saver
condition|)
block|{
comment|// saver->save() may call QCoreApplication::processEvents,
comment|// block event before calling saver->save().
name|bool
name|oldScreensaverblockevents
init|=
name|screensaverblockevents
decl_stmt|;
if|if
condition|(
operator|*
name|screensaverinterval
operator|>=
literal|1000
condition|)
block|{
name|screensaverblockevents
operator|=
operator|(
name|screensavereventblocklevel
operator|>=
literal|0
operator|&&
name|screensavereventblocklevel
operator|<=
name|level
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT_BLOCK_DEBUG
if|if
condition|(
name|screensaverblockevents
condition|)
name|qDebug
argument_list|(
literal|"ready to block events"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|int
modifier|*
name|oldScreensaverinterval
init|=
name|screensaverinterval
decl_stmt|;
if|if
condition|(
name|saver
operator|->
name|save
argument_list|(
name|level
argument_list|)
condition|)
block|{
comment|// only update screensaverinterval if it hasn't already changed
if|if
condition|(
name|oldScreensaverinterval
operator|==
name|screensaverinterval
condition|)
block|{
if|if
condition|(
name|screensaverinterval
operator|&&
name|screensaverinterval
index|[
literal|1
index|]
condition|)
block|{
name|screensavertimer
operator|->
name|start
argument_list|(
operator|*
operator|++
name|screensaverinterval
argument_list|)
expr_stmt|;
name|screensavertime
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|screensaverinterval
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// restore previous state
name|screensaverblockevents
operator|=
name|oldScreensaverblockevents
expr_stmt|;
comment|// for some reason, the saver don't want us to change to the
comment|// next level, so we'll stay at this level for another interval
if|if
condition|(
name|screensaverinterval
operator|&&
operator|*
name|screensaverinterval
condition|)
block|{
name|screensavertimer
operator|->
name|start
argument_list|(
operator|*
name|screensaverinterval
argument_list|)
expr_stmt|;
name|screensavertime
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|screensaverinterval
operator|=
literal|0
expr_stmt|;
comment|//screensaverintervals;
name|screensaverblockevents
operator|=
literal|false
expr_stmt|;
name|_q_screenSaverSleep
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_screenSaverTimeout
name|void
name|QWSServerPrivate
operator|::
name|_q_screenSaverTimeout
parameter_list|()
block|{
if|if
condition|(
name|screensaverinterval
condition|)
block|{
if|if
condition|(
name|screensavertime
operator|.
name|elapsed
argument_list|()
operator|>
operator|*
name|screensaverinterval
operator|*
literal|2
condition|)
block|{
comment|// bogus (eg. unsuspend, system time changed)
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
comment|// try again
return|return;
block|}
name|screenSave
argument_list|(
name|screensaverinterval
operator|-
name|screensaverintervals
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if the screen saver is active; otherwise returns     false.      Note that this function can only be used in the server process.      \sa screenSaverActivate() */
end_comment
begin_function
DECL|function|screenSaverActive
name|bool
name|QWSServer
operator|::
name|screenSaverActive
parameter_list|()
block|{
return|return
name|qwsServerPrivate
operator|->
name|screensaverinterval
operator|&&
operator|!
name|qwsServerPrivate
operator|->
name|screensavertimer
operator|->
name|isActive
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateWindowRegions
name|void
name|QWSServer
operator|::
name|updateWindowRegions
parameter_list|()
specifier|const
block|{
name|qwsServerPrivate
operator|->
name|update_regions
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Activates the screen saver if \a activate is true; otherwise it is     deactivated.      Note that this function can only be used in the server process.      \sa screenSaverActive(), setScreenSaver() */
end_comment
begin_function
DECL|function|screenSaverActivate
name|void
name|QWSServer
operator|::
name|screenSaverActivate
parameter_list|(
name|bool
name|activate
parameter_list|)
block|{
if|if
condition|(
name|activate
condition|)
name|qwsServerPrivate
operator|->
name|_q_screenSaverSleep
argument_list|()
expr_stmt|;
else|else
name|qwsServerPrivate
operator|->
name|_q_screenSaverWake
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|disconnectClient
name|void
name|QWSServerPrivate
operator|::
name|disconnectClient
parameter_list|(
name|QWSClient
modifier|*
name|c
parameter_list|)
block|{
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|0
argument_list|,
name|c
argument_list|,
name|SLOT
argument_list|(
name|closeHandler
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateClientCursorPos
name|void
name|QWSServerPrivate
operator|::
name|updateClientCursorPos
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWSServer
argument_list|)
expr_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
name|qwsServerPrivate
operator|->
name|mouseGrabber
condition|?
name|qwsServerPrivate
operator|->
name|mouseGrabber
else|:
name|qwsServer
operator|->
name|windowAt
argument_list|(
name|QWSServer
operator|::
name|mousePosition
argument_list|)
decl_stmt|;
name|QWSClient
modifier|*
name|winClient
init|=
name|win
condition|?
name|win
operator|->
name|client
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|winClient
operator|&&
name|winClient
operator|!=
name|cursorClient
condition|)
name|q
operator|->
name|sendMouseEvent
argument_list|(
name|QWSServer
operator|::
name|mousePosition
argument_list|,
name|mouseState
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_INPUTMETHODS
end_ifndef
begin_comment
comment|/*!     \class QWSInputMethod     \preliminary     \ingroup qws      \brief The QWSInputMethod class provides international input methods     in Qt for Embedded Linux.      Note that this class is only available in \l{Qt for Embedded Linux}.      A \l{Qt for Embedded Linux} application requires a server application to be     running, or to be the server application itself. All system     generated events, including keyboard and mouse events, are passed     to the server application which then propagates the event to the     appropriate client.      An input method consists of a filter and optionally a graphical     interface, and is used to filter input events between the server     and the client application.      \tableofcontents      \section1 Creating Custom Input Methods      To implement a custom input method, derive from the QWSInputMethod     class, and use the server's \l     {QWSServer::}{setCurrentInputMethod()} function to install it.      When subclassing QWSInputMethod, you can reimplement the filter()     functions to handle input from both physical and virtual keyboards     as well as mouse devices. Note that the default implementations do     nothing. Use the setInputResolution() function to control the     number of bits shifted when filtering mouse input, i.e., when     going from pointer resolution to screen resolution (the current     resolution can be retrieved using the inputResolutionShift()     function).      Reimplement the reset() function to restore the state of the input     method. Note that the default implementation calls the sendEvent()     function with empty preedit and commit strings if the input method     is in compose mode (i.e., if the input method is actively     composing a preedit string).      To receive replies to an input method query (sent using the     sendQuery() function), you must reimplement the queryResponse()     function, while the mouseHandler() function must be reimplemented     if you want to handle mouse events within the preedit     text. Reimplement the updateHandler() function to handle update     events including resets and focus changes. The UpdateType enum     describes the various types of update events recognized by the     input method.      \section1 Using Input Methods      In addition to the filter(), reset(), queryResponse(),     mouseHandler() and updateHandler() function mentioned in the     previous section, the QWSInputMethod provides several other     functions helping the window system to manage the installed input     methods.      The sendEvent() function sends the given event to the focus     widget, while the sendPreeditString() function sends the given     preedit text (encapsulated by an event). QWSInputMethod also     provides the sendCommitString() convenience function which sends     an event encapsulating the given commit string to the current     focus widget, and the sendMouseEvent() function which sends the     given mouse event.      Finally, the QWSInputMethod class provides the sendQuery()     function for sending input method queries. This function     encapsulates the event with a QWSEvent instance of the \l     {QWSEvent::}{IMQuery} type.      \sa QWSServer, {Qt for Embedded Linux Architecture} */
end_comment
begin_comment
comment|/*!     Constructs a new input method.      Use the QWSServer::setCurrentInputMethod() function to install it. */
end_comment
begin_constructor
DECL|function|QWSInputMethod
name|QWSInputMethod
operator|::
name|QWSInputMethod
parameter_list|()
block|{  }
end_constructor
begin_comment
comment|/*!     Destroys this input method, uninstalling it if it is installed. */
end_comment
begin_destructor
DECL|function|~QWSInputMethod
name|QWSInputMethod
operator|::
name|~
name|QWSInputMethod
parameter_list|()
block|{
if|if
condition|(
name|current_IM
operator|==
name|this
condition|)
name|current_IM
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Filters the key input identified by the given \a unicode, \a     keycode, \a modifiers, \a isPress and \a autoRepeat parameters.      Note that the default implementation does nothing; reimplement     this function to handle input from both physical and virtual     devices.      The \a keycode is a Qt::Key value, and the \a modifiers is an OR     combination of Qt::KeyboardModifiers. The \a isPress parameter is     telling whether the input is a key press or key release, and the     \a autoRepeat parameter determines whether the input is     autorepeated ( i.e., in which case the     QWSKeyboardHandler::beginAutoRepeat() function has been called).      To block the event from further processing, return true when     reimplementing this function; the default implementation returns     false.      \sa setInputResolution(), inputResolutionShift() */
end_comment
begin_function
DECL|function|filter
name|bool
name|QWSInputMethod
operator|::
name|filter
parameter_list|(
name|int
name|unicode
parameter_list|,
name|int
name|keycode
parameter_list|,
name|int
name|modifiers
parameter_list|,
name|bool
name|isPress
parameter_list|,
name|bool
name|autoRepeat
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|keycode
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|modifiers
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|isPress
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|autoRepeat
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Filters the mouse input identified by the given \a position, \a     state, and \a wheel parameters. */
end_comment
begin_function
DECL|function|filter
name|bool
name|QWSInputMethod
operator|::
name|filter
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|position
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|wheel
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|wheel
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the state of the input method.      If the input method is in compose mode, i.e., the input method is     actively composing a preedit string, the default implementation     calls sendEvent() with empty preedit and commit strings; otherwise     it does nothing. Reimplement this function to alter this behavior.      \sa sendEvent() */
end_comment
begin_function
DECL|function|reset
name|void
name|QWSInputMethod
operator|::
name|reset
parameter_list|()
block|{
if|if
condition|(
name|current_IM_composing_win
condition|)
block|{
name|QInputMethodEvent
name|ime
decl_stmt|;
name|sendEvent
argument_list|(
operator|&
name|ime
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \enum QWSInputMethod::UpdateType      This enum describes the various types of update events recognized     by the input method.      \value Update    The input widget is updated in some way; use sendQuery() with                             Qt::ImMicroFocus as an argument for more information.     \value FocusIn   A new input widget receives focus.     \value FocusOut  The input widget loses focus.     \value Reset       The input method should be reset.     \value Destroyed The input widget is destroyed.      \sa updateHandler() */
end_comment
begin_comment
comment|/*!     Handles update events including resets and focus changes. The     update events are specified by the given \a type which is one of     the UpdateType enum values.      Note that reimplementations of this function must call the base     implementation for all cases that it does not handle itself.      \sa UpdateType */
end_comment
begin_function
DECL|function|updateHandler
name|void
name|QWSInputMethod
operator|::
name|updateHandler
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FocusOut
case|:
case|case
name|Reset
case|:
name|reset
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Receive replies to an input method query.      Note that the default implementation does nothing; reimplement     this function to receive such replies.      Internally, an input method query is passed encapsulated by an \l     {QWSEvent::IMQuery}{IMQuery} event generated by the sendQuery()     function. The queried property and the result is passed in the \a     property and \a result parameters.      \sa sendQuery(), QWSServer::sendIMQuery() */
end_comment
begin_function
DECL|function|queryResponse
name|void
name|QWSInputMethod
operator|::
name|queryResponse
parameter_list|(
name|int
name|property
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|result
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|property
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSInputMethod::mouseHandler(int offset, int state)      Handles mouse events within the preedit text.      Note that the default implementation resets the input method on     all mouse presses; reimplement this function to alter this     behavior.      The \a offset parameter specifies the position of the mouse event     within the string, and \a state specifies the type of the mouse     event as described by the QWSServer::IMMouse enum. If \a state is     less than 0, the mouse event is inside the associated widget, but     outside the preedit text. When clicking in a different widget, the     \a state is QWSServer::MouseOutside.      \sa sendPreeditString(), reset() */
end_comment
begin_function
DECL|function|mouseHandler
name|void
name|QWSInputMethod
operator|::
name|mouseHandler
parameter_list|(
name|int
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|QWSServer
operator|::
name|MousePress
operator|||
name|state
operator|==
name|QWSServer
operator|::
name|MouseOutside
condition|)
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sends an event encapsulating the given \a preeditString, to the     focus widget.      The specified \a selectionLength is the number of characters to be     marked as selected (starting at the given \a cursorPosition). If     \a selectionLength is negative, the text \e before \a     cursorPosition is marked.      The preedit string is marked with QInputContext::PreeditFormat,     and the selected part is marked with     QInputContext::SelectionFormat.      Sending an input method event with a non-empty preedit string will     cause the input method to enter compose mode.  Sending an input     method event with an empty preedit string will cause the input     method to leave compose mode, i.e., the input method will no longer     be actively composing the preedit string.      Internally, the event is represented by a QWSEvent object of the     \l {QWSEvent::IMEvent}{IMEvent} type.      \sa sendEvent(), sendCommitString() */
end_comment
begin_function
DECL|function|sendPreeditString
name|void
name|QWSInputMethod
operator|::
name|sendPreeditString
parameter_list|(
specifier|const
name|QString
modifier|&
name|preeditString
parameter_list|,
name|int
name|cursorPosition
parameter_list|,
name|int
name|selectionLength
parameter_list|)
block|{
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|int
name|selPos
init|=
name|cursorPosition
decl_stmt|;
if|if
condition|(
name|selectionLength
operator|==
literal|0
condition|)
block|{
name|selPos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|selectionLength
operator|<
literal|0
condition|)
block|{
name|selPos
operator|+=
name|selectionLength
expr_stmt|;
name|selectionLength
operator|=
operator|-
name|selectionLength
expr_stmt|;
block|}
if|if
condition|(
name|selPos
operator|>
literal|0
condition|)
name|attributes
operator|+=
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|TextFormat
argument_list|,
literal|0
argument_list|,
name|selPos
argument_list|,
name|QVariant
argument_list|(
name|int
argument_list|(
name|QInputContext
operator|::
name|PreeditFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectionLength
condition|)
name|attributes
operator|+=
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|TextFormat
argument_list|,
name|selPos
argument_list|,
name|selectionLength
argument_list|,
name|QVariant
argument_list|(
name|int
argument_list|(
name|QInputContext
operator|::
name|SelectionFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|selPos
operator|+
name|selectionLength
operator|<
name|preeditString
operator|.
name|length
argument_list|()
condition|)
name|attributes
operator|+=
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|TextFormat
argument_list|,
name|selPos
operator|+
name|selectionLength
argument_list|,
name|preeditString
operator|.
name|length
argument_list|()
operator|-
name|selPos
operator|-
name|selectionLength
argument_list|,
name|QVariant
argument_list|(
name|int
argument_list|(
name|QInputContext
operator|::
name|PreeditFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|attributes
operator|+=
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Cursor
argument_list|,
name|cursorPosition
argument_list|,
literal|0
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|ime
argument_list|(
name|preeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|qwsServer
operator|->
name|sendIMEvent
argument_list|(
operator|&
name|ime
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWSInputMethod::sendCommitString(const QString&commitString, int replaceFromPosition, int replaceLength)      Sends an event encapsulating the given \a commitString, to the     focus widget.      Note that this will cause the input method to leave compose mode,     i.e., the input method will no longer be actively composing the     preedit string.      If the specified \a replaceLength is greater than 0, the commit     string will replace the given number of characters of the     receiving widget's previous text, starting at the given \a     replaceFromPosition relative to the start of the current preedit     string.      Internally, the event is represented by a QWSEvent object of the     \l {QWSEvent::IMEvent}{IMEvent} type.      \sa sendEvent(), sendPreeditString() */
end_comment
begin_function
DECL|function|sendCommitString
name|void
name|QWSInputMethod
operator|::
name|sendCommitString
parameter_list|(
specifier|const
name|QString
modifier|&
name|commitString
parameter_list|,
name|int
name|replaceFrom
parameter_list|,
name|int
name|replaceLength
parameter_list|)
block|{
name|QInputMethodEvent
name|ime
decl_stmt|;
name|ime
operator|.
name|setCommitString
argument_list|(
name|commitString
argument_list|,
name|replaceFrom
argument_list|,
name|replaceLength
argument_list|)
expr_stmt|;
name|qwsServer
operator|->
name|sendIMEvent
argument_list|(
operator|&
name|ime
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QWSInputMethod::sendIMEvent(QWSServer::IMState state, const QString&text, int cursorPosition, int selectionLength)     \obsolete      Sends a QInputMethodEvent object to the focus widget.      If the specified \a state is QWSServer::IMCompose, \a text is a     preedit string, \a cursorPosition is the cursor's position within     the preedit string, and \a selectionLength is the number of     characters (starting at \a cursorPosition) that should be marked     as selected by the input widget receiving the event. If the     specified \a state is QWSServer::IMEnd, \a text is a commit     string.      Use sendEvent(), sendPreeditString() or sendCommitString() instead. */
end_comment
begin_comment
comment|/*!     \fn QWSInputMethod::sendEvent(const QInputMethodEvent *event)      Sends the given \a event to the focus widget.      The \c QInputMethodEvent class is derived from QWSEvent, i.e., the     given \a event is a QWSEvent object of the \l     {QWSEvent::IMEvent}{IMEvent} type.      \sa sendPreeditString(), sendCommitString(), reset() */
end_comment
begin_comment
comment|/*!     \fn void QWSInputMethod::sendQuery(int property)      Sends an input method query (internally encapsulated by a QWSEvent     of the \l {QWSEvent::IMQuery}{IMQuery} type) for the specified \a     property.      To receive responses to input method queries, the virtual     queryResponse() function must be reimplemented.      \sa queryResponse(), QWSServer::sendIMQuery() */
end_comment
begin_comment
comment|/*!     Sets and returns the number of bits shifted to go from pointer     resolution to screen resolution when filtering mouse input.      If \a isHigh is true and the device has a pointer device     resolution twice or more of the screen resolution, the positions     passed to the filter() function will be presented at the higher     resolution; otherwise the resolution will be equal to that of the     screen resolution.      \sa inputResolutionShift(), filter() */
end_comment
begin_function
DECL|function|setInputResolution
name|uint
name|QWSInputMethod
operator|::
name|setInputResolution
parameter_list|(
name|bool
name|isHigh
parameter_list|)
block|{
name|mIResolution
operator|=
name|isHigh
expr_stmt|;
return|return
name|inputResolutionShift
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bits shifted to go from pointer resolution     to screen resolution when filtering mouse input.      \sa setInputResolution(), filter() */
end_comment
begin_function
DECL|function|inputResolutionShift
name|uint
name|QWSInputMethod
operator|::
name|inputResolutionShift
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
comment|// default for devices with single resolution.
block|}
end_function
begin_comment
comment|/*!     \fn void QWSInputMethod::sendMouseEvent( const QPoint&position, int state, int wheel )      Sends a mouse event specified by the given \a position, \a state     and \a wheel parameters.      The given \a position will be transformed if the screen     coordinates do not match the pointer device coordinates.      Note that the event will be not be tested by the active input     method, but calling the QWSServer::sendMouseEvent() function will     make the current input method filter the event.      \sa mouseHandler(), sendEvent() */
end_comment
begin_function
DECL|function|sendMouseEvent
name|void
name|QWSInputMethod
operator|::
name|sendMouseEvent
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|wheel
parameter_list|)
block|{
if|if
condition|(
name|qt_last_x
condition|)
block|{
operator|*
name|qt_last_x
operator|=
name|pos
operator|.
name|x
argument_list|()
expr_stmt|;
operator|*
name|qt_last_y
operator|=
name|pos
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|QWSServer
operator|::
name|mousePosition
operator|=
name|pos
expr_stmt|;
name|qwsServerPrivate
operator|->
name|mouseState
operator|=
name|state
expr_stmt|;
name|QWSServerPrivate
operator|::
name|sendMouseEventUnfiltered
argument_list|(
name|pos
argument_list|,
name|state
argument_list|,
name|wheel
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_INPUTMETHODS
end_comment
begin_comment
comment|/*!     \fn  QWSWindow::QWSWindow(int i, QWSClient * client)     \internal      Constructs a new top-level window, associated with the client \a     client and giving it the id \a i. */
end_comment
begin_comment
comment|/*!     \fn QWSServer::windowEvent(QWSWindow * window, QWSServer::WindowEvent eventType)      This signal is emitted whenever something happens to a top-level     window (e.g., it's created or destroyed), passing a pointer to the     window and the event's type in the \a window and \a eventType     parameters, respectively.      \sa markedText() */
end_comment
begin_comment
comment|/*!     \class QWSServer::KeyboardFilter     \ingroup qws      \brief The KeyboardFilter class is a base class for global     keyboard event filters in Qt for Embedded Linux.      Note that this class is only available in \l{Qt for Embedded Linux}.      In \l{Qt for Embedded Linux}, all system generated events, including     keyboard events, are passed to the server application which then     propagates the event to the appropriate client. The KeyboardFilter     class is used to implement a global, low-level filter on the     server side. The server applies the filter to all keyboard events     before passing them on to the clients:      \image qwsserver_keyboardfilter.png      This feature can, for example, be used to filter things like APM     (advanced power management) suspended from a button without having     to filter for it in all applications.      To add a new keyboard filter you must first create the filter by     deriving from this class, reimplementing the pure virtual filter()     function. Then you can install the filter on the server using     QWSServer's \l {QWSServer::}{addKeyboardFilter()}     function. QWSServer also provides a \l     {QWSServer::}{removeKeyboardFilter()} function.      \sa {Qt for Embedded Linux Architecture}, QWSServer, QWSInputMethod */
end_comment
begin_comment
comment|/*!     \fn QWSServer::KeyboardFilter::~KeyboardFilter()      Destroys the keyboard filter. */
end_comment
begin_comment
comment|/*!     \fn bool QWSServer::KeyboardFilter::filter(int unicode, int keycode, int modifiers, bool isPress, bool autoRepeat)      Implement this function to return true if a given key event should     be stopped from being processed any further; otherwise it should     return false.      A key event can be identified by the given \a unicode value and     the \a keycode, \a modifiers, \a isPress and \a autoRepeat     parameters.      The \a keycode parameter is the Qt keycode value as defined by the     Qt::Key enum. The \a modifiers is an OR combination of     Qt::KeyboardModifier values, indicating whether \gui     Shift/Alt/Ctrl keys are pressed. The \a isPress parameter is true     if the event is a key press event and \a autoRepeat is true if the     event is caused by an auto-repeat mechanism and not an actual key     press. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qwindowsystem_qws.cpp"
end_include
end_unit
