begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qkbd_qws.h"
end_include
begin_include
include|#
directive|include
file|"qkbd_qws_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_KEYBOARD
end_ifndef
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QDataStream>
end_include
begin_include
include|#
directive|include
file|<QStringList>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_QWS
end_ifdef
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_include
include|#
directive|include
file|"qscreen_qws.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_QPA
end_ifdef
begin_include
include|#
directive|include
file|<QWindowSystemInterface>
end_include
begin_include
include|#
directive|include
file|<QKeyEvent>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|//#define QT_DEBUG_KEYMAP
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QWSKbPrivate
class|class
name|QWSKbPrivate
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|QWSKbPrivate
name|QWSKbPrivate
parameter_list|(
name|QWSKeyboardHandler
modifier|*
name|h
parameter_list|,
specifier|const
name|QString
modifier|&
name|device
parameter_list|)
member_init_list|:
name|m_handler
argument_list|(
name|h
argument_list|)
member_init_list|,
name|m_modifiers
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_composing
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_dead_unicode
argument_list|(
literal|0xffff
argument_list|)
member_init_list|,
name|m_no_zap
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_do_compose
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_keymap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_keymap_size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_keycompose
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_keycompose_size
argument_list|(
literal|0
argument_list|)
block|{
name|m_ar_timer
operator|=
operator|new
name|QTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_ar_timer
operator|->
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|m_ar_timer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|autoRepeat
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_ar_delay
operator|=
literal|400
expr_stmt|;
name|m_ar_period
operator|=
literal|80
expr_stmt|;
name|memset
argument_list|(
name|m_locks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m_locks
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|keymap
decl_stmt|;
name|QStringList
name|args
init|=
name|device
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|arg
decl|,
name|args
control|)
block|{
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"keymap="
argument_list|)
argument_list|)
condition|)
name|keymap
operator|=
name|arg
operator|.
name|mid
argument_list|(
literal|7
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|QLatin1String
argument_list|(
literal|"disable-zap"
argument_list|)
condition|)
name|m_no_zap
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|QLatin1String
argument_list|(
literal|"enable-compose"
argument_list|)
condition|)
name|m_do_compose
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"repeat-delay="
argument_list|)
argument_list|)
condition|)
name|m_ar_delay
operator|=
name|arg
operator|.
name|mid
argument_list|(
literal|13
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"repeat-rate="
argument_list|)
argument_list|)
condition|)
name|m_ar_period
operator|=
name|arg
operator|.
name|mid
argument_list|(
literal|12
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|keymap
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|loadKeymap
argument_list|(
name|keymap
argument_list|)
condition|)
name|unloadKeymap
argument_list|()
expr_stmt|;
block|}
DECL|function|~QWSKbPrivate
name|~
name|QWSKbPrivate
parameter_list|()
block|{
name|unloadKeymap
argument_list|()
expr_stmt|;
block|}
DECL|function|beginAutoRepeat
name|void
name|beginAutoRepeat
parameter_list|(
name|int
name|uni
parameter_list|,
name|int
name|code
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|mod
parameter_list|)
block|{
name|m_ar_unicode
operator|=
name|uni
expr_stmt|;
name|m_ar_keycode
operator|=
name|code
expr_stmt|;
name|m_ar_modifier
operator|=
name|mod
expr_stmt|;
name|m_ar_timer
operator|->
name|start
argument_list|(
name|m_ar_delay
argument_list|)
expr_stmt|;
block|}
DECL|function|endAutoRepeat
name|void
name|endAutoRepeat
parameter_list|()
block|{
name|m_ar_timer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
DECL|function|toQtModifiers
specifier|static
name|Qt
operator|::
name|KeyboardModifiers
name|toQtModifiers
parameter_list|(
name|quint8
name|mod
parameter_list|)
block|{
name|Qt
operator|::
name|KeyboardModifiers
name|qtmod
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
if|if
condition|(
name|mod
operator|&
operator|(
name|QWSKeyboard
operator|::
name|ModShift
operator||
name|QWSKeyboard
operator|::
name|ModShiftL
operator||
name|QWSKeyboard
operator|::
name|ModShiftR
operator|)
condition|)
name|qtmod
operator||=
name|Qt
operator|::
name|ShiftModifier
expr_stmt|;
if|if
condition|(
name|mod
operator|&
operator|(
name|QWSKeyboard
operator|::
name|ModControl
operator||
name|QWSKeyboard
operator|::
name|ModCtrlL
operator||
name|QWSKeyboard
operator|::
name|ModCtrlR
operator|)
condition|)
name|qtmod
operator||=
name|Qt
operator|::
name|ControlModifier
expr_stmt|;
if|if
condition|(
name|mod
operator|&
name|QWSKeyboard
operator|::
name|ModAlt
condition|)
name|qtmod
operator||=
name|Qt
operator|::
name|AltModifier
expr_stmt|;
return|return
name|qtmod
return|;
block|}
name|void
name|unloadKeymap
parameter_list|()
function_decl|;
name|bool
name|loadKeymap
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
function_decl|;
private|private
name|slots
private|:
DECL|function|autoRepeat
name|void
name|autoRepeat
parameter_list|()
block|{
name|m_handler
operator|->
name|processKeyEvent
argument_list|(
name|m_ar_unicode
argument_list|,
name|m_ar_keycode
argument_list|,
name|m_ar_modifier
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|m_handler
operator|->
name|processKeyEvent
argument_list|(
name|m_ar_unicode
argument_list|,
name|m_ar_keycode
argument_list|,
name|m_ar_modifier
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|m_ar_timer
operator|->
name|start
argument_list|(
name|m_ar_period
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|member|m_handler
name|QWSKeyboardHandler
modifier|*
name|m_handler
decl_stmt|;
comment|// auto repeat simulation
DECL|member|m_ar_unicode
name|int
name|m_ar_unicode
decl_stmt|;
DECL|member|m_ar_keycode
name|int
name|m_ar_keycode
decl_stmt|;
DECL|member|m_ar_modifier
name|Qt
operator|::
name|KeyboardModifiers
name|m_ar_modifier
decl_stmt|;
DECL|member|m_ar_delay
name|int
name|m_ar_delay
decl_stmt|;
DECL|member|m_ar_period
name|int
name|m_ar_period
decl_stmt|;
DECL|member|m_ar_timer
name|QTimer
modifier|*
name|m_ar_timer
decl_stmt|;
comment|// keymap handling
DECL|member|m_modifiers
name|quint8
name|m_modifiers
decl_stmt|;
DECL|member|m_locks
name|quint8
name|m_locks
index|[
literal|3
index|]
decl_stmt|;
DECL|member|m_composing
name|int
name|m_composing
decl_stmt|;
DECL|member|m_dead_unicode
name|quint16
name|m_dead_unicode
decl_stmt|;
DECL|member|m_no_zap
name|bool
name|m_no_zap
decl_stmt|;
DECL|member|m_do_compose
name|bool
name|m_do_compose
decl_stmt|;
DECL|member|m_keymap
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|m_keymap
decl_stmt|;
DECL|member|m_keymap_size
name|int
name|m_keymap_size
decl_stmt|;
DECL|member|m_keycompose
specifier|const
name|QWSKeyboard
operator|::
name|Composing
modifier|*
name|m_keycompose
decl_stmt|;
DECL|member|m_keycompose_size
name|int
name|m_keycompose_size
decl_stmt|;
DECL|member|s_keymap_default
specifier|static
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
name|s_keymap_default
index|[]
decl_stmt|;
DECL|member|s_keycompose_default
specifier|static
specifier|const
name|QWSKeyboard
operator|::
name|Composing
name|s_keycompose_default
index|[]
decl_stmt|;
friend|friend
class_decl|class
name|QWSKeyboardHandler
class_decl|;
block|}
class|;
end_class
begin_comment
comment|// simple builtin US keymap
end_comment
begin_include
include|#
directive|include
file|"qkbd_defaultmap_qws_p.h"
end_include
begin_comment
comment|// the unloadKeymap() function needs to be AFTER the defaultmap include,
end_comment
begin_comment
comment|// since the sizeof(s_keymap_default) wouldn't work otherwise.
end_comment
begin_function
DECL|function|unloadKeymap
name|void
name|QWSKbPrivate
operator|::
name|unloadKeymap
parameter_list|()
block|{
if|if
condition|(
name|m_keymap
operator|&&
name|m_keymap
operator|!=
name|s_keymap_default
condition|)
operator|delete
index|[]
name|m_keymap
expr_stmt|;
if|if
condition|(
name|m_keycompose
operator|&&
name|m_keycompose
operator|!=
name|s_keycompose_default
condition|)
operator|delete
index|[]
name|m_keycompose
expr_stmt|;
name|m_keymap
operator|=
name|s_keymap_default
expr_stmt|;
name|m_keymap_size
operator|=
sizeof|sizeof
argument_list|(
name|s_keymap_default
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|s_keymap_default
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|m_keycompose
operator|=
name|s_keycompose_default
expr_stmt|;
name|m_keycompose_size
operator|=
sizeof|sizeof
argument_list|(
name|s_keycompose_default
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|s_keycompose_default
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// reset state, so we could switch keymaps at runtime
name|m_modifiers
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|m_locks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m_locks
argument_list|)
argument_list|)
expr_stmt|;
name|m_composing
operator|=
literal|0
expr_stmt|;
name|m_dead_unicode
operator|=
literal|0xffff
expr_stmt|;
block|}
end_function
begin_function
DECL|function|loadKeymap
name|bool
name|QWSKbPrivate
operator|::
name|loadKeymap
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|QFile
name|f
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not open keymap file '%s'"
argument_list|,
name|qPrintable
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// .qmap files have a very simple structure:
comment|// quint32 magic           (QWSKeyboard::FileMagic)
comment|// quint32 version         (1)
comment|// quint32 keymap_size     (# of struct QWSKeyboard::Mappings)
comment|// quint32 keycompose_size (# of struct QWSKeyboard::Composings)
comment|// all QWSKeyboard::Mappings via QDataStream::operator(<<|>>)
comment|// all QWSKeyboard::Composings via QDataStream::operator(<<|>>)
name|quint32
name|qmap_magic
decl_stmt|,
name|qmap_version
decl_stmt|,
name|qmap_keymap_size
decl_stmt|,
name|qmap_keycompose_size
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|ds
operator|>>
name|qmap_magic
operator|>>
name|qmap_version
operator|>>
name|qmap_keymap_size
operator|>>
name|qmap_keycompose_size
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
operator|||
name|qmap_magic
operator|!=
name|QWSKeyboard
operator|::
name|FileMagic
operator|||
name|qmap_version
operator|!=
literal|1
operator|||
name|qmap_keymap_size
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"'%s' is ot a valid.qmap keymap file."
argument_list|,
name|qPrintable
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|qmap_keymap
init|=
operator|new
name|QWSKeyboard
operator|::
name|Mapping
index|[
name|qmap_keymap_size
index|]
decl_stmt|;
name|QWSKeyboard
operator|::
name|Composing
modifier|*
name|qmap_keycompose
init|=
name|qmap_keycompose_size
condition|?
operator|new
name|QWSKeyboard
operator|::
name|Composing
index|[
name|qmap_keycompose_size
index|]
else|:
literal|0
decl_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmap_keymap_size
condition|;
operator|++
name|i
control|)
name|ds
operator|>>
name|qmap_keymap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmap_keycompose_size
condition|;
operator|++
name|i
control|)
name|ds
operator|>>
name|qmap_keycompose
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
block|{
operator|delete
index|[]
name|qmap_keymap
expr_stmt|;
operator|delete
index|[]
name|qmap_keycompose
expr_stmt|;
name|qWarning
argument_list|(
literal|"Keymap file '%s' can not be loaded."
argument_list|,
name|qPrintable
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// unload currently active and clear state
name|unloadKeymap
argument_list|()
expr_stmt|;
name|m_keymap
operator|=
name|qmap_keymap
expr_stmt|;
name|m_keymap_size
operator|=
name|qmap_keymap_size
expr_stmt|;
name|m_keycompose
operator|=
name|qmap_keycompose
expr_stmt|;
name|m_keycompose_size
operator|=
name|qmap_keycompose_size
expr_stmt|;
name|m_do_compose
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \class QWSKeyboardHandler     \ingroup qws      \brief The QWSKeyboardHandler class is a base class for keyboard     drivers in Qt for Embedded Linux.      Note that this class is only available in \l{Qt for Embedded Linux}.      \l{Qt for Embedded Linux} provides ready-made drivers for several keyboard     protocols, see the \l{Qt for Embedded Linux Character Input}{character     input} documentation for details. Custom keyboard drivers can be     implemented by subclassing the QWSKeyboardHandler class and     creating a keyboard driver plugin (derived from     QKbdDriverPlugin). The default implementation of the     QKbdDriverFactory class will automatically detect the plugin, and     load the driver into the server application at run-time using Qt's     \l{How to Create Qt Plugins}{plugin system}.      The keyboard driver receives keyboard events from the system     device and encapsulates each event with an instance of the     QWSEvent class which it then passes to the server application (the     server is responsible for propagating the event to the appropriate     client). To receive keyboard events, a QWSKeyboardHandler object     will usually create a QSocketNotifier object for the given     device. The QSocketNotifier class provides support for monitoring     activity on a file descriptor. When the socket notifier receives     data, it will call the keyboard driver's processKeyEvent()     function to send the event to the \l{Qt for Embedded Linux} server     application for relaying to clients.       QWSKeyboardHandler also provides functions to control     auto-repetion of key sequences, beginAutoRepeat() and     endAutoRepeat(), and the transformDirKey() function enabling     transformation of arrow keys according to the display orientation.      \sa QKbdDriverPlugin, QKbdDriverFactory, {Qt for Embedded Linux Character Input} */
end_comment
begin_comment
comment|/*!     Constructs a keyboard driver. The \a device argument is passed by the     QWS_KEYBOARD environment variable.      Call the QWSServer::setKeyboardHandler() function to make the     newly created keyboard driver, the primary driver. Note that the     primary driver is controlled by the system, i.e., the system will     delete it upon exit. */
end_comment
begin_constructor
DECL|function|QWSKeyboardHandler
name|QWSKeyboardHandler
operator|::
name|QWSKeyboardHandler
parameter_list|(
specifier|const
name|QString
modifier|&
name|device
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QWSKbPrivate
argument_list|(
name|this
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \overload */
end_comment
begin_constructor
DECL|function|QWSKeyboardHandler
name|QWSKeyboardHandler
operator|::
name|QWSKeyboardHandler
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QWSKbPrivate
argument_list|(
name|this
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys this keyboard driver.      Do not call this function if this driver is the primary keyboard     handler, i.e., if QWSServer::setKeyboardHandler() function has     been called passing this driver as argument. The primary keyboard     driver is deleted by the system. */
end_comment
begin_destructor
DECL|function|~QWSKeyboardHandler
name|QWSKeyboardHandler
operator|::
name|~
name|QWSKeyboardHandler
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sends a key event to the \l{Qt for Embedded Linux} server application.      The key event is identified by its \a unicode value and the \a     keycode, \a modifiers, \a isPress and \a autoRepeat parameters.      The \a keycode parameter is the Qt keycode value as defined by the     Qt::Key enum. The \a modifiers is an OR combination of     Qt::KeyboardModifier values, indicating whether \gui     Shift/Alt/Ctrl keys are pressed. The \a isPress parameter is true     if the event is a key press event and \a autoRepeat is true if the     event is caused by an auto-repeat mechanism and not an actual key     press.      Note that this function does not handle key mapping. Please use     processKeycode() if you need that functionality.      \sa processKeycode(), beginAutoRepeat(), endAutoRepeat(), transformDirKey() */
end_comment
begin_function
DECL|function|processKeyEvent
name|void
name|QWSKeyboardHandler
operator|::
name|processKeyEvent
parameter_list|(
name|int
name|unicode
parameter_list|,
name|int
name|keycode
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|,
name|bool
name|isPress
parameter_list|,
name|bool
name|autoRepeat
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
name|qwsServer
operator|->
name|processKeyEvent
argument_list|(
name|unicode
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|isPress
argument_list|,
name|autoRepeat
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
name|QEvent
operator|::
name|Type
name|type
init|=
name|isPress
condition|?
name|QEvent
operator|::
name|KeyPress
else|:
name|QEvent
operator|::
name|KeyRelease
decl_stmt|;
name|QString
name|str
decl_stmt|;
if|if
condition|(
name|unicode
operator|!=
literal|0xffff
condition|)
name|str
operator|=
name|QString
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleKeyEvent
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|keycode
argument_list|,
name|modifiers
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn int QWSKeyboardHandler::transformDirKey(int keycode)      Transforms the arrow key specified by the given \a keycode, to the     orientation of the display and returns the transformed keycode.      The \a keycode is a Qt::Key value. The values identifying arrow     keys are:      \list         \o Qt::Key_Left         \o Qt::Key_Up         \o Qt::Key_Right         \o Qt::Key_Down     \endlist      \sa processKeyEvent()  */
end_comment
begin_function
DECL|function|transformDirKey
name|int
name|QWSKeyboardHandler
operator|::
name|transformDirKey
parameter_list|(
name|int
name|key
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_QWS
specifier|static
name|int
name|dir_keyrot
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dir_keyrot
operator|<
literal|0
condition|)
block|{
comment|// get the rotation
switch|switch
condition|(
name|qgetenv
argument_list|(
literal|"QWS_CURSOR_ROTATION"
argument_list|)
operator|.
name|toInt
argument_list|()
condition|)
block|{
case|case
literal|90
case|:
name|dir_keyrot
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|180
case|:
name|dir_keyrot
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|270
case|:
name|dir_keyrot
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|dir_keyrot
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|int
name|xf
init|=
name|qt_screen
operator|->
name|transformOrientation
argument_list|()
operator|+
name|dir_keyrot
decl_stmt|;
return|return
operator|(
name|key
operator|-
name|Qt
operator|::
name|Key_Left
operator|+
name|xf
operator|)
operator|%
literal|4
operator|+
name|Qt
operator|::
name|Key_Left
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn void QWSKeyboardHandler::beginAutoRepeat(int unicode, int keycode, Qt::KeyboardModifiers modifier)      Begins auto-repeating the specified key press; after a short delay     the key press is sent periodically until the endAutoRepeat()     function is called.      The key press is specified by its \a unicode, \a keycode and \a     modifier state.      \sa endAutoRepeat(), processKeyEvent() */
end_comment
begin_function
DECL|function|beginAutoRepeat
name|void
name|QWSKeyboardHandler
operator|::
name|beginAutoRepeat
parameter_list|(
name|int
name|uni
parameter_list|,
name|int
name|code
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|mod
parameter_list|)
block|{
name|d
operator|->
name|beginAutoRepeat
argument_list|(
name|uni
argument_list|,
name|code
argument_list|,
name|mod
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Stops auto-repeating a key press.      \sa beginAutoRepeat(), processKeyEvent() */
end_comment
begin_function
DECL|function|endAutoRepeat
name|void
name|QWSKeyboardHandler
operator|::
name|endAutoRepeat
parameter_list|()
block|{
name|d
operator|->
name|endAutoRepeat
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QWSKeyboardHandler::KeycodeAction      This enum describes the various special actions that actual     QWSKeyboardHandler implementations have to take care of.      \value None No further action required.      \value CapsLockOn  Set the state of the Caps lock LED to on.     \value CapsLockOff Set the state of the Caps lock LED to off.     \value NumLockOn  Set the state of the Num lock LED to on.     \value NumLockOff Set the state of the Num lock LED to off.     \value ScrollLockOn  Set the state of the Scroll lock LED to on.     \value ScrollLockOff Set the state of the Scroll lock LED to off.      \value PreviousConsole Switch to the previous virtual console (by                            default Ctrl+Alt+Left on Linux).     \value NextConsole Switch to the next virtual console (by default                        Ctrl+Alt+Right on Linux).     \value SwitchConsoleFirst Switch to the first virtual console (0).     \value SwitchConsoleLast Switch to the last virtual console (255).     \value SwitchConsoleMask If the KeyAction value is between SwitchConsoleFirst                              and SwitchConsoleLast, you can use this mask to get                              the specific virtual console number to switch to.      \value Reboot Reboot the machine - this is ignored in both the TTY and                   LinuxInput handlers though (by default Ctrl+Alt+Del on Linux).      \sa processKeycode() */
end_comment
begin_comment
comment|/*!     \fn QWSKeyboardHandler::KeycodeAction QWSKeyboardHandler::processKeycode(quint16 keycode, bool isPress, bool autoRepeat)  	\since 4.6 	     Maps \a keycode according to a keymap and sends that key event to the     \l{Qt for Embedded Linux} server application.      Please see the \l{Qt for Embedded Linux Character Input} and the \l     {kmap2qmap} documentations for a description on how to create and use     keymap files.      The key event is identified by its \a keycode value and the \a isPress     and \a autoRepeat parameters.      The \a keycode parameter is \bold NOT the Qt keycode value as defined by     the Qt::Key enum. This functions expects a standard Linux 16 bit kernel     keycode as it is used in the Linux Input Event sub-system. This     \a keycode is transformed to a Qt::Key code by using either a     compiled-in US keyboard layout or by dynamically loading a keymap at     startup which can be specified via the QWS_KEYBOARD environment     variable.      The \a isPress parameter is true if the event is a key press event and     \a autoRepeat is true if the event is caused by an auto-repeat mechanism     and not an actual key press.      The return value indicates if the actual QWSKeyboardHandler     implementation needs to take care of a special action, like console     switching or LED handling.      If standard Linux console keymaps are used, \a keycode must be one of the     standardized values defined in \c /usr/include/linux/input.h      \sa processKeyEvent(), KeycodeAction */
end_comment
begin_function
DECL|function|processKeycode
name|QWSKeyboardHandler
operator|::
name|KeycodeAction
name|QWSKeyboardHandler
operator|::
name|processKeycode
parameter_list|(
name|quint16
name|keycode
parameter_list|,
name|bool
name|pressed
parameter_list|,
name|bool
name|autorepeat
parameter_list|)
block|{
name|KeycodeAction
name|result
init|=
name|None
decl_stmt|;
name|bool
name|first_press
init|=
name|pressed
operator|&&
operator|!
name|autorepeat
decl_stmt|;
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|map_plain
init|=
literal|0
decl_stmt|;
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|map_withmod
init|=
literal|0
decl_stmt|;
comment|// get a specific and plain mapping for the keycode and the current modifiers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|m_keymap_size
operator|&&
operator|!
operator|(
name|map_plain
operator|&&
name|map_withmod
operator|)
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|m
init|=
name|d
operator|->
name|m_keymap
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|keycode
operator|==
name|keycode
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|modifiers
operator|==
literal|0
condition|)
name|map_plain
operator|=
name|m
expr_stmt|;
name|quint8
name|testmods
init|=
name|d
operator|->
name|m_modifiers
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|m_locks
index|[
literal|0
index|]
comment|/*CapsLock*/
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsLetter
operator|)
condition|)
name|testmods
operator|^=
name|QWSKeyboard
operator|::
name|ModShift
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|modifiers
operator|==
name|testmods
condition|)
name|map_withmod
operator|=
name|m
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG_KEYMAP
name|qWarning
argument_list|(
literal|"Processing key event: keycode=%3d, modifiers=%02x pressed=%d, autorepeat=%d  |  plain=%d, withmod=%d, size=%d"
argument_list|, \
name|keycode
argument_list|,
name|d
operator|->
name|m_modifiers
argument_list|,
name|pressed
condition|?
literal|1
else|:
literal|0
argument_list|,
name|autorepeat
condition|?
literal|1
else|:
literal|0
argument_list|, \
name|map_plain
condition|?
name|map_plain
operator|-
name|d
operator|->
name|m_keymap
else|:
operator|-
literal|1
argument_list|, \
name|map_withmod
condition|?
name|map_withmod
operator|-
name|d
operator|->
name|m_keymap
else|:
operator|-
literal|1
argument_list|, \
name|d
operator|->
name|m_keymap_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QWSKeyboard
operator|::
name|Mapping
modifier|*
name|it
init|=
name|map_withmod
condition|?
name|map_withmod
else|:
name|map_plain
decl_stmt|;
if|if
condition|(
operator|!
name|it
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_KEYMAP
comment|// we couldn't even find a plain mapping
name|qWarning
argument_list|(
literal|"Could not find a suitable mapping for keycode: %3d, modifiers: %02x"
argument_list|,
name|keycode
argument_list|,
name|d
operator|->
name|m_modifiers
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
name|bool
name|skip
init|=
literal|false
decl_stmt|;
name|quint16
name|unicode
init|=
name|it
operator|->
name|unicode
decl_stmt|;
name|quint32
name|qtcode
init|=
name|it
operator|->
name|qtcode
decl_stmt|;
if|if
condition|(
operator|(
name|it
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsModifier
operator|)
operator|&&
name|it
operator|->
name|special
condition|)
block|{
comment|// this is a modifier, i.e. Shift, Alt, ...
if|if
condition|(
name|pressed
condition|)
name|d
operator|->
name|m_modifiers
operator||=
name|quint8
argument_list|(
name|it
operator|->
name|special
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|m_modifiers
operator|&=
operator|~
name|quint8
argument_list|(
name|it
operator|->
name|special
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtcode
operator|>=
name|Qt
operator|::
name|Key_CapsLock
operator|&&
name|qtcode
operator|<=
name|Qt
operator|::
name|Key_ScrollLock
condition|)
block|{
comment|// (Caps|Num|Scroll)Lock
if|if
condition|(
name|first_press
condition|)
block|{
name|quint8
modifier|&
name|lock
init|=
name|d
operator|->
name|m_locks
index|[
name|qtcode
operator|-
name|Qt
operator|::
name|Key_CapsLock
index|]
decl_stmt|;
name|lock
operator|^=
literal|1
expr_stmt|;
switch|switch
condition|(
name|qtcode
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_CapsLock
case|:
name|result
operator|=
name|lock
condition|?
name|CapsLockOn
else|:
name|CapsLockOff
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_NumLock
case|:
name|result
operator|=
name|lock
condition|?
name|NumLockOn
else|:
name|NumLockOff
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_ScrollLock
case|:
name|result
operator|=
name|lock
condition|?
name|ScrollLockOn
else|:
name|ScrollLockOff
expr_stmt|;
break|break;
default|default                :
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsSystem
operator|)
operator|&&
name|it
operator|->
name|special
operator|&&
name|first_press
condition|)
block|{
switch|switch
condition|(
name|it
operator|->
name|special
condition|)
block|{
case|case
name|QWSKeyboard
operator|::
name|SystemReboot
case|:
name|result
operator|=
name|Reboot
expr_stmt|;
break|break;
case|case
name|QWSKeyboard
operator|::
name|SystemZap
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|m_no_zap
condition|)
name|qApp
operator|->
name|quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|QWSKeyboard
operator|::
name|SystemConsolePrevious
case|:
name|result
operator|=
name|PreviousConsole
expr_stmt|;
break|break;
case|case
name|QWSKeyboard
operator|::
name|SystemConsoleNext
case|:
name|result
operator|=
name|NextConsole
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|it
operator|->
name|special
operator|>=
name|QWSKeyboard
operator|::
name|SystemConsoleFirst
operator|&&
name|it
operator|->
name|special
operator|<=
name|QWSKeyboard
operator|::
name|SystemConsoleLast
condition|)
block|{
name|result
operator|=
name|KeycodeAction
argument_list|(
name|SwitchConsoleFirst
operator|+
operator|(
operator|(
name|it
operator|->
name|special
operator|&
name|QWSKeyboard
operator|::
name|SystemConsoleMask
operator|)
operator|&
name|SwitchConsoleMask
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|skip
operator|=
literal|true
expr_stmt|;
comment|// no need to tell QWS about it
block|}
elseif|else
if|if
condition|(
operator|(
name|qtcode
operator|==
name|Qt
operator|::
name|Key_Multi_key
operator|)
operator|&&
name|d
operator|->
name|m_do_compose
condition|)
block|{
comment|// the Compose key was pressed
if|if
condition|(
name|first_press
condition|)
name|d
operator|->
name|m_composing
operator|=
literal|2
expr_stmt|;
name|skip
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsDead
operator|)
operator|&&
name|d
operator|->
name|m_do_compose
condition|)
block|{
comment|// a Dead key was pressed
if|if
condition|(
name|first_press
operator|&&
name|d
operator|->
name|m_composing
operator|==
literal|1
operator|&&
name|d
operator|->
name|m_dead_unicode
operator|==
name|unicode
condition|)
block|{
comment|// twice
name|d
operator|->
name|m_composing
operator|=
literal|0
expr_stmt|;
name|qtcode
operator|=
name|Qt
operator|::
name|Key_unknown
expr_stmt|;
comment|// otherwise it would be Qt::Key_Dead...
block|}
elseif|else
if|if
condition|(
name|first_press
operator|&&
name|unicode
operator|!=
literal|0xffff
condition|)
block|{
name|d
operator|->
name|m_dead_unicode
operator|=
name|unicode
expr_stmt|;
name|d
operator|->
name|m_composing
operator|=
literal|1
expr_stmt|;
name|skip
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|// a normal key was pressed
specifier|const
name|int
name|modmask
init|=
name|Qt
operator|::
name|ShiftModifier
operator||
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator||
name|Qt
operator|::
name|MetaModifier
operator||
name|Qt
operator|::
name|KeypadModifier
decl_stmt|;
comment|// we couldn't find a specific mapping for the current modifiers,
comment|// or that mapping didn't have special modifiers:
comment|// so just report the plain mapping with additional modifiers.
if|if
condition|(
operator|(
name|it
operator|==
name|map_plain
operator|&&
name|it
operator|!=
name|map_withmod
operator|)
operator|||
operator|(
name|map_withmod
operator|&&
operator|!
operator|(
name|map_withmod
operator|->
name|qtcode
operator|&
name|modmask
operator|)
operator|)
condition|)
block|{
name|qtcode
operator||=
name|QWSKbPrivate
operator|::
name|toQtModifiers
argument_list|(
name|d
operator|->
name|m_modifiers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|m_composing
operator|==
literal|2
operator|&&
name|first_press
operator|&&
operator|!
operator|(
name|it
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsModifier
operator|)
condition|)
block|{
comment|// the last key press was the Compose key
if|if
condition|(
name|unicode
operator|!=
literal|0xffff
condition|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
comment|// check if this code is in the compose table at all
for|for
control|(
init|;
name|idx
operator|<
name|d
operator|->
name|m_keycompose_size
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|d
operator|->
name|m_keycompose
index|[
name|idx
index|]
operator|.
name|first
operator|==
name|unicode
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|<
name|d
operator|->
name|m_keycompose_size
condition|)
block|{
comment|// found it -> simulate a Dead key press
name|d
operator|->
name|m_dead_unicode
operator|=
name|unicode
expr_stmt|;
name|unicode
operator|=
literal|0xffff
expr_stmt|;
name|d
operator|->
name|m_composing
operator|=
literal|1
expr_stmt|;
name|skip
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|m_composing
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|m_composing
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|m_composing
operator|==
literal|1
operator|&&
name|first_press
operator|&&
operator|!
operator|(
name|it
operator|->
name|flags
operator|&
name|QWSKeyboard
operator|::
name|IsModifier
operator|)
condition|)
block|{
comment|// the last key press was a Dead key
name|bool
name|valid
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|unicode
operator|!=
literal|0xffff
condition|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
comment|// check if this code is in the compose table at all
for|for
control|(
init|;
name|idx
operator|<
name|d
operator|->
name|m_keycompose_size
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|d
operator|->
name|m_keycompose
index|[
name|idx
index|]
operator|.
name|first
operator|==
name|d
operator|->
name|m_dead_unicode
operator|&&
name|d
operator|->
name|m_keycompose
index|[
name|idx
index|]
operator|.
name|second
operator|==
name|unicode
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|<
name|d
operator|->
name|m_keycompose_size
condition|)
block|{
name|quint16
name|composed
init|=
name|d
operator|->
name|m_keycompose
index|[
name|idx
index|]
operator|.
name|result
decl_stmt|;
if|if
condition|(
name|composed
operator|!=
literal|0xffff
condition|)
block|{
name|unicode
operator|=
name|composed
expr_stmt|;
name|qtcode
operator|=
name|Qt
operator|::
name|Key_unknown
expr_stmt|;
name|valid
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|unicode
operator|=
name|d
operator|->
name|m_dead_unicode
expr_stmt|;
name|qtcode
operator|=
name|Qt
operator|::
name|Key_unknown
expr_stmt|;
block|}
name|d
operator|->
name|m_composing
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_KEYMAP
name|qWarning
argument_list|(
literal|"Processing: uni=%04x, qt=%08x, qtmod=%08x"
argument_list|,
name|unicode
argument_list|,
name|qtcode
operator|&
operator|~
name|modmask
argument_list|,
operator|(
name|qtcode
operator|&
name|modmask
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// send the result to the QWS server
name|processKeyEvent
argument_list|(
name|unicode
argument_list|,
name|qtcode
operator|&
operator|~
name|modmask
argument_list|,
name|Qt
operator|::
name|KeyboardModifiers
argument_list|(
name|qtcode
operator|&
name|modmask
argument_list|)
argument_list|,
name|pressed
argument_list|,
name|autorepeat
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qkbd_qws.moc"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_KEYBOARD
end_comment
end_unit
