begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcopchannel_qws.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COP
end_ifndef
begin_include
include|#
directive|include
file|"qwsdisplay_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwscommand_qws_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_p.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qpointer.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_typedef
DECL|typedef|QCopServerMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QList
argument_list|<
name|QWSClient
modifier|*
argument_list|>
argument_list|>
name|QCopServerMap
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|qcopServerMap
specifier|static
name|QCopServerMap
modifier|*
name|qcopServerMap
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QCopServerRegexp
class|class
name|QCopServerRegexp
block|{
public|public:
name|QCopServerRegexp
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
constructor_decl|;
name|QCopServerRegexp
parameter_list|(
specifier|const
name|QCopServerRegexp
modifier|&
name|other
parameter_list|)
constructor_decl|;
DECL|member|channel
name|QString
name|channel
decl_stmt|;
DECL|member|client
name|QWSClient
modifier|*
name|client
decl_stmt|;
DECL|member|regexp
name|QRegExp
name|regexp
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QCopServerRegexp
name|QCopServerRegexp
operator|::
name|QCopServerRegexp
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
name|QWSClient
modifier|*
name|client
parameter_list|)
block|{
name|this
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|->
name|client
operator|=
name|client
expr_stmt|;
name|this
operator|->
name|regexp
operator|=
name|QRegExp
argument_list|(
name|channel
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QCopServerRegexp
name|QCopServerRegexp
operator|::
name|QCopServerRegexp
parameter_list|(
specifier|const
name|QCopServerRegexp
modifier|&
name|other
parameter_list|)
block|{
name|channel
operator|=
name|other
operator|.
name|channel
expr_stmt|;
name|client
operator|=
name|other
operator|.
name|client
expr_stmt|;
name|regexp
operator|=
name|other
operator|.
name|regexp
expr_stmt|;
block|}
end_constructor
begin_typedef
DECL|typedef|QCopServerRegexpList
typedef|typedef
name|QList
argument_list|<
name|QCopServerRegexp
argument_list|>
name|QCopServerRegexpList
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|qcopServerRegexpList
specifier|static
name|QCopServerRegexpList
modifier|*
name|qcopServerRegexpList
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|QCopClientMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QList
argument_list|<
name|QPointer
argument_list|<
name|QCopChannel
argument_list|>
argument_list|>
argument_list|>
name|QCopClientMap
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|qcopClientMap
specifier|static
name|QCopClientMap
modifier|*
name|qcopClientMap
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMutex
argument_list|,
argument|qcopClientMapMutex
argument_list|)
end_macro
begin_comment
comment|// Determine if a channel name contains wildcard characters.
end_comment
begin_function
DECL|function|containsWildcards
specifier|static
name|bool
name|containsWildcards
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
block|{
return|return
name|channel
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QCopChannelPrivate
class|class
name|QCopChannelPrivate
block|{
public|public:
DECL|member|channel
name|QString
name|channel
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QCopChannel     \ingroup qws      \brief The QCopChannel class provides communication capabilities     between clients in \l{Qt for Embedded Linux}.      Note that this class is only available in \l{Qt for Embedded Linux}.      The Qt COmmunication Protocol (QCOP) is a many-to-many protocol     for transferring messages across registered channels. A channel is     registered by name, and anyone who wants to can listen to the     channel as well as send messages through it. The QCOP protocol     allows clients to communicate both within the same address space     and between different processes.      To send messages to a given channel, QCopChannel provides the     static send() function. Using this function alone, the messages     are queued until Qt re-enters the event loop. To immediately flush     all queued messages to the registered listeners, call the static     flush() function.      To listen to the traffic on a given channel, you typically     instantiate a QCopChannel object for the given channel and connect     to its received() signal that is emitted whenever there is     incoming data.  Use the static isRegistered() function to query     the server for the existence of a given channel. QCopChannel     provides the channel() function returning the name of this     QCopChannel object's channel.      In additon, QCopChannel provides the virtual receive() function     that can be reimplemented to filter the incoming messages and     data. The default implementation simply emits the received()     signal.      \sa QWSServer, QWSClient, {Qt for Embedded Linux Architecture} */
end_comment
begin_comment
comment|/*!     Constructs a QCopChannel object for the specified \a channel, with     the given \a parent. Once created, the channel is registered by     the server.      \sa isRegistered(), channel() */
end_comment
begin_constructor
DECL|function|QCopChannel
name|QCopChannel
operator|::
name|QCopChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
block|{
name|init
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_comment
comment|/*!     Use the two argument overload instead, and call the     QObject::setObjectName() function to \a name the instance. */
end_comment
begin_constructor
DECL|function|QCopChannel
name|QCopChannel
operator|::
name|QCopChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
block|{
name|setObjectName
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|init
name|void
name|QCopChannel
operator|::
name|init
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QCopChannelPrivate
expr_stmt|;
name|d
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
if|if
condition|(
operator|!
name|qt_fbdpy
condition|)
block|{
name|qFatal
argument_list|(
literal|"QCopChannel: Must construct a QApplication "
literal|"before QCopChannel"
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|QMutexLocker
name|locker
argument_list|(
name|qcopClientMapMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qcopClientMap
condition|)
name|qcopClientMap
operator|=
operator|new
name|QCopClientMap
expr_stmt|;
comment|// do we need a new channel list ?
name|QCopClientMap
operator|::
name|Iterator
name|it
init|=
name|qcopClientMap
operator|->
name|find
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|qcopClientMap
operator|->
name|end
argument_list|()
condition|)
block|{
name|it
operator|.
name|value
argument_list|()
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
name|it
operator|=
name|qcopClientMap
operator|->
name|insert
argument_list|(
name|channel
argument_list|,
name|QList
argument_list|<
name|QPointer
argument_list|<
name|QCopChannel
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|.
name|value
argument_list|()
operator|.
name|append
argument_list|(
name|QPointer
argument_list|<
name|QCopChannel
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// inform server about this channel
name|qt_fbdpy
operator|->
name|registerChannel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Resend all channel registrations   */
end_comment
begin_function
DECL|function|reregisterAll
name|void
name|QCopChannel
operator|::
name|reregisterAll
parameter_list|()
block|{
if|if
condition|(
name|qcopClientMap
condition|)
for|for
control|(
name|QCopClientMap
operator|::
name|Iterator
name|iter
init|=
name|qcopClientMap
operator|->
name|begin
argument_list|()
init|;
name|iter
operator|!=
name|qcopClientMap
operator|->
name|end
argument_list|()
condition|;
operator|++
name|iter
control|)
name|qt_fbdpy
operator|->
name|registerChannel
argument_list|(
name|iter
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys this QCopChannel object.      The server is notified that this particular listener has closed     its connection. The server will keep the channel open until the     last registered listener detaches.      \sa isRegistered(), channel() */
end_comment
begin_destructor
DECL|function|~QCopChannel
name|QCopChannel
operator|::
name|~
name|QCopChannel
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|qcopClientMapMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCopClientMap
operator|::
name|Iterator
name|it
init|=
name|qcopClientMap
operator|->
name|find
argument_list|(
name|d
operator|->
name|channel
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|it
operator|!=
name|qcopClientMap
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|.
name|value
argument_list|()
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// still any clients connected locally ?
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QByteArray
name|data
decl_stmt|;
name|QDataStream
name|s
argument_list|(
operator|&
name|data
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|s
operator|<<
name|d
operator|->
name|channel
expr_stmt|;
if|if
condition|(
name|qt_fbdpy
condition|)
name|send
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"detach()"
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|qcopClientMap
operator|->
name|remove
argument_list|(
name|d
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the name of this object's channel.      \sa isRegistered() */
end_comment
begin_function
DECL|function|channel
name|QString
name|QCopChannel
operator|::
name|channel
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|channel
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QCopChannel::receive(const QString& message, const QByteArray&data)      Processes the incoming \a message and \a data.      This function is called by the server when this object's channel     receives new messages. Note that the default implementation simply     emits the received() signal; reimplement this function to process     the incoming \a message and \a data.      Note that the format of the given \a data has to be well defined     in order to extract the information it contains. In addition, it     is recommended to use the DCOP convention. This is not a     requirement, but you must ensure that the sender and receiver     agree on the argument types. For example:      \snippet doc/src/snippets/code/src_gui_embedded_qcopchannel_qws.cpp 0      The above code assumes that the \c message is a DCOP-style     function signature and the \c data contains the function's     arguments.      \sa send(), channel(), received()  */
end_comment
begin_function
DECL|function|receive
name|void
name|QCopChannel
operator|::
name|receive
parameter_list|(
specifier|const
name|QString
modifier|&
name|msg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
emit|emit
name|received
argument_list|(
name|msg
argument_list|,
name|data
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \fn void QCopChannel::received(const QString& message, const QByteArray&data)      This signal is emitted whenever this object's channel receives new     messages (i.e., it is emitted by the receive() function), passing     the incoming \a message and \a data as parameters.      \sa receive(), channel() */
end_comment
begin_comment
comment|/*!     Queries the server for the existence of the given \a channel. Returns true     if the channel is registered; otherwise returns false.      \sa channel(), send() */
end_comment
begin_function
DECL|function|isRegistered
name|bool
name|QCopChannel
operator|::
name|isRegistered
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
block|{
name|QByteArray
name|data
decl_stmt|;
name|QDataStream
name|s
argument_list|(
operator|&
name|data
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|s
operator|<<
name|channel
expr_stmt|;
if|if
condition|(
operator|!
name|send
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"isRegistered()"
argument_list|)
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|false
return|;
name|QWSQCopMessageEvent
modifier|*
name|e
init|=
name|qt_fbdpy
operator|->
name|waitForQCopResponse
argument_list|()
decl_stmt|;
name|bool
name|known
init|=
name|e
operator|->
name|message
operator|==
literal|"known"
decl_stmt|;
operator|delete
name|e
expr_stmt|;
return|return
name|known
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QCopChannel::send(const QString& channel, const QString& message)     \overload */
end_comment
begin_function
DECL|function|send
name|bool
name|QCopChannel
operator|::
name|send
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
block|{
name|QByteArray
name|data
decl_stmt|;
return|return
name|send
argument_list|(
name|channel
argument_list|,
name|msg
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QCopChannel::send(const QString& channel, const QString& message,                        const QByteArray&data)      Sends the given \a message on the specified \a channel with the     given \a data. The message will be distributed to all clients     subscribed to the channel. Returns true if the message is sent     successfully; otherwise returns false.      It is recommended to use the DCOP convention. This is not a     requirement, but you must ensure that the sender and receiver     agree on the argument types.      Note that QDataStream provides a convenient way to fill the byte     array with auxiliary data. For example:      \snippet doc/src/snippets/code/src_gui_embedded_qcopchannel_qws.cpp 1      In the code above the channel is \c "System/Shell". The \c message     is an arbitrary string, but in the example we've used the DCOP     convention of passing a function signature. Such a signature is     formatted as \c "functionname(types)" where \c types is a list of     zero or more comma-separated type names, with no whitespace, no     consts and no pointer or reference marks, i.e. no "*" or "&".      \sa receive(), isRegistered() */
end_comment
begin_function
DECL|function|send
name|bool
name|QCopChannel
operator|::
name|send
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_fbdpy
condition|)
block|{
name|qFatal
argument_list|(
literal|"QCopChannel::send: Must construct a QApplication "
literal|"before using QCopChannel"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|qt_fbdpy
operator|->
name|sendMessage
argument_list|(
name|channel
argument_list|,
name|msg
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Flushes all queued messages to the registered listeners.      Note that this function returns false if no QApplication has been     constructed, otherwise it returns true.      \sa send()  */
end_comment
begin_function
DECL|function|flush
name|bool
name|QCopChannel
operator|::
name|flush
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qt_fbdpy
condition|)
block|{
name|qFatal
argument_list|(
literal|"QCopChannel::flush: Must construct a QApplication "
literal|"before using QCopChannel"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|qt_fbdpy
operator|->
name|flushCommands
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_class
DECL|class|QWSServerSignalBridge
class|class
name|QWSServerSignalBridge
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|void
name|emitNewChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
function_decl|;
name|void
name|emitRemovedChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
function_decl|;
signals|signals:
name|void
name|newChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
function_decl|;
name|void
name|removedChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|emitNewChannel
name|void
name|QWSServerSignalBridge
operator|::
name|emitNewChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
block|{
emit|emit
name|newChannel
argument_list|(
name|channel
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|emitRemovedChannel
name|void
name|QWSServerSignalBridge
operator|::
name|emitRemovedChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|channel
parameter_list|)
block|{
emit|emit
name|removedChannel
argument_list|(
name|channel
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal     Server side: subscribe client \a cl on channel \a ch. */
end_comment
begin_function
DECL|function|registerChannel
name|void
name|QCopChannel
operator|::
name|registerChannel
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|,
name|QWSClient
modifier|*
name|cl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcopServerMap
condition|)
name|qcopServerMap
operator|=
operator|new
name|QCopServerMap
expr_stmt|;
comment|// do we need a new channel list ?
name|QCopServerMap
operator|::
name|Iterator
name|it
init|=
name|qcopServerMap
operator|->
name|find
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|qcopServerMap
operator|->
name|end
argument_list|()
condition|)
name|it
operator|=
name|qcopServerMap
operator|->
name|insert
argument_list|(
name|ch
argument_list|,
name|QList
argument_list|<
name|QWSClient
operator|*
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// If the channel name contains wildcard characters, then we also
comment|// register it on the server regexp matching list.
if|if
condition|(
name|containsWildcards
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|QCopServerRegexp
name|item
argument_list|(
name|ch
argument_list|,
name|cl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qcopServerRegexpList
condition|)
name|qcopServerRegexpList
operator|=
operator|new
name|QCopServerRegexpList
expr_stmt|;
name|qcopServerRegexpList
operator|->
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
comment|// If this is the first client in the channel, announce the channel as being created.
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QWSServerSignalBridge
modifier|*
name|qwsBridge
init|=
operator|new
name|QWSServerSignalBridge
argument_list|()
decl_stmt|;
name|connect
argument_list|(
name|qwsBridge
argument_list|,
name|SIGNAL
argument_list|(
name|newChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|qwsServer
argument_list|,
name|SIGNAL
argument_list|(
name|newChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|qwsBridge
operator|->
name|emitNewChannel
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|delete
name|qwsBridge
expr_stmt|;
block|}
name|it
operator|.
name|value
argument_list|()
operator|.
name|append
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Server side: unsubscribe \a cl from all channels. */
end_comment
begin_function
DECL|function|detach
name|void
name|QCopChannel
operator|::
name|detach
parameter_list|(
name|QWSClient
modifier|*
name|cl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcopServerMap
condition|)
return|return;
name|QCopServerMap
operator|::
name|Iterator
name|it
init|=
name|qcopServerMap
operator|->
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|qcopServerMap
operator|->
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|contains
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|it
operator|.
name|value
argument_list|()
operator|.
name|removeAll
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|// If this was the last client in the channel, announce the channel as dead.
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QWSServerSignalBridge
modifier|*
name|qwsBridge
init|=
operator|new
name|QWSServerSignalBridge
argument_list|()
decl_stmt|;
name|connect
argument_list|(
name|qwsBridge
argument_list|,
name|SIGNAL
argument_list|(
name|removedChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|qwsServer
argument_list|,
name|SIGNAL
argument_list|(
name|removedChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|qwsBridge
operator|->
name|emitRemovedChannel
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|qwsBridge
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|qcopServerRegexpList
condition|)
return|return;
name|QCopServerRegexpList
operator|::
name|Iterator
name|it2
init|=
name|qcopServerRegexpList
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it2
operator|!=
name|qcopServerRegexpList
operator|->
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it2
operator|)
operator|.
name|client
operator|==
name|cl
condition|)
name|it2
operator|=
name|qcopServerRegexpList
operator|->
name|erase
argument_list|(
name|it2
argument_list|)
expr_stmt|;
else|else
operator|++
name|it2
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Server side: transmit the message to all clients registered to the     specified channel. */
end_comment
begin_function
DECL|function|answer
name|void
name|QCopChannel
operator|::
name|answer
parameter_list|(
name|QWSClient
modifier|*
name|cl
parameter_list|,
specifier|const
name|QString
modifier|&
name|ch
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
comment|// internal commands
if|if
condition|(
name|ch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|msg
operator|==
name|QLatin1String
argument_list|(
literal|"isRegistered()"
argument_list|)
condition|)
block|{
name|QString
name|c
decl_stmt|;
name|QDataStream
name|s
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|s
operator|>>
name|c
expr_stmt|;
name|bool
name|known
init|=
name|qcopServerMap
operator|&&
name|qcopServerMap
operator|->
name|contains
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
operator|(
operator|(
operator|*
name|qcopServerMap
operator|)
index|[
name|c
index|]
operator|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// Yes, it's a typo, it's not user-visible, and we choose not to fix it for compatibility
name|QLatin1String
name|ans
init|=
name|QLatin1String
argument_list|(
name|known
condition|?
literal|"known"
else|:
literal|"unknown"
argument_list|)
decl_stmt|;
name|QWSServerPrivate
operator|::
name|sendQCopEvent
argument_list|(
name|cl
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|ans
argument_list|,
name|data
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|msg
operator|==
name|QLatin1String
argument_list|(
literal|"detach()"
argument_list|)
condition|)
block|{
name|QString
name|c
decl_stmt|;
name|QDataStream
name|s
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|s
operator|>>
name|c
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qcopServerMap
argument_list|)
expr_stmt|;
name|QCopServerMap
operator|::
name|Iterator
name|it
init|=
name|qcopServerMap
operator|->
name|find
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|qcopServerMap
operator|->
name|end
argument_list|()
condition|)
block|{
comment|//Q_ASSERT(it.value().contains(cl));
name|it
operator|.
name|value
argument_list|()
operator|.
name|removeAll
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If this was the last client in the channel, announce the channel as dead
name|QWSServerSignalBridge
modifier|*
name|qwsBridge
init|=
operator|new
name|QWSServerSignalBridge
argument_list|()
decl_stmt|;
name|connect
argument_list|(
name|qwsBridge
argument_list|,
name|SIGNAL
argument_list|(
name|removedChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|qwsServer
argument_list|,
name|SIGNAL
argument_list|(
name|removedChannel
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|qwsBridge
operator|->
name|emitRemovedChannel
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|qwsBridge
expr_stmt|;
name|qcopServerMap
operator|->
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qcopServerRegexpList
operator|&&
name|containsWildcards
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Remove references to a wildcarded channel.
name|QCopServerRegexpList
operator|::
name|Iterator
name|it
init|=
name|qcopServerRegexpList
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|qcopServerRegexpList
operator|->
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|client
operator|==
name|cl
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|channel
operator|==
name|c
condition|)
name|it
operator|=
name|qcopServerRegexpList
operator|->
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
block|}
return|return;
block|}
name|qWarning
argument_list|(
literal|"QCopChannel: unknown internal command %s"
argument_list|,
name|qPrintable
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|QWSServerPrivate
operator|::
name|sendQCopEvent
argument_list|(
name|cl
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"bad"
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qcopServerMap
condition|)
block|{
name|QList
argument_list|<
name|QWSClient
modifier|*
argument_list|>
name|clist
init|=
name|qcopServerMap
operator|->
name|value
argument_list|(
name|ch
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clist
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWSClient
modifier|*
name|c
init|=
name|clist
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QWSServerPrivate
operator|::
name|sendQCopEvent
argument_list|(
name|c
argument_list|,
name|ch
argument_list|,
name|msg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qcopServerRegexpList
operator|&&
operator|!
name|containsWildcards
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// Search for wildcard matches and forward the message on.
name|QCopServerRegexpList
operator|::
name|ConstIterator
name|it
init|=
name|qcopServerRegexpList
operator|->
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|qcopServerRegexpList
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|regexp
operator|.
name|exactMatch
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|QByteArray
name|newData
decl_stmt|;
block|{
name|QDataStream
name|stream
argument_list|(
operator|&
name|newData
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Append
argument_list|)
decl_stmt|;
name|stream
operator|<<
name|ch
expr_stmt|;
name|stream
operator|<<
name|msg
expr_stmt|;
name|stream
operator|<<
name|data
expr_stmt|;
comment|// Stream is flushed and closed at this point.
block|}
name|QWSServerPrivate
operator|::
name|sendQCopEvent
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|client
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|channel
argument_list|,
name|QLatin1String
argument_list|(
literal|"forwardedMessage(QString,QString,QByteArray)"
argument_list|)
argument_list|,
name|newData
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Client side: distribute received event to the QCop instance managing the     channel. */
end_comment
begin_function
DECL|function|sendLocally
name|void
name|QCopChannel
operator|::
name|sendLocally
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qcopClientMap
argument_list|)
expr_stmt|;
comment|// filter out internal events
if|if
condition|(
name|ch
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// feed local clients with received data
name|QList
argument_list|<
name|QPointer
argument_list|<
name|QCopChannel
argument_list|>
argument_list|>
name|clients
decl_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
name|qcopClientMapMutex
argument_list|()
argument_list|)
decl_stmt|;
name|clients
operator|=
operator|(
operator|*
name|qcopClientMap
operator|)
index|[
name|ch
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clients
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QCopChannel
modifier|*
name|channel
init|=
operator|(
name|QCopChannel
operator|*
operator|)
name|clients
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|channel
condition|)
name|channel
operator|->
name|receive
argument_list|(
name|msg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qcopchannel_qws.moc"
end_include
begin_endif
endif|#
directive|endif
end_endif
end_unit
