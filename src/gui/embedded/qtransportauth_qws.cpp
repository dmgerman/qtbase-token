begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtransportauth_qws.h"
end_include
begin_include
include|#
directive|include
file|"qtransportauth_qws_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SXE
end_ifndef
begin_include
include|#
directive|include
file|"../../3rdparty/md5/md5.h"
end_include
begin_include
include|#
directive|include
file|"../../3rdparty/md5/md5.cpp"
end_include
begin_include
include|#
directive|include
file|"qwsutils_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwssocket_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwscommand_qws_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocket.h"
end_include
begin_include
include|#
directive|include
file|"qlibraryinfo.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<private/qcore_unix_p.h>
end_include
begin_comment
comment|// overrides QT_OPEN
end_comment
begin_include
include|#
directive|include
file|<syslog.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/socket.h>
end_include
begin_include
include|#
directive|include
file|<sys/file.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcache.h>
end_include
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|512
end_define
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!   \internal   memset for security purposes, guaranteed not to be optimized away   http://www.faqs.org/docs/Linux-HOWTO/Secure-Programs-HOWTO.html */
DECL|function|guaranteed_memset
name|Q_GUI_EXPORT
name|void
modifier|*
name|guaranteed_memset
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|volatile
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|v
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/*!   \class QTransportAuth   \internal    \brief Authenticate a message transport.    For performance reasons, message authentication is tied to an individual   message transport instance.  For example in connection oriented transports   the authentication cookie can be cached against the connection avoiding   the overhead of authentication on every message.    For each process there is one instance of the QTransportAuth object.   For server processes it can determine the \link secure-exe-environ.html SXE   Program Identity \endlink and provide access to policy data to determine if   the message should be forwarded for action.  If not actioned, the message   may be treated as being from a flawed or malicious process.    Retrieve the instance with the getInstance() method.  The constructor is   disabled and instances of QTransportAuth should never be constructed by   calling classes.    To make the Authentication easier to use a proxied QIODevice is provided   which uses an internal QBuffer.    In the server code first get a pointer to a QTransportAuth::Data object   using the connectTransport() method:    \snippet doc/src/snippets/code/src_gui_embedded_qtransportauth_qws.cpp 0    Here it is asserted that the transport is trusted.  See the assumptions   listed in the \link secure-exe-environ.html SXE documentation \endlink    Then proxy in the authentication device:    \snippet doc/src/snippets/code/src_gui_embedded_qtransportauth_qws.cpp 1    In the client code it is similar.  Use the connectTransport() method   just the same then proxy in the authentication device instead of the   socket in write calls:    \snippet doc/src/snippets/code/src_gui_embedded_qtransportauth_qws.cpp 2 */
end_comment
begin_function_decl
specifier|static
name|int
name|hmac_md5
parameter_list|(
name|unsigned
name|char
modifier|*
name|text
parameter_list|,
comment|/* pointer to data stream */
name|int
name|text_length
parameter_list|,
comment|/* length of data stream */
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
comment|/* pointer to authentication key */
name|int
name|key_length
parameter_list|,
comment|/* length of authentication key */
name|unsigned
name|char
modifier|*
name|digest
comment|/* caller digest to be filled in */
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|KEY_CACHE_SIZE
define|#
directive|define
name|KEY_CACHE_SIZE
value|30
end_define
begin_decl_stmt
DECL|variable|errorStrings
specifier|const
name|char
modifier|*
specifier|const
name|errorStrings
index|[]
init|=
block|{
literal|"pending identity verification"
block|,
literal|"message too small to carry auth data"
block|,
literal|"cache miss on connection oriented transport"
block|,
literal|"no magic bytes on message"
block|,
literal|"key not found for prog id"
block|,
literal|"authorization key match failed"
block|,
literal|"key out of date"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|errorString
specifier|const
name|char
modifier|*
name|QTransportAuth
operator|::
name|errorString
parameter_list|(
specifier|const
name|Data
modifier|&
name|d
parameter_list|)
block|{
if|if
condition|(
operator|(
name|d
operator|.
name|status
operator|&
name|ErrMask
operator|)
operator|==
name|Success
condition|)
return|return
literal|"success"
return|;
name|int
name|e
init|=
name|d
operator|.
name|status
operator|&
name|ErrMask
decl_stmt|;
if|if
condition|(
name|e
operator|>
name|OutOfDate
condition|)
return|return
literal|"unknown"
return|;
return|return
name|errorStrings
index|[
name|e
index|]
return|;
block|}
end_function
begin_constructor
DECL|function|SxeRegistryLocker
name|SxeRegistryLocker
operator|::
name|SxeRegistryLocker
parameter_list|(
name|QObject
modifier|*
name|reg
parameter_list|)
member_init_list|:
name|m_success
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_reg
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|reg
condition|)
if|if
condition|(
operator|!
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|reg
argument_list|,
literal|"lockManifest"
argument_list|,
name|Q_RETURN_ARG
argument_list|(
name|bool
argument_list|,
name|m_success
argument_list|)
argument_list|)
condition|)
name|m_success
operator|=
literal|false
expr_stmt|;
name|m_reg
operator|=
name|reg
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~SxeRegistryLocker
name|SxeRegistryLocker
operator|::
name|~
name|SxeRegistryLocker
parameter_list|()
block|{
if|if
condition|(
name|m_success
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|m_reg
argument_list|,
literal|"unlockManifest"
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_constructor
DECL|function|QTransportAuthPrivate
name|QTransportAuthPrivate
operator|::
name|QTransportAuthPrivate
parameter_list|()
member_init_list|:
name|keyInitialised
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_packageRegistry
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QTransportAuthPrivate
name|QTransportAuthPrivate
operator|::
name|~
name|QTransportAuthPrivate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \internal   Construct a new QTransportAuth */
end_comment
begin_constructor
DECL|function|QTransportAuth
name|QTransportAuth
operator|::
name|QTransportAuth
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTransportAuthPrivate
argument_list|)
block|{
comment|// qDebug( "creating transport auth" );
block|}
end_constructor
begin_comment
comment|/*!   \internal   Destructor */
end_comment
begin_destructor
DECL|function|~QTransportAuth
name|QTransportAuth
operator|::
name|~
name|QTransportAuth
parameter_list|()
block|{
comment|// qDebug( "deleting transport auth" );
block|}
end_destructor
begin_comment
comment|/*!   Set the process key for this currently running Qt Extended process to   the \a authdata.  \a authdata should be sizeof(struct AuthCookie)   in length and contain the key and program id.  Use this method   when setting or changing the SXE identity of the current program. */
end_comment
begin_function
DECL|function|setProcessKey
name|void
name|QTransportAuth
operator|::
name|setProcessKey
parameter_list|(
specifier|const
name|char
modifier|*
name|authdata
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
operator|::
name|memcpy
argument_list|(
operator|&
name|d
operator|->
name|authKey
argument_list|,
name|authdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|AuthCookie
argument_list|)
argument_list|)
expr_stmt|;
name|QFile
name|proc_key
argument_list|(
name|QLatin1String
argument_list|(
literal|"/proc/self/lids_key"
argument_list|)
argument_list|)
decl_stmt|;
comment|// where proc key exists use that instead
if|if
condition|(
name|proc_key
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qint64
name|kb
init|=
name|proc_key
operator|.
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
operator|->
name|authKey
operator|.
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|qDebug
argument_list|(
literal|"Using %li bytes of /proc/%i/lids_key\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|kb
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|kb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|keyInitialised
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Apply \a key as the process key for the currently running application.    \a prog is current ignored    Deprecated function */
end_comment
begin_function
DECL|function|setProcessKey
name|void
name|QTransportAuth
operator|::
name|setProcessKey
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|setProcessKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|displaybuf
index|[
name|QSXE_KEY_LEN
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"key"
operator|<<
name|displaybuf
operator|<<
literal|"set"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Register \a pr as a policy handler object.  The object pointed to   by \a pr should have a slot as follows   \snippet doc/src/snippets/code/src_gui_embedded_qtransportauth_qws.cpp 3   All requests received by this server will then generate a call to   this slot, and may be processed for policy compliance. */
end_comment
begin_function
DECL|function|registerPolicyReceiver
name|void
name|QTransportAuth
operator|::
name|registerPolicyReceiver
parameter_list|(
name|QObject
modifier|*
name|pr
parameter_list|)
block|{
comment|// not every policy receiver needs setup - no error if this fails
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|pr
argument_list|,
literal|"setupPolicyCheck"
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|policyCheck
argument_list|(
name|QTransportAuth
operator|::
name|Data
operator|&
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|pr
argument_list|,
name|SLOT
argument_list|(
name|policyCheck
argument_list|(
name|QTransportAuth
operator|::
name|Data
operator|&
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Unregister the \a pr from being a policy handler.  No more policyCheck signals   are received by this object. */
end_comment
begin_function
DECL|function|unregisterPolicyReceiver
name|void
name|QTransportAuth
operator|::
name|unregisterPolicyReceiver
parameter_list|(
name|QObject
modifier|*
name|pr
parameter_list|)
block|{
name|disconnect
argument_list|(
name|pr
argument_list|)
expr_stmt|;
comment|// not every policy receiver needs tear down - no error if this fails
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|pr
argument_list|,
literal|"teardownPolicyCheck"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Record a new transport connection with \a properties and \a descriptor.    The calling code is responsible for destroying the returned data when the   tranport connection is closed. */
end_comment
begin_function
DECL|function|connectTransport
name|QTransportAuth
operator|::
name|Data
modifier|*
name|QTransportAuth
operator|::
name|connectTransport
parameter_list|(
name|unsigned
name|char
name|properties
parameter_list|,
name|int
name|descriptor
parameter_list|)
block|{
name|Data
modifier|*
name|data
init|=
operator|new
name|Data
argument_list|(
name|properties
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
name|data
operator|->
name|status
operator|=
name|Pending
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!   Is the transport trusted.  This is true iff data written into the   transport medium cannot be intercepted or modified by another process.   This is for example true for Unix Domain Sockets, but not for shared   memory or UDP sockets.    There is of course an underlying assumption that the kernel implementing   the transport is sound, ie it cannot be compromised by writing to   /dev/kmem or loading untrusted modules */
end_comment
begin_function
DECL|function|trusted
specifier|inline
name|bool
name|QTransportAuth
operator|::
name|Data
operator|::
name|trusted
parameter_list|()
specifier|const
block|{
return|return
call|(
name|bool
call|)
argument_list|(
name|properties
operator|&
name|Trusted
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Assert that the transport is trusted.    For example with respect to shared memory, if it is ensured that no untrusted   root processes are running, and that unix permissions have been set such that   any untrusted non-root processes do not have access rights, then a shared   memory transport could be asserted to be trusted.    \sa trusted() */
end_comment
begin_function
DECL|function|setTrusted
specifier|inline
name|void
name|QTransportAuth
operator|::
name|Data
operator|::
name|setTrusted
parameter_list|(
name|bool
name|t
parameter_list|)
block|{
name|properties
operator|=
name|t
condition|?
name|properties
operator||
name|Trusted
else|:
name|properties
operator|&
operator|~
name|Trusted
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Is the transport connection oriented.  This is true iff once a connection   has been accepted, and state established, then further messages over the   transport are guaranteed to have come from the original connecting entity.   This is for example true for Unix Domain Sockets, but not   for shared memory or UDP sockets.    By extension if the transport is not trusted() then it should not be   assumed to be connection oriented, since spoofed connection information   could be created.  For example if we assume the TCP/IP transport is   trusted, it can be treated as connection oriented; but this is only the   case if intervening routers are trusted.    Connection oriented transports have authorization cached against the   connection, and thus authorization is only done at connect time. */
end_comment
begin_function
DECL|function|connection
specifier|inline
name|bool
name|QTransportAuth
operator|::
name|Data
operator|::
name|connection
parameter_list|()
specifier|const
block|{
return|return
call|(
name|bool
call|)
argument_list|(
name|properties
operator|&
name|Connection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Assert that the transport is connection oriented.    \sa connection() */
end_comment
begin_function
DECL|function|setConnection
specifier|inline
name|void
name|QTransportAuth
operator|::
name|Data
operator|::
name|setConnection
parameter_list|(
name|bool
name|t
parameter_list|)
block|{
name|properties
operator|=
name|t
condition|?
name|properties
operator||
name|Connection
else|:
name|properties
operator|&
operator|~
name|Connection
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Return a pointer to the instance of this process's QTransportAuth object */
end_comment
begin_function
DECL|function|getInstance
name|QTransportAuth
modifier|*
name|QTransportAuth
operator|::
name|getInstance
parameter_list|()
block|{
specifier|static
name|QTransportAuth
name|theInstance
decl_stmt|;
return|return
operator|&
name|theInstance
return|;
block|}
end_function
begin_comment
comment|/*!   Set the full path to the key file    Since this is normally relative to Qtopia::qpeDir() this needs to be   set within the Qt Extended framework.    The keyfile should be protected by file permissions or by MAC rules   such that it can only be read/written by the "qpe" server process */
end_comment
begin_function
DECL|function|setKeyFilePath
name|void
name|QTransportAuth
operator|::
name|setKeyFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_keyFilePath
operator|=
name|path
expr_stmt|;
block|}
end_function
begin_function
DECL|function|keyFilePath
name|QString
name|QTransportAuth
operator|::
name|keyFilePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTransportAuth
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_keyFilePath
return|;
block|}
end_function
begin_function
DECL|function|setLogFilePath
name|void
name|QTransportAuth
operator|::
name|setLogFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_logFilePath
operator|=
name|path
expr_stmt|;
block|}
end_function
begin_function
DECL|function|logFilePath
name|QString
name|QTransportAuth
operator|::
name|logFilePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTransportAuth
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_logFilePath
return|;
block|}
end_function
begin_function
DECL|function|setPackageRegistry
name|void
name|QTransportAuth
operator|::
name|setPackageRegistry
parameter_list|(
name|QObject
modifier|*
name|registry
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_packageRegistry
operator|=
name|registry
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isDiscoveryMode
name|bool
name|QTransportAuth
operator|::
name|isDiscoveryMode
parameter_list|()
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|SXE_DISCOVERY
argument_list|)
specifier|static
name|bool
name|checked
init|=
literal|false
decl_stmt|;
specifier|static
name|bool
name|yesItIs
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|checked
condition|)
return|return
name|yesItIs
return|;
name|yesItIs
operator|=
operator|(
name|getenv
argument_list|(
literal|"SXE_DISCOVERY_MODE"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|yesItIs
condition|)
block|{
name|qWarning
argument_list|(
literal|"SXE Discovery mode on, ALLOWING ALL requests and logging to %s"
argument_list|,
name|qPrintable
argument_list|(
name|logFilePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QFile
operator|::
name|remove
argument_list|(
name|logFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|checked
operator|=
literal|true
expr_stmt|;
return|return
name|yesItIs
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   \internal   Return the authorizer device mapped to this client.  Note that this   could probably all be void* instead of QWSClient* for generality.   Until the need for that rears its head its QWSClient* to save the casts.    #### OK the need has arrived, but the public API is frozen. */
end_comment
begin_function
DECL|function|passThroughByClient
name|QIODevice
modifier|*
name|QTransportAuth
operator|::
name|passThroughByClient
parameter_list|(
name|QWSClient
modifier|*
name|client
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTransportAuth
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|buffersByClient
operator|.
name|contains
argument_list|(
name|client
argument_list|)
condition|)
block|{
return|return
name|d
operator|->
name|buffersByClient
index|[
name|client
index|]
return|;
block|}
comment|// qWarning( "buffer not found for client %p", client );
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Return a QIODevice pointer (to an internal QBuffer) which can be used   to receive data after authorization on transport \a d.    The return QIODevice will act as a pass-through.    The data will be consumed from \a iod and forwarded on to the returned   QIODevice which can be connected to readyRead() signal handlers in   place of the original QIODevice \a iod.    This will be called in the server process to handle incoming   authenticated requests.    The returned QIODevice will take ownership of \a data which will be deleted   when the QIODevice is delected.    \sa setTargetDevice() */
end_comment
begin_function
DECL|function|recvBuf
name|QAuthDevice
modifier|*
name|QTransportAuth
operator|::
name|recvBuf
parameter_list|(
name|QTransportAuth
operator|::
name|Data
modifier|*
name|data
parameter_list|,
name|QIODevice
modifier|*
name|iod
parameter_list|)
block|{
return|return
operator|new
name|QAuthDevice
argument_list|(
name|iod
argument_list|,
name|data
argument_list|,
name|QAuthDevice
operator|::
name|Receive
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Return a QIODevice pointer (to an internal QBuffer) which can be used   to write data onto, for authorization on transport \a d.    The return QIODevice will act as a pass-through.    The data written to the return QIODevice will be forwarded on to the   returned QIODevice.  In the case of a QTcpSocket, this will cause it   to send out the data with the authentication information on it.    This will be called in the client process to generate outgoing   authenticated requests.    The returned QIODevice will take ownership of \a data which will be deleted   when the QIODevice is delected.    \sa setTargetDevice() */
end_comment
begin_function
DECL|function|authBuf
name|QAuthDevice
modifier|*
name|QTransportAuth
operator|::
name|authBuf
parameter_list|(
name|QTransportAuth
operator|::
name|Data
modifier|*
name|data
parameter_list|,
name|QIODevice
modifier|*
name|iod
parameter_list|)
block|{
return|return
operator|new
name|QAuthDevice
argument_list|(
name|iod
argument_list|,
name|data
argument_list|,
name|QAuthDevice
operator|::
name|Send
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getClientKey
specifier|const
name|unsigned
name|char
modifier|*
name|QTransportAuth
operator|::
name|getClientKey
parameter_list|(
name|unsigned
name|char
name|progId
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|getClientKey
argument_list|(
name|progId
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|invalidateClientKeyCache
name|void
name|QTransportAuth
operator|::
name|invalidateClientKeyCache
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
name|d
operator|->
name|invalidateClientKeyCache
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getKeyFileMutex
name|QMutex
modifier|*
name|QTransportAuth
operator|::
name|getKeyFileMutex
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
return|return
operator|&
name|d
operator|->
name|keyfileMutex
return|;
block|}
end_function
begin_comment
comment|/*    \internal    Respond to the destroyed(QObject*) signal of the QAuthDevice's    client object and remove it from the buffersByClient lookup hash. */
end_comment
begin_function
DECL|function|bufferDestroyed
name|void
name|QTransportAuth
operator|::
name|bufferDestroyed
parameter_list|(
name|QObject
modifier|*
name|cli
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTransportAuth
argument_list|)
expr_stmt|;
if|if
condition|(
name|cli
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|buffersByClient
operator|.
name|contains
argument_list|(
name|cli
argument_list|)
condition|)
block|{
name|d
operator|->
name|buffersByClient
operator|.
name|remove
argument_list|(
name|cli
argument_list|)
expr_stmt|;
comment|// qDebug( "@@@@@@@ client %p removed @@@@@@@@@", cli );
block|}
comment|// qDebug( "           client count %d", d->buffersByClient.count() );
block|}
end_function
begin_function
DECL|function|authorizeRequest
name|bool
name|QTransportAuth
operator|::
name|authorizeRequest
parameter_list|(
name|QTransportAuth
operator|::
name|Data
modifier|&
name|d
parameter_list|,
specifier|const
name|QString
modifier|&
name|request
parameter_list|)
block|{
name|bool
name|isAuthorized
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|isEmpty
argument_list|()
operator|&&
name|request
operator|!=
name|QLatin1String
argument_list|(
literal|"Unknown"
argument_list|)
condition|)
block|{
name|d
operator|.
name|status
operator|&=
name|QTransportAuth
operator|::
name|ErrMask
expr_stmt|;
comment|// clear the status
emit|emit
name|policyCheck
argument_list|(
name|d
argument_list|,
name|request
argument_list|)
emit|;
name|isAuthorized
operator|=
operator|(
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator|==
name|QTransportAuth
operator|::
name|Allow
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SXE_DISCOVERY
argument_list|)
if|if
condition|(
name|isDiscoveryMode
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTSTREAM
if|if
condition|(
operator|!
name|logFilePath
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|log
argument_list|(
name|logFilePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|log
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Append
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not write to log in discovery mode: %s"
argument_list|,
name|qPrintable
argument_list|(
name|logFilePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTextStream
name|ts
argument_list|(
operator|&
name|log
argument_list|)
decl_stmt|;
name|ts
operator|<<
name|d
operator|.
name|progId
operator|<<
literal|'\t'
operator|<<
operator|(
name|isAuthorized
condition|?
literal|"Allow"
else|:
literal|"Deny"
operator|)
operator|<<
literal|'\t'
operator|<<
name|request
operator|<<
name|endl
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|isAuthorized
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|isAuthorized
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s - denied: for Program Id %u [PID %d]"
argument_list|,
name|qPrintable
argument_list|(
name|request
argument_list|)
argument_list|,
name|d
operator|.
name|progId
argument_list|,
name|d
operator|.
name|processId
argument_list|)
expr_stmt|;
name|char
name|linkTarget
index|[
name|BUF_SIZE
index|]
init|=
literal|""
decl_stmt|;
name|char
name|exeLink
index|[
name|BUF_SIZE
index|]
init|=
literal|""
decl_stmt|;
name|char
name|cmdlinePath
index|[
name|BUF_SIZE
index|]
init|=
literal|""
decl_stmt|;
name|char
name|cmdline
index|[
name|BUF_SIZE
index|]
init|=
literal|""
decl_stmt|;
comment|//get executable from /proc/pid/exe
name|snprintf
argument_list|(
name|exeLink
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"/proc/%d/exe"
argument_list|,
name|d
operator|.
name|processId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|::
name|readlink
argument_list|(
name|exeLink
argument_list|,
name|linkTarget
argument_list|,
name|BUF_SIZE
operator|-
literal|1
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"SXE:- Error encountered in retrieving executable link target from /proc/%u/exe : %s"
argument_list|,
name|d
operator|.
name|processId
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|linkTarget
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
name|linkTarget
argument_list|)
expr_stmt|;
block|}
comment|//get cmdline from proc/pid/cmdline
name|snprintf
argument_list|(
name|cmdlinePath
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"/proc/%d/cmdline"
argument_list|,
name|d
operator|.
name|processId
argument_list|)
expr_stmt|;
name|int
name|cmdlineFd
init|=
name|QT_OPEN
argument_list|(
name|cmdlinePath
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmdlineFd
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"SXE:- Error encountered in opening /proc/%u/cmdline: %s"
argument_list|,
name|d
operator|.
name|processId
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cmdline
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|QT_READ
argument_list|(
name|cmdlineFd
argument_list|,
name|cmdline
argument_list|,
name|BUF_SIZE
operator|-
literal|1
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"SXE:- Error encountered in reading /proc/%u/cmdline : %s"
argument_list|,
name|d
operator|.
name|processId
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cmdline
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
name|QT_CLOSE
argument_list|(
name|cmdlineFd
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_LOCAL6
argument_list|,
literal|"%s // PID:%u // ProgId:%u // Exe:%s // Request:%s // Cmdline:%s"
argument_list|,
literal|"<SXE Breach>"
argument_list|,
name|d
operator|.
name|processId
argument_list|,
name|d
operator|.
name|progId
argument_list|,
name|linkTarget
argument_list|,
name|qPrintable
argument_list|(
name|request
argument_list|)
argument_list|,
name|cmdline
argument_list|)
expr_stmt|;
block|}
return|return
name|isAuthorized
return|;
block|}
end_function
begin_function
DECL|function|__fileOpen
specifier|inline
name|bool
name|__fileOpen
parameter_list|(
name|QFile
modifier|*
name|f
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
if|if
condition|(
name|f
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qDebug
argument_list|(
literal|"Opened file: %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|f
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Could not open file: %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|f
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|#
directive|else
return|return
operator|(
name|f
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   \internal   Find client keys for the \a progId.  If it is cached should be very   fast, otherwise requires a read of the secret key file    In the success case a pointer to the keys is returned.  The pointer is   to storage allocated for the internal cache and must be used asap.    The list returned is a sequence of one or more keys which match the   progId.  There is no separator, each 16 byte sequence represents a key.   The sequence is followed by two iterations of the SXE magic   bytes,eg  0xBA, 0xD4, 0xD4, 0xBA, 0xBA, 0xD4, 0xD4, 0xBA    NULL is returned in the following cases:   \list     \o the keyfiles could not be accessed - error condition     \o there was no key for the supplied program id - key auth failed   \endlist    Note that for the keyfiles, there is multi-thread and multi-process   concurrency issues: they can be read by the qpe process when   QTransportAuth calls getClientKey to verify a request, and they can be   read or written by the packagemanager when updating package data.    To protect against this, the keyfileMutex& SxeRegistryLocker is used.    The sxe_installer tool can also update inode and device numbers in   the manifest file, but this only occurs outside of normal operation,   so qpe and packagemanager are never running when this occurs. */
end_comment
begin_function
DECL|function|getClientKey
specifier|const
name|unsigned
name|char
modifier|*
name|QTransportAuthPrivate
operator|::
name|getClientKey
parameter_list|(
name|unsigned
name|char
name|progId
parameter_list|)
block|{
name|int
name|manifestMatchCount
init|=
literal|0
decl_stmt|;
name|struct
name|IdBlock
name|mr
decl_stmt|;
name|int
name|total_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result_ptr
decl_stmt|;
name|int
name|keysFound
init|=
literal|0
decl_stmt|;
name|bool
name|foundKey
decl_stmt|;
name|int
name|keysRead
init|=
literal|0
decl_stmt|;
name|struct
name|usr_key_entry
name|keys_list
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|keyCache
operator|.
name|contains
argument_list|(
name|progId
argument_list|)
condition|)
return|return
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|keyCache
index|[
name|progId
index|]
return|;
name|SxeRegistryLocker
name|rlock
argument_list|(
name|m_packageRegistry
argument_list|)
decl_stmt|;
comment|// ### Qt 4.3: this is hacky - see documentation for setKeyFilePath
name|QString
name|manifestPath
init|=
name|m_keyFilePath
operator|+
name|QLatin1String
argument_list|(
literal|"/manifest"
argument_list|)
decl_stmt|;
name|QString
name|actualKeyPath
init|=
name|QLatin1String
argument_list|(
literal|"/proc/lids/keys"
argument_list|)
decl_stmt|;
name|bool
name|noFailOnKeyMissing
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|actualKeyPath
argument_list|)
condition|)
block|{
name|actualKeyPath
operator|=
name|m_keyFilePath
operator|+
name|QLatin1String
argument_list|(
literal|"/"
name|QSXE_KEYFILE
argument_list|)
expr_stmt|;
block|}
name|QFile
name|kf
argument_list|(
name|actualKeyPath
argument_list|)
decl_stmt|;
name|QFile
name|mn
argument_list|(
name|manifestPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|__fileOpen
argument_list|(
operator|&
name|mn
argument_list|)
condition|)
goto|goto
name|key_not_found
goto|;
comment|// first find how much storage is needed
while|while
condition|(
name|mn
operator|.
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|IdBlock
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|mr
operator|.
name|progId
operator|==
name|progId
condition|)
name|manifestMatchCount
operator|++
expr_stmt|;
if|if
condition|(
name|manifestMatchCount
operator|==
literal|0
condition|)
goto|goto
name|key_not_found
goto|;
if|if
condition|(
operator|!
name|__fileOpen
argument_list|(
operator|&
name|kf
argument_list|)
condition|)
block|{
name|noFailOnKeyMissing
operator|=
literal|false
expr_stmt|;
goto|goto
name|key_not_found
goto|;
block|}
name|total_size
operator|=
literal|2
operator|*
name|QSXE_MAGIC_BYTES
operator|+
name|manifestMatchCount
operator|*
name|QSXE_KEY_LEN
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mn
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|result_ptr
operator|=
name|result
expr_stmt|;
comment|/* reading whole key array in is much more efficient, 99% case is this loop only        executes once, should not have more than 128 keyed items */
while|while
condition|(
operator|(
name|keysRead
operator|=
name|kf
operator|.
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keys_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usr_key_entry
argument_list|)
operator|*
literal|128
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* qDebug("PID %d: getClientKey() - read %d bytes = %d keys from %s", getpid(), keysRead,                 keysRead/sizeof(struct usr_key_entry), qPrintable(actualKeyPath)); */
name|keysRead
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|usr_key_entry
argument_list|)
expr_stmt|;
while|while
condition|(
name|mn
operator|.
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|IdBlock
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mr
operator|.
name|progId
operator|==
name|progId
condition|)
block|{
name|foundKey
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keysRead
condition|;
operator|++
name|i
control|)
block|{
comment|/* if ( i == 0 )                         qDebug()<< "         pid"<< getpid()<< "looking for device"<< (dev_t)mr.device<< "inode"<< (ino_t)mr.inode;                     qDebug()<< "         pid"<< getpid()<< "trying device"<<  keys_list[i].dev<< "inode"<<  keys_list[i].ino; */
if|if
condition|(
name|keys_list
index|[
name|i
index|]
operator|.
name|ino
operator|==
operator|(
name|ino_t
operator|)
name|mr
operator|.
name|inode
operator|&&
name|keys_list
index|[
name|i
index|]
operator|.
name|dev
operator|==
operator|(
name|dev_t
operator|)
name|mr
operator|.
name|device
condition|)
block|{
name|memcpy
argument_list|(
name|result_ptr
argument_list|,
name|keys_list
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
name|result_ptr
operator|+=
name|QSXE_KEY_LEN
expr_stmt|;
name|foundKey
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|foundKey
condition|)
block|{
name|keysFound
operator|++
expr_stmt|;
if|if
condition|(
name|keysFound
operator|==
name|manifestMatchCount
condition|)
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|result_ptr
operator|==
name|result
condition|)
comment|// nothing found!
goto|goto
name|key_not_found
goto|;
comment|// 2 x magic bytes sentinel at end of sequence
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|QSXE_MAGIC_BYTES
condition|;
operator|++
name|j
control|)
operator|*
name|result_ptr
operator|++
operator|=
name|magic
index|[
name|j
index|]
expr_stmt|;
name|keyCache
operator|.
name|insert
argument_list|(
name|progId
argument_list|,
name|result
argument_list|,
name|total_size
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* qDebug( "PID %d : Found %d client keys for prog %u", getpid(), keysFound, progId ); */
goto|goto
name|success_out
goto|;
name|key_not_found
label|:
if|if
condition|(
name|noFailOnKeyMissing
condition|)
comment|// return an "empty" set of keys in this case
block|{
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|QSXE_MAGIC_BYTES
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|result_ptr
operator|=
name|result
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|QSXE_MAGIC_BYTES
condition|;
operator|++
name|j
control|)
operator|*
name|result_ptr
operator|++
operator|=
name|magic
index|[
name|j
index|]
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
return|;
block|}
name|qWarning
argument_list|(
literal|"PID %d : Not found client key for prog %u"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|progId
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
name|success_out
label|:
if|if
condition|(
name|mn
operator|.
name|isOpen
argument_list|()
condition|)
name|mn
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|kf
operator|.
name|isOpen
argument_list|()
condition|)
name|kf
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
return|;
block|}
end_function
begin_function
DECL|function|invalidateClientKeyCache
name|void
name|QTransportAuthPrivate
operator|::
name|invalidateClientKeyCache
parameter_list|()
block|{
name|keyfileMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|keyCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|keyfileMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|////
end_comment
begin_comment
comment|////  RequestAnalyzer definition
end_comment
begin_comment
comment|////
end_comment
begin_constructor
DECL|function|RequestAnalyzer
name|RequestAnalyzer
operator|::
name|RequestAnalyzer
parameter_list|()
member_init_list|:
name|moreData
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dataSize
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~RequestAnalyzer
name|RequestAnalyzer
operator|::
name|~
name|RequestAnalyzer
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Analzye the data in the\a msgQueue according to some protocol   and produce a request string for policy analysis.    If enough data is in the queue for analysis of a complete message,   return a non-null string, and set a flag so requireMoreData() will   return false; otherwise return a null string and requireMoreData()   return true.    The amount of bytes analyzed is then available via bytesAnalyzed().    A null string is also returned in the case where the message was   corrupt and could not be analyzed.  In this case requireMoreData()   returns false.  Note: this method will modify the msgQueue and pull off the data   deemed to be corrupt, in the case of corrupt data.    In all other cases the msgQueue is left alone.  The calling code   should then pull off the analyzed data.  Use bytesAnalzyed() to   find how much data to pull off the queue. */
end_comment
begin_function
DECL|function|analyze
name|QString
name|RequestAnalyzer
operator|::
name|analyze
parameter_list|(
name|QByteArray
modifier|*
name|msgQueue
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_QWS
name|dataSize
operator|=
literal|0
expr_stmt|;
name|moreData
operator|=
literal|false
expr_stmt|;
name|QBuffer
name|cmdBuf
argument_list|(
name|msgQueue
argument_list|)
decl_stmt|;
name|cmdBuf
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
name|QWSCommand
operator|::
name|Type
name|command_type
init|=
call|(
name|QWSCommand
operator|::
name|Type
call|)
argument_list|(
name|qws_read_uint
argument_list|(
operator|&
name|cmdBuf
argument_list|)
argument_list|)
decl_stmt|;
name|QWSCommand
modifier|*
name|command
init|=
name|QWSCommand
operator|::
name|factory
argument_list|(
name|command_type
argument_list|)
decl_stmt|;
comment|// if NULL, factory will have already printed warning for bogus
comment|// command_type just purge the bad stuff and attempt to recover
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
block|{
operator|*
name|msgQueue
operator|=
name|msgQueue
operator|->
name|mid
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|request
init|=
name|QLatin1String
argument_list|(
name|qws_getCommandTypeString
argument_list|(
name|command_type
argument_list|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COP
if|if
condition|(
operator|!
name|command
operator|->
name|read
argument_list|(
operator|&
name|cmdBuf
argument_list|)
condition|)
block|{
comment|// not all command arrived yet - come back later
operator|delete
name|command
expr_stmt|;
name|moreData
operator|=
literal|true
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|command_type
operator|==
name|QWSCommand
operator|::
name|QCopSend
condition|)
block|{
name|QWSQCopSendCommand
modifier|*
name|sendCommand
init|=
cast|static_cast
argument_list|<
name|QWSQCopSendCommand
operator|*
argument_list|>
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|request
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"/QCop/%1/%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|sendCommand
operator|->
name|channel
argument_list|)
operator|.
name|arg
argument_list|(
name|sendCommand
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|command_type
operator|==
name|QWSCommand
operator|::
name|QCopRegisterChannel
condition|)
block|{
name|QWSQCopRegisterChannelCommand
modifier|*
name|registerCommand
init|=
cast|static_cast
argument_list|<
name|QWSQCopRegisterChannelCommand
operator|*
argument_list|>
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|request
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"/QCop/RegisterChannel/%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|registerCommand
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dataSize
operator|=
name|QWS_PROTOCOL_ITEM_SIZE
argument_list|(
operator|*
name|command
argument_list|)
expr_stmt|;
operator|delete
name|command
expr_stmt|;
return|return
name|request
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|msgQueue
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|////
end_comment
begin_comment
comment|////  AuthDevice definition
end_comment
begin_comment
comment|////
end_comment
begin_comment
comment|/*!   Constructs a new auth device for the transport \a data and I/O device \a parent.    Incoming or outgoing data will be authenticated according to the auth direction \a dir.    The auth device will take ownership of the transport \a data and delete it when the device   is destroyed. */
end_comment
begin_constructor
DECL|function|QAuthDevice
name|QAuthDevice
operator|::
name|QAuthDevice
parameter_list|(
name|QIODevice
modifier|*
name|parent
parameter_list|,
name|QTransportAuth
operator|::
name|Data
modifier|*
name|data
parameter_list|,
name|AuthDirection
name|dir
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
name|data
argument_list|)
member_init_list|,
name|way
argument_list|(
name|dir
argument_list|)
member_init_list|,
name|m_target
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_client
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_bytesAvailable
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_skipWritten
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|analyzer
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|dir
operator|==
name|Receive
condition|)
comment|// server side
block|{
name|connect
argument_list|(
name|m_target
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|recvReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connect
argument_list|(
name|m_target
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|connect
argument_list|(
name|m_target
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|targetBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QAuthDevice
name|QAuthDevice
operator|::
name|~
name|QAuthDevice
parameter_list|()
block|{
if|if
condition|(
name|analyzer
condition|)
operator|delete
name|analyzer
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \internal   Store a pointer to the related device or instance which this   authorizer is proxying for */
end_comment
begin_function
DECL|function|setClient
name|void
name|QAuthDevice
operator|::
name|setClient
parameter_list|(
name|QObject
modifier|*
name|cli
parameter_list|)
block|{
name|m_client
operator|=
name|cli
expr_stmt|;
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|buffersByClient
index|[
name|cli
index|]
operator|=
name|this
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|cli
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
argument_list|,
name|SLOT
argument_list|(
name|bufferDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// qDebug( "@@@@@@@@@@@@ client set %p @@@@@@@@@", cli );
comment|// qDebug( "           client count %d", QTransportAuth::getInstance()->d_func()->buffersByClient.count() );
block|}
end_function
begin_function
DECL|function|client
name|QObject
modifier|*
name|QAuthDevice
operator|::
name|client
parameter_list|()
specifier|const
block|{
return|return
name|m_client
return|;
block|}
end_function
begin_comment
comment|/*   \fn void QAuthDevice::authViolation(QTransportAuth::Data&)    This signal is emitted if an authorization failure is generated, as   described in checkAuth();    \sa checkAuth() */
end_comment
begin_comment
comment|/*   \fn void QAuthDevice::policyCheck(QTransportAuth::Data&transport, const QString&request )    This signal is emitted when a transport successfully delivers a request   and gives the opportunity to either deny or accept the request.    This signal must be connected in the same thread, ie it cannot be queued.    As soon as all handlers connected to this signal are processed the Allow or   Deny state on the \a transport is checked, and the request is allowed or denied   accordingly.    \sa checkAuth() */
end_comment
begin_comment
comment|/*!   \internal   Reimplement QIODevice writeData method.    For client end, when the device is written to the incoming data is   processed and an authentication header calculated.  This is pushed   into the target device, followed by the actual incoming data (the   payload).    For server end, it is a fatal error to write to the device. */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QAuthDevice
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
if|if
condition|(
name|way
operator|==
name|Receive
condition|)
comment|// server
return|return
name|m_target
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
return|;
comment|// client
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|displaybuf
index|[
literal|1024
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|header
index|[
name|QSXE_HEADER_LEN
index|]
decl_stmt|;
operator|::
name|memset
argument_list|(
name|header
argument_list|,
literal|0
argument_list|,
name|QSXE_HEADER_LEN
argument_list|)
expr_stmt|;
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|authToMessage
argument_list|(
operator|*
name|d
argument_list|,
name|header
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|m_target
operator|->
name|write
argument_list|(
name|header
argument_list|,
name|QSXE_HEADER_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
name|QSXE_HEADER_LEN
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%d QAuthDevice::writeData - CLIENT: Header written: %s"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|displaybuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_skipWritten
operator|+=
name|QSXE_HEADER_LEN
expr_stmt|;
block|}
name|m_target
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|int
name|bytesToDisplay
init|=
name|bytes
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dataptr
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
decl_stmt|;
while|while
condition|(
name|bytesToDisplay
operator|>
literal|0
condition|)
block|{
name|int
name|amt
init|=
name|bytes
operator|<
literal|500
condition|?
name|bytes
else|:
literal|500
decl_stmt|;
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
name|dataptr
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%d QAuthDevice::writeData - CLIENT: %s"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|bytes
operator|>
literal|0
condition|?
name|displaybuf
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|dataptr
operator|+=
literal|500
expr_stmt|;
name|bytesToDisplay
operator|-=
literal|500
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|m_target
operator|->
name|inherits
argument_list|(
literal|"QAbstractSocket"
argument_list|)
condition|)
cast|static_cast
argument_list|<
name|QAbstractSocket
operator|*
argument_list|>
argument_list|(
name|m_target
argument_list|)
operator|->
name|flush
argument_list|()
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_comment
comment|/*!   Reimplement from QIODevice    Read data out of the internal message queue, reduce the queue by the amount   read.  Note that the amount available is only ever the size of a command   (although a command can be very big) since we need to check at command   boundaries for new authentication headers. */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QAuthDevice
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
if|if
condition|(
name|way
operator|==
name|Send
condition|)
comment|// client
return|return
name|m_target
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
return|;
if|if
condition|(
name|msgQueue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|displaybuf
index|[
literal|1024
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|msgQueue
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|msgQueue
operator|.
name|size
argument_list|()
operator|>
literal|500
condition|?
literal|500
else|:
name|msgQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|getpid
argument_list|()
operator|<<
literal|"QAuthDevice::readData() buffered/requested/avail"
operator|<<
name|msgQueue
operator|.
name|size
argument_list|()
operator|<<
name|maxSize
operator|<<
name|m_bytesAvailable
operator|<<
name|displaybuf
expr_stmt|;
endif|#
directive|endif
name|Q_ASSERT
argument_list|(
name|m_bytesAvailable
operator|<=
name|msgQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qint64
name|bytes
init|=
operator|(
name|maxSize
operator|>
name|m_bytesAvailable
operator|)
condition|?
name|m_bytesAvailable
else|:
name|maxSize
decl_stmt|;
operator|::
name|memcpy
argument_list|(
name|data
argument_list|,
name|msgQueue
operator|.
name|constData
argument_list|()
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|msgQueue
operator|=
name|msgQueue
operator|.
name|mid
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|m_bytesAvailable
operator|-=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Receive readyRead signal from the target recv device.  In response   authorize the data, and write results out to the recvBuf() device   for processing by the application.  Trigger the readyRead signal.    Authorizing involves first checking the transport is valid, ie the   handshake has either already been done and is cached on a trusted   transport, or was valid with this message; then second passing the   string representation of the service request up to any policyReceivers    If either of these fail, the message is denied.  In discovery mode   denied messages are allowed, but the message is logged. */
end_comment
begin_function
DECL|function|recvReadyRead
name|void
name|QAuthDevice
operator|::
name|recvReadyRead
parameter_list|()
block|{
name|qint64
name|bytes
init|=
name|m_target
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return;
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
name|QUnixSocket
modifier|*
name|usock
init|=
cast|static_cast
argument_list|<
name|QUnixSocket
operator|*
argument_list|>
argument_list|(
name|m_target
argument_list|)
decl_stmt|;
name|QUnixSocketMessage
name|msg
init|=
name|usock
operator|->
name|read
argument_list|()
decl_stmt|;
name|msgQueue
operator|.
name|append
argument_list|(
name|msg
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|processId
operator|=
name|msg
operator|.
name|processId
argument_list|()
expr_stmt|;
comment|// if "fragmented" packet 1/2 way through start of a command, ie
comment|// in the QWS msg type, cant do anything, come back later when
comment|// there's more of the packet
if|if
condition|(
name|msgQueue
operator|.
name|size
argument_list|()
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|// qDebug()<< "returning: msg size too small"<< msgQueue.size();
return|return;
block|}
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|displaybuf
index|[
literal|1024
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|displaybuf
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|msgQueue
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|msgQueue
operator|.
name|size
argument_list|()
operator|>
literal|500
condition|?
literal|500
else|:
name|msgQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%d ***** SERVER read %lli bytes - msg %s"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|bytes
argument_list|,
name|displaybuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|bufHasMessages
init|=
name|msgQueue
operator|.
name|size
argument_list|()
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
while|while
condition|(
name|bufHasMessages
condition|)
block|{
name|unsigned
name|char
name|saveStatus
init|=
name|d
operator|->
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|status
operator|&
name|QTransportAuth
operator|::
name|ErrMask
operator|)
operator|==
name|QTransportAuth
operator|::
name|NoSuchKey
condition|)
block|{
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|authorizeRequest
argument_list|(
operator|*
name|d
argument_list|,
name|QLatin1String
argument_list|(
literal|"NoSuchKey"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|authFromMessage
argument_list|(
operator|*
name|d
argument_list|,
name|msgQueue
argument_list|,
name|msgQueue
operator|.
name|size
argument_list|()
argument_list|)
condition|)
block|{
comment|// not all arrived yet?  come back later
if|if
condition|(
operator|(
name|d
operator|->
name|status
operator|&
name|QTransportAuth
operator|::
name|ErrMask
operator|)
operator|==
name|QTransportAuth
operator|::
name|TooSmall
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|saveStatus
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|d
operator|->
name|status
operator|&
name|QTransportAuth
operator|::
name|ErrMask
operator|)
operator|==
name|QTransportAuth
operator|::
name|NoMagic
condition|)
block|{
comment|// no msg auth header, don't change the success status for connections
if|if
condition|(
name|d
operator|->
name|connection
argument_list|()
condition|)
name|d
operator|->
name|status
operator|=
name|saveStatus
expr_stmt|;
block|}
else|else
block|{
comment|// msg auth header detected and auth determined, remove hdr
name|msgQueue
operator|=
name|msgQueue
operator|.
name|mid
argument_list|(
name|QSXE_HEADER_LEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authorizeMessage
argument_list|()
condition|)
break|break;
name|bufHasMessages
operator|=
name|msgQueue
operator|.
name|size
argument_list|()
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**   \internal   Handle bytesWritten signals from the underlying target device.   We adjust the target's value for bytes that are part of auth packets. */
end_comment
begin_function
DECL|function|targetBytesWritten
name|void
name|QAuthDevice
operator|::
name|targetBytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|m_skipWritten
operator|>=
name|bytes
condition|)
block|{
name|m_skipWritten
operator|-=
name|bytes
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_skipWritten
operator|>
literal|0
condition|)
block|{
name|bytes
operator|-=
name|m_skipWritten
expr_stmt|;
name|m_skipWritten
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
emit|emit
name|bytesWritten
argument_list|(
name|bytes
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/**   \internal   Pre-process the message to determine what QWS command it is.  This   information is used as the "request" for the purposes of authorization.    The request and other data on the connection (id, PID, etc.) are forwarded   to all policy listeners by emitting a signal.    The signal must be processed synchronously because on return the allow/deny   status is used immediately to either drop or continue processing the message. */
end_comment
begin_function
DECL|function|authorizeMessage
name|bool
name|QAuthDevice
operator|::
name|authorizeMessage
parameter_list|()
block|{
if|if
condition|(
name|analyzer
operator|==
name|NULL
condition|)
name|analyzer
operator|=
operator|new
name|RequestAnalyzer
argument_list|()
expr_stmt|;
name|QString
name|request
init|=
call|(
modifier|*
name|analyzer
call|)
argument_list|(
operator|&
name|msgQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyzer
operator|->
name|requireMoreData
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|isAuthorized
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|isEmpty
argument_list|()
operator|&&
name|request
operator|!=
name|QLatin1String
argument_list|(
literal|"Unknown"
argument_list|)
condition|)
block|{
name|isAuthorized
operator|=
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|authorizeRequest
argument_list|(
operator|*
name|d
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
name|bool
name|moreToProcess
init|=
operator|(
name|msgQueue
operator|.
name|size
argument_list|()
operator|-
name|analyzer
operator|->
name|bytesAnalyzed
argument_list|()
operator|)
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAuthorized
condition|)
block|{
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|qDebug
argument_list|()
operator|<<
name|getpid
argument_list|()
operator|<<
literal|"SERVER authorized: releasing"
operator|<<
name|analyzer
operator|->
name|bytesAnalyzed
argument_list|()
operator|<<
literal|"byte command"
operator|<<
name|request
expr_stmt|;
endif|#
directive|endif
name|m_bytesAvailable
operator|=
name|analyzer
operator|->
name|bytesAnalyzed
argument_list|()
expr_stmt|;
emit|emit
name|QIODevice
operator|::
name|readyRead
argument_list|()
emit|;
return|return
name|moreToProcess
return|;
block|}
else|else
block|{
name|msgQueue
operator|=
name|msgQueue
operator|.
name|mid
argument_list|(
name|analyzer
operator|->
name|bytesAnalyzed
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setRequestAnalyzer
name|void
name|QAuthDevice
operator|::
name|setRequestAnalyzer
parameter_list|(
name|RequestAnalyzer
modifier|*
name|ra
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|ra
argument_list|)
expr_stmt|;
if|if
condition|(
name|analyzer
condition|)
operator|delete
name|analyzer
expr_stmt|;
name|analyzer
operator|=
name|ra
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Add authentication header to the beginning of a message     Note that the per-process auth cookie is used.  This key should be rewritten in    the binary image of the executable at install time to make it unique.     For this to be secure some mechanism (eg MAC kernel or other    permissions) must prevent other processes from reading the key.     The buffer must have AUTH_SPACE(0) bytes spare at the beginning for the    authentication header to be added.     Returns true if header successfully added.  Will fail if the    per-process key has not yet been set with setProcessKey() */
end_comment
begin_function
DECL|function|authToMessage
name|bool
name|QTransportAuth
operator|::
name|authToMessage
parameter_list|(
name|QTransportAuth
operator|::
name|Data
modifier|&
name|d
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|msgLen
parameter_list|)
block|{
comment|// qDebug( "authToMessage(): prog id %u", d.progId );
comment|// only authorize connection oriented transports once, unless key has changed
if|if
condition|(
name|d
operator|.
name|connection
argument_list|()
operator|&&
operator|(
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|ErrMask
operator|)
operator|!=
name|QTransportAuth
operator|::
name|Pending
operator|)
operator|&&
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|progId
operator|==
name|d
operator|.
name|progId
condition|)
return|return
literal|false
return|;
name|d
operator|.
name|progId
operator|=
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|progId
expr_stmt|;
comment|// If Unix socket credentials are being used the key wont be set
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|keyInitialised
condition|)
return|return
literal|false
return|;
name|unsigned
name|char
name|digest
index|[
name|QSXE_KEY_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|msgPtr
init|=
name|hdr
decl_stmt|;
comment|// magic always goes on the beginning
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|QSXE_MAGIC_BYTES
condition|;
operator|++
name|m
control|)
operator|*
name|msgPtr
operator|++
operator|=
name|magic
index|[
name|m
index|]
expr_stmt|;
name|hdr
index|[
name|QSXE_LEN_IDX
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|msgLen
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|trusted
argument_list|()
condition|)
block|{
comment|// Use HMAC
name|int
name|rc
init|=
name|hmac_md5
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msgLen
argument_list|,
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|,
name|digest
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|memcpy
argument_list|(
name|hdr
operator|+
name|QSXE_KEY_IDX
argument_list|,
name|digest
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hdr
operator|+
name|QSXE_KEY_IDX
argument_list|,
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
block|}
name|hdr
index|[
name|QSXE_PROG_IDX
index|]
operator|=
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|progId
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|keydisplay
index|[
name|QSXE_KEY_LEN
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|keydisplay
argument_list|,
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|key
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%d CLIENT Auth to message %s against prog id %u and key %s\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|msg
argument_list|,
name|d_func
argument_list|()
operator|->
name|authKey
operator|.
name|progId
argument_list|,
name|keydisplay
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// TODO implement sequence to prevent replay attack, not required
comment|// for trusted transports
name|hdr
index|[
name|QSXE_SEQ_IDX
index|]
operator|=
literal|1
expr_stmt|;
comment|// dummy sequence
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|Success
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Check authorization on the \a msg, which must be of size \a msgLen,   for the transport \a d.    If able to determine authorization, return the program identity of   the message source in the reference \a progId, and return true.    Otherwise return false.    If data is being received on a socket, it may be that more data is yet   needed before authentication can proceed.    Also the message may not be an authenticated at all.    In these cases the method returns false to indicate authorization could   not be determined:   \list     \i The message is too small to carry the authentication data        (status TooSmall is set on the \a d transport )     \i The 4 magic bytes are missing from the message start        (status NoMagic is set on the \a d transport )     \i The message is too small to carry the auth + claimed payload        (status TooSmall is set on the \a d transport )   \endlist    If however the authentication header (preceded by the magic bytes) and   any authenticated payload is received the method will determine the   authentication status, and return true.    In the following cases as well as returning true it will also emit   an authViolation():   \list     \i If the program id claimed by the message is not found in the key file        (status NoSuchKey is set on the \a d transport )     \i The authentication token failed against the claimed program id:         \list             \i in the case of trusted transports, the secret did not match             \i in the case of untrusted transports the HMAC code did not match         \endlist        (status FailMatch is set on the \a d transport )     \endlist    In these cases the authViolation( QTransportAuth::Data d ) signal is emitted   and the error string can be obtained from the status like this:   \snippet doc/src/snippets/code/src_gui_embedded_qtransportauth_qws.cpp 4 */
end_comment
begin_function
DECL|function|authFromMessage
name|bool
name|QTransportAuth
operator|::
name|authFromMessage
parameter_list|(
name|QTransportAuth
operator|::
name|Data
modifier|&
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|msgLen
parameter_list|)
block|{
if|if
condition|(
name|msgLen
operator|<
name|QSXE_MAGIC_BYTES
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|TooSmall
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// if no magic bytes, exit straight away
name|int
name|m
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|mptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|msg
argument_list|)
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|QSXE_MAGIC_BYTES
condition|;
operator|++
name|m
control|)
block|{
if|if
condition|(
operator|*
name|mptr
operator|++
operator|!=
name|magic
index|[
name|m
index|]
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|NoMagic
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|msgLen
operator|<
name|AUTH_SPACE
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|TooSmall
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// At this point we know the header is at least long enough to contain valid auth
comment|// data, however the data may be spoofed.  If it is not verified then the status will
comment|// be set to uncertified so the spoofed data will not be relied on.  However we want to
comment|// know the program id which is being reported (even if it might be spoofed) for
comment|// policy debugging purposes.  So set it here, rather than after verification.
name|d
operator|.
name|progId
operator|=
name|msg
index|[
name|QSXE_PROG_IDX
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|authhdr
index|[
name|QSXE_HEADER_LEN
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|authhdr
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|msg
argument_list|)
argument_list|,
name|QSXE_HEADER_LEN
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%d SERVER authFromMessage(): message header is %s"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|authhdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unsigned
name|char
name|authLen
init|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msg
index|[
name|QSXE_LEN_IDX
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|msgLen
operator|<
name|AUTH_SPACE
argument_list|(
name|authLen
argument_list|)
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|TooSmall
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|isCached
init|=
name|d_func
argument_list|()
operator|->
name|keyCache
operator|.
name|contains
argument_list|(
name|d
operator|.
name|progId
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|clientKey
init|=
name|d_func
argument_list|()
operator|->
name|getClientKey
argument_list|(
name|d
operator|.
name|progId
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientKey
operator|==
name|NULL
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|NoSuchKey
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|char
name|keydisplay
index|[
name|QSXE_KEY_LEN
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|hexstring
argument_list|(
name|keydisplay
argument_list|,
name|clientKey
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"\t\tauthFromMessage(): message %s against prog id %u and key %s\n"
argument_list|,
name|AUTH_DATA
argument_list|(
name|msg
argument_list|)
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|d
operator|.
name|progId
operator|)
argument_list|,
name|keydisplay
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|unsigned
name|char
modifier|*
name|auth_tok
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
name|QSXE_KEY_LEN
index|]
decl_stmt|;
name|bool
name|multi_tok
init|=
literal|false
decl_stmt|;
name|bool
name|need_to_recheck
init|=
literal|false
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|trusted
argument_list|()
condition|)
block|{
name|hmac_md5
argument_list|(
name|AUTH_DATA
argument_list|(
name|msg
argument_list|)
argument_list|,
name|authLen
argument_list|,
name|clientKey
argument_list|,
name|QSXE_KEY_LEN
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|auth_tok
operator|=
name|digest
expr_stmt|;
block|}
else|else
block|{
name|auth_tok
operator|=
name|clientKey
expr_stmt|;
name|multi_tok
operator|=
literal|true
expr_stmt|;
comment|// 1 or more keys are in the clientKey
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|auth_tok
argument_list|,
name|magic
argument_list|,
name|QSXE_MAGIC_BYTES
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|auth_tok
operator|+
name|QSXE_MAGIC_BYTES
argument_list|,
name|magic
argument_list|,
name|QSXE_MAGIC_BYTES
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|memcmp
argument_list|(
name|msg
operator|+
name|QSXE_KEY_IDX
argument_list|,
name|auth_tok
argument_list|,
name|QSXE_KEY_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|Success
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|multi_tok
condition|)
break|break;
name|auth_tok
operator|+=
name|QSXE_KEY_LEN
expr_stmt|;
block|}
comment|//the keys cached on d.progId may not contain the binary key because the cache entry was made
comment|//before the binary had first started, must search for client key again.
if|if
condition|(
name|isCached
condition|)
block|{
name|d_func
argument_list|()
operator|->
name|keyCache
operator|.
name|remove
argument_list|(
name|d
operator|.
name|progId
argument_list|)
expr_stmt|;
name|isCached
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QTransportAuth::authFromMessage(): key not found in set of keys cached"
operator|<<
literal|"against prog Id ="
operator|<<
name|d
operator|.
name|progId
operator|<<
literal|". Re-obtaining client key. "
expr_stmt|;
endif|#
directive|endif
name|clientKey
operator|=
name|d_func
argument_list|()
operator|->
name|getClientKey
argument_list|(
name|d
operator|.
name|progId
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientKey
operator|==
name|NULL
condition|)
block|{
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|NoSuchKey
expr_stmt|;
return|return
literal|false
return|;
block|}
name|need_to_recheck
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|need_to_recheck
operator|=
literal|false
expr_stmt|;
block|}
block|}
do|while
condition|(
name|need_to_recheck
condition|)
do|;
name|d
operator|.
name|status
operator|=
operator|(
name|d
operator|.
name|status
operator|&
name|QTransportAuth
operator|::
name|StatusMask
operator|)
operator||
name|QTransportAuth
operator|::
name|FailMatch
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
literal|"QTransportAuth::authFromMessage():failed authentication"
expr_stmt|;
name|FAREnforcer
operator|::
name|getInstance
argument_list|()
operator|->
name|logAuthAttempt
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|authViolation
argument_list|(
name|d
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QTRANSPORTAUTH_DEBUG
end_ifdef
begin_comment
comment|/*!   sprintf into hex - dest \a buf, src \a key, \a key_len is length of key.    The target buf should be [ key_len * 2 + 1 ] in size */
end_comment
begin_function
DECL|function|hexstring
name|void
name|hexstring
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
literal|0
init|;
name|i
operator|<
name|key_len
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
block|{
name|unsigned
name|char
name|lo_nibble
init|=
name|key
index|[
name|i
index|]
operator|&
literal|0x0f
decl_stmt|;
name|unsigned
name|char
name|hi_nibble
init|=
name|key
index|[
name|i
index|]
operator|>>
literal|4
decl_stmt|;
name|buf
index|[
name|p
index|]
operator|=
operator|(
name|int
operator|)
name|hi_nibble
operator|>
literal|9
condition|?
name|hi_nibble
operator|-
literal|10
operator|+
literal|'A'
else|:
name|hi_nibble
operator|+
literal|'0'
expr_stmt|;
name|buf
index|[
name|p
operator|+
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|lo_nibble
operator|>
literal|9
condition|?
name|lo_nibble
operator|-
literal|10
operator|+
literal|'A'
else|:
name|lo_nibble
operator|+
literal|'0'
expr_stmt|;
block|}
name|buf
index|[
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   HMAC MD5 as listed in RFC 2104    This code is taken from:        http://www.faqs.org/rfcs/rfc2104.html    with the allowance for keys other than length 16 removed, but otherwise   a straight cut-and-paste.    The HMAC_MD5 transform looks like:    \snippet doc/src/snippets/code/src.gui.embedded.qtransportauth_qws.cpp 5    \list     \i where K is an n byte key     \i ipad is the byte 0x36 repeated 64 times     \i opad is the byte 0x5c repeated 64 times     \i and text is the data being protected   \endlist    Hardware is available with accelerated implementations of HMAC-MD5 and   HMAC-SHA1.  Where this hardware is available, this routine should be   replaced with a call into the accelerated version. */
end_comment
begin_function
DECL|function|hmac_md5
specifier|static
name|int
name|hmac_md5
parameter_list|(
name|unsigned
name|char
modifier|*
name|text
parameter_list|,
comment|/* pointer to data stream */
name|int
name|text_length
parameter_list|,
comment|/* length of data stream */
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
comment|/* pointer to authentication key */
name|int
name|key_length
parameter_list|,
comment|/* length of authentication key */
name|unsigned
name|char
modifier|*
name|digest
comment|/* caller digest to be filled in */
parameter_list|)
block|{
name|MD5Context
name|context
decl_stmt|;
name|unsigned
name|char
name|k_ipad
index|[
literal|65
index|]
decl_stmt|;
comment|/* inner padding - * key XORd with ipad */
name|unsigned
name|char
name|k_opad
index|[
literal|65
index|]
decl_stmt|;
comment|/* outer padding - * key XORd with opad */
name|int
name|i
decl_stmt|;
comment|/* in this implementation key_length == 16 */
if|if
condition|(
name|key_length
operator|!=
literal|16
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key length was %d - must be 16 bytes"
argument_list|,
name|key_length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* start out by storing key in pads */
name|memset
argument_list|(
name|k_ipad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|k_ipad
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|k_opad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|k_opad
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|k_ipad
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|k_opad
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
expr_stmt|;
comment|/* XOR key with ipad and opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|k_ipad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|k_opad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
block|}
comment|/* perform inner MD5 */
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* init context for 1st pass */
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|k_ipad
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* start with inner pad */
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|text
argument_list|,
name|text_length
argument_list|)
expr_stmt|;
comment|/* then text of datagram */
name|MD5Final
argument_list|(
operator|&
name|context
argument_list|,
name|digest
argument_list|)
expr_stmt|;
comment|/* finish up 1st pass */
comment|/* perform outer MD5 */
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* init context for 2nd pass */
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|k_opad
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* start with outer pad */
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|digest
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* then results of 1st * hash */
name|MD5Final
argument_list|(
operator|&
name|context
argument_list|,
name|digest
argument_list|)
expr_stmt|;
comment|/* finish up 2nd pass */
return|return
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|member|minutelyRate
specifier|const
name|int
name|FAREnforcer
operator|::
name|minutelyRate
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|minutelyRate
comment|//allowed number of false authentication attempts per minute
end_comment
begin_decl_stmt
DECL|member|FARMessage
specifier|const
name|QString
name|FAREnforcer
operator|::
name|FARMessage
init|=
name|QLatin1String
argument_list|(
literal|"FAR_Exceeded"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|SxeTag
specifier|const
name|QString
name|FAREnforcer
operator|::
name|SxeTag
init|=
name|QLatin1String
argument_list|(
literal|"<SXE Breach>"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|minute
specifier|const
name|int
name|FAREnforcer
operator|::
name|minute
init|=
literal|60
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|FAREnforcer
name|FAREnforcer
operator|::
name|FAREnforcer
parameter_list|()
member_init_list|:
name|authAttempts
argument_list|()
block|{
name|QDateTime
name|nullDateTime
init|=
name|QDateTime
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|minutelyRate
condition|;
name|i
operator|++
control|)
name|authAttempts
operator|<<
name|nullDateTime
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|getInstance
name|FAREnforcer
modifier|*
name|FAREnforcer
operator|::
name|getInstance
parameter_list|()
block|{
specifier|static
name|FAREnforcer
name|theInstance
decl_stmt|;
return|return
operator|&
name|theInstance
return|;
block|}
end_function
begin_function
DECL|function|logAuthAttempt
name|void
name|FAREnforcer
operator|::
name|logAuthAttempt
parameter_list|(
name|QDateTime
name|time
parameter_list|)
block|{
name|QDateTime
name|dt
init|=
name|authAttempts
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|authAttempts
operator|.
name|append
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
operator|.
name|secsTo
argument_list|(
name|authAttempts
operator|.
name|last
argument_list|()
argument_list|)
operator|<=
name|minute
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SXE_DISCOVERY
argument_list|)
if|if
condition|(
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|isDiscoveryMode
argument_list|()
condition|)
block|{
specifier|static
name|QBasicAtomicInt
name|reported
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reported
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTSTREAM
name|QString
name|logFilePath
init|=
name|QTransportAuth
operator|::
name|getInstance
argument_list|()
operator|->
name|logFilePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|logFilePath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|log
argument_list|(
name|logFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|log
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Append
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not write to log in discovery mode: %s"
argument_list|,
name|qPrintable
argument_list|(
name|logFilePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTextStream
name|ts
argument_list|(
operator|&
name|log
argument_list|)
decl_stmt|;
name|ts
operator|<<
literal|"\t\tWarning: False Authentication Rate of "
operator|<<
name|minutelyRate
operator|<<
literal|"\n"
operator|<<
literal|"\t\tserver connections/authentications per minute has been exceeded,\n"
operator|<<
literal|"\t\tno further warnings will be issued\n"
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|reset
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_LOCAL6
argument_list|,
literal|"%s %s"
argument_list|,
name|qPrintable
argument_list|(
name|FAREnforcer
operator|::
name|SxeTag
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|FAREnforcer
operator|::
name|FARMessage
argument_list|)
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|reset
name|void
name|FAREnforcer
operator|::
name|reset
parameter_list|()
block|{
name|QDateTime
name|nullDateTime
init|=
name|QDateTime
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|minutelyRate
condition|;
name|i
operator|++
control|)
name|authAttempts
index|[
name|i
index|]
operator|=
name|nullDateTime
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qtransportauth_qws_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SXE
end_comment
end_unit
