begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qscreenlinuxfb_qws.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_LINUXFB
end_ifndef
begin_comment
comment|//#include "qmemorymanager_qws.h"
end_comment
begin_include
include|#
directive|include
file|"qwsdisplay_qws.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|<private/qwssignalhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_unix_p.h>
end_include
begin_comment
comment|// overrides QT_OPEN
end_comment
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_include
include|#
directive|include
file|<sys/kd.h>
end_include
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_FREEBSD
argument_list|)
end_if
begin_include
include|#
directive|include
file|<linux/fb.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef
begin_include
include|#
directive|include
file|<asm/mtrr.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
specifier|extern
name|int
name|qws_client_id
decl_stmt|;
end_decl_stmt
begin_comment
comment|//#define DEBUG_CACHE
end_comment
begin_class
DECL|class|QLinuxFbScreenPrivate
class|class
name|QLinuxFbScreenPrivate
super|:
specifier|public
name|QObject
block|{
public|public:
name|QLinuxFbScreenPrivate
parameter_list|()
constructor_decl|;
name|~
name|QLinuxFbScreenPrivate
parameter_list|()
destructor_decl|;
name|void
name|openTty
parameter_list|()
function_decl|;
name|void
name|closeTty
parameter_list|()
function_decl|;
DECL|member|fd
name|int
name|fd
decl_stmt|;
DECL|member|startupw
name|int
name|startupw
decl_stmt|;
DECL|member|startuph
name|int
name|startuph
decl_stmt|;
DECL|member|startupd
name|int
name|startupd
decl_stmt|;
DECL|member|blank
name|bool
name|blank
decl_stmt|;
DECL|member|driverType
name|QLinuxFbScreen
operator|::
name|DriverTypes
name|driverType
decl_stmt|;
DECL|member|doGraphicsMode
name|bool
name|doGraphicsMode
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
DECL|member|doGenericColors
name|bool
name|doGenericColors
decl_stmt|;
endif|#
directive|endif
DECL|member|ttyfd
name|int
name|ttyfd
decl_stmt|;
DECL|member|oldKdMode
name|long
name|oldKdMode
decl_stmt|;
DECL|member|ttyDevice
name|QString
name|ttyDevice
decl_stmt|;
DECL|member|displaySpec
name|QString
name|displaySpec
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QLinuxFbScreenPrivate
name|QLinuxFbScreenPrivate
operator|::
name|QLinuxFbScreenPrivate
parameter_list|()
member_init_list|:
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|blank
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|doGraphicsMode
argument_list|(
literal|true
argument_list|)
member_init_list|,
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
name|doGenericColors
argument_list|(
literal|false
argument_list|)
member_init_list|,
endif|#
directive|endif
name|ttyfd
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|oldKdMode
argument_list|(
name|KD_TEXT
argument_list|)
block|{
name|QWSSignalHandler
operator|::
name|instance
argument_list|()
operator|->
name|addObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QLinuxFbScreenPrivate
name|QLinuxFbScreenPrivate
operator|::
name|~
name|QLinuxFbScreenPrivate
parameter_list|()
block|{
name|closeTty
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|openTty
name|void
name|QLinuxFbScreenPrivate
operator|::
name|openTty
parameter_list|()
block|{
specifier|const
name|char
modifier|*
specifier|const
name|devs
index|[]
init|=
block|{
literal|"/dev/tty0"
block|,
literal|"/dev/tty"
block|,
literal|"/dev/console"
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|ttyDevice
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|dev
init|=
name|devs
init|;
operator|*
name|dev
condition|;
operator|++
name|dev
control|)
block|{
name|ttyfd
operator|=
name|QT_OPEN
argument_list|(
operator|*
name|dev
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyfd
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
block|}
else|else
block|{
name|ttyfd
operator|=
name|QT_OPEN
argument_list|(
name|ttyDevice
operator|.
name|toAscii
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyfd
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|doGraphicsMode
condition|)
block|{
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|KDGETMODE
argument_list|,
operator|&
name|oldKdMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldKdMode
operator|!=
name|KD_GRAPHICS
condition|)
block|{
name|int
name|ret
init|=
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|KDSETMODE
argument_list|,
name|KD_GRAPHICS
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|doGraphicsMode
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// No blankin' screen, no blinkin' cursor!, no cursor!
specifier|const
name|char
name|termctl
index|[]
init|=
literal|"\033[9;0]\033[?33l\033[?25l\033[?1c"
decl_stmt|;
name|QT_WRITE
argument_list|(
name|ttyfd
argument_list|,
name|termctl
argument_list|,
sizeof|sizeof
argument_list|(
name|termctl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeTty
name|void
name|QLinuxFbScreenPrivate
operator|::
name|closeTty
parameter_list|()
block|{
if|if
condition|(
name|ttyfd
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|doGraphicsMode
condition|)
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|KDSETMODE
argument_list|,
name|oldKdMode
argument_list|)
expr_stmt|;
comment|// Blankin' screen, blinkin' cursor!
specifier|const
name|char
name|termctl
index|[]
init|=
literal|"\033[9;15]\033[?33h\033[?25h\033[?0c"
decl_stmt|;
name|QT_WRITE
argument_list|(
name|ttyfd
argument_list|,
name|termctl
argument_list|,
sizeof|sizeof
argument_list|(
name|termctl
argument_list|)
argument_list|)
expr_stmt|;
name|QT_CLOSE
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
name|ttyfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QLinuxFbScreen::DriverTypes      This enum describes the driver type.      \value GenericDriver Generic Linux framebuffer driver     \value EInk8Track e-Ink framebuffer driver using the 8Track chipset  */
end_comment
begin_comment
comment|/*!     \fn QLinuxFbScreen::fixupScreenInfo(fb_fix_screeninfo&finfo, fb_var_screeninfo&vinfo)      Adjust the values returned by the framebuffer driver, to work     around driver bugs or nonstandard behavior in certain drivers.     \a finfo and \a vinfo specify the fixed and variable screen info     returned by the driver.  */
end_comment
begin_function
DECL|function|fixupScreenInfo
name|void
name|QLinuxFbScreen
operator|::
name|fixupScreenInfo
parameter_list|(
name|fb_fix_screeninfo
modifier|&
name|finfo
parameter_list|,
name|fb_var_screeninfo
modifier|&
name|vinfo
parameter_list|)
block|{
comment|// 8Track e-ink devices (as found in Sony PRS-505) lie
comment|// about their bit depth -- they claim they're 1 bit per
comment|// pixel while the only supported mode is 8 bit per pixel
comment|// grayscale.
comment|// Caused by this, they also miscalculate their line length.
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|finfo
operator|.
name|id
argument_list|,
literal|"8TRACKFB"
argument_list|)
operator|&&
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|1
condition|)
block|{
name|vinfo
operator|.
name|bits_per_pixel
operator|=
literal|8
expr_stmt|;
name|finfo
operator|.
name|line_length
operator|=
name|vinfo
operator|.
name|xres
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      \class QLinuxFbScreen     \ingroup qws      \brief The QLinuxFbScreen class implements a screen driver for the     Linux framebuffer.      Note that this class is only available in \l{Qt for Embedded Linux}.     Custom screen drivers can be added by subclassing the     QScreenDriverPlugin class, using the QScreenDriverFactory class to     dynamically load the driver into the application, but there should     only be one screen object per application.      The QLinuxFbScreen class provides the cache() function allocating     off-screen graphics memory, and the complementary uncache()     function releasing the allocated memory. The latter function will     first sync the graphics card to ensure the memory isn't still     being used by a command in the graphics card FIFO queue. The     deleteEntry() function deletes the given memory block without such     synchronization.  Given the screen instance and client id, the     memory can also be released using the clearCache() function, but     this should only be necessary if a client exits abnormally.      In addition, when in paletted graphics modes, the set() function     provides the possibility of setting a specified color index to a     given RGB value.      The QLinuxFbScreen class also acts as a factory for the     unaccelerated screen cursor and the unaccelerated raster-based     implementation of QPaintEngine (\c QRasterPaintEngine);     accelerated drivers for Linux should derive from this class.      \sa QScreen, QScreenDriverPlugin, {Running Applications} */
end_comment
begin_comment
comment|/*!     \fn bool QLinuxFbScreen::useOffscreen()     \internal */
end_comment
begin_comment
comment|// Unaccelerated screen/driver setup. Can be overridden by accelerated
end_comment
begin_comment
comment|// drivers
end_comment
begin_comment
comment|/*!     \fn QLinuxFbScreen::QLinuxFbScreen(int displayId)      Constructs a QLinuxFbScreen object. The \a displayId argument     identifies the Qt for Embedded Linux server to connect to. */
end_comment
begin_constructor
DECL|function|QLinuxFbScreen
name|QLinuxFbScreen
operator|::
name|QLinuxFbScreen
parameter_list|(
name|int
name|display_id
parameter_list|)
member_init_list|:
name|QScreen
argument_list|(
name|display_id
argument_list|,
name|LinuxFBClass
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QLinuxFbScreenPrivate
argument_list|)
block|{
name|canaccel
operator|=
literal|false
expr_stmt|;
name|clearCacheFunc
operator|=
operator|&
name|clearCache
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|setSupportsBlitInClients
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destroys this QLinuxFbScreen object. */
end_comment
begin_destructor
DECL|function|~QLinuxFbScreen
name|QLinuxFbScreen
operator|::
name|~
name|QLinuxFbScreen
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \reimp      This is called by \l{Qt for Embedded Linux} clients to map in the framebuffer.     It should be reimplemented by accelerated drivers to map in     graphics card registers; those drivers should then call this     function in order to set up offscreen memory management. The     device is specified in \a displaySpec; e.g. "/dev/fb".      \sa disconnect() */
end_comment
begin_function
DECL|function|connect
name|bool
name|QLinuxFbScreen
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|displaySpec
parameter_list|)
block|{
name|d_ptr
operator|->
name|displaySpec
operator|=
name|displaySpec
expr_stmt|;
specifier|const
name|QStringList
name|args
init|=
name|displaySpec
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"nographicsmodeswitch"
argument_list|)
argument_list|)
condition|)
name|d_ptr
operator|->
name|doGraphicsMode
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
if|if
condition|(
name|args
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"genericcolors"
argument_list|)
argument_list|)
condition|)
name|d_ptr
operator|->
name|doGenericColors
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|QRegExp
name|ttyRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"tty=(.*)"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|indexOf
argument_list|(
name|ttyRegExp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|d_ptr
operator|->
name|ttyDevice
operator|=
name|ttyRegExp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
ifndef|#
directive|ifndef
name|QT_QWS_FRAMEBUFFER_LITTLE_ENDIAN
if|if
condition|(
name|args
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"littleendian"
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
name|QScreen
operator|::
name|setFrameBufferLittleEndian
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|dev
init|=
name|QLatin1String
argument_list|(
literal|"/dev/fb0"
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QString
name|d
decl|,
name|args
control|)
block|{
if|if
condition|(
name|d
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
name|dev
operator|=
name|d
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|access
argument_list|(
name|dev
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|d_ptr
operator|->
name|fd
operator|=
name|QT_OPEN
argument_list|(
name|dev
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|type
argument_list|()
operator|==
name|QApplication
operator|::
name|GuiServer
condition|)
block|{
name|perror
argument_list|(
literal|"QScreenLinuxFb::connect"
argument_list|)
expr_stmt|;
name|qCritical
argument_list|(
literal|"Error opening framebuffer device %s"
argument_list|,
name|qPrintable
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|dev
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|d_ptr
operator|->
name|fd
operator|=
name|QT_OPEN
argument_list|(
name|dev
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
operator|::
name|fb_fix_screeninfo
name|finfo
decl_stmt|;
operator|::
name|fb_var_screeninfo
name|vinfo
decl_stmt|;
comment|//#######################
comment|// Shut up Valgrind
name|memset
argument_list|(
operator|&
name|vinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|finfo
argument_list|)
argument_list|)
expr_stmt|;
comment|//#######################
comment|/* Get fixed screen information */
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_FSCREENINFO
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::connect"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Error reading fixed information"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d_ptr
operator|->
name|driverType
operator|=
name|strcmp
argument_list|(
name|finfo
operator|.
name|id
argument_list|,
literal|"8TRACKFB"
argument_list|)
condition|?
name|GenericDriver
else|:
name|EInk8Track
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|type
operator|==
name|FB_TYPE_VGA_PLANES
condition|)
block|{
name|qWarning
argument_list|(
literal|"VGA16 video mode not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/* Get variable screen information */
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_VSCREENINFO
argument_list|,
operator|&
name|vinfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::connect"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Error reading variable information"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|fixupScreenInfo
argument_list|(
name|finfo
argument_list|,
name|vinfo
argument_list|)
expr_stmt|;
name|grayscale
operator|=
name|vinfo
operator|.
name|grayscale
expr_stmt|;
name|d
operator|=
name|vinfo
operator|.
name|bits_per_pixel
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|24
condition|)
block|{
name|d
operator|=
name|vinfo
operator|.
name|red
operator|.
name|length
operator|+
name|vinfo
operator|.
name|green
operator|.
name|length
operator|+
name|vinfo
operator|.
name|blue
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
name|d
operator|=
literal|24
expr_stmt|;
comment|// reset if color component lengths are not reported
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|16
condition|)
block|{
name|d
operator|=
name|vinfo
operator|.
name|red
operator|.
name|length
operator|+
name|vinfo
operator|.
name|green
operator|.
name|length
operator|+
name|vinfo
operator|.
name|blue
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
name|d
operator|=
literal|16
expr_stmt|;
block|}
name|lstep
operator|=
name|finfo
operator|.
name|line_length
expr_stmt|;
name|int
name|xoff
init|=
name|vinfo
operator|.
name|xoffset
decl_stmt|;
name|int
name|yoff
init|=
name|vinfo
operator|.
name|yoffset
decl_stmt|;
specifier|const
name|char
modifier|*
name|qwssize
decl_stmt|;
if|if
condition|(
operator|(
name|qwssize
operator|=
operator|::
name|getenv
argument_list|(
literal|"QWS_SIZE"
argument_list|)
operator|)
operator|&&
name|sscanf
argument_list|(
name|qwssize
argument_list|,
literal|"%dx%d"
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|h
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|w
operator|>
name|vinfo
operator|.
name|xres
condition|)
name|w
operator|=
name|vinfo
operator|.
name|xres
expr_stmt|;
if|if
condition|(
operator|(
name|uint
operator|)
name|h
operator|>
name|vinfo
operator|.
name|yres
condition|)
name|h
operator|=
name|vinfo
operator|.
name|yres
expr_stmt|;
block|}
name|dw
operator|=
name|w
expr_stmt|;
name|dh
operator|=
name|h
expr_stmt|;
name|int
name|xxoff
decl_stmt|,
name|yyoff
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|qwssize
argument_list|,
literal|"%*dx%*d+%d+%d"
argument_list|,
operator|&
name|xxoff
argument_list|,
operator|&
name|yyoff
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|xxoff
argument_list|<
literal|0
operator|||
name|xxoff
operator|+
name|w
argument_list|>
name|vinfo
operator|.
name|xres
condition|)
name|xxoff
operator|=
name|vinfo
operator|.
name|xres
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|yyoff
argument_list|<
literal|0
operator|||
name|yyoff
operator|+
name|h
argument_list|>
name|vinfo
operator|.
name|yres
condition|)
name|yyoff
operator|=
name|vinfo
operator|.
name|yres
operator|-
name|h
expr_stmt|;
name|xoff
operator|+=
name|xxoff
expr_stmt|;
name|yoff
operator|+=
name|yyoff
expr_stmt|;
block|}
else|else
block|{
name|xoff
operator|+=
operator|(
name|vinfo
operator|.
name|xres
operator|-
name|w
operator|)
operator|/
literal|2
expr_stmt|;
name|yoff
operator|+=
operator|(
name|vinfo
operator|.
name|yres
operator|-
name|h
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|dw
operator|=
name|w
operator|=
name|vinfo
operator|.
name|xres
expr_stmt|;
name|dh
operator|=
name|h
operator|=
name|vinfo
operator|.
name|yres
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QScreenLinuxFb::connect(): Unable to find screen geometry, "
literal|"will use 320x240."
argument_list|)
expr_stmt|;
name|dw
operator|=
name|w
operator|=
literal|320
expr_stmt|;
name|dh
operator|=
name|h
operator|=
literal|240
expr_stmt|;
block|}
name|setPixelFormat
argument_list|(
name|vinfo
argument_list|)
expr_stmt|;
comment|// Handle display physical size spec.
name|QStringList
name|displayArgs
init|=
name|displaySpec
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
name|QRegExp
name|mmWidthRx
argument_list|(
name|QLatin1String
argument_list|(
literal|"mmWidth=?(\\d+)"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dimIdxW
init|=
name|displayArgs
operator|.
name|indexOf
argument_list|(
name|mmWidthRx
argument_list|)
decl_stmt|;
name|QRegExp
name|mmHeightRx
argument_list|(
name|QLatin1String
argument_list|(
literal|"mmHeight=?(\\d+)"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dimIdxH
init|=
name|displayArgs
operator|.
name|indexOf
argument_list|(
name|mmHeightRx
argument_list|)
decl_stmt|;
if|if
condition|(
name|dimIdxW
operator|>=
literal|0
condition|)
block|{
name|mmWidthRx
operator|.
name|exactMatch
argument_list|(
name|displayArgs
operator|.
name|at
argument_list|(
name|dimIdxW
argument_list|)
argument_list|)
expr_stmt|;
name|physWidth
operator|=
name|mmWidthRx
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|dimIdxH
operator|<
literal|0
condition|)
name|physHeight
operator|=
name|dh
operator|*
name|physWidth
operator|/
name|dw
expr_stmt|;
block|}
if|if
condition|(
name|dimIdxH
operator|>=
literal|0
condition|)
block|{
name|mmHeightRx
operator|.
name|exactMatch
argument_list|(
name|displayArgs
operator|.
name|at
argument_list|(
name|dimIdxH
argument_list|)
argument_list|)
expr_stmt|;
name|physHeight
operator|=
name|mmHeightRx
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|dimIdxW
operator|<
literal|0
condition|)
name|physWidth
operator|=
name|dw
operator|*
name|physHeight
operator|/
name|dh
expr_stmt|;
block|}
if|if
condition|(
name|dimIdxW
operator|<
literal|0
operator|&&
name|dimIdxH
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|vinfo
operator|.
name|width
operator|!=
literal|0
operator|&&
name|vinfo
operator|.
name|height
operator|!=
literal|0
operator|&&
name|vinfo
operator|.
name|width
operator|!=
name|UINT_MAX
operator|&&
name|vinfo
operator|.
name|height
operator|!=
name|UINT_MAX
condition|)
block|{
name|physWidth
operator|=
name|vinfo
operator|.
name|width
expr_stmt|;
name|physHeight
operator|=
name|vinfo
operator|.
name|height
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|dpi
init|=
literal|72
decl_stmt|;
name|physWidth
operator|=
name|qRound
argument_list|(
name|dw
operator|*
literal|25.4
operator|/
name|dpi
argument_list|)
expr_stmt|;
name|physHeight
operator|=
name|qRound
argument_list|(
name|dh
operator|*
literal|25.4
operator|/
name|dpi
argument_list|)
expr_stmt|;
block|}
block|}
name|dataoffset
operator|=
name|yoff
operator|*
name|lstep
operator|+
name|xoff
operator|*
name|d
operator|/
literal|8
expr_stmt|;
comment|//qDebug("Using %dx%dx%d screen",w,h,d);
comment|/* Figure out the size of the screen in bytes */
name|size
operator|=
name|h
operator|*
name|lstep
expr_stmt|;
name|mapsize
operator|=
name|finfo
operator|.
name|smem_len
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|mapsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|d_ptr
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|data
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|type
argument_list|()
operator|==
name|QApplication
operator|::
name|GuiServer
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::connect"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Error: failed to map framebuffer device to memory."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|data
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|data
operator|+=
name|dataoffset
expr_stmt|;
block|}
name|canaccel
operator|=
name|useOffscreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|canaccel
condition|)
name|setupOffScreen
argument_list|()
expr_stmt|;
comment|// Now read in palette
if|if
condition|(
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|8
operator|)
operator|||
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|4
operator|)
condition|)
block|{
name|screencols
operator|=
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|8
operator|)
condition|?
literal|256
else|:
literal|16
expr_stmt|;
name|int
name|loopc
decl_stmt|;
operator|::
name|fb_cmap
name|startcmap
decl_stmt|;
name|startcmap
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|startcmap
operator|.
name|len
operator|=
name|screencols
expr_stmt|;
name|startcmap
operator|.
name|red
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|startcmap
operator|.
name|green
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|startcmap
operator|.
name|blue
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|startcmap
operator|.
name|transp
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|==
operator|-
literal|1
operator|||
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGETCMAP
argument_list|,
operator|&
name|startcmap
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::connect"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Error reading palette from framebuffer, using default palette"
argument_list|)
expr_stmt|;
name|createPalette
argument_list|(
name|startcmap
argument_list|,
name|vinfo
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
block|}
name|int
name|bits_used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|loopc
operator|=
literal|0
init|;
name|loopc
operator|<
name|screencols
condition|;
name|loopc
operator|++
control|)
block|{
name|screenclut
index|[
name|loopc
index|]
operator|=
name|qRgb
argument_list|(
name|startcmap
operator|.
name|red
index|[
name|loopc
index|]
operator|>>
literal|8
argument_list|,
name|startcmap
operator|.
name|green
index|[
name|loopc
index|]
operator|>>
literal|8
argument_list|,
name|startcmap
operator|.
name|blue
index|[
name|loopc
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bits_used
operator||=
name|startcmap
operator|.
name|red
index|[
name|loopc
index|]
operator||
name|startcmap
operator|.
name|green
index|[
name|loopc
index|]
operator||
name|startcmap
operator|.
name|blue
index|[
name|loopc
index|]
expr_stmt|;
block|}
comment|// WORKAROUND: Some framebuffer drivers only return 8 bit
comment|// color values, so we need to not bit shift them..
if|if
condition|(
operator|(
name|bits_used
operator|&
literal|0x00ff
operator|)
operator|&&
operator|!
operator|(
name|bits_used
operator|&
literal|0xff00
operator|)
condition|)
block|{
for|for
control|(
name|loopc
operator|=
literal|0
init|;
name|loopc
operator|<
name|screencols
condition|;
name|loopc
operator|++
control|)
block|{
name|screenclut
index|[
name|loopc
index|]
operator|=
name|qRgb
argument_list|(
name|startcmap
operator|.
name|red
index|[
name|loopc
index|]
argument_list|,
name|startcmap
operator|.
name|green
index|[
name|loopc
index|]
argument_list|,
name|startcmap
operator|.
name|blue
index|[
name|loopc
index|]
argument_list|)
expr_stmt|;
block|}
name|qWarning
argument_list|(
literal|"8 bits cmap returned due to faulty FB driver, colors corrected"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|startcmap
operator|.
name|red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|startcmap
operator|.
name|green
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|startcmap
operator|.
name|blue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|startcmap
operator|.
name|transp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|screencols
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This unmaps the framebuffer.      \sa connect() */
end_comment
begin_function
DECL|function|disconnect
name|void
name|QLinuxFbScreen
operator|::
name|disconnect
parameter_list|()
block|{
name|data
operator|-=
name|dataoffset
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|munmap
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// #define DEBUG_VINFO
end_comment
begin_function
DECL|function|createPalette
name|void
name|QLinuxFbScreen
operator|::
name|createPalette
parameter_list|(
name|fb_cmap
modifier|&
name|cmap
parameter_list|,
name|fb_var_screeninfo
modifier|&
name|vinfo
parameter_list|,
name|fb_fix_screeninfo
modifier|&
name|finfo
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|8
operator|)
operator|||
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|4
operator|)
condition|)
block|{
name|screencols
operator|=
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|8
operator|)
condition|?
literal|256
else|:
literal|16
expr_stmt|;
name|cmap
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|cmap
operator|.
name|len
operator|=
name|screencols
expr_stmt|;
name|cmap
operator|.
name|red
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|green
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|blue
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|transp
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
name|screencols
argument_list|)
expr_stmt|;
if|if
condition|(
name|screencols
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|finfo
operator|.
name|type
operator|==
name|FB_TYPE_PACKED_PIXELS
condition|)
block|{
comment|// We'll setup a grayscale cmap for 4bpp linear
name|int
name|val
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
operator|++
name|idx
operator|,
name|val
operator|+=
literal|17
control|)
block|{
name|cmap
operator|.
name|red
index|[
name|idx
index|]
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|idx
index|]
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|idx
index|]
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|screenclut
index|[
name|idx
index|]
operator|=
name|qRgb
argument_list|(
name|val
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Default 16 colour palette
comment|// Green is now trolltech green so certain images look nicer
comment|//                             black  d_gray l_gray white  red  green  blue cyan magenta yellow
name|unsigned
name|char
name|reds
index|[
literal|16
index|]
init|=
block|{
literal|0x00
block|,
literal|0x7F
block|,
literal|0xBF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xA2
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x7F
block|,
literal|0x7F
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x82
block|}
decl_stmt|;
name|unsigned
name|char
name|greens
index|[
literal|16
index|]
init|=
block|{
literal|0x00
block|,
literal|0x7F
block|,
literal|0xBF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0xC5
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x7F
block|,
literal|0x7F
block|,
literal|0x7F
block|}
decl_stmt|;
name|unsigned
name|char
name|blues
index|[
literal|16
index|]
init|=
block|{
literal|0x00
block|,
literal|0x7F
block|,
literal|0xBF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x11
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x7F
block|,
literal|0x7F
block|,
literal|0x7F
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
operator|++
name|idx
control|)
block|{
name|cmap
operator|.
name|red
index|[
name|idx
index|]
operator|=
operator|(
operator|(
name|reds
index|[
name|idx
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|reds
index|[
name|idx
index|]
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|idx
index|]
operator|=
operator|(
operator|(
name|greens
index|[
name|idx
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|greens
index|[
name|idx
index|]
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|idx
index|]
operator|=
operator|(
operator|(
name|blues
index|[
name|idx
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|blues
index|[
name|idx
index|]
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|screenclut
index|[
name|idx
index|]
operator|=
name|qRgb
argument_list|(
name|reds
index|[
name|idx
index|]
argument_list|,
name|greens
index|[
name|idx
index|]
argument_list|,
name|blues
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|grayscale
condition|)
block|{
comment|// Build grayscale palette
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screencols
condition|;
operator|++
name|i
control|)
block|{
name|int
name|bval
init|=
name|screencols
operator|==
literal|256
condition|?
name|i
else|:
operator|(
name|i
operator|<<
literal|4
operator|)
decl_stmt|;
name|ushort
name|val
init|=
operator|(
name|bval
operator|<<
literal|8
operator|)
operator||
name|bval
decl_stmt|;
name|cmap
operator|.
name|red
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|screenclut
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|bval
argument_list|,
name|bval
argument_list|,
name|bval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// 6x6x6 216 color cube
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|ir
init|=
literal|0x0
init|;
name|ir
operator|<=
literal|0xff
condition|;
name|ir
operator|+=
literal|0x33
control|)
block|{
for|for
control|(
name|int
name|ig
init|=
literal|0x0
init|;
name|ig
operator|<=
literal|0xff
condition|;
name|ig
operator|+=
literal|0x33
control|)
block|{
for|for
control|(
name|int
name|ib
init|=
literal|0x0
init|;
name|ib
operator|<=
literal|0xff
condition|;
name|ib
operator|+=
literal|0x33
control|)
block|{
name|cmap
operator|.
name|red
index|[
name|idx
index|]
operator|=
operator|(
name|ir
operator|<<
literal|8
operator|)
operator||
name|ir
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|idx
index|]
operator|=
operator|(
name|ig
operator|<<
literal|8
operator|)
operator||
name|ig
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|idx
index|]
operator|=
operator|(
name|ib
operator|<<
literal|8
operator|)
operator||
name|ib
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|screenclut
index|[
name|idx
index|]
operator|=
name|qRgb
argument_list|(
name|ir
argument_list|,
name|ig
argument_list|,
name|ib
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
block|}
block|}
comment|// Fill in rest with 0
for|for
control|(
name|int
name|loopc
init|=
literal|0
init|;
name|loopc
operator|<
literal|40
condition|;
operator|++
name|loopc
control|)
block|{
name|screenclut
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|screencols
operator|=
name|idx
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|finfo
operator|.
name|visual
operator|==
name|FB_VISUAL_DIRECTCOLOR
condition|)
block|{
name|cmap
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|int
name|rbits
init|=
literal|0
decl_stmt|,
name|gbits
init|=
literal|0
decl_stmt|,
name|bbits
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|vinfo
operator|.
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|rbits
operator|=
name|vinfo
operator|.
name|red
operator|.
name|length
expr_stmt|;
name|gbits
operator|=
name|vinfo
operator|.
name|green
operator|.
name|length
expr_stmt|;
name|bbits
operator|=
name|vinfo
operator|.
name|blue
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|rbits
operator|==
literal|0
operator|&&
name|gbits
operator|==
literal|0
operator|&&
name|bbits
operator|==
literal|0
condition|)
block|{
comment|// cyber2000 driver bug hack
name|rbits
operator|=
literal|3
expr_stmt|;
name|gbits
operator|=
literal|3
expr_stmt|;
name|bbits
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
name|rbits
operator|=
literal|5
expr_stmt|;
name|gbits
operator|=
literal|5
expr_stmt|;
name|bbits
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rbits
operator|=
literal|5
expr_stmt|;
name|gbits
operator|=
literal|6
expr_stmt|;
name|bbits
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|18
case|:
case|case
literal|19
case|:
name|rbits
operator|=
literal|6
expr_stmt|;
name|gbits
operator|=
literal|6
expr_stmt|;
name|bbits
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|rbits
operator|=
name|gbits
operator|=
name|bbits
operator|=
literal|8
expr_stmt|;
break|break;
block|}
name|screencols
operator|=
name|cmap
operator|.
name|len
operator|=
literal|1
operator|<<
name|qMax
argument_list|(
name|rbits
argument_list|,
name|qMax
argument_list|(
name|gbits
argument_list|,
name|bbits
argument_list|)
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|red
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|green
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|blue
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|transp
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0x0
init|;
name|i
operator|<
name|cmap
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|cmap
operator|.
name|red
index|[
name|i
index|]
operator|=
name|i
operator|*
literal|65535
operator|/
operator|(
operator|(
literal|1
operator|<<
name|rbits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|i
index|]
operator|=
name|i
operator|*
literal|65535
operator|/
operator|(
operator|(
literal|1
operator|<<
name|gbits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|i
index|]
operator|=
name|i
operator|*
literal|65535
operator|/
operator|(
operator|(
literal|1
operator|<<
name|bbits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp      This is called by the \l{Qt for Embedded Linux} server at startup time.     It turns off console blinking, sets up the color palette, enables write     combining on the framebuffer and initialises the off-screen memory     manager. */
end_comment
begin_function
DECL|function|initDevice
name|bool
name|QLinuxFbScreen
operator|::
name|initDevice
parameter_list|()
block|{
name|d_ptr
operator|->
name|openTty
argument_list|()
expr_stmt|;
comment|// Grab current mode so we can reset it
name|fb_var_screeninfo
name|vinfo
decl_stmt|;
name|fb_fix_screeninfo
name|finfo
decl_stmt|;
comment|//#######################
comment|// Shut up Valgrind
name|memset
argument_list|(
operator|&
name|vinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|finfo
argument_list|)
argument_list|)
expr_stmt|;
comment|//#######################
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_VSCREENINFO
argument_list|,
operator|&
name|vinfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::initDevice"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Error reading variable information in card init"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_VINFO
name|qDebug
argument_list|(
literal|"Greyscale %d"
argument_list|,
name|vinfo
operator|.
name|grayscale
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"Nonstd %d"
argument_list|,
name|vinfo
operator|.
name|nonstd
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"Red %d %d %d"
argument_list|,
name|vinfo
operator|.
name|red
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|red
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|red
operator|.
name|msb_right
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"Green %d %d %d"
argument_list|,
name|vinfo
operator|.
name|green
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|green
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|green
operator|.
name|msb_right
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"Blue %d %d %d"
argument_list|,
name|vinfo
operator|.
name|blue
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|blue
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|blue
operator|.
name|msb_right
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"Transparent %d %d %d"
argument_list|,
name|vinfo
operator|.
name|transp
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|transp
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|transp
operator|.
name|msb_right
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_FSCREENINFO
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::initDevice"
argument_list|)
expr_stmt|;
name|qCritical
argument_list|(
literal|"Error reading fixed information in card init"
argument_list|)
expr_stmt|;
comment|// It's not an /error/ as such, though definitely a bad sign
comment|// so we return true
return|return
literal|true
return|;
block|}
name|fixupScreenInfo
argument_list|(
name|finfo
argument_list|,
name|vinfo
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|startupw
operator|=
name|vinfo
operator|.
name|xres
expr_stmt|;
name|d_ptr
operator|->
name|startuph
operator|=
name|vinfo
operator|.
name|yres
expr_stmt|;
name|d_ptr
operator|->
name|startupd
operator|=
name|vinfo
operator|.
name|bits_per_pixel
expr_stmt|;
name|grayscale
operator|=
name|vinfo
operator|.
name|grayscale
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
comment|// Now init mtrr
if|if
condition|(
operator|!
operator|::
name|getenv
argument_list|(
literal|"QWS_NOMTRR"
argument_list|)
condition|)
block|{
name|int
name|mfd
init|=
name|QT_OPEN
argument_list|(
literal|"/proc/mtrr"
argument_list|,
name|O_WRONLY
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// MTRR entry goes away when file is closed - i.e.
comment|// hopefully when QWS is killed
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|mtrr_sentry
name|sentry
decl_stmt|;
name|sentry
operator|.
name|base
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|finfo
operator|.
name|smem_start
expr_stmt|;
comment|//qDebug("Physical framebuffer address %p",(void*)finfo.smem_start);
comment|// Size needs to be in 4k chunks, but that's not always
comment|// what we get thanks to graphics card registers. Write combining
comment|// these is Not Good, so we write combine what we can
comment|// (which is not much - 4 megs on an 8 meg card, it seems)
name|unsigned
name|int
name|size
init|=
name|finfo
operator|.
name|smem_len
decl_stmt|;
name|size
operator|=
name|size
operator|>>
literal|22
expr_stmt|;
name|size
operator|=
name|size
operator|<<
literal|22
expr_stmt|;
name|sentry
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|sentry
operator|.
name|type
operator|=
name|MTRR_TYPE_WRCOMB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mfd
argument_list|,
name|MTRRIOC_ADD_ENTRY
argument_list|,
operator|&
name|sentry
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|//printf("Couldn't add mtrr entry for %lx %lx, %s\n",
comment|//sentry.base,sentry.size,strerror(errno));
block|}
block|}
comment|// Should we close mfd here?
comment|//QT_CLOSE(mfd);
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|8
operator|)
operator|||
operator|(
name|vinfo
operator|.
name|bits_per_pixel
operator|==
literal|4
operator|)
operator|||
operator|(
name|finfo
operator|.
name|visual
operator|==
name|FB_VISUAL_DIRECTCOLOR
operator|)
condition|)
block|{
name|fb_cmap
name|cmap
decl_stmt|;
name|createPalette
argument_list|(
name|cmap
argument_list|,
name|vinfo
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOPUTCMAP
argument_list|,
operator|&
name|cmap
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::initDevice"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Error writing palette to framebuffer"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cmap
operator|.
name|red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|green
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|blue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canaccel
condition|)
block|{
operator|*
name|entryp
operator|=
literal|0
expr_stmt|;
operator|*
name|lowest
operator|=
name|mapsize
expr_stmt|;
name|insert_entry
argument_list|(
operator|*
name|entryp
argument_list|,
operator|*
name|lowest
argument_list|,
operator|*
name|lowest
argument_list|)
expr_stmt|;
comment|// dummy entry to mark start
block|}
name|shared
operator|->
name|fifocount
operator|=
literal|0
expr_stmt|;
name|shared
operator|->
name|buffer_offset
operator|=
literal|0xffffffff
expr_stmt|;
comment|// 0 would be a sensible offset (screen)
name|shared
operator|->
name|linestep
operator|=
literal|0
expr_stmt|;
name|shared
operator|->
name|cliptop
operator|=
literal|0xffffffff
expr_stmt|;
name|shared
operator|->
name|clipleft
operator|=
literal|0xffffffff
expr_stmt|;
name|shared
operator|->
name|clipright
operator|=
literal|0xffffffff
expr_stmt|;
name|shared
operator|->
name|clipbottom
operator|=
literal|0xffffffff
expr_stmt|;
name|shared
operator|->
name|rop
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
if|if
condition|(
name|pixelFormat
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Invalid
operator|&&
name|screencols
operator|==
literal|0
operator|&&
name|d_ptr
operator|->
name|doGenericColors
condition|)
block|{
name|qt_set_generic_blit
argument_list|(
name|this
argument_list|,
name|vinfo
operator|.
name|bits_per_pixel
argument_list|,
name|vinfo
operator|.
name|red
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|green
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|blue
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|transp
operator|.
name|length
argument_list|,
name|vinfo
operator|.
name|red
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|green
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|blue
operator|.
name|offset
argument_list|,
name|vinfo
operator|.
name|transp
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
name|QScreenCursor
operator|::
name|initSoftwareCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|blank
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   The offscreen memory manager's list of entries is stored at the bottom   of the offscreen memory area and consistes of a series of QPoolEntry's,   each of which keep track of a block of allocated memory. Unallocated memory   is implicitly indicated by the gap between blocks indicated by QPoolEntry's.   The memory manager looks through any unallocated memory before the end   of currently-allocated memory to see if a new block will fit in the gap;   if it doesn't it allocated it from the end of currently-allocated memory.   Memory is allocated from the top of the framebuffer downwards; if it hits   the list of entries then offscreen memory is full and further allocations   are made from main RAM (and hence unaccelerated). Allocated memory can   be seen as a sort of upside-down stack; lowest keeps track of the   bottom of the stack. */
end_comment
begin_function
DECL|function|delete_entry
name|void
name|QLinuxFbScreen
operator|::
name|delete_entry
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>
operator|*
name|entryp
operator|||
name|pos
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Attempt to delete odd pos! %d %d"
argument_list|,
name|pos
argument_list|,
operator|*
name|entryp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"Remove entry: %d"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QPoolEntry
modifier|*
name|qpe
init|=
operator|&
name|entries
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|qpe
operator|->
name|start
operator|<=
operator|*
name|lowest
condition|)
block|{
comment|// Lowest goes up again
operator|*
name|lowest
operator|=
name|entries
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|start
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"   moved lowest to %d"
argument_list|,
operator|*
name|lowest
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
operator|*
name|entryp
operator|)
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|*
name|entryp
condition|)
return|return;
name|int
name|size
init|=
operator|(
operator|*
name|entryp
operator|)
operator|-
name|pos
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|entries
index|[
name|pos
index|]
argument_list|,
operator|&
name|entries
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QPoolEntry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|insert_entry
name|void
name|QLinuxFbScreen
operator|::
name|insert_entry
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>
operator|*
name|entryp
condition|)
block|{
name|qWarning
argument_list|(
literal|"Attempt to insert odd pos! %d %d"
argument_list|,
name|pos
argument_list|,
operator|*
name|entryp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"Insert entry: %d, %d -> %d"
argument_list|,
name|pos
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|start
operator|<
operator|(
name|int
operator|)
operator|*
name|lowest
condition|)
block|{
operator|*
name|lowest
operator|=
name|start
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"    moved lowest to %d"
argument_list|,
operator|*
name|lowest
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pos
operator|==
operator|*
name|entryp
condition|)
block|{
name|entries
index|[
name|pos
index|]
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|entries
index|[
name|pos
index|]
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|entries
index|[
name|pos
index|]
operator|.
name|clientId
operator|=
name|qws_client_id
expr_stmt|;
operator|(
operator|*
name|entryp
operator|)
operator|++
expr_stmt|;
return|return;
block|}
name|int
name|size
init|=
operator|(
operator|*
name|entryp
operator|)
operator|-
name|pos
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|entries
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|&
name|entries
index|[
name|pos
index|]
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QPoolEntry
argument_list|)
argument_list|)
expr_stmt|;
name|entries
index|[
name|pos
index|]
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|entries
index|[
name|pos
index|]
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|entries
index|[
name|pos
index|]
operator|.
name|clientId
operator|=
name|qws_client_id
expr_stmt|;
operator|(
operator|*
name|entryp
operator|)
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn uchar * QLinuxFbScreen::cache(int amount)      Requests the specified \a amount of offscreen graphics card memory     from the memory manager, and returns a pointer to the data within     the framebuffer (or 0 if there is no free memory).      Note that the display is locked while memory is allocated in order to     preserve the memory pool's integrity.      Use the QScreen::onCard() function to retrieve an offset (in     bytes) from the start of graphics card memory for the returned     pointer.      \sa uncache(), clearCache(), deleteEntry() */
end_comment
begin_function
DECL|function|cache
name|uchar
modifier|*
name|QLinuxFbScreen
operator|::
name|cache
parameter_list|(
name|int
name|amount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|canaccel
operator|||
name|entryp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|qt_fbdpy
operator|->
name|grab
argument_list|()
expr_stmt|;
name|int
name|startp
init|=
name|cacheStart
operator|+
operator|(
operator|*
name|entryp
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QPoolEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|startp
operator|>=
operator|(
name|int
operator|)
operator|*
name|lowest
condition|)
block|{
comment|// We don't have room for another cache QPoolEntry.
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"No room for pool entry in VRAM"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|align
init|=
name|pixmapOffsetAlignment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|*
name|entryp
operator|>
literal|1
condition|)
block|{
comment|// Try to find a gap in the allocated blocks.
for|for
control|(
name|int
name|loopc
init|=
literal|0
init|;
name|loopc
operator|<
operator|*
name|entryp
operator|-
literal|1
condition|;
name|loopc
operator|++
control|)
block|{
name|int
name|freestart
init|=
name|entries
index|[
name|loopc
operator|+
literal|1
index|]
operator|.
name|end
decl_stmt|;
name|int
name|freeend
init|=
name|entries
index|[
name|loopc
index|]
operator|.
name|start
decl_stmt|;
if|if
condition|(
name|freestart
operator|!=
name|freeend
condition|)
block|{
while|while
condition|(
name|freestart
operator|%
name|align
condition|)
block|{
name|freestart
operator|++
expr_stmt|;
block|}
name|int
name|len
init|=
name|freeend
operator|-
name|freestart
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|amount
condition|)
block|{
name|insert_entry
argument_list|(
name|loopc
operator|+
literal|1
argument_list|,
name|freestart
argument_list|,
name|freestart
operator|+
name|amount
argument_list|)
expr_stmt|;
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
return|return
name|data
operator|+
name|freestart
return|;
block|}
block|}
block|}
block|}
comment|// No free blocks in already-taken memory; get some more
comment|// if we can
name|int
name|newlowest
init|=
operator|(
operator|*
name|lowest
operator|)
operator|-
name|amount
decl_stmt|;
if|if
condition|(
name|newlowest
operator|%
name|align
condition|)
block|{
name|newlowest
operator|-=
name|align
expr_stmt|;
while|while
condition|(
name|newlowest
operator|%
name|align
condition|)
block|{
name|newlowest
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|startp
operator|>=
name|newlowest
condition|)
block|{
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CACHE
name|qDebug
argument_list|(
literal|"No VRAM available for %d bytes"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|insert_entry
argument_list|(
operator|*
name|entryp
argument_list|,
name|newlowest
argument_list|,
operator|*
name|lowest
argument_list|)
expr_stmt|;
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
return|return
name|data
operator|+
name|newlowest
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLinuxFbScreen::uncache(uchar * memoryBlock)      Deletes the specified \a memoryBlock allocated from the graphics     card memory.      Note that the display is locked while memory is unallocated in     order to preserve the memory pool's integrity.      This function will first sync the graphics card to ensure the     memory isn't still being used by a command in the graphics card     FIFO queue. It is possible to speed up a driver by overriding this     function to avoid syncing. For example, the driver might delay     deleting the memory until it detects that all commands dealing     with the memory are no longer in the queue. Note that it will then     be up to the driver to ensure that the specified \a memoryBlock no     longer is being used.      \sa cache(), deleteEntry(), clearCache()  */
end_comment
begin_function
DECL|function|uncache
name|void
name|QLinuxFbScreen
operator|::
name|uncache
parameter_list|(
name|uchar
modifier|*
name|c
parameter_list|)
block|{
comment|// need to sync graphics card
name|deleteEntry
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLinuxFbScreen::deleteEntry(uchar * memoryBlock)      Deletes the specified \a memoryBlock allocated from the graphics     card memory.      \sa uncache(), cache(), clearCache() */
end_comment
begin_function
DECL|function|deleteEntry
name|void
name|QLinuxFbScreen
operator|::
name|deleteEntry
parameter_list|(
name|uchar
modifier|*
name|c
parameter_list|)
block|{
name|qt_fbdpy
operator|->
name|grab
argument_list|()
expr_stmt|;
name|unsigned
name|long
name|pos
init|=
operator|(
name|unsigned
name|long
operator|)
name|c
decl_stmt|;
name|pos
operator|-=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|data
operator|)
expr_stmt|;
name|unsigned
name|int
name|hold
init|=
operator|(
operator|*
name|entryp
operator|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|loopc
init|=
literal|1
init|;
name|loopc
operator|<
name|hold
condition|;
name|loopc
operator|++
control|)
block|{
if|if
condition|(
name|entries
index|[
name|loopc
index|]
operator|.
name|start
operator|==
name|pos
condition|)
block|{
if|if
condition|(
name|entries
index|[
name|loopc
index|]
operator|.
name|clientId
operator|==
name|qws_client_id
condition|)
name|delete_entry
argument_list|(
name|loopc
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"Attempt to delete client id %d cache entry"
argument_list|,
name|entries
index|[
name|loopc
index|]
operator|.
name|clientId
argument_list|)
expr_stmt|;
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
name|qWarning
argument_list|(
literal|"Attempt to delete unknown offset %ld"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes all entries from the cache for the specified screen \a     instance and client identified by the given \a clientId.      Calling this function should only be necessary if a client exits     abnormally.      \sa cache(), uncache(), deleteEntry() */
end_comment
begin_function
DECL|function|clearCache
name|void
name|QLinuxFbScreen
operator|::
name|clearCache
parameter_list|(
name|QScreen
modifier|*
name|instance
parameter_list|,
name|int
name|clientId
parameter_list|)
block|{
name|QLinuxFbScreen
modifier|*
name|screen
init|=
operator|(
name|QLinuxFbScreen
operator|*
operator|)
name|instance
decl_stmt|;
if|if
condition|(
operator|!
name|screen
operator|->
name|canaccel
operator|||
operator|!
name|screen
operator|->
name|entryp
condition|)
return|return;
name|qt_fbdpy
operator|->
name|grab
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|loopc
init|=
literal|0
init|;
name|loopc
operator|<
operator|*
operator|(
name|screen
operator|->
name|entryp
operator|)
condition|;
name|loopc
operator|++
control|)
block|{
if|if
condition|(
name|screen
operator|->
name|entries
index|[
name|loopc
index|]
operator|.
name|clientId
operator|==
name|clientId
condition|)
block|{
name|screen
operator|->
name|delete_entry
argument_list|(
name|loopc
argument_list|)
expr_stmt|;
name|loopc
operator|--
expr_stmt|;
block|}
block|}
name|qt_fbdpy
operator|->
name|ungrab
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupOffScreen
name|void
name|QLinuxFbScreen
operator|::
name|setupOffScreen
parameter_list|()
block|{
comment|// Figure out position of offscreen memory
comment|// Set up pool entries pointer table and 64-bit align it
name|int
name|psize
init|=
name|size
decl_stmt|;
comment|// hw: this causes the limitation of cursors to 64x64
comment|// the cursor should rather use the normal pixmap mechanism
name|psize
operator|+=
literal|4096
expr_stmt|;
comment|// cursor data
name|psize
operator|+=
literal|8
expr_stmt|;
comment|// for alignment
name|psize
operator|&=
operator|~
literal|0x7
expr_stmt|;
comment|// align
name|unsigned
name|long
name|pos
init|=
operator|(
name|unsigned
name|long
operator|)
name|data
decl_stmt|;
name|pos
operator|+=
name|psize
expr_stmt|;
name|entryp
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|pos
operator|)
expr_stmt|;
name|lowest
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pos
operator|)
operator|+
literal|1
expr_stmt|;
name|pos
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|*
literal|4
expr_stmt|;
name|entries
operator|=
operator|(
name|QPoolEntry
operator|*
operator|)
name|pos
expr_stmt|;
comment|// beginning of offscreen memory available for pixmaps.
name|cacheStart
operator|=
name|psize
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|QPoolEntry
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This is called by the \l{Qt for Embedded Linux} server when it shuts     down, and should be inherited if you need to do any card-specific cleanup.     The default version hides the screen cursor and reenables the blinking     cursor and screen blanking. */
end_comment
begin_function
DECL|function|shutdownDevice
name|void
name|QLinuxFbScreen
operator|::
name|shutdownDevice
parameter_list|()
block|{
comment|// Causing crashes. Not needed.
comment|//setMode(startupw,startuph,startupd);
comment|/*     if (startupd == 8) {         ioctl(fd,FBIOPUTCMAP,startcmap);         free(startcmap->red);         free(startcmap->green);         free(startcmap->blue);         free(startcmap->transp);         delete startcmap;         startcmap = 0;     } */
name|d_ptr
operator|->
name|closeTty
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLinuxFbScreen::set(unsigned int index,unsigned int red,unsigned int green,unsigned int blue)      Sets the specified color \a index to the specified RGB value, (\a     red, \a green, \a blue), when in paletted graphics modes. */
end_comment
begin_function
DECL|function|set
name|void
name|QLinuxFbScreen
operator|::
name|set
parameter_list|(
name|unsigned
name|int
name|i
parameter_list|,
name|unsigned
name|int
name|r
parameter_list|,
name|unsigned
name|int
name|g
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|fb_cmap
name|cmap
decl_stmt|;
name|cmap
operator|.
name|start
operator|=
name|i
expr_stmt|;
name|cmap
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|cmap
operator|.
name|red
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|green
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|blue
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|transp
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|red
index|[
literal|0
index|]
operator|=
name|r
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|green
index|[
literal|0
index|]
operator|=
name|g
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
literal|0
index|]
operator|=
name|b
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOPUTCMAP
argument_list|,
operator|&
name|cmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|green
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|blue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|transp
argument_list|)
expr_stmt|;
block|}
name|screenclut
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Sets the framebuffer to a new resolution and bit depth. The width is     in \a nw, the height is in \a nh, and the depth is in \a nd. After     doing this any currently-existing paint engines will be invalid and the     screen should be completely redrawn. In a multiple-process     Embedded Qt situation you must signal all other applications to     call setMode() to the same mode and redraw. */
end_comment
begin_function
DECL|function|setMode
name|void
name|QLinuxFbScreen
operator|::
name|setMode
parameter_list|(
name|int
name|nw
parameter_list|,
name|int
name|nh
parameter_list|,
name|int
name|nd
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
return|return;
name|fb_fix_screeninfo
name|finfo
decl_stmt|;
name|fb_var_screeninfo
name|vinfo
decl_stmt|;
comment|//#######################
comment|// Shut up Valgrind
name|memset
argument_list|(
operator|&
name|vinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|finfo
argument_list|)
argument_list|)
expr_stmt|;
comment|//#######################
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_VSCREENINFO
argument_list|,
operator|&
name|vinfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::setMode"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Error reading variable information in mode change"
argument_list|)
expr_stmt|;
block|}
name|vinfo
operator|.
name|xres
operator|=
name|nw
expr_stmt|;
name|vinfo
operator|.
name|yres
operator|=
name|nh
expr_stmt|;
name|vinfo
operator|.
name|bits_per_pixel
operator|=
name|nd
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOPUT_VSCREENINFO
argument_list|,
operator|&
name|vinfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::setMode"
argument_list|)
expr_stmt|;
name|qCritical
argument_list|(
literal|"Error writing variable information in mode change"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_VSCREENINFO
argument_list|,
operator|&
name|vinfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::setMode"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Error reading changed variable information in mode change"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOGET_FSCREENINFO
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QLinuxFbScreen::setMode"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Error reading fixed information"
argument_list|)
expr_stmt|;
block|}
name|fixupScreenInfo
argument_list|(
name|finfo
argument_list|,
name|vinfo
argument_list|)
expr_stmt|;
name|disconnect
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|d_ptr
operator|->
name|displaySpec
argument_list|)
expr_stmt|;
name|exposeRegion
argument_list|(
name|region
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// save the state of the graphics card
end_comment
begin_comment
comment|// This is needed so that e.g. we can restore the palette when switching
end_comment
begin_comment
comment|// between linux virtual consoles.
end_comment
begin_comment
comment|/*!     \reimp      This doesn't do anything; accelerated drivers may wish to reimplement     it to save graphics cards registers. It's called by the     \l{Qt for Embedded Linux} server when the virtual console is switched. */
end_comment
begin_function
DECL|function|save
name|void
name|QLinuxFbScreen
operator|::
name|save
parameter_list|()
block|{
comment|// nothing to do.
block|}
end_function
begin_comment
comment|// restore the state of the graphics card.
end_comment
begin_comment
comment|/*!     \reimp      This is called when the virtual console is switched back to     \l{Qt for Embedded Linux} and restores the palette. */
end_comment
begin_function
DECL|function|restore
name|void
name|QLinuxFbScreen
operator|::
name|restore
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
operator|(
name|d
operator|==
literal|8
operator|)
operator|||
operator|(
name|d
operator|==
literal|4
operator|)
condition|)
block|{
name|fb_cmap
name|cmap
decl_stmt|;
name|cmap
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|cmap
operator|.
name|len
operator|=
name|screencols
expr_stmt|;
name|cmap
operator|.
name|red
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|green
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|blue
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|transp
operator|=
operator|(
name|unsigned
name|short
name|int
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
name|int
operator|)
operator|*
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|loopc
init|=
literal|0
init|;
name|loopc
operator|<
name|screencols
condition|;
name|loopc
operator|++
control|)
block|{
name|cmap
operator|.
name|red
index|[
name|loopc
index|]
operator|=
name|qRed
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|green
index|[
name|loopc
index|]
operator|=
name|qGreen
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|blue
index|[
name|loopc
index|]
operator|=
name|qBlue
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|cmap
operator|.
name|transp
index|[
name|loopc
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOPUTCMAP
argument_list|,
operator|&
name|cmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|green
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|blue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmap
operator|.
name|transp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn int QLinuxFbScreen::sharedRamSize(void * end)     \internal */
end_comment
begin_comment
comment|// This works like the QScreenCursor code. end points to the end
end_comment
begin_comment
comment|// of our shared structure, we return the amount of memory we reserved
end_comment
begin_function
DECL|function|sharedRamSize
name|int
name|QLinuxFbScreen
operator|::
name|sharedRamSize
parameter_list|(
name|void
modifier|*
name|end
parameter_list|)
block|{
name|shared
operator|=
operator|(
name|QLinuxFb_Shared
operator|*
operator|)
name|end
expr_stmt|;
name|shared
operator|--
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|QLinuxFb_Shared
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setDirty
name|void
name|QLinuxFbScreen
operator|::
name|setDirty
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|driverType
operator|==
name|EInk8Track
condition|)
block|{
comment|// e-Ink displays need a trigger to actually show what is
comment|// in their framebuffer memory. The 8-Track driver does this
comment|// by adding custom IOCTLs - FBIO_EINK_DISP_PIC (0x46a2) takes
comment|// an argument specifying whether or not to flash the screen
comment|// while updating.
comment|// There doesn't seem to be a way to tell it to just update
comment|// a subset of the screen.
if|if
condition|(
name|r
operator|.
name|left
argument_list|()
operator|==
literal|0
operator|&&
name|r
operator|.
name|top
argument_list|()
operator|==
literal|0
operator|&&
name|r
operator|.
name|width
argument_list|()
operator|==
name|dw
operator|&&
name|r
operator|.
name|height
argument_list|()
operator|==
name|dh
condition|)
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
literal|0x46a2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
literal|0x46a2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|blank
name|void
name|QLinuxFbScreen
operator|::
name|blank
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|blank
operator|==
name|on
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|QT_QWS_IPAQ
argument_list|)
if|if
condition|(
name|on
condition|)
name|system
argument_list|(
literal|"apm -suspend"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d_ptr
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
return|return;
comment|// Some old kernel versions don't have this.  These defines should go
comment|// away eventually
if|#
directive|if
name|defined
argument_list|(
name|FBIOBLANK
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|VESA_POWERDOWN
argument_list|)
operator|&&
name|defined
argument_list|(
name|VESA_NO_BLANKING
argument_list|)
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOBLANK
argument_list|,
name|on
condition|?
name|VESA_POWERDOWN
else|:
name|VESA_NO_BLANKING
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|d_ptr
operator|->
name|fd
argument_list|,
name|FBIOBLANK
argument_list|,
name|on
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|d_ptr
operator|->
name|blank
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPixelFormat
name|void
name|QLinuxFbScreen
operator|::
name|setPixelFormat
parameter_list|(
name|struct
name|fb_var_screeninfo
name|info
parameter_list|)
block|{
specifier|const
name|fb_bitfield
name|rgba
index|[
literal|4
index|]
init|=
block|{
name|info
operator|.
name|red
block|,
name|info
operator|.
name|green
block|,
name|info
operator|.
name|blue
block|,
name|info
operator|.
name|transp
block|}
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|QImage
operator|::
name|Format_Invalid
decl_stmt|;
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|32
case|:
block|{
specifier|const
name|fb_bitfield
name|argb8888
index|[
literal|4
index|]
init|=
block|{
block|{
literal|16
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|8
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|24
block|,
literal|8
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|const
name|fb_bitfield
name|abgr8888
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|8
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|16
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|24
block|,
literal|8
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|argb8888
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|argb8888
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|abgr8888
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
name|pixeltype
operator|=
name|QScreen
operator|::
name|BGRPixel
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|24
case|:
block|{
specifier|const
name|fb_bitfield
name|rgb888
index|[
literal|4
index|]
init|=
block|{
block|{
literal|16
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|8
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|const
name|fb_bitfield
name|bgr888
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|8
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|16
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|rgb888
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB888
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|bgr888
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB888
expr_stmt|;
name|pixeltype
operator|=
name|QScreen
operator|::
name|BGRPixel
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|18
case|:
block|{
specifier|const
name|fb_bitfield
name|rgb666
index|[
literal|4
index|]
init|=
block|{
block|{
literal|12
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|rgb666
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_RGB666
expr_stmt|;
break|break;
block|}
case|case
literal|16
case|:
block|{
specifier|const
name|fb_bitfield
name|rgb565
index|[
literal|4
index|]
init|=
block|{
block|{
literal|11
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|const
name|fb_bitfield
name|bgr565
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|11
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|rgb565
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|bgr565
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
name|pixeltype
operator|=
name|QScreen
operator|::
name|BGRPixel
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|15
case|:
block|{
specifier|const
name|fb_bitfield
name|rgb1555
index|[
literal|4
index|]
init|=
block|{
block|{
literal|10
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|15
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|const
name|fb_bitfield
name|bgr1555
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|10
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|15
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|rgb1555
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB555
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|bgr1555
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB555
expr_stmt|;
name|pixeltype
operator|=
name|QScreen
operator|::
name|BGRPixel
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|12
case|:
block|{
specifier|const
name|fb_bitfield
name|rgb444
index|[
literal|4
index|]
init|=
block|{
block|{
literal|8
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rgba
argument_list|,
name|rgb444
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fb_bitfield
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_RGB444
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
break|break;
case|case
literal|1
case|:
name|format
operator|=
name|QImage
operator|::
name|Format_Mono
expr_stmt|;
comment|//###: LSB???
break|break;
default|default:
break|break;
block|}
name|QScreen
operator|::
name|setPixelFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|useOffscreen
name|bool
name|QLinuxFbScreen
operator|::
name|useOffscreen
parameter_list|()
block|{
comment|// Not done for 8Track because on e-Ink displays,
comment|// everything is offscreen anyway
if|if
condition|(
name|d_ptr
operator|->
name|driverType
operator|==
name|EInk8Track
operator|||
operator|(
operator|(
name|mapsize
operator|-
name|size
operator|)
operator|<
literal|16
operator|*
literal|1024
operator|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_LINUXFB
end_comment
end_unit
