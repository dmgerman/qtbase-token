begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlock_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QWS_MULTIPROCESS
end_ifdef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/* no multiprocess - use a dummy */
end_comment
begin_constructor
DECL|function|QLock
name|QLock
operator|::
name|QLock
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*filename*/
parameter_list|,
name|char
comment|/*id*/
parameter_list|,
name|bool
comment|/*create*/
parameter_list|)
member_init_list|:
name|type
argument_list|(
name|Read
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QLock
name|QLock
operator|::
name|~
name|QLock
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|isValid
name|bool
name|QLock
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|lock
name|void
name|QLock
operator|::
name|lock
parameter_list|(
name|Type
name|t
parameter_list|)
block|{
name|data
operator|=
operator|(
name|QLockData
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QLock
operator|::
name|unlock
parameter_list|()
block|{
name|data
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|locked
name|bool
name|QLock
operator|::
name|locked
parameter_list|()
specifier|const
block|{
return|return
name|data
return|;
block|}
end_function
begin_expr_stmt
name|QT_END_NAMESPACE
else|#
directive|else
comment|// QT_NO_QWS_MULTIPROCESS
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
define|#
directive|define
name|Q_NO_SEMAPHORE
endif|#
directive|endif
include|#
directive|include
file|"qwssignalhandler_p.h"
include|#
directive|include
file|<unistd.h>
include|#
directive|include
file|<sys/types.h>
include|#
directive|include
file|<sys/ipc.h>
if|#
directive|if
name|defined
argument_list|(
name|Q_NO_SEMAPHORE
argument_list|)
include|#
directive|include
file|<sys/stat.h>
include|#
directive|include
file|<sys/file.h>
else|#
directive|else
include|#
directive|include
file|<sys/sem.h>
endif|#
directive|endif
include|#
directive|include
file|<string.h>
include|#
directive|include
file|<errno.h>
include|#
directive|include
file|<qdebug.h>
include|#
directive|include
file|<private/qcore_unix_p.h>
comment|// overrides QT_OPEN
name|QT_BEGIN_NAMESPACE
define|#
directive|define
name|MAX_LOCKS
value|200
comment|// maximum simultaneous read locks
name|class
name|QLockData
block|{
specifier|public
operator|:
ifdef|#
directive|ifdef
name|Q_NO_SEMAPHORE
name|QByteArray
name|file
block|;
endif|#
directive|endif
comment|// Q_NO_SEMAPHORE
name|int
name|id
block|;
name|int
name|count
block|;
name|bool
name|owned
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*!     \class QLock     \brief The QLock class is a wrapper for a System V shared semaphore.      \ingroup qws      \internal      It is used by \l{Qt for Embedded Linux} for synchronizing access to the graphics     card and shared memory region between processes. */
end_comment
begin_comment
comment|/*!     \enum QLock::Type      \value Read     \value Write */
end_comment
begin_comment
comment|/*!     \fn QLock::QLock(const QString&filename, char id, bool create)      Creates a lock. \a filename is the file path of the Unix-domain     socket the \l{Qt for Embedded Linux} client is using. \a id is the name of the     particular lock to be created on that socket. If \a create is true     the lock is to be created (as the Qt for Embedded Linux server does); if \a     create is false the lock should exist already (as the Qt for Embedded Linux     client expects). */
end_comment
begin_constructor
name|QLock
operator|::
name|QLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|filename
parameter_list|,
name|char
name|id
parameter_list|,
name|bool
name|create
parameter_list|)
block|{
name|data
operator|=
operator|new
name|QLockData
expr_stmt|;
name|data
operator|->
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_NO_SEMAPHORE
name|data
operator|->
name|file
operator|=
name|QString
argument_list|(
name|filename
operator|+
name|id
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|data
operator|->
name|id
operator|=
name|QT_OPEN
argument_list|(
name|data
operator|->
name|file
argument_list|,
name|O_RDWR
operator||
operator|(
name|x
condition|?
name|O_CREAT
else|:
literal|0
operator|)
argument_list|,
name|S_IRWXU
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|id
operator|!=
operator|-
literal|1
operator|||
operator|!
name|create
condition|)
block|{
name|data
operator|->
name|owned
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
name|key_t
name|semkey
init|=
name|ftok
argument_list|(
name|filename
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|data
operator|->
name|id
operator|=
name|semget
argument_list|(
name|semkey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|owned
operator|=
name|create
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
name|qt_semun
name|arg
decl_stmt|;
name|arg
operator|.
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|id
operator|!=
operator|-
literal|1
condition|)
name|semctl
argument_list|(
name|data
operator|->
name|id
argument_list|,
literal|0
argument_list|,
name|IPC_RMID
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|data
operator|->
name|id
operator|=
name|semget
argument_list|(
name|semkey
argument_list|,
literal|1
argument_list|,
name|IPC_CREAT
operator||
literal|0600
argument_list|)
expr_stmt|;
name|arg
operator|.
name|val
operator|=
name|MAX_LOCKS
expr_stmt|;
name|semctl
argument_list|(
name|data
operator|->
name|id
argument_list|,
literal|0
argument_list|,
name|SETVAL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|QWSSignalHandler
operator|::
name|instance
argument_list|()
operator|->
name|addSemaphore
argument_list|(
name|data
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|data
operator|->
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|eno
init|=
name|errno
decl_stmt|;
name|qWarning
argument_list|(
literal|"Cannot %s semaphore %s '%c'"
argument_list|,
operator|(
name|create
condition|?
literal|"create"
else|:
literal|"get"
operator|)
argument_list|,
name|qPrintable
argument_list|(
name|filename
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Error"
operator|<<
name|eno
operator|<<
name|strerror
argument_list|(
name|eno
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \fn QLock::~QLock()      Destroys a lock */
end_comment
begin_destructor
name|QLock
operator|::
name|~
name|QLock
parameter_list|()
block|{
if|if
condition|(
name|locked
argument_list|()
condition|)
name|unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_NO_SEMAPHORE
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
name|QT_CLOSE
argument_list|(
name|data
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|owned
condition|)
name|unlink
argument_list|(
name|data
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|data
operator|->
name|owned
condition|)
name|QWSSignalHandler
operator|::
name|instance
argument_list|()
operator|->
name|removeSemaphore
argument_list|(
name|data
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|data
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QLock::isValid() const      Returns true if the lock constructor was successful; returns false if     the lock could not be created or was not available to connect to. */
end_comment
begin_function
name|bool
name|QLock
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|data
operator|->
name|id
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Locks the semaphore with a lock of type \a t. Locks can either be     \c Read or \c Write. If a lock is \c Read, attempts by other     processes to obtain \c Read locks will succeed, and \c Write     attempts will block until the lock is unlocked. If locked as \c     Write, all attempts to lock by other processes will block until     the lock is unlocked. Locks are stacked: i.e. a given QLock can be     locked multiple times by the same process without blocking, and     will only be unlocked after a corresponding number of unlock()     calls. */
end_comment
begin_function
name|void
name|QLock
operator|::
name|lock
parameter_list|(
name|Type
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
operator|->
name|count
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_NO_SEMAPHORE
name|int
name|op
init|=
name|LOCK_SH
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Write
condition|)
name|op
operator|=
name|LOCK_EX
expr_stmt|;
for|for
control|(
name|int
name|rv
init|=
literal|1
init|;
name|rv
condition|;
control|)
block|{
name|rv
operator|=
name|flock
argument_list|(
name|data
operator|->
name|id
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|qDebug
argument_list|(
literal|"Semop lock failure %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sembuf
name|sops
decl_stmt|;
name|sops
operator|.
name|sem_num
operator|=
literal|0
expr_stmt|;
name|sops
operator|.
name|sem_flg
operator|=
name|SEM_UNDO
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|Write
condition|)
block|{
name|sops
operator|.
name|sem_op
operator|=
operator|-
name|MAX_LOCKS
expr_stmt|;
name|type
operator|=
name|Write
expr_stmt|;
block|}
else|else
block|{
name|sops
operator|.
name|sem_op
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|Read
expr_stmt|;
block|}
name|int
name|rv
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|semop
argument_list|(
name|data
operator|->
name|id
argument_list|,
operator|&
name|sops
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|qDebug
argument_list|(
literal|"Semop lock failure %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
endif|#
directive|endif
block|}
name|data
operator|->
name|count
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLock::unlock()      Unlocks the semaphore. If other processes were blocking waiting to     lock() the semaphore, one of them will wake up and succeed in     lock()ing. */
end_comment
begin_function
name|void
name|QLock
operator|::
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|data
operator|->
name|count
condition|)
block|{
name|data
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|count
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_NO_SEMAPHORE
for|for
control|(
name|int
name|rv
init|=
literal|1
init|;
name|rv
condition|;
control|)
block|{
name|rv
operator|=
name|flock
argument_list|(
name|data
operator|->
name|id
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|qDebug
argument_list|(
literal|"Semop lock failure %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sembuf
name|sops
decl_stmt|;
name|sops
operator|.
name|sem_num
operator|=
literal|0
expr_stmt|;
name|sops
operator|.
name|sem_op
operator|=
literal|1
expr_stmt|;
name|sops
operator|.
name|sem_flg
operator|=
name|SEM_UNDO
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Write
condition|)
name|sops
operator|.
name|sem_op
operator|=
name|MAX_LOCKS
expr_stmt|;
name|int
name|rv
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|semop
argument_list|(
name|data
operator|->
name|id
argument_list|,
operator|&
name|sops
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|qDebug
argument_list|(
literal|"Semop unlock failure %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|qDebug
argument_list|(
literal|"Unlock without corresponding lock"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QLock::locked() const      Returns true if the lock is currently held by the current process;     otherwise returns false. */
end_comment
begin_function
name|bool
name|QLock
operator|::
name|locked
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|data
operator|->
name|count
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_MULTIPROCESS
end_comment
end_unit
