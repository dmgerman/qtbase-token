begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qunixsocketserver_p.h"
end_include
begin_comment
comment|// #define QUNIXSOCKETSERVER_DEBUG
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QUNIXSOCKETSERVER_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qsocketnotifier.h>
end_include
begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|<sys/types.h>
include|#
directive|include
file|<sys/socket.h>
include|#
directive|include
file|<sys/un.h>
include|#
directive|include
file|<unistd.h>
include|#
directive|include
file|<errno.h>
block|}
end_extern
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_define
DECL|macro|UNIX_PATH_MAX
define|#
directive|define
name|UNIX_PATH_MAX
value|108
end_define
begin_comment
DECL|macro|UNIX_PATH_MAX
comment|// From unix(7)
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QUnixSocketServerPrivate
class|class
name|QUnixSocketServerPrivate
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|QUnixSocketServerPrivate
name|QUnixSocketServerPrivate
parameter_list|(
name|QUnixSocketServer
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|()
member_init_list|,
name|me
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|maxConns
argument_list|(
literal|30
argument_list|)
member_init_list|,
name|error
argument_list|(
name|QUnixSocketServer
operator|::
name|NoError
argument_list|)
member_init_list|,
name|acceptNotifier
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|me
name|QUnixSocketServer
modifier|*
name|me
decl_stmt|;
DECL|member|fd
name|int
name|fd
decl_stmt|;
DECL|member|maxConns
name|int
name|maxConns
decl_stmt|;
DECL|member|address
name|QByteArray
name|address
decl_stmt|;
DECL|member|error
name|QUnixSocketServer
operator|::
name|ServerError
name|error
decl_stmt|;
DECL|member|acceptNotifier
name|QSocketNotifier
modifier|*
name|acceptNotifier
decl_stmt|;
public|public
name|slots
public|:
name|void
name|acceptActivated
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!   \class QUnixSocketServer   \internal    \brief The QUnixSocketServer class provides a Unix domain socket based server.   \omit   \ingroup Platform::DeviceSpecific   \ingroup Platform::OS   \ingroup Platform::Communications   \endomit   \ingroup qws    This class makes it possible to accept incoming Unix domain socket   connections.  Call \l QUnixSocketServer::listen() to have the server listen   for incoming connections on a specified path.  The pure virtual   \l QUnixSocketServer::incomingConnection() is called each time a new   connection is established.  Users must inherit from QUnixSocketServer and   implement this method.    If an error occurs, \l QUnixSocketServer::serverError() returns the type of   error.  Errors can only occur during server establishment - that is, during a   call to \l QUnixSocketServer::listen().  Calling \l QUnixSocketServer::close()   causes QUnixSocketServer to stop listening for connections and reset its   state.    QUnixSocketServer is often used in conjunction with the \l QUnixSocket class.    \sa QUnixSocket */
end_comment
begin_comment
comment|/*!   \enum QUnixSocketServer::ServerError    The ServerError enumeration represents the errors that can occur during server   establishment.  The most recent error can be retrieved through a call to   \l QUnixSocketServer::serverError().    \value NoError No error has occurred.   \value InvalidPath An invalid path endpoint was passed to          \l QUnixSocketServer::listen().  As defined by unix(7), invalid paths          include an empty path, or what more than 107 characters long.   \value ResourceError An error acquiring or manipulating the system's socket          resources occurred.  For example, if the process runs out of available          socket descriptors, a ResourceError will occur.   \value BindError The server was unable to bind to the specified path.   \value ListenError The server was unable to listen on the specified path for          incoming connections.   */
end_comment
begin_comment
comment|/*!   Create a new Unix socket server with the given \a parent.   */
end_comment
begin_constructor
DECL|function|QUnixSocketServer
name|QUnixSocketServer
operator|::
name|QUnixSocketServer
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Stops listening for incoming connection and destroys the Unix socket server.   */
end_comment
begin_destructor
DECL|function|~QUnixSocketServer
name|QUnixSocketServer
operator|::
name|~
name|QUnixSocketServer
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Stop listening for incoming connections and resets the Unix socket server's   state.  Calling this method while \l {QUnixSocketServer::isListening()}{not listening } for incoming connections is a no-op.    \sa QUnixSocketServer::listen()   */
end_comment
begin_function
DECL|function|close
name|void
name|QUnixSocketServer
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|acceptNotifier
condition|)
block|{
name|d
operator|->
name|acceptNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|acceptNotifier
expr_stmt|;
block|}
name|d
operator|->
name|acceptNotifier
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|d
operator|->
name|fd
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|int
name|closerv
init|=
endif|#
directive|endif
operator|::
name|close
argument_list|(
name|d
operator|->
name|fd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
literal|0
operator|!=
name|closerv
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketServer: Unable to close socket ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|address
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
name|d
operator|->
name|error
operator|=
name|NoError
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the last server error.  Errors may only occur within a call to   \l QUnixSocketServer::listen(), and only when such a call fails.    This method is not destructive, so multiple calls to   QUnixSocketServer::serverError() will return the same value.  The error is   only reset by an explicit call to \l QUnixSocketServer::close() or   by further calls to \l QUnixSocketServer::listen().   */
end_comment
begin_function
DECL|function|serverError
name|QUnixSocketServer
operator|::
name|ServerError
name|QUnixSocketServer
operator|::
name|serverError
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|NoError
return|;
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this server is listening for incoming connections, false   otherwise.    \sa QUnixSocketServer::listen()   */
end_comment
begin_function
DECL|function|isListening
name|bool
name|QUnixSocketServer
operator|::
name|isListening
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|-
literal|1
operator|!=
name|d
operator|->
name|fd
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Tells the server to listen for incoming connections on \a path.  Returns true   if it successfully initializes, false otherwise.  In the case of failure, the   \l QUnixSocketServer::serverError() error status is set accordingly.    Calling this method while the server is already running will result in the   server begin reset, and then attempting to listen on \a path.  This will not   affect connections established prior to the server being reset, but further   incoming connections on the previous path will be refused.    The server can be explicitly reset by a call to \l QUnixSocketServer::close().    \sa QUnixSocketServer::close()   */
end_comment
begin_function
DECL|function|listen
name|bool
name|QUnixSocketServer
operator|::
name|listen
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
comment|// Any existing server is destroyed
block|}
else|else
block|{
name|d
operator|=
operator|new
name|QUnixSocketServerPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|||
name|path
operator|.
name|size
argument_list|()
operator|>
name|UNIX_PATH_MAX
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|InvalidPath
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// ok if this fails
comment|// Create the socket
name|d
operator|->
name|fd
operator|=
operator|::
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|d
operator|->
name|fd
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKETSERVER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketServer: Unable to create socket ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|error
operator|=
name|ResourceError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Construct our unix address
name|struct
operator|::
name|sockaddr_un
name|addr
decl_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|::
name|memcpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
name|path
operator|.
name|data
argument_list|()
argument_list|,
name|path
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|<
name|UNIX_PATH_MAX
condition|)
name|addr
operator|.
name|sun_path
index|[
name|path
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// Attempt to bind
if|if
condition|(
operator|-
literal|1
operator|==
operator|::
name|bind
argument_list|(
name|d
operator|->
name|fd
argument_list|,
operator|(
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr_un
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKETSERVER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketServer: Unable to bind socket ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|error
operator|=
name|BindError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Listen to socket
if|if
condition|(
operator|-
literal|1
operator|==
operator|::
name|listen
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|d
operator|->
name|maxConns
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKETSERVER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketServer: Unable to listen socket ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|error
operator|=
name|ListenError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Success!
name|d
operator|->
name|address
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|acceptNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|acceptNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|acceptNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|,
name|SLOT
argument_list|(
name|acceptActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the Unix path on which this server is listening.  If this server is   not listening, and empty address will be returned.   */
end_comment
begin_function
DECL|function|serverAddress
name|QByteArray
name|QUnixSocketServer
operator|::
name|serverAddress
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|d
operator|->
name|address
return|;
block|}
end_function
begin_function
DECL|function|socketDescriptor
name|int
name|QUnixSocketServer
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|fd
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the maximum length the queue of pending connections may grow to.  That   is, the maximum number of clients attempting to connect for which the Unix   socket server has not yet accepted and passed to   \l QUnixSocketServer::incomingConnection().  If a connection request arrives   with the queue full, the client may receive a connection refused notification.    By default a queue length of 30 is used.    \sa QUnixSocketServer::setMaxPendingConnections()   */
end_comment
begin_function
DECL|function|maxPendingConnections
name|int
name|QUnixSocketServer
operator|::
name|maxPendingConnections
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|30
return|;
return|return
name|d
operator|->
name|maxConns
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the maximum length the queue of pending connections may grow to   \a numConnections.  This value will only apply to   \l QUnixSocketServer::listen() calls made following the value change - it will   not be retroactively applied.    \sa QUnixSocketServer::maxPendingConnections()   */
end_comment
begin_function
DECL|function|setMaxPendingConnections
name|void
name|QUnixSocketServer
operator|::
name|setMaxPendingConnections
parameter_list|(
name|int
name|numConnections
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|numConnections
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUnixSocketServerPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|maxConns
operator|=
name|numConnections
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QUnixSocketServer::incomingConnection(int socketDescriptor)    This method is invoked each time a new incoming connection is established with   the server.  Clients must reimplement this function in their QUnixSocketServer   derived class to handle the connection.    A common approach to handling the connection is to pass \a socketDescriptor to   a QUnixSocket instance.    \sa QUnixSocket   */
end_comment
begin_function
DECL|function|acceptActivated
name|void
name|QUnixSocketServerPrivate
operator|::
name|acceptActivated
parameter_list|()
block|{
operator|::
name|sockaddr_un
name|r
decl_stmt|;
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|sockaddr_un
argument_list|)
decl_stmt|;
name|int
name|connsock
init|=
operator|::
name|accept
argument_list|(
name|fd
argument_list|,
operator|(
name|sockaddr
operator|*
operator|)
operator|&
name|r
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKETSERVER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketServer: Accept connection "
operator|<<
name|connsock
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
literal|1
operator|!=
name|connsock
condition|)
name|me
operator|->
name|incomingConnection
argument_list|(
name|connsock
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qunixsocketserver.moc"
end_include
end_unit
