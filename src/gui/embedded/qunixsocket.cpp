begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qunixsocket_p.h"
end_include
begin_comment
comment|// #define QUNIXSOCKET_DEBUG 1
end_comment
begin_include
include|#
directive|include
file|<QtCore/qsocketnotifier.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qqueue.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_comment
comment|// overrides QT_OPEN
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|<unistd.h>
include|#
directive|include
file|<string.h>
include|#
directive|include
file|<errno.h>
include|#
directive|include
file|<sys/socket.h>
include|#
directive|include
file|<sys/un.h>
block|}
end_extern
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_define
DECL|macro|UNIX_PATH_MAX
define|#
directive|define
name|UNIX_PATH_MAX
value|108
end_define
begin_comment
DECL|macro|UNIX_PATH_MAX
comment|// From unix(7)
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_LINUXBASE
end_ifdef
begin_comment
comment|// LSB doesn't declare ucred
end_comment
begin_struct
DECL|struct|ucred
struct|struct
name|ucred
block|{
DECL|member|pid
name|pid_t
name|pid
decl_stmt|;
comment|/* PID of sending process.  */
DECL|member|uid
name|uid_t
name|uid
decl_stmt|;
comment|/* UID of sending process.  */
DECL|member|gid
name|gid_t
name|gid
decl_stmt|;
comment|/* GID of sending process.  */
block|}
struct|;
end_struct
begin_comment
comment|// LSB doesn't define the ones below
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|SO_PASSCRED
end_ifndef
begin_define
DECL|macro|SO_PASSCRED
define|#
directive|define
name|SO_PASSCRED
value|16
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|SCM_CREDENTIALS
end_ifndef
begin_define
DECL|macro|SCM_CREDENTIALS
define|#
directive|define
name|SCM_CREDENTIALS
value|0x02
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|MSG_DONTWAIT
end_ifndef
begin_define
DECL|macro|MSG_DONTWAIT
define|#
directive|define
name|MSG_DONTWAIT
value|0x40
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|MSG_NOSIGNAL
end_ifndef
begin_define
DECL|macro|MSG_NOSIGNAL
define|#
directive|define
name|MSG_NOSIGNAL
value|0x4000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_LINUXBASE
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// class QUnixSocketRights
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/*!   \class QUnixSocketRights   \internal    \brief The QUnixSocketRights class encapsulates QUnixSocket rights data.   \omit   \ingroup Platform::DeviceSpecific   \ingroup Platform::OS   \ingroup Platform::Communications   \endomit   \ingroup qws    \l QUnixSocket allows you to transfer Unix file descriptors between processes.   A file descriptor is referred to as "rights data" as it allows one process to   transfer its right to access a resource to another.    The Unix system verifies resource permissions only when the resource is first   opened.  For example, consider a file on disk readable only by the user "qt".   A process running as user "qt" will be able to open this file for reading.   If, while the process was still reading from the file, the ownership was   changed from user "qt" to user "root", the process would be allowed to   continue reading from the file, even though attempting to reopen the file   would be denied.  Permissions are associated with special descriptors called   file descriptors which are returned to a process after it initially opens a   resource.    File descriptors can be duplicated within a process through the dup(2) system   call.  File descriptors can be passed between processes using the   \l QUnixSocket class in the same way.  Even though the receiving process never   opened the resource directly, it has the same permissions to access it as the   process that did.    \sa QUnixSocket  */
end_comment
begin_struct
DECL|struct|QUnixSocketRightsPrivate
struct|struct
name|QUnixSocketRightsPrivate
super|:
specifier|public
name|QSharedData
block|{
DECL|function|~QUnixSocketRightsPrivate
specifier|virtual
name|~
name|QUnixSocketRightsPrivate
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|int
name|closerv
init|=
endif|#
directive|endif
name|QT_CLOSE
argument_list|(
name|fd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
literal|0
operator|!=
name|closerv
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketRightsPrivate: Unable to close managed"
literal|" file descriptor ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
DECL|member|fd
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!   Create a new QUnixSocketRights instance containing the file descriptor \a fd.   \a fd will be dup(2)'d internally, so the application is free to close \a fd   following this call.    If the dup(2) fails, or you pass an invalid \a fd, an   \l {QUnixSocketRights::isValid()}{invalid } object will be   constructed.    QUnixSocketRights instances are immutable and the internal file descriptor   will be shared between any copies made of this object.  The system will   close(2) the file descriptor once it is no longer needed.   */
end_comment
begin_constructor
DECL|function|QUnixSocketRights
name|QUnixSocketRights
operator|::
name|QUnixSocketRights
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QUnixSocketRightsPrivate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|fd
condition|)
block|{
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|fd
operator|=
name|qt_safe_dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
operator|-
literal|1
operator|==
name|d
operator|->
name|fd
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketRights: Unable to duplicate fd "
operator|<<
name|fd
operator|<<
literal|" ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_constructor
begin_comment
comment|/*!   \internal    Construct a QUnixSocketRights instance on \a fd without dup(2)'ing the file   descriptor.   */
end_comment
begin_constructor
DECL|function|QUnixSocketRights
name|QUnixSocketRights
operator|::
name|QUnixSocketRights
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|-
literal|1
operator|!=
name|fd
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|QUnixSocketRightsPrivate
argument_list|()
expr_stmt|;
name|d
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the QUnixSocketRights instance.   */
end_comment
begin_destructor
DECL|function|~QUnixSocketRights
name|QUnixSocketRights
operator|::
name|~
name|QUnixSocketRights
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Create a copy of \a other.   */
end_comment
begin_function
name|QUnixSocketRights
modifier|&
DECL|function|operator =
name|QUnixSocketRights
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUnixSocketRights
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Create a copy of \a other.   */
end_comment
begin_constructor
DECL|function|QUnixSocketRights
name|QUnixSocketRights
operator|::
name|QUnixSocketRights
parameter_list|(
specifier|const
name|QUnixSocketRights
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Returns true if this QUnixSocketRights instance is managing a valid file   descriptor.  This method is equivalent to (-1 != peekFd()).    \sa QUnixSocketRights::peekFd()   */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QUnixSocketRights
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fd
operator|!=
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   Return a duplicate of the file descriptor contained in this object.  If this   is an \l {QUnixSocketRights::isValid()}{invalid } object, or the   dup(2) call fails, an invalid file descriptor (-1) will be returned.    \sa QUnixSocketRights::peekFd()   */
end_comment
begin_function
DECL|function|dupFd
name|int
name|QUnixSocketRights
operator|::
name|dupFd
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|d
operator|->
name|fd
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|rv
init|=
name|qt_safe_dup
argument_list|(
name|d
operator|->
name|fd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocketRights: Unable to duplicate managed file "
literal|"descriptor ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the file descriptor contained in this object.  If this   is an \l {QUnixSocketRights::isValid()}{invalid } object an invalid   file descriptor (-1) will be returned.    The lifetime of this file descriptor is tied to the lifetime of the   QUnixSocketRights instance.  The file descriptor returned by this method   \e may be close(2)'d when the QUnixSocketRights instance is destroyed.  If   you want to continue to use the file descriptor use   \l QUnixSocketRights::dupFd() instead.    \sa QUnixSocketRights::dupFd()   */
end_comment
begin_function
DECL|function|peekFd
name|int
name|QUnixSocketRights
operator|::
name|peekFd
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fd
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// class QUnixSocketMessage
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_struct
DECL|struct|QUnixSocketMessagePrivate
struct|struct
name|QUnixSocketMessagePrivate
super|:
specifier|public
name|QSharedData
block|{
DECL|function|QUnixSocketMessagePrivate
name|QUnixSocketMessagePrivate
parameter_list|()
member_init_list|:
name|state
argument_list|(
name|Default
argument_list|)
member_init_list|,
name|vec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iovecLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataSize
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|QUnixSocketMessagePrivate
name|QUnixSocketMessagePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|b
parameter_list|)
member_init_list|:
name|bytes
argument_list|(
name|b
argument_list|)
member_init_list|,
name|state
argument_list|(
name|Default
argument_list|)
member_init_list|,
name|vec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iovecLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataSize
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|QUnixSocketMessagePrivate
name|QUnixSocketMessagePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|b
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
modifier|&
name|r
parameter_list|)
member_init_list|:
name|bytes
argument_list|(
name|b
argument_list|)
member_init_list|,
name|rights
argument_list|(
name|r
argument_list|)
member_init_list|,
name|state
argument_list|(
name|Default
argument_list|)
member_init_list|,
name|vec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iovecLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataSize
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|size
name|int
name|size
parameter_list|()
specifier|const
block|{
return|return
name|vec
condition|?
name|dataSize
else|:
name|bytes
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|removeBytes
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
DECL|member|bytes
name|QByteArray
name|bytes
decl_stmt|;
DECL|member|rights
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
name|rights
decl_stmt|;
DECL|enum|AncillaryDataState
enum|enum
name|AncillaryDataState
block|{
DECL|enumerator|Default
name|Default
init|=
literal|0x00
block|,
DECL|enumerator|Truncated
name|Truncated
init|=
literal|0x01
block|,
DECL|enumerator|Credential
name|Credential
init|=
literal|0x02
block|}
enum|;
DECL|member|state
name|AncillaryDataState
name|state
decl_stmt|;
DECL|member|pid
name|pid_t
name|pid
decl_stmt|;
DECL|member|gid
name|gid_t
name|gid
decl_stmt|;
DECL|member|uid
name|uid_t
name|uid
decl_stmt|;
DECL|member|vec
operator|::
name|iovec
modifier|*
name|vec
decl_stmt|;
DECL|member|iovecLen
name|int
name|iovecLen
decl_stmt|;
comment|// number of vectors in array
DECL|member|dataSize
name|int
name|dataSize
decl_stmt|;
comment|// total size of vectors = payload
block|}
struct|;
end_struct
begin_comment
comment|/*!   \internal   Remove \a bytesToDequeue bytes from the front of this message */
end_comment
begin_function
DECL|function|removeBytes
name|void
name|QUnixSocketMessagePrivate
operator|::
name|removeBytes
parameter_list|(
name|unsigned
name|int
name|bytesToDequeue
parameter_list|)
block|{
if|if
condition|(
name|vec
condition|)
block|{
operator|::
name|iovec
modifier|*
name|vecPtr
init|=
name|vec
decl_stmt|;
if|if
condition|(
name|bytesToDequeue
operator|>
operator|(
name|unsigned
name|int
operator|)
name|dataSize
condition|)
name|bytesToDequeue
operator|=
name|dataSize
expr_stmt|;
while|while
condition|(
name|bytesToDequeue
operator|>
literal|0
operator|&&
name|iovecLen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vecPtr
operator|->
name|iov_len
operator|>
name|bytesToDequeue
condition|)
block|{
comment|// dequeue the bytes by taking them off the front of the
comment|// current vector.  since we don't own the iovec, its okay
comment|// to "leak" this away by pointing past it
name|char
modifier|*
modifier|*
name|base
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
operator|(
name|vecPtr
operator|->
name|iov_base
operator|)
argument_list|)
decl_stmt|;
operator|*
name|base
operator|+=
name|bytesToDequeue
expr_stmt|;
name|vecPtr
operator|->
name|iov_len
operator|-=
name|bytesToDequeue
expr_stmt|;
name|bytesToDequeue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// dequeue bytes by skipping a whole vector.  again, its ok
comment|// to lose the pointers to this data
name|bytesToDequeue
operator|-=
name|vecPtr
operator|->
name|iov_len
expr_stmt|;
name|iovecLen
operator|--
expr_stmt|;
name|vecPtr
operator|++
expr_stmt|;
block|}
block|}
name|dataSize
operator|-=
name|bytesToDequeue
expr_stmt|;
if|if
condition|(
name|iovecLen
operator|==
literal|0
condition|)
name|vec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|bytesToDequeue
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \class QUnixSocketMessage   \internal    \brief The QUnixSocketMessage class encapsulates a message sent or received   through the QUnixSocket class.   \omit   \ingroup Platform::DeviceSpecific   \ingroup Platform::OS   \ingroup Platform::Communications   \endomit   \ingroup qws    In addition to transmitting regular byte stream data, messages sent over Unix   domain sockets may have special ancillary properties.  QUnixSocketMessage   instances allow programmers to retrieve and control these properties.    Every QUnixSocketMessage sent has an associated set of credentials.  A   message's credentials consist of the process id, the user id and the group id   of the sending process.  Normally these credentials are set automatically for   you by the QUnixSocketMessage class and can be queried by the receiving   process using the \l QUnixSocketMessage::processId(),   \l QUnixSocketMessage::userId() and \l QUnixSocketMessage::groupId() methods   respectively.    Advanced applications may wish to change the credentials that their message   is sent with, and may do so though the \l QUnixSocketMessage::setProcessId(),   \l QUnixSocketMessage::setUserId() and \l QUnixSocketMessage::setGroupId()   methods.  The validity of these credentials is verified by the system kernel.   Only the root user can send messages with credentials that are not his own.   Sending of the message will fail for any non-root user who attempts to   fabricate credentials.  Note that this failure is enforced by the system   kernel - receivers can trust the accuracy of credential data!    Unix domain socket messages may also be used to transmit Unix file descriptors   between processes.  In this context, file descriptors are known as rights data   and are encapsulated by the \l QUnixSocketRights class.  Senders can set the   file descriptors to transmit using the \l QUnixSocketMessage::setRights() and   receivers can retrieve this data through a call to   \l QUnixSocketMessage::rights().  \l QUnixSocket and \l QUnixSocketRights   discuss the specific copy and ordering semantic associated with rights data.    QUnixSocketMessage messages are sent by the \l QUnixSocket::write() method.   Like any normal network message, attempting to transmit an empty   QUnixSocketMessage will succeed, but result in a no-op.  Limitations in the   Unix domain protocol semantic will cause a transmission of a   QUnixSocketMessage with rights data, but no byte data portion, to fail.    \sa QUnixSocket QUnixSocketRights   */
end_comment
begin_comment
comment|/*!   Construct an empty QUnixSocketMessage.  This instance will have not data and   no rights information.  The message's credentials will be set to the   application's default credentials.   */
end_comment
begin_constructor
DECL|function|QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|QUnixSocketMessage
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QUnixSocketMessagePrivate
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Construct a QUnixSocketMessage with an initial data payload of \a bytes.  The   message's credentials will be set to the application's default credentials.   */
end_comment
begin_constructor
DECL|function|QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|QUnixSocketMessage
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|bytes
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QUnixSocketMessagePrivate
argument_list|(
name|bytes
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Construct a QUnixSocketMessage with an initial data payload of \a bytes and   an initial rights payload of \a rights.  The message's credentials will be set   to the application's default credentials.    A message with rights data but an empty data payload cannot be transmitted   by the system.   */
end_comment
begin_constructor
DECL|function|QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|QUnixSocketMessage
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|bytes
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
modifier|&
name|rights
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QUnixSocketMessagePrivate
argument_list|(
name|bytes
argument_list|,
name|rights
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Create a copy of \a other.   */
end_comment
begin_constructor
DECL|function|QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|QUnixSocketMessage
parameter_list|(
specifier|const
name|QUnixSocketMessage
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \fn  QUnixSocketMessage::QUnixSocketMessage(const iovec* data, int vecLen)    Construct a QUnixSocketMessage with an initial data payload of \a   data which points to an array of \a vecLen iovec structures.  The   message's credentials will be set to the application's default   credentials.    This method can be used to avoid the overhead of copying buffers of data   and will directly send the data pointed to by \a data on the socket.  It also   avoids the syscall overhead of making a number of small socket write calls,   if a number of data items can be delivered with one write.    Caller must ensure the iovec * \a data remains valid until the message   is flushed.  Caller retains ownership of the iovec structs.   */
end_comment
begin_constructor
DECL|function|QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|QUnixSocketMessage
parameter_list|(
specifier|const
operator|::
name|iovec
modifier|*
name|data
parameter_list|,
name|int
name|vecLen
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QUnixSocketMessagePrivate
argument_list|()
argument_list|)
block|{
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|vecLen
condition|;
name|v
operator|++
control|)
name|d
operator|->
name|dataSize
operator|+=
name|data
index|[
name|v
index|]
operator|.
name|iov_len
expr_stmt|;
name|d
operator|->
name|vec
operator|=
cast|const_cast
argument_list|<
name|iovec
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|d
operator|->
name|iovecLen
operator|=
name|vecLen
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Assign the contents of \a other to this object.   */
end_comment
begin_function
DECL|function|operator =
name|QUnixSocketMessage
modifier|&
name|QUnixSocketMessage
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUnixSocketMessage
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Destroy this instance.   */
end_comment
begin_destructor
DECL|function|~QUnixSocketMessage
name|QUnixSocketMessage
operator|::
name|~
name|QUnixSocketMessage
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Set the data portion of the message to \a bytes.    \sa QUnixSocketMessage::bytes()   */
end_comment
begin_function
DECL|function|setBytes
name|void
name|QUnixSocketMessage
operator|::
name|setBytes
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|bytes
parameter_list|)
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Set the rights portion of the message to \a rights.    A message with rights data but an empty byte data payload cannot be   transmitted by the system.    \sa QUnixSocketMessage::rights()   */
end_comment
begin_function
DECL|function|setRights
name|void
name|QUnixSocketMessage
operator|::
name|setRights
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
modifier|&
name|rights
parameter_list|)
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|rights
operator|=
name|rights
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Return the rights portion of the message.    \sa QUnixSocketMessage::setRights()   */
end_comment
begin_function
DECL|function|rights
specifier|const
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
modifier|&
name|QUnixSocketMessage
operator|::
name|rights
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|rights
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the rights portion of the message was truncated on reception   due to insufficient buffer size.  The rights buffer size can be adjusted   through calls to the \l QUnixSocket::setRightsBufferSize() method.   \l QUnixSocket contains a discussion of the buffering and truncation   characteristics of the Unix domain protocol.    \sa QUnixSocket QUnixSocket::setRightsBufferSize()   */
end_comment
begin_function
DECL|function|rightsWereTruncated
name|bool
name|QUnixSocketMessage
operator|::
name|rightsWereTruncated
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|state
operator|&
name|QUnixSocketMessagePrivate
operator|::
name|Truncated
return|;
block|}
end_function
begin_comment
comment|/*!   Return the data portion of the message.    \sa QUnixSocketMessage::setBytes()   */
end_comment
begin_function
DECL|function|bytes
specifier|const
name|QByteArray
modifier|&
name|QUnixSocketMessage
operator|::
name|bytes
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|bytes
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the process id credential associated with this message.    \sa QUnixSocketMessage::setProcessId()   */
end_comment
begin_function
DECL|function|processId
name|pid_t
name|QUnixSocketMessage
operator|::
name|processId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|&
name|d
operator|->
name|state
condition|)
return|return
name|d
operator|->
name|pid
return|;
else|else
return|return
operator|::
name|getpid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the user id credential associated with this message.    \sa QUnixSocketMessage::setUserId()   */
end_comment
begin_function
DECL|function|userId
name|uid_t
name|QUnixSocketMessage
operator|::
name|userId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|&
name|d
operator|->
name|state
condition|)
return|return
name|d
operator|->
name|uid
return|;
else|else
return|return
operator|::
name|geteuid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the group id credential associated with this message.    \sa QUnixSocketMessage::setGroupId()   */
end_comment
begin_function
DECL|function|groupId
name|gid_t
name|QUnixSocketMessage
operator|::
name|groupId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|&
name|d
operator|->
name|state
condition|)
return|return
name|d
operator|->
name|gid
return|;
else|else
return|return
operator|::
name|getegid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Set the process id credential associated with this message to \a pid.  Unless   you are the root user, setting a fraudulant credential will cause this message   to fail.    \sa QUnixSocketMessage::processId()  */
end_comment
begin_function
DECL|function|setProcessId
name|void
name|QUnixSocketMessage
operator|::
name|setProcessId
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|state
operator|&
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|)
condition|)
block|{
name|d
operator|->
name|state
operator|=
call|(
name|QUnixSocketMessagePrivate
operator|::
name|AncillaryDataState
call|)
argument_list|(
name|d
operator|->
name|state
operator||
name|QUnixSocketMessagePrivate
operator|::
name|Credential
argument_list|)
expr_stmt|;
name|d
operator|->
name|uid
operator|=
operator|::
name|geteuid
argument_list|()
expr_stmt|;
name|d
operator|->
name|gid
operator|=
operator|::
name|getegid
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Set the user id credential associated with this message to \a uid.  Unless   you are the root user, setting a fraudulant credential will cause this message   to fail.    \sa QUnixSocketMessage::userId()  */
end_comment
begin_function
DECL|function|setUserId
name|void
name|QUnixSocketMessage
operator|::
name|setUserId
parameter_list|(
name|uid_t
name|uid
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|state
operator|&
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|)
condition|)
block|{
name|d
operator|->
name|state
operator|=
call|(
name|QUnixSocketMessagePrivate
operator|::
name|AncillaryDataState
call|)
argument_list|(
name|d
operator|->
name|state
operator||
name|QUnixSocketMessagePrivate
operator|::
name|Credential
argument_list|)
expr_stmt|;
name|d
operator|->
name|pid
operator|=
operator|::
name|getpid
argument_list|()
expr_stmt|;
name|d
operator|->
name|gid
operator|=
operator|::
name|getegid
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Set the group id credential associated with this message to \a gid.  Unless   you are the root user, setting a fraudulant credential will cause this message   to fail.    \sa QUnixSocketMessage::groupId()  */
end_comment
begin_function
DECL|function|setGroupId
name|void
name|QUnixSocketMessage
operator|::
name|setGroupId
parameter_list|(
name|gid_t
name|gid
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|state
operator|&
name|QUnixSocketMessagePrivate
operator|::
name|Credential
operator|)
condition|)
block|{
name|d
operator|->
name|state
operator|=
call|(
name|QUnixSocketMessagePrivate
operator|::
name|AncillaryDataState
call|)
argument_list|(
name|d
operator|->
name|state
operator||
name|QUnixSocketMessagePrivate
operator|::
name|Credential
argument_list|)
expr_stmt|;
name|d
operator|->
name|pid
operator|=
operator|::
name|getpid
argument_list|()
expr_stmt|;
name|d
operator|->
name|uid
operator|=
operator|::
name|geteuid
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Return true if this message is valid.  A message with rights data but an empty   byte data payload cannot be transmitted by the system and is marked as   invalid.   */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QUnixSocketMessage
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|rights
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|d
operator|->
name|bytes
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// class QUnixSocket
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_define
DECL|macro|QUNIXSOCKET_DEFAULT_READBUFFER
define|#
directive|define
name|QUNIXSOCKET_DEFAULT_READBUFFER
value|1024
end_define
begin_define
DECL|macro|QUNIXSOCKET_DEFAULT_ANCILLARYBUFFER
define|#
directive|define
name|QUNIXSOCKET_DEFAULT_ANCILLARYBUFFER
value|0
end_define
begin_comment
comment|/*!   \class QUnixSocket   \internal    \brief The QUnixSocket class provides a Unix domain socket.    \omit   \ingroup Platform::DeviceSpecific   \ingroup Platform::OS   \ingroup Platform::Communications   \endomit   \ingroup qws    Unix domain sockets provide an efficient mechanism for communications between   Unix processes on the same machine.  Unix domain sockets support a reliable,   stream-oriented, connection-oriented transport protocol, much like TCP   sockets.  Unlike IP based sockets, the connection endpoint of a Unix domain   socket is a file on disk of type socket.    In addition to transporting raw data bytes, Unix domain sockets are able to   transmit special ancillary data.  The two types of ancillary data supported   by the QUnixSocket class are:    \list   \o Credential Data - Allows a receiver   to reliably identify the process sending each message.   \o \l {QUnixSocketRights}{Rights Data } - Allows Unix file descriptors   to be transmitted between processes.   \endlist    Because of the need to support ancillary data, QUnixSocket is not a QIODevice,   like QTcpSocket and QUdpSocket.  Instead, QUnixSocket contains a number of   read and write methods that clients must invoke directly.  Rather than   returning raw data bytes, \l QUnixSocket::read() returns \l QUnixSocketMessage   instances that encapsulate the message's byte data and any other ancillary   data.    Ancillary data is transmitted "out of band".  Every \l QUnixSocketMessage   received will have credential data associated with it that the client can   access through calls to \l QUnixSocketMessage::processId(),   \l QUnixSocketMessage::groupId() and \l QUnixSocketMessage::userId().   Likewise, message creators can set the credential data to send through calls   to \l QUnixSocketMessage::setProcessId(), \l QUnixSocketMessage::setGroupId()   and \l QUnixSocketMessage::setUserId() respectively.  The authenticity of the   credential values is verified by the system kernel and cannot be fabricated   by unprivileged processes.  Only processes running as the root user can   specify credential data that does not match the sending process.    Unix file descriptors, known as "rights data", transmitted between processes   appear as though they had been dup(2)'d between the two.  As Unix   domain sockets present a continuous stream of bytes to the receiver, the   rights data - which is transmitted out of band - must be "slotted" in at some   point.  The rights data is logically associated with the first byte - called   the anchor byte - of the \l QUnixSocketMessage to which they are attached.   Received rights data will be available from the   \l QUnixSocketMessage::rights() method for the \l QUnixSocketMessage   instance that contains the anchor byte.    In addition to a \l QUnixSocket::write() that takes a \l QUnixSocketMessage   instance - allowing a client to transmit both byte and rights data - a   number of convenience overloads are provided for use when only transmitting   simple byte data.  Unix requires that at least one byte of raw data be   transmitted in order to send rights data.  A \l QUnixSocketMessage instance   with rights data, but no byte data, cannot be transmitted.    Unix sockets present a stream interface, such that, for example, a single   six byte transmission might be received as two three byte messages.  Rights   data, on the other hand, is conceptually transmitted as unfragmentable   datagrams.  If the receiving buffer is not large enough to contain all the   transmitted rights information, the data is truncated and irretreivably lost.   Users should use the \l QUnixSocket::setRightsBufferSize() method to control   the buffer size used for this data, and develop protocols that avoid the   problem.  If the buffer size is too small and rights data is truncated,   the \l QUnixSocketMessage::rightsWereTruncated() flag will be set.    \sa QUnixSocketMessage QUnixSocketRights */
end_comment
begin_comment
comment|/*!   \enum QUnixSocket::SocketError    The SocketError enumeration represents the various errors that can occur on   a Unix domain socket.  The most recent error for the socket is available   through the \l QUnixSocket::error() method.    \value NoError No error has occurred.   \value InvalidPath An invalid path endpoint was passed to          \l QUnixSocket::connect().  As defined by unix(7), invalid paths          include an empty path, or what more than 107 characters long.   \value ResourceError An error acquiring or manipulating the system's socket          resources occurred.  For example, if the process runs out of available          socket descriptors, a ResourceError will occur.   \value NonexistentPath The endpoing passed to \l QUnixSocket::connect() does          not refer to a Unix domain socket entity on disk.   \value ConnectionRefused The connection to the specified endpoint was refused.          Generally this means that there is no server listening on that          endpoint.   \value UnknownError An unknown error has occurred.   \value ReadFailure An error occurred while reading bytes from the connection.   \value WriteFailure An error occurred while writing bytes into the connection.   */
end_comment
begin_comment
comment|/*!   \enum QUnixSocket::SocketState    The SocketState enumeration represents the connection state of a QUnixSocket   instance.    \value UnconnectedState The connection is not established.   \value ConnectedState The connection is established.   \value ClosingState The connection is being closed, following a call to          \l QUnixSocket::close().  While closing, any pending data will be          transmitted, but further writes by the application will be refused.   */
end_comment
begin_comment
comment|/*   \fn QUnixSocket::bytesWritten(qint64 bytes)    This signal is emitted every time a payload of data has been written to the   connection.  The \a bytes argument is set to the number of bytes that were   written in this payload.    \sa QUnixSocket::readyRead() */
end_comment
begin_comment
comment|/*   \fn QUnixSocket::readyRead()    This signal is emitted once every time new data is available for reading from   the connection. It will only be emitted again once new data is available.    \sa QUnixSocket::bytesWritten() */
end_comment
begin_comment
comment|/*!   \fn QUnixSocket::stateChanged(SocketState socketState)    This signal is emitted each time the socket changes connection state.   \a socketState will be set to the socket's new state. */
end_comment
begin_class
DECL|class|QUnixSocketPrivate
class|class
name|QUnixSocketPrivate
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|QUnixSocketPrivate
name|QUnixSocketPrivate
parameter_list|(
name|QUnixSocket
modifier|*
name|_me
parameter_list|)
member_init_list|:
name|me
argument_list|(
name|_me
argument_list|)
member_init_list|,
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|readNotifier
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeNotifier
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QUnixSocket
operator|::
name|UnconnectedState
argument_list|)
member_init_list|,
name|error
argument_list|(
name|QUnixSocket
operator|::
name|NoError
argument_list|)
member_init_list|,
name|writeQueueBytes
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|messageValid
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dataBuffer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataBufferLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataBufferCapacity
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ancillaryBuffer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ancillaryBufferCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|closingTimer
argument_list|(
literal|0
argument_list|)
block|{
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|me
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|me
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|~QUnixSocketPrivate
name|~
name|QUnixSocketPrivate
parameter_list|()
block|{
if|if
condition|(
name|dataBuffer
condition|)
operator|delete
index|[]
name|dataBuffer
expr_stmt|;
if|if
condition|(
name|ancillaryBuffer
condition|)
operator|delete
index|[]
name|ancillaryBuffer
expr_stmt|;
block|}
DECL|enumerator|CausedAbort
enum|enum
block|{
name|CausedAbort
init|=
literal|0x70000000
block|}
enum|;
DECL|member|me
name|QUnixSocket
modifier|*
name|me
decl_stmt|;
DECL|member|fd
name|int
name|fd
decl_stmt|;
DECL|member|readNotifier
name|QSocketNotifier
modifier|*
name|readNotifier
decl_stmt|;
DECL|member|writeNotifier
name|QSocketNotifier
modifier|*
name|writeNotifier
decl_stmt|;
DECL|member|state
name|QUnixSocket
operator|::
name|SocketState
name|state
decl_stmt|;
DECL|member|error
name|QUnixSocket
operator|::
name|SocketError
name|error
decl_stmt|;
DECL|member|writeQueue
name|QQueue
argument_list|<
name|QUnixSocketMessage
argument_list|>
name|writeQueue
decl_stmt|;
DECL|member|writeQueueBytes
name|unsigned
name|int
name|writeQueueBytes
decl_stmt|;
DECL|member|messageValid
name|bool
name|messageValid
decl_stmt|;
DECL|member|message
operator|::
name|msghdr
name|message
decl_stmt|;
DECL|function|flushAncillary
specifier|inline
name|void
name|flushAncillary
parameter_list|()
block|{
if|if
condition|(
operator|!
name|messageValid
condition|)
return|return;
operator|::
name|cmsghdr
modifier|*
name|h
init|=
operator|(
operator|::
name|cmsghdr
operator|*
operator|)
name|CMSG_FIRSTHDR
argument_list|(
operator|&
operator|(
name|message
operator|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|SCM_RIGHTS
operator|==
name|h
operator|->
name|cmsg_type
condition|)
block|{
name|int
modifier|*
name|fds
init|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|int
name|numFds
init|=
operator|(
name|h
operator|->
name|cmsg_len
operator|-
name|CMSG_LEN
argument_list|(
literal|0
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|numFds
condition|;
operator|++
name|ii
control|)
name|QT_CLOSE
argument_list|(
name|fds
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
block|}
name|h
operator|=
operator|(
operator|::
name|cmsghdr
operator|*
operator|)
name|CMSG_NXTHDR
argument_list|(
operator|&
operator|(
name|message
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|messageValid
operator|=
literal|false
expr_stmt|;
block|}
DECL|member|dataBuffer
name|char
modifier|*
name|dataBuffer
decl_stmt|;
DECL|member|dataBufferLength
name|unsigned
name|int
name|dataBufferLength
decl_stmt|;
DECL|member|dataBufferCapacity
name|unsigned
name|int
name|dataBufferCapacity
decl_stmt|;
DECL|member|ancillaryBuffer
name|char
modifier|*
name|ancillaryBuffer
decl_stmt|;
DECL|function|ancillaryBufferCapacity
specifier|inline
name|unsigned
name|int
name|ancillaryBufferCapacity
parameter_list|()
block|{
return|return
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
operator|::
name|ucred
argument_list|)
argument_list|)
operator|+
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ancillaryBufferCount
argument_list|)
return|;
block|}
DECL|member|ancillaryBufferCount
name|unsigned
name|int
name|ancillaryBufferCount
decl_stmt|;
DECL|member|address
name|QByteArray
name|address
decl_stmt|;
DECL|member|closingTimer
name|int
name|closingTimer
decl_stmt|;
DECL|function|timerEvent
specifier|virtual
name|void
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
parameter_list|)
block|{
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
name|killTimer
argument_list|(
name|closingTimer
argument_list|)
expr_stmt|;
name|closingTimer
operator|=
literal|0
expr_stmt|;
block|}
signals|signals:
name|void
name|readyRead
parameter_list|()
function_decl|;
name|void
name|bytesWritten
parameter_list|(
name|qint64
parameter_list|)
function_decl|;
public|public
name|slots
public|:
name|void
name|readActivated
parameter_list|()
function_decl|;
name|qint64
name|writeActivated
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!   Construct a QUnixSocket instance, with \a parent.    The read buffer is initially set to 1024 bytes, and the rights buffer to 0   entries.    \sa QUnixSocket::readBufferSize() QUnixSocket::rightsBufferSize()   */
end_comment
begin_constructor
DECL|function|QUnixSocket
name|QUnixSocket
operator|::
name|QUnixSocket
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
operator|new
name|QUnixSocketPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|setOpenMode
argument_list|(
name|QIODevice
operator|::
name|NotOpen
argument_list|)
expr_stmt|;
name|setReadBufferSize
argument_list|(
name|QUNIXSOCKET_DEFAULT_READBUFFER
argument_list|)
expr_stmt|;
name|setRightsBufferSize
argument_list|(
name|QUNIXSOCKET_DEFAULT_ANCILLARYBUFFER
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Construct a QUnixSocket instance, with \a parent.    The read buffer is initially set to \a readBufferSize bytes, and the rights   buffer to \a rightsBufferSize entries.    \sa QUnixSocket::readBufferSize() QUnixSocket::rightsBufferSize()   */
end_comment
begin_constructor
DECL|function|QUnixSocket
name|QUnixSocket
operator|::
name|QUnixSocket
parameter_list|(
name|qint64
name|readBufferSize
parameter_list|,
name|qint64
name|rightsBufferSize
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
operator|new
name|QUnixSocketPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|readBufferSize
operator|>
literal|0
operator|&&
name|rightsBufferSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|setOpenMode
argument_list|(
name|QIODevice
operator|::
name|NotOpen
argument_list|)
expr_stmt|;
name|setReadBufferSize
argument_list|(
name|readBufferSize
argument_list|)
expr_stmt|;
name|setRightsBufferSize
argument_list|(
name|rightsBufferSize
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the QUnixSocket instance.  Any unsent data is discarded.   */
end_comment
begin_destructor
DECL|function|~QUnixSocket
name|QUnixSocket
operator|::
name|~
name|QUnixSocket
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Attempt to connect to \a path.    This method is synchronous and will return true if the connection succeeds and   false otherwise.  In the case of failure, \l QUnixSocket::error() will be set   accordingly.    Any existing connection will be aborted, and all pending data will be   discarded.    \sa QUnixSocket::close() QUnixSocket::abort() QUnixSocket::error()   */
end_comment
begin_function
DECL|function|connect
name|bool
name|QUnixSocket
operator|::
name|connect
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
name|int
name|_true
decl_stmt|;
name|int
name|crv
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Connect requested to '"
operator|<<
name|path
operator|<<
literal|'\''
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|// Reset any existing connection
if|if
condition|(
name|UnconnectedState
operator|!=
name|d
operator|->
name|state
condition|)
comment|// abort() caused a signal and someone messed
comment|// with us.  We'll assume they know what
comment|// they're doing and bail.  Alternative is to
comment|// have a special "Connecting" state
return|return
literal|false
return|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|||
name|path
operator|.
name|size
argument_list|()
operator|>
name|UNIX_PATH_MAX
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|InvalidPath
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Create the socket
name|d
operator|->
name|fd
operator|=
operator|::
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|d
operator|->
name|fd
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to create socket ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|error
operator|=
name|ResourceError
expr_stmt|;
goto|goto
name|connect_error
goto|;
block|}
comment|// Set socket options
name|_true
operator|=
literal|1
expr_stmt|;
name|crv
operator|=
operator|::
name|setsockopt
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_PASSCRED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|_true
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|crv
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to configure socket ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|error
operator|=
name|ResourceError
expr_stmt|;
goto|goto
name|connect_error
goto|;
block|}
comment|// Construct our unix address
name|struct
operator|::
name|sockaddr_un
name|addr
decl_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|::
name|memcpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
name|path
operator|.
name|data
argument_list|()
argument_list|,
name|path
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|<
name|UNIX_PATH_MAX
condition|)
name|addr
operator|.
name|sun_path
index|[
name|path
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// Attempt the connect
name|crv
operator|=
operator|::
name|connect
argument_list|(
name|d
operator|->
name|fd
argument_list|,
operator|(
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr_un
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|crv
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to connect ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ECONNREFUSED
operator|==
name|errno
condition|)
name|d
operator|->
name|error
operator|=
name|ConnectionRefused
expr_stmt|;
elseif|else
if|if
condition|(
name|ENOENT
operator|==
name|errno
condition|)
name|d
operator|->
name|error
operator|=
name|NonexistentPath
expr_stmt|;
else|else
name|d
operator|->
name|error
operator|=
name|UnknownError
expr_stmt|;
goto|goto
name|connect_error
goto|;
block|}
comment|// We're connected!
name|d
operator|->
name|address
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|ConnectedState
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|readNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|,
name|SLOT
argument_list|(
name|readActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|writeNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|,
name|SLOT
argument_list|(
name|writeActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setOpenMode
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|ConnectedState
argument_list|)
emit|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Connected to "
operator|<<
name|path
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
name|connect_error
label|:
comment|// Cleanup failed connection
if|if
condition|(
operator|-
literal|1
operator|!=
name|d
operator|->
name|fd
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|int
name|closerv
init|=
endif|#
directive|endif
name|QT_CLOSE
argument_list|(
name|d
operator|->
name|fd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
literal|0
operator|!=
name|closerv
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to close file descriptor after "
literal|"failed connect ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the socket descriptor to use to \a socketDescriptor, bypassing   QUnixSocket's connection infrastructure, and return true on success and false   on failure.  \a socketDescriptor must be in the connected state, and must be   a Unix domain socket descriptor.  Following a successful call to this method,   the QUnixSocket instance will be in the Connected state and will have assumed   ownership of \a socketDescriptor.    Any existing connection will be aborted, and all pending data will be   discarded.    \sa QUnixSocket::connect() */
end_comment
begin_function
DECL|function|setSocketDescriptor
name|bool
name|QUnixSocket
operator|::
name|setSocketDescriptor
parameter_list|(
name|int
name|socketDescriptor
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|UnconnectedState
operator|!=
name|state
argument_list|()
condition|)
comment|// See QUnixSocket::connect()
return|return
literal|false
return|;
comment|// Attempt to set the socket options
if|if
condition|(
operator|-
literal|1
operator|==
name|socketDescriptor
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: User provided socket is invalid"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|error
operator|=
name|ResourceError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Set socket options
name|int
name|_true
init|=
literal|1
decl_stmt|;
name|int
name|crv
init|=
operator|::
name|setsockopt
argument_list|(
name|socketDescriptor
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_PASSCRED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|_true
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|crv
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to configure client provided socket ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|error
operator|=
name|ResourceError
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|fd
operator|=
name|socketDescriptor
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|ConnectedState
expr_stmt|;
name|d
operator|->
name|address
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
name|setOpenMode
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|d
operator|->
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|readNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|,
name|SLOT
argument_list|(
name|readActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|writeNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|d
argument_list|,
name|SLOT
argument_list|(
name|writeActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the socket descriptor currently in use.  This method will return -1   if the QUnixSocket instance is in the UnconnectedState \l {QUnixSocket::state()}{state. }    \sa QUnixSocket::setSocketDescriptor()   */
end_comment
begin_function
DECL|function|socketDescriptor
name|int
name|QUnixSocket
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fd
return|;
block|}
end_function
begin_comment
comment|/*!   Abort the connection.  This will immediately disconnect (if connected) and   discard any pending data.  Following a call to QUnixSocket::abort() the   object will always be in the disconnected \link QUnixSocket::state() state.   \endlink    \sa QUnixSocket::close() */
end_comment
begin_function
DECL|function|abort
name|void
name|QUnixSocket
operator|::
name|abort
parameter_list|()
block|{
name|setOpenMode
argument_list|(
name|QIODevice
operator|::
name|NotOpen
argument_list|)
expr_stmt|;
comment|// We want to be able to use QUnixSocket::abort() to cleanup our state but
comment|// also preserve the error message that caused the abort.  It is not
comment|// possible to reorder code to do this:
comment|//        abort();
comment|//        d->error = SomeError
comment|// as QUnixSocket::abort() might emit a signal and we need the error to be
comment|// set within that signal.  So, if we want an error message to be preserved
comment|// across a *single* call to abort(), we set the
comment|// QUnixSocketPrivate::CausedAbort flag in the error.
if|if
condition|(
name|d
operator|->
name|error
operator|&
name|QUnixSocketPrivate
operator|::
name|CausedAbort
condition|)
name|d
operator|->
name|error
operator|=
call|(
name|QUnixSocket
operator|::
name|SocketError
call|)
argument_list|(
name|d
operator|->
name|error
operator|&
operator|~
name|QUnixSocketPrivate
operator|::
name|CausedAbort
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|error
operator|=
name|NoError
expr_stmt|;
if|if
condition|(
name|UnconnectedState
operator|==
name|d
operator|->
name|state
condition|)
return|return;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|int
name|closerv
init|=
endif|#
directive|endif
operator|::
name|close
argument_list|(
name|d
operator|->
name|fd
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
if|if
condition|(
literal|0
operator|!=
name|closerv
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to close socket during abort ("
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Reset variables
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|UnconnectedState
expr_stmt|;
name|d
operator|->
name|dataBufferLength
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|flushAncillary
argument_list|()
expr_stmt|;
name|d
operator|->
name|address
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readNotifier
condition|)
block|{
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|writeNotifier
condition|)
block|{
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|readNotifier
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|writeQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeQueueBytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|closingTimer
condition|)
block|{
name|d
operator|->
name|killTimer
argument_list|(
name|d
operator|->
name|closingTimer
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|closingTimer
operator|=
literal|0
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!   Close the connection.  The instance will enter the Closing   \l {QUnixSocket::state()}{state } until all pending data has been   transmitted, at which point it will enter the Unconnected state.    Even if there is no pending data for transmission, the object will never   jump directly to Disconnect without first passing through the   Closing state.    \sa QUnixSocket::abort()   */
end_comment
begin_function
DECL|function|close
name|void
name|QUnixSocket
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
name|ConnectedState
operator|!=
name|state
argument_list|()
condition|)
return|return;
name|d
operator|->
name|state
operator|=
name|ClosingState
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|writeQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|closingTimer
operator|=
name|d
operator|->
name|startTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Start a timer to "fake"
comment|// completing writes
block|}
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     This function writes as much as possible from the internal write buffer to     the underlying socket, without blocking. If any data was written, this     function returns true; otherwise false is returned. */
end_comment
begin_comment
comment|// Note! docs partially copied from QAbstractSocket::flush()
end_comment
begin_function
DECL|function|flush
name|bool
name|QUnixSocket
operator|::
name|flush
parameter_list|()
block|{
comment|// This needs to have the same semantics as QAbstractSocket, if it is to
comment|// be used interchangeably with that class.
if|if
condition|(
name|d
operator|->
name|writeQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|writeActivated
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the last error to have occurred on this object.  This method is not   destructive, so multiple calls to QUnixSocket::error() will return the same   value.  The error is only reset by a call to \l QUnixSocket::connect() or   \l QUnixSocket::abort()   */
end_comment
begin_function
DECL|function|error
name|QUnixSocket
operator|::
name|SocketError
name|QUnixSocket
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
call|(
name|QUnixSocket
operator|::
name|SocketError
call|)
argument_list|(
name|d
operator|->
name|error
operator|&
operator|~
name|QUnixSocketPrivate
operator|::
name|CausedAbort
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the connection state of this instance.   */
end_comment
begin_function
DECL|function|state
name|QUnixSocket
operator|::
name|SocketState
name|QUnixSocket
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the Unix path address passed to \l QUnixSocket::connect().  This   method will return an empty path if the object is in the Unconnected   \l {QUnixSocket::state()}{state } or was connected through a call   to \l QUnixSocket::setSocketDescriptor()    \sa QUnixSocket::connect() QUnixSocket::setSocketDescriptor()   */
end_comment
begin_function
DECL|function|address
name|QByteArray
name|QUnixSocket
operator|::
name|address
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|address
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the number of bytes available for immediate retrieval through a call   to \l QUnixSocket::read().   */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QUnixSocket
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
return|return
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
operator|+
name|d
operator|->
name|dataBufferLength
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the number of enqueued bytes still to be written to the socket.   */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QUnixSocket
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|writeQueueBytes
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the size of the read buffer in bytes.  The read buffer size   determines the amount of byte data that can be read from the socket in one go.   The read buffer size caps the maximum value that can be returned by   \l QUnixSocket::bytesAvailable() and will always be greater than zero.  By   default, the read buffer size is 1024 bytes.    The size of the read buffer is independent of the rights buffer, which can be   queried by \l QUnixSocket::rightsBufferSize().    \sa QUnixSocket::setReadBufferSize()   */
end_comment
begin_function
DECL|function|readBufferSize
name|qint64
name|QUnixSocket
operator|::
name|readBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|dataBufferCapacity
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a size of the socket's read buffer in bytes.    The size of the read buffer is independent of the rights buffer, which can be   set by \l QUnixSocket::setRightsBufferSize().    Attempting to reduce the buffer size while bytes are available for reading   (ie. while the buffer is in use) will fail.    \sa QUnixSocket::readBufferSize()   */
end_comment
begin_function
DECL|function|setReadBufferSize
name|void
name|QUnixSocket
operator|::
name|setReadBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|d
operator|->
name|dataBufferCapacity
operator|||
name|d
operator|->
name|dataBufferLength
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|dataBuffer
condition|)
operator|delete
index|[]
name|d
operator|->
name|dataBuffer
expr_stmt|;
name|d
operator|->
name|dataBuffer
operator|=
operator|new
name|char
index|[
name|size
index|]
expr_stmt|;
name|d
operator|->
name|dataBufferCapacity
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the size of the rights buffer in rights entries.  The rights buffer   size determines the number of rights transferences that can be received in   any message.  Unlike byte stream data which can be fragmented into many   smaller messages if the \link QUnixSocket::readBufferSize() read buffer   \endlink is not large enough to contain all the available data, rights data   is transmitted as unfragmentable datagrams.  If the rights buffer is not   large enough to contain this unfragmentable datagram, the datagram will be   truncated and rights data irretrievably lost.  If truncation occurs, the   \l QUnixSocketMessage::rightsWereTruncated() flag will be set.  By default   the rights buffer size is 0 entries - rights data cannot be received.    The size of the rights buffer is independent of the read buffer, which can be   queried by \l QUnixSocket::readBufferSize().    \sa QUnixSocket::setRightsBufferSize()   */
end_comment
begin_function
DECL|function|rightsBufferSize
name|qint64
name|QUnixSocket
operator|::
name|rightsBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|ancillaryBufferCount
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a size of the socket's rights buffer in rights entries.    The size of the rights buffer is independent of the read buffer, which can be   set by \l QUnixSocket::setReadBufferSize().    Attempting to reduce the buffer size while bytes are available for reading   (ie. while the buffer is in use) will fail.    \sa QUnixSocket::rightsBufferSize()   */
end_comment
begin_function
DECL|function|setRightsBufferSize
name|void
name|QUnixSocket
operator|::
name|setRightsBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|size
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|==
name|d
operator|->
name|ancillaryBufferCount
operator|||
name|d
operator|->
name|dataBufferLength
operator|)
operator|&&
name|d
operator|->
name|ancillaryBuffer
condition|)
return|return;
name|qint64
name|byteSize
init|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
operator|::
name|ucred
argument_list|)
argument_list|)
operator|+
name|CMSG_SPACE
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ancillaryBuffer
condition|)
operator|delete
index|[]
name|d
operator|->
name|ancillaryBuffer
expr_stmt|;
name|d
operator|->
name|ancillaryBuffer
operator|=
operator|new
name|char
index|[
name|byteSize
index|]
expr_stmt|;
name|d
operator|->
name|ancillaryBufferCount
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \overload    Writes \a socketdata to the socket.  In addition to failing if the socket   is not in the Connected state, writing will fail if \a socketdata is   \l {QUnixSocketMessage::isValid()}{invalid. }    Writes through the QUnixSocket class are asynchronous.  Rather than being   written immediately, data is enqueued and written once the application   reenters the Qt event loop and the socket becomes available for writing.   Thus, this method will only fail if the socket is not in the Connected state   - it is illegal to attempt a write on a Unconnected or Closing socket.    Applications can monitor the progress of data writes through the   \l QUnixSocket::bytesWritten() signal and \l QUnixSocket::bytesToWrite()   method.    \sa QUnixSocketMessage   */
end_comment
begin_function
DECL|function|write
name|qint64
name|QUnixSocket
operator|::
name|write
parameter_list|(
specifier|const
name|QUnixSocketMessage
modifier|&
name|socketdata
parameter_list|)
block|{
if|if
condition|(
name|ConnectedState
operator|!=
name|state
argument_list|()
operator|||
operator|!
name|socketdata
operator|.
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|socketdata
operator|.
name|d
operator|->
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|writeQueue
operator|.
name|enqueue
argument_list|(
name|socketdata
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeQueueBytes
operator|+=
name|socketdata
operator|.
name|d
operator|->
name|size
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|socketdata
operator|.
name|d
operator|->
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Return the next available message, or an empty message if none is available.    To avoid retrieving empty messages, applications should connect to the   \l QUnixSocket::readyRead() signal to be notified when new messages are   available or periodically poll the \l QUnixSocket::bytesAvailable() method.    \sa QUnixSocket::readyRead() QUnixSocket::bytesAvailable()   */
end_comment
begin_function
DECL|function|read
name|QUnixSocketMessage
name|QUnixSocket
operator|::
name|read
parameter_list|()
block|{
name|QUnixSocketMessage
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|dataBufferLength
condition|)
return|return
name|data
return|;
name|data
operator|.
name|d
operator|->
name|state
operator|=
name|QUnixSocketMessagePrivate
operator|::
name|Credential
expr_stmt|;
comment|// Bytes are easy
name|data
operator|.
name|setBytes
argument_list|(
name|QByteArray
argument_list|(
name|d
operator|->
name|dataBuffer
argument_list|,
name|d
operator|->
name|dataBufferLength
argument_list|)
argument_list|)
expr_stmt|;
comment|// Extract ancillary data
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
name|a
decl_stmt|;
operator|::
name|cmsghdr
modifier|*
name|h
init|=
operator|(
operator|::
name|cmsghdr
operator|*
operator|)
name|CMSG_FIRSTHDR
argument_list|(
operator|&
operator|(
name|d
operator|->
name|message
operator|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|SCM_CREDENTIALS
operator|==
name|h
operator|->
name|cmsg_type
condition|)
block|{
operator|::
name|ucred
modifier|*
name|cred
init|=
operator|(
operator|::
name|ucred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|(
literal|"Credentials recd: pid %lu - gid %lu - uid %lu"
argument_list|,
name|cred
operator|->
name|pid
argument_list|,
name|cred
operator|->
name|gid
argument_list|,
name|cred
operator|->
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data
operator|.
name|d
operator|->
name|pid
operator|=
name|cred
operator|->
name|pid
expr_stmt|;
name|data
operator|.
name|d
operator|->
name|gid
operator|=
name|cred
operator|->
name|gid
expr_stmt|;
name|data
operator|.
name|d
operator|->
name|uid
operator|=
name|cred
operator|->
name|uid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCM_RIGHTS
operator|==
name|h
operator|->
name|cmsg_type
condition|)
block|{
name|int
modifier|*
name|fds
init|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|int
name|numFds
init|=
operator|(
name|h
operator|->
name|cmsg_len
operator|-
name|CMSG_LEN
argument_list|(
literal|0
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|numFds
condition|;
operator|++
name|ii
control|)
block|{
name|QUnixSocketRights
name|qusr
argument_list|(
name|fds
index|[
name|ii
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|a
operator|.
name|append
argument_list|(
name|qusr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qFatal
argument_list|(
literal|"QUnixSocket: Unknown ancillary data type (%d) received."
argument_list|,
name|h
operator|->
name|cmsg_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|h
operator|=
operator|(
operator|::
name|cmsghdr
operator|*
operator|)
name|CMSG_NXTHDR
argument_list|(
operator|&
operator|(
name|d
operator|->
name|message
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|message
operator|.
name|msg_flags
operator|&
name|MSG_CTRUNC
condition|)
block|{
name|data
operator|.
name|d
operator|->
name|state
operator|=
call|(
name|QUnixSocketMessagePrivate
operator|::
name|AncillaryDataState
call|)
argument_list|(
name|QUnixSocketMessagePrivate
operator|::
name|Truncated
operator||
name|QUnixSocketMessagePrivate
operator|::
name|Credential
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|a
operator|.
name|isEmpty
argument_list|()
condition|)
name|data
operator|.
name|d
operator|->
name|rights
operator|=
name|a
expr_stmt|;
name|d
operator|->
name|dataBufferLength
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|messageValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QUnixSocket
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QUnixSocket
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|if
condition|(
name|UnconnectedState
operator|==
name|d
operator|->
name|state
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|messageValid
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Q_ASSERT
argument_list|(
operator|-
literal|1
operator|!=
name|d
operator|->
name|fd
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|msecs
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|ptrTv
init|=
literal|0
decl_stmt|;
name|QTime
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
do|do
block|{
name|fd_set
name|readset
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|d
operator|->
name|fd
argument_list|,
operator|&
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|msecs
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|ptrTv
operator|=
operator|&
name|tv
expr_stmt|;
block|}
name|int
name|rv
init|=
operator|::
name|select
argument_list|(
name|d
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ptrTv
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
literal|0
case|:
comment|// timeout
return|return
literal|false
return|;
case|case
literal|1
case|:
comment|// ok
name|d
operator|->
name|readActivated
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
default|default:
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|// error
break|break;
block|}
name|timeout
operator|=
name|msecs
operator|-
name|stopWatch
operator|.
name|elapsed
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|timeout
operator|>
literal|0
condition|)
do|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QUnixSocket
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|if
condition|(
name|UnconnectedState
operator|==
name|d
operator|->
name|state
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
operator|-
literal|1
operator|!=
name|d
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|writeQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
name|QTime
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|d
operator|->
name|fd
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|msecs
operator|<
literal|0
condition|?
literal|0
else|:
name|msecs
operator|-
name|stopWatch
operator|.
name|elapsed
argument_list|()
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|ptrTv
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|msecs
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|ptrTv
operator|=
operator|&
name|tv
expr_stmt|;
block|}
name|int
name|rv
init|=
operator|::
name|select
argument_list|(
name|d
operator|->
name|fd
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|fdwrite
argument_list|,
literal|0
argument_list|,
name|ptrTv
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
literal|0
case|:
comment|// timeout
return|return
literal|false
return|;
case|case
literal|1
case|:
block|{
comment|// ok to write
name|qint64
name|bytesWritten
init|=
name|d
operator|->
name|writeActivated
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesWritten
operator|==
literal|0
condition|)
block|{
comment|// We need to retry
name|int
name|delay
init|=
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|msecs
condition|)
block|{
name|timeout
operator|=
name|msecs
operator|-
name|stopWatch
operator|.
name|elapsed
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
comment|// We have exceeded our allotted time
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|delay
operator|>
name|timeout
condition|)
name|delay
operator|=
name|timeout
expr_stmt|;
block|}
block|}
comment|// Pause before we make another attempt to send
operator|::
name|usleep
argument_list|(
name|delay
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|1024
condition|)
name|delay
operator|*=
literal|2
expr_stmt|;
name|bytesWritten
operator|=
name|d
operator|->
name|writeActivated
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|bytesWritten
operator|==
literal|0
condition|)
do|;
block|}
return|return
operator|(
name|bytesWritten
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
default|default:
comment|// error - or an uncaught signal!!!!!!!!!
if|if
condition|(
name|rv
operator|==
name|EINTR
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
comment|// fix warnings
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QUnixSocket
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
for|for
control|(
name|unsigned
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|d
operator|->
name|dataBufferLength
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|d
operator|->
name|dataBuffer
index|[
name|ii
index|]
operator|==
literal|'\n'
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QUnixSocket
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|maxSize
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|dataBufferLength
condition|)
return|return
literal|0
return|;
comment|// Read data
name|unsigned
name|int
name|size
init|=
name|d
operator|->
name|dataBufferLength
operator|>
name|maxSize
condition|?
name|maxSize
else|:
name|d
operator|->
name|dataBufferLength
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|d
operator|->
name|dataBuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|d
operator|->
name|dataBufferLength
condition|)
block|{
name|d
operator|->
name|dataBufferLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|d
operator|->
name|dataBuffer
argument_list|,
name|d
operator|->
name|dataBuffer
operator|+
name|size
argument_list|,
name|d
operator|->
name|dataBufferLength
operator|-
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|dataBufferLength
operator|-=
name|size
expr_stmt|;
block|}
comment|// Flush ancillary
name|d
operator|->
name|flushAncillary
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|d
operator|->
name|dataBufferLength
condition|)
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QUnixSocket
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
return|return
name|write
argument_list|(
name|QUnixSocketMessage
argument_list|(
name|QByteArray
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|writeActivated
name|qint64
name|QUnixSocketPrivate
operator|::
name|writeActivated
parameter_list|()
block|{
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QUnixSocketMessage
modifier|&
name|m
init|=
name|writeQueue
operator|.
name|head
argument_list|()
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
modifier|&
name|a
init|=
name|m
operator|.
name|rights
argument_list|()
decl_stmt|;
comment|//
comment|// Construct the message
comment|//
operator|::
name|iovec
name|vec
decl_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|d
operator|->
name|vec
condition|)
comment|// message does not already have an iovec
block|{
name|vec
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|m
operator|.
name|bytes
argument_list|()
operator|.
name|constData
argument_list|()
expr_stmt|;
name|vec
operator|.
name|iov_len
operator|=
name|m
operator|.
name|bytes
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Allocate the control buffer
operator|::
name|msghdr
name|sendmessage
decl_stmt|;
operator|::
name|bzero
argument_list|(
operator|&
name|sendmessage
argument_list|,
sizeof|sizeof
argument_list|(
operator|::
name|msghdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|d
operator|->
name|vec
condition|)
block|{
name|sendmessage
operator|.
name|msg_iov
operator|=
name|m
operator|.
name|d
operator|->
name|vec
expr_stmt|;
name|sendmessage
operator|.
name|msg_iovlen
operator|=
name|m
operator|.
name|d
operator|->
name|iovecLen
expr_stmt|;
block|}
else|else
block|{
name|sendmessage
operator|.
name|msg_iov
operator|=
operator|&
name|vec
expr_stmt|;
name|sendmessage
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
block|}
name|unsigned
name|int
name|required
init|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
operator|::
name|ucred
argument_list|)
argument_list|)
operator|+
name|a
operator|.
name|size
argument_list|()
operator|*
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|sendmessage
operator|.
name|msg_control
operator|=
operator|new
name|char
index|[
name|required
index|]
expr_stmt|;
operator|::
name|bzero
argument_list|(
name|sendmessage
operator|.
name|msg_control
argument_list|,
name|required
argument_list|)
expr_stmt|;
name|sendmessage
operator|.
name|msg_controllen
operator|=
name|required
expr_stmt|;
comment|// Create ancillary buffer
operator|::
name|cmsghdr
modifier|*
name|h
init|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|sendmessage
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|d
operator|->
name|state
operator|&
name|QUnixSocketMessagePrivate
operator|::
name|Credential
condition|)
block|{
name|h
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
operator|::
name|ucred
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|h
operator|->
name|cmsg_type
operator|=
name|SCM_CREDENTIALS
expr_stmt|;
operator|(
operator|(
operator|::
name|ucred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
operator|)
operator|->
name|pid
operator|=
name|m
operator|.
name|d
operator|->
name|pid
expr_stmt|;
operator|(
operator|(
operator|::
name|ucred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
operator|)
operator|->
name|gid
operator|=
name|m
operator|.
name|d
operator|->
name|gid
expr_stmt|;
operator|(
operator|(
operator|::
name|ucred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
operator|)
operator|->
name|uid
operator|=
name|m
operator|.
name|d
operator|->
name|uid
expr_stmt|;
name|h
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|sendmessage
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendmessage
operator|.
name|msg_controllen
operator|-=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
operator|::
name|ucred
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|a
operator|.
name|count
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
specifier|const
name|QUnixSocketRights
modifier|&
name|r
init|=
name|a
operator|.
name|at
argument_list|(
name|ii
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|h
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|h
operator|->
name|cmsg_type
operator|=
name|SCM_RIGHTS
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|h
argument_list|)
operator|)
operator|=
name|r
operator|.
name|peekFd
argument_list|()
expr_stmt|;
name|h
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|sendmessage
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendmessage
operator|.
name|msg_controllen
operator|-=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Transmitting message (length"
operator|<<
name|m
operator|.
name|d
operator|->
name|size
argument_list|()
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
operator|::
name|ssize_t
name|s
init|=
operator|::
name|sendmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|sendmessage
argument_list|,
name|MSG_DONTWAIT
operator||
name|MSG_NOSIGNAL
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Transmitted message ("
operator|<<
name|s
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
literal|1
operator|==
name|s
condition|)
block|{
if|if
condition|(
name|EAGAIN
operator|==
name|errno
operator|||
name|EWOULDBLOCK
operator|==
name|errno
operator|||
name|EINTR
operator|==
name|errno
condition|)
block|{
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EPIPE
operator|==
name|errno
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Remote side disconnected during transmit "
literal|"("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to transmit data ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
call|(
name|QUnixSocket
operator|::
name|SocketError
call|)
argument_list|(
name|QUnixSocket
operator|::
name|WriteFailure
operator||
name|CausedAbort
argument_list|)
expr_stmt|;
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
name|m
operator|.
name|d
operator|->
name|size
argument_list|()
condition|)
block|{
comment|// A partial transmission
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|delete
index|[]
operator|(
name|char
operator|*
operator|)
name|sendmessage
operator|.
name|msg_control
expr_stmt|;
name|m
operator|.
name|d
operator|->
name|rights
operator|=
name|QList
argument_list|<
name|QUnixSocketRights
argument_list|>
argument_list|()
expr_stmt|;
name|m
operator|.
name|d
operator|->
name|removeBytes
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|writeQueueBytes
operator|-=
name|s
expr_stmt|;
emit|emit
name|bytesWritten
argument_list|(
name|s
argument_list|)
emit|;
return|return
name|s
return|;
block|}
else|else
block|{
comment|// Success!
name|writeQueue
operator|.
name|dequeue
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|writeQueueBytes
operator|>=
operator|(
name|unsigned
operator|)
name|s
argument_list|)
expr_stmt|;
name|writeQueueBytes
operator|-=
name|s
expr_stmt|;
emit|emit
name|bytesWritten
argument_list|(
name|s
argument_list|)
emit|;
block|}
operator|delete
index|[]
operator|(
name|char
operator|*
operator|)
name|sendmessage
operator|.
name|msg_control
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|s
operator|&&
operator|!
name|writeQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|writeActivated
argument_list|()
return|;
elseif|else
if|if
condition|(
name|QUnixSocket
operator|::
name|ClosingState
operator|==
name|me
operator|->
name|state
argument_list|()
operator|&&
name|writeQueue
operator|.
name|isEmpty
argument_list|()
condition|)
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|-
literal|1
operator|==
name|s
operator|)
operator|&&
operator|(
name|EAGAIN
operator|==
name|errno
operator|||
name|EWOULDBLOCK
operator|==
name|errno
operator|||
name|EINTR
operator|==
name|errno
operator|)
condition|)
comment|// Return zero bytes written to indicate retry may be required
return|return
literal|0
return|;
else|else
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|readActivated
name|void
name|QUnixSocketPrivate
operator|::
name|readActivated
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: readActivated"
expr_stmt|;
endif|#
directive|endif
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
operator|::
name|iovec
name|vec
decl_stmt|;
name|vec
operator|.
name|iov_base
operator|=
name|dataBuffer
expr_stmt|;
name|vec
operator|.
name|iov_len
operator|=
name|dataBufferCapacity
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|message
argument_list|,
sizeof|sizeof
argument_list|(
operator|::
name|msghdr
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|msg_iov
operator|=
operator|&
name|vec
expr_stmt|;
name|message
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|message
operator|.
name|msg_controllen
operator|=
name|ancillaryBufferCapacity
argument_list|()
expr_stmt|;
name|message
operator|.
name|msg_control
operator|=
name|ancillaryBuffer
expr_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_CMSG_CLOEXEC
name|flags
operator|=
name|MSG_CMSG_CLOEXEC
expr_stmt|;
endif|#
directive|endif
name|int
name|recvrv
init|=
operator|::
name|recvmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|message
argument_list|,
name|flags
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Received message ("
operator|<<
name|recvrv
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
literal|1
operator|==
name|recvrv
condition|)
block|{
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: Unable to receive data ("
operator|<<
operator|::
name|strerror
argument_list|(
name|errno
argument_list|)
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
call|(
name|QUnixSocket
operator|::
name|SocketError
call|)
argument_list|(
name|QUnixSocket
operator|::
name|ReadFailure
operator||
name|CausedAbort
argument_list|)
expr_stmt|;
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|recvrv
condition|)
block|{
name|me
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|recvrv
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|(
name|unsigned
operator|)
name|recvrv
operator|<=
name|dataBufferCapacity
argument_list|)
expr_stmt|;
name|dataBufferLength
operator|=
name|recvrv
expr_stmt|;
name|messageValid
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|QUNIXSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QUnixSocket: readyRead() "
operator|<<
name|dataBufferLength
expr_stmt|;
endif|#
directive|endif
emit|emit
name|readyRead
argument_list|()
emit|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qunixsocket.moc"
end_include
end_unit
