begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qscreenqnx_qws.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<gf/gf.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// This struct holds all the pointers to QNX's internals
end_comment
begin_struct
DECL|struct|QQnxScreenContext
struct|struct
name|QQnxScreenContext
block|{
DECL|function|QQnxScreenContext
specifier|inline
name|QQnxScreenContext
parameter_list|()
member_init_list|:
name|device
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|display
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|layer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hwSurface
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|memSurface
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|context
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|device
name|gf_dev_t
name|device
decl_stmt|;
DECL|member|deviceInfo
name|gf_dev_info_t
name|deviceInfo
decl_stmt|;
DECL|member|display
name|gf_display_t
name|display
decl_stmt|;
DECL|member|displayInfo
name|gf_display_info_t
name|displayInfo
decl_stmt|;
DECL|member|layer
name|gf_layer_t
name|layer
decl_stmt|;
DECL|member|hwSurface
name|gf_surface_t
name|hwSurface
decl_stmt|;
DECL|member|memSurface
name|gf_surface_t
name|memSurface
decl_stmt|;
DECL|member|memSurfaceInfo
name|gf_surface_info_t
name|memSurfaceInfo
decl_stmt|;
DECL|member|context
name|gf_context_t
name|context
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     \class QQnxScreen     \preliminary     \ingroup qws     \since 4.6     \internal      \brief The QQnxScreen class implements a screen driver     for QNX io-display based devices.      Note - you never have to instanciate this class, the QScreenDriverFactory     does that for us based on the \c{QWS_DISPLAY} environment variable.      To activate this driver, set \c{QWS_DISPLAY} to \c{qnx}.      Example:     \c{QWS_DISPLAY=qnx; export QWS_DISPLAY}      By default, the main layer of the first display of the first device is used.     If you have multiple graphic cards, multiple displays or multiple layers and     don't want to connect to the default, you can override that with setting     the corresponding options \c{device}, \c{display} or \c{layer} in the \c{QWS_DISPLAY} variable:      \c{QWS_DISPLAY=qnx:device=3:display=4:layer=5}      In addition, it is suggested to set the physical width and height of the display.     QQnxScreen will use that information to compute the dots per inch (DPI) in order to render     fonts correctly. If this informaiton is omitted, QQnxScreen defaults to 72 dpi.      \c{QWS_DISPLAY=qnx:mmWidth=120:mmHeight=80}      \c{mmWidth} and \c{mmHeight} are the physical width/height of the screen in millimeters.      \sa QScreen, QScreenDriverPlugin, {Running Qt for Embedded Linux Applications}{Running Applications} */
end_comment
begin_comment
comment|/*!     Constructs a QQnxScreen object. The \a display_id argument     identifies the Qt for Embedded Linux server to connect to. */
end_comment
begin_constructor
DECL|function|QQnxScreen
name|QQnxScreen
operator|::
name|QQnxScreen
parameter_list|(
name|int
name|display_id
parameter_list|)
member_init_list|:
name|QScreen
argument_list|(
name|display_id
argument_list|)
member_init_list|,
name|d
argument_list|(
operator|new
name|QQnxScreenContext
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys this QQnxScreen object. */
end_comment
begin_destructor
DECL|function|~QQnxScreen
name|QQnxScreen
operator|::
name|~
name|QQnxScreen
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|initDevice
name|bool
name|QQnxScreen
operator|::
name|initDevice
parameter_list|()
block|{
comment|// implement this if you have multiple processes that want to access the display
comment|// (not required if QT_NO_QWS_MULTIPROCESS is set)
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Attaches to the named device \a name. */
end_comment
begin_function
DECL|function|attachDevice
specifier|static
name|bool
name|attachDevice
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
init|=
name|gf_dev_attach
argument_list|(
operator|&
name|d
operator|->
name|device
argument_list|,
name|name
argument_list|,
operator|&
name|d
operator|->
name|deviceInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_dev_attach(%s) failed with error code %d"
argument_list|,
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Attaches to the display at index \a displayIndex.  */
end_comment
begin_function
DECL|function|attachDisplay
specifier|static
name|bool
name|attachDisplay
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|,
name|int
name|displayIndex
parameter_list|)
block|{
name|int
name|ret
init|=
name|gf_display_attach
argument_list|(
operator|&
name|d
operator|->
name|display
argument_list|,
name|d
operator|->
name|device
argument_list|,
name|displayIndex
argument_list|,
operator|&
name|d
operator|->
name|displayInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_display_attach(%d) failed with error code %d"
argument_list|,
name|displayIndex
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Attaches to the layer \a layerIndex.  */
end_comment
begin_function
DECL|function|attachLayer
specifier|static
name|bool
name|attachLayer
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|,
name|int
name|layerIndex
parameter_list|)
block|{
name|int
name|ret
init|=
name|gf_layer_attach
argument_list|(
operator|&
name|d
operator|->
name|layer
argument_list|,
name|d
operator|->
name|display
argument_list|,
name|layerIndex
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_layer_attach(%d) failed with error code %d"
argument_list|,
name|layerIndex
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gf_layer_enable
argument_list|(
name|d
operator|->
name|layer
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Creates a new hardware surface (usually on the Gfx card memory) with the dimensions \a w * \a h.  */
end_comment
begin_function
DECL|function|createHwSurface
specifier|static
name|bool
name|createHwSurface
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|ret
init|=
name|gf_surface_create_layer
argument_list|(
operator|&
name|d
operator|->
name|hwSurface
argument_list|,
operator|&
name|d
operator|->
name|layer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|GF_FORMAT_ARGB8888
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_surface_create_layer(%dx%d) failed with error code %d"
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gf_layer_set_surfaces
argument_list|(
name|d
operator|->
name|layer
argument_list|,
operator|&
name|d
operator|->
name|hwSurface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gf_layer_update
argument_list|(
name|d
operator|->
name|layer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_layer_update() failed with error code %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Creates an in-memory, linear accessible surface of dimensions \a w * \a h.   This is the main surface that QWS blits to.  */
end_comment
begin_function
DECL|function|createMemSurface
specifier|static
name|bool
name|createMemSurface
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
comment|// Note: gf_surface_attach() could also be used, so we'll create the buffer
comment|// and let the surface point to it. Here, we use surface_create instead.
name|int
name|ret
init|=
name|gf_surface_create
argument_list|(
operator|&
name|d
operator|->
name|memSurface
argument_list|,
name|d
operator|->
name|device
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|GF_FORMAT_ARGB8888
argument_list|,
literal|0
argument_list|,
name|GF_SURFACE_CREATE_CPU_FAST_ACCESS
operator||
name|GF_SURFACE_CREATE_CPU_LINEAR_ACCESSIBLE
operator||
name|GF_SURFACE_PHYS_CONTIG
operator||
name|GF_SURFACE_CREATE_SHAREABLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_surface_create(%dx%d) failed with error code %d"
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|gf_surface_get_info
argument_list|(
name|d
operator|->
name|memSurface
argument_list|,
operator|&
name|d
operator|->
name|memSurfaceInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|memSurfaceInfo
operator|.
name|sid
operator|==
name|unsigned
argument_list|(
name|GF_SID_INVALID
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_surface_get_info() failed."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/* \internal    Creates a QNX gf context and sets our memory surface on it.  */
end_comment
begin_function
DECL|function|createContext
specifier|static
name|bool
name|createContext
parameter_list|(
name|QQnxScreenContext
modifier|*
specifier|const
name|d
parameter_list|)
block|{
name|int
name|ret
init|=
name|gf_context_create
argument_list|(
operator|&
name|d
operator|->
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_context_create() failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ret
operator|=
name|gf_context_set_surface
argument_list|(
name|d
operator|->
name|context
argument_list|,
name|d
operator|->
name|memSurface
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_context_set_surface() failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp   Connects to QNX's io-display based device based on the \a displaySpec parameters   from the \c{QWS_DISPLAY} environment variable. See the QQnxScreen class documentation   for possible parameters.    \sa QQnxScreen  */
end_comment
begin_function
DECL|function|connect
name|bool
name|QQnxScreen
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|displaySpec
parameter_list|)
block|{
specifier|const
name|QStringList
name|params
init|=
name|displaySpec
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|bool
name|isOk
init|=
literal|false
decl_stmt|;
name|QRegExp
name|deviceRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^device=(.+)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|indexOf
argument_list|(
name|deviceRegExp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|isOk
operator|=
name|attachDevice
argument_list|(
name|d
argument_list|,
name|deviceRegExp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no device specified - attach to device 0 (the default)
name|isOk
operator|=
name|attachDevice
argument_list|(
name|d
argument_list|,
name|GF_DEVICE_INDEX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isOk
condition|)
return|return
literal|false
return|;
name|qDebug
argument_list|(
literal|"QQnxScreen: Attached to Device, number of displays: %d"
argument_list|,
name|d
operator|->
name|deviceInfo
operator|.
name|ndisplays
argument_list|)
expr_stmt|;
comment|// default to display 0
name|int
name|displayIndex
init|=
literal|0
decl_stmt|;
name|QRegExp
name|displayRegexp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^display=(\\d+)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|indexOf
argument_list|(
name|displayRegexp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|displayIndex
operator|=
name|displayRegexp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attachDisplay
argument_list|(
name|d
argument_list|,
name|displayIndex
argument_list|)
condition|)
return|return
literal|false
return|;
name|qDebug
argument_list|(
literal|"QQnxScreen: Attached to Display %d, resolution %dx%d, refresh %d Hz"
argument_list|,
name|displayIndex
argument_list|,
name|d
operator|->
name|displayInfo
operator|.
name|xres
argument_list|,
name|d
operator|->
name|displayInfo
operator|.
name|yres
argument_list|,
name|d
operator|->
name|displayInfo
operator|.
name|refresh
argument_list|)
expr_stmt|;
comment|// default to main_layer_index from the displayInfo struct
name|int
name|layerIndex
init|=
literal|0
decl_stmt|;
name|QRegExp
name|layerRegexp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^layer=(\\d+)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|indexOf
argument_list|(
name|layerRegexp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|layerIndex
operator|=
name|layerRegexp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|layerIndex
operator|=
name|d
operator|->
name|displayInfo
operator|.
name|main_layer_index
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attachLayer
argument_list|(
name|d
argument_list|,
name|layerIndex
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// tell QWSDisplay the width and height of the display
name|w
operator|=
name|dw
operator|=
name|d
operator|->
name|displayInfo
operator|.
name|xres
expr_stmt|;
name|h
operator|=
name|dh
operator|=
name|d
operator|->
name|displayInfo
operator|.
name|yres
expr_stmt|;
comment|// we only support 32 bit displays for now.
name|QScreen
operator|::
name|d
operator|=
literal|32
expr_stmt|;
comment|// assume 72 dpi as default, to calculate the physical dimensions if not specified
specifier|const
name|int
name|defaultDpi
init|=
literal|72
decl_stmt|;
comment|// Handle display physical size spec.
name|QRegExp
name|mmWidthRegexp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^mmWidth=(\\d+)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|indexOf
argument_list|(
name|mmWidthRegexp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|physWidth
operator|=
name|qRound
argument_list|(
name|dw
operator|*
literal|25.4
operator|/
name|defaultDpi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|physWidth
operator|=
name|mmWidthRegexp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|QRegExp
name|mmHeightRegexp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^mmHeight=(\\d+)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|indexOf
argument_list|(
name|mmHeightRegexp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|physHeight
operator|=
name|qRound
argument_list|(
name|dh
operator|*
literal|25.4
operator|/
name|defaultDpi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|physHeight
operator|=
name|mmHeightRegexp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
comment|// create a hardware surface with our dimensions. In the old days, it was possible
comment|// to get a pointer directly to the hw surface, so we could blit directly. Now, we
comment|// have to use one indirection more, because it's not guaranteed that the hw surface
comment|// is mappable into our process.
if|if
condition|(
operator|!
name|createHwSurface
argument_list|(
name|d
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// create an in-memory linear surface that is used by QWS. QWS will blit directly in here.
if|if
condition|(
operator|!
name|createMemSurface
argument_list|(
name|d
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// set the address of the in-memory buffer that QWS is blitting to
name|data
operator|=
name|d
operator|->
name|memSurfaceInfo
operator|.
name|vaddr
expr_stmt|;
comment|// set the line stepping
name|lstep
operator|=
name|d
operator|->
name|memSurfaceInfo
operator|.
name|stride
expr_stmt|;
comment|// the overall size of the in-memory buffer is linestep * height
name|size
operator|=
name|mapsize
operator|=
name|lstep
operator|*
name|h
expr_stmt|;
comment|// create a QNX drawing context
if|if
condition|(
operator|!
name|createContext
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// we're always using a software cursor for now. Initialize it here.
name|QScreenCursor
operator|::
name|initSoftwareCursor
argument_list|()
expr_stmt|;
comment|// done, the driver should be connected to the display now.
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|disconnect
name|void
name|QQnxScreen
operator|::
name|disconnect
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|context
condition|)
name|gf_context_free
argument_list|(
name|d
operator|->
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|memSurface
condition|)
name|gf_surface_free
argument_list|(
name|d
operator|->
name|memSurface
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hwSurface
condition|)
name|gf_surface_free
argument_list|(
name|d
operator|->
name|hwSurface
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layer
condition|)
name|gf_layer_detach
argument_list|(
name|d
operator|->
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|display
condition|)
name|gf_display_detach
argument_list|(
name|d
operator|->
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
name|gf_dev_detach
argument_list|(
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
name|d
operator|->
name|memSurface
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|hwSurface
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|layer
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|display
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|device
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|shutdownDevice
name|void
name|QQnxScreen
operator|::
name|shutdownDevice
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \reimp   QQnxScreen doesn't support setting the mode, use io-display instead.  */
end_comment
begin_function
DECL|function|setMode
name|void
name|QQnxScreen
operator|::
name|setMode
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: Unable to change mode, use io-display instead."
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|supportsDepth
name|bool
name|QQnxScreen
operator|::
name|supportsDepth
parameter_list|(
name|int
name|depth
parameter_list|)
specifier|const
block|{
comment|// only 32-bit for the moment
return|return
name|depth
operator|==
literal|32
return|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|exposeRegion
name|void
name|QQnxScreen
operator|::
name|exposeRegion
parameter_list|(
name|QRegion
name|r
parameter_list|,
name|int
name|changing
parameter_list|)
block|{
comment|// here is where the actual magic happens. QWS will call exposeRegion whenever
comment|// a region on the screen is dirty and needs to be updated on the actual screen.
comment|// first, call the parent implementation. The parent implementation will update
comment|// the region on our in-memory surface
name|QScreen
operator|::
name|exposeRegion
argument_list|(
name|r
argument_list|,
name|changing
argument_list|)
expr_stmt|;
comment|// now our in-memory surface should be up to date with the latest changes.
comment|// the code below copies the region from the in-memory surface to the hardware.
comment|// just get the bounding rectangle of the region. Most screen updates are rectangular
comment|// anyways. Code could be optimized to blit each and every member of the region
comment|// individually, but in real life, the speed-up is neglectable
specifier|const
name|QRect
name|br
init|=
name|r
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|br
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// ignore empty regions because gf_draw_blit2 doesn't like 0x0 dimensions
comment|// start drawing.
name|int
name|ret
init|=
name|gf_draw_begin
argument_list|(
name|d
operator|->
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_draw_begin() failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// blit the changed region from the memory surface to the hardware surface
name|ret
operator|=
name|gf_draw_blit2
argument_list|(
name|d
operator|->
name|context
argument_list|,
name|d
operator|->
name|memSurface
argument_list|,
name|d
operator|->
name|hwSurface
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|,
name|br
operator|.
name|right
argument_list|()
argument_list|,
name|br
operator|.
name|bottom
argument_list|()
argument_list|,
name|br
operator|.
name|x
argument_list|()
argument_list|,
name|br
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_draw_blit2() failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|// flush all drawing commands (in our case, a single blit)
name|ret
operator|=
name|gf_draw_flush
argument_list|(
name|d
operator|->
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GF_ERR_OK
condition|)
block|{
name|qWarning
argument_list|(
literal|"QQnxScreen: gf_draw_flush() failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|// tell QNX that we're done drawing.
name|gf_draw_end
argument_list|(
name|d
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
