begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qmouseqnx_qws.h"
end_include
begin_include
include|#
directive|include
file|"qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<sys/dcmd_input.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QQnxMouseHandler     \preliminary     \ingroup qws     \internal     \since 4.6      \brief The QQnxMouseHandler class implements a mouse driver     for the QNX \c{devi-hid} input manager.      To be able to compile this mouse handler, \l{Qt for Embedded Linux}     must be configured with the \c -qt-mouse-qnx option, see the     \l{Qt for Embedded Linux Pointer Handling}{Pointer Handling} documentation for details.      In order to use this mouse handler, the \c{devi-hid} input manager     must be set up and run with the resource manager interface (option \c{-r}).     Also, Photon must not be running.      Example invocation from command line: \c{/usr/photon/bin/devi-hid -Pr kbd mouse}     Note that after running \c{devi-hid}, you will not be able to use the local     shell anymore. It is suggested to run the command in a shell scrip, that launches     a Qt application after invocation of \c{devi-hid}.      To make \l{Qt for Embedded Linux} explicitly choose the qnx mouse     handler, set the QWS_MOUSE_PROTO environment variable to \c{qnx}. By default,     the first mouse device (\c{/dev/devi/mouse0}) is used. To override, pass a device     name as the first and only parameter, for example     \c{QWS_MOUSE_PROTO=qnx:/dev/devi/mouse1; export QWS_MOUSE_PROTO}.      \sa {Qt for Embedded Linux Pointer Handling}{Pointer Handling}, {Qt for Embedded Linux} */
comment|/*!     Constructs a mouse handler for the specified \a device, defaulting to \c{/dev/devi/mouse0}.     The \a driver parameter must be \c{"qnx"}.      Note that you should never instanciate this class, instead let QMouseDriverFactory     handle the mouse handlers.      \sa QMouseDriverFactory  */
DECL|function|QQnxMouseHandler
name|QQnxMouseHandler
operator|::
name|QQnxMouseHandler
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*driver*/
parameter_list|,
specifier|const
name|QString
modifier|&
name|device
parameter_list|)
block|{
comment|// open the mouse device with O_NONBLOCK so reading won't block when there's no data
name|mouseFD
operator|=
name|QT_OPEN
argument_list|(
name|device
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"/dev/devi/mouse0"
else|:
name|device
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|QT_OPEN_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mouseFD
operator|==
operator|-
literal|1
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|errno
argument_list|,
literal|"QQnxMouseHandler: Unable to open mouse device"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// register a socket notifier on the file descriptor so we'll wake up whenever
comment|// there's a mouse move waiting for us.
name|mouseNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|mouseFD
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|mouseNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketActivated
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"QQnxMouseHandler: connected."
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys this mouse handler and closes the connection to the mouse device.  */
end_comment
begin_destructor
DECL|function|~QQnxMouseHandler
name|QQnxMouseHandler
operator|::
name|~
name|QQnxMouseHandler
parameter_list|()
block|{
name|QT_CLOSE
argument_list|(
name|mouseFD
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|resume
name|void
name|QQnxMouseHandler
operator|::
name|resume
parameter_list|()
block|{
if|if
condition|(
name|mouseNotifier
condition|)
name|mouseNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|suspend
name|void
name|QQnxMouseHandler
operator|::
name|suspend
parameter_list|()
block|{
if|if
condition|(
name|mouseNotifier
condition|)
name|mouseNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal    This function is called whenever there is activity on the mouse device.   By default, it reads up to 10 mouse move packets and calls mouseChanged()   for each of them. */
end_comment
begin_function
DECL|function|socketActivated
name|void
name|QQnxMouseHandler
operator|::
name|socketActivated
parameter_list|()
block|{
comment|// _mouse_packet is a QNX structure. devi-hid is nice enough to translate
comment|// the raw byte data from mouse devices into generic format for us.
name|_mouse_packet
name|packet
decl_stmt|;
name|int
name|iteration
init|=
literal|0
decl_stmt|;
comment|// read mouse events in batches of 10. Since we're getting quite a lot
comment|// of mouse events, it's better to do them in batches than to return to the
comment|// event loop every time.
do|do
block|{
name|int
name|bytesRead
init|=
name|QT_READ
argument_list|(
name|mouseFD
argument_list|,
operator|&
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|==
operator|-
literal|1
condition|)
block|{
comment|// EAGAIN means that there are no more mouse events to read
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
name|qErrnoWarning
argument_list|(
name|errno
argument_list|,
literal|"QQnxMouseHandler: Unable to read from socket"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// bytes read should always be equal to the size of a packet.
name|Q_ASSERT
argument_list|(
name|bytesRead
operator|==
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|// translate the coordinates from the QNX data structure to Qt coordinates
comment|// note the swapped y axis
name|QPoint
name|pos
init|=
name|mousePos
decl_stmt|;
name|pos
operator|+=
name|QPoint
argument_list|(
name|packet
operator|.
name|dx
argument_list|,
operator|-
name|packet
operator|.
name|dy
argument_list|)
expr_stmt|;
comment|// QNX only tells us relative mouse movements, not absolute ones, so limit the
comment|// cursor position manually to the screen
name|limitToScreen
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// translate the QNX mouse button bitmask to Qt buttons
name|int
name|buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
if|if
condition|(
name|packet
operator|.
name|hdr
operator|.
name|buttons
operator|&
name|_POINTER_BUTTON_LEFT
condition|)
name|buttons
operator||=
name|Qt
operator|::
name|LeftButton
expr_stmt|;
if|if
condition|(
name|packet
operator|.
name|hdr
operator|.
name|buttons
operator|&
name|_POINTER_BUTTON_MIDDLE
condition|)
name|buttons
operator||=
name|Qt
operator|::
name|MidButton
expr_stmt|;
if|if
condition|(
name|packet
operator|.
name|hdr
operator|.
name|buttons
operator|&
name|_POINTER_BUTTON_RIGHT
condition|)
name|buttons
operator||=
name|Qt
operator|::
name|RightButton
expr_stmt|;
comment|// call mouseChanged() - this does all the magic to actually move the on-screen
comment|// mouse cursor.
name|mouseChanged
argument_list|(
name|pos
argument_list|,
name|buttons
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|iteration
operator|<
literal|11
condition|)
do|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
