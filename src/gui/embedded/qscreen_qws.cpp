begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qscreen_qws.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qscreendriverfactory_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsystem_qws.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qcolor.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qwsdisplay_qws.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwindowsurface_qws_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpainter_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicssystem_qws_p.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// #define QT_USE_MEMCPY_DUFF
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
DECL|variable|qt_screencursor
name|Q_GUI_EXPORT
name|QScreenCursor
modifier|*
name|qt_screencursor
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_screen
name|Q_GUI_EXPORT
name|QScreen
modifier|*
name|qt_screen
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|clearCacheFunc
name|ClearCacheFunc
name|QScreen
operator|::
name|clearCacheFunc
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
end_ifndef
begin_comment
comment|/*!     \class QScreenCursor     \ingroup qws      \brief The QScreenCursor class is a base class for screen cursors     in Qt for Embedded Linux.      Note that this class is non-portable, and that it is only     available in \l{Qt for Embedded Linux}.      QScreenCursor implements a software cursor, but can be subclassed     to support hardware cursors as well. When deriving from the     QScreenCursor class it is important to maintain the cursor's     image, position, hot spot (the point within the cursor's image     that will be the position of the associated mouse events) and     visibility as well as informing whether it is hardware accelerated     or not.      Note that there may only be one screen cursor at a time. Use the     static instance() function to retrieve a pointer to the current     screen cursor. Typically, the cursor is constructed by the QScreen     class or one of its descendants when it is initializing the     device; the QScreenCursor class should never be instantiated     explicitly.      Use the move() function to change the position of the cursor, and     the set() function to alter its image or its hot spot. In     addition, you can find out whether the cursor is accelerated or     not, using the isAccelerated() function, and the boundingRect()     function returns the cursor's bounding rectangle.      The cursor's appearance can be controlled using the isVisible(),     hide() and show() functions; alternatively the QWSServer class     provides some means of controlling the cursor's appearance using     the QWSServer::isCursorVisible() and QWSServer::setCursorVisible()     functions.      \sa QScreen, QWSServer */
end_comment
begin_comment
comment|/*!     \fn static QScreenCursor* QScreenCursor::instance()     \since 4.2      Returns a pointer to the application's unique screen cursor. */
end_comment
begin_comment
comment|/*!     Constructs a screen cursor */
end_comment
begin_constructor
DECL|function|QScreenCursor
name|QScreenCursor
operator|::
name|QScreenCursor
parameter_list|()
block|{
name|pos
operator|=
name|QPoint
argument_list|(
name|qt_screen
operator|->
name|deviceWidth
argument_list|()
operator|/
literal|2
argument_list|,
name|qt_screen
operator|->
name|deviceHeight
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|size
operator|=
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable
operator|=
literal|true
expr_stmt|;
name|hwaccel
operator|=
literal|false
expr_stmt|;
name|supportsAlpha
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the screen cursor. */
end_comment
begin_destructor
DECL|function|~QScreenCursor
name|QScreenCursor
operator|::
name|~
name|QScreenCursor
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Hides the cursor from the screen.      \sa show() */
end_comment
begin_function
DECL|function|hide
name|void
name|QScreenCursor
operator|::
name|hide
parameter_list|()
block|{
if|if
condition|(
name|enable
condition|)
block|{
name|enable
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|hwaccel
condition|)
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|boundingRect
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Shows the mouse cursor.      \sa hide() */
end_comment
begin_function
DECL|function|show
name|void
name|QScreenCursor
operator|::
name|show
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
name|enable
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|hwaccel
condition|)
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|boundingRect
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the cursor's image to be the given \a image.      The \a hotx and \a hoty parameters define the cursor's hot spot,     i.e., the point within the cursor's image that will be the     position of the associated mouse events.      \sa move() */
end_comment
begin_function
DECL|function|set
name|void
name|QScreenCursor
operator|::
name|set
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|int
name|hotx
parameter_list|,
name|int
name|hoty
parameter_list|)
block|{
specifier|const
name|QRect
name|r
init|=
name|boundingRect
argument_list|()
decl_stmt|;
name|hotspot
operator|=
name|QPoint
argument_list|(
name|hotx
argument_list|,
name|hoty
argument_list|)
expr_stmt|;
comment|// These are in almost all cases the fastest formats to blend
name|QImage
operator|::
name|Format
name|f
decl_stmt|;
switch|switch
condition|(
name|qt_screen
operator|->
name|depth
argument_list|()
condition|)
block|{
case|case
literal|12
case|:
name|f
operator|=
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|f
operator|=
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|f
operator|=
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|f
operator|=
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
expr_stmt|;
break|break;
default|default:
name|f
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
block|}
name|cursor
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|size
operator|=
name|image
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|enable
operator|&&
operator|!
name|hwaccel
condition|)
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|r
operator||
name|boundingRect
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the mouse cursor to the given position, i.e., (\a x, \a y).      Note that the given position defines the top-left corner of the     cursor's image, i.e., not the cursor's hot spot (the position of     the associated mouse events).      \sa set() */
end_comment
begin_function
DECL|function|move
name|void
name|QScreenCursor
operator|::
name|move
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|QRegion
name|r
init|=
name|boundingRect
argument_list|()
decl_stmt|;
name|pos
operator|=
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|&&
operator|!
name|hwaccel
condition|)
block|{
name|r
operator||=
name|boundingRect
argument_list|()
expr_stmt|;
name|qt_screen
operator|->
name|exposeRegion
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QScreenCursor::initSoftwareCursor ()      Initializes the screen cursor.      This function is typically called from the screen driver when     initializing the device. Alternatively, the cursor can be set     directly using the pointer returned by the static instance()     function.      \sa QScreen::initDevice() */
end_comment
begin_function
DECL|function|initSoftwareCursor
name|void
name|QScreenCursor
operator|::
name|initSoftwareCursor
parameter_list|()
block|{
name|qt_screencursor
operator|=
operator|new
name|QScreenCursor
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_CURSOR
end_comment
begin_comment
comment|/*!     \fn QRect QScreenCursor::boundingRect () const      Returns the cursor's bounding rectangle. */
end_comment
begin_comment
comment|/*!     \internal     \fn bool QScreenCursor::enabled () */
end_comment
begin_comment
comment|/*!     \fn QImage QScreenCursor::image () const      Returns the cursor's image. */
end_comment
begin_comment
comment|/*!     \fn bool QScreenCursor::isAccelerated () const      Returns true if the cursor is accelerated; otherwise false. */
end_comment
begin_comment
comment|/*!     \fn bool QScreenCursor::isVisible () const      Returns true if the cursor is visible; otherwise false. */
end_comment
begin_comment
comment|/*!     \internal     \fn bool QScreenCursor::supportsAlphaCursor () const */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::cursor      \brief the cursor's image.      \sa image() */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::size      \brief the cursor's size */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::pos      \brief the cursor's position, i.e., the position of the top-left     corner of the crsor's image      \sa set(), move() */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::hotspot      \brief the cursor's hotspot, i.e., the point within the cursor's     image that will be the position of the associated mouse events.      \sa set(), move() */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::enable      \brief whether the cursor is visible or not      \sa isVisible() */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::hwaccel      \brief holds whether the cursor is accelerated or not      If the cursor is not accelerated, its image will be included by     the screen when it composites the window surfaces.      \sa isAccelerated()  */
end_comment
begin_comment
comment|/*     \variable QScreenCursor::supportsAlpha */
end_comment
begin_comment
comment|/*!     \internal     \macro qt_screencursor     \relates QScreenCursor      A global pointer referring to the unique screen cursor. It is     equivalent to the pointer returned by the     QScreenCursor::instance() function. */
end_comment
begin_class
DECL|class|QScreenPrivate
class|class
name|QScreenPrivate
block|{
public|public:
name|QScreenPrivate
parameter_list|(
name|QScreen
modifier|*
name|parent
parameter_list|,
name|QScreen
operator|::
name|ClassId
name|id
init|=
name|QScreen
operator|::
name|CustomClass
parameter_list|)
constructor_decl|;
name|~
name|QScreenPrivate
parameter_list|()
destructor_decl|;
specifier|inline
name|QImage
operator|::
name|Format
name|preferredImageFormat
parameter_list|()
specifier|const
function_decl|;
DECL|typedef|SolidFillFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|SolidFillFunc
function_decl|)
parameter_list|(
name|QScreen
modifier|*
parameter_list|,
specifier|const
name|QColor
modifier|&
parameter_list|,
specifier|const
name|QRegion
modifier|&
parameter_list|)
function_decl|;
DECL|typedef|BlitFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|BlitFunc
function_decl|)
parameter_list|(
name|QScreen
modifier|*
parameter_list|,
specifier|const
name|QImage
modifier|&
parameter_list|,
specifier|const
name|QPoint
modifier|&
parameter_list|,
specifier|const
name|QRegion
modifier|&
parameter_list|)
function_decl|;
DECL|member|solidFill
name|SolidFillFunc
name|solidFill
decl_stmt|;
DECL|member|blit
name|BlitFunc
name|blit
decl_stmt|;
DECL|member|offset
name|QPoint
name|offset
decl_stmt|;
DECL|member|subScreens
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|subScreens
decl_stmt|;
DECL|member|pixmapFactory
name|QPixmapDataFactory
modifier|*
name|pixmapFactory
decl_stmt|;
DECL|member|graphicsSystem
name|QGraphicsSystem
modifier|*
name|graphicsSystem
decl_stmt|;
DECL|member|defaultGraphicsSystem
name|QWSGraphicsSystem
name|defaultGraphicsSystem
decl_stmt|;
comment|//###
DECL|member|pixelFormat
name|QImage
operator|::
name|Format
name|pixelFormat
decl_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
DECL|member|fb_is_littleEndian
name|bool
name|fb_is_littleEndian
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
DECL|member|supportsBlitInClients
name|bool
name|supportsBlitInClients
decl_stmt|;
endif|#
directive|endif
DECL|member|classId
name|int
name|classId
decl_stmt|;
DECL|member|q_ptr
name|QScreen
modifier|*
name|q_ptr
decl_stmt|;
block|}
class|;
end_class
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|solidFill_template
specifier|static
name|void
name|solidFill_template
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|T
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|T
name|c
init|=
name|qt_colorConvert
argument_list|<
name|T
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|int
name|stride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_rectfill
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
end_ifdef
begin_function
DECL|function|solidFill_rgb_32bpp
specifier|static
name|void
name|solidFill_rgb_32bpp
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|quint32
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|quint32
name|c
init|=
name|qt_convertToRgb
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|stride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_rectfill
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|solidFill_rgb_16bpp
specifier|static
name|void
name|solidFill_rgb_16bpp
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|quint16
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|quint16
name|c
init|=
name|qt_convertToRgb
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|stride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_rectfill
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_GENERIC
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_4
end_ifdef
begin_function
DECL|function|qt_rectfill_gray4
specifier|static
specifier|inline
name|void
name|qt_rectfill_gray4
parameter_list|(
name|quint8
modifier|*
name|dest
parameter_list|,
name|quint8
name|value
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
specifier|const
name|int
name|pixelsPerByte
init|=
literal|2
decl_stmt|;
name|dest
operator|+=
name|y
operator|*
name|stride
operator|+
name|x
operator|/
name|pixelsPerByte
expr_stmt|;
specifier|const
name|int
name|doAlign
init|=
name|x
operator|&
literal|1
decl_stmt|;
specifier|const
name|int
name|doTail
init|=
operator|(
name|width
operator|-
name|doAlign
operator|)
operator|&
literal|1
decl_stmt|;
specifier|const
name|int
name|width8
init|=
operator|(
name|width
operator|-
name|doAlign
operator|)
operator|/
name|pixelsPerByte
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|doAlign
condition|)
operator|*
name|dest
operator|=
operator|(
operator|*
name|dest
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|value
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|width8
condition|)
name|qt_memfill
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|dest
operator|+
name|doAlign
argument_list|,
name|value
argument_list|,
name|width8
argument_list|)
expr_stmt|;
if|if
condition|(
name|doTail
condition|)
block|{
name|quint8
modifier|*
name|d
init|=
name|dest
operator|+
name|doAlign
operator|+
name|width8
decl_stmt|;
operator|*
name|d
operator|=
operator|(
operator|*
name|d
operator|&
literal|0x0f
operator|)
operator||
operator|(
name|value
operator|&
literal|0xf0
operator|)
expr_stmt|;
block|}
name|dest
operator|+=
name|stride
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|solidFill_gray4
specifier|static
name|void
name|solidFill_gray4
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|quint8
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|quint8
name|c
init|=
name|qGray
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
operator|>>
literal|4
decl_stmt|;
specifier|const
name|quint8
name|c8
init|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator||
name|c
decl_stmt|;
specifier|const
name|int
name|stride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_rectfill_gray4
argument_list|(
name|dest
argument_list|,
name|c8
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_4
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_1
end_ifdef
begin_function
DECL|function|qt_rectfill_mono
specifier|static
specifier|inline
name|void
name|qt_rectfill_mono
parameter_list|(
name|quint8
modifier|*
name|dest
parameter_list|,
name|quint8
name|value
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|stride
parameter_list|)
block|{
specifier|const
name|int
name|pixelsPerByte
init|=
literal|8
decl_stmt|;
specifier|const
name|int
name|alignWidth
init|=
name|qMin
argument_list|(
name|width
argument_list|,
operator|(
literal|8
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|7
argument_list|)
decl_stmt|;
specifier|const
name|int
name|doAlign
init|=
operator|(
name|alignWidth
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|int
name|alignStart
init|=
name|pixelsPerByte
operator|-
literal|1
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
decl_stmt|;
specifier|const
name|int
name|alignStop
init|=
name|alignStart
operator|-
operator|(
name|alignWidth
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|quint8
name|alignMask
init|=
operator|(
operator|(
literal|1
operator|<<
name|alignWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|alignStop
decl_stmt|;
specifier|const
name|int
name|tailWidth
init|=
operator|(
name|width
operator|-
name|alignWidth
operator|)
operator|&
literal|7
decl_stmt|;
specifier|const
name|int
name|doTail
init|=
operator|(
name|tailWidth
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|quint8
name|tailMask
init|=
operator|(
literal|1
operator|<<
operator|(
name|pixelsPerByte
operator|-
name|tailWidth
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|width8
init|=
operator|(
name|width
operator|-
name|alignWidth
operator|)
operator|/
name|pixelsPerByte
decl_stmt|;
name|dest
operator|+=
name|y
operator|*
name|stride
operator|+
name|x
operator|/
name|pixelsPerByte
expr_stmt|;
name|stride
operator|-=
operator|(
name|doAlign
operator|+
name|width8
operator|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|doAlign
condition|)
block|{
operator|*
name|dest
operator|=
operator|(
operator|*
name|dest
operator|&
operator|~
name|alignMask
operator|)
operator||
operator|(
name|value
operator|&
name|alignMask
operator|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
block|}
if|if
condition|(
name|width8
condition|)
block|{
name|qt_memfill
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|dest
argument_list|,
name|value
argument_list|,
name|width8
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|width8
expr_stmt|;
block|}
if|if
condition|(
name|doTail
condition|)
operator|*
name|dest
operator|=
operator|(
operator|*
name|dest
operator|&
name|tailMask
operator|)
operator||
operator|(
name|value
operator|&
operator|~
name|tailMask
operator|)
expr_stmt|;
name|dest
operator|+=
name|stride
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|solidFill_mono
specifier|static
name|void
name|solidFill_mono
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|quint8
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|quint8
name|c8
init|=
operator|(
name|qGray
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
operator|>>
literal|7
operator|)
operator|*
literal|0xff
decl_stmt|;
specifier|const
name|int
name|stride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_rectfill_mono
argument_list|(
name|dest
argument_list|,
name|c8
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|stride
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_1
end_comment
begin_function
DECL|function|qt_solidFill_setup
name|void
name|qt_solidFill_setup
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|screen
operator|->
name|depth
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_32
case|case
literal|32
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|quint32
argument_list|>
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qabgr8888
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_24
case|case
literal|24
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qrgb888
argument_list|>
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|quint24
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_18
case|case
literal|18
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|quint18
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
literal|16
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|quint16
argument_list|>
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qbgr565
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_15
case|case
literal|15
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qrgb555
argument_list|>
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qbgr555
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_12
case|case
literal|12
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|qrgb444
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_8
case|case
literal|8
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_template
argument_list|<
name|quint8
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_4
case|case
literal|4
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_gray4
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_1
case|case
literal|1
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_mono
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qFatal
argument_list|(
literal|"solidFill_setup(): Screen depth %d not supported!"
argument_list|,
name|screen
operator|->
name|depth
argument_list|()
argument_list|)
expr_stmt|;
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
argument_list|(
name|screen
argument_list|,
name|color
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|DST
parameter_list|,
name|typename
name|SRC
parameter_list|>
DECL|function|blit_template
specifier|static
name|void
name|blit_template
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|DST
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|DST
operator|*
argument_list|>
argument_list|(
name|screen
operator|->
name|base
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|screenStride
init|=
name|screen
operator|->
name|linestep
argument_list|()
decl_stmt|;
specifier|const
name|int
name|imageStride
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|const
name|QRect
name|r
init|=
name|region
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
specifier|const
name|SRC
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|SRC
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
operator|+
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|qt_rectconvert
argument_list|<
name|DST
argument_list|,
name|SRC
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|r
operator|.
name|x
argument_list|()
operator|+
name|topLeft
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|topLeft
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|screenStride
argument_list|,
name|imageStride
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|SRC
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|SRC
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
operator|+
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|qt_rectconvert
argument_list|<
name|DST
argument_list|,
name|SRC
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|r
operator|.
name|x
argument_list|()
operator|+
name|topLeft
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|topLeft
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|screenStride
argument_list|,
name|imageStride
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_32
end_ifdef
begin_function
DECL|function|blit_32
specifier|static
name|void
name|blit_32
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|quint32
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|quint32
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
name|qCritical
argument_list|(
literal|"blit_32(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_32
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_24
end_ifdef
begin_function
DECL|function|blit_24
specifier|static
name|void
name|blit_24
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|quint24
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|blit_template
argument_list|<
name|quint24
argument_list|,
name|qrgb888
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|quint24
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
name|qCritical
argument_list|(
literal|"blit_24(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|blit_qrgb888
specifier|static
name|void
name|blit_qrgb888
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qrgb888
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|blit_template
argument_list|<
name|qrgb888
argument_list|,
name|qrgb888
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qrgb888
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
name|qCritical
argument_list|(
literal|"blit_24(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_24
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_18
end_ifdef
begin_function
DECL|function|blit_18
specifier|static
name|void
name|blit_18
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qrgb666
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
name|blit_template
argument_list|<
name|qrgb666
argument_list|,
name|qrgb666
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qrgb666
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
name|qCritical
argument_list|(
literal|"blit_18(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_18
end_comment
begin_if
if|#
directive|if
operator|(
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|QT_QWS_DEPTH_16
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_QWS_DEPTH_15
argument_list|)
operator|)
end_if
begin_class
DECL|class|quint16LE
class|class
name|quint16LE
block|{
public|public:
DECL|function|quint16LE
specifier|inline
name|quint16LE
parameter_list|(
name|quint32
name|v
parameter_list|)
block|{
name|data
operator|=
operator|(
operator|(
name|v
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|v
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
DECL|function|quint16LE
specifier|inline
name|quint16LE
parameter_list|(
name|int
name|v
parameter_list|)
block|{
name|data
operator|=
operator|(
operator|(
name|v
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|v
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
DECL|function|quint16LE
specifier|inline
name|quint16LE
parameter_list|(
name|quint16
name|v
parameter_list|)
block|{
name|data
operator|=
operator|(
operator|(
name|v
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|v
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
DECL|function|quint16LE
specifier|inline
name|quint16LE
parameter_list|(
name|qrgb555
name|v
parameter_list|)
block|{
name|data
operator|=
operator|(
operator|(
operator|(
name|quint16
operator|)
name|v
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|quint16
operator|)
name|v
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|quint16LE
modifier|&
name|v
parameter_list|)
specifier|const
block|{
return|return
name|data
operator|==
name|v
operator|.
name|data
return|;
block|}
private|private:
DECL|member|data
name|quint16
name|data
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
end_ifdef
begin_function
DECL|function|blit_16
specifier|static
name|void
name|blit_16
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
comment|// ### This probably doesn't work but it's a case which should never happen
name|blit_template
argument_list|<
name|quint16
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|quint16
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_16(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
end_if
begin_function
DECL|function|blit_16_bigToLittleEndian
specifier|static
name|void
name|blit_16_bigToLittleEndian
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|quint16LE
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|quint16LE
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_16_bigToLittleEndian(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_BIG_ENDIAN
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_16
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_15
end_ifdef
begin_function
DECL|function|blit_15
specifier|static
name|void
name|blit_15
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qrgb555
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
name|blit_template
argument_list|<
name|qrgb555
argument_list|,
name|qrgb555
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qrgb555
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_15(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
end_if
begin_function
DECL|function|blit_15_bigToLittleEndian
specifier|static
name|void
name|blit_15_bigToLittleEndian
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
name|blit_template
argument_list|<
name|quint16LE
argument_list|,
name|qrgb555
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_15_bigToLittleEndian(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_BIG_ENDIAN
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_15
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_12
end_ifdef
begin_function
DECL|function|blit_12
specifier|static
name|void
name|blit_12
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|blit_template
argument_list|<
name|qrgb444
argument_list|,
name|qargb4444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|blit_template
argument_list|<
name|qrgb444
argument_list|,
name|qrgb444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_12(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_12
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_8
end_ifdef
begin_function
DECL|function|blit_8
specifier|static
name|void
name|blit_8
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|quint8
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|quint8
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|blit_template
argument_list|<
name|quint8
argument_list|,
name|qargb4444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|blit_template
argument_list|<
name|quint8
argument_list|,
name|qrgb444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_8(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_8
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_4
end_ifdef
begin_struct
DECL|struct|qgray4
DECL|member|dummy
DECL|variable|Q_PACKED
struct|struct
name|qgray4
block|{
name|quint8
name|dummy
decl_stmt|;
block|}
name|Q_PACKED
struct|;
end_struct
begin_function_decl
template|template
parameter_list|<
name|typename
name|SRC
parameter_list|>
name|Q_STATIC_TEMPLATE_FUNCTION
specifier|inline
name|quint8
name|qt_convertToGray4
parameter_list|(
name|SRC
name|color
parameter_list|)
function_decl|;
end_function_decl
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToGray4
specifier|inline
name|quint8
name|qt_convertToGray4
parameter_list|(
name|quint32
name|color
parameter_list|)
block|{
return|return
name|qGray
argument_list|(
name|color
argument_list|)
operator|>>
literal|4
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToGray4
specifier|inline
name|quint8
name|qt_convertToGray4
parameter_list|(
name|quint16
name|color
parameter_list|)
block|{
specifier|const
name|int
name|r
init|=
operator|(
name|color
operator|&
literal|0xf800
operator|)
operator|>>
literal|11
decl_stmt|;
specifier|const
name|int
name|g
init|=
operator|(
name|color
operator|&
literal|0x07e0
operator|)
operator|>>
literal|6
decl_stmt|;
comment|// only keep 5 bit
specifier|const
name|int
name|b
init|=
operator|(
name|color
operator|&
literal|0x001f
operator|)
decl_stmt|;
return|return
operator|(
name|r
operator|*
literal|11
operator|+
name|g
operator|*
literal|16
operator|+
name|b
operator|*
literal|5
operator|)
operator|>>
literal|6
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToGray4
specifier|inline
name|quint8
name|qt_convertToGray4
parameter_list|(
name|qrgb444
name|color
parameter_list|)
block|{
return|return
name|qt_convertToGray4
argument_list|(
name|quint32
argument_list|(
name|color
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToGray4
specifier|inline
name|quint8
name|qt_convertToGray4
parameter_list|(
name|qargb4444
name|color
parameter_list|)
block|{
return|return
name|qt_convertToGray4
argument_list|(
name|quint32
argument_list|(
name|color
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|SRC
parameter_list|>
DECL|function|qt_rectconvert_gray4
name|Q_STATIC_TEMPLATE_FUNCTION
specifier|inline
name|void
name|qt_rectconvert_gray4
parameter_list|(
name|qgray4
modifier|*
name|dest4
parameter_list|,
specifier|const
name|SRC
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
specifier|const
name|int
name|pixelsPerByte
init|=
literal|2
decl_stmt|;
name|quint8
modifier|*
name|dest8
init|=
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|dest4
argument_list|)
operator|+
name|y
operator|*
name|dstStride
operator|+
name|x
operator|/
name|pixelsPerByte
decl_stmt|;
specifier|const
name|int
name|doAlign
init|=
name|x
operator|&
literal|1
decl_stmt|;
specifier|const
name|int
name|doTail
init|=
operator|(
name|width
operator|-
name|doAlign
operator|)
operator|&
literal|1
decl_stmt|;
specifier|const
name|int
name|width8
init|=
operator|(
name|width
operator|-
name|doAlign
operator|)
operator|/
name|pixelsPerByte
decl_stmt|;
specifier|const
name|int
name|count8
init|=
operator|(
name|width8
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|srcStride
operator|=
name|srcStride
operator|/
sizeof|sizeof
argument_list|(
name|SRC
argument_list|)
operator|-
name|width
expr_stmt|;
name|dstStride
operator|-=
operator|(
name|width8
operator|+
name|doAlign
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|doAlign
condition|)
block|{
operator|*
name|dest8
operator|=
operator|(
operator|*
name|dest8
operator|&
literal|0xf0
operator|)
operator||
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
operator|++
name|dest8
expr_stmt|;
block|}
if|if
condition|(
name|count8
condition|)
block|{
name|int
name|n
init|=
name|count8
decl_stmt|;
switch|switch
condition|(
name|width8
operator|&
literal|0x03
condition|)
comment|// duff's device
block|{
case|case
literal|0
case|:
do|do
block|{
operator|*
name|dest8
operator|++
operator|=
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|dest8
operator|++
operator|=
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|dest8
operator|++
operator|=
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|dest8
operator|++
operator|=
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
block|}
block|}
if|if
condition|(
name|doTail
condition|)
operator|*
name|dest8
operator|=
name|qt_convertToGray4
argument_list|<
name|SRC
argument_list|>
argument_list|(
operator|*
name|src
operator|++
argument_list|)
operator|<<
literal|4
operator||
operator|(
operator|*
name|dest8
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|dest8
operator|+=
name|dstStride
expr_stmt|;
name|src
operator|+=
name|srcStride
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qgray4
modifier|*
name|dest
parameter_list|,
specifier|const
name|quint32
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_gray4
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qgray4
modifier|*
name|dest
parameter_list|,
specifier|const
name|quint16
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_gray4
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qgray4
modifier|*
name|dest
parameter_list|,
specifier|const
name|qrgb444
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_gray4
argument_list|<
name|qrgb444
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qgray4
modifier|*
name|dest
parameter_list|,
specifier|const
name|qargb4444
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_gray4
argument_list|<
name|qargb4444
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|blit_4
specifier|static
name|void
name|blit_4
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qgray4
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qgray4
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|blit_template
argument_list|<
name|qgray4
argument_list|,
name|qrgb444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|blit_template
argument_list|<
name|qgray4
argument_list|,
name|qargb4444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_4(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_4
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_1
end_ifdef
begin_struct
DECL|struct|qmono
DECL|member|dummy
DECL|variable|Q_PACKED
struct|struct
name|qmono
block|{
name|quint8
name|dummy
decl_stmt|;
block|}
name|Q_PACKED
struct|;
end_struct
begin_function_decl
template|template
parameter_list|<
name|typename
name|SRC
parameter_list|>
name|Q_STATIC_TEMPLATE_FUNCTION
specifier|inline
name|quint8
name|qt_convertToMono
parameter_list|(
name|SRC
name|color
parameter_list|)
function_decl|;
end_function_decl
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToMono
specifier|inline
name|quint8
name|qt_convertToMono
parameter_list|(
name|quint32
name|color
parameter_list|)
block|{
return|return
name|qGray
argument_list|(
name|color
argument_list|)
operator|>>
literal|7
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToMono
specifier|inline
name|quint8
name|qt_convertToMono
parameter_list|(
name|quint16
name|color
parameter_list|)
block|{
return|return
operator|(
name|qGray
argument_list|(
name|qt_colorConvert
argument_list|<
name|quint32
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|color
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>>
literal|7
operator|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToMono
specifier|inline
name|quint8
name|qt_convertToMono
parameter_list|(
name|qargb4444
name|color
parameter_list|)
block|{
return|return
operator|(
name|qGray
argument_list|(
name|quint32
argument_list|(
name|color
argument_list|)
argument_list|)
operator|>>
literal|7
operator|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_convertToMono
specifier|inline
name|quint8
name|qt_convertToMono
parameter_list|(
name|qrgb444
name|color
parameter_list|)
block|{
return|return
operator|(
name|qGray
argument_list|(
name|quint32
argument_list|(
name|color
argument_list|)
argument_list|)
operator|>>
literal|7
operator|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|SRC
parameter_list|>
DECL|function|qt_rectconvert_mono
specifier|inline
name|void
name|qt_rectconvert_mono
parameter_list|(
name|qmono
modifier|*
name|dest
parameter_list|,
specifier|const
name|SRC
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
specifier|const
name|int
name|pixelsPerByte
init|=
literal|8
decl_stmt|;
name|quint8
modifier|*
name|dest8
init|=
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|dest
argument_list|)
operator|+
name|y
operator|*
name|dstStride
operator|+
name|x
operator|/
name|pixelsPerByte
decl_stmt|;
specifier|const
name|int
name|alignWidth
init|=
name|qMin
argument_list|(
name|width
argument_list|,
operator|(
literal|8
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|7
argument_list|)
decl_stmt|;
specifier|const
name|int
name|doAlign
init|=
operator|(
name|alignWidth
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|int
name|alignStart
init|=
name|pixelsPerByte
operator|-
literal|1
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
decl_stmt|;
specifier|const
name|int
name|alignStop
init|=
name|alignStart
operator|-
operator|(
name|alignWidth
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|quint8
name|alignMask
init|=
operator|(
operator|(
literal|1
operator|<<
name|alignWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|alignStop
decl_stmt|;
specifier|const
name|int
name|tailWidth
init|=
operator|(
name|width
operator|-
name|alignWidth
operator|)
operator|&
literal|7
decl_stmt|;
specifier|const
name|int
name|doTail
init|=
operator|(
name|tailWidth
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|quint8
name|tailMask
init|=
operator|(
literal|1
operator|<<
operator|(
name|pixelsPerByte
operator|-
name|tailWidth
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|width8
init|=
operator|(
name|width
operator|-
name|alignWidth
operator|)
operator|/
name|pixelsPerByte
decl_stmt|;
name|srcStride
operator|=
name|srcStride
operator|/
sizeof|sizeof
argument_list|(
name|SRC
argument_list|)
operator|-
operator|(
name|width8
operator|*
literal|8
operator|+
name|alignWidth
operator|)
expr_stmt|;
name|dstStride
operator|-=
operator|(
name|width8
operator|+
name|doAlign
operator|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|doAlign
condition|)
block|{
name|quint8
name|d
init|=
operator|*
name|dest8
operator|&
operator|~
name|alignMask
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alignStart
init|;
name|i
operator|>=
name|alignStop
condition|;
operator|--
name|i
control|)
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
operator|*
name|src
operator|++
argument_list|)
operator|<<
name|i
expr_stmt|;
operator|*
name|dest8
operator|++
operator|=
name|d
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|width8
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|dest8
operator|=
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|5
index|]
argument_list|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|6
index|]
argument_list|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|7
index|]
argument_list|)
operator|)
expr_stmt|;
name|src
operator|+=
literal|8
expr_stmt|;
operator|++
name|dest8
expr_stmt|;
block|}
if|if
condition|(
name|doTail
condition|)
block|{
name|quint8
name|d
init|=
operator|*
name|dest8
operator|&
name|tailMask
decl_stmt|;
switch|switch
condition|(
name|tailWidth
condition|)
block|{
case|case
literal|7
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|6
index|]
argument_list|)
operator|<<
literal|1
expr_stmt|;
case|case
literal|6
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|5
index|]
argument_list|)
operator|<<
literal|2
expr_stmt|;
case|case
literal|5
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|4
index|]
argument_list|)
operator|<<
literal|3
expr_stmt|;
case|case
literal|4
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
case|case
literal|3
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|5
expr_stmt|;
case|case
literal|2
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|6
expr_stmt|;
case|case
literal|1
case|:
name|d
operator||=
name|qt_convertToMono
argument_list|<
name|SRC
argument_list|>
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|7
expr_stmt|;
block|}
operator|*
name|dest8
operator|=
name|d
expr_stmt|;
block|}
name|dest8
operator|+=
name|dstStride
expr_stmt|;
name|src
operator|+=
name|srcStride
expr_stmt|;
block|}
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qmono
modifier|*
name|dest
parameter_list|,
specifier|const
name|quint32
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_mono
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qmono
modifier|*
name|dest
parameter_list|,
specifier|const
name|quint16
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_mono
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qmono
modifier|*
name|dest
parameter_list|,
specifier|const
name|qrgb444
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_mono
argument_list|<
name|qrgb444
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|qt_rectconvert
name|void
name|qt_rectconvert
parameter_list|(
name|qmono
modifier|*
name|dest
parameter_list|,
specifier|const
name|qargb4444
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dstStride
parameter_list|,
name|int
name|srcStride
parameter_list|)
block|{
name|qt_rectconvert_mono
argument_list|<
name|qargb4444
argument_list|>
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstStride
argument_list|,
name|srcStride
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|blit_1
specifier|static
name|void
name|blit_1
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qmono
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qmono
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|blit_template
argument_list|<
name|qmono
argument_list|,
name|qrgb444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|blit_template
argument_list|<
name|qmono
argument_list|,
name|qargb4444
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_1(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_1
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_GENERIC
end_ifdef
begin_function
DECL|function|blit_rgb
specifier|static
name|void
name|blit_rgb
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|blit_template
argument_list|<
name|qrgb
argument_list|,
name|quint32
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|blit_template
argument_list|<
name|qrgb
argument_list|,
name|quint16
argument_list|>
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return;
default|default:
name|qCritical
argument_list|(
literal|"blit_rgb(): Image format %d not supported!"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_set_generic_blit
name|void
name|qt_set_generic_blit
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|len_red
parameter_list|,
name|int
name|len_green
parameter_list|,
name|int
name|len_blue
parameter_list|,
name|int
name|len_alpha
parameter_list|,
name|int
name|off_red
parameter_list|,
name|int
name|off_green
parameter_list|,
name|int
name|off_blue
parameter_list|,
name|int
name|off_alpha
parameter_list|)
block|{
name|qrgb
operator|::
name|bpp
operator|=
name|bpp
operator|/
literal|8
expr_stmt|;
name|qrgb
operator|::
name|len_red
operator|=
name|len_red
expr_stmt|;
name|qrgb
operator|::
name|len_green
operator|=
name|len_green
expr_stmt|;
name|qrgb
operator|::
name|len_blue
operator|=
name|len_blue
expr_stmt|;
name|qrgb
operator|::
name|len_alpha
operator|=
name|len_alpha
expr_stmt|;
name|qrgb
operator|::
name|off_red
operator|=
name|off_red
expr_stmt|;
name|qrgb
operator|::
name|off_green
operator|=
name|off_green
expr_stmt|;
name|qrgb
operator|::
name|off_blue
operator|=
name|off_blue
expr_stmt|;
name|qrgb
operator|::
name|off_alpha
operator|=
name|off_alpha
expr_stmt|;
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_rgb
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|16
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_rgb_16bpp
expr_stmt|;
elseif|else
if|if
condition|(
name|bpp
operator|==
literal|32
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|solidFill
operator|=
name|solidFill_rgb_32bpp
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QWS_DEPTH_GENERIC
end_comment
begin_function
DECL|function|qt_blit_setup
name|void
name|qt_blit_setup
parameter_list|(
name|QScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|screen
operator|->
name|depth
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_32
case|case
literal|32
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_32
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_template
argument_list|<
name|qabgr8888
argument_list|,
name|quint32
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_24
case|case
literal|24
case|:
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_qrgb888
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_24
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_18
case|case
literal|18
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_18
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
case|case
literal|16
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
if|if
condition|(
name|screen
operator|->
name|d_ptr
operator|->
name|fb_is_littleEndian
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_16_bigToLittleEndian
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_16
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_template
argument_list|<
name|qbgr565
argument_list|,
name|quint16
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_15
case|case
literal|15
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
if|if
condition|(
name|screen
operator|->
name|d_ptr
operator|->
name|fb_is_littleEndian
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_15_bigToLittleEndian
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|// Q_BIG_ENDIAN
if|if
condition|(
name|screen
operator|->
name|pixelType
argument_list|()
operator|==
name|QScreen
operator|::
name|NormalPixel
condition|)
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_15
expr_stmt|;
else|else
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_template
argument_list|<
name|qbgr555
argument_list|,
name|qrgb555
argument_list|>
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_12
case|case
literal|12
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_12
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_8
case|case
literal|8
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_8
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_4
case|case
literal|4
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_4
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_1
case|case
literal|1
case|:
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
name|blit_1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qFatal
argument_list|(
literal|"blit_setup(): Screen depth %d not supported!"
argument_list|,
name|screen
operator|->
name|depth
argument_list|()
argument_list|)
expr_stmt|;
name|screen
operator|->
name|d_ptr
operator|->
name|blit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|screen
operator|->
name|d_ptr
operator|->
name|blit
argument_list|(
name|screen
argument_list|,
name|image
argument_list|,
name|topLeft
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QScreenPrivate
name|QScreenPrivate
operator|::
name|QScreenPrivate
parameter_list|(
name|QScreen
modifier|*
name|parent
parameter_list|,
name|QScreen
operator|::
name|ClassId
name|id
parameter_list|)
member_init_list|:
name|defaultGraphicsSystem
argument_list|(
name|QWSGraphicsSystem
argument_list|(
name|parent
argument_list|)
argument_list|)
member_init_list|,
name|pixelFormat
argument_list|(
name|QImage
operator|::
name|Format_Invalid
argument_list|)
member_init_list|,
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|supportsBlitInClients
argument_list|(
literal|false
argument_list|)
member_init_list|,
endif|#
directive|endif
name|classId
argument_list|(
name|id
argument_list|)
member_init_list|,
name|q_ptr
argument_list|(
name|parent
argument_list|)
block|{
name|solidFill
operator|=
name|qt_solidFill_setup
expr_stmt|;
name|blit
operator|=
name|qt_blit_setup
expr_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
name|fb_is_littleEndian
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|pixmapFactory
operator|=
literal|0
expr_stmt|;
name|graphicsSystem
operator|=
operator|&
name|defaultGraphicsSystem
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QScreenPrivate
name|QScreenPrivate
operator|::
name|~
name|QScreenPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|preferredImageFormat
name|QImage
operator|::
name|Format
name|QScreenPrivate
operator|::
name|preferredImageFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|pixelFormat
operator|>
name|QImage
operator|::
name|Format_Indexed8
condition|)
return|return
name|pixelFormat
return|;
if|if
condition|(
name|q_ptr
operator|->
name|depth
argument_list|()
operator|<=
literal|16
condition|)
return|return
name|QImage
operator|::
name|Format_RGB16
return|;
else|else
return|return
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
return|;
block|}
end_function
begin_comment
comment|/*!     \class QScreen     \ingroup qws      \brief The QScreen class is a base class for screen drivers in     Qt for Embedded Linux.      Note that this class is only available in \l{Qt for Embedded Linux}.      \l{Qt for Embedded Linux} provides ready-made drivers for several screen     protocols, see the \l{Qt for Embedded Linux Display Management}{display     management} documentation for details. Custom screen drivers can     be implemented by subclassing the QScreen class and creating a     screen driver plugin (derived from QScreenDriverPlugin). The     default implementation of the QScreenDriverFactory class     will automatically detect the plugin, and load the driver into the     server application at run-time using Qt's \l {How to Create Qt     Plugins}{plugin system}.      When rendering, the default behavior is for each     client to render its widgets as well as its decorations into     memory, while the server copies the memory content to the device's     framebuffer using the screen driver. See the \l{Qt for Embedded Linux     Architecture} overview for details (note that it is possible for     the clients to manipulate and control the underlying hardware     directly as well).      Starting with Qt 4.2, it is also possible to add an     accelerated graphics driver to take advantage of available     hardware resources. See the \l{Adding an Accelerated Graphics     Driver to Qt for Embedded Linux} documentation for details.      \tableofcontents      \section1 Framebuffer Management      When a \l{Qt for Embedded Linux} application starts running, it     calls the screen driver's connect() function to map the     framebuffer and the accelerated drivers that the graphics card     control registers. The connect() function should then read out the     parameters of the framebuffer and use them as required to set this     class's protected variables.      The initDevice() function can be reimplemented to initialize the     graphics card. Note, however, that connect() is called \e before     the initDevice() function, so, for some hardware configurations,     some of the initialization that would normally be done in the     initDevice() function might have to be done in the connect()     function.      Likewise, just before a \l{Qt for Embedded Linux} application     exits, it calls the screen driver's disconnect() function. The     server application will in addition call the shutdownDevice()     function before it calls disconnect(). Note that the default     implementation of the shutdownDevice() function only hides the     mouse cursor.      QScreen also provides the save() and restore() functions, making     it possible to save and restore the state of the graphics     card. Note that the default implementations do nothing. Hardware     screen drivers should reimplement these functions to save (and     restore) its registers, enabling switching between virtual     consoles.      In addition, you can use the base() function to retrieve a pointer     to the beginning of the framebuffer, and the region() function to     retrieve the framebuffer's region. Use the onCard() function to     determine whether the framebuffer is within the graphics card's     memory, and the totalSize() function to determine the size of the     available graphics card memory (including the screen). Finally,     you can use the offset() function to retrieve the offset between     the framebuffer's coordinates and the application's coordinate     system.      \section1 Palette Management      QScreen provides several functions to retrieve information about     the color palette: The clut() function returns a pointer to the     color lookup table (i.e. its color palette). Use the colorCount()     function to determine the number of entries in this table, and the     alloc() function to retrieve the palette index of the color that     is the closest match to a given RGB value.      To determine if the screen driver supports a given color depth,     use the supportsDepth() function that returns true of the     specified depth is supported.      \section1 Drawing on Screen      When a screen update is required, the \l{Qt for Embedded Linux} server runs     through all the top-level windows that intersect with the region     that is about to be updated, and ensures that the associated     clients have updated their memory buffer. Then the server calls     the exposeRegion() function that composes the window surfaces and     copies the content of memory to screen by calling the blit() and     solidFill() functions.      The blit() function copies a given region in a given image to a     specified point using device coordinates, while the solidFill()     function fills the given region of the screen with the specified     color. Note that normally there is no need to call either of these     functions explicitly.      In addition, QScreen provides the blank() function that can be     reimplemented to prevent any contents from being displayed on the     screen, and the setDirty() function that can be reimplemented to     indicate that a given rectangle of the screen has been     altered. Note that the default implementations of these functions     do nothing.      Reimplement the mapFromDevice() and mapToDevice() functions to     map objects from the framebuffer coordinate system to the     coordinate space used by the application, and vice versa. Be aware     that the default implementations simply return the given objects     as they are.      \section1 Properties      \table     \header \o Property \o Functions     \row     \o Size     \o      The size of the screen can be retrieved using the screenSize()     function. The size is returned in bytes.      The framebuffer's logical width and height can be retrieved using     width() and height(), respectively. These functions return values     are given in pixels. Alternatively, the physicalWidth() and     physicalHeight() function returns the same metrics in     millimeters. QScreen also provides the deviceWidth() and     deviceHeight() functions returning the physical width and height     of the device in pixels. Note that the latter metrics can differ     from the ones used if the display is centered within the     framebuffer.      \row     \o Resolution     \o      Reimplement the setMode() function to be able to set the     framebuffer to a new resolution (width and height) and bit depth.      The current depth of the framebuffer can be always be retrieved     using the depth() function. Use the pixmapDepth() function to     obtain the preferred depth for pixmaps.      \row     \o Pixmap Alignment     \o      Use the pixmapOffsetAlignment() function to retrieve the value to     which the start address of pixmaps held in the graphics card's     memory, should be aligned.      Use the pixmapLinestepAlignment() to retrieve the value to which     the \e {individual scanlines} of pixmaps should be aligned.      \row     \o Image Display     \o      The isInterlaced() function tells whether the screen is displaying     images progressively, and the isTransformed() function whether it     is rotated. The transformOrientation() function can be     reimplemented to return the current rotation.      \row     \o Scanlines     \o      Use the linestep() function to retrieve the length of each     scanline of the framebuffer.      \row     \o Pixel Type     \o      The pixelType() function returns the screen's pixel storage format as     described by the PixelType enum.      \endtable      \section1 Subclassing and Initial Values      You need to set the following members when implementing a subclass of QScreen:      \table     \header \o Member \o Initial Value     \row \o \l{QScreen::}{data} \o A pointer to the framebuffer if possible;     0 otherwise.     \row \o \l{QScreen::}{lstep} \o The number of bytes between each scanline     in the framebuffer.     \row \o \l{QScreen::}{w} \o The logical screen width in pixels.     \row \o \l{QScreen::}{h} \o The logical screen height in pixels.     \row \o \l{QScreen::}{dw} \o The real screen width in pixels.     \row \o \l{QScreen::}{dh} \o The real screen height in pixels.     \row \o \l{QScreen::}{d} \o The number of bits per pixel.     \row \o \l{QScreen::}{physWidth} \o The screen width in millimeters.     \row \o \l{QScreen::}{physHeight} \o The screen height in millimeters.     \endtable      The logical screen values are the same as the real screen values unless the     screen is transformed in some way; e.g., rotated.      See also the \l{Accelerated Graphics Driver Example} for an example that     shows how to initialize these values.      \sa QScreenDriverPlugin, QScreenDriverFactory, {Qt for Embedded Linux Display     Management} */
end_comment
begin_comment
comment|/*!     \enum QScreen::PixelType      This enum describes the pixel storage format of the screen,     i.e. the order of the red (R), green (G) and blue (B) components     of a pixel.      \value NormalPixel Red-green-blue (RGB)     \value BGRPixel Blue-green-red (BGR)      \sa pixelType() */
end_comment
begin_comment
comment|/*!     \enum QScreen::ClassId      This enum defines the class identifiers for the known screen subclasses.      \value LinuxFBClass QLinuxFBScreen     \value TransformedClass QTransformedScreen     \value VNCClass QVNCScreen     \value MultiClass QMultiScreen     \value VFbClass QVFbScreen     \value DirectFBClass QDirectFBScreen     \value SvgalibClass QSvgalibScreen     \value ProxyClass QProxyScreen     \value GLClass QGLScreen     \value CustomClass Unknown QScreen subclass      \sa classId() */
end_comment
begin_comment
comment|/*!   \variable QScreen::screenclut   \brief the color table    Initialize this variable in a subclass using a paletted screen mode,   and initialize its partner, QScreen::screencols.    \sa screencols */
end_comment
begin_comment
comment|/*!   \variable QScreen::screencols   \brief the number of entries in the color table    Initialize this variable in a subclass using a paletted screen mode,   and initialize its partner, QScreen::screenclut.    \sa screenclut */
end_comment
begin_comment
comment|/*!   \variable QScreen::data   \brief points to the first visible pixel in the frame buffer.    You must initialize this variable if you are using the default   implementation of non-buffered painting Qt::WA_PaintOnScreen,   QPixmap::grabWindow() or QDirectPainter::frameBuffer(). If you   initialize this variable, you must also initialize QScreen::size and   QScreen::mapsize.    \sa QScreen::size, QScreen::mapsize */
end_comment
begin_comment
comment|/*!   \variable QScreen::w   \brief the logical width of the screen.    This variable \e{must} be initialized by a subclass. */
end_comment
begin_comment
comment|/*!   \variable QScreen::lstep   \brief the number of bytes representing a line in the frame buffer.    i.e., \e{line step}. \c {data[lstep * 2]} is the address of the   first visible pixel in the third line of the frame buffer.    \sa data */
end_comment
begin_comment
comment|/*!   \variable QScreen::h   \brief the logical height of the screen.    This variable \e{must} be initialized by a subclass. */
end_comment
begin_comment
comment|/*!   \variable QScreen::d   \brief the pixel depth    This is the number of significant bits used to set a pixel   color. This variable \e{must} be initialized by a subclass. */
end_comment
begin_comment
comment|/*!   \variable QScreen::pixeltype   \brief set to BGRPixel    Set this variable to BGRPixel in a subclass, if the screen pixel   format is a BGR type and you have used setPixelFormat() to set the   pixel format to the corresponding RGB format. e.g., you have set the   pixel format to QImage::Format_RGB555, but your screen really uses   BGR, not RGB. */
end_comment
begin_comment
comment|/*!   \variable QScreen::grayscale   \brief the gray scale screen mode flag    Set this variable to true in a subclass, if you are using a   grayscale screen mode. e.g., in an 8-bit mode where you don't want   to use the palette, but you want to use the grayscales. */
end_comment
begin_comment
comment|/*!   \variable QScreen::dw   \brief the device width    This is the number of pixels in a row of the physical screen.  It   \e{must} be initialized by a subclass. Normally, it should be set to   the logical width QScreen::w, but it might be different, e.g., if   you are doing rotations in software.    \sa QScreen::w */
end_comment
begin_comment
comment|/*!   \variable QScreen::dh   \brief the device height    This is the number of pixels in a column of the physical screen.  It   \e{must} be initialized by a subclass. Normally, it should be set to   the logical height QScreen::h, but it might be different, e.g., if   you are doing rotations in software.    \sa QScreen::h */
end_comment
begin_comment
comment|/*!   \variable QScreen::size   \brief the number of bytes in the visible region of the frame buffer    This is the number of bytes in the visible part of the block pointed   to by the QScreen::data pointer. You must initialize this variable   if you initialize the QScreen::data pointer.    \sa QScreen::data, QScreen::mapsize */
end_comment
begin_comment
comment|/*!   \variable QScreen::mapsize   \brief the total number of bytes in the frame buffer    This is the total number of bytes in the block pointed to by the   QScreen::data pointer. You must initialize this variable if you   initialize the QScreen::data pointer.    \sa QScreen::data, QScreen::size */
end_comment
begin_comment
comment|/*!   \variable QScreen::physWidth   \brief the physical width of the screen in millimeters.    Currently, this variable is used when calculating the screen DPI,   which in turn is used when deciding the actual font size Qt is   using. */
end_comment
begin_comment
comment|/*!   \variable QScreen::physHeight   \brief the physical height of the screen in millimeters.    Currently, this variable is used when calculating the screen DPI,   which in turn is used when deciding the actual font size Qt is   using. */
end_comment
begin_comment
comment|/*!     \fn static QScreen* QScreen::instance()      Returns a pointer to the application's QScreen instance.      If this screen consists of several subscreens, operations to the     returned instance will affect all its subscreens. Use the     subscreens() function to retrieve access to a particular     subscreen.      \sa subScreens(), subScreenIndexAt() */
end_comment
begin_comment
comment|/*!     \fn QList<QScreen*> QScreen::subScreens() const     \since 4.2      Returns a list of this screen's subscreens. Use the     subScreenIndexAt() function to retrieve the index of a screen at a     given position.      Note that if \e this screen consists of several subscreens,     operations to \e this instance will affect all subscreens by     default.      \sa instance(), subScreenIndexAt() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::physicalWidth() const     \since 4.2      Returns the physical width of the screen in millimeters.      \sa width(), deviceWidth(), physicalHeight() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::physicalHeight() const     \since 4.2      Returns the physical height of the screen in millimeters.      \sa height(), deviceHeight(), physicalWidth() */
end_comment
begin_comment
comment|/*!     \fn virtual bool QScreen::initDevice() = 0      This function is called by the \l{Qt for Embedded Linux} server to     initialize the framebuffer. Note that a server application will call the     connect() function prior to this function.      Implement this function to make accelerated drivers set up the     graphics card. Return true to indicate success and false to indicate     failure.      \sa shutdownDevice(), connect() */
end_comment
begin_comment
comment|/*!     \fn virtual bool QScreen::connect(const QString&displaySpec) = 0      This function is called by every \l{Qt for Embedded Linux}     application on startup, and must be implemented to map in the     framebuffer and the accelerated drivers that the graphics card     control registers.  Note that connect must be called \e before     the initDevice() function.      Ensure that true is returned if a connection to the screen device     is made. Otherwise, return false. Upon making the connection, the     function should read out the parameters of the framebuffer and use     them as required to set this class's protected variables.      The \a displaySpec argument is passed by the QWS_DISPLAY     environment variable or the -display command line parameter, and     has the following syntax:      \snippet doc/src/snippets/code/src_gui_embedded_qscreen_qws.cpp 0      For example, to use the mach64 driver on fb1 as display 2:      \snippet doc/src/snippets/code/src_gui_embedded_qscreen_qws.cpp 1      See \l{Qt for Embedded Linux Display Management} for more details.      \sa disconnect(), initDevice(), {Running Qt for Embedded Linux Applications} */
end_comment
begin_comment
comment|/*!     \fn QScreen::disconnect()      This function is called by every \l{Qt for Embedded Linux} application     before exiting, and must be implemented to unmap the     framebuffer. Note that a server application will call the     shutdownDevice() function prior to this function.      \sa connect(), shutdownDevice(), {Running Qt for Embedded Linux     Applications} */
end_comment
begin_comment
comment|/*!     \fn QScreen::setMode(int width, int height, int depth)      Implement this function to reset the framebuffer's resolution (\a     width and \a height) and bit \a depth.      After the resolution has been set, existing paint engines will be     invalid and the framebuffer should be completely redrawn. In a     multiple-process situation, all other applications must be     notified to reset their mode and update themselves accordingly. */
end_comment
begin_comment
comment|/*!     \fn QScreen::blank(bool on)      Prevents the screen driver form displaying any content on the     screen.      Note that the default implementation does nothing.      Reimplement this function to prevent the screen driver from     displaying any contents on the screen if \a on is true; otherwise     the contents is expected to be shown.      \sa blit() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::pixmapOffsetAlignment()      Returns the value (in bits) to which the start address of pixmaps     held in the graphics card's memory, should be aligned.      Note that the default implementation returns 64; reimplement this     function to override the return value, e.g., when implementing an     accelerated driver (see the \l {Adding an Accelerated Graphics     Driver to Qt for Embedded Linux}{Adding an Accelerated Graphics Driver}     documentation for details).      \sa pixmapLinestepAlignment() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::pixmapLinestepAlignment()      Returns the value (in bits) to which individual scanlines of     pixmaps held in the graphics card's memory, should be     aligned.      Note that the default implementation returns 64; reimplement this     function to override the return value, e.g., when implementing an     accelerated driver (see the \l {Adding an Accelerated Graphics     Driver to Qt for Embedded Linux}{Adding an Accelerated Graphics Driver}     documentation for details).      \sa pixmapOffsetAlignment() */
end_comment
begin_comment
comment|/*!     \fn QScreen::width() const      Returns the logical width of the framebuffer in pixels.      \sa deviceWidth(), physicalWidth(), height() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::height() const      Returns the logical height of the framebuffer in pixels.      \sa deviceHeight(), physicalHeight(), width() */
end_comment
begin_comment
comment|/*!     \fn QScreen::depth() const      Returns the depth of the framebuffer, in bits per pixel.      Note that the returned depth is the number of bits each pixel     fills rather than the number of significant bits, so 24bpp and     32bpp express the same range of colors (8 bits of red, green and     blue).      \sa clut(), pixmapDepth() */
end_comment
begin_comment
comment|/*!     \fn int QScreen::pixmapDepth() const      Returns the preferred depth for pixmaps, in bits per pixel.      \sa depth() */
end_comment
begin_comment
comment|/*!     \fn QScreen::linestep() const      Returns the length of each scanline of the framebuffer in bytes.      \sa isInterlaced() */
end_comment
begin_comment
comment|/*!     \fn QScreen::deviceWidth() const      Returns the physical width of the framebuffer device in pixels.      Note that the returned width can differ from the width which     \l{Qt for Embedded Linux} will actually use, that is if the display is     centered within the framebuffer.      \sa width(), physicalWidth(), deviceHeight() */
end_comment
begin_comment
comment|/*!     \fn QScreen::deviceHeight() const      Returns the full height of the framebuffer device in pixels.      Note that the returned height can differ from the height which     \l{Qt for Embedded Linux} will actually use, that is if the display is     centered within the framebuffer.      \sa height(), physicalHeight(), deviceWidth() */
end_comment
begin_comment
comment|/*!     \fn uchar *QScreen::base() const      Returns a pointer to the beginning of the framebuffer.      \sa onCard(), region(), totalSize() */
end_comment
begin_comment
comment|/*!     \fn uchar *QScreen::cache(int)      \internal      This function is used to store pixmaps in graphics memory for the     use of the accelerated drivers. See QLinuxFbScreen (where the     caching is implemented) for more information. */
end_comment
begin_comment
comment|/*!     \fn QScreen::uncache(uchar *)      \internal      This function is called on pixmap destruction to remove them from     graphics card memory. */
end_comment
begin_comment
comment|/*!     \fn QScreen::screenSize() const      Returns the size of the screen in bytes.      The screen size is always located at the beginning of framebuffer     memory, i.e. it can also be retrieved using the base() function.      \sa base(), region() */
end_comment
begin_comment
comment|/*!     \fn QScreen::totalSize() const      Returns the size of the available graphics card memory (including     the screen) in bytes.      \sa onCard() */
end_comment
begin_comment
comment|// Unaccelerated screen/driver setup. Can be overridden by accelerated
end_comment
begin_comment
comment|// drivers
end_comment
begin_comment
comment|/*!     \fn QScreen::QScreen(int displayId)      Constructs a new screen driver.      The \a displayId identifies the \l{Qt for Embedded Linux} server to connect     to. */
end_comment
begin_comment
comment|/*!     \fn QScreen::clut()      Returns a pointer to the screen's color lookup table (i.e. its     color palette).      Note that this function only apply in paletted modes like 8-bit,     i.e. in modes where only the palette indexes (and not the actual     color values) are stored in memory.      \sa alloc(), depth(), colorCount() */
end_comment
begin_comment
comment|/*!     \obsolete     \fn int QScreen::numCols()      \sa colorCount() */
end_comment
begin_comment
comment|/*!     \since 4.6     \fn int QScreen::colorCount()      Returns the number of entries in the screen's color lookup table     (i.e. its color palette). A pointer to the color table can be     retrieved using the clut() function.      \sa clut(), alloc() */
end_comment
begin_comment
comment|/*!     \since 4.4      Constructs a new screen driver.      The \a display_id identifies the \l{Qt for Embedded Linux}     server to connect to. The \a classId specifies the class     identifier. */
end_comment
begin_constructor
DECL|function|QScreen
name|QScreen
operator|::
name|QScreen
parameter_list|(
name|int
name|display_id
parameter_list|,
name|ClassId
name|classId
parameter_list|)
member_init_list|:
name|screencols
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|entries
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|entryp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lowest
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|w
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lstep
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|h
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|pixeltype
argument_list|(
name|NormalPixel
argument_list|)
member_init_list|,
name|grayscale
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dw
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dh
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mapsize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|displayId
argument_list|(
name|display_id
argument_list|)
member_init_list|,
name|physWidth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|physHeight
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QScreenPrivate
argument_list|(
name|this
argument_list|,
name|classId
argument_list|)
argument_list|)
block|{
name|clearCacheFunc
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QScreen
name|QScreen
operator|::
name|QScreen
parameter_list|(
name|int
name|display_id
parameter_list|)
member_init_list|:
name|screencols
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|entries
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|entryp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lowest
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|w
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lstep
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|h
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|pixeltype
argument_list|(
name|NormalPixel
argument_list|)
member_init_list|,
name|grayscale
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dw
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dh
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mapsize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|displayId
argument_list|(
name|display_id
argument_list|)
member_init_list|,
name|physWidth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|physHeight
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QScreenPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|clearCacheFunc
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys this screen driver. */
end_comment
begin_destructor
DECL|function|~QScreen
name|QScreen
operator|::
name|~
name|QScreen
parameter_list|()
block|{
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     This function is called by the \l{Qt for Embedded Linux} server before it     calls the disconnect() function when exiting.      Note that the default implementation only hides the mouse cursor;     reimplement this function to do the necessary graphics card     specific cleanup.      \sa initDevice(), disconnect() */
end_comment
begin_function
DECL|function|shutdownDevice
name|void
name|QScreen
operator|::
name|shutdownDevice
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
condition|)
name|qt_screencursor
operator|->
name|hide
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
specifier|extern
name|bool
name|qws_accel
decl_stmt|;
end_decl_stmt
begin_comment
comment|//in qapplication_qws.cpp
end_comment
begin_comment
comment|/*!     \fn PixelType QScreen::pixelType() const      Returns the pixel storage format of the screen. */
end_comment
begin_comment
comment|/*!   Returns the pixel format of the screen, or \c QImage::Format_Invalid   if the pixel format is not a supported image format.  */
end_comment
begin_function
DECL|function|pixelFormat
name|QImage
operator|::
name|Format
name|QScreen
operator|::
name|pixelFormat
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|pixelFormat
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the screen's pixel format to \a format.  */
end_comment
begin_function
DECL|function|setPixelFormat
name|void
name|QScreen
operator|::
name|setPixelFormat
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
name|d_ptr
operator|->
name|pixelFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn int QScreen::alloc(unsigned int red, unsigned int green, unsigned int blue)      Returns the index in the screen's palette which is the closest     match to the given RGB value (\a red, \a green, \a blue).      Note that this function only apply in paletted modes like 8-bit,     i.e. in modes where only the palette indexes (and not the actual     color values) are stored in memory.      \sa clut(), colorCount() */
end_comment
begin_function
DECL|function|alloc
name|int
name|QScreen
operator|::
name|alloc
parameter_list|(
name|unsigned
name|int
name|r
parameter_list|,
name|unsigned
name|int
name|g
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|grayscale
condition|)
return|return
name|qGray
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
return|;
comment|// First we look to see if we match a default color
specifier|const
name|int
name|pos
init|=
operator|(
name|r
operator|+
literal|25
operator|)
operator|/
literal|51
operator|*
literal|36
operator|+
operator|(
name|g
operator|+
literal|25
operator|)
operator|/
literal|51
operator|*
literal|6
operator|+
operator|(
name|b
operator|+
literal|25
operator|)
operator|/
literal|51
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|screencols
operator|&&
name|screenclut
index|[
name|pos
index|]
operator|==
name|qRgb
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
condition|)
block|{
return|return
name|pos
return|;
block|}
comment|// search for nearest color
name|unsigned
name|int
name|mindiff
init|=
literal|0xffffffff
decl_stmt|;
name|unsigned
name|int
name|diff
decl_stmt|;
name|int
name|dr
decl_stmt|,
name|dg
decl_stmt|,
name|db
decl_stmt|;
for|for
control|(
name|int
name|loopc
init|=
literal|0
init|;
name|loopc
operator|<
name|screencols
condition|;
operator|++
name|loopc
control|)
block|{
name|dr
operator|=
name|qRed
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|-
name|r
expr_stmt|;
name|dg
operator|=
name|qGreen
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|-
name|g
expr_stmt|;
name|db
operator|=
name|qBlue
argument_list|(
name|screenclut
index|[
name|loopc
index|]
argument_list|)
operator|-
name|b
expr_stmt|;
name|diff
operator|=
name|dr
operator|*
name|dr
operator|+
name|dg
operator|*
name|dg
operator|+
name|db
operator|*
name|db
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|mindiff
condition|)
block|{
name|ret
operator|=
name|loopc
expr_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
break|break;
name|mindiff
operator|=
name|diff
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|4
condition|)
block|{
name|ret
operator|=
name|qGray
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
operator|>>
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
name|qGray
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
operator|>=
literal|128
expr_stmt|;
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"cannot alloc %dbpp color"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Saves the current state of the graphics card.      For example, hardware screen drivers should reimplement the save()     and restore() functions to save and restore its registers,     enabling swintching between virtual consoles.      Note that the default implementation does nothing.      \sa restore() */
end_comment
begin_function
DECL|function|save
name|void
name|QScreen
operator|::
name|save
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     Restores the previously saved state of the graphics card.      For example, hardware screen drivers should reimplement the save()     and restore() functions to save and restore its registers,     enabling swintching between virtual consoles.      Note that the default implementation does nothing.      \sa save() */
end_comment
begin_function
DECL|function|restore
name|void
name|QScreen
operator|::
name|restore
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|blank
name|void
name|QScreen
operator|::
name|blank
parameter_list|(
name|bool
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|set
name|void
name|QScreen
operator|::
name|set
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn bool QScreen::supportsDepth(int depth) const      Returns true if the screen supports the specified color \a depth;     otherwise returns false.      \sa clut() */
end_comment
begin_function
DECL|function|supportsDepth
name|bool
name|QScreen
operator|::
name|supportsDepth
parameter_list|(
name|int
name|d
parameter_list|)
specifier|const
block|{
if|if
condition|(
literal|false
condition|)
block|{
comment|//Just to simplify the ifdeffery
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_1
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_4
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|4
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_8
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|8
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_16
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|16
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_15
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|15
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_18
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|18
operator|||
name|d
operator|==
literal|19
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_24
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|24
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_QWS_DEPTH_32
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|32
condition|)
block|{
return|return
literal|true
return|;
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QScreen::onCard(const unsigned char *buffer) const      Returns true if the specified \a buffer is within the graphics     card's memory; otherwise returns false (i.e. if it's in main RAM).      \sa base(), totalSize() */
end_comment
begin_function
DECL|function|onCard
name|bool
name|QScreen
operator|::
name|onCard
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
specifier|const
block|{
name|long
name|t
init|=
operator|(
name|unsigned
name|long
operator|)
name|p
decl_stmt|;
name|long
name|bmin
init|=
operator|(
name|unsigned
name|long
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|t
operator|<
name|bmin
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|t
operator|>=
name|bmin
operator|+
name|mapsize
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QScreen::onCard(const unsigned char * buffer, ulong& offset) const     \overload      If the specified \a buffer is within the graphics card's memory,     this function stores the offset from the start of graphics card     memory (in bytes), in the location specified by the \a offset     parameter. */
end_comment
begin_function
DECL|function|onCard
name|bool
name|QScreen
operator|::
name|onCard
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|ulong
modifier|&
name|offset
parameter_list|)
specifier|const
block|{
name|long
name|t
init|=
operator|(
name|unsigned
name|long
operator|)
name|p
decl_stmt|;
name|long
name|bmin
init|=
operator|(
name|unsigned
name|long
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|t
operator|<
name|bmin
condition|)
return|return
literal|false
return|;
name|long
name|o
init|=
name|t
operator|-
name|bmin
decl_stmt|;
if|if
condition|(
name|o
operator|>=
name|mapsize
condition|)
return|return
literal|false
return|;
name|offset
operator|=
name|o
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/* #if !defined(QT_NO_QWS_REPEATER)     { "Repeater", qt_get_screen_repeater, 0 }, #endif #if defined(QT_QWS_EE)     { "EE", qt_get_screen_ee, 0 }, #endif  */
end_comment
begin_comment
comment|/* Given a display_id (number of the \l{Qt for Embedded Linux} server to connect to) and a spec (e.g. Mach64:/dev/fb0) return a QScreen-descendant. The QScreenDriverFactory is queried for a suitable driver and, if found, asked to create a driver. People writing new graphics drivers should either hook their own QScreen-descendant into QScreenDriverFactory or use the QScreenDriverPlugin to make a dynamically loadable driver. */
end_comment
begin_function
DECL|function|qt_get_screen
name|Q_GUI_EXPORT
name|QScreen
modifier|*
name|qt_get_screen
parameter_list|(
name|int
name|display_id
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|QString
name|displaySpec
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|QString
name|driver
init|=
name|displaySpec
decl_stmt|;
name|int
name|colon
init|=
name|displaySpec
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|>=
literal|0
condition|)
name|driver
operator|.
name|truncate
argument_list|(
name|colon
argument_list|)
expr_stmt|;
name|driver
operator|=
name|driver
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|bool
name|foundDriver
init|=
literal|false
decl_stmt|;
name|QString
name|driverName
init|=
name|driver
decl_stmt|;
name|QStringList
name|driverList
decl_stmt|;
if|if
condition|(
operator|!
name|driver
operator|.
name|isEmpty
argument_list|()
condition|)
name|driverList
operator|<<
name|driver
expr_stmt|;
else|else
name|driverList
operator|=
name|QScreenDriverFactory
operator|::
name|keys
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|driverList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|driverName
init|=
name|driverList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_screen
operator|=
name|QScreenDriverFactory
operator|::
name|create
argument_list|(
name|driverName
argument_list|,
name|display_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_screen
condition|)
block|{
name|foundDriver
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|qt_screen
operator|->
name|connect
argument_list|(
name|displaySpec
argument_list|)
condition|)
block|{
return|return
name|qt_screen
return|;
block|}
else|else
block|{
operator|delete
name|qt_screen
expr_stmt|;
name|qt_screen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|driver
operator|.
name|isNull
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"No suitable driver found"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|foundDriver
condition|)
name|qFatal
argument_list|(
literal|"%s: driver cannot connect"
argument_list|,
name|driver
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qFatal
argument_list|(
literal|"%s: driver not found"
argument_list|,
name|driver
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
end_ifndef
begin_function
DECL|function|blendCursor
specifier|static
name|void
name|blendCursor
parameter_list|(
name|QImage
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImage
modifier|&
name|cursor
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
name|QRasterBuffer
name|rb
decl_stmt|;
name|rb
operator|.
name|prepare
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|QSpanData
name|spanData
decl_stmt|;
name|spanData
operator|.
name|init
argument_list|(
operator|&
name|rb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|type
operator|=
name|QSpanData
operator|::
name|Texture
expr_stmt|;
name|spanData
operator|.
name|initTexture
argument_list|(
operator|&
name|cursor
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|dx
operator|=
operator|-
name|offset
operator|.
name|x
argument_list|()
expr_stmt|;
name|spanData
operator|.
name|dy
operator|=
operator|-
name|offset
operator|.
name|y
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|spanData
operator|.
name|blend
condition|)
return|return;
specifier|const
name|QRect
name|rect
init|=
name|QRect
argument_list|(
name|offset
argument_list|,
name|cursor
operator|.
name|size
argument_list|()
argument_list|)
operator|&
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QT_FT_Span
argument_list|,
literal|32
argument_list|>
name|spans
argument_list|(
name|h
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
operator|++
name|i
control|)
block|{
name|spans
index|[
name|i
index|]
operator|.
name|x
operator|=
name|rect
operator|.
name|x
argument_list|()
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|len
operator|=
name|w
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|y
operator|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|i
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|coverage
operator|=
literal|255
expr_stmt|;
block|}
name|spanData
operator|.
name|blend
argument_list|(
name|h
argument_list|,
name|spans
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|spanData
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_CURSOR
end_comment
begin_comment
comment|/*!     \fn void QScreen::exposeRegion(QRegion region, int windowIndex)      This function is called by the \l{Qt for Embedded Linux} server whenever a     screen update is required. \a region is the area on the screen     that must be updated, and \a windowIndex is the index into     QWSServer::clientWindows() of the window that required the     update. QWSWindow::state() gives more information about the cause.      The default implementation composes the     affected windows and paints the given \a region on screen by     calling the blit() and solidFill() functions      This function can be reimplemented to perform composition in     hardware, or to perform transition effects.     For simpler hardware acceleration, or to interface with     this is typically done by reimplementing the blit() and     solidFill() functions instead.      Note that there is no need to call this function explicitly.      \sa blit(), solidFill(), blank() */
end_comment
begin_function
DECL|function|exposeRegion
name|void
name|QScreen
operator|::
name|exposeRegion
parameter_list|(
name|QRegion
name|r
parameter_list|,
name|int
name|windowIndex
parameter_list|)
block|{
name|r
operator|&=
name|region
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|changing
init|=
name|windowIndex
decl_stmt|;
comment|// when we have just lowered a window, we have to expose all the windows below where the
comment|// window used to be.
if|if
condition|(
name|changing
operator|&&
name|qwsServer
operator|->
name|clientWindows
argument_list|()
operator|.
name|at
argument_list|(
name|changing
argument_list|)
operator|->
name|state
argument_list|()
operator|==
name|QWSWindow
operator|::
name|Lowering
condition|)
name|changing
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QTOPIA_PERFTEST
specifier|static
enum|enum
block|{
name|PerfTestUnknown
block|,
name|PerfTestOn
block|,
name|PerfTestOff
block|}
name|perfTestState
init|=
name|PerfTestUnknown
enum|;
if|if
condition|(
name|PerfTestUnknown
operator|==
name|perfTestState
condition|)
block|{
if|if
condition|(
operator|::
name|getenv
argument_list|(
literal|"QTOPIA_PERFTEST"
argument_list|)
condition|)
name|perfTestState
operator|=
name|PerfTestOn
expr_stmt|;
else|else
name|perfTestState
operator|=
name|PerfTestOff
expr_stmt|;
block|}
if|if
condition|(
name|PerfTestOn
operator|==
name|perfTestState
condition|)
block|{
name|QWSWindow
modifier|*
name|changed
init|=
name|qwsServer
operator|->
name|clientWindows
argument_list|()
operator|.
name|at
argument_list|(
name|changing
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changed
operator|->
name|client
argument_list|()
operator|->
name|identity
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"Performance  :  expose_region  :"
operator|<<
name|changed
operator|->
name|client
argument_list|()
operator|->
name|identity
argument_list|()
operator|<<
name|r
operator|.
name|boundingRect
argument_list|()
operator|<<
literal|": "
operator|<<
name|qPrintable
argument_list|(
name|QTime
operator|::
name|currentTime
argument_list|()
operator|.
name|toString
argument_list|(
literal|"h:mm:ss.zzz"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
specifier|const
name|QRect
name|bounds
init|=
name|r
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|QRegion
name|blendRegion
decl_stmt|;
name|QImage
modifier|*
name|blendBuffer
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
operator|&&
operator|!
name|qt_screencursor
operator|->
name|isAccelerated
argument_list|()
condition|)
block|{
name|blendRegion
operator|=
name|r
operator|&
name|qt_screencursor
operator|->
name|boundingRect
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|compose
argument_list|(
literal|0
argument_list|,
name|r
argument_list|,
name|blendRegion
argument_list|,
operator|&
name|blendBuffer
argument_list|,
name|changing
argument_list|)
expr_stmt|;
if|if
condition|(
name|blendBuffer
operator|&&
operator|!
name|blendBuffer
operator|->
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|QPoint
name|offset
init|=
name|blendRegion
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_CURSOR
if|if
condition|(
name|qt_screencursor
operator|&&
operator|!
name|qt_screencursor
operator|->
name|isAccelerated
argument_list|()
condition|)
block|{
specifier|const
name|QRect
name|cursorRect
init|=
name|qt_screencursor
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|blendRegion
operator|.
name|intersects
argument_list|(
name|cursorRect
argument_list|)
condition|)
block|{
name|blendCursor
argument_list|(
name|blendBuffer
argument_list|,
name|qt_screencursor
operator|->
name|image
argument_list|()
argument_list|,
name|cursorRect
operator|.
name|topLeft
argument_list|()
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_QWS_CURSOR
name|blit
argument_list|(
operator|*
name|blendBuffer
argument_list|,
name|offset
argument_list|,
name|blendRegion
argument_list|)
expr_stmt|;
operator|delete
name|blendBuffer
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|setDirty
argument_list|(
name|r
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|r
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|setDirty
argument_list|(
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QScreen::blit(const QImage&image, const QPoint&topLeft, const QRegion&region)      Copies the given \a region in the given \a image to the point     specified by \a topLeft using device coordinates.      This function is called from the exposeRegion() function; it is     not intended to be called explicitly.      Reimplement this function to make use of \l{Adding an Accelerated     Graphics Driver to Qt for Embedded Linux}{accelerated hardware}. Note that     this function must be reimplemented if the framebuffer format is     not supported by \l{Qt for Embedded Linux} (See the     \l{Qt for Embedded Linux Display Management}{Display Management}     documentation for more details).      \sa exposeRegion(), solidFill(), blank() */
end_comment
begin_function
DECL|function|blit
name|void
name|QScreen
operator|::
name|blit
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|reg
parameter_list|)
block|{
specifier|const
name|QRect
name|bound
init|=
operator|(
name|region
argument_list|()
operator|&
name|QRect
argument_list|(
name|topLeft
argument_list|,
name|img
operator|.
name|size
argument_list|()
argument_list|)
operator|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|QWSDisplay
operator|::
name|grab
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|blit
argument_list|(
name|this
argument_list|,
name|img
argument_list|,
name|topLeft
operator|-
name|offset
argument_list|()
argument_list|,
operator|(
name|reg
operator|&
name|bound
operator|)
operator|.
name|translated
argument_list|(
operator|-
name|topLeft
argument_list|)
argument_list|)
expr_stmt|;
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
end_ifdef
begin_comment
comment|/*!   Returns true if this screen driver supports calling QScreen::blit() and   QScreen::setDirty() directly from non-server applications, otherwise returns   false.    If available, this is used to optimize the performance of non-occluded, opaque   client windows by removing the server round trip when they are updated.    \sa setSupportsBlitInClients()  */
end_comment
begin_function
DECL|function|supportsBlitInClients
name|bool
name|QScreen
operator|::
name|supportsBlitInClients
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|supportsBlitInClients
return|;
block|}
end_function
begin_comment
comment|/*!   If \a supported, the screen driver is marked as supporting blitting directly   from non-server applications.    \sa supportsBlitInClients()  */
end_comment
begin_function
DECL|function|setSupportsBlitInClients
name|void
name|QScreen
operator|::
name|setSupportsBlitInClients
parameter_list|(
name|bool
name|supported
parameter_list|)
block|{
name|d_ptr
operator|->
name|supportsBlitInClients
operator|=
name|supported
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|blit
name|void
name|QScreen
operator|::
name|blit
parameter_list|(
name|QWSWindow
modifier|*
name|win
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|clip
parameter_list|)
block|{
name|QWSWindowSurface
modifier|*
name|surface
init|=
name|win
operator|->
name|windowSurface
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|surface
condition|)
return|return;
specifier|const
name|QImage
modifier|&
name|img
init|=
name|surface
operator|->
name|image
argument_list|()
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return;
specifier|const
name|QRegion
name|rgn
init|=
name|clip
operator|&
name|win
operator|->
name|paintedRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|rgn
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|surface
operator|->
name|lock
argument_list|()
expr_stmt|;
name|blit
argument_list|(
name|img
argument_list|,
name|win
operator|->
name|requestedRegion
argument_list|()
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|,
name|rgn
argument_list|)
expr_stmt|;
name|surface
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|fill_data
struct|struct
name|fill_data
block|{
DECL|member|color
name|quint32
name|color
decl_stmt|;
DECL|member|data
name|uchar
modifier|*
name|data
decl_stmt|;
DECL|member|lineStep
name|int
name|lineStep
decl_stmt|;
DECL|member|x
name|int
name|x
decl_stmt|;
DECL|member|y
name|int
name|y
decl_stmt|;
DECL|member|w
name|int
name|w
decl_stmt|;
DECL|member|h
name|int
name|h
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     Fills the given \a region of the screen with the specified \a     color.      This function is called from the exposeRegion() function; it is     not intended to be called explicitly.      Reimplement this function to make use of \l{Adding an Accelerated     Graphics Driver to Qt for Embedded Linux}{accelerated hardware}. Note that     this function must be reimplemented if the framebuffer format is     not supported by \l{Qt for Embedded Linux} (See the     \l{Qt for Embedded Linux Display Management}{Display Management}     documentation for more details).      \sa exposeRegion(), blit(), blank() */
end_comment
begin_comment
comment|// the base class implementation works in device coordinates, so that transformed drivers can use it
end_comment
begin_function
DECL|function|solidFill
name|void
name|QScreen
operator|::
name|solidFill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QWSDisplay
operator|::
name|grab
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|solidFill
argument_list|(
name|this
argument_list|,
name|color
argument_list|,
name|region
operator|.
name|translated
argument_list|(
operator|-
name|offset
argument_list|()
argument_list|)
operator|&
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|)
argument_list|)
expr_stmt|;
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Creates and returns a new window surface matching the given \a     key.      The server application will call this function whenever it needs     to create a server side representation of a window, e.g. when     copying the content of memory to the screen using the screen     driver.      Note that this function must be reimplemented when adding an     accelerated graphics driver. See the     \l{Adding an Accelerated Graphics Driver to Qt for Embedded Linux}     {Adding an Accelerated Graphics Driver} documentation for details.      \sa {Qt for Embedded Linux Architecture} */
end_comment
begin_function
DECL|function|createSurface
name|QWSWindowSurface
modifier|*
name|QScreen
operator|::
name|createSurface
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_PAINTONSCREEN
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"OnScreen"
argument_list|)
condition|)
return|return
operator|new
name|QWSOnScreenSurface
return|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"mem"
argument_list|)
condition|)
return|return
operator|new
name|QWSLocalMemSurface
return|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
elseif|else
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"shm"
argument_list|)
condition|)
return|return
operator|new
name|QWSSharedMemSurface
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_PAINT_DEBUG
elseif|else
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"Yellow"
argument_list|)
condition|)
return|return
operator|new
name|QWSYellowSurface
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DIRECTPAINTER
elseif|else
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"DirectPainter"
argument_list|)
condition|)
return|return
operator|new
name|QWSDirectPainterSurface
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PAINTONSCREEN
end_ifndef
begin_function
DECL|function|isWidgetPaintOnScreen
name|bool
name|QScreen
operator|::
name|isWidgetPaintOnScreen
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
specifier|static
name|int
name|doOnScreen
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|doOnScreen
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|QByteArray
name|env
init|=
name|qgetenv
argument_list|(
literal|"QT_ONSCREEN_PAINT"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
operator|==
literal|"force"
condition|)
name|doOnScreen
operator|=
literal|2
expr_stmt|;
else|else
name|doOnScreen
operator|=
operator|(
name|env
operator|.
name|toInt
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|doOnScreen
operator|==
literal|2
condition|)
comment|// force
return|return
literal|true
return|;
if|if
condition|(
name|doOnScreen
operator|==
literal|0
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|isOpaque
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Creates and returns a new window surface for the given \a widget. */
end_comment
begin_function
DECL|function|createSurface
name|QWSWindowSurface
modifier|*
name|QScreen
operator|::
name|createSurface
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_PAINTONSCREEN
if|if
condition|(
name|isWidgetPaintOnScreen
argument_list|(
name|widget
argument_list|)
operator|&&
name|base
argument_list|()
condition|)
return|return
operator|new
name|QWSOnScreenSurface
argument_list|(
name|widget
argument_list|)
return|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|QApplication
operator|::
name|type
argument_list|()
operator|==
name|QApplication
operator|::
name|GuiServer
condition|)
return|return
operator|new
name|QWSLocalMemSurface
argument_list|(
name|widget
argument_list|)
return|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
else|else
return|return
operator|new
name|QWSSharedMemSurface
argument_list|(
name|widget
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|compose
name|void
name|QScreen
operator|::
name|compose
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|exposed
parameter_list|,
name|QRegion
modifier|&
name|blend
parameter_list|,
name|QImage
modifier|*
modifier|*
name|blendbuffer
parameter_list|,
name|int
name|changing_level
parameter_list|)
block|{
name|QRect
name|exposed_bounds
init|=
name|exposed
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|QWSWindow
modifier|*
name|win
init|=
literal|0
decl_stmt|;
do|do
block|{
name|win
operator|=
name|qwsServer
operator|->
name|clientWindows
argument_list|()
operator|.
name|value
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|// null is background
operator|++
name|level
expr_stmt|;
block|}
do|while
condition|(
name|win
operator|&&
operator|!
name|win
operator|->
name|paintedRegion
argument_list|()
operator|.
name|boundingRect
argument_list|()
operator|.
name|intersects
argument_list|(
name|exposed_bounds
argument_list|)
condition|)
do|;
name|QWSWindowSurface
modifier|*
name|surface
init|=
operator|(
name|win
condition|?
name|win
operator|->
name|windowSurface
argument_list|()
else|:
literal|0
operator|)
decl_stmt|;
name|bool
name|above_changing
init|=
name|level
operator|<=
name|changing_level
decl_stmt|;
comment|// 0 is topmost
name|QRegion
name|exposedBelow
init|=
name|exposed
decl_stmt|;
name|bool
name|opaque
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|win
condition|)
block|{
name|opaque
operator|=
name|win
operator|->
name|isOpaque
argument_list|()
operator|||
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
expr_stmt|;
if|if
condition|(
name|opaque
condition|)
block|{
name|exposedBelow
operator|-=
name|win
operator|->
name|paintedRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|above_changing
operator|||
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
name|blend
operator|-=
name|exposed
operator|&
name|win
operator|->
name|paintedRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|blend
operator|+=
name|exposed
operator|&
name|win
operator|->
name|paintedRegion
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|win
operator|&&
operator|!
name|exposedBelow
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|compose
argument_list|(
name|level
argument_list|,
name|exposedBelow
argument_list|,
name|blend
argument_list|,
name|blendbuffer
argument_list|,
name|changing_level
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QSize
name|blendSize
init|=
name|blend
operator|.
name|boundingRect
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blendSize
operator|.
name|isNull
argument_list|()
condition|)
block|{
operator|*
name|blendbuffer
operator|=
operator|new
name|QImage
argument_list|(
name|blendSize
argument_list|,
name|d_ptr
operator|->
name|preferredImageFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|QRegion
name|blitRegion
init|=
name|exposed
operator|-
name|blend
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|paintBackground
argument_list|(
name|blitRegion
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|above_changing
operator|&&
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
name|blit
argument_list|(
name|win
argument_list|,
name|blitRegion
argument_list|)
expr_stmt|;
name|QRegion
name|blendRegion
init|=
name|exposed
operator|&
name|blend
decl_stmt|;
if|if
condition|(
name|win
condition|)
name|blendRegion
operator|&=
name|win
operator|->
name|paintedRegion
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blendRegion
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPoint
name|off
init|=
name|blend
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QRasterBuffer
name|rb
decl_stmt|;
name|rb
operator|.
name|prepare
argument_list|(
operator|*
name|blendbuffer
argument_list|)
expr_stmt|;
name|QSpanData
name|spanData
decl_stmt|;
name|spanData
operator|.
name|init
argument_list|(
operator|&
name|rb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
block|{
specifier|const
name|QImage
operator|::
name|Format
name|format
init|=
operator|(
operator|*
name|blendbuffer
operator|)
operator|->
name|format
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|spanData
operator|.
name|rasterBuffer
operator|->
name|compositionMode
operator|=
name|QPainter
operator|::
name|CompositionMode_Source
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|spanData
operator|.
name|setup
argument_list|(
name|qwsServer
operator|->
name|backgroundBrush
argument_list|()
argument_list|,
literal|256
argument_list|,
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|dx
operator|=
name|off
operator|.
name|x
argument_list|()
expr_stmt|;
name|spanData
operator|.
name|dy
operator|=
name|off
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|surface
operator|->
name|isBuffered
argument_list|()
condition|)
block|{
return|return;
block|}
else|else
block|{
specifier|const
name|QImage
modifier|&
name|img
init|=
name|surface
operator|->
name|image
argument_list|()
decl_stmt|;
name|QPoint
name|winoff
init|=
name|off
operator|-
name|win
operator|->
name|requestedRegion
argument_list|()
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
comment|// convert win->opacity() from scale [0..255] to [0..256]
name|int
name|const_alpha
init|=
name|win
operator|->
name|opacity
argument_list|()
decl_stmt|;
name|const_alpha
operator|+=
operator|(
name|const_alpha
operator|>>
literal|7
operator|)
expr_stmt|;
name|spanData
operator|.
name|type
operator|=
name|QSpanData
operator|::
name|Texture
expr_stmt|;
name|spanData
operator|.
name|initTexture
argument_list|(
operator|&
name|img
argument_list|,
name|const_alpha
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|dx
operator|=
name|winoff
operator|.
name|x
argument_list|()
expr_stmt|;
name|spanData
operator|.
name|dy
operator|=
name|winoff
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|spanData
operator|.
name|blend
condition|)
return|return;
if|if
condition|(
name|surface
condition|)
name|surface
operator|->
name|lock
argument_list|()
expr_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|blendRegion
operator|.
name|rects
argument_list|()
decl_stmt|;
specifier|const
name|int
name|nspans
init|=
literal|256
decl_stmt|;
name|QT_FT_Span
name|spans
index|[
name|nspans
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|y
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|()
operator|-
name|off
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|ye
init|=
name|y
operator|+
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|x
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|()
operator|-
name|off
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|width
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|ye
condition|)
block|{
name|int
name|n
init|=
name|qMin
argument_list|(
name|nspans
argument_list|,
name|ye
operator|-
name|y
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|spans
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|y
operator|=
name|y
operator|+
name|i
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|coverage
operator|=
literal|255
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|spanData
operator|.
name|blend
argument_list|(
name|n
argument_list|,
name|spans
argument_list|,
operator|&
name|spanData
argument_list|)
expr_stmt|;
name|y
operator|+=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|surface
condition|)
name|surface
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|paintBackground
name|void
name|QScreen
operator|::
name|paintBackground
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
specifier|const
name|QBrush
modifier|&
name|bg
init|=
name|qwsServer
operator|->
name|backgroundBrush
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|BrushStyle
name|bs
init|=
name|bg
operator|.
name|style
argument_list|()
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|Qt
operator|::
name|NoBrush
operator|||
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|bs
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|solidFill
argument_list|(
name|bg
operator|.
name|color
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QRect
name|br
init|=
name|r
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|QImage
name|img
argument_list|(
name|br
operator|.
name|size
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|preferredImageFormat
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|off
init|=
name|br
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QRasterBuffer
name|rb
decl_stmt|;
name|rb
operator|.
name|prepare
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
name|QSpanData
name|spanData
decl_stmt|;
name|spanData
operator|.
name|init
argument_list|(
operator|&
name|rb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|setup
argument_list|(
name|bg
argument_list|,
literal|256
argument_list|,
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|spanData
operator|.
name|dx
operator|=
name|off
operator|.
name|x
argument_list|()
expr_stmt|;
name|spanData
operator|.
name|dy
operator|=
name|off
operator|.
name|y
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|spanData
operator|.
name|blend
argument_list|)
expr_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|r
operator|.
name|rects
argument_list|()
decl_stmt|;
specifier|const
name|int
name|nspans
init|=
literal|256
decl_stmt|;
name|QT_FT_Span
name|spans
index|[
name|nspans
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|y
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|()
operator|-
name|off
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|ye
init|=
name|y
operator|+
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|x
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|()
operator|-
name|off
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|width
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|ye
condition|)
block|{
name|int
name|n
init|=
name|qMin
argument_list|(
name|nspans
argument_list|,
name|ye
operator|-
name|y
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|spans
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|y
operator|=
name|y
operator|+
name|i
expr_stmt|;
name|spans
index|[
name|i
index|]
operator|.
name|coverage
operator|=
literal|255
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|spanData
operator|.
name|blend
argument_list|(
name|n
argument_list|,
name|spans
argument_list|,
operator|&
name|spanData
argument_list|)
expr_stmt|;
name|y
operator|+=
name|n
expr_stmt|;
block|}
block|}
name|blit
argument_list|(
name|img
argument_list|,
name|br
operator|.
name|topLeft
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn virtual int QScreen::sharedRamSize(void *)      \internal */
end_comment
begin_comment
comment|/*!     \fn QScreen::setDirty(const QRect& rectangle)      Marks the given \a rectangle as dirty.      Note that the default implementation does nothing; reimplement     this function to indicate that the given \a rectangle has been     altered. */
end_comment
begin_function
DECL|function|setDirty
name|void
name|QScreen
operator|::
name|setDirty
parameter_list|(
specifier|const
name|QRect
modifier|&
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn QScreen::isTransformed() const      Returns true if the screen is transformed (for instance, rotated     90 degrees); otherwise returns false.      \sa transformOrientation(), isInterlaced() */
end_comment
begin_function
DECL|function|isTransformed
name|bool
name|QScreen
operator|::
name|isTransformed
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::isInterlaced() const      Returns true if the display is interlaced (i.e. is displaying     images progressively like a television screen); otherwise returns     false.      If the display is interlaced, the drawing is altered to look     better.      \sa isTransformed(), linestep() */
end_comment
begin_function
DECL|function|isInterlaced
name|bool
name|QScreen
operator|::
name|isInterlaced
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
comment|//qws_screen_is_interlaced;;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapToDevice(const QSize&size) const      Maps the given \a size from the coordinate space used by the     application to the framebuffer coordinate system. Note that the     default implementation simply returns the given \a size as it is.      Reimplement this function to use the given device's coordinate     system when mapping.      \sa mapFromDevice() */
end_comment
begin_function
DECL|function|mapToDevice
name|QSize
name|QScreen
operator|::
name|mapToDevice
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
specifier|const
block|{
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapFromDevice(const QSize&size) const      Maps the given \a size from the framebuffer coordinate system to     the coordinate space used by the application. Note that the     default implementation simply returns the given \a size as it is.      Reimplement this function to use the given device's coordinate     system when mapping.      \sa mapToDevice() */
end_comment
begin_function
DECL|function|mapFromDevice
name|QSize
name|QScreen
operator|::
name|mapFromDevice
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
specifier|const
block|{
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapToDevice(const QPoint&point, const QSize&screenSize) const     \overload      Maps the given \a point from the coordinate space used by the     application to the framebuffer coordinate system, passing the     device's \a screenSize as argument. Note that the default     implementation returns the given \a point as it is. */
end_comment
begin_function
DECL|function|mapToDevice
name|QPoint
name|QScreen
operator|::
name|mapToDevice
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapFromDevice(const QPoint&point, const QSize&screenSize) const     \overload      Maps the given \a point from the framebuffer coordinate system to     the coordinate space used by the application, passing the device's     \a screenSize as argument. Note that the default implementation     simply returns the given \a point as it is. */
end_comment
begin_function
DECL|function|mapFromDevice
name|QPoint
name|QScreen
operator|::
name|mapFromDevice
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapToDevice(const QRect&rectangle, const QSize&screenSize) const     \overload      Maps the given \a rectangle from the coordinate space used by the     application to the framebuffer coordinate system, passing the     device's \a screenSize as argument. Note that the default     implementation returns the given \a rectangle as it is. */
end_comment
begin_function
DECL|function|mapToDevice
name|QRect
name|QScreen
operator|::
name|mapToDevice
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapFromDevice(const QRect&rectangle, const QSize&screenSize) const     \overload      Maps the given \a rectangle from the framebuffer coordinate system to     the coordinate space used by the application, passing the device's     \a screenSize as argument. Note that the default implementation     simply returns the given \a rectangle as it is. */
end_comment
begin_function
DECL|function|mapFromDevice
name|QRect
name|QScreen
operator|::
name|mapFromDevice
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapToDevice(const QImage&image) const     \overload      Maps the given \a image from the coordinate space used by the     application to the framebuffer coordinate system. Note that the     default implementation returns the given \a image as it is. */
end_comment
begin_function
DECL|function|mapToDevice
name|QImage
name|QScreen
operator|::
name|mapToDevice
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapFromDevice(const QImage&image) const     \overload      Maps the given \a image from the framebuffer coordinate system to     the coordinate space used by the application. Note that the     default implementation simply returns the given \a image as it is. */
end_comment
begin_function
DECL|function|mapFromDevice
name|QImage
name|QScreen
operator|::
name|mapFromDevice
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapToDevice(const QRegion&region, const QSize&screenSize) const     \overload      Maps the given \a region from the coordinate space used by the     application to the framebuffer coordinate system, passing the     device's \a screenSize as argument. Note that the default     implementation returns the given \a region as it is. */
end_comment
begin_function
DECL|function|mapToDevice
name|QRegion
name|QScreen
operator|::
name|mapToDevice
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::mapFromDevice(const QRegion&region, const QSize&screenSize) const     \overload      Maps the given \a region from the framebuffer coordinate system to     the coordinate space used by the application, passing the device's     \a screenSize as argument. Note that the default implementation     simply returns the given \a region as it is. */
end_comment
begin_function
DECL|function|mapFromDevice
name|QRegion
name|QScreen
operator|::
name|mapFromDevice
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
specifier|const
name|QSize
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScreen::transformOrientation() const      Returns the current rotation as an integer value.      Note that the default implementation returns 0; reimplement this     function to override this value.      \sa isTransformed() */
end_comment
begin_function
DECL|function|transformOrientation
name|int
name|QScreen
operator|::
name|transformOrientation
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pixmapDepth
name|int
name|QScreen
operator|::
name|pixmapDepth
parameter_list|()
specifier|const
block|{
return|return
name|depth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|memoryNeeded
name|int
name|QScreen
operator|::
name|memoryNeeded
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|haltUpdates
name|void
name|QScreen
operator|::
name|haltUpdates
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|resumeUpdates
name|void
name|QScreen
operator|::
name|resumeUpdates
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \fn QRegion QScreen::region() const     \since 4.2      Returns the region covered by this screen driver.      \sa base(), screenSize() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setOffset
name|void
name|QScreen
operator|::
name|setOffset
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|d_ptr
operator|->
name|offset
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the logical offset of the screen, i.e., the offset between     (0,0) in screen coordinates and the application coordinate system. */
end_comment
begin_function
DECL|function|offset
name|QPoint
name|QScreen
operator|::
name|offset
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|offset
return|;
block|}
end_function
begin_if
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
end_if
begin_function
DECL|function|setFrameBufferLittleEndian
name|void
name|QScreen
operator|::
name|setFrameBufferLittleEndian
parameter_list|(
name|bool
name|littleEndian
parameter_list|)
block|{
name|d_ptr
operator|->
name|fb_is_littleEndian
operator|=
name|littleEndian
expr_stmt|;
block|}
end_function
begin_function
DECL|function|frameBufferLittleEndian
name|bool
name|QScreen
operator|::
name|frameBufferLittleEndian
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|fb_is_littleEndian
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn int QScreen::subScreenIndexAt(const QPoint&position) const     \since 4.2      Returns the index of the subscreen at the given \a position;     returns -1 if no screen is found.      The index identifies the subscreen in the list of pointers     returned by the subScreens() function.      \sa instance(), subScreens() */
end_comment
begin_function
DECL|function|subScreenIndexAt
name|int
name|QScreen
operator|::
name|subScreenIndexAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
specifier|const
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|screens
init|=
name|subScreens
argument_list|()
decl_stmt|;
specifier|const
name|int
name|n
init|=
name|screens
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|screens
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|region
argument_list|()
operator|.
name|contains
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|QT_LOADABLE_MODULES
end_ifdef
begin_include
include|#
directive|include
file|<dlfcn.h>
end_include
begin_comment
comment|// ### needs update after driver init changes
end_comment
begin_comment
unit|static QScreen * qt_dodriver(char * driver,char * a,unsigned char * b)  {     char buf[200];     strcpy(buf,"/etc/qws/drivers/");     qstrcpy(buf+17,driver);     qDebug("Attempting driver %s",driver);      void * handle;     handle=dlopen(buf,RTLD_LAZY);     if(handle==0) {         qFatal("Module load error");     }     QScreen *(*qt_get_screen_func)(char *,unsigned char *);     qt_get_screen_func=dlsym(handle,"qt_get_screen");     if(qt_get_screen_func==0) {         qFatal("Couldn't get symbol");     }     QScreen * ret=qt_get_screen_func(a,b);     return ret; }  static QScreen * qt_do_entry(char * entry) {     unsigned char config[256];      FILE * f=fopen(entry,"r");     if(!f) {         return 0;     }      int r=fread(config,256,1,f);     if(r<1)         return 0;      fclose(f);      unsigned short vendorid=*((unsigned short int *)config);     unsigned short deviceid=*(((unsigned short int *)config)+1);     if(config[0xb]!=3)         return 0;      if(vendorid==0x1002) {         if(deviceid==0x4c4d) {             qDebug("Compaq Armada/IBM Thinkpad's Mach64 card");             return qt_dodriver("mach64.so",entry,config);         } else if(deviceid==0x4742) {             qDebug("Desktop Rage Pro Mach64 card");             return qt_dodriver("mach64.so",entry,config);         } else {             qDebug("Unrecognised ATI card id %x",deviceid);             return 0;         }     } else {         qDebug("Unrecognised vendor");     }     return 0; }  extern bool qws_accel;
comment|/// ** NOT SUPPPORTED **
end_comment
begin_else
unit|QScreen * qt_probe_bus() {     if(!qws_accel) {         return qt_dodriver("unaccel.so",0,0);     }      QT_DIR *dirptr = QT_OPENDIR("/proc/bus/pci");     if(!dirptr)         return qt_dodriver("unaccel.so",0,0);     QT_DIR * dirptr2;     QT_DIRENT *cards;      QT_DIRENT *busses = QT_READDIR(dirptr);      while(busses) {         if(busses->d_name[0]!='.') {             char buf[100];             strcpy(buf,"/proc/bus/pci/");             qstrcpy(buf+14,busses->d_name);             int p=strlen(buf);             dirptr2 = QT_OPENDIR(buf);             if(dirptr2) {                 cards = QT_READDIR(dirptr2);                 while(cards) {                     if(cards->d_name[0]!='.') {                         buf[p]='/';                         qstrcpy(buf+p+1,cards->d_name);                         QScreen * ret=qt_do_entry(buf);                         if(ret)                             return ret;                     }                     cards = QT_READDIR(dirptr2);                 }                 QT_CLOSEDIR(dirptr2);             }         }         busses = QT_READDIR(dirptr);     }     QT_CLOSEDIR(dirptr);      return qt_dodriver("unaccel.so",0,0); }
else|#
directive|else
end_else
begin_endif
unit|char *qt_qws_hardcoded_slot = "/proc/bus/pci/01/00.0";  const unsigned char* qt_probe_bus() {     const char * slot;     slot=::getenv("QWS_CARD_SLOT");     if(!slot)         slot=qt_qws_hardcoded_slot;     if (slot) {         static unsigned char config[256];         FILE * f=fopen(slot,"r");         if(!f) {             qDebug("Open failure for %s",slot);             slot=0;         } else {             int r=fread((char*)config,256,1,f);             fclose(f);             if(r<1) {                 qDebug("Read failure");                 return 0;             } else {                 return config;             }         }     }     return 0; }
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// 0
end_comment
begin_comment
comment|/*!     \internal     \since 4.4 */
end_comment
begin_function
DECL|function|setPixmapDataFactory
name|void
name|QScreen
operator|::
name|setPixmapDataFactory
parameter_list|(
name|QPixmapDataFactory
modifier|*
name|factory
parameter_list|)
block|{
specifier|static
name|bool
name|shownWarning
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|shownWarning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QScreen::setPixmapDataFactory() is deprecated - use setGraphicsSystem() instead"
argument_list|)
expr_stmt|;
name|shownWarning
operator|=
literal|true
expr_stmt|;
block|}
name|d_ptr
operator|->
name|pixmapFactory
operator|=
name|factory
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.4 */
end_comment
begin_function
DECL|function|pixmapDataFactory
name|QPixmapDataFactory
modifier|*
name|QScreen
operator|::
name|pixmapDataFactory
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|pixmapFactory
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.5 */
end_comment
begin_function
DECL|function|setGraphicsSystem
name|void
name|QScreen
operator|::
name|setGraphicsSystem
parameter_list|(
name|QGraphicsSystem
modifier|*
name|system
parameter_list|)
block|{
name|d_ptr
operator|->
name|graphicsSystem
operator|=
name|system
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.5 */
end_comment
begin_function
DECL|function|graphicsSystem
name|QGraphicsSystem
modifier|*
name|QScreen
operator|::
name|graphicsSystem
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|graphicsSystem
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the class identifier for the screen object. */
end_comment
begin_function
DECL|function|classId
name|QScreen
operator|::
name|ClassId
name|QScreen
operator|::
name|classId
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|ClassId
argument_list|>
argument_list|(
name|d_ptr
operator|->
name|classId
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
