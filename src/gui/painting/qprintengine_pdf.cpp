begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtGui/qprintengine.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qbitmap.h>
end_include
begin_include
include|#
directive|include
file|<qpainterpath.h>
end_include
begin_include
include|#
directive|include
file|<qpaintdevice.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qimagewriter.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PRINTER
end_ifndef
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_include
include|#
directive|include
file|<zlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qwinfunctions_wince.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qprintengine_pdf_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdrawhelper_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|//#define FONT_DUMP
comment|// might be helpful for smooth transforms of images
comment|// Can't use it though, as gs generates completely wrong images if this is true.
DECL|variable|interpolateImages
specifier|static
specifier|const
name|bool
name|interpolateImages
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_COMPRESS
end_ifdef
begin_decl_stmt
DECL|variable|do_compress
specifier|static
specifier|const
name|bool
name|do_compress
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|do_compress
specifier|static
specifier|const
name|bool
name|do_compress
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QPdfPage
name|QPdfPage
operator|::
name|QPdfPage
parameter_list|()
member_init_list|:
name|QPdf
operator|::
name|ByteStream
argument_list|(
literal|true
argument_list|)
comment|// Enable file backing
block|{ }
end_constructor
begin_function
DECL|function|streamImage
name|void
name|QPdfPage
operator|::
name|streamImage
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|object
parameter_list|)
block|{
operator|*
name|this
operator|<<
name|w
operator|<<
literal|"0 0 "
operator|<<
operator|-
name|h
operator|<<
literal|"0 "
operator|<<
name|h
operator|<<
literal|"cm /Im"
operator|<<
name|object
operator|<<
literal|" Do\n"
expr_stmt|;
if|if
condition|(
operator|!
name|images
operator|.
name|contains
argument_list|(
name|object
argument_list|)
condition|)
name|images
operator|.
name|append
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_pdf_decide_features
specifier|inline
name|QPaintEngine
operator|::
name|PaintEngineFeatures
name|qt_pdf_decide_features
parameter_list|()
block|{
name|QPaintEngine
operator|::
name|PaintEngineFeatures
name|f
init|=
name|QPaintEngine
operator|::
name|AllFeatures
decl_stmt|;
name|f
operator|&=
operator|~
operator|(
name|QPaintEngine
operator|::
name|PorterDuff
operator||
name|QPaintEngine
operator|::
name|PerspectiveTransform
operator||
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
ifndef|#
directive|ifndef
name|USE_NATIVE_GRADIENTS
operator||
name|QPaintEngine
operator|::
name|LinearGradientFill
endif|#
directive|endif
operator||
name|QPaintEngine
operator|::
name|RadialGradientFill
operator||
name|QPaintEngine
operator|::
name|ConicalGradientFill
operator|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_constructor
DECL|function|QPdfEngine
name|QPdfEngine
operator|::
name|QPdfEngine
parameter_list|(
name|QPrinter
operator|::
name|PrinterMode
name|m
parameter_list|)
member_init_list|:
name|QPdfBaseEngine
argument_list|(
operator|*
operator|new
name|QPdfEnginePrivate
argument_list|(
name|m
argument_list|)
argument_list|,
name|qt_pdf_decide_features
argument_list|()
argument_list|)
block|{
name|state
operator|=
name|QPrinter
operator|::
name|Idle
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QPdfEngine
name|QPdfEngine
operator|::
name|~
name|QPdfEngine
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|begin
name|bool
name|QPdfEngine
operator|::
name|begin
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QPdfBaseEngine
operator|::
name|begin
argument_list|(
name|pdev
argument_list|)
condition|)
block|{
name|state
operator|=
name|QPrinter
operator|::
name|Error
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|stream
operator|->
name|setDevice
argument_list|(
name|d
operator|->
name|outDevice
argument_list|)
expr_stmt|;
name|d
operator|->
name|streampos
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|hasPen
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|hasBrush
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|clipEnabled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|allClipped
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|xrefPositions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|pageRoot
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|catalog
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|info
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|graphicsState
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|patternColorSpace
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|pages
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|imageCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|state
operator|=
name|QPrinter
operator|::
name|Active
expr_stmt|;
name|d
operator|->
name|writeHeader
argument_list|()
expr_stmt|;
name|newPage
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|end
name|bool
name|QPdfEngine
operator|::
name|end
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeTail
argument_list|()
expr_stmt|;
name|d
operator|->
name|stream
operator|->
name|unsetDevice
argument_list|()
expr_stmt|;
name|QPdfBaseEngine
operator|::
name|end
argument_list|()
expr_stmt|;
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|state
operator|=
name|QPrinter
operator|::
name|Idle
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|drawPixmap
name|void
name|QPdfEngine
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rectangle
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|)
block|{
if|if
condition|(
name|sr
operator|.
name|isEmpty
argument_list|()
operator|||
name|rectangle
operator|.
name|isEmpty
argument_list|()
operator|||
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
name|QBrush
name|b
init|=
name|d
operator|->
name|brush
decl_stmt|;
name|QRect
name|sourceRect
init|=
name|sr
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|QPixmap
name|pm
init|=
name|sourceRect
operator|!=
name|pixmap
operator|.
name|rect
argument_list|()
condition|?
name|pixmap
operator|.
name|copy
argument_list|(
name|sourceRect
argument_list|)
else|:
name|pixmap
decl_stmt|;
name|QImage
name|image
init|=
name|pm
operator|.
name|toImage
argument_list|()
decl_stmt|;
name|bool
name|bitmap
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|object
init|=
name|d
operator|->
name|addImage
argument_list|(
name|image
argument_list|,
operator|&
name|bitmap
argument_list|,
name|pm
operator|.
name|cacheKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|<
literal|0
condition|)
return|return;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"q\n/GSa gs\n"
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
name|QPdf
operator|::
name|generateMatrix
argument_list|(
name|QTransform
argument_list|(
name|rectangle
operator|.
name|width
argument_list|()
operator|/
name|sr
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rectangle
operator|.
name|height
argument_list|()
operator|/
name|sr
operator|.
name|height
argument_list|()
argument_list|,
name|rectangle
operator|.
name|x
argument_list|()
argument_list|,
name|rectangle
operator|.
name|y
argument_list|()
argument_list|)
operator|*
operator|(
name|d
operator|->
name|simplePen
condition|?
name|QTransform
argument_list|()
else|:
name|d
operator|->
name|stroker
operator|.
name|matrix
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
condition|)
block|{
comment|// set current pen as d->brush
name|d
operator|->
name|brush
operator|=
name|d
operator|->
name|pen
operator|.
name|brush
argument_list|()
expr_stmt|;
block|}
name|setBrush
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentPage
operator|->
name|streamImage
argument_list|(
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|object
argument_list|)
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"Q\n"
expr_stmt|;
name|d
operator|->
name|brush
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawImage
name|void
name|QPdfEngine
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rectangle
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
if|if
condition|(
name|sr
operator|.
name|isEmpty
argument_list|()
operator|||
name|rectangle
operator|.
name|isEmpty
argument_list|()
operator|||
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
name|QRect
name|sourceRect
init|=
name|sr
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|QImage
name|im
init|=
name|sourceRect
operator|!=
name|image
operator|.
name|rect
argument_list|()
condition|?
name|image
operator|.
name|copy
argument_list|(
name|sourceRect
argument_list|)
else|:
name|image
decl_stmt|;
name|bool
name|bitmap
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|object
init|=
name|d
operator|->
name|addImage
argument_list|(
name|im
argument_list|,
operator|&
name|bitmap
argument_list|,
name|im
operator|.
name|cacheKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|<
literal|0
condition|)
return|return;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"q\n/GSa gs\n"
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
name|QPdf
operator|::
name|generateMatrix
argument_list|(
name|QTransform
argument_list|(
name|rectangle
operator|.
name|width
argument_list|()
operator|/
name|sr
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rectangle
operator|.
name|height
argument_list|()
operator|/
name|sr
operator|.
name|height
argument_list|()
argument_list|,
name|rectangle
operator|.
name|x
argument_list|()
argument_list|,
name|rectangle
operator|.
name|y
argument_list|()
argument_list|)
operator|*
operator|(
name|d
operator|->
name|simplePen
condition|?
name|QTransform
argument_list|()
else|:
name|d
operator|->
name|stroker
operator|.
name|matrix
operator|)
argument_list|)
expr_stmt|;
name|setBrush
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentPage
operator|->
name|streamImage
argument_list|(
name|im
operator|.
name|width
argument_list|()
argument_list|,
name|im
operator|.
name|height
argument_list|()
argument_list|,
name|object
argument_list|)
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"Q\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawTiledPixmap
name|void
name|QPdfEngine
operator|::
name|drawTiledPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rectangle
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
name|bool
name|bitmap
init|=
operator|(
name|pixmap
operator|.
name|depth
argument_list|()
operator|==
literal|1
operator|)
decl_stmt|;
name|QBrush
name|b
init|=
name|d
operator|->
name|brush
decl_stmt|;
name|QPointF
name|bo
init|=
name|d
operator|->
name|brushOrigin
decl_stmt|;
name|bool
name|hp
init|=
name|d
operator|->
name|hasPen
decl_stmt|;
name|d
operator|->
name|hasPen
operator|=
literal|false
expr_stmt|;
name|bool
name|hb
init|=
name|d
operator|->
name|hasBrush
decl_stmt|;
name|d
operator|->
name|hasBrush
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|brush
operator|=
name|QBrush
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
condition|)
comment|// #### fix bitmap case where we have a brush pen
name|d
operator|->
name|brush
operator|.
name|setColor
argument_list|(
name|d
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|brushOrigin
operator|=
operator|-
name|point
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"q\n"
expr_stmt|;
name|setBrush
argument_list|()
expr_stmt|;
name|drawRects
argument_list|(
operator|&
name|rectangle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"Q\n"
expr_stmt|;
name|d
operator|->
name|hasPen
operator|=
name|hp
expr_stmt|;
name|d
operator|->
name|hasBrush
operator|=
name|hb
expr_stmt|;
name|d
operator|->
name|brush
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|brushOrigin
operator|=
name|bo
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setBrush
name|void
name|QPdfEngine
operator|::
name|setBrush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|BrushStyle
name|style
init|=
name|d
operator|->
name|brush
operator|.
name|style
argument_list|()
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
name|bool
name|specifyColor
decl_stmt|;
name|int
name|gStateObject
init|=
literal|0
decl_stmt|;
name|int
name|patternObject
init|=
name|d
operator|->
name|addBrushPattern
argument_list|(
name|d
operator|->
name|stroker
operator|.
name|matrix
argument_list|,
operator|&
name|specifyColor
argument_list|,
operator|&
name|gStateObject
argument_list|)
decl_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
operator|(
name|patternObject
condition|?
literal|"/PCSp cs "
else|:
literal|"/CSp cs "
operator|)
expr_stmt|;
if|if
condition|(
name|specifyColor
condition|)
block|{
name|QColor
name|rgba
init|=
name|d
operator|->
name|brush
operator|.
name|color
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|colorMode
operator|==
name|QPrinter
operator|::
name|GrayScale
condition|)
block|{
name|qreal
name|gray
init|=
name|qGray
argument_list|(
name|rgba
operator|.
name|rgba
argument_list|()
argument_list|)
operator|/
literal|255.
decl_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
name|gray
operator|<<
name|gray
operator|<<
name|gray
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|->
name|currentPage
operator|<<
name|rgba
operator|.
name|redF
argument_list|()
operator|<<
name|rgba
operator|.
name|greenF
argument_list|()
operator|<<
name|rgba
operator|.
name|blueF
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|patternObject
condition|)
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"/Pat"
operator|<<
name|patternObject
expr_stmt|;
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"scn\n"
expr_stmt|;
if|if
condition|(
name|gStateObject
condition|)
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"/GState"
operator|<<
name|gStateObject
operator|<<
literal|"gs\n"
expr_stmt|;
else|else
operator|*
name|d
operator|->
name|currentPage
operator|<<
literal|"/GSa gs\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|type
name|QPaintEngine
operator|::
name|Type
name|QPdfEngine
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|QPaintEngine
operator|::
name|Pdf
return|;
block|}
end_function
begin_function
DECL|function|newPage
name|bool
name|QPdfEngine
operator|::
name|newPage
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QPdfEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|newPage
argument_list|()
expr_stmt|;
return|return
name|QPdfBaseEngine
operator|::
name|newPage
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QPdfEnginePrivate
name|QPdfEnginePrivate
operator|::
name|QPdfEnginePrivate
parameter_list|(
name|QPrinter
operator|::
name|PrinterMode
name|m
parameter_list|)
member_init_list|:
name|QPdfBaseEnginePrivate
argument_list|(
name|m
argument_list|)
block|{
name|streampos
operator|=
literal|0
expr_stmt|;
name|stream
operator|=
operator|new
name|QDataStream
expr_stmt|;
name|pageOrder
operator|=
name|QPrinter
operator|::
name|FirstPageFirst
expr_stmt|;
name|orientation
operator|=
name|QPrinter
operator|::
name|Portrait
expr_stmt|;
name|fullPage
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QPdfEnginePrivate
name|QPdfEnginePrivate
operator|::
name|~
name|QPdfEnginePrivate
parameter_list|()
block|{
operator|delete
name|stream
expr_stmt|;
block|}
end_destructor
begin_ifdef
ifdef|#
directive|ifdef
name|USE_NATIVE_GRADIENTS
end_ifdef
begin_function
DECL|function|gradientBrush
name|int
name|QPdfEnginePrivate
operator|::
name|gradientBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|b
parameter_list|,
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|int
modifier|*
name|gStateObject
parameter_list|)
block|{
specifier|const
name|QGradient
modifier|*
name|gradient
init|=
name|b
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|gradient
condition|)
return|return
literal|0
return|;
name|QTransform
name|inv
init|=
name|matrix
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|QPointF
name|page_rect
index|[
literal|4
index|]
init|=
block|{
name|inv
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
block|,
name|inv
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|width_
argument_list|,
literal|0
argument_list|)
argument_list|)
block|,
name|inv
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
name|height_
argument_list|)
argument_list|)
block|,
name|inv
operator|.
name|map
argument_list|(
argument|QPointF(width_, height_)
argument_list|)
block|}
decl_stmt|;
name|bool
name|opaque
init|=
name|b
operator|.
name|isOpaque
argument_list|()
decl_stmt|;
name|QByteArray
name|shader
decl_stmt|;
name|QByteArray
name|alphaShader
decl_stmt|;
if|if
condition|(
name|gradient
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|LinearGradient
condition|)
block|{
specifier|const
name|QLinearGradient
modifier|*
name|lg
init|=
cast|static_cast
argument_list|<
specifier|const
name|QLinearGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
decl_stmt|;
name|shader
operator|=
name|QPdf
operator|::
name|generateLinearGradientShader
argument_list|(
name|lg
argument_list|,
name|page_rect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opaque
condition|)
name|alphaShader
operator|=
name|QPdf
operator|::
name|generateLinearGradientShader
argument_list|(
name|lg
argument_list|,
name|page_rect
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// #############
return|return
literal|0
return|;
block|}
name|int
name|shaderObject
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|shader
argument_list|)
expr_stmt|;
name|QByteArray
name|str
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|s
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
name|s
operator|<<
literal|"<<\n"
literal|"/Type /Pattern\n"
literal|"/PatternType 2\n"
literal|"/Shading "
operator|<<
name|shaderObject
operator|<<
literal|"0 R\n"
literal|"/Matrix ["
operator|<<
name|matrix
operator|.
name|m11
argument_list|()
operator|<<
name|matrix
operator|.
name|m12
argument_list|()
operator|<<
name|matrix
operator|.
name|m21
argument_list|()
operator|<<
name|matrix
operator|.
name|m22
argument_list|()
operator|<<
name|matrix
operator|.
name|dx
argument_list|()
operator|<<
name|matrix
operator|.
name|dy
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
name|s
operator|<<
literal|">>\n"
literal|"endobj\n"
expr_stmt|;
name|int
name|patternObj
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|currentPage
operator|->
name|patterns
operator|.
name|append
argument_list|(
name|patternObj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opaque
condition|)
block|{
name|bool
name|ca
init|=
literal|true
decl_stmt|;
name|QGradientStops
name|stops
init|=
name|gradient
operator|->
name|stops
argument_list|()
decl_stmt|;
name|int
name|a
init|=
name|stops
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|second
operator|.
name|alpha
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|stops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|stops
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
operator|.
name|alpha
argument_list|()
operator|!=
name|a
condition|)
block|{
name|ca
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ca
condition|)
block|{
operator|*
name|gStateObject
operator|=
name|addConstantAlphaObject
argument_list|(
name|stops
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|second
operator|.
name|alpha
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|alphaShaderObject
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|alphaShader
argument_list|)
expr_stmt|;
name|QByteArray
name|content
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|c
argument_list|(
operator|&
name|content
argument_list|)
decl_stmt|;
name|c
operator|<<
literal|"/Shader"
operator|<<
name|alphaShaderObject
operator|<<
literal|"sh\n"
expr_stmt|;
name|QByteArray
name|form
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|f
argument_list|(
operator|&
name|form
argument_list|)
decl_stmt|;
name|f
operator|<<
literal|"<<\n"
literal|"/Type /XObject\n"
literal|"/Subtype /Form\n"
literal|"/BBox [0 0 "
operator|<<
name|width_
operator|<<
name|height_
operator|<<
literal|"]\n"
literal|"/Group<</S /Transparency>>\n"
literal|"/Resources<<\n"
literal|"/Shading<< /Shader"
operator|<<
name|alphaShaderObject
operator|<<
name|alphaShaderObject
operator|<<
literal|"0 R>>\n"
literal|">>\n"
expr_stmt|;
name|f
operator|<<
literal|"/Length "
operator|<<
name|content
operator|.
name|length
argument_list|()
operator|<<
literal|"\n"
literal|">>\n"
literal|"stream\n"
operator|<<
name|content
operator|<<
literal|"endstream\n"
literal|"endobj\n"
expr_stmt|;
name|int
name|softMaskFormObject
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|form
argument_list|)
expr_stmt|;
operator|*
name|gStateObject
operator|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xprintf
argument_list|(
literal|"<< /SMask<< /S /Alpha /G %d 0 R>>>>\n"
literal|"endobj\n"
argument_list|,
name|softMaskFormObject
argument_list|)
expr_stmt|;
name|currentPage
operator|->
name|graphicStates
operator|.
name|append
argument_list|(
operator|*
name|gStateObject
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|patternObj
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|addConstantAlphaObject
name|int
name|QPdfEnginePrivate
operator|::
name|addConstantAlphaObject
parameter_list|(
name|int
name|brushAlpha
parameter_list|,
name|int
name|penAlpha
parameter_list|)
block|{
if|if
condition|(
name|brushAlpha
operator|==
literal|255
operator|&&
name|penAlpha
operator|==
literal|255
condition|)
return|return
literal|0
return|;
name|int
name|object
init|=
name|alphaCache
operator|.
name|value
argument_list|(
name|QPair
argument_list|<
name|uint
argument_list|,
name|uint
argument_list|>
argument_list|(
name|brushAlpha
argument_list|,
name|penAlpha
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
block|{
name|object
operator|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QByteArray
name|alphaDef
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|s
argument_list|(
operator|&
name|alphaDef
argument_list|)
decl_stmt|;
name|s
operator|<<
literal|"<<\n/ca "
operator|<<
operator|(
name|brushAlpha
operator|/
name|qreal
argument_list|(
literal|255.
argument_list|)
operator|)
operator|<<
literal|'\n'
expr_stmt|;
name|s
operator|<<
literal|"/CA "
operator|<<
operator|(
name|penAlpha
operator|/
name|qreal
argument_list|(
literal|255.
argument_list|)
operator|)
operator|<<
literal|"\n>>"
expr_stmt|;
name|xprintf
argument_list|(
literal|"%s\nendobj\n"
argument_list|,
name|alphaDef
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|alphaCache
operator|.
name|insert
argument_list|(
name|QPair
argument_list|<
name|uint
argument_list|,
name|uint
argument_list|>
argument_list|(
name|brushAlpha
argument_list|,
name|penAlpha
argument_list|)
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentPage
operator|->
name|graphicStates
operator|.
name|indexOf
argument_list|(
name|object
argument_list|)
operator|<
literal|0
condition|)
name|currentPage
operator|->
name|graphicStates
operator|.
name|append
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
end_function
begin_function
DECL|function|addBrushPattern
name|int
name|QPdfEnginePrivate
operator|::
name|addBrushPattern
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|,
name|bool
modifier|*
name|specifyColor
parameter_list|,
name|int
modifier|*
name|gStateObject
parameter_list|)
block|{
name|int
name|paintType
init|=
literal|2
decl_stmt|;
comment|// Uncolored tiling
name|int
name|w
init|=
literal|8
decl_stmt|;
name|int
name|h
init|=
literal|8
decl_stmt|;
operator|*
name|specifyColor
operator|=
literal|true
expr_stmt|;
operator|*
name|gStateObject
operator|=
literal|0
expr_stmt|;
name|QTransform
name|matrix
init|=
name|m
decl_stmt|;
name|matrix
operator|.
name|translate
argument_list|(
name|brushOrigin
operator|.
name|x
argument_list|()
argument_list|,
name|brushOrigin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|matrix
operator|=
name|matrix
operator|*
name|pageMatrix
argument_list|()
expr_stmt|;
comment|//qDebug()<< brushOrigin<< matrix;
name|Qt
operator|::
name|BrushStyle
name|style
init|=
name|brush
operator|.
name|style
argument_list|()
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
condition|)
block|{
comment|//&& style<= Qt::ConicalGradientPattern) {
ifdef|#
directive|ifdef
name|USE_NATIVE_GRADIENTS
operator|*
name|specifyColor
operator|=
literal|false
expr_stmt|;
return|return
name|gradientBrush
argument_list|(
name|b
argument_list|,
name|matrix
argument_list|,
name|gStateObject
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|!
name|brush
operator|.
name|isOpaque
argument_list|()
operator|&&
name|brush
operator|.
name|style
argument_list|()
operator|<
name|Qt
operator|::
name|LinearGradientPattern
operator|)
operator|||
name|opacity
operator|!=
literal|1.0
condition|)
operator|*
name|gStateObject
operator|=
name|addConstantAlphaObject
argument_list|(
name|qRound
argument_list|(
name|brush
operator|.
name|color
argument_list|()
operator|.
name|alpha
argument_list|()
operator|*
name|opacity
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|pen
operator|.
name|color
argument_list|()
operator|.
name|alpha
argument_list|()
operator|*
name|opacity
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|imageObject
init|=
operator|-
literal|1
decl_stmt|;
name|QByteArray
name|pattern
init|=
name|QPdf
operator|::
name|patternForBrush
argument_list|(
name|brush
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|TexturePattern
condition|)
return|return
literal|0
return|;
name|QImage
name|image
init|=
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|toImage
argument_list|()
decl_stmt|;
name|bool
name|bitmap
init|=
literal|true
decl_stmt|;
name|imageObject
operator|=
name|addImage
argument_list|(
name|image
argument_list|,
operator|&
name|bitmap
argument_list|,
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|cacheKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageObject
operator|!=
operator|-
literal|1
condition|)
block|{
name|QImage
operator|::
name|Format
name|f
init|=
name|image
operator|.
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|!=
name|QImage
operator|::
name|Format_MonoLSB
operator|&&
name|f
operator|!=
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
name|paintType
operator|=
literal|1
expr_stmt|;
comment|// Colored tiling
operator|*
name|specifyColor
operator|=
literal|false
expr_stmt|;
block|}
name|w
operator|=
name|image
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|image
operator|.
name|height
argument_list|()
expr_stmt|;
name|QTransform
name|m
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
name|h
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|s
argument_list|(
operator|&
name|pattern
argument_list|)
decl_stmt|;
name|s
operator|<<
name|QPdf
operator|::
name|generateMatrix
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|s
operator|<<
literal|"/Im"
operator|<<
name|imageObject
operator|<<
literal|" Do\n"
expr_stmt|;
block|}
block|}
name|QByteArray
name|str
decl_stmt|;
name|QPdf
operator|::
name|ByteStream
name|s
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
name|s
operator|<<
literal|"<<\n"
literal|"/Type /Pattern\n"
literal|"/PatternType 1\n"
literal|"/PaintType "
operator|<<
name|paintType
operator|<<
literal|"\n"
literal|"/TilingType 1\n"
literal|"/BBox [0 0 "
operator|<<
name|w
operator|<<
name|h
operator|<<
literal|"]\n"
literal|"/XStep "
operator|<<
name|w
operator|<<
literal|"\n"
literal|"/YStep "
operator|<<
name|h
operator|<<
literal|"\n"
literal|"/Matrix ["
operator|<<
name|matrix
operator|.
name|m11
argument_list|()
operator|<<
name|matrix
operator|.
name|m12
argument_list|()
operator|<<
name|matrix
operator|.
name|m21
argument_list|()
operator|<<
name|matrix
operator|.
name|m22
argument_list|()
operator|<<
name|matrix
operator|.
name|dx
argument_list|()
operator|<<
name|matrix
operator|.
name|dy
argument_list|()
operator|<<
literal|"]\n"
literal|"/Resources \n<< "
expr_stmt|;
comment|// open resource tree
if|if
condition|(
name|imageObject
operator|>
literal|0
condition|)
block|{
name|s
operator|<<
literal|"/XObject<< /Im"
operator|<<
name|imageObject
operator|<<
literal|' '
operator|<<
name|imageObject
operator|<<
literal|"0 R>> "
expr_stmt|;
block|}
name|s
operator|<<
literal|">>\n"
literal|"/Length "
operator|<<
name|pattern
operator|.
name|length
argument_list|()
operator|<<
literal|"\n"
literal|">>\n"
literal|"stream\n"
operator|<<
name|pattern
operator|<<
literal|"endstream\n"
literal|"endobj\n"
expr_stmt|;
name|int
name|patternObj
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|currentPage
operator|->
name|patterns
operator|.
name|append
argument_list|(
name|patternObj
argument_list|)
expr_stmt|;
return|return
name|patternObj
return|;
block|}
end_function
begin_comment
comment|/*!  * Adds an image to the pdf and return the pdf-object id. Returns -1 if adding the image failed.  */
end_comment
begin_function
DECL|function|addImage
name|int
name|QPdfEnginePrivate
operator|::
name|addImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|bool
modifier|*
name|bitmap
parameter_list|,
name|qint64
name|serial_no
parameter_list|)
block|{
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|object
init|=
name|imageCache
operator|.
name|value
argument_list|(
name|serial_no
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
condition|)
return|return
name|object
return|;
name|QImage
name|image
init|=
name|img
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|image
operator|.
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
operator|&&
operator|*
name|bitmap
operator|&&
name|img
operator|.
name|colorTable
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|img
operator|.
name|colorTable
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
operator|.
name|rgba
argument_list|()
operator|&&
name|img
operator|.
name|colorTable
argument_list|()
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QColor
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
operator|.
name|rgba
argument_list|()
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_Mono
argument_list|)
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format_Mono
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bitmap
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB32
operator|&&
name|format
operator|!=
name|QImage
operator|::
name|Format_ARGB32
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32
expr_stmt|;
block|}
block|}
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|d
init|=
name|image
operator|.
name|depth
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
name|int
name|bytesPerLine
init|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|QByteArray
name|data
decl_stmt|;
name|data
operator|.
name|resize
argument_list|(
name|bytesPerLine
operator|*
name|h
argument_list|)
expr_stmt|;
name|char
modifier|*
name|rawdata
init|=
name|data
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|memcpy
argument_list|(
name|rawdata
argument_list|,
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|bytesPerLine
argument_list|)
expr_stmt|;
name|rawdata
operator|+=
name|bytesPerLine
expr_stmt|;
block|}
name|object
operator|=
name|writeImage
argument_list|(
name|data
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QByteArray
name|softMaskData
decl_stmt|;
name|bool
name|dct
init|=
literal|false
decl_stmt|;
name|QByteArray
name|imageData
decl_stmt|;
name|bool
name|hasAlpha
init|=
literal|false
decl_stmt|;
name|bool
name|hasMask
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|QImageWriter
operator|::
name|supportedImageFormats
argument_list|()
operator|.
name|contains
argument_list|(
literal|"jpeg"
argument_list|)
operator|&&
name|colorMode
operator|!=
name|QPrinter
operator|::
name|GrayScale
condition|)
block|{
name|QBuffer
name|buffer
argument_list|(
operator|&
name|imageData
argument_list|)
decl_stmt|;
name|QImageWriter
name|writer
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"jpeg"
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setQuality
argument_list|(
literal|94
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|dct
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
name|softMaskData
operator|.
name|resize
argument_list|(
name|w
operator|*
name|h
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|sdata
init|=
operator|(
name|uchar
operator|*
operator|)
name|softMaskData
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|rgb
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|uchar
name|alpha
init|=
name|qAlpha
argument_list|(
operator|*
name|rgb
argument_list|)
decl_stmt|;
operator|*
name|sdata
operator|++
operator|=
name|alpha
expr_stmt|;
name|hasMask
operator||=
operator|(
name|alpha
operator|<
literal|255
operator|)
expr_stmt|;
name|hasAlpha
operator||=
operator|(
name|alpha
operator|!=
literal|0
operator|&&
name|alpha
operator|!=
literal|255
operator|)
expr_stmt|;
operator|++
name|rgb
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|imageData
operator|.
name|resize
argument_list|(
name|colorMode
operator|==
name|QPrinter
operator|::
name|GrayScale
condition|?
name|w
operator|*
name|h
else|:
literal|3
operator|*
name|w
operator|*
name|h
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|data
init|=
operator|(
name|uchar
operator|*
operator|)
name|imageData
operator|.
name|data
argument_list|()
decl_stmt|;
name|softMaskData
operator|.
name|resize
argument_list|(
name|w
operator|*
name|h
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|sdata
init|=
operator|(
name|uchar
operator|*
operator|)
name|softMaskData
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|rgb
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorMode
operator|==
name|QPrinter
operator|::
name|GrayScale
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|qGray
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
name|uchar
name|alpha
init|=
name|qAlpha
argument_list|(
operator|*
name|rgb
argument_list|)
decl_stmt|;
operator|*
name|sdata
operator|++
operator|=
name|alpha
expr_stmt|;
name|hasMask
operator||=
operator|(
name|alpha
operator|<
literal|255
operator|)
expr_stmt|;
name|hasAlpha
operator||=
operator|(
name|alpha
operator|!=
literal|0
operator|&&
name|alpha
operator|!=
literal|255
operator|)
expr_stmt|;
operator|++
name|rgb
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|qRed
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|qGreen
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|qBlue
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
name|uchar
name|alpha
init|=
name|qAlpha
argument_list|(
operator|*
name|rgb
argument_list|)
decl_stmt|;
operator|*
name|sdata
operator|++
operator|=
name|alpha
expr_stmt|;
name|hasMask
operator||=
operator|(
name|alpha
operator|<
literal|255
operator|)
expr_stmt|;
name|hasAlpha
operator||=
operator|(
name|alpha
operator|!=
literal|0
operator|&&
name|alpha
operator|!=
literal|255
operator|)
expr_stmt|;
operator|++
name|rgb
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
name|hasAlpha
operator|=
name|hasMask
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|maskObject
init|=
literal|0
decl_stmt|;
name|int
name|softMaskObject
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasAlpha
condition|)
block|{
name|softMaskObject
operator|=
name|writeImage
argument_list|(
name|softMaskData
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasMask
condition|)
block|{
comment|// dither the soft mask to 1bit and add it. This also helps PDF viewers
comment|// without transparency support
name|int
name|bytesPerLine
init|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|QByteArray
name|mask
argument_list|(
name|bytesPerLine
operator|*
name|h
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|mdata
init|=
operator|(
name|uchar
operator|*
operator|)
name|mask
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sdata
init|=
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|softMaskData
operator|.
name|constData
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|*
name|sdata
condition|)
name|mdata
index|[
name|x
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
operator|++
name|sdata
expr_stmt|;
block|}
name|mdata
operator|+=
name|bytesPerLine
expr_stmt|;
block|}
name|maskObject
operator|=
name|writeImage
argument_list|(
name|mask
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|object
operator|=
name|writeImage
argument_list|(
name|imageData
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|colorMode
operator|==
name|QPrinter
operator|::
name|GrayScale
condition|?
literal|8
else|:
literal|32
argument_list|,
name|maskObject
argument_list|,
name|softMaskObject
argument_list|,
name|dct
argument_list|)
expr_stmt|;
block|}
name|imageCache
operator|.
name|insert
argument_list|(
name|serial_no
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
end_function
begin_function
DECL|function|drawTextItem
name|void
name|QPdfEnginePrivate
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItemInt
modifier|&
name|ti
parameter_list|)
block|{
if|if
condition|(
name|ti
operator|.
name|charFormat
operator|.
name|isAnchor
argument_list|()
condition|)
block|{
name|qreal
name|size
init|=
name|ti
operator|.
name|fontEngine
operator|->
name|fontDef
operator|.
name|pixelSize
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_WIN
if|if
condition|(
name|ti
operator|.
name|fontEngine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Win
condition|)
block|{
name|QFontEngineWin
modifier|*
name|fe
init|=
cast|static_cast
argument_list|<
name|QFontEngineWin
operator|*
argument_list|>
argument_list|(
name|ti
operator|.
name|fontEngine
argument_list|)
decl_stmt|;
name|size
operator|=
name|fe
operator|->
name|tm
operator|.
name|tmHeight
expr_stmt|;
block|}
endif|#
directive|endif
name|int
name|synthesized
init|=
name|ti
operator|.
name|fontEngine
operator|->
name|synthesized
argument_list|()
decl_stmt|;
name|qreal
name|stretch
init|=
name|synthesized
operator|&
name|QFontEngine
operator|::
name|SynthesizedStretch
condition|?
name|ti
operator|.
name|fontEngine
operator|->
name|fontDef
operator|.
name|stretch
operator|/
literal|100.
else|:
literal|1.
decl_stmt|;
name|QTransform
name|trans
decl_stmt|;
comment|// Build text rendering matrix (Trm). We need it to map the text area to user
comment|// space units on the PDF page.
name|trans
operator|=
name|QTransform
argument_list|(
name|size
operator|*
name|stretch
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Apply text matrix (Tm).
name|trans
operator|*=
name|QTransform
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Apply page displacement (Identity for first page).
name|trans
operator|*=
name|stroker
operator|.
name|matrix
expr_stmt|;
comment|// Apply Current Transformation Matrix (CTM)
name|trans
operator|*=
name|pageMatrix
argument_list|()
expr_stmt|;
name|qreal
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|trans
operator|.
name|map
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|trans
operator|.
name|map
argument_list|(
name|ti
operator|.
name|width
operator|.
name|toReal
argument_list|()
operator|/
name|size
argument_list|,
operator|(
name|ti
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
operator|-
name|ti
operator|.
name|descent
operator|.
name|toReal
argument_list|()
operator|)
operator|/
name|size
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|uint
name|annot
init|=
name|addXrefEntry
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_DEBUG_PDF_LINKS
name|xprintf
argument_list|(
literal|"<<\n/Type /Annot\n/Subtype /Link\n/Rect [%f %f %f %f]\n/Border [16 16 1]\n/A<<\n"
argument_list|,
else|#
directive|else
argument|xprintf(
literal|"<<\n/Type /Annot\n/Subtype /Link\n/Rect [%f %f %f %f]\n/Border [0 0 0]\n/A<<\n"
argument|,
endif|#
directive|endif
argument|static_cast<double>(x1),                 static_cast<double>(y1),                 static_cast<double>(x2),                 static_cast<double>(y2));         xprintf(
literal|"/Type /Action\n/S /URI\n/URI (%s)\n"
argument|,                 ti.charFormat.anchorHref().toLatin1().constData());         xprintf(
literal|">>\n>>\n"
argument|);         xprintf(
literal|"endobj\n"
argument|);          if (!currentPage->annotations.contains(annot)) {             currentPage->annotations.append(annot);         }     }      QPdfBaseEnginePrivate::drawTextItem(p, ti); }  QTransform QPdfEnginePrivate::pageMatrix() const {     qreal scale =
literal|72.
argument|/resolution;     QTransform tmp(scale,
literal|0.0
argument|,
literal|0.0
argument|, -scale,
literal|0.0
argument|, height());     if (!fullPage) {         QRect r = pageRect();         tmp.translate(r.left(), r.top());     }     return tmp; }  void QPdfEnginePrivate::newPage() {     if (currentPage&& currentPage->pageSize.isEmpty())         currentPage->pageSize = QSize(width(), height());     writePage();      delete currentPage;     currentPage = new QPdfPage;     currentPage->pageSize = QSize(width(), height());     stroker.stream = currentPage;     pages.append(requestObject());      *currentPage<<
literal|"/GSa gs /CSp cs /CSp CS\n"
argument|<< QPdf::generateMatrix(pageMatrix())<<
literal|"q q\n"
argument|; }
comment|// For strings up to 10000 bytes only !
argument|void QPdfEnginePrivate::xprintf(const char* fmt, ...) {     if (!stream)         return;      const int msize =
literal|10000
argument|;     char buf[msize];      va_list args;     va_start(args, fmt);     int bufsize = qvsnprintf(buf, msize, fmt, args);      Q_ASSERT(bufsize<msize);      va_end(args);      stream->writeRawData(buf, bufsize);     streampos += bufsize; }  int QPdfEnginePrivate::writeCompressed(QIODevice *dev) {
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
argument|if (do_compress) {         int size = QPdfPage::chunkSize();         int sum =
literal|0
argument|;         ::z_stream zStruct;         zStruct.zalloc = Z_NULL;         zStruct.zfree = Z_NULL;         zStruct.opaque = Z_NULL;         if (::deflateInit(&zStruct, Z_DEFAULT_COMPRESSION) != Z_OK) {             qWarning(
literal|"QPdfStream::writeCompressed: Error in deflateInit()"
argument|);             return sum;         }         zStruct.avail_in =
literal|0
argument|;         QByteArray in
argument_list|,
argument|out;         out.resize(size);         while (!dev->atEnd() || zStruct.avail_in !=
literal|0
argument|) {             if (zStruct.avail_in ==
literal|0
argument|) {                 in = dev->read(size);                 zStruct.avail_in = in.size();                 zStruct.next_in = reinterpret_cast<unsigned char*>(in.data());                 if (in.size()<=
literal|0
argument|) {                     qWarning(
literal|"QPdfStream::writeCompressed: Error in read()"
argument|);                     ::deflateEnd(&zStruct);                     return sum;                 }             }             zStruct.next_out = reinterpret_cast<unsigned char*>(out.data());             zStruct.avail_out = out.size();             if (::deflate(&zStruct,
literal|0
argument|) != Z_OK) {                 qWarning(
literal|"QPdfStream::writeCompressed: Error in deflate()"
argument|);                 ::deflateEnd(&zStruct);                 return sum;             }             int written = out.size() - zStruct.avail_out;             stream->writeRawData(out.constData(), written);             streampos += written;             sum += written;         }         int ret;         do {             zStruct.next_out = reinterpret_cast<unsigned char*>(out.data());             zStruct.avail_out = out.size();             ret = ::deflate(&zStruct, Z_FINISH);             if (ret != Z_OK&& ret != Z_STREAM_END) {                 qWarning(
literal|"QPdfStream::writeCompressed: Error in deflate()"
argument|);                 ::deflateEnd(&zStruct);                 return sum;             }             int written = out.size() - zStruct.avail_out;             stream->writeRawData(out.constData(), written);             streampos += written;             sum += written;         } while (ret == Z_OK);          ::deflateEnd(&zStruct);          return sum;     } else
endif|#
directive|endif
argument|{         QByteArray arr;         int sum =
literal|0
argument|;         while (!dev->atEnd()) {             arr = dev->read(QPdfPage::chunkSize());             stream->writeRawData(arr.constData(), arr.size());             streampos += arr.size();             sum += arr.size();         }         return sum;     } }  int QPdfEnginePrivate::writeCompressed(const char *src, int len) {
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
argument|if(do_compress) {         uLongf destLen = len + len/
literal|100
argument|+
literal|13
argument|;
comment|// zlib requirement
argument|Bytef* dest = new Bytef[destLen];         if (Z_OK == ::compress(dest,&destLen, (const Bytef*) src, (uLongf)len)) {             stream->writeRawData((const char*)dest, destLen);         } else {             qWarning(
literal|"QPdfStream::writeCompressed: Error in compress()"
argument|);             destLen =
literal|0
argument|;         }         delete [] dest;         len = destLen;     } else
endif|#
directive|endif
argument|{         stream->writeRawData(src,len);     }     streampos += len;     return len; }  int QPdfEnginePrivate::writeImage(const QByteArray&data, int width, int height, int depth,                                   int maskObject, int softMaskObject, bool dct) {     int image = addXrefEntry(-
literal|1
argument|);     xprintf(
literal|"<<\n"
literal|"/Type /XObject\n"
literal|"/Subtype /Image\n"
literal|"/Width %d\n"
literal|"/Height %d\n"
argument|, width, height);      if (depth ==
literal|1
argument|) {         xprintf(
literal|"/ImageMask true\n"
literal|"/Decode [1 0]\n"
argument|);     } else {         xprintf(
literal|"/BitsPerComponent 8\n"
literal|"/ColorSpace %s\n"
argument|, (depth ==
literal|32
argument|) ?
literal|"/DeviceRGB"
argument|:
literal|"/DeviceGray"
argument|);     }     if (maskObject>
literal|0
argument|)         xprintf(
literal|"/Mask %d 0 R\n"
argument|, maskObject);     if (softMaskObject>
literal|0
argument|)         xprintf(
literal|"/SMask %d 0 R\n"
argument|, softMaskObject);      int lenobj = requestObject();     xprintf(
literal|"/Length %d 0 R\n"
argument|, lenobj);     if (interpolateImages)         xprintf(
literal|"/Interpolate true\n"
argument|);     int len =
literal|0
argument|;     if (dct) {
comment|//qDebug()<< "DCT";
argument|xprintf(
literal|"/Filter /DCTDecode\n>>\nstream\n"
argument|);         write(data);         len = data.length();     } else {         if (do_compress)             xprintf(
literal|"/Filter /FlateDecode\n>>\nstream\n"
argument|);         else             xprintf(
literal|">>\nstream\n"
argument|);         len = writeCompressed(data);     }     xprintf(
literal|"endstream\n"
literal|"endobj\n"
argument|);     addXrefEntry(lenobj);     xprintf(
literal|"%d\n"
literal|"endobj\n"
argument|, len);     return image; }   void QPdfEnginePrivate::writeHeader() {     addXrefEntry(
literal|0
argument|,
literal|false
argument|);      xprintf(
literal|"%%PDF-1.4\n"
argument|);      writeInfo();      catalog = addXrefEntry(-
literal|1
argument|);     pageRoot = requestObject();     xprintf(
literal|"<<\n"
literal|"/Type /Catalog\n"
literal|"/Pages %d 0 R\n"
literal|">>\n"
literal|"endobj\n"
argument|, pageRoot);
comment|// graphics state
argument|graphicsState = addXrefEntry(-
literal|1
argument|);     xprintf(
literal|"<<\n"
literal|"/Type /ExtGState\n"
literal|"/SA true\n"
literal|"/SM 0.02\n"
literal|"/ca 1.0\n"
literal|"/CA 1.0\n"
literal|"/AIS false\n"
literal|"/SMask /None"
literal|">>\n"
literal|"endobj\n"
argument|);
comment|// color space for pattern
argument|patternColorSpace = addXrefEntry(-
literal|1
argument|);     xprintf(
literal|"[/Pattern /DeviceRGB]\n"
literal|"endobj\n"
argument|); }  void QPdfEnginePrivate::writeInfo() {     info = addXrefEntry(-
literal|1
argument|);     xprintf(
literal|"<<\n/Title "
argument|);     printString(title);     xprintf(
literal|"\n/Creator "
argument|);     printString(creator);     xprintf(
literal|"\n/Producer "
argument|);     printString(QString::fromLatin1(
literal|"Qt "
argument|QT_VERSION_STR
literal|" (C) 2011 Nokia Corporation and/or its subsidiary(-ies)"
argument|));     QDateTime now = QDateTime::currentDateTime().toUTC();     QTime t = now.time();     QDate d = now.date();     xprintf(
literal|"\n/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
argument|,             d.year(),             d.month(),             d.day(),             t.hour(),             t.minute(),             t.second());     xprintf(
literal|">>\n"
literal|"endobj\n"
argument|); }  void QPdfEnginePrivate::writePageRoot() {     addXrefEntry(pageRoot);      xprintf(
literal|"<<\n"
literal|"/Type /Pages\n"
literal|"/Kids \n"
literal|"[\n"
argument|);     int size = pages.size();     for (int i =
literal|0
argument|; i< size; ++i)         xprintf(
literal|"%d 0 R\n"
argument|, pages[i]);     xprintf(
literal|"]\n"
argument|);
comment|//xprintf("/Group<</S /Transparency /I true /K false>>\n");
argument|xprintf(
literal|"/Count %d\n"
argument|, pages.size());      xprintf(
literal|"/ProcSet [/PDF /Text /ImageB /ImageC]\n"
literal|">>\n"
literal|"endobj\n"
argument|); }   void QPdfEnginePrivate::embedFont(QFontSubset *font) {
comment|//qDebug()<< "embedFont"<< font->object_id;
argument|int fontObject = font->object_id;     QByteArray fontData = font->toTruetype();
ifdef|#
directive|ifdef
name|FONT_DUMP
argument|static int i =
literal|0
argument|;     QString fileName(
literal|"font%1.ttf"
argument|);     fileName = fileName.arg(i++);     QFile ff(fileName);     ff.open(QFile::WriteOnly);     ff.write(fontData);     ff.close();
endif|#
directive|endif
argument|int fontDescriptor = requestObject();     int fontstream = requestObject();     int cidfont = requestObject();     int toUnicode = requestObject();      QFontEngine::Properties properties = font->fontEngine->properties();      {         qreal scale =
literal|1000
argument|/properties.emSquare.toReal();         addXrefEntry(fontDescriptor);         QByteArray descriptor;         QPdf::ByteStream s(&descriptor);         s<<
literal|"<< /Type /FontDescriptor\n"
literal|"/FontName /Q"
argument|;         int tag = fontDescriptor;         for (int i =
literal|0
argument|; i<
literal|5
argument|; ++i) {             s<< (char)(
literal|'A'
argument|+ (tag %
literal|26
argument|));             tag /=
literal|26
argument|;         }         s<<
literal|'+'
argument|<< properties.postscriptName<<
literal|"\n"
literal|"/Flags "
argument|<<
literal|4
argument|<<
literal|"\n"
literal|"/FontBBox ["
argument|<< properties.boundingBox.x()*scale<< -(properties.boundingBox.y() + properties.boundingBox.height())*scale<< (properties.boundingBox.x() + properties.boundingBox.width())*scale<< -properties.boundingBox.y()*scale<<
literal|"]\n"
literal|"/ItalicAngle "
argument|<< properties.italicAngle.toReal()<<
literal|"\n"
literal|"/Ascent "
argument|<< properties.ascent.toReal()*scale<<
literal|"\n"
literal|"/Descent "
argument|<< -properties.descent.toReal()*scale<<
literal|"\n"
literal|"/CapHeight "
argument|<< properties.capHeight.toReal()*scale<<
literal|"\n"
literal|"/StemV "
argument|<< properties.lineWidth.toReal()*scale<<
literal|"\n"
literal|"/FontFile2 "
argument|<< fontstream<<
literal|"0 R\n"
literal|">> endobj\n"
argument|;         write(descriptor);     }     {         addXrefEntry(fontstream);         QByteArray header;         QPdf::ByteStream s(&header);          int length_object = requestObject();         s<<
literal|"<<\n"
literal|"/Length1 "
argument|<< fontData.size()<<
literal|"\n"
literal|"/Length "
argument|<< length_object<<
literal|"0 R\n"
argument|;         if (do_compress)             s<<
literal|"/Filter /FlateDecode\n"
argument|;         s<<
literal|">>\n"
literal|"stream\n"
argument|;         write(header);         int len = writeCompressed(fontData);         write(
literal|"endstream\n"
literal|"endobj\n"
argument|);         addXrefEntry(length_object);         xprintf(
literal|"%d\n"
literal|"endobj\n"
argument|, len);     }     {         addXrefEntry(cidfont);         QByteArray cid;         QPdf::ByteStream s(&cid);         s<<
literal|"<< /Type /Font\n"
literal|"/Subtype /CIDFontType2\n"
literal|"/BaseFont /"
argument|<< properties.postscriptName<<
literal|"\n"
literal|"/CIDSystemInfo<< /Registry (Adobe) /Ordering (Identity) /Supplement 0>>\n"
literal|"/FontDescriptor "
argument|<< fontDescriptor<<
literal|"0 R\n"
literal|"/CIDToGIDMap /Identity\n"
argument|<< font->widthArray()<<
literal|">>\n"
literal|"endobj\n"
argument|;         write(cid);     }     {         addXrefEntry(toUnicode);         QByteArray touc = font->createToUnicodeMap();         xprintf(
literal|"<< /Length %d>>\n"
literal|"stream\n"
argument|, touc.length());         write(touc);         write(
literal|"endstream\n"
literal|"endobj\n"
argument|);     }     {         addXrefEntry(fontObject);         QByteArray font;         QPdf::ByteStream s(&font);         s<<
literal|"<< /Type /Font\n"
literal|"/Subtype /Type0\n"
literal|"/BaseFont /"
argument|<< properties.postscriptName<<
literal|"\n"
literal|"/Encoding /Identity-H\n"
literal|"/DescendantFonts ["
argument|<< cidfont<<
literal|"0 R]\n"
literal|"/ToUnicode "
argument|<< toUnicode<<
literal|"0 R"
literal|">>\n"
literal|"endobj\n"
argument|;         write(font);     } }   void QPdfEnginePrivate::writeFonts() {     for (QHash<QFontEngine::FaceId, QFontSubset *>::iterator it = fonts.begin(); it != fonts.end(); ++it) {         embedFont(*it);         delete *it;     }     fonts.clear(); }  void QPdfEnginePrivate::writePage() {     if (pages.empty())         return;      *currentPage<<
literal|"Q Q\n"
argument|;      uint pageStream = requestObject();     uint pageStreamLength = requestObject();     uint resources = requestObject();     uint annots = requestObject();      addXrefEntry(pages.last());     xprintf(
literal|"<<\n"
literal|"/Type /Page\n"
literal|"/Parent %d 0 R\n"
literal|"/Contents %d 0 R\n"
literal|"/Resources %d 0 R\n"
literal|"/Annots %d 0 R\n"
literal|"/MediaBox [0 0 %d %d]\n"
literal|">>\n"
literal|"endobj\n"
argument|,             pageRoot, pageStream, resources, annots,
comment|// make sure we use the pagesize from when we started the page, since the user may have changed it
argument|currentPage->pageSize.width(), currentPage->pageSize.height());      addXrefEntry(resources);     xprintf(
literal|"<<\n"
literal|"/ColorSpace<<\n"
literal|"/PCSp %d 0 R\n"
literal|"/CSp /DeviceRGB\n"
literal|"/CSpg /DeviceGray\n"
literal|">>\n"
literal|"/ExtGState<<\n"
literal|"/GSa %d 0 R\n"
argument|,             patternColorSpace, graphicsState);      for (int i =
literal|0
argument|; i< currentPage->graphicStates.size(); ++i)         xprintf(
literal|"/GState%d %d 0 R\n"
argument|, currentPage->graphicStates.at(i), currentPage->graphicStates.at(i));     xprintf(
literal|">>\n"
argument|);      xprintf(
literal|"/Pattern<<\n"
argument|);     for (int i =
literal|0
argument|; i< currentPage->patterns.size(); ++i)         xprintf(
literal|"/Pat%d %d 0 R\n"
argument|, currentPage->patterns.at(i), currentPage->patterns.at(i));     xprintf(
literal|">>\n"
argument|);      xprintf(
literal|"/Font<<\n"
argument|);     for (int i =
literal|0
argument|; i< currentPage->fonts.size();++i)         xprintf(
literal|"/F%d %d 0 R\n"
argument|, currentPage->fonts[i], currentPage->fonts[i]);     xprintf(
literal|">>\n"
argument|);      xprintf(
literal|"/XObject<<\n"
argument|);     for (int i =
literal|0
argument|; i<currentPage->images.size(); ++i) {         xprintf(
literal|"/Im%d %d 0 R\n"
argument|, currentPage->images.at(i), currentPage->images.at(i));     }     xprintf(
literal|">>\n"
argument|);      xprintf(
literal|">>\n"
literal|"endobj\n"
argument|);      addXrefEntry(annots);     xprintf(
literal|"[ "
argument|);     for (int i =
literal|0
argument|; i<currentPage->annotations.size(); ++i) {         xprintf(
literal|"%d 0 R "
argument|, currentPage->annotations.at(i));     }     xprintf(
literal|"]\nendobj\n"
argument|);      addXrefEntry(pageStream);     xprintf(
literal|"<<\n"
literal|"/Length %d 0 R\n"
argument|, pageStreamLength);
comment|// object number for stream length object
argument|if (do_compress)         xprintf(
literal|"/Filter /FlateDecode\n"
argument|);      xprintf(
literal|">>\n"
argument|);     xprintf(
literal|"stream\n"
argument|);     QIODevice *content = currentPage->stream();     int len = writeCompressed(content);     xprintf(
literal|"endstream\n"
literal|"endobj\n"
argument|);      addXrefEntry(pageStreamLength);     xprintf(
literal|"%d\nendobj\n"
argument|,len); }  void QPdfEnginePrivate::writeTail() {     writePage();     writeFonts();     writePageRoot();     addXrefEntry(xrefPositions.size(),
literal|false
argument|);     xprintf(
literal|"xref\n"
literal|"0 %d\n"
literal|"%010d 65535 f \n"
argument|, xrefPositions.size()-
literal|1
argument|, xrefPositions[
literal|0
argument|]);      for (int i =
literal|1
argument|; i< xrefPositions.size()-
literal|1
argument|; ++i)         xprintf(
literal|"%010d 00000 n \n"
argument|, xrefPositions[i]);      xprintf(
literal|"trailer\n"
literal|"<<\n"
literal|"/Size %d\n"
literal|"/Info %d 0 R\n"
literal|"/Root %d 0 R\n"
literal|">>\n"
literal|"startxref\n%d\n"
literal|"%%%%EOF\n"
argument|,             xrefPositions.size()-
literal|1
argument|, info, catalog, xrefPositions.last()); }  int QPdfEnginePrivate::addXrefEntry(int object, bool printostr) {     if (object<
literal|0
argument|)         object = requestObject();      if (object>=xrefPositions.size())         xrefPositions.resize(object+
literal|1
argument|);      xrefPositions[object] = streampos;     if (printostr)         xprintf(
literal|"%d 0 obj\n"
argument|,object);      return object; }  void QPdfEnginePrivate::printString(const QString&string) {
comment|// The 'text string' type in PDF is encoded either as PDFDocEncoding, or
comment|// Unicode UTF-16 with a Unicode byte order mark as the first character
comment|// (0xfeff), with the high-order byte first.
argument|QByteArray array(
literal|"(\xfe\xff"
argument|);     const ushort *utf16 = string.utf16();          for (int i=
literal|0
argument|; i< string.size(); ++i) {         char part[
literal|2
argument|] = {char((*(utf16 + i))>>
literal|8
argument|)
argument_list|,
argument|char((*(utf16 + i))&
literal|0xff
argument|)};         for(int j=
literal|0
argument|; j<
literal|2
argument|; ++j) {             if (part[j] ==
literal|'('
argument||| part[j] ==
literal|')'
argument||| part[j] ==
literal|'\\'
argument|)                 array.append(
literal|'\\'
argument|);             array.append(part[j]);         }     }     array.append(
literal|")"
argument|);     write(array); }  QT_END_NAMESPACE
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PRINTER
end_comment
end_unit
