begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qrasterizer_p.h"
end_include
begin_include
include|#
directive|include
file|<QPoint>
end_include
begin_include
include|#
directive|include
file|<QRect>
end_include
begin_include
include|#
directive|include
file|<private/qmath_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdatabuffer_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_typedef
DECL|typedef|Q16Dot16
typedef|typedef
name|int
name|Q16Dot16
typedef|;
end_typedef
begin_define
DECL|macro|Q16Dot16ToFloat
define|#
directive|define
name|Q16Dot16ToFloat
parameter_list|(
name|i
parameter_list|)
value|((i)/65536.)
end_define
begin_define
DECL|macro|FloatToQ16Dot16
define|#
directive|define
name|FloatToQ16Dot16
parameter_list|(
name|i
parameter_list|)
value|(int)((i) * 65536.)
end_define
begin_define
DECL|macro|IntToQ16Dot16
define|#
directive|define
name|IntToQ16Dot16
parameter_list|(
name|i
parameter_list|)
value|((i)<< 16)
end_define
begin_define
DECL|macro|Q16Dot16ToInt
define|#
directive|define
name|Q16Dot16ToInt
parameter_list|(
name|i
parameter_list|)
value|((i)>> 16)
end_define
begin_define
DECL|macro|Q16Dot16Factor
define|#
directive|define
name|Q16Dot16Factor
value|65536
end_define
begin_define
DECL|macro|Q16Dot16Multiply
define|#
directive|define
name|Q16Dot16Multiply
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(int)((qlonglong(x) * qlonglong(y))>> 16)
end_define
begin_define
DECL|macro|Q16Dot16FastMultiply
define|#
directive|define
name|Q16Dot16FastMultiply
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) * (y))>> 16)
end_define
begin_define
DECL|macro|SPAN_BUFFER_SIZE
define|#
directive|define
name|SPAN_BUFFER_SIZE
value|256
end_define
begin_define
DECL|macro|COORD_ROUNDING
define|#
directive|define
name|COORD_ROUNDING
value|1
end_define
begin_comment
DECL|macro|COORD_ROUNDING
comment|// 0: round up, 1: round down
end_comment
begin_define
DECL|macro|COORD_OFFSET
define|#
directive|define
name|COORD_OFFSET
value|32
end_define
begin_comment
DECL|macro|COORD_OFFSET
comment|// 26.6, 32 is half a pixel
end_comment
begin_function
DECL|function|PointToVector
specifier|static
specifier|inline
name|QT_FT_Vector
name|PointToVector
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
name|QT_FT_Vector
name|result
init|=
block|{
name|QT_FT_Pos
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|*
literal|64
argument_list|)
block|,
name|QT_FT_Pos
argument_list|(
argument|p.y() *
literal|64
argument_list|)
block|}
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_class
DECL|class|QSpanBuffer
class|class
name|QSpanBuffer
block|{
public|public:
DECL|function|QSpanBuffer
name|QSpanBuffer
parameter_list|(
name|ProcessSpans
name|blend
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QRect
modifier|&
name|clipRect
parameter_list|)
member_init_list|:
name|m_spanCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_blend
argument_list|(
name|blend
argument_list|)
member_init_list|,
name|m_data
argument_list|(
name|data
argument_list|)
member_init_list|,
name|m_clipRect
argument_list|(
name|clipRect
argument_list|)
block|{     }
DECL|function|~QSpanBuffer
name|~
name|QSpanBuffer
parameter_list|()
block|{
name|flushSpans
argument_list|()
expr_stmt|;
block|}
DECL|function|addSpan
name|void
name|addSpan
parameter_list|(
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|int
name|y
parameter_list|,
name|unsigned
name|char
name|coverage
parameter_list|)
block|{
if|if
condition|(
operator|!
name|coverage
operator|||
operator|!
name|len
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|y
operator|>=
name|m_clipRect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y
operator|<=
name|m_clipRect
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|x
operator|>=
name|m_clipRect
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|x
operator|+
name|int
argument_list|(
name|len
argument_list|)
operator|-
literal|1
operator|<=
name|m_clipRect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|m_spans
index|[
name|m_spanCount
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|m_spans
index|[
name|m_spanCount
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m_spans
index|[
name|m_spanCount
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|m_spans
index|[
name|m_spanCount
index|]
operator|.
name|coverage
operator|=
name|coverage
expr_stmt|;
if|if
condition|(
operator|++
name|m_spanCount
operator|==
name|SPAN_BUFFER_SIZE
condition|)
name|flushSpans
argument_list|()
expr_stmt|;
block|}
private|private:
DECL|function|flushSpans
name|void
name|flushSpans
parameter_list|()
block|{
name|m_blend
argument_list|(
name|m_spanCount
argument_list|,
name|m_spans
argument_list|,
name|m_data
argument_list|)
expr_stmt|;
name|m_spanCount
operator|=
literal|0
expr_stmt|;
block|}
DECL|member|m_spans
name|QT_FT_Span
name|m_spans
index|[
name|SPAN_BUFFER_SIZE
index|]
decl_stmt|;
DECL|member|m_spanCount
name|int
name|m_spanCount
decl_stmt|;
DECL|member|m_blend
name|ProcessSpans
name|m_blend
decl_stmt|;
DECL|member|m_data
name|void
modifier|*
name|m_data
decl_stmt|;
DECL|member|m_clipRect
name|QRect
name|m_clipRect
decl_stmt|;
block|}
class|;
end_class
begin_define
DECL|macro|CHUNK_SIZE
define|#
directive|define
name|CHUNK_SIZE
value|64
end_define
begin_class
DECL|class|QScanConverter
class|class
name|QScanConverter
block|{
public|public:
name|QScanConverter
parameter_list|()
constructor_decl|;
name|~
name|QScanConverter
parameter_list|()
destructor_decl|;
name|void
name|begin
parameter_list|(
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|,
name|bool
name|legacyRounding
parameter_list|,
name|QSpanBuffer
modifier|*
name|spanBuffer
parameter_list|)
function_decl|;
name|void
name|end
parameter_list|()
function_decl|;
name|void
name|mergeCurve
parameter_list|(
specifier|const
name|QT_FT_Vector
modifier|&
name|a
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|b
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|c
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|d
parameter_list|)
function_decl|;
name|void
name|mergeLine
parameter_list|(
name|QT_FT_Vector
name|a
parameter_list|,
name|QT_FT_Vector
name|b
parameter_list|)
function_decl|;
DECL|struct|Line
struct|struct
name|Line
block|{
DECL|member|x
name|Q16Dot16
name|x
decl_stmt|;
DECL|member|delta
name|Q16Dot16
name|delta
decl_stmt|;
DECL|member|top
DECL|member|bottom
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|;
DECL|member|winding
name|int
name|winding
decl_stmt|;
block|}
struct|;
private|private:
DECL|struct|Intersection
struct|struct
name|Intersection
block|{
DECL|member|x
name|int
name|x
decl_stmt|;
DECL|member|winding
name|int
name|winding
decl_stmt|;
DECL|member|left
DECL|member|right
name|int
name|left
decl_stmt|,
name|right
decl_stmt|;
block|}
struct|;
specifier|inline
name|bool
name|clip
parameter_list|(
name|Q16Dot16
modifier|&
name|xFP
parameter_list|,
name|int
modifier|&
name|iTop
parameter_list|,
name|int
modifier|&
name|iBottom
parameter_list|,
name|Q16Dot16
name|slopeFP
parameter_list|,
name|Q16Dot16
name|edgeFP
parameter_list|,
name|int
name|winding
parameter_list|)
function_decl|;
specifier|inline
name|void
name|mergeIntersection
parameter_list|(
name|Intersection
modifier|*
name|head
parameter_list|,
specifier|const
name|Intersection
modifier|&
name|isect
parameter_list|)
function_decl|;
name|void
name|prepareChunk
parameter_list|()
function_decl|;
name|void
name|emitNode
parameter_list|(
specifier|const
name|Intersection
modifier|*
name|node
parameter_list|)
function_decl|;
name|void
name|emitSpans
parameter_list|(
name|int
name|chunk
parameter_list|)
function_decl|;
specifier|inline
name|void
name|allocate
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
DECL|member|m_lines
name|QDataBuffer
argument_list|<
name|Line
argument_list|>
name|m_lines
decl_stmt|;
DECL|member|m_alloc
name|int
name|m_alloc
decl_stmt|;
DECL|member|m_size
name|int
name|m_size
decl_stmt|;
DECL|member|m_top
name|int
name|m_top
decl_stmt|;
DECL|member|m_bottom
name|int
name|m_bottom
decl_stmt|;
DECL|member|m_leftFP
name|Q16Dot16
name|m_leftFP
decl_stmt|;
DECL|member|m_rightFP
name|Q16Dot16
name|m_rightFP
decl_stmt|;
DECL|member|m_fillRuleMask
name|int
name|m_fillRuleMask
decl_stmt|;
DECL|member|m_legacyRounding
name|bool
name|m_legacyRounding
decl_stmt|;
DECL|member|m_x
name|int
name|m_x
decl_stmt|;
DECL|member|m_y
name|int
name|m_y
decl_stmt|;
DECL|member|m_winding
name|int
name|m_winding
decl_stmt|;
DECL|member|m_intersections
name|Intersection
modifier|*
name|m_intersections
decl_stmt|;
DECL|member|m_spanBuffer
name|QSpanBuffer
modifier|*
name|m_spanBuffer
decl_stmt|;
DECL|member|m_active
name|QDataBuffer
argument_list|<
name|Line
modifier|*
argument_list|>
name|m_active
decl_stmt|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
friend|friend
name|void
name|qScanConvert
parameter_list|(
name|QScanConverter
modifier|&
name|d
parameter_list|,
name|T
name|allVertical
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QRasterizerPrivate
class|class
name|QRasterizerPrivate
block|{
public|public:
DECL|member|antialiased
name|bool
name|antialiased
decl_stmt|;
DECL|member|legacyRounding
name|bool
name|legacyRounding
decl_stmt|;
DECL|member|blend
name|ProcessSpans
name|blend
decl_stmt|;
DECL|member|data
name|void
modifier|*
name|data
decl_stmt|;
DECL|member|clipRect
name|QRect
name|clipRect
decl_stmt|;
DECL|member|scanConverter
name|QScanConverter
name|scanConverter
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QScanConverter
name|QScanConverter
operator|::
name|QScanConverter
parameter_list|()
member_init_list|:
name|m_lines
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_alloc
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_intersections
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_active
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QScanConverter
name|QScanConverter
operator|::
name|~
name|QScanConverter
parameter_list|()
block|{
if|if
condition|(
name|m_intersections
condition|)
name|free
argument_list|(
name|m_intersections
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|begin
name|void
name|QScanConverter
operator|::
name|begin
parameter_list|(
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|,
name|bool
name|legacyRounding
parameter_list|,
name|QSpanBuffer
modifier|*
name|spanBuffer
parameter_list|)
block|{
name|m_top
operator|=
name|top
expr_stmt|;
name|m_bottom
operator|=
name|bottom
expr_stmt|;
name|m_leftFP
operator|=
name|IntToQ16Dot16
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|m_rightFP
operator|=
name|IntToQ16Dot16
argument_list|(
name|right
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m_lines
operator|.
name|reset
argument_list|()
expr_stmt|;
name|m_fillRuleMask
operator|=
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
operator|~
literal|0x0
else|:
literal|0x1
expr_stmt|;
name|m_legacyRounding
operator|=
name|legacyRounding
expr_stmt|;
name|m_spanBuffer
operator|=
name|spanBuffer
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepareChunk
name|void
name|QScanConverter
operator|::
name|prepareChunk
parameter_list|()
block|{
name|m_size
operator|=
name|CHUNK_SIZE
expr_stmt|;
name|allocate
argument_list|(
name|CHUNK_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m_intersections
argument_list|,
literal|0
argument_list|,
name|CHUNK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|Intersection
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitNode
name|void
name|QScanConverter
operator|::
name|emitNode
parameter_list|(
specifier|const
name|Intersection
modifier|*
name|node
parameter_list|)
block|{
name|tail_call
label|:
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|emitNode
argument_list|(
name|node
operator|+
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_winding
operator|&
name|m_fillRuleMask
condition|)
name|m_spanBuffer
operator|->
name|addSpan
argument_list|(
name|m_x
argument_list|,
name|node
operator|->
name|x
operator|-
name|m_x
argument_list|,
name|m_y
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|m_x
operator|=
name|node
operator|->
name|x
expr_stmt|;
name|m_winding
operator|+=
name|node
operator|->
name|winding
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
block|{
name|node
operator|+=
name|node
operator|->
name|right
expr_stmt|;
goto|goto
name|tail_call
goto|;
block|}
block|}
end_function
begin_function
DECL|function|emitSpans
name|void
name|QScanConverter
operator|::
name|emitSpans
parameter_list|(
name|int
name|chunk
parameter_list|)
block|{
for|for
control|(
name|int
name|dy
init|=
literal|0
init|;
name|dy
operator|<
name|CHUNK_SIZE
condition|;
operator|++
name|dy
control|)
block|{
name|m_x
operator|=
literal|0
expr_stmt|;
name|m_y
operator|=
name|chunk
operator|+
name|dy
expr_stmt|;
name|m_winding
operator|=
literal|0
expr_stmt|;
name|emitNode
argument_list|(
operator|&
name|m_intersections
index|[
name|dy
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// split control points b[0] ... b[3] into
end_comment
begin_comment
comment|// left (b[0] ... b[3]) and right (b[3] ... b[6])
end_comment
begin_function
DECL|function|split
specifier|static
name|void
name|split
parameter_list|(
name|QT_FT_Vector
modifier|*
name|b
parameter_list|)
block|{
name|b
index|[
literal|6
index|]
operator|=
name|b
index|[
literal|3
index|]
expr_stmt|;
block|{
specifier|const
name|QT_FT_Pos
name|temp
init|=
operator|(
name|b
index|[
literal|1
index|]
operator|.
name|x
operator|+
name|b
index|[
literal|2
index|]
operator|.
name|x
operator|)
operator|/
literal|2
decl_stmt|;
name|b
index|[
literal|1
index|]
operator|.
name|x
operator|=
operator|(
name|b
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|b
index|[
literal|1
index|]
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|5
index|]
operator|.
name|x
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
index|[
literal|3
index|]
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|.
name|x
operator|=
operator|(
name|b
index|[
literal|1
index|]
operator|.
name|x
operator|+
name|temp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|4
index|]
operator|.
name|x
operator|=
operator|(
name|b
index|[
literal|5
index|]
operator|.
name|x
operator|+
name|temp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
index|[
literal|4
index|]
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|{
specifier|const
name|QT_FT_Pos
name|temp
init|=
operator|(
name|b
index|[
literal|1
index|]
operator|.
name|y
operator|+
name|b
index|[
literal|2
index|]
operator|.
name|y
operator|)
operator|/
literal|2
decl_stmt|;
name|b
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|(
name|b
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|b
index|[
literal|1
index|]
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|5
index|]
operator|.
name|y
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
index|[
literal|3
index|]
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|(
name|b
index|[
literal|1
index|]
operator|.
name|y
operator|+
name|temp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|4
index|]
operator|.
name|y
operator|=
operator|(
name|b
index|[
literal|5
index|]
operator|.
name|y
operator|+
name|temp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
index|[
literal|4
index|]
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|topOrder
specifier|static
specifier|inline
name|bool
name|topOrder
parameter_list|(
specifier|const
name|QScanConverter
operator|::
name|Line
modifier|&
name|a
parameter_list|,
specifier|const
name|QScanConverter
operator|::
name|Line
modifier|&
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|top
operator|<
name|b
operator|.
name|top
return|;
block|}
end_function
begin_function
DECL|function|xOrder
specifier|static
specifier|inline
name|bool
name|xOrder
parameter_list|(
specifier|const
name|QScanConverter
operator|::
name|Line
modifier|*
name|a
parameter_list|,
specifier|const
name|QScanConverter
operator|::
name|Line
modifier|*
name|b
parameter_list|)
block|{
return|return
name|a
operator|->
name|x
operator|<
name|b
operator|->
name|x
return|;
block|}
end_function
begin_struct
template|template
parameter_list|<
name|bool
name|B
parameter_list|>
struct|struct
DECL|struct|QBoolToType
name|QBoolToType
block|{
DECL|function|operator ()
specifier|inline
name|bool
name|operator
name|()
parameter_list|()
specifier|const
block|{
return|return
name|B
return|;
block|}
block|}
struct|;
end_struct
begin_comment
comment|// should be a member function but VC6 doesn't support member template functions
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|qScanConvert
name|void
name|qScanConvert
parameter_list|(
name|QScanConverter
modifier|&
name|d
parameter_list|,
name|T
name|allVertical
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|m_lines
operator|.
name|size
argument_list|()
condition|)
block|{
name|d
operator|.
name|m_active
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return;
block|}
name|qSort
argument_list|(
name|d
operator|.
name|m_lines
operator|.
name|data
argument_list|()
argument_list|,
name|d
operator|.
name|m_lines
operator|.
name|data
argument_list|()
operator|+
name|d
operator|.
name|m_lines
operator|.
name|size
argument_list|()
argument_list|,
name|QT_PREPEND_NAMESPACE
argument_list|(
name|topOrder
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|d
operator|.
name|m_lines
operator|.
name|first
argument_list|()
operator|.
name|top
init|;
name|y
operator|<=
name|d
operator|.
name|m_bottom
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
init|;
name|line
operator|<
name|d
operator|.
name|m_lines
operator|.
name|size
argument_list|()
operator|&&
name|d
operator|.
name|m_lines
operator|.
name|at
argument_list|(
name|line
argument_list|)
operator|.
name|top
operator|==
name|y
condition|;
operator|++
name|line
control|)
block|{
comment|// add node to active list
if|if
condition|(
name|allVertical
argument_list|()
condition|)
block|{
name|QScanConverter
operator|::
name|Line
modifier|*
name|l
init|=
operator|&
name|d
operator|.
name|m_lines
operator|.
name|at
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|d
operator|.
name|m_active
operator|.
name|resize
argument_list|(
name|d
operator|.
name|m_active
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|d
operator|.
name|m_active
operator|.
name|size
argument_list|()
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
operator|&&
name|QT_PREPEND_NAMESPACE
argument_list|(
name|xOrder
argument_list|)
argument_list|(
name|l
argument_list|,
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
condition|;
operator|--
name|j
control|)
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|=
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|d
operator|.
name|m_active
operator|<<
operator|&
name|d
operator|.
name|m_lines
operator|.
name|at
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numActive
init|=
name|d
operator|.
name|m_active
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allVertical
argument_list|()
condition|)
block|{
comment|// use insertion sort instead of qSort, as the active edge list is quite small
comment|// and in the average case already sorted
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numActive
condition|;
operator|++
name|i
control|)
block|{
name|QScanConverter
operator|::
name|Line
modifier|*
name|l
init|=
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
operator|&&
name|QT_PREPEND_NAMESPACE
argument_list|(
name|xOrder
argument_list|)
argument_list|(
name|l
argument_list|,
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
condition|;
operator|--
name|j
control|)
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|=
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|=
name|l
expr_stmt|;
block|}
block|}
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|winding
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numActive
condition|;
operator|++
name|i
control|)
block|{
name|QScanConverter
operator|::
name|Line
modifier|*
name|node
init|=
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|int
name|current
init|=
name|Q16Dot16ToInt
argument_list|(
name|node
operator|->
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|winding
operator|&
name|d
operator|.
name|m_fillRuleMask
condition|)
name|d
operator|.
name|m_spanBuffer
operator|->
name|addSpan
argument_list|(
name|x
argument_list|,
name|current
operator|-
name|x
argument_list|,
name|y
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|x
operator|=
name|current
expr_stmt|;
name|winding
operator|+=
name|node
operator|->
name|winding
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|bottom
operator|==
name|y
condition|)
block|{
comment|// remove node from active list
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|numActive
operator|-
literal|1
condition|;
operator|++
name|j
control|)
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|=
name|d
operator|.
name|m_active
operator|.
name|at
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|.
name|m_active
operator|.
name|resize
argument_list|(
operator|--
name|numActive
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|allVertical
argument_list|()
condition|)
name|node
operator|->
name|x
operator|+=
name|node
operator|->
name|delta
expr_stmt|;
block|}
block|}
name|d
operator|.
name|m_active
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end
name|void
name|QScanConverter
operator|::
name|end
parameter_list|()
block|{
if|if
condition|(
name|m_lines
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|m_lines
operator|.
name|size
argument_list|()
operator|<=
literal|32
condition|)
block|{
name|bool
name|allVertical
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_lines
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_lines
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|delta
condition|)
block|{
name|allVertical
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allVertical
condition|)
name|qScanConvert
argument_list|(
operator|*
name|this
argument_list|,
name|QBoolToType
argument_list|<
literal|true
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qScanConvert
argument_list|(
operator|*
name|this
argument_list|,
name|QBoolToType
argument_list|<
literal|false
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|chunkTop
init|=
name|m_top
init|;
name|chunkTop
operator|<=
name|m_bottom
condition|;
name|chunkTop
operator|+=
name|CHUNK_SIZE
control|)
block|{
name|prepareChunk
argument_list|()
expr_stmt|;
name|Intersection
name|isect
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|chunkBottom
init|=
name|chunkTop
operator|+
name|CHUNK_SIZE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_lines
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Line
modifier|&
name|line
init|=
name|m_lines
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|line
operator|.
name|bottom
operator|<
name|chunkTop
operator|)
operator|||
operator|(
name|line
operator|.
name|top
operator|>
name|chunkBottom
operator|)
condition|)
continue|continue;
specifier|const
name|int
name|top
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|top
operator|-
name|chunkTop
argument_list|)
decl_stmt|;
specifier|const
name|int
name|bottom
init|=
name|qMin
argument_list|(
name|CHUNK_SIZE
argument_list|,
name|line
operator|.
name|bottom
operator|+
literal|1
operator|-
name|chunkTop
argument_list|)
decl_stmt|;
name|allocate
argument_list|(
name|m_size
operator|+
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|isect
operator|.
name|winding
operator|=
name|line
operator|.
name|winding
expr_stmt|;
name|Intersection
modifier|*
name|it
init|=
name|m_intersections
operator|+
name|top
decl_stmt|;
name|Intersection
modifier|*
name|end
init|=
name|m_intersections
operator|+
name|bottom
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|delta
condition|)
block|{
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|isect
operator|.
name|x
operator|=
name|Q16Dot16ToInt
argument_list|(
name|line
operator|.
name|x
argument_list|)
expr_stmt|;
name|line
operator|.
name|x
operator|+=
name|line
operator|.
name|delta
expr_stmt|;
name|mergeIntersection
argument_list|(
name|it
argument_list|,
name|isect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isect
operator|.
name|x
operator|=
name|Q16Dot16ToInt
argument_list|(
name|line
operator|.
name|x
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|mergeIntersection
argument_list|(
name|it
argument_list|,
name|isect
argument_list|)
expr_stmt|;
block|}
block|}
name|emitSpans
argument_list|(
name|chunkTop
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m_alloc
operator|>
literal|1024
condition|)
block|{
name|free
argument_list|(
name|m_intersections
argument_list|)
expr_stmt|;
name|m_alloc
operator|=
literal|0
expr_stmt|;
name|m_size
operator|=
literal|0
expr_stmt|;
name|m_intersections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m_lines
operator|.
name|size
argument_list|()
operator|>
literal|1024
condition|)
name|m_lines
operator|.
name|shrink
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allocate
specifier|inline
name|void
name|QScanConverter
operator|::
name|allocate
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|m_alloc
operator|<
name|size
condition|)
block|{
name|int
name|newAlloc
init|=
name|qMax
argument_list|(
name|size
argument_list|,
literal|2
operator|*
name|m_alloc
argument_list|)
decl_stmt|;
name|m_intersections
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Intersection
operator|*
operator|)
name|realloc
argument_list|(
name|m_intersections
argument_list|,
name|newAlloc
operator|*
sizeof|sizeof
argument_list|(
name|Intersection
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|m_alloc
operator|=
name|newAlloc
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mergeIntersection
specifier|inline
name|void
name|QScanConverter
operator|::
name|mergeIntersection
parameter_list|(
name|Intersection
modifier|*
name|it
parameter_list|,
specifier|const
name|Intersection
modifier|&
name|isect
parameter_list|)
block|{
name|Intersection
modifier|*
name|current
init|=
name|it
decl_stmt|;
while|while
condition|(
name|isect
operator|.
name|x
operator|!=
name|current
operator|->
name|x
condition|)
block|{
name|int
modifier|&
name|next
init|=
name|isect
operator|.
name|x
operator|<
name|current
operator|->
name|x
condition|?
name|current
operator|->
name|left
else|:
name|current
operator|->
name|right
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|current
operator|+=
name|next
expr_stmt|;
else|else
block|{
name|Intersection
modifier|*
name|last
init|=
name|m_intersections
operator|+
name|m_size
decl_stmt|;
name|next
operator|=
name|last
operator|-
name|current
expr_stmt|;
operator|*
name|last
operator|=
name|isect
expr_stmt|;
operator|++
name|m_size
expr_stmt|;
return|return;
block|}
block|}
name|current
operator|->
name|winding
operator|+=
name|isect
operator|.
name|winding
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mergeCurve
name|void
name|QScanConverter
operator|::
name|mergeCurve
parameter_list|(
specifier|const
name|QT_FT_Vector
modifier|&
name|pa
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|pb
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|pc
parameter_list|,
specifier|const
name|QT_FT_Vector
modifier|&
name|pd
parameter_list|)
block|{
comment|// make room for 32 splits
name|QT_FT_Vector
name|beziers
index|[
literal|4
operator|+
literal|3
operator|*
literal|32
index|]
decl_stmt|;
name|QT_FT_Vector
modifier|*
name|b
init|=
name|beziers
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|pa
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|pb
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
name|pc
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
name|pd
expr_stmt|;
specifier|const
name|QT_FT_Pos
name|flatness
init|=
literal|16
decl_stmt|;
while|while
condition|(
name|b
operator|>=
name|beziers
condition|)
block|{
name|QT_FT_Vector
name|delta
init|=
block|{
name|b
index|[
literal|3
index|]
operator|.
name|x
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|x
block|,
name|b
index|[
literal|3
index|]
operator|.
name|y
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|y
block|}
decl_stmt|;
name|QT_FT_Pos
name|l
init|=
name|qAbs
argument_list|(
name|delta
operator|.
name|x
argument_list|)
operator|+
name|qAbs
argument_list|(
name|delta
operator|.
name|y
argument_list|)
decl_stmt|;
name|bool
name|belowThreshold
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|64
condition|)
block|{
name|qlonglong
name|d2
init|=
name|qAbs
argument_list|(
name|qlonglong
argument_list|(
name|b
index|[
literal|1
index|]
operator|.
name|x
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
operator|*
name|qlonglong
argument_list|(
name|delta
operator|.
name|y
argument_list|)
operator|-
name|qlonglong
argument_list|(
name|b
index|[
literal|1
index|]
operator|.
name|y
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
operator|*
name|qlonglong
argument_list|(
name|delta
operator|.
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|qlonglong
name|d3
init|=
name|qAbs
argument_list|(
name|qlonglong
argument_list|(
name|b
index|[
literal|2
index|]
operator|.
name|x
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
operator|*
name|qlonglong
argument_list|(
name|delta
operator|.
name|y
argument_list|)
operator|-
name|qlonglong
argument_list|(
name|b
index|[
literal|2
index|]
operator|.
name|y
operator|-
name|b
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
operator|*
name|qlonglong
argument_list|(
name|delta
operator|.
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|qlonglong
name|d
init|=
name|d2
operator|+
name|d3
decl_stmt|;
name|belowThreshold
operator|=
operator|(
name|d
operator|<=
name|qlonglong
argument_list|(
name|flatness
argument_list|)
operator|*
name|qlonglong
argument_list|(
name|l
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|QT_FT_Pos
name|d
init|=
name|qAbs
argument_list|(
name|b
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|b
index|[
literal|1
index|]
operator|.
name|x
argument_list|)
operator|+
name|qAbs
argument_list|(
name|b
index|[
literal|0
index|]
operator|.
name|y
operator|-
name|b
index|[
literal|1
index|]
operator|.
name|y
argument_list|)
operator|+
name|qAbs
argument_list|(
name|b
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|b
index|[
literal|2
index|]
operator|.
name|x
argument_list|)
operator|+
name|qAbs
argument_list|(
name|b
index|[
literal|0
index|]
operator|.
name|y
operator|-
name|b
index|[
literal|2
index|]
operator|.
name|y
argument_list|)
decl_stmt|;
name|belowThreshold
operator|=
operator|(
name|d
operator|<=
name|flatness
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|belowThreshold
operator|||
name|b
operator|==
name|beziers
operator|+
literal|3
operator|*
literal|32
condition|)
block|{
name|mergeLine
argument_list|(
name|b
index|[
literal|0
index|]
argument_list|,
name|b
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|b
operator|-=
literal|3
expr_stmt|;
continue|continue;
block|}
name|split
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clip
specifier|inline
name|bool
name|QScanConverter
operator|::
name|clip
parameter_list|(
name|Q16Dot16
modifier|&
name|xFP
parameter_list|,
name|int
modifier|&
name|iTop
parameter_list|,
name|int
modifier|&
name|iBottom
parameter_list|,
name|Q16Dot16
name|slopeFP
parameter_list|,
name|Q16Dot16
name|edgeFP
parameter_list|,
name|int
name|winding
parameter_list|)
block|{
name|bool
name|right
init|=
name|edgeFP
operator|==
name|m_rightFP
decl_stmt|;
if|if
condition|(
name|xFP
operator|==
name|edgeFP
condition|)
block|{
if|if
condition|(
operator|(
name|slopeFP
operator|>
literal|0
operator|)
operator|^
name|right
condition|)
return|return
literal|false
return|;
else|else
block|{
name|Line
name|line
init|=
block|{
name|edgeFP
block|,
literal|0
block|,
name|iTop
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|Q16Dot16
name|lastFP
init|=
name|xFP
operator|+
name|slopeFP
operator|*
operator|(
name|iBottom
operator|-
name|iTop
operator|)
decl_stmt|;
if|if
condition|(
name|lastFP
operator|==
name|edgeFP
condition|)
block|{
if|if
condition|(
operator|(
name|slopeFP
operator|<
literal|0
operator|)
operator|^
name|right
condition|)
return|return
literal|false
return|;
else|else
block|{
name|Line
name|line
init|=
block|{
name|edgeFP
block|,
literal|0
block|,
name|iTop
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// does line cross edge?
if|if
condition|(
operator|(
name|lastFP
operator|<
name|edgeFP
operator|)
operator|^
operator|(
name|xFP
operator|<
name|edgeFP
operator|)
condition|)
block|{
name|Q16Dot16
name|deltaY
init|=
name|Q16Dot16
argument_list|(
operator|(
name|edgeFP
operator|-
name|xFP
operator|)
operator|/
name|Q16Dot16ToFloat
argument_list|(
name|slopeFP
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|xFP
operator|<
name|edgeFP
operator|)
operator|^
name|right
condition|)
block|{
comment|// top segment needs to be clipped
name|int
name|iHeight
init|=
name|Q16Dot16ToInt
argument_list|(
name|deltaY
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|iMiddle
init|=
name|iTop
operator|+
name|iHeight
decl_stmt|;
name|Line
name|line
init|=
block|{
name|edgeFP
block|,
literal|0
block|,
name|iTop
block|,
name|iMiddle
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|iMiddle
operator|!=
name|iBottom
condition|)
block|{
name|xFP
operator|+=
name|slopeFP
operator|*
operator|(
name|iHeight
operator|+
literal|1
operator|)
expr_stmt|;
name|iTop
operator|=
name|iMiddle
operator|+
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// bottom segment needs to be clipped
name|int
name|iHeight
init|=
name|Q16Dot16ToInt
argument_list|(
name|deltaY
argument_list|)
decl_stmt|;
name|int
name|iMiddle
init|=
name|iTop
operator|+
name|iHeight
decl_stmt|;
if|if
condition|(
name|iMiddle
operator|!=
name|iBottom
condition|)
block|{
name|Line
name|line
init|=
block|{
name|edgeFP
block|,
literal|0
block|,
name|iMiddle
operator|+
literal|1
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|iBottom
operator|=
name|iMiddle
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xFP
operator|<
name|edgeFP
operator|)
operator|^
name|right
condition|)
block|{
name|Line
name|line
init|=
block|{
name|edgeFP
block|,
literal|0
block|,
name|iTop
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|mergeLine
name|void
name|QScanConverter
operator|::
name|mergeLine
parameter_list|(
name|QT_FT_Vector
name|a
parameter_list|,
name|QT_FT_Vector
name|b
parameter_list|)
block|{
name|int
name|winding
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|y
operator|>
name|b
operator|.
name|y
condition|)
block|{
name|qSwap
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|winding
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|m_legacyRounding
condition|)
block|{
name|a
operator|.
name|x
operator|+=
name|COORD_OFFSET
expr_stmt|;
name|a
operator|.
name|y
operator|+=
name|COORD_OFFSET
expr_stmt|;
name|b
operator|.
name|x
operator|+=
name|COORD_OFFSET
expr_stmt|;
name|b
operator|.
name|y
operator|+=
name|COORD_OFFSET
expr_stmt|;
block|}
name|int
name|rounding
init|=
name|m_legacyRounding
condition|?
name|COORD_ROUNDING
else|:
literal|0
decl_stmt|;
name|int
name|iTop
init|=
name|qMax
argument_list|(
name|m_top
argument_list|,
name|int
argument_list|(
operator|(
name|a
operator|.
name|y
operator|+
literal|32
operator|-
name|rounding
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|iBottom
init|=
name|qMin
argument_list|(
name|m_bottom
argument_list|,
name|int
argument_list|(
operator|(
name|b
operator|.
name|y
operator|-
literal|32
operator|-
name|rounding
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|iTop
operator|<=
name|iBottom
condition|)
block|{
name|Q16Dot16
name|aFP
init|=
name|Q16Dot16Factor
operator|/
literal|2
operator|+
operator|(
name|a
operator|.
name|x
operator|<<
literal|10
operator|)
operator|-
name|rounding
decl_stmt|;
if|if
condition|(
name|b
operator|.
name|x
operator|==
name|a
operator|.
name|x
condition|)
block|{
name|Line
name|line
init|=
block|{
name|qBound
argument_list|(
name|m_leftFP
argument_list|,
name|aFP
argument_list|,
name|m_rightFP
argument_list|)
block|,
literal|0
block|,
name|iTop
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|qreal
name|slope
init|=
operator|(
name|b
operator|.
name|x
operator|-
name|a
operator|.
name|x
operator|)
operator|/
name|qreal
argument_list|(
name|b
operator|.
name|y
operator|-
name|a
operator|.
name|y
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|slopeFP
init|=
name|FloatToQ16Dot16
argument_list|(
name|slope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|xFP
init|=
name|aFP
operator|+
name|Q16Dot16Multiply
argument_list|(
name|slopeFP
argument_list|,
name|IntToQ16Dot16
argument_list|(
name|iTop
argument_list|)
operator|+
name|Q16Dot16Factor
operator|/
literal|2
operator|-
operator|(
name|a
operator|.
name|y
operator|<<
literal|10
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|clip
argument_list|(
name|xFP
argument_list|,
name|iTop
argument_list|,
name|iBottom
argument_list|,
name|slopeFP
argument_list|,
name|m_leftFP
argument_list|,
name|winding
argument_list|)
condition|)
return|return;
if|if
condition|(
name|clip
argument_list|(
name|xFP
argument_list|,
name|iTop
argument_list|,
name|iBottom
argument_list|,
name|slopeFP
argument_list|,
name|m_rightFP
argument_list|,
name|winding
argument_list|)
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|xFP
operator|>=
name|m_leftFP
argument_list|)
expr_stmt|;
name|Line
name|line
init|=
block|{
name|xFP
block|,
name|slopeFP
block|,
name|iTop
block|,
name|iBottom
block|,
name|winding
block|}
decl_stmt|;
name|m_lines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_constructor
DECL|function|QRasterizer
name|QRasterizer
operator|::
name|QRasterizer
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QRasterizerPrivate
argument_list|)
block|{
name|d
operator|->
name|legacyRounding
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QRasterizer
name|QRasterizer
operator|::
name|~
name|QRasterizer
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setAntialiased
name|void
name|QRasterizer
operator|::
name|setAntialiased
parameter_list|(
name|bool
name|antialiased
parameter_list|)
block|{
name|d
operator|->
name|antialiased
operator|=
name|antialiased
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initialize
name|void
name|QRasterizer
operator|::
name|initialize
parameter_list|(
name|ProcessSpans
name|blend
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|d
operator|->
name|blend
operator|=
name|blend
expr_stmt|;
name|d
operator|->
name|data
operator|=
name|data
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setClipRect
name|void
name|QRasterizer
operator|::
name|setClipRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|clipRect
parameter_list|)
block|{
name|d
operator|->
name|clipRect
operator|=
name|clipRect
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setLegacyRoundingEnabled
name|void
name|QRasterizer
operator|::
name|setLegacyRoundingEnabled
parameter_list|(
name|bool
name|legacyRoundingEnabled
parameter_list|)
block|{
name|d
operator|->
name|legacyRounding
operator|=
name|legacyRoundingEnabled
expr_stmt|;
block|}
end_function
begin_function
DECL|function|intersectPixelFP
specifier|static
name|Q16Dot16
name|intersectPixelFP
parameter_list|(
name|int
name|x
parameter_list|,
name|Q16Dot16
name|top
parameter_list|,
name|Q16Dot16
name|bottom
parameter_list|,
name|Q16Dot16
name|leftIntersectX
parameter_list|,
name|Q16Dot16
name|rightIntersectX
parameter_list|,
name|Q16Dot16
name|slope
parameter_list|,
name|Q16Dot16
name|invSlope
parameter_list|)
block|{
name|Q16Dot16
name|leftX
init|=
name|IntToQ16Dot16
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|Q16Dot16
name|rightX
init|=
name|IntToQ16Dot16
argument_list|(
name|x
argument_list|)
operator|+
name|Q16Dot16Factor
decl_stmt|;
name|Q16Dot16
name|leftIntersectY
decl_stmt|,
name|rightIntersectY
decl_stmt|;
if|if
condition|(
name|slope
operator|>
literal|0
condition|)
block|{
name|leftIntersectY
operator|=
name|top
operator|+
name|Q16Dot16Multiply
argument_list|(
name|leftX
operator|-
name|leftIntersectX
argument_list|,
name|invSlope
argument_list|)
expr_stmt|;
name|rightIntersectY
operator|=
name|leftIntersectY
operator|+
name|invSlope
expr_stmt|;
block|}
else|else
block|{
name|leftIntersectY
operator|=
name|top
operator|+
name|Q16Dot16Multiply
argument_list|(
name|leftX
operator|-
name|rightIntersectX
argument_list|,
name|invSlope
argument_list|)
expr_stmt|;
name|rightIntersectY
operator|=
name|leftIntersectY
operator|+
name|invSlope
expr_stmt|;
block|}
if|if
condition|(
name|leftIntersectX
operator|>=
name|leftX
operator|&&
name|rightIntersectX
operator|<=
name|rightX
condition|)
block|{
return|return
name|Q16Dot16Multiply
argument_list|(
name|bottom
operator|-
name|top
argument_list|,
name|leftIntersectX
operator|-
name|leftX
operator|+
operator|(
operator|(
name|rightIntersectX
operator|-
name|leftIntersectX
operator|)
operator|>>
literal|1
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|leftIntersectX
operator|>=
name|rightX
condition|)
block|{
return|return
name|bottom
operator|-
name|top
return|;
block|}
elseif|else
if|if
condition|(
name|leftIntersectX
operator|>=
name|leftX
condition|)
block|{
if|if
condition|(
name|slope
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|bottom
operator|-
name|top
operator|)
operator|-
name|Q16Dot16FastMultiply
argument_list|(
operator|(
name|rightX
operator|-
name|leftIntersectX
operator|)
operator|>>
literal|1
argument_list|,
name|rightIntersectY
operator|-
name|top
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|bottom
operator|-
name|top
operator|)
operator|-
name|Q16Dot16FastMultiply
argument_list|(
operator|(
name|rightX
operator|-
name|leftIntersectX
operator|)
operator|>>
literal|1
argument_list|,
name|bottom
operator|-
name|rightIntersectY
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightIntersectX
operator|<=
name|leftX
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|rightIntersectX
operator|<=
name|rightX
condition|)
block|{
if|if
condition|(
name|slope
operator|>
literal|0
condition|)
block|{
return|return
name|Q16Dot16FastMultiply
argument_list|(
operator|(
name|rightIntersectX
operator|-
name|leftX
operator|)
operator|>>
literal|1
argument_list|,
name|bottom
operator|-
name|leftIntersectY
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Q16Dot16FastMultiply
argument_list|(
operator|(
name|rightIntersectX
operator|-
name|leftX
operator|)
operator|>>
literal|1
argument_list|,
name|leftIntersectY
operator|-
name|top
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|slope
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|bottom
operator|-
name|rightIntersectY
operator|)
operator|+
operator|(
operator|(
name|rightIntersectY
operator|-
name|leftIntersectY
operator|)
operator|>>
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|rightIntersectY
operator|-
name|top
operator|)
operator|+
operator|(
operator|(
name|leftIntersectY
operator|-
name|rightIntersectY
operator|)
operator|>>
literal|1
operator|)
return|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|q26Dot6Compare
specifier|static
specifier|inline
name|bool
name|q26Dot6Compare
parameter_list|(
name|qreal
name|p1
parameter_list|,
name|qreal
name|p2
parameter_list|)
block|{
return|return
name|int
argument_list|(
operator|(
name|p2
operator|-
name|p1
operator|)
operator|*
literal|64.
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qFloorF
specifier|static
specifier|inline
name|qreal
name|qFloorF
parameter_list|(
name|qreal
name|v
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_USE_MATH_H_FLOATS
if|if
condition|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
return|return
name|floorf
argument_list|(
name|v
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|floor
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|snapTo26Dot6Grid
specifier|static
specifier|inline
name|QPointF
name|snapTo26Dot6Grid
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
return|return
name|QPointF
argument_list|(
name|qFloorF
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|*
literal|64
argument_list|)
operator|*
operator|(
literal|1
operator|/
name|qreal
argument_list|(
literal|64
argument_list|)
operator|)
argument_list|,
name|qFloorF
argument_list|(
name|p
operator|.
name|y
argument_list|()
operator|*
literal|64
argument_list|)
operator|*
operator|(
literal|1
operator|/
name|qreal
argument_list|(
literal|64
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    The rasterize line function relies on some div by zero which should    result in +/-inf values. However, when floating point exceptions are    enabled, this will cause crashes, so we return high numbers instead.    As the returned value is used in further arithmetic, returning    FLT_MAX/DBL_MAX will also cause values, so instead return a value    that is well outside the int-range.  */
end_comment
begin_function
DECL|function|qSafeDivide
specifier|static
specifier|inline
name|qreal
name|qSafeDivide
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|)
block|{
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|>
literal|0
condition|?
literal|1e20
else|:
operator|-
literal|1e20
return|;
return|return
name|x
operator|/
name|y
return|;
block|}
end_function
begin_comment
comment|/* Conversion to int fails if the value is too large to fit into INT_MAX or    too small to fit into INT_MIN, so we need this slightly safer conversion    when floating point exceptions are enabled  */
end_comment
begin_function
DECL|function|qSafeFloatToQ16Dot16
specifier|static
specifier|inline
name|int
name|qSafeFloatToQ16Dot16
parameter_list|(
name|qreal
name|x
parameter_list|)
block|{
name|qreal
name|tmp
init|=
name|x
operator|*
literal|65536.
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
name|qreal
argument_list|(
name|INT_MAX
argument_list|)
condition|)
return|return
name|INT_MAX
return|;
elseif|else
if|if
condition|(
name|tmp
operator|<
name|qreal
argument_list|(
name|INT_MIN
argument_list|)
condition|)
return|return
operator|-
name|INT_MAX
return|;
return|return
name|int
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rasterizeLine
name|void
name|QRasterizer
operator|::
name|rasterizeLine
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|a
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|b
parameter_list|,
name|qreal
name|width
parameter_list|,
name|bool
name|squareCap
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
operator|||
name|width
operator|==
literal|0
operator|||
name|d
operator|->
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|width
operator|>
literal|0.0
argument_list|)
expr_stmt|;
name|QPointF
name|pa
init|=
name|a
decl_stmt|;
name|QPointF
name|pb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|squareCap
condition|)
block|{
name|QPointF
name|delta
init|=
name|pb
operator|-
name|pa
decl_stmt|;
name|pa
operator|-=
operator|(
literal|0.5f
operator|*
name|width
operator|)
operator|*
name|delta
expr_stmt|;
name|pb
operator|+=
operator|(
literal|0.5f
operator|*
name|width
operator|)
operator|*
name|delta
expr_stmt|;
block|}
name|QPointF
name|offs
init|=
name|QPointF
argument_list|(
name|qAbs
argument_list|(
name|b
operator|.
name|y
argument_list|()
operator|-
name|a
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|b
operator|.
name|x
argument_list|()
operator|-
name|a
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
operator|*
name|width
operator|*
literal|0.5
decl_stmt|;
specifier|const
name|QRectF
name|clip
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|topLeft
argument_list|()
operator|-
name|offs
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|bottomRight
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
name|offs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|clip
operator|.
name|contains
argument_list|(
name|pa
argument_list|)
operator|||
operator|!
name|clip
operator|.
name|contains
argument_list|(
name|pb
argument_list|)
condition|)
block|{
name|qreal
name|t1
init|=
literal|0
decl_stmt|;
name|qreal
name|t2
init|=
literal|1
decl_stmt|;
specifier|const
name|qreal
name|o
index|[
literal|2
index|]
init|=
block|{
name|pa
operator|.
name|x
argument_list|()
block|,
name|pa
operator|.
name|y
argument_list|()
block|}
decl_stmt|;
specifier|const
name|qreal
name|d
index|[
literal|2
index|]
init|=
block|{
name|pb
operator|.
name|x
argument_list|()
operator|-
name|pa
operator|.
name|x
argument_list|()
block|,
name|pb
operator|.
name|y
argument_list|()
operator|-
name|pa
operator|.
name|y
argument_list|()
block|}
decl_stmt|;
specifier|const
name|qreal
name|low
index|[
literal|2
index|]
init|=
block|{
name|clip
operator|.
name|left
argument_list|()
block|,
name|clip
operator|.
name|top
argument_list|()
block|}
decl_stmt|;
specifier|const
name|qreal
name|high
index|[
literal|2
index|]
init|=
block|{
name|clip
operator|.
name|right
argument_list|()
block|,
name|clip
operator|.
name|bottom
argument_list|()
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|<=
name|low
index|[
name|i
index|]
operator|||
name|o
index|[
name|i
index|]
operator|>=
name|high
index|[
name|i
index|]
condition|)
return|return;
continue|continue;
block|}
specifier|const
name|qreal
name|d_inv
init|=
literal|1
operator|/
name|d
index|[
name|i
index|]
decl_stmt|;
name|qreal
name|t_low
init|=
operator|(
name|low
index|[
name|i
index|]
operator|-
name|o
index|[
name|i
index|]
operator|)
operator|*
name|d_inv
decl_stmt|;
name|qreal
name|t_high
init|=
operator|(
name|high
index|[
name|i
index|]
operator|-
name|o
index|[
name|i
index|]
operator|)
operator|*
name|d_inv
decl_stmt|;
if|if
condition|(
name|t_low
operator|>
name|t_high
condition|)
name|qSwap
argument_list|(
name|t_low
argument_list|,
name|t_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|<
name|t_low
condition|)
name|t1
operator|=
name|t_low
expr_stmt|;
if|if
condition|(
name|t2
operator|>
name|t_high
condition|)
name|t2
operator|=
name|t_high
expr_stmt|;
if|if
condition|(
name|t1
operator|>=
name|t2
condition|)
return|return;
block|}
name|QPointF
name|npa
init|=
name|pa
operator|+
operator|(
name|pb
operator|-
name|pa
operator|)
operator|*
name|t1
decl_stmt|;
name|QPointF
name|npb
init|=
name|pa
operator|+
operator|(
name|pb
operator|-
name|pa
operator|)
operator|*
name|t2
decl_stmt|;
name|pa
operator|=
name|npa
expr_stmt|;
name|pb
operator|=
name|npb
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|antialiased
operator|&&
name|d
operator|->
name|legacyRounding
condition|)
block|{
name|pa
operator|.
name|rx
argument_list|()
operator|+=
operator|(
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
operator|)
operator|/
literal|64.
expr_stmt|;
name|pa
operator|.
name|ry
argument_list|()
operator|+=
operator|(
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
operator|)
operator|/
literal|64.
expr_stmt|;
name|pb
operator|.
name|rx
argument_list|()
operator|+=
operator|(
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
operator|)
operator|/
literal|64.
expr_stmt|;
name|pb
operator|.
name|ry
argument_list|()
operator|+=
operator|(
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
operator|)
operator|/
literal|64.
expr_stmt|;
block|}
block|{
comment|// old delta
specifier|const
name|QPointF
name|d0
init|=
name|a
operator|-
name|b
decl_stmt|;
specifier|const
name|qreal
name|w0
init|=
name|d0
operator|.
name|x
argument_list|()
operator|*
name|d0
operator|.
name|x
argument_list|()
operator|+
name|d0
operator|.
name|y
argument_list|()
operator|*
name|d0
operator|.
name|y
argument_list|()
decl_stmt|;
comment|// new delta
specifier|const
name|QPointF
name|d
init|=
name|pa
operator|-
name|pb
decl_stmt|;
specifier|const
name|qreal
name|w
init|=
name|d
operator|.
name|x
argument_list|()
operator|*
name|d
operator|.
name|x
argument_list|()
operator|+
name|d
operator|.
name|y
argument_list|()
operator|*
name|d
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
return|return;
comment|// adjust width which is given relative to |b - a|
name|width
operator|*=
name|sqrt
argument_list|(
name|w0
operator|/
name|w
argument_list|)
expr_stmt|;
block|}
name|QSpanBuffer
name|buffer
argument_list|(
name|d
operator|->
name|blend
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|d
operator|->
name|clipRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|q26Dot6Compare
argument_list|(
name|pa
operator|.
name|y
argument_list|()
argument_list|,
name|pb
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|qreal
name|x
init|=
operator|(
name|pa
operator|.
name|x
argument_list|()
operator|+
name|pb
operator|.
name|x
argument_list|()
operator|)
operator|*
literal|0.5f
decl_stmt|;
specifier|const
name|qreal
name|dx
init|=
name|qAbs
argument_list|(
name|pb
operator|.
name|x
argument_list|()
operator|-
name|pa
operator|.
name|x
argument_list|()
argument_list|)
operator|*
literal|0.5f
decl_stmt|;
specifier|const
name|qreal
name|y
init|=
name|pa
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|dy
init|=
name|width
operator|*
name|dx
decl_stmt|;
name|pa
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
operator|-
name|dy
argument_list|)
expr_stmt|;
name|pb
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|dy
argument_list|)
expr_stmt|;
name|width
operator|=
literal|1
operator|/
name|width
expr_stmt|;
block|}
if|if
condition|(
name|q26Dot6Compare
argument_list|(
name|pa
operator|.
name|x
argument_list|()
argument_list|,
name|pb
operator|.
name|x
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|pa
operator|.
name|y
argument_list|()
operator|>
name|pb
operator|.
name|y
argument_list|()
condition|)
name|qSwap
argument_list|(
name|pa
argument_list|,
name|pb
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|dy
init|=
name|pb
operator|.
name|y
argument_list|()
operator|-
name|pa
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|halfWidth
init|=
literal|0.5f
operator|*
name|width
operator|*
name|dy
decl_stmt|;
name|qreal
name|left
init|=
name|pa
operator|.
name|x
argument_list|()
operator|-
name|halfWidth
decl_stmt|;
name|qreal
name|right
init|=
name|pa
operator|.
name|x
argument_list|()
operator|+
name|halfWidth
decl_stmt|;
name|left
operator|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|left
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|right
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pa
operator|.
name|ry
argument_list|()
operator|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|pa
operator|.
name|y
argument_list|()
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|.
name|ry
argument_list|()
operator|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|pb
operator|.
name|y
argument_list|()
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q26Dot6Compare
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|||
name|q26Dot6Compare
argument_list|(
name|pa
operator|.
name|y
argument_list|()
argument_list|,
name|pb
operator|.
name|y
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|antialiased
condition|)
block|{
specifier|const
name|Q16Dot16
name|iLeft
init|=
name|int
argument_list|(
name|left
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|iRight
init|=
name|int
argument_list|(
name|right
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|leftWidth
init|=
name|IntToQ16Dot16
argument_list|(
name|iLeft
operator|+
literal|1
argument_list|)
operator|-
name|FloatToQ16Dot16
argument_list|(
name|left
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|rightWidth
init|=
name|FloatToQ16Dot16
argument_list|(
name|right
argument_list|)
operator|-
name|IntToQ16Dot16
argument_list|(
name|iRight
argument_list|)
decl_stmt|;
name|Q16Dot16
name|coverage
index|[
literal|3
index|]
decl_stmt|;
name|int
name|x
index|[
literal|3
index|]
decl_stmt|;
name|int
name|len
index|[
literal|3
index|]
decl_stmt|;
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|iLeft
operator|==
name|iRight
condition|)
block|{
name|coverage
index|[
literal|0
index|]
operator|=
operator|(
name|leftWidth
operator|+
name|rightWidth
operator|)
operator|*
literal|255
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|iLeft
expr_stmt|;
name|len
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|coverage
index|[
literal|0
index|]
operator|=
name|leftWidth
operator|*
literal|255
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|iLeft
expr_stmt|;
name|len
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|leftWidth
operator|==
name|Q16Dot16Factor
condition|)
block|{
name|len
index|[
literal|0
index|]
operator|=
name|iRight
operator|-
name|iLeft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iRight
operator|-
name|iLeft
operator|>
literal|1
condition|)
block|{
name|coverage
index|[
literal|1
index|]
operator|=
name|IntToQ16Dot16
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|iLeft
operator|+
literal|1
expr_stmt|;
name|len
index|[
literal|1
index|]
operator|=
name|iRight
operator|-
name|iLeft
operator|-
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|rightWidth
condition|)
block|{
name|coverage
index|[
name|n
index|]
operator|=
name|rightWidth
operator|*
literal|255
expr_stmt|;
name|x
index|[
name|n
index|]
operator|=
name|iRight
expr_stmt|;
name|len
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
specifier|const
name|Q16Dot16
name|iTopFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|pa
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|iBottomFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|pb
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|yPa
init|=
name|FloatToQ16Dot16
argument_list|(
name|pa
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|yPb
init|=
name|FloatToQ16Dot16
argument_list|(
name|pb
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Q16Dot16
name|yFP
init|=
name|iTopFP
init|;
name|yFP
operator|<=
name|iBottomFP
condition|;
name|yFP
operator|+=
name|Q16Dot16Factor
control|)
block|{
specifier|const
name|Q16Dot16
name|rowHeight
init|=
name|qMin
argument_list|(
name|yFP
operator|+
name|Q16Dot16Factor
argument_list|,
name|yPb
argument_list|)
operator|-
name|qMax
argument_list|(
name|yFP
argument_list|,
name|yPa
argument_list|)
decl_stmt|;
specifier|const
name|int
name|y
init|=
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|>
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
condition|)
break|break;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|addSpan
argument_list|(
name|x
index|[
name|i
index|]
argument_list|,
name|len
index|[
name|i
index|]
argument_list|,
name|y
argument_list|,
name|Q16Dot16ToInt
argument_list|(
name|Q16Dot16Multiply
argument_list|(
name|rowHeight
argument_list|,
name|coverage
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// aliased
name|int
name|iTop
init|=
name|int
argument_list|(
name|pa
operator|.
name|y
argument_list|()
operator|+
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iBottom
init|=
name|pb
operator|.
name|y
argument_list|()
operator|<
literal|0.5f
condition|?
operator|-
literal|1
else|:
name|int
argument_list|(
name|pb
operator|.
name|y
argument_list|()
operator|-
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iLeft
init|=
name|int
argument_list|(
name|left
operator|+
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iRight
init|=
name|right
operator|<
literal|0.5f
condition|?
operator|-
literal|1
else|:
name|int
argument_list|(
name|right
operator|-
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iWidth
init|=
name|iRight
operator|-
name|iLeft
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|iTop
init|;
name|y
operator|<=
name|iBottom
condition|;
operator|++
name|y
control|)
name|buffer
operator|.
name|addSpan
argument_list|(
name|iLeft
argument_list|,
name|iWidth
argument_list|,
name|y
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pa
operator|.
name|y
argument_list|()
operator|>
name|pb
operator|.
name|y
argument_list|()
condition|)
name|qSwap
argument_list|(
name|pa
argument_list|,
name|pb
argument_list|)
expr_stmt|;
name|QPointF
name|delta
init|=
name|pb
operator|-
name|pa
decl_stmt|;
name|delta
operator|*=
literal|0.5f
operator|*
name|width
expr_stmt|;
specifier|const
name|QPointF
name|perp
argument_list|(
name|delta
operator|.
name|y
argument_list|()
argument_list|,
operator|-
name|delta
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|top
decl_stmt|;
name|QPointF
name|left
decl_stmt|;
name|QPointF
name|right
decl_stmt|;
name|QPointF
name|bottom
decl_stmt|;
if|if
condition|(
name|pa
operator|.
name|x
argument_list|()
operator|<
name|pb
operator|.
name|x
argument_list|()
condition|)
block|{
name|top
operator|=
name|pa
operator|+
name|perp
expr_stmt|;
name|left
operator|=
name|pa
operator|-
name|perp
expr_stmt|;
name|right
operator|=
name|pb
operator|+
name|perp
expr_stmt|;
name|bottom
operator|=
name|pb
operator|-
name|perp
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|pa
operator|-
name|perp
expr_stmt|;
name|left
operator|=
name|pb
operator|-
name|perp
expr_stmt|;
name|right
operator|=
name|pa
operator|+
name|perp
expr_stmt|;
name|bottom
operator|=
name|pb
operator|+
name|perp
expr_stmt|;
block|}
name|top
operator|=
name|snapTo26Dot6Grid
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|snapTo26Dot6Grid
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|left
operator|=
name|snapTo26Dot6Grid
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|snapTo26Dot6Grid
argument_list|(
name|right
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|topBound
init|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|top
operator|.
name|y
argument_list|()
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|bottomBound
init|=
name|qBound
argument_list|(
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|bottom
operator|.
name|y
argument_list|()
argument_list|,
name|qreal
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QPointF
name|topLeftEdge
init|=
name|left
operator|-
name|top
decl_stmt|;
specifier|const
name|QPointF
name|topRightEdge
init|=
name|right
operator|-
name|top
decl_stmt|;
specifier|const
name|QPointF
name|bottomLeftEdge
init|=
name|bottom
operator|-
name|left
decl_stmt|;
specifier|const
name|QPointF
name|bottomRightEdge
init|=
name|bottom
operator|-
name|right
decl_stmt|;
specifier|const
name|qreal
name|topLeftSlope
init|=
name|qSafeDivide
argument_list|(
name|topLeftEdge
operator|.
name|x
argument_list|()
argument_list|,
name|topLeftEdge
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|bottomLeftSlope
init|=
name|qSafeDivide
argument_list|(
name|bottomLeftEdge
operator|.
name|x
argument_list|()
argument_list|,
name|bottomLeftEdge
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|topRightSlope
init|=
name|qSafeDivide
argument_list|(
name|topRightEdge
operator|.
name|x
argument_list|()
argument_list|,
name|topRightEdge
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|bottomRightSlope
init|=
name|qSafeDivide
argument_list|(
name|bottomRightEdge
operator|.
name|x
argument_list|()
argument_list|,
name|bottomRightEdge
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|topLeftSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|topLeftSlope
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|topRightSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|topRightSlope
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|bottomLeftSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|bottomLeftSlope
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|bottomRightSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|bottomRightSlope
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|invTopLeftSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|qSafeDivide
argument_list|(
literal|1
argument_list|,
name|topLeftSlope
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|invTopRightSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|qSafeDivide
argument_list|(
literal|1
argument_list|,
name|topRightSlope
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|invBottomLeftSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|qSafeDivide
argument_list|(
literal|1
argument_list|,
name|bottomLeftSlope
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|invBottomRightSlopeFP
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|qSafeDivide
argument_list|(
literal|1
argument_list|,
name|bottomRightSlope
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|antialiased
condition|)
block|{
specifier|const
name|Q16Dot16
name|iTopFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|topBound
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|iLeftFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|left
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|iRightFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|right
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|iBottomFP
init|=
name|IntToQ16Dot16
argument_list|(
name|int
argument_list|(
name|bottomBound
argument_list|)
argument_list|)
decl_stmt|;
name|Q16Dot16
name|leftIntersectAf
init|=
name|FloatToQ16Dot16
argument_list|(
name|top
operator|.
name|x
argument_list|()
operator|+
operator|(
name|int
argument_list|(
name|topBound
argument_list|)
operator|-
name|top
operator|.
name|y
argument_list|()
operator|)
operator|*
name|topLeftSlope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|rightIntersectAf
init|=
name|FloatToQ16Dot16
argument_list|(
name|top
operator|.
name|x
argument_list|()
operator|+
operator|(
name|int
argument_list|(
name|topBound
argument_list|)
operator|-
name|top
operator|.
name|y
argument_list|()
operator|)
operator|*
name|topRightSlope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|leftIntersectBf
init|=
literal|0
decl_stmt|;
name|Q16Dot16
name|rightIntersectBf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iLeftFP
operator|<
name|iTopFP
condition|)
name|leftIntersectBf
operator|=
name|FloatToQ16Dot16
argument_list|(
name|left
operator|.
name|x
argument_list|()
operator|+
operator|(
name|int
argument_list|(
name|topBound
argument_list|)
operator|-
name|left
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomLeftSlope
argument_list|)
expr_stmt|;
if|if
condition|(
name|iRightFP
operator|<
name|iTopFP
condition|)
name|rightIntersectBf
operator|=
name|FloatToQ16Dot16
argument_list|(
name|right
operator|.
name|x
argument_list|()
operator|+
operator|(
name|int
argument_list|(
name|topBound
argument_list|)
operator|-
name|right
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomRightSlope
argument_list|)
expr_stmt|;
name|Q16Dot16
name|rowTop
decl_stmt|,
name|rowBottomLeft
decl_stmt|,
name|rowBottomRight
decl_stmt|,
name|rowTopLeft
decl_stmt|,
name|rowTopRight
decl_stmt|,
name|rowBottom
decl_stmt|;
name|Q16Dot16
name|topLeftIntersectAf
decl_stmt|,
name|topLeftIntersectBf
decl_stmt|,
name|topRightIntersectAf
decl_stmt|,
name|topRightIntersectBf
decl_stmt|;
name|Q16Dot16
name|bottomLeftIntersectAf
decl_stmt|,
name|bottomLeftIntersectBf
decl_stmt|,
name|bottomRightIntersectAf
decl_stmt|,
name|bottomRightIntersectBf
decl_stmt|;
name|int
name|leftMin
decl_stmt|,
name|leftMax
decl_stmt|,
name|rightMin
decl_stmt|,
name|rightMax
decl_stmt|;
specifier|const
name|Q16Dot16
name|yTopFP
init|=
name|FloatToQ16Dot16
argument_list|(
name|top
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|yLeftFP
init|=
name|FloatToQ16Dot16
argument_list|(
name|left
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|yRightFP
init|=
name|FloatToQ16Dot16
argument_list|(
name|right
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Q16Dot16
name|yBottomFP
init|=
name|FloatToQ16Dot16
argument_list|(
name|bottom
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|rowTop
operator|=
name|qMax
argument_list|(
name|iTopFP
argument_list|,
name|yTopFP
argument_list|)
expr_stmt|;
name|topLeftIntersectAf
operator|=
name|leftIntersectAf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|topLeftSlopeFP
argument_list|,
name|rowTop
operator|-
name|iTopFP
argument_list|)
expr_stmt|;
name|topRightIntersectAf
operator|=
name|rightIntersectAf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|topRightSlopeFP
argument_list|,
name|rowTop
operator|-
name|iTopFP
argument_list|)
expr_stmt|;
name|Q16Dot16
name|yFP
init|=
name|iTopFP
decl_stmt|;
while|while
condition|(
name|yFP
operator|<=
name|iBottomFP
condition|)
block|{
name|rowBottomLeft
operator|=
name|qMin
argument_list|(
name|yFP
operator|+
name|Q16Dot16Factor
argument_list|,
name|yLeftFP
argument_list|)
expr_stmt|;
name|rowBottomRight
operator|=
name|qMin
argument_list|(
name|yFP
operator|+
name|Q16Dot16Factor
argument_list|,
name|yRightFP
argument_list|)
expr_stmt|;
name|rowTopLeft
operator|=
name|qMax
argument_list|(
name|yFP
argument_list|,
name|yLeftFP
argument_list|)
expr_stmt|;
name|rowTopRight
operator|=
name|qMax
argument_list|(
name|yFP
argument_list|,
name|yRightFP
argument_list|)
expr_stmt|;
name|rowBottom
operator|=
name|qMin
argument_list|(
name|yFP
operator|+
name|Q16Dot16Factor
argument_list|,
name|yBottomFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|yFP
operator|==
name|iLeftFP
condition|)
block|{
specifier|const
name|int
name|y
init|=
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
decl_stmt|;
name|leftIntersectBf
operator|=
name|FloatToQ16Dot16
argument_list|(
name|left
operator|.
name|x
argument_list|()
operator|+
operator|(
name|y
operator|-
name|left
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomLeftSlope
argument_list|)
expr_stmt|;
name|topLeftIntersectBf
operator|=
name|leftIntersectBf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|bottomLeftSlopeFP
argument_list|,
name|rowTopLeft
operator|-
name|yFP
argument_list|)
expr_stmt|;
name|bottomLeftIntersectAf
operator|=
name|leftIntersectAf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|topLeftSlopeFP
argument_list|,
name|rowBottomLeft
operator|-
name|yFP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topLeftIntersectBf
operator|=
name|leftIntersectBf
expr_stmt|;
name|bottomLeftIntersectAf
operator|=
name|leftIntersectAf
operator|+
name|topLeftSlopeFP
expr_stmt|;
block|}
if|if
condition|(
name|yFP
operator|==
name|iRightFP
condition|)
block|{
specifier|const
name|int
name|y
init|=
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
decl_stmt|;
name|rightIntersectBf
operator|=
name|FloatToQ16Dot16
argument_list|(
name|right
operator|.
name|x
argument_list|()
operator|+
operator|(
name|y
operator|-
name|right
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomRightSlope
argument_list|)
expr_stmt|;
name|topRightIntersectBf
operator|=
name|rightIntersectBf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|bottomRightSlopeFP
argument_list|,
name|rowTopRight
operator|-
name|yFP
argument_list|)
expr_stmt|;
name|bottomRightIntersectAf
operator|=
name|rightIntersectAf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|topRightSlopeFP
argument_list|,
name|rowBottomRight
operator|-
name|yFP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topRightIntersectBf
operator|=
name|rightIntersectBf
expr_stmt|;
name|bottomRightIntersectAf
operator|=
name|rightIntersectAf
operator|+
name|topRightSlopeFP
expr_stmt|;
block|}
if|if
condition|(
name|yFP
operator|==
name|iBottomFP
condition|)
block|{
name|bottomLeftIntersectBf
operator|=
name|leftIntersectBf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|bottomLeftSlopeFP
argument_list|,
name|rowBottom
operator|-
name|yFP
argument_list|)
expr_stmt|;
name|bottomRightIntersectBf
operator|=
name|rightIntersectBf
operator|+
name|Q16Dot16Multiply
argument_list|(
name|bottomRightSlopeFP
argument_list|,
name|rowBottom
operator|-
name|yFP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bottomLeftIntersectBf
operator|=
name|leftIntersectBf
operator|+
name|bottomLeftSlopeFP
expr_stmt|;
name|bottomRightIntersectBf
operator|=
name|rightIntersectBf
operator|+
name|bottomRightSlopeFP
expr_stmt|;
block|}
if|if
condition|(
name|yFP
operator|<
name|iLeftFP
condition|)
block|{
name|leftMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|bottomLeftIntersectAf
argument_list|)
expr_stmt|;
name|leftMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|topLeftIntersectAf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yFP
operator|==
name|iLeftFP
condition|)
block|{
name|leftMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|qMax
argument_list|(
name|bottomLeftIntersectAf
argument_list|,
name|topLeftIntersectBf
argument_list|)
argument_list|)
expr_stmt|;
name|leftMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|qMax
argument_list|(
name|topLeftIntersectAf
argument_list|,
name|bottomLeftIntersectBf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|topLeftIntersectBf
argument_list|)
expr_stmt|;
name|leftMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|bottomLeftIntersectBf
argument_list|)
expr_stmt|;
block|}
name|leftMin
operator|=
name|qBound
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|leftMin
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|leftMax
operator|=
name|qBound
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|leftMax
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|yFP
operator|<
name|iRightFP
condition|)
block|{
name|rightMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|topRightIntersectAf
argument_list|)
expr_stmt|;
name|rightMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|bottomRightIntersectAf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yFP
operator|==
name|iRightFP
condition|)
block|{
name|rightMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|qMin
argument_list|(
name|topRightIntersectAf
argument_list|,
name|bottomRightIntersectBf
argument_list|)
argument_list|)
expr_stmt|;
name|rightMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|qMin
argument_list|(
name|bottomRightIntersectAf
argument_list|,
name|topRightIntersectBf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightMin
operator|=
name|Q16Dot16ToInt
argument_list|(
name|bottomRightIntersectBf
argument_list|)
expr_stmt|;
name|rightMax
operator|=
name|Q16Dot16ToInt
argument_list|(
name|topRightIntersectBf
argument_list|)
expr_stmt|;
block|}
name|rightMin
operator|=
name|qBound
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|rightMin
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|rightMax
operator|=
name|qBound
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|rightMax
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftMax
operator|>
name|rightMax
condition|)
name|leftMax
operator|=
name|rightMax
expr_stmt|;
if|if
condition|(
name|rightMin
operator|<
name|leftMin
condition|)
name|rightMin
operator|=
name|leftMin
expr_stmt|;
name|Q16Dot16
name|rowHeight
init|=
name|rowBottom
operator|-
name|rowTop
decl_stmt|;
name|int
name|x
init|=
name|leftMin
decl_stmt|;
while|while
condition|(
name|x
operator|<=
name|leftMax
condition|)
block|{
name|Q16Dot16
name|excluded
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yFP
operator|<=
name|iLeftFP
condition|)
name|excluded
operator|+=
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTop
argument_list|,
name|rowBottomLeft
argument_list|,
name|bottomLeftIntersectAf
argument_list|,
name|topLeftIntersectAf
argument_list|,
name|topLeftSlopeFP
argument_list|,
name|invTopLeftSlopeFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|yFP
operator|>=
name|iLeftFP
condition|)
name|excluded
operator|+=
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTopLeft
argument_list|,
name|rowBottom
argument_list|,
name|topLeftIntersectBf
argument_list|,
name|bottomLeftIntersectBf
argument_list|,
name|bottomLeftSlopeFP
argument_list|,
name|invBottomLeftSlopeFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|rightMin
condition|)
block|{
if|if
condition|(
name|yFP
operator|<=
name|iRightFP
condition|)
name|excluded
operator|+=
operator|(
name|rowBottomRight
operator|-
name|rowTop
operator|)
operator|-
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTop
argument_list|,
name|rowBottomRight
argument_list|,
name|topRightIntersectAf
argument_list|,
name|bottomRightIntersectAf
argument_list|,
name|topRightSlopeFP
argument_list|,
name|invTopRightSlopeFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|yFP
operator|>=
name|iRightFP
condition|)
name|excluded
operator|+=
operator|(
name|rowBottom
operator|-
name|rowTopRight
operator|)
operator|-
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTopRight
argument_list|,
name|rowBottom
argument_list|,
name|bottomRightIntersectBf
argument_list|,
name|topRightIntersectBf
argument_list|,
name|bottomRightSlopeFP
argument_list|,
name|invBottomRightSlopeFP
argument_list|)
expr_stmt|;
block|}
name|Q16Dot16
name|coverage
init|=
name|rowHeight
operator|-
name|excluded
decl_stmt|;
name|buffer
operator|.
name|addSpan
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
argument_list|,
name|Q16Dot16ToInt
argument_list|(
literal|255
operator|*
name|coverage
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
name|rightMin
condition|)
block|{
name|buffer
operator|.
name|addSpan
argument_list|(
name|x
argument_list|,
name|rightMin
operator|-
name|x
argument_list|,
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
argument_list|,
name|Q16Dot16ToInt
argument_list|(
literal|255
operator|*
name|rowHeight
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|rightMin
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|<=
name|rightMax
condition|)
block|{
name|Q16Dot16
name|excluded
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yFP
operator|<=
name|iRightFP
condition|)
name|excluded
operator|+=
operator|(
name|rowBottomRight
operator|-
name|rowTop
operator|)
operator|-
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTop
argument_list|,
name|rowBottomRight
argument_list|,
name|topRightIntersectAf
argument_list|,
name|bottomRightIntersectAf
argument_list|,
name|topRightSlopeFP
argument_list|,
name|invTopRightSlopeFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|yFP
operator|>=
name|iRightFP
condition|)
name|excluded
operator|+=
operator|(
name|rowBottom
operator|-
name|rowTopRight
operator|)
operator|-
name|intersectPixelFP
argument_list|(
name|x
argument_list|,
name|rowTopRight
argument_list|,
name|rowBottom
argument_list|,
name|bottomRightIntersectBf
argument_list|,
name|topRightIntersectBf
argument_list|,
name|bottomRightSlopeFP
argument_list|,
name|invBottomRightSlopeFP
argument_list|)
expr_stmt|;
name|Q16Dot16
name|coverage
init|=
name|rowHeight
operator|-
name|excluded
decl_stmt|;
name|buffer
operator|.
name|addSpan
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|Q16Dot16ToInt
argument_list|(
name|yFP
argument_list|)
argument_list|,
name|Q16Dot16ToInt
argument_list|(
literal|255
operator|*
name|coverage
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
name|leftIntersectAf
operator|+=
name|topLeftSlopeFP
expr_stmt|;
name|leftIntersectBf
operator|+=
name|bottomLeftSlopeFP
expr_stmt|;
name|rightIntersectAf
operator|+=
name|topRightSlopeFP
expr_stmt|;
name|rightIntersectBf
operator|+=
name|bottomRightSlopeFP
expr_stmt|;
name|topLeftIntersectAf
operator|=
name|leftIntersectAf
expr_stmt|;
name|topRightIntersectAf
operator|=
name|rightIntersectAf
expr_stmt|;
name|yFP
operator|+=
name|Q16Dot16Factor
expr_stmt|;
name|rowTop
operator|=
name|yFP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// aliased
name|int
name|iTop
init|=
name|int
argument_list|(
name|top
operator|.
name|y
argument_list|()
operator|+
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iLeft
init|=
name|left
operator|.
name|y
argument_list|()
operator|<
literal|0.5f
condition|?
operator|-
literal|1
else|:
name|int
argument_list|(
name|left
operator|.
name|y
argument_list|()
operator|-
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iRight
init|=
name|right
operator|.
name|y
argument_list|()
operator|<
literal|0.5f
condition|?
operator|-
literal|1
else|:
name|int
argument_list|(
name|right
operator|.
name|y
argument_list|()
operator|-
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iBottom
init|=
name|bottom
operator|.
name|y
argument_list|()
operator|<
literal|0.5f
condition|?
operator|-
literal|1
else|:
name|int
argument_list|(
name|bottom
operator|.
name|y
argument_list|()
operator|-
literal|0.5f
argument_list|)
decl_stmt|;
name|int
name|iMiddle
init|=
name|qMin
argument_list|(
name|iLeft
argument_list|,
name|iRight
argument_list|)
decl_stmt|;
name|Q16Dot16
name|leftIntersectAf
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|top
operator|.
name|x
argument_list|()
operator|+
literal|0.5f
operator|+
operator|(
name|iTop
operator|+
literal|0.5f
operator|-
name|top
operator|.
name|y
argument_list|()
operator|)
operator|*
name|topLeftSlope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|leftIntersectBf
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|left
operator|.
name|x
argument_list|()
operator|+
literal|0.5f
operator|+
operator|(
name|iLeft
operator|+
literal|1.5f
operator|-
name|left
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomLeftSlope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|rightIntersectAf
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|top
operator|.
name|x
argument_list|()
operator|-
literal|0.5f
operator|+
operator|(
name|iTop
operator|+
literal|0.5f
operator|-
name|top
operator|.
name|y
argument_list|()
operator|)
operator|*
name|topRightSlope
argument_list|)
decl_stmt|;
name|Q16Dot16
name|rightIntersectBf
init|=
name|qSafeFloatToQ16Dot16
argument_list|(
name|right
operator|.
name|x
argument_list|()
operator|-
literal|0.5f
operator|+
operator|(
name|iRight
operator|+
literal|1.5f
operator|-
name|right
operator|.
name|y
argument_list|()
operator|)
operator|*
name|bottomRightSlope
argument_list|)
decl_stmt|;
name|int
name|ny
decl_stmt|;
name|int
name|y
init|=
name|iTop
decl_stmt|;
DECL|macro|DO_SEGMENT
define|#
directive|define
name|DO_SEGMENT
parameter_list|(
name|next
parameter_list|,
name|li
parameter_list|,
name|ri
parameter_list|,
name|ls
parameter_list|,
name|rs
parameter_list|)
define|\
value|ny = qMin(next + 1, d->clipRect.top()); \             if (y< ny) { \                 li += ls * (ny - y); \                 ri += rs * (ny - y); \                 y = ny; \             } \             if (next> d->clipRect.bottom()) \                 next = d->clipRect.bottom(); \             for (; y<= next; ++y) { \                 const int x1 = qMax(Q16Dot16ToInt(li), d->clipRect.left()); \                 const int x2 = qMin(Q16Dot16ToInt(ri), d->clipRect.right()); \                 if (x2>= x1) \                     buffer.addSpan(x1, x2 - x1 + 1, y, 255); \                 li += ls; \                 ri += rs; \              }
name|DO_SEGMENT
argument_list|(
argument|iMiddle
argument_list|,
argument|leftIntersectAf
argument_list|,
argument|rightIntersectAf
argument_list|,
argument|topLeftSlopeFP
argument_list|,
argument|topRightSlopeFP
argument_list|)
name|DO_SEGMENT
argument_list|(
argument|iRight
argument_list|,
argument|leftIntersectBf
argument_list|,
argument|rightIntersectAf
argument_list|,
argument|bottomLeftSlopeFP
argument_list|,
argument|topRightSlopeFP
argument_list|)
name|DO_SEGMENT
argument_list|(
name|iLeft
argument_list|,
name|leftIntersectAf
argument_list|,
name|rightIntersectBf
argument_list|,
name|topLeftSlopeFP
argument_list|,
name|bottomRightSlopeFP
argument_list|)
expr_stmt|;
name|DO_SEGMENT
argument_list|(
name|iBottom
argument_list|,
name|leftIntersectBf
argument_list|,
name|rightIntersectBf
argument_list|,
name|bottomLeftSlopeFP
argument_list|,
name|bottomRightSlopeFP
argument_list|)
expr_stmt|;
DECL|macro|DO_SEGMENT
undef|#
directive|undef
name|DO_SEGMENT
block|}
block|}
block|}
end_function
begin_function
DECL|function|rasterize
name|void
name|QRasterizer
operator|::
name|rasterize
parameter_list|(
specifier|const
name|QT_FT_Outline
modifier|*
name|outline
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
if|if
condition|(
name|outline
operator|->
name|n_points
operator|<
literal|3
operator|||
name|outline
operator|->
name|n_contours
operator|==
literal|0
condition|)
return|return;
specifier|const
name|QT_FT_Vector
modifier|*
name|points
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|QSpanBuffer
name|buffer
argument_list|(
name|d
operator|->
name|blend
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|d
operator|->
name|clipRect
argument_list|)
decl_stmt|;
comment|// ### QT_FT_Outline already has a bounding rect which is
comment|// ### precomputed at this point, so we should probably just be
comment|// ### using that instead...
name|QT_FT_Pos
name|min_y
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|,
name|max_y
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|outline
operator|->
name|n_points
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QT_FT_Vector
modifier|&
name|p
init|=
name|points
index|[
name|i
index|]
decl_stmt|;
name|min_y
operator|=
name|qMin
argument_list|(
name|p
operator|.
name|y
argument_list|,
name|min_y
argument_list|)
expr_stmt|;
name|max_y
operator|=
name|qMax
argument_list|(
name|p
operator|.
name|y
argument_list|,
name|max_y
argument_list|)
expr_stmt|;
block|}
name|int
name|rounding
init|=
name|d
operator|->
name|legacyRounding
condition|?
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
else|:
literal|0
decl_stmt|;
name|int
name|iTopBound
init|=
name|qMax
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|,
name|int
argument_list|(
operator|(
name|min_y
operator|+
literal|32
operator|+
name|rounding
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|iBottomBound
init|=
name|qMin
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
argument_list|,
name|int
argument_list|(
operator|(
name|max_y
operator|-
literal|32
operator|+
name|rounding
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|iTopBound
operator|>
name|iBottomBound
condition|)
return|return;
name|d
operator|->
name|scanConverter
operator|.
name|begin
argument_list|(
name|iTopBound
argument_list|,
name|iBottomBound
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|,
name|fillRule
argument_list|,
name|d
operator|->
name|legacyRounding
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outline
operator|->
name|n_contours
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|last
init|=
name|outline
operator|->
name|contours
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|first
init|;
name|j
operator|<
name|last
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|outline
operator|->
name|tags
index|[
name|j
operator|+
literal|1
index|]
operator|==
name|QT_FT_CURVE_TAG_CUBIC
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|outline
operator|->
name|tags
index|[
name|j
operator|+
literal|2
index|]
operator|==
name|QT_FT_CURVE_TAG_CUBIC
argument_list|)
expr_stmt|;
name|d
operator|->
name|scanConverter
operator|.
name|mergeCurve
argument_list|(
name|points
index|[
name|j
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|scanConverter
operator|.
name|mergeLine
argument_list|(
name|points
index|[
name|j
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|scanConverter
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rasterize
name|void
name|QRasterizer
operator|::
name|rasterize
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QSpanBuffer
name|buffer
argument_list|(
name|d
operator|->
name|blend
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|d
operator|->
name|clipRect
argument_list|)
decl_stmt|;
name|QRectF
name|bounds
init|=
name|path
operator|.
name|controlPointRect
argument_list|()
decl_stmt|;
name|double
name|rounding
init|=
name|d
operator|->
name|legacyRounding
condition|?
operator|(
name|COORD_OFFSET
operator|-
name|COORD_ROUNDING
operator|)
operator|/
literal|64.
else|:
literal|0.0
decl_stmt|;
name|int
name|iTopBound
init|=
name|qMax
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|top
argument_list|()
argument_list|,
name|int
argument_list|(
name|bounds
operator|.
name|top
argument_list|()
operator|+
literal|0.5
operator|+
name|rounding
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|iBottomBound
init|=
name|qMin
argument_list|(
name|d
operator|->
name|clipRect
operator|.
name|bottom
argument_list|()
argument_list|,
name|int
argument_list|(
name|bounds
operator|.
name|bottom
argument_list|()
operator|-
literal|0.5
operator|+
name|rounding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|iTopBound
operator|>
name|iBottomBound
condition|)
return|return;
name|d
operator|->
name|scanConverter
operator|.
name|begin
argument_list|(
name|iTopBound
argument_list|,
name|iBottomBound
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|left
argument_list|()
argument_list|,
name|d
operator|->
name|clipRect
operator|.
name|right
argument_list|()
argument_list|,
name|fillRule
argument_list|,
name|d
operator|->
name|legacyRounding
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|int
name|subpathStart
init|=
literal|0
decl_stmt|;
name|QT_FT_Vector
name|last
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|QT_FT_Vector
name|p1
init|=
name|last
decl_stmt|;
name|QT_FT_Vector
name|p2
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|scanConverter
operator|.
name|mergeLine
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|last
operator|=
name|p2
expr_stmt|;
break|break;
block|}
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|QT_FT_Vector
name|first
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|subpathStart
argument_list|)
argument_list|)
decl_stmt|;
comment|// close previous subpath
if|if
condition|(
name|first
operator|.
name|x
operator|!=
name|last
operator|.
name|x
operator|||
name|first
operator|.
name|y
operator|!=
name|last
operator|.
name|y
condition|)
name|d
operator|->
name|scanConverter
operator|.
name|mergeLine
argument_list|(
name|last
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
name|subpathStart
operator|=
name|i
expr_stmt|;
name|last
operator|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|QT_FT_Vector
name|p1
init|=
name|last
decl_stmt|;
name|QT_FT_Vector
name|p2
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QT_FT_Vector
name|p3
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QT_FT_Vector
name|p4
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|scanConverter
operator|.
name|mergeCurve
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|)
expr_stmt|;
name|last
operator|=
name|p4
expr_stmt|;
break|break;
block|}
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|QT_FT_Vector
name|first
init|=
name|PointToVector
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|subpathStart
argument_list|)
argument_list|)
decl_stmt|;
comment|// close path
if|if
condition|(
name|first
operator|.
name|x
operator|!=
name|last
operator|.
name|x
operator|||
name|first
operator|.
name|y
operator|!=
name|last
operator|.
name|y
condition|)
name|d
operator|->
name|scanConverter
operator|.
name|mergeLine
argument_list|(
name|last
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|d
operator|->
name|scanConverter
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
