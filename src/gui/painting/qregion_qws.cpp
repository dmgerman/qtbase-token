begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// XXX - add appropriate friendship relationships
end_comment
begin_define
DECL|macro|private
define|#
directive|define
name|private
value|public
end_define
begin_include
include|#
directive|include
file|"qregion.h"
end_include
begin_undef
DECL|macro|private
undef|#
directive|undef
name|private
end_undef
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<qatomic.h>
end_include
begin_include
include|#
directive|include
file|<qsemaphore.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QFastMutex
class|class
name|QFastMutex
block|{
DECL|member|contenders
name|QAtomicInt
name|contenders
decl_stmt|;
DECL|member|semaphore
name|QSemaphore
name|semaphore
decl_stmt|;
public|public:
DECL|function|QFastMutex
specifier|inline
name|QFastMutex
parameter_list|()
member_init_list|:
name|contenders
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|semaphore
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|lock
specifier|inline
name|void
name|lock
parameter_list|()
block|{
if|if
condition|(
name|contenders
operator|.
name|fetchAndAddAcquire
argument_list|(
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|semaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|contenders
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|tryLock
specifier|inline
name|bool
name|tryLock
parameter_list|()
block|{
return|return
name|contenders
operator|.
name|testAndSetAcquire
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|function|unlock
specifier|inline
name|void
name|unlock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|contenders
operator|.
name|testAndSetRelease
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|semaphore
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_comment
comment|/*  *  1 if r1 contains r2  *  0 if r1 does not completely contain r2  */
end_comment
begin_define
DECL|macro|CONTAINSCHECK
define|#
directive|define
name|CONTAINSCHECK
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
define|\
value|((r2).left()>= (r1).left()&& (r2).right()<= (r1).right()&& \      (r2).top()>= (r1).top()&& (r2).bottom()<= (r1).bottom())
end_define
begin_comment
comment|/*  *   clip region  */
end_comment
begin_struct
DECL|struct|QRegionPrivate
struct|struct
name|QRegionPrivate
super|:
specifier|public
name|QRegion
operator|::
name|QRegionData
block|{
DECL|enumerator|Single
DECL|enumerator|Vector
DECL|member|mode
enum|enum
block|{
name|Single
block|,
name|Vector
block|}
name|mode
enum|;
DECL|member|numRects
name|int
name|numRects
decl_stmt|;
DECL|member|rects
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
decl_stmt|;
DECL|member|single
name|QRect
name|single
decl_stmt|;
DECL|member|extents
name|QRect
name|extents
decl_stmt|;
DECL|member|innerRect
name|QRect
name|innerRect
decl_stmt|;
union|union
block|{
DECL|member|innerArea
name|int
name|innerArea
decl_stmt|;
DECL|member|next
name|QRegionPrivate
modifier|*
name|next
decl_stmt|;
block|}
union|;
DECL|function|vector
specifier|inline
name|void
name|vector
parameter_list|()
block|{
if|if
condition|(
name|mode
operator|!=
name|Vector
operator|&&
name|numRects
condition|)
block|{
if|if
condition|(
name|rects
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
name|rects
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rects
index|[
literal|0
index|]
operator|=
name|single
expr_stmt|;
block|}
name|mode
operator|=
name|Vector
expr_stmt|;
block|}
DECL|function|QRegionPrivate
specifier|inline
name|QRegionPrivate
parameter_list|()
member_init_list|:
name|mode
argument_list|(
name|Single
argument_list|)
member_init_list|,
name|numRects
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|innerArea
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|function|QRegionPrivate
specifier|inline
name|QRegionPrivate
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
member_init_list|:
name|mode
argument_list|(
name|Single
argument_list|)
block|{
name|numRects
operator|=
literal|1
expr_stmt|;
comment|//        rects[0] = r;
name|single
operator|=
name|r
expr_stmt|;
name|extents
operator|=
name|r
expr_stmt|;
name|innerRect
operator|=
name|r
expr_stmt|;
name|innerArea
operator|=
name|r
operator|.
name|width
argument_list|()
operator|*
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
DECL|function|QRegionPrivate
specifier|inline
name|QRegionPrivate
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|&
name|r
parameter_list|)
block|{
name|mode
operator|=
name|r
operator|.
name|mode
expr_stmt|;
name|rects
operator|=
name|r
operator|.
name|rects
expr_stmt|;
name|single
operator|=
name|r
operator|.
name|single
expr_stmt|;
name|numRects
operator|=
name|r
operator|.
name|numRects
expr_stmt|;
name|extents
operator|=
name|r
operator|.
name|extents
expr_stmt|;
name|innerRect
operator|=
name|r
operator|.
name|innerRect
expr_stmt|;
name|innerArea
operator|=
name|r
operator|.
name|innerArea
expr_stmt|;
block|}
DECL|function|operator =
specifier|inline
name|QRegionPrivate
modifier|&
name|operator
name|=
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|&
name|r
parameter_list|)
block|{
name|mode
operator|=
name|r
operator|.
name|mode
expr_stmt|;
name|rects
operator|=
name|r
operator|.
name|rects
expr_stmt|;
name|single
operator|=
name|r
operator|.
name|single
expr_stmt|;
name|numRects
operator|=
name|r
operator|.
name|numRects
expr_stmt|;
name|extents
operator|=
name|r
operator|.
name|extents
expr_stmt|;
name|innerRect
operator|=
name|r
operator|.
name|innerRect
expr_stmt|;
name|innerArea
operator|=
name|r
operator|.
name|innerArea
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|/*      * Returns true if r is guaranteed to be fully contained in this region.      * A false return value does not guarantee the opposite.      */
DECL|function|contains
specifier|inline
name|bool
name|contains
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|&
name|r
parameter_list|)
specifier|const
block|{
specifier|const
name|QRect
modifier|&
name|r1
init|=
name|innerRect
decl_stmt|;
specifier|const
name|QRect
modifier|&
name|r2
init|=
name|r
operator|.
name|extents
decl_stmt|;
return|return
name|CONTAINSCHECK
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
return|;
block|}
DECL|function|updateInnerRect
specifier|inline
name|void
name|updateInnerRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|area
init|=
name|rect
operator|.
name|width
argument_list|()
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|area
operator|>
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|area
expr_stmt|;
name|innerRect
operator|=
name|rect
expr_stmt|;
block|}
block|}
name|void
name|append
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
function_decl|;
name|void
name|prepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
function_decl|;
specifier|inline
name|bool
name|canAppend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|canPrepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|qt_nextRegionPtr
specifier|static
name|QRegionPrivate
modifier|*
name|qt_nextRegionPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_nextRegionLock
specifier|static
name|QFastMutex
name|qt_nextRegionLock
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_allocRegionMemory
specifier|static
name|QRegionPrivate
modifier|*
name|qt_allocRegionMemory
parameter_list|()
block|{
name|QRegionPrivate
modifier|*
name|rv
init|=
literal|0
decl_stmt|;
name|qt_nextRegionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_nextRegionPtr
condition|)
block|{
name|rv
operator|=
name|qt_nextRegionPtr
expr_stmt|;
name|qt_nextRegionPtr
operator|=
name|rv
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|qt_nextRegionPtr
operator|=
operator|(
name|QRegionPrivate
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|QRegionPrivate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
literal|256
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
name|ii
operator|==
literal|255
condition|)
block|{
name|qt_nextRegionPtr
index|[
name|ii
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qt_nextRegionPtr
index|[
name|ii
index|]
operator|.
name|next
operator|=
operator|&
name|qt_nextRegionPtr
index|[
name|ii
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
name|rv
operator|=
name|qt_nextRegionPtr
expr_stmt|;
name|qt_nextRegionPtr
operator|=
name|rv
operator|->
name|next
expr_stmt|;
block|}
name|qt_nextRegionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function
begin_function
DECL|function|qt_freeRegionMemory
specifier|static
name|void
name|qt_freeRegionMemory
parameter_list|(
name|QRegionPrivate
modifier|*
name|rp
parameter_list|)
block|{
name|qt_nextRegionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|qt_nextRegionPtr
expr_stmt|;
name|qt_nextRegionPtr
operator|=
name|rp
expr_stmt|;
name|qt_nextRegionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_allocRegion
specifier|static
name|QRegionPrivate
modifier|*
name|qt_allocRegion
parameter_list|()
block|{
name|QRegionPrivate
modifier|*
name|mem
init|=
name|qt_allocRegionMemory
argument_list|()
decl_stmt|;
return|return
operator|new
operator|(
name|mem
operator|)
name|QRegionPrivate
return|;
block|}
end_function
begin_function
DECL|function|qt_allocRegion
specifier|static
name|QRegionPrivate
modifier|*
name|qt_allocRegion
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|QRegionPrivate
modifier|*
name|mem
init|=
name|qt_allocRegionMemory
argument_list|()
decl_stmt|;
return|return
operator|new
operator|(
name|mem
operator|)
name|QRegionPrivate
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_allocRegion
specifier|static
name|QRegionPrivate
modifier|*
name|qt_allocRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|&
name|r
parameter_list|)
block|{
name|QRegionPrivate
modifier|*
name|mem
init|=
name|qt_allocRegionMemory
argument_list|()
decl_stmt|;
return|return
operator|new
operator|(
name|mem
operator|)
name|QRegionPrivate
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_freeRegion
name|void
name|qt_freeRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|rp
parameter_list|)
block|{
name|rp
operator|->
name|~
name|QRegionPrivate
argument_list|()
expr_stmt|;
name|qt_freeRegionMemory
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|//    delete rp;
block|}
end_function
begin_function
DECL|function|isEmptyHelper
specifier|static
specifier|inline
name|bool
name|isEmptyHelper
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|preg
parameter_list|)
block|{
return|return
operator|!
name|preg
operator|||
name|preg
operator|->
name|numRects
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|append
name|void
name|QRegionPrivate
operator|::
name|append
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|vector
argument_list|()
expr_stmt|;
name|QRect
modifier|*
name|destRect
init|=
name|rects
operator|.
name|data
argument_list|()
operator|+
name|numRects
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|srcRect
init|=
operator|(
name|r
operator|->
name|mode
operator|==
name|Vector
operator|)
condition|?
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
else|:
operator|&
name|r
operator|->
name|single
decl_stmt|;
name|int
name|numAppend
init|=
name|r
operator|->
name|numRects
decl_stmt|;
comment|// test for merge in x direction
block|{
specifier|const
name|QRect
modifier|*
name|rFirst
init|=
name|srcRect
decl_stmt|;
name|QRect
modifier|*
name|myLast
init|=
name|rects
operator|.
name|data
argument_list|()
operator|+
operator|(
name|numRects
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|rFirst
operator|->
name|top
argument_list|()
operator|==
name|myLast
operator|->
name|top
argument_list|()
operator|&&
name|rFirst
operator|->
name|height
argument_list|()
operator|==
name|myLast
operator|->
name|height
argument_list|()
operator|&&
name|rFirst
operator|->
name|left
argument_list|()
operator|==
operator|(
name|myLast
operator|->
name|right
argument_list|()
operator|+
literal|1
operator|)
condition|)
block|{
name|myLast
operator|->
name|setWidth
argument_list|(
name|myLast
operator|->
name|width
argument_list|()
operator|+
name|rFirst
operator|->
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|myLast
argument_list|)
expr_stmt|;
operator|++
name|srcRect
expr_stmt|;
operator|--
name|numAppend
expr_stmt|;
block|}
block|}
comment|// append rectangles
specifier|const
name|int
name|newNumRects
init|=
name|numRects
operator|+
name|numAppend
decl_stmt|;
if|if
condition|(
name|newNumRects
operator|>
name|rects
operator|.
name|size
argument_list|()
condition|)
block|{
name|rects
operator|.
name|resize
argument_list|(
name|newNumRects
argument_list|)
expr_stmt|;
name|destRect
operator|=
name|rects
operator|.
name|data
argument_list|()
operator|+
name|numRects
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|destRect
argument_list|,
name|srcRect
argument_list|,
name|numAppend
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// update inner rectangle
if|if
condition|(
name|innerArea
operator|<
name|r
operator|->
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|r
operator|->
name|innerArea
expr_stmt|;
name|innerRect
operator|=
name|r
operator|->
name|innerRect
expr_stmt|;
block|}
comment|// update extents
name|destRect
operator|=
operator|&
name|extents
expr_stmt|;
name|srcRect
operator|=
operator|&
name|r
operator|->
name|extents
expr_stmt|;
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|destRect
operator|->
name|left
argument_list|()
argument_list|,
name|srcRect
operator|->
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|destRect
operator|->
name|top
argument_list|()
argument_list|,
name|srcRect
operator|->
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|right
argument_list|()
argument_list|,
name|srcRect
operator|->
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|bottom
argument_list|()
argument_list|,
name|srcRect
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|numRects
operator|=
name|newNumRects
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepend
name|void
name|QRegionPrivate
operator|::
name|prepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
block|{
if|#
directive|if
literal|1
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// XXX ak: does not respect vectorization of region
name|Q_ASSERT
argument_list|(
operator|!
name|isEmpty
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|// move existing rectangles
name|memmove
argument_list|(
name|rects
operator|.
name|data
argument_list|()
operator|+
name|r
operator|->
name|numRects
argument_list|,
name|rects
operator|.
name|constData
argument_list|()
argument_list|,
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// prepend new rectangles
name|memcpy
argument_list|(
name|rects
operator|.
name|data
argument_list|()
argument_list|,
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
argument_list|,
name|r
operator|->
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// update inner rectangle
if|if
condition|(
name|innerArea
operator|<
name|r
operator|->
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|r
operator|->
name|innerArea
expr_stmt|;
name|innerRect
operator|=
name|r
operator|->
name|innerRect
expr_stmt|;
block|}
comment|// update extents
name|destRect
operator|=
operator|&
name|extents
expr_stmt|;
name|srcRect
operator|=
operator|&
name|r
operator|->
name|extents
expr_stmt|;
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|destRect
operator|->
name|left
argument_list|()
argument_list|,
name|srcRect
operator|->
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|destRect
operator|->
name|top
argument_list|()
argument_list|,
name|srcRect
operator|->
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|right
argument_list|()
argument_list|,
name|srcRect
operator|->
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|bottom
argument_list|()
argument_list|,
name|srcRect
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|numRects
operator|=
name|newNumRects
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|canAppend
name|bool
name|QRegionPrivate
operator|::
name|canAppend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|rFirst
init|=
operator|(
name|r
operator|->
name|mode
operator|==
name|Vector
operator|)
condition|?
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
else|:
operator|&
name|r
operator|->
name|single
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|myLast
init|=
operator|(
name|mode
operator|==
name|Vector
operator|)
condition|?
operator|(
name|rects
operator|.
name|constData
argument_list|()
operator|+
operator|(
name|numRects
operator|-
literal|1
operator|)
operator|)
else|:
operator|&
name|single
decl_stmt|;
comment|// XXX: possible improvements:
comment|//   - nFirst->top() == myLast->bottom() + 1, must possibly merge bands
if|if
condition|(
name|rFirst
operator|->
name|top
argument_list|()
operator|>
operator|(
name|myLast
operator|->
name|bottom
argument_list|()
operator|+
literal|1
operator|)
operator|||
operator|(
name|rFirst
operator|->
name|top
argument_list|()
operator|==
name|myLast
operator|->
name|top
argument_list|()
operator|&&
name|rFirst
operator|->
name|height
argument_list|()
operator|==
name|myLast
operator|->
name|height
argument_list|()
operator|&&
name|rFirst
operator|->
name|left
argument_list|()
operator|>
name|myLast
operator|->
name|right
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canPrepend
name|bool
name|QRegionPrivate
operator|::
name|canPrepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
block|{
if|#
directive|if
literal|1
name|Q_UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
return|return
name|r
operator|->
name|canAppend
argument_list|(
name|this
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
end_if
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qregion_x11.cpp"
name|QT_END_INCLUDE_NAMESPACE
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qregion_mac.cpp"
name|QT_END_INCLUDE_NAMESPACE
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
specifier|static
name|QRegionPrivate
name|qrp
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QRegion
operator|::
name|QRegionData
name|QRegion
operator|::
name|shared_empty
init|=
block|{
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
block|,
operator|&
name|qrp
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|OverlapFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|OverlapFunc
function_decl|)
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|NonOverlapFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|NonOverlapFunc
function_decl|)
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
specifier|static
name|bool
name|EqualRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|r2
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|UnionRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|miRegionOp
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|OverlapFunc
name|overlapFunc
parameter_list|,
name|NonOverlapFunc
name|nonOverlap1Func
parameter_list|,
name|NonOverlapFunc
name|nonOverlap2Func
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|RectangleOut
define|#
directive|define
name|RectangleOut
value|0
end_define
begin_define
DECL|macro|RectangleIn
define|#
directive|define
name|RectangleIn
value|1
end_define
begin_define
DECL|macro|RectanglePart
define|#
directive|define
name|RectanglePart
value|2
end_define
begin_define
DECL|macro|EvenOddRule
define|#
directive|define
name|EvenOddRule
value|0
end_define
begin_define
DECL|macro|WindingRule
define|#
directive|define
name|WindingRule
value|1
end_define
begin_comment
comment|// START OF region.h extract
end_comment
begin_comment
comment|/* $XConsortium: region.h,v 11.14 94/04/17 20:22:20 rws Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_XREGION_H
end_ifndef
begin_define
DECL|macro|_XREGION_H
define|#
directive|define
name|_XREGION_H
end_define
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<limits.h>
name|QT_END_INCLUDE_NAMESPACE
comment|/*  1 if two BOXs overlap.  *  0 if two BOXs do not overlap.  *  Remember, x2 and y2 are not in the region  */
DECL|macro|EXTENTCHECK
define|#
directive|define
name|EXTENTCHECK
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
define|\
value|((r1)->right()>= (r2)->left()&& \          (r1)->left()<= (r2)->right()&& \          (r1)->bottom()>= (r2)->top()&& \          (r1)->top()<= (r2)->bottom())
comment|/*  *  update region extents  */
DECL|macro|EXTENTS
define|#
directive|define
name|EXTENTS
parameter_list|(
name|r
parameter_list|,
name|idRect
parameter_list|)
value|{\             if((r)->left()< (idRect)->extents.left())\               (idRect)->extents.setLeft((r)->left());\             if((r)->top()< (idRect)->extents.top())\               (idRect)->extents.setTop((r)->top());\             if((r)->right()> (idRect)->extents.right())\               (idRect)->extents.setRight((r)->right());\             if((r)->bottom()> (idRect)->extents.bottom())\               (idRect)->extents.setBottom((r)->bottom());\         }
comment|/*  *   Check to see if there is enough memory in the present region.  */
DECL|macro|MEMCHECK
define|#
directive|define
name|MEMCHECK
parameter_list|(
name|dest
parameter_list|,
name|rect
parameter_list|,
name|firstrect
parameter_list|)
value|{\         if ((dest).numRects>= ((dest).rects.size()-1)){\           firstrect.resize(firstrect.size() * 2); \           (rect) = (firstrect).data() + (dest).numRects;\         }\       }
comment|/*  * number of points to buffer before sending them off  * to scanlines(): Must be an even number  */
DECL|macro|NUMPTSTOBUFFER
define|#
directive|define
name|NUMPTSTOBUFFER
value|200
comment|/*  * used to allocate buffers for points and link  * the buffers together  */
decl|typedef struct
DECL|struct|_POINTBLOCK
name|_POINTBLOCK
argument_list|{
DECL|member|pts
name|QPoint
name|pts
index|[
name|NUMPTSTOBUFFER
index|]
argument_list|;
DECL|member|next
expr|struct
name|_POINTBLOCK
operator|*
name|next
argument_list|; }
DECL|typedef|POINTBLOCK
name|POINTBLOCK
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// END OF region.h extract
end_comment
begin_comment
comment|// START OF Region.c extract
end_comment
begin_comment
comment|/* $XConsortium: Region.c /main/30 1996/10/22 14:21:24 kaleb $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987, 1988  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/*  * The functions in this file implement the Region abstraction, similar to one  * used in the X11 sample server. A Region is simply an area, as the name  * implies, and is implemented as a "y-x-banded" array of rectangles. To  * explain: Each Region is made up of a certain number of rectangles sorted  * by y coordinate first, and then by x coordinate.  *  * Furthermore, the rectangles are banded such that every rectangle with a  * given upper-left y coordinate (y1) will have the same lower-right y  * coordinate (y2) and vice versa. If a rectangle has scanlines in a band, it  * will span the entire vertical distance of the band. This means that some  * areas that could be merged into a taller rectangle will be represented as  * several shorter rectangles to account for shorter rectangles to its left  * or right but within its "vertical scope".  *  * An added constraint on the rectangles is that they must cover as much  * horizontal area as possible. E.g. no two rectangles in a band are allowed  * to touch.  *  * Whenever possible, bands will be merged together to cover a greater vertical  * distance (and thus reduce the number of rectangles). Two bands can be merged  * only if the bottom of one touches the top of the other and they have  * rectangles in the same places (of the same width, of course). This maintains  * the y-x-banding that's so nice to have...  */
end_comment
begin_comment
comment|/* $XFree86: xc/lib/X11/Region.c,v 1.1.1.2.2.2 1998/10/04 15:22:50 hohndel Exp $ */
end_comment
begin_function
DECL|function|UnionRectWithRegion
specifier|static
name|void
name|UnionRectWithRegion
parameter_list|(
specifier|register
specifier|const
name|QRect
modifier|*
name|rect
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|source
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rect
operator|->
name|width
argument_list|()
operator|||
operator|!
name|rect
operator|->
name|height
argument_list|()
condition|)
return|return;
name|QRegionPrivate
name|region
argument_list|(
operator|*
name|rect
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|EqualRegion
argument_list|(
name|source
argument_list|,
operator|&
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
operator|&
name|region
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|==
literal|0
condition|)
name|dest
operator|=
name|region
expr_stmt|;
elseif|else
if|if
condition|(
name|dest
operator|.
name|canAppend
argument_list|(
operator|&
name|region
argument_list|)
condition|)
name|dest
operator|.
name|append
argument_list|(
operator|&
name|region
argument_list|)
expr_stmt|;
else|else
name|UnionRegion
argument_list|(
operator|&
name|region
argument_list|,
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSetExtents --  *      Reset the extents and innerRect of a region to what they should be.  *      Called by miSubtract and miIntersect b/c they can't figure it out  *      along the way or do so easily, as miUnion can.  *  * Results:  *      None.  *  * Side Effects:  *      The region's 'extents' and 'innerRect' structure is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSetExtents
specifier|static
name|void
name|miSetExtents
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
specifier|register
specifier|const
name|QRect
modifier|*
name|pBox
decl_stmt|,
modifier|*
name|pBoxEnd
decl_stmt|;
specifier|register
name|QRect
modifier|*
name|pExtents
decl_stmt|;
name|dest
operator|.
name|innerRect
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dest
operator|.
name|innerArea
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|==
literal|0
condition|)
block|{
name|dest
operator|.
name|extents
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|pExtents
operator|=
operator|&
name|dest
operator|.
name|extents
expr_stmt|;
name|pBox
operator|=
operator|(
name|dest
operator|.
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
operator|(
name|dest
operator|.
name|rects
operator|.
name|constData
argument_list|()
operator|)
else|:
operator|(
operator|&
name|dest
operator|.
name|single
operator|)
expr_stmt|;
name|pBoxEnd
operator|=
operator|(
name|dest
operator|.
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
operator|(
operator|&
name|pBox
index|[
name|dest
operator|.
name|numRects
operator|-
literal|1
index|]
operator|)
else|:
operator|(
operator|&
name|dest
operator|.
name|single
operator|)
expr_stmt|;
comment|/*      * Since pBox is the first rectangle in the region, it must have the      * smallest y1 and since pBoxEnd is the last rectangle in the region,      * it must have the largest y2, because of banding. Initialize x1 and      * x2 from  pBox and pBoxEnd, resp., as good things to initialize them      * to...      */
name|pExtents
operator|->
name|setLeft
argument_list|(
name|pBox
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setTop
argument_list|(
name|pBox
operator|->
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setRight
argument_list|(
name|pBoxEnd
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setBottom
argument_list|(
name|pBoxEnd
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|pExtents
operator|->
name|top
argument_list|()
operator|<=
name|pExtents
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|pBox
operator|<=
name|pBoxEnd
condition|)
block|{
if|if
condition|(
name|pBox
operator|->
name|left
argument_list|()
operator|<
name|pExtents
operator|->
name|left
argument_list|()
condition|)
name|pExtents
operator|->
name|setLeft
argument_list|(
name|pBox
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBox
operator|->
name|right
argument_list|()
operator|>
name|pExtents
operator|->
name|right
argument_list|()
condition|)
name|pExtents
operator|->
name|setRight
argument_list|(
name|pBox
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pBox
argument_list|)
expr_stmt|;
operator|++
name|pBox
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|pExtents
operator|->
name|left
argument_list|()
operator|<=
name|pExtents
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* TranslateRegion(pRegion, x, y)    translates in place    added by raymond */
end_comment
begin_function
DECL|function|OffsetRegion
specifier|static
name|void
name|OffsetRegion
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|region
parameter_list|,
specifier|register
name|int
name|x
parameter_list|,
specifier|register
name|int
name|y
parameter_list|)
block|{
specifier|register
name|int
name|nbox
decl_stmt|;
specifier|register
name|QRect
modifier|*
name|pbox
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
block|{
name|region
operator|.
name|single
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbox
operator|=
name|region
operator|.
name|rects
operator|.
name|data
argument_list|()
expr_stmt|;
name|nbox
operator|=
name|region
operator|.
name|numRects
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|pbox
operator|->
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|++
name|pbox
expr_stmt|;
block|}
block|}
name|region
operator|.
name|extents
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|region
operator|.
name|innerRect
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *          Region Intersection  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miIntersectO --  *      Handle an overlapping band for miIntersect.  *  * Results:  *      None.  *  * Side Effects:  *      Rectangles may be added to the region.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miIntersectO
specifier|static
name|void
name|miIntersectO
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
specifier|register
name|int
name|x1
decl_stmt|;
specifier|register
name|int
name|x2
decl_stmt|;
specifier|register
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
name|x1
operator|=
name|qMax
argument_list|(
name|r1
operator|->
name|left
argument_list|()
argument_list|,
name|r2
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|x2
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|r2
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * If there's any overlap between the two rectangles, add that          * overlap to the new region.          * There's no need to check for subsumption because the only way          * such a need could arise is if some region has two rectangles          * right next to each other. Since that should never happen...          */
if|if
condition|(
name|x1
operator|<=
name|x2
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
block|}
comment|/*          * Need to advance the pointers. Shift the one that extends          * to the right the least, since the other still has a chance to          * overlap with that region's next rectangle, if you see what I mean.          */
if|if
condition|(
name|r1
operator|->
name|right
argument_list|()
operator|<
name|r2
operator|->
name|right
argument_list|()
condition|)
block|{
operator|++
name|r1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|right
argument_list|()
operator|<
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
operator|++
name|r2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|r1
expr_stmt|;
operator|++
name|r2
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*======================================================================  *          Generic Region Operator  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miCoalesce --  *      Attempt to merge the boxes in the current band with those in the  *      previous one. Used only by miRegionOp.  *  * Results:  *      The new index for the previous band.  *  * Side Effects:  *      If coalescing takes place:  *          - rectangles in the previous band will have their y2 fields  *            altered.  *          - dest.numRects will be decreased.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miCoalesce
specifier|static
name|int
name|miCoalesce
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
name|int
name|prevStart
parameter_list|,
name|int
name|curStart
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|pPrevBox
decl_stmt|;
comment|/* Current box in previous band */
specifier|register
name|QRect
modifier|*
name|pCurBox
decl_stmt|;
comment|/* Current box in current band */
specifier|register
name|QRect
modifier|*
name|pRegEnd
decl_stmt|;
comment|/* End of region */
name|int
name|curNumRects
decl_stmt|;
comment|/* Number of rectangles in current band */
name|int
name|prevNumRects
decl_stmt|;
comment|/* Number of rectangles in previous band */
name|int
name|bandY1
decl_stmt|;
comment|/* Y1 coordinate for current band */
name|QRect
modifier|*
name|rData
init|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
decl_stmt|;
name|pRegEnd
operator|=
name|rData
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|pPrevBox
operator|=
name|rData
operator|+
name|prevStart
expr_stmt|;
name|prevNumRects
operator|=
name|curStart
operator|-
name|prevStart
expr_stmt|;
comment|/*      * Figure out how many rectangles are in the current band. Have to do      * this because multiple bands could have been added in miRegionOp      * at the end when one region has been exhausted.      */
name|pCurBox
operator|=
name|rData
operator|+
name|curStart
expr_stmt|;
name|bandY1
operator|=
name|pCurBox
operator|->
name|top
argument_list|()
expr_stmt|;
for|for
control|(
name|curNumRects
operator|=
literal|0
init|;
name|pCurBox
operator|!=
name|pRegEnd
operator|&&
name|pCurBox
operator|->
name|top
argument_list|()
operator|==
name|bandY1
condition|;
operator|++
name|curNumRects
control|)
block|{
operator|++
name|pCurBox
expr_stmt|;
block|}
if|if
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
block|{
comment|/*          * If more than one band was added, we have to find the start          * of the last band added so the next coalescing job can start          * at the right place... (given when multiple bands are added,          * this may be pointless -- see above).          */
operator|--
name|pRegEnd
expr_stmt|;
while|while
condition|(
operator|(
name|pRegEnd
operator|-
literal|1
operator|)
operator|->
name|top
argument_list|()
operator|==
name|pRegEnd
operator|->
name|top
argument_list|()
condition|)
operator|--
name|pRegEnd
expr_stmt|;
name|curStart
operator|=
name|pRegEnd
operator|-
name|rData
expr_stmt|;
name|pRegEnd
operator|=
name|rData
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
block|}
if|if
condition|(
name|curNumRects
operator|==
name|prevNumRects
operator|&&
name|curNumRects
operator|!=
literal|0
condition|)
block|{
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/*          * The bands may only be coalesced if the bottom of the previous          * matches the top scanline of the current.          */
if|if
condition|(
name|pPrevBox
operator|->
name|bottom
argument_list|()
operator|==
name|pCurBox
operator|->
name|top
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|/*              * Make sure the bands have boxes in the same places. This              * assumes that boxes have been added in such a way that they              * cover the most area possible. I.e. two boxes in a band must              * have some horizontal space between them.              */
do|do
block|{
if|if
condition|(
name|pPrevBox
operator|->
name|left
argument_list|()
operator|!=
name|pCurBox
operator|->
name|left
argument_list|()
operator|||
name|pPrevBox
operator|->
name|right
argument_list|()
operator|!=
name|pCurBox
operator|->
name|right
argument_list|()
condition|)
block|{
comment|// The bands don't line up so they can't be coalesced.
return|return
name|curStart
return|;
block|}
operator|++
name|pPrevBox
expr_stmt|;
operator|++
name|pCurBox
expr_stmt|;
operator|--
name|prevNumRects
expr_stmt|;
block|}
do|while
condition|(
name|prevNumRects
operator|!=
literal|0
condition|)
do|;
name|dest
operator|.
name|numRects
operator|-=
name|curNumRects
expr_stmt|;
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
name|pPrevBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/*              * The bands may be merged, so set the bottom y of each box              * in the previous band to that of the corresponding box in              * the current band.              */
do|do
block|{
name|pPrevBox
operator|->
name|setBottom
argument_list|(
name|pCurBox
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pPrevBox
argument_list|)
expr_stmt|;
operator|++
name|pPrevBox
expr_stmt|;
operator|++
name|pCurBox
expr_stmt|;
name|curNumRects
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|curNumRects
operator|!=
literal|0
condition|)
do|;
comment|/*              * If only one band was added to the region, we have to backup              * curStart to the start of the previous band.              *              * If more than one band was added to the region, copy the              * other bands down. The assumption here is that the other bands              * came from the same region as the current one and no further              * coalescing can be done on them since it's all been done              * already... curStart is already in the right place.              */
if|if
condition|(
name|pCurBox
operator|==
name|pRegEnd
condition|)
block|{
name|curStart
operator|=
name|prevStart
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
operator|*
name|pPrevBox
operator|++
operator|=
operator|*
name|pCurBox
operator|++
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pPrevBox
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
do|;
block|}
block|}
block|}
return|return
name|curStart
return|;
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miRegionOp --  *      Apply an operation to two regions. Called by miUnion, miInverse,  *      miSubtract, miIntersect...  *  * Results:  *      None.  *  * Side Effects:  *      The new region is overwritten.  *  * Notes:  *      The idea behind this function is to view the two regions as sets.  *      Together they cover a rectangle of area that this function divides  *      into horizontal bands where points are covered only by one region  *      or by both. For the first case, the nonOverlapFunc is called with  *      each the band and the band's upper and lower extents. For the  *      second, the overlapFunc is called to process the entire band. It  *      is responsible for clipping the rectangles in the band, though  *      this function provides the boundaries.  *      At the end of each band, the new region is coalesced, if possible,  *      to reduce the number of rectangles in the region.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miRegionOp
specifier|static
name|void
name|miRegionOp
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|OverlapFunc
name|overlapFunc
parameter_list|,
name|NonOverlapFunc
name|nonOverlap1Func
parameter_list|,
name|NonOverlapFunc
name|nonOverlap2Func
parameter_list|)
block|{
specifier|register
specifier|const
name|QRect
modifier|*
name|r1
decl_stmt|;
comment|// Pointer into first region
specifier|register
specifier|const
name|QRect
modifier|*
name|r2
decl_stmt|;
comment|// Pointer into 2d region
specifier|const
name|QRect
modifier|*
name|r1End
decl_stmt|;
comment|// End of 1st region
specifier|const
name|QRect
modifier|*
name|r2End
decl_stmt|;
comment|// End of 2d region
specifier|register
name|int
name|ybot
decl_stmt|;
comment|// Bottom of intersection
specifier|register
name|int
name|ytop
decl_stmt|;
comment|// Top of intersection
name|int
name|prevBand
decl_stmt|;
comment|// Index of start of previous band in dest
name|int
name|curBand
decl_stmt|;
comment|// Index of start of current band in dest
specifier|register
specifier|const
name|QRect
modifier|*
name|r1BandEnd
decl_stmt|;
comment|// End of current band in r1
specifier|register
specifier|const
name|QRect
modifier|*
name|r2BandEnd
decl_stmt|;
comment|// End of current band in r2
name|int
name|top
decl_stmt|;
comment|// Top of non-overlapping band
name|int
name|bot
decl_stmt|;
comment|// Bottom of non-overlapping band
comment|/*      * Initialization:      *  set r1, r2, r1End and r2End appropriately, preserve the important      * parts of the destination region until the end in case it's one of      * the two source regions, then mark the "new" region empty, allocating      * another array of rectangles for it to use.      */
name|r1
operator|=
operator|(
name|reg1
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
name|reg1
operator|->
name|rects
operator|.
name|data
argument_list|()
else|:
operator|&
name|reg1
operator|->
name|single
expr_stmt|;
name|r2
operator|=
operator|(
name|reg2
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
name|reg2
operator|->
name|rects
operator|.
name|data
argument_list|()
else|:
operator|&
name|reg2
operator|->
name|single
expr_stmt|;
name|r1End
operator|=
name|r1
operator|+
name|reg1
operator|->
name|numRects
expr_stmt|;
name|r2End
operator|=
name|r2
operator|+
name|reg2
operator|->
name|numRects
expr_stmt|;
name|dest
operator|.
name|vector
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|oldRects
init|=
name|dest
operator|.
name|rects
decl_stmt|;
name|dest
operator|.
name|numRects
operator|=
literal|0
expr_stmt|;
comment|/*      * Allocate a reasonable number of rectangles for the new region. The idea      * is to allocate enough so the individual functions don't need to      * reallocate and copy the array, which is time consuming, yet we don't      * have to worry about using too much memory. I hope to be able to      * nuke the realloc() at the end of this function eventually.      */
name|dest
operator|.
name|rects
operator|.
name|resize
argument_list|(
name|qMax
argument_list|(
name|reg1
operator|->
name|numRects
argument_list|,
name|reg2
operator|->
name|numRects
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Initialize ybot and ytop.      * In the upcoming loop, ybot and ytop serve different functions depending      * on whether the band being handled is an overlapping or non-overlapping      * band.      *  In the case of a non-overlapping band (only one of the regions      * has points in the band), ybot is the bottom of the most recent      * intersection and thus clips the top of the rectangles in that band.      * ytop is the top of the next intersection between the two regions and      * serves to clip the bottom of the rectangles in the current band.      *  For an overlapping band (where the two regions intersect), ytop clips      * the top of the rectangles of both regions and ybot clips the bottoms.      */
if|if
condition|(
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|<
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
condition|)
name|ybot
operator|=
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|-
literal|1
expr_stmt|;
else|else
name|ybot
operator|=
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/*      * prevBand serves to mark the start of the previous band so rectangles      * can be coalesced into larger rectangles. qv. miCoalesce, above.      * In the beginning, there is no previous band, so prevBand == curBand      * (curBand is set later on, of course, but the first band will always      * start at index 0). prevBand and curBand must be indices because of      * the possible expansion, and resultant moving, of the new region's      * array of rectangles.      */
name|prevBand
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
comment|/*          * This algorithm proceeds one source-band (as opposed to a          * destination band, which is determined by where the two regions          * intersect) at a time. r1BandEnd and r2BandEnd serve to mark the          * rectangle after the last one in the current band for their          * respective regions.          */
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
name|r1BandEnd
operator|!=
name|r1End
operator|&&
name|r1BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r1
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r1BandEnd
expr_stmt|;
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
name|r2BandEnd
operator|!=
name|r2End
operator|&&
name|r2BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r2
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r2BandEnd
expr_stmt|;
comment|/*          * First handle the band that doesn't intersect, if any.          *          * Note that attention is restricted to one band in the          * non-intersecting region at once, so if a region has n          * bands between the current position and the next place it overlaps          * the other, this entire loop will be passed through n times.          */
if|if
condition|(
name|r1
operator|->
name|top
argument_list|()
operator|<
name|r2
operator|->
name|top
argument_list|()
condition|)
block|{
name|top
operator|=
name|qMax
argument_list|(
name|r1
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|bottom
argument_list|()
argument_list|,
name|r2
operator|->
name|top
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonOverlap1Func
operator|!=
literal|0
operator|&&
name|bot
operator|>=
name|top
condition|)
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|ytop
operator|=
name|r2
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|top
argument_list|()
operator|<
name|r1
operator|->
name|top
argument_list|()
condition|)
block|{
name|top
operator|=
name|qMax
argument_list|(
name|r2
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|=
name|qMin
argument_list|(
name|r2
operator|->
name|bottom
argument_list|()
argument_list|,
name|r1
operator|->
name|top
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonOverlap2Func
operator|!=
literal|0
operator|&&
name|bot
operator|>=
name|top
condition|)
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|dest
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|ytop
operator|=
name|r1
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ytop
operator|=
name|r1
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
comment|/*          * If any rectangles got added to the region, try and coalesce them          * with rectangles from the previous band. Note we could just do          * this test in miCoalesce, but some machines incur a not          * inconsiderable cost for function calls, so...          */
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*          * Now see if we've hit an intersecting band. The two bands only          * intersect if ybot>= ytop          */
name|ybot
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|bottom
argument_list|()
argument_list|,
name|r2
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
if|if
condition|(
name|ybot
operator|>=
name|ytop
condition|)
call|(
modifier|*
name|overlapFunc
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|ytop
argument_list|,
name|ybot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*          * If we've finished with a band (y2 == ybot) we skip forward          * in the region to the next band.          */
if|if
condition|(
name|r1
operator|->
name|bottom
argument_list|()
operator|==
name|ybot
condition|)
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
if|if
condition|(
name|r2
operator|->
name|bottom
argument_list|()
operator|==
name|ybot
condition|)
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
do|;
comment|/*      * Deal with whichever region still has rectangles left.      */
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
if|if
condition|(
name|nonOverlap1Func
operator|!=
literal|0
condition|)
block|{
do|do
block|{
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
name|r1BandEnd
operator|<
name|r1End
operator|&&
name|r1BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r1
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r1BandEnd
expr_stmt|;
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|qMax
argument_list|(
name|r1
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
argument_list|,
name|r1
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|r2
operator|!=
name|r2End
operator|)
operator|&&
operator|(
name|nonOverlap2Func
operator|!=
literal|0
operator|)
condition|)
block|{
do|do
block|{
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
name|r2BandEnd
operator|<
name|r2End
operator|&&
name|r2BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r2
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r2BandEnd
expr_stmt|;
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|dest
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|qMax
argument_list|(
name|r2
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
argument_list|,
name|r2
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
do|;
block|}
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
operator|(
name|void
operator|)
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*      * A bit of cleanup. To keep regions from growing without bound,      * we shrink the array of rectangles to match the new number of      * rectangles in the region.      *      * Only do this stuff if the number of rectangles allocated is more than      * twice the number of rectangles in the region (a simple optimization).      */
if|if
condition|(
name|qMax
argument_list|(
literal|4
argument_list|,
name|dest
operator|.
name|numRects
argument_list|)
operator|<
operator|(
name|dest
operator|.
name|rects
operator|.
name|size
argument_list|()
operator|>>
literal|1
operator|)
condition|)
name|dest
operator|.
name|rects
operator|.
name|resize
argument_list|(
name|dest
operator|.
name|numRects
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *          Region Union  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionNonO --  *      Handle a non-overlapping band for the union operation. Just  *      Adds the rectangles into the region. Doesn't have to check for  *      subsumption or anything.  *  * Results:  *      None.  *  * Side Effects:  *      dest.numRects is incremented and the final rectangles overwritten  *      with the rectangles we're passed.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miUnionNonO
specifier|static
name|void
name|miUnionNonO
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|left
argument_list|()
operator|<=
name|r
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|r
operator|->
name|left
argument_list|()
argument_list|,
name|y1
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|dest
operator|.
name|numRects
operator|++
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionO --  *      Handle an overlapping band for the union operation. Picks the  *      left-most rectangle each time and merges it into the region.  *  * Results:  *      None.  *  * Side Effects:  *      Rectangles are overwritten in dest.rects and dest.numRects will  *      be changed.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miUnionO
specifier|static
name|void
name|miUnionO
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
DECL|macro|MERGERECT
define|#
directive|define
name|MERGERECT
parameter_list|(
name|r
parameter_list|)
define|\
value|if ((dest.numRects != 0)&&  \         (pNextRect[-1].top() == y1)&&  \         (pNextRect[-1].bottom() == y2)&&  \         (pNextRect[-1].right()>= r->left()-1)) { \         if (pNextRect[-1].right()< r->right()) { \             pNextRect[-1].setRight(r->right());  \             dest.updateInnerRect(pNextRect[-1]); \             Q_ASSERT(pNextRect[-1].left()<= pNextRect[-1].right()); \         }  \     } else { \         MEMCHECK(dest, pNextRect, dest.rects)  \         pNextRect->setCoords(r->left(), y1, r->right(), y2); \         dest.updateInnerRect(*pNextRect); \         dest.numRects++;  \         pNextRect++;  \     }  \     r++;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|left
argument_list|()
operator|<
name|r2
operator|->
name|left
argument_list|()
condition|)
block|{
name|MERGERECT
argument_list|(
argument|r1
argument_list|)
block|}
else|else
block|{
name|MERGERECT
argument_list|(
argument|r2
argument_list|)
block|}
block|}
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
do|do
block|{
name|MERGERECT
argument_list|(
argument|r1
argument_list|)
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
block|{
name|MERGERECT
argument_list|(
argument|r2
argument_list|)
block|}
block|}
block|}
end_function
begin_function
DECL|function|UnionRegion
specifier|static
name|void
name|UnionRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|reg1
argument_list|)
operator|&&
operator|!
name|isEmptyHelper
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg1
operator|->
name|contains
argument_list|(
operator|*
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg2
operator|->
name|contains
argument_list|(
operator|*
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg1
operator|->
name|canAppend
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg2
operator|->
name|canAppend
argument_list|(
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg1
operator|->
name|innerArea
operator|>
name|reg2
operator|->
name|innerArea
condition|)
block|{
name|dest
operator|.
name|innerArea
operator|=
name|reg1
operator|->
name|innerArea
expr_stmt|;
name|dest
operator|.
name|innerRect
operator|=
name|reg1
operator|->
name|innerRect
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|.
name|innerArea
operator|=
name|reg2
operator|->
name|innerArea
expr_stmt|;
name|dest
operator|.
name|innerRect
operator|=
name|reg2
operator|->
name|innerRect
expr_stmt|;
block|}
name|miRegionOp
argument_list|(
name|dest
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|,
name|miUnionO
argument_list|,
name|miUnionNonO
argument_list|,
name|miUnionNonO
argument_list|)
expr_stmt|;
name|dest
operator|.
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *        Region Subtraction  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractNonO --  *      Deal with non-overlapping band for subtraction. Any parts from  *      region 2 we discard. Anything from region 1 we add to the region.  *  * Results:  *      None.  *  * Side Effects:  *      dest may be affected.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSubtractNonO1
specifier|static
name|void
name|miSubtractNonO1
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|left
argument_list|()
operator|<=
name|r
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|r
operator|->
name|left
argument_list|()
argument_list|,
name|y1
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractO --  *      Overlapping band subtraction. x1 is the left-most point not yet  *      checked.  *  * Results:  *      None.  *  * Side Effects:  *      dest may have rectangles added to it.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSubtractO
specifier|static
name|void
name|miSubtractO
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|register
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
specifier|register
name|int
name|y1
parameter_list|,
specifier|register
name|int
name|y2
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
specifier|register
name|int
name|x1
decl_stmt|;
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
if|if
condition|(
name|r2
operator|->
name|right
argument_list|()
operator|<
name|x1
condition|)
block|{
comment|/*              * Subtrahend missed the boat: go to next subtrahend.              */
operator|++
name|r2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|left
argument_list|()
operator|<=
name|x1
condition|)
block|{
comment|/*              * Subtrahend precedes minuend: nuke left edge of minuend.              */
name|x1
operator|=
name|r2
operator|->
name|right
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*                  * Minuend completely covered: advance to next minuend and                  * reset left fence to edge of new minuend.                  */
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Subtrahend now used up since it doesn't extend beyond minuend
operator|++
name|r2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|left
argument_list|()
operator|<=
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*              * Left part of subtrahend covers part of minuend: add uncovered              * part of minuend to region and skip to next subtrahend.              */
name|Q_ASSERT
argument_list|(
name|x1
operator|<
name|r2
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r2
operator|->
name|left
argument_list|()
operator|-
literal|1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
name|x1
operator|=
name|r2
operator|->
name|right
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*                  * Minuend used up: advance to new...                  */
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Subtrahend used up
operator|++
name|r2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * Minuend used up: add any remaining piece before advancing.              */
if|if
condition|(
name|r1
operator|->
name|right
argument_list|()
operator|>=
name|x1
condition|)
block|{
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
block|}
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      * Add remaining minuend rectangles to region.      */
while|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|x1
operator|<=
name|r1
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtract --  *      Subtract regS from regM and leave the result in regD.  *      S stands for subtrahend, M for minuend and D for difference.  *  * Side Effects:  *      regD is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|SubtractRegion
specifier|static
name|void
name|SubtractRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|regM
parameter_list|,
name|QRegionPrivate
modifier|*
name|regS
parameter_list|,
specifier|register
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|regM
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|regS
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|EXTENTCHECK
argument_list|(
operator|&
name|regM
operator|->
name|extents
argument_list|,
operator|&
name|regS
operator|->
name|extents
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|regS
operator|->
name|contains
argument_list|(
operator|*
name|regM
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|regM
argument_list|,
name|regS
argument_list|)
argument_list|)
expr_stmt|;
name|miRegionOp
argument_list|(
name|dest
argument_list|,
name|regM
argument_list|,
name|regS
argument_list|,
name|miSubtractO
argument_list|,
name|miSubtractNonO1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Can't alter dest's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the unaltered. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|XorRegion
specifier|static
name|void
name|XorRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|sra
parameter_list|,
name|QRegionPrivate
modifier|*
name|srb
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|sra
argument_list|)
operator|&&
operator|!
name|isEmptyHelper
argument_list|(
name|srb
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|EXTENTCHECK
argument_list|(
operator|&
name|sra
operator|->
name|extents
argument_list|,
operator|&
name|srb
operator|->
name|extents
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|sra
argument_list|,
name|srb
argument_list|)
argument_list|)
expr_stmt|;
name|QRegionPrivate
name|tra
decl_stmt|,
name|trb
decl_stmt|;
if|if
condition|(
operator|!
name|srb
operator|->
name|contains
argument_list|(
operator|*
name|sra
argument_list|)
condition|)
name|SubtractRegion
argument_list|(
name|sra
argument_list|,
name|srb
argument_list|,
name|tra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sra
operator|->
name|contains
argument_list|(
operator|*
name|srb
argument_list|)
condition|)
name|SubtractRegion
argument_list|(
name|srb
argument_list|,
name|sra
argument_list|,
name|trb
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|isEmptyHelper
argument_list|(
operator|&
name|trb
argument_list|)
operator|||
operator|!
name|tra
operator|.
name|contains
argument_list|(
name|trb
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|isEmptyHelper
argument_list|(
operator|&
name|tra
argument_list|)
operator|||
operator|!
name|trb
operator|.
name|contains
argument_list|(
name|tra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
operator|&
name|tra
argument_list|)
condition|)
block|{
name|dest
operator|=
name|trb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isEmptyHelper
argument_list|(
operator|&
name|trb
argument_list|)
condition|)
block|{
name|dest
operator|=
name|tra
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tra
operator|.
name|canAppend
argument_list|(
operator|&
name|trb
argument_list|)
condition|)
block|{
name|dest
operator|=
name|tra
expr_stmt|;
name|dest
operator|.
name|append
argument_list|(
operator|&
name|trb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trb
operator|.
name|canAppend
argument_list|(
operator|&
name|tra
argument_list|)
condition|)
block|{
name|dest
operator|=
name|trb
expr_stmt|;
name|dest
operator|.
name|append
argument_list|(
operator|&
name|tra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnionRegion
argument_list|(
operator|&
name|tra
argument_list|,
operator|&
name|trb
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *      Check to see if two regions are equal  */
end_comment
begin_function
DECL|function|EqualRegion
specifier|static
name|bool
name|EqualRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|r2
parameter_list|)
block|{
if|if
condition|(
name|r1
operator|->
name|numRects
operator|!=
name|r2
operator|->
name|numRects
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|numRects
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|!=
name|r2
operator|->
name|extents
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
operator|&&
name|r2
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
block|{
return|return
name|r1
operator|->
name|single
operator|==
name|r2
operator|->
name|single
return|;
block|}
else|else
block|{
specifier|const
name|QRect
modifier|*
name|rr1
init|=
operator|(
name|r1
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
name|r1
operator|->
name|rects
operator|.
name|constData
argument_list|()
else|:
operator|&
name|r1
operator|->
name|single
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|rr2
init|=
operator|(
name|r2
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
name|r2
operator|->
name|rects
operator|.
name|constData
argument_list|()
else|:
operator|&
name|r2
operator|->
name|single
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r1
operator|->
name|numRects
condition|;
operator|++
name|i
operator|,
operator|++
name|rr1
operator|,
operator|++
name|rr2
control|)
block|{
if|if
condition|(
operator|*
name|rr1
operator|!=
operator|*
name|rr2
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|PointInRegion
specifier|static
name|bool
name|PointInRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|pRegion
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pRegion
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
return|return
name|pRegion
operator|->
name|single
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|pRegion
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|pRegion
operator|->
name|extents
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|pRegion
operator|->
name|innerRect
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pRegion
operator|->
name|numRects
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pRegion
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|RectInRegion
specifier|static
name|bool
name|RectInRegion
parameter_list|(
specifier|register
name|QRegionPrivate
modifier|*
name|region
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|ry
parameter_list|,
name|uint
name|rwidth
parameter_list|,
name|uint
name|rheight
parameter_list|)
block|{
specifier|register
specifier|const
name|QRect
modifier|*
name|pbox
decl_stmt|;
specifier|register
specifier|const
name|QRect
modifier|*
name|pboxEnd
decl_stmt|;
name|QRect
name|rect
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|,
name|rwidth
argument_list|,
name|rheight
argument_list|)
decl_stmt|;
specifier|register
name|QRect
modifier|*
name|prect
init|=
operator|&
name|rect
decl_stmt|;
name|int
name|partIn
decl_stmt|,
name|partOut
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|numRects
operator|==
literal|0
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|region
operator|->
name|extents
argument_list|,
name|prect
argument_list|)
condition|)
return|return
name|RectangleOut
return|;
name|partOut
operator|=
literal|false
expr_stmt|;
name|partIn
operator|=
literal|false
expr_stmt|;
comment|/* can stop when both partOut and partIn are true, or we reach prect->y2 */
for|for
control|(
name|pbox
operator|=
operator|(
name|region
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Vector
operator|)
condition|?
name|region
operator|->
name|rects
operator|.
name|constData
argument_list|()
else|:
operator|&
name|region
operator|->
name|single
operator|,
name|pboxEnd
operator|=
name|pbox
operator|+
name|region
operator|->
name|numRects
init|;
name|pbox
operator|<
name|pboxEnd
condition|;
operator|++
name|pbox
control|)
block|{
if|if
condition|(
name|pbox
operator|->
name|bottom
argument_list|()
operator|<
name|ry
condition|)
continue|continue;
if|if
condition|(
name|pbox
operator|->
name|top
argument_list|()
operator|>
name|ry
condition|)
block|{
name|partOut
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|partIn
operator|||
name|pbox
operator|->
name|top
argument_list|()
operator|>
name|prect
operator|->
name|bottom
argument_list|()
condition|)
break|break;
name|ry
operator|=
name|pbox
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pbox
operator|->
name|right
argument_list|()
operator|<
name|rx
condition|)
continue|continue;
comment|/* not far enough over yet */
if|if
condition|(
name|pbox
operator|->
name|left
argument_list|()
operator|>
name|rx
condition|)
block|{
name|partOut
operator|=
literal|true
expr_stmt|;
comment|/* missed part of rectangle to left */
if|if
condition|(
name|partIn
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|left
argument_list|()
operator|<=
name|prect
operator|->
name|right
argument_list|()
condition|)
block|{
name|partIn
operator|=
literal|true
expr_stmt|;
comment|/* definitely overlap */
if|if
condition|(
name|partOut
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|right
argument_list|()
operator|>=
name|prect
operator|->
name|right
argument_list|()
condition|)
block|{
name|ry
operator|=
name|pbox
operator|->
name|bottom
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|/* finished with this band */
if|if
condition|(
name|ry
operator|>
name|prect
operator|->
name|bottom
argument_list|()
condition|)
break|break;
name|rx
operator|=
name|prect
operator|->
name|left
argument_list|()
expr_stmt|;
comment|/* reset x out to left again */
block|}
else|else
block|{
comment|/*              * Because boxes in a band are maximal width, if the first box              * to overlap the rectangle doesn't completely cover it in that              * band, the rectangle must be partially out, since some of it              * will be uncovered in that band. partIn will have been set true              * by now...              */
break|break;
block|}
block|}
return|return
name|partIn
condition|?
operator|(
operator|(
name|ry
operator|<=
name|prect
operator|->
name|bottom
argument_list|()
operator|)
condition|?
name|RectanglePart
else|:
name|RectangleIn
operator|)
else|:
name|RectangleOut
return|;
block|}
end_function
begin_comment
comment|// END OF Region.c extract
end_comment
begin_comment
comment|// START OF poly.h extract
end_comment
begin_comment
comment|/* $XConsortium: poly.h,v 1.4 94/04/17 20:22:19 rws Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/*  *     This file contains a few macros to help track  *     the edge of a filled object.  The object is assumed  *     to be filled in scanline order, and thus the  *     algorithm used is an extension of Bresenham's line  *     drawing algorithm which assumes that y is always the  *     major axis.  *     Since these pieces of code are the same for any filled shape,  *     it is more convenient to gather the library in one  *     place, but since these pieces of code are also in  *     the inner loops of output primitives, procedure call  *     overhead is out of the question.  *     See the author for a derivation if needed.  */
end_comment
begin_comment
comment|/*  *  In scan converting polygons, we want to choose those pixels  *  which are inside the polygon.  Thus, we add .5 to the starting  *  x coordinate for both left and right edges.  Now we choose the  *  first pixel which is inside the pgon for the left edge and the  *  first pixel which is outside the pgon for the right edge.  *  Draw the left pixel, but not the right.  *  *  How to add .5 to the starting x coordinate:  *      If the edge is moving to the right, then subtract dy from the  *  error term from the general form of the algorithm.  *      If the edge is moving to the left, then add dy to the error term.  *  *  The reason for the difference between edges moving to the left  *  and edges moving to the right is simple:  If an edge is moving  *  to the right, then we want the algorithm to flip immediately.  *  If it is moving to the left, then we don't want it to flip until  *  we traverse an entire pixel.  */
end_comment
begin_define
DECL|macro|BRESINITPGON
define|#
directive|define
name|BRESINITPGON
parameter_list|(
name|dy
parameter_list|,
name|x1
parameter_list|,
name|x2
parameter_list|,
name|xStart
parameter_list|,
name|d
parameter_list|,
name|m
parameter_list|,
name|m1
parameter_list|,
name|incr1
parameter_list|,
name|incr2
parameter_list|)
value|{ \     int dx;
comment|/* local storage */
value|\ \
comment|/* \      *  if the edge is horizontal, then it is ignored \      *  and assumed not to be processed.  Otherwise, do this stuff. \      */
value|\     if ((dy) != 0) { \         xStart = (x1); \         dx = (x2) - xStart; \         if (dx< 0) { \             m = dx / (dy); \             m1 = m - 1; \             incr1 = -2 * dx + 2 * (dy) * m1; \             incr2 = -2 * dx + 2 * (dy) * m; \             d = 2 * m * (dy) - 2 * dx - 2 * (dy); \         } else { \             m = dx / (dy); \             m1 = m + 1; \             incr1 = 2 * dx - 2 * (dy) * m1; \             incr2 = 2 * dx - 2 * (dy) * m; \             d = -2 * m * (dy) + 2 * dx; \         } \     } \ }
end_define
begin_define
DECL|macro|BRESINCRPGON
define|#
directive|define
name|BRESINCRPGON
parameter_list|(
name|d
parameter_list|,
name|minval
parameter_list|,
name|m
parameter_list|,
name|m1
parameter_list|,
name|incr1
parameter_list|,
name|incr2
parameter_list|)
value|{ \     if (m1> 0) { \         if (d> 0) { \             minval += m1; \             d += incr1; \         } \         else { \             minval += m; \             d += incr2; \         } \     } else {\         if (d>= 0) { \             minval += m1; \             d += incr1; \         } \         else { \             minval += m; \             d += incr2; \         } \     } \ }
end_define
begin_comment
comment|/*  *     This structure contains all of the information needed  *     to run the bresenham algorithm.  *     The variables may be hardcoded into the declarations  *     instead of using this structure to make use of  *     register declarations.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|minor_axis
name|int
name|minor_axis
decl_stmt|;
comment|/* minor axis        */
DECL|member|d
name|int
name|d
decl_stmt|;
comment|/* decision variable */
DECL|member|m
DECL|member|m1
name|int
name|m
decl_stmt|,
name|m1
decl_stmt|;
comment|/* slope and slope+1 */
DECL|member|incr1
DECL|member|incr2
name|int
name|incr1
decl_stmt|,
name|incr2
decl_stmt|;
comment|/* error increments */
block|}
DECL|typedef|BRESINFO
name|BRESINFO
typedef|;
end_typedef
begin_define
DECL|macro|BRESINITPGONSTRUCT
define|#
directive|define
name|BRESINITPGONSTRUCT
parameter_list|(
name|dmaj
parameter_list|,
name|min1
parameter_list|,
name|min2
parameter_list|,
name|bres
parameter_list|)
define|\
value|BRESINITPGON(dmaj, min1, min2, bres.minor_axis, bres.d, \                      bres.m, bres.m1, bres.incr1, bres.incr2)
end_define
begin_define
DECL|macro|BRESINCRPGONSTRUCT
define|#
directive|define
name|BRESINCRPGONSTRUCT
parameter_list|(
name|bres
parameter_list|)
define|\
value|BRESINCRPGON(bres.d, bres.minor_axis, bres.m, bres.m1, bres.incr1, bres.incr2)
end_define
begin_comment
comment|/*  *     These are the data structures needed to scan  *     convert regions.  Two different scan conversion  *     methods are available -- the even-odd method, and  *     the winding number method.  *     The even-odd rule states that a point is inside  *     the polygon if a ray drawn from that point in any  *     direction will pass through an odd number of  *     path segments.  *     By the winding number rule, a point is decided  *     to be inside the polygon if a ray drawn from that  *     point in any direction passes through a different  *     number of clockwise and counter-clockwise path  *     segments.  *  *     These data structures are adapted somewhat from  *     the algorithm in (Foley/Van Dam) for scan converting  *     polygons.  *     The basic algorithm is to start at the top (smallest y)  *     of the polygon, stepping down to the bottom of  *     the polygon by incrementing the y coordinate.  We  *     keep a list of edges which the current scanline crosses,  *     sorted by x.  This list is called the Active Edge Table (AET)  *     As we change the y-coordinate, we update each entry in  *     in the active edge table to reflect the edges new xcoord.  *     This list must be sorted at each scanline in case  *     two edges intersect.  *     We also keep a data structure known as the Edge Table (ET),  *     which keeps track of all the edges which the current  *     scanline has not yet reached.  The ET is basically a  *     list of ScanLineList structures containing a list of  *     edges which are entered at a given scanline.  There is one  *     ScanLineList per scanline at which an edge is entered.  *     When we enter a new edge, we move it from the ET to the AET.  *  *     From the AET, we can implement the even-odd rule as in  *     (Foley/Van Dam).  *     The winding number rule is a little trickier.  We also  *     keep the EdgeTableEntries in the AET linked by the  *     nextWETE (winding EdgeTableEntry) link.  This allows  *     the edges to be linked just as before for updating  *     purposes, but only uses the edges linked by the nextWETE  *     link as edges representing spans of the polygon to  *     drawn (as with the even-odd rule).  */
end_comment
begin_comment
comment|/*  * for the winding number rule  */
end_comment
begin_define
DECL|macro|CLOCKWISE
define|#
directive|define
name|CLOCKWISE
value|1
end_define
begin_define
DECL|macro|COUNTERCLOCKWISE
define|#
directive|define
name|COUNTERCLOCKWISE
value|-1
end_define
begin_typedef
DECL|struct|_EdgeTableEntry
typedef|typedef
struct|struct
name|_EdgeTableEntry
block|{
DECL|member|ymax
name|int
name|ymax
decl_stmt|;
comment|/* ycoord at which we exit this edge. */
DECL|member|bres
name|BRESINFO
name|bres
decl_stmt|;
comment|/* Bresenham info to run the edge     */
DECL|member|next
name|struct
name|_EdgeTableEntry
modifier|*
name|next
decl_stmt|;
comment|/* next in the list     */
DECL|member|back
name|struct
name|_EdgeTableEntry
modifier|*
name|back
decl_stmt|;
comment|/* for insertion sort   */
DECL|member|nextWETE
name|struct
name|_EdgeTableEntry
modifier|*
name|nextWETE
decl_stmt|;
comment|/* for winding num rule */
DECL|member|ClockWise
name|int
name|ClockWise
decl_stmt|;
comment|/* flag for winding number rule       */
block|}
DECL|typedef|EdgeTableEntry
name|EdgeTableEntry
typedef|;
end_typedef
begin_typedef
DECL|struct|_ScanLineList
typedef|typedef
struct|struct
name|_ScanLineList
block|{
DECL|member|scanline
name|int
name|scanline
decl_stmt|;
comment|/* the scanline represented */
DECL|member|edgelist
name|EdgeTableEntry
modifier|*
name|edgelist
decl_stmt|;
comment|/* header node              */
DECL|member|next
name|struct
name|_ScanLineList
modifier|*
name|next
decl_stmt|;
comment|/* next in the list       */
block|}
DECL|typedef|ScanLineList
name|ScanLineList
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|ymax
name|int
name|ymax
decl_stmt|;
comment|/* ymax for the polygon     */
DECL|member|ymin
name|int
name|ymin
decl_stmt|;
comment|/* ymin for the polygon     */
DECL|member|scanlines
name|ScanLineList
name|scanlines
decl_stmt|;
comment|/* header node              */
block|}
DECL|typedef|EdgeTable
name|EdgeTable
typedef|;
end_typedef
begin_comment
comment|/*  * Here is a struct to help with storage allocation  * so we can allocate a big chunk at a time, and then take  * pieces from this heap when we need to.  */
end_comment
begin_define
DECL|macro|SLLSPERBLOCK
define|#
directive|define
name|SLLSPERBLOCK
value|25
end_define
begin_typedef
DECL|struct|_ScanLineListBlock
typedef|typedef
struct|struct
name|_ScanLineListBlock
block|{
DECL|member|SLLs
name|ScanLineList
name|SLLs
index|[
name|SLLSPERBLOCK
index|]
decl_stmt|;
DECL|member|next
name|struct
name|_ScanLineListBlock
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|ScanLineListBlock
name|ScanLineListBlock
typedef|;
end_typedef
begin_comment
comment|/*  *  *     a few macros for the inner loops of the fill code where  *     performance considerations don't allow a procedure call.  *  *     Evaluate the given edge at the given scanline.  *     If the edge has expired, then we leave it and fix up  *     the active edge table; otherwise, we increment the  *     x value to be ready for the next scanline.  *     The winding number rule is in effect, so we must notify  *     the caller when the edge has been removed so he  *     can reorder the Winding Active Edge Table.  */
end_comment
begin_define
DECL|macro|EVALUATEEDGEWINDING
define|#
directive|define
name|EVALUATEEDGEWINDING
parameter_list|(
name|pAET
parameter_list|,
name|pPrevAET
parameter_list|,
name|y
parameter_list|,
name|fixWAET
parameter_list|)
value|{ \    if (pAET->ymax == y) {
comment|/* leaving this edge */
value|\       pPrevAET->next = pAET->next; \       pAET = pPrevAET->next; \       fixWAET = 1; \       if (pAET) \          pAET->back = pPrevAET; \    } \    else { \       BRESINCRPGONSTRUCT(pAET->bres) \       pPrevAET = pAET; \       pAET = pAET->next; \    } \ }
end_define
begin_comment
comment|/*  *     Evaluate the given edge at the given scanline.  *     If the edge has expired, then we leave it and fix up  *     the active edge table; otherwise, we increment the  *     x value to be ready for the next scanline.  *     The even-odd rule is in effect.  */
end_comment
begin_define
DECL|macro|EVALUATEEDGEEVENODD
define|#
directive|define
name|EVALUATEEDGEEVENODD
parameter_list|(
name|pAET
parameter_list|,
name|pPrevAET
parameter_list|,
name|y
parameter_list|)
value|{ \    if (pAET->ymax == y) {
comment|/* leaving this edge */
value|\       pPrevAET->next = pAET->next; \       pAET = pPrevAET->next; \       if (pAET) \          pAET->back = pPrevAET; \    } \    else { \       BRESINCRPGONSTRUCT(pAET->bres) \       pPrevAET = pAET; \       pAET = pAET->next; \    } \ }
end_define
begin_comment
comment|// END OF poly.h extract
end_comment
begin_comment
comment|// START OF PolyReg.c extract
end_comment
begin_comment
comment|/* $XConsortium: PolyReg.c,v 11.23 94/11/17 21:59:37 converse Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/* $XFree86: xc/lib/X11/PolyReg.c,v 1.1.1.2.8.2 1998/10/04 15:22:49 hohndel Exp $ */
end_comment
begin_define
DECL|macro|LARGE_COORDINATE
define|#
directive|define
name|LARGE_COORDINATE
value|1000000
end_define
begin_define
DECL|macro|SMALL_COORDINATE
define|#
directive|define
name|SMALL_COORDINATE
value|-LARGE_COORDINATE
end_define
begin_comment
comment|/*  *     InsertEdgeInET  *  *     Insert the given edge into the edge table.  *     First we must find the correct bucket in the  *     Edge table, then find the right slot in the  *     bucket.  Finally, we can insert it.  *  */
end_comment
begin_function
DECL|function|InsertEdgeInET
specifier|static
name|void
name|InsertEdgeInET
parameter_list|(
name|EdgeTable
modifier|*
name|ET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|ETE
parameter_list|,
name|int
name|scanline
parameter_list|,
name|ScanLineListBlock
modifier|*
modifier|*
name|SLLBlock
parameter_list|,
name|int
modifier|*
name|iSLLBlock
parameter_list|)
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|start
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
specifier|register
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|,
modifier|*
name|pPrevSLL
decl_stmt|;
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
comment|/*      * find the right bucket to put the edge into      */
name|pPrevSLL
operator|=
operator|&
name|ET
operator|->
name|scanlines
expr_stmt|;
name|pSLL
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|pSLL
operator|&&
operator|(
name|pSLL
operator|->
name|scanline
operator|<
name|scanline
operator|)
condition|)
block|{
name|pPrevSLL
operator|=
name|pSLL
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
comment|/*      * reassign pSLL (pointer to ScanLineList) if necessary      */
if|if
condition|(
operator|(
operator|!
name|pSLL
operator|)
operator|||
operator|(
name|pSLL
operator|->
name|scanline
operator|>
name|scanline
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|iSLLBlock
operator|>
name|SLLSPERBLOCK
operator|-
literal|1
condition|)
block|{
name|tmpSLLBlock
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ScanLineListBlock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|next
operator|=
name|tmpSLLBlock
expr_stmt|;
name|tmpSLLBlock
operator|->
name|next
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|SLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
operator|*
name|iSLLBlock
operator|=
literal|0
expr_stmt|;
block|}
name|pSLL
operator|=
operator|&
operator|(
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|SLLs
index|[
operator|(
operator|*
name|iSLLBlock
operator|)
operator|++
index|]
operator|)
expr_stmt|;
name|pSLL
operator|->
name|next
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
name|pSLL
operator|->
name|edgelist
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|pPrevSLL
operator|->
name|next
operator|=
name|pSLL
expr_stmt|;
block|}
name|pSLL
operator|->
name|scanline
operator|=
name|scanline
expr_stmt|;
comment|/*      * now insert the edge in the right bucket      */
name|prev
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|pSLL
operator|->
name|edgelist
expr_stmt|;
while|while
condition|(
name|start
operator|&&
operator|(
name|start
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETE
operator|->
name|bres
operator|.
name|minor_axis
operator|)
condition|)
block|{
name|prev
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
block|}
name|ETE
operator|->
name|next
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|ETE
expr_stmt|;
else|else
name|pSLL
operator|->
name|edgelist
operator|=
name|ETE
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  *     CreateEdgeTable  *  *     This routine creates the edge table for  *     scan converting polygons.  *     The Edge Table (ET) looks like:  *  *    EdgeTable  *     --------  *    |  ymax  |        ScanLineLists  *    |scanline|-->------------>-------------->...  *     --------   |scanline|   |scanline|  *                |edgelist|   |edgelist|  *                ---------    ---------  *                    |             |  *                    |             |  *                    V             V  *              list of ETEs   list of ETEs  *  *     where ETE is an EdgeTableEntry data structure,  *     and there is one ScanLineList per scanline at  *     which an edge is initially entered.  *  */
end_comment
begin_function
DECL|function|CreateETandAET
specifier|static
name|void
name|CreateETandAET
parameter_list|(
specifier|register
name|int
name|count
parameter_list|,
specifier|register
specifier|const
name|QPoint
modifier|*
name|pts
parameter_list|,
name|EdgeTable
modifier|*
name|ET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|,
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEs
parameter_list|,
name|ScanLineListBlock
modifier|*
name|pSLLBlock
parameter_list|)
block|{
specifier|register
specifier|const
name|QPoint
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|PrevPt
decl_stmt|,
modifier|*
name|CurrPt
decl_stmt|;
name|int
name|iSLLBlock
init|=
literal|0
decl_stmt|;
name|int
name|dy
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
return|return;
comment|/*      *  initialize the Active Edge Table      */
name|AET
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|back
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|=
name|SMALL_COORDINATE
expr_stmt|;
comment|/*      *  initialize the Edge Table.      */
name|ET
operator|->
name|scanlines
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|ET
operator|->
name|ymax
operator|=
name|SMALL_COORDINATE
expr_stmt|;
name|ET
operator|->
name|ymin
operator|=
name|LARGE_COORDINATE
expr_stmt|;
name|pSLLBlock
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|PrevPt
operator|=
operator|&
name|pts
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
comment|/*      *  for each vertex in the array of points.      *  In this loop we are dealing with two vertices at      *  a time -- these make up one edge of the polygon.      */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|CurrPt
operator|=
name|pts
operator|++
expr_stmt|;
comment|/*          *  find out which point is above and which is below.          */
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|>
name|CurrPt
operator|->
name|y
argument_list|()
condition|)
block|{
name|bottom
operator|=
name|PrevPt
expr_stmt|;
name|top
operator|=
name|CurrPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|CurrPt
expr_stmt|;
name|top
operator|=
name|PrevPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|1
expr_stmt|;
block|}
comment|/*          * don't add horizontal edges to the Edge table.          */
if|if
condition|(
name|bottom
operator|->
name|y
argument_list|()
operator|!=
name|top
operator|->
name|y
argument_list|()
condition|)
block|{
name|pETEs
operator|->
name|ymax
operator|=
name|bottom
operator|->
name|y
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* -1 so we don't get last scanline */
comment|/*              *  initialize integer edge algorithm              */
name|dy
operator|=
name|bottom
operator|->
name|y
argument_list|()
operator|-
name|top
operator|->
name|y
argument_list|()
expr_stmt|;
name|BRESINITPGONSTRUCT
argument_list|(
argument|dy
argument_list|,
argument|top->x()
argument_list|,
argument|bottom->x()
argument_list|,
argument|pETEs->bres
argument_list|)
name|InsertEdgeInET
argument_list|(
name|ET
argument_list|,
name|pETEs
argument_list|,
name|top
operator|->
name|y
argument_list|()
argument_list|,
operator|&
name|pSLLBlock
argument_list|,
operator|&
name|iSLLBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|>
name|ET
operator|->
name|ymax
condition|)
name|ET
operator|->
name|ymax
operator|=
name|PrevPt
operator|->
name|y
argument_list|()
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|<
name|ET
operator|->
name|ymin
condition|)
name|ET
operator|->
name|ymin
operator|=
name|PrevPt
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pETEs
expr_stmt|;
block|}
name|PrevPt
operator|=
name|CurrPt
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     loadAET  *  *     This routine moves EdgeTableEntries from the  *     EdgeTable into the Active Edge Table,  *     leaving them sorted by smaller x coordinate.  *  */
end_comment
begin_function
DECL|function|loadAET
specifier|static
name|void
name|loadAET
parameter_list|(
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|,
specifier|register
name|EdgeTableEntry
modifier|*
name|ETEs
parameter_list|)
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|tmp
decl_stmt|;
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|ETEs
condition|)
block|{
while|while
condition|(
name|AET
operator|&&
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETEs
operator|->
name|bres
operator|.
name|minor_axis
condition|)
block|{
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|tmp
operator|=
name|ETEs
operator|->
name|next
expr_stmt|;
name|ETEs
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|->
name|back
operator|=
name|pPrevAET
expr_stmt|;
name|pPrevAET
operator|->
name|next
operator|=
name|ETEs
expr_stmt|;
name|pPrevAET
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     computeWAET  *  *     This routine links the AET by the  *     nextWETE (winding EdgeTableEntry) link for  *     use by the winding number rule.  The final  *     Active Edge Table (AET) might look something  *     like:  *  *     AET  *     ----------  ---------   ---------  *     |ymax    |  |ymax    |  |ymax    |  *     | ...    |  |...     |  |...     |  *     |next    |->|next    |->|next    |->...  *     |nextWETE|  |nextWETE|  |nextWETE|  *     ---------   ---------   ^--------  *         |                   |       |  *         V------------------->       V---> ...  *  */
end_comment
begin_function
DECL|function|computeWAET
specifier|static
name|void
name|computeWAET
parameter_list|(
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|)
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
specifier|register
name|int
name|inside
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|isInside
init|=
literal|0
decl_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
if|if
condition|(
name|AET
operator|->
name|ClockWise
condition|)
operator|++
name|isInside
expr_stmt|;
else|else
operator|--
name|isInside
expr_stmt|;
if|if
condition|(
operator|!
name|inside
operator|&&
operator|!
name|isInside
operator|||
name|inside
operator|&&
name|isInside
condition|)
block|{
name|pWETE
operator|->
name|nextWETE
operator|=
name|AET
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
block|}
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|pWETE
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  *     InsertionSort  *  *     Just a simple insertion sort using  *     pointers and back pointers to sort the Active  *     Edge Table.  *  */
end_comment
begin_function
DECL|function|InsertionSort
specifier|static
name|int
name|InsertionSort
parameter_list|(
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|)
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEchase
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEinsert
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEchaseBackTMP
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
name|pETEinsert
operator|=
name|AET
expr_stmt|;
name|pETEchase
operator|=
name|AET
expr_stmt|;
while|while
condition|(
name|pETEchase
operator|->
name|back
operator|->
name|bres
operator|.
name|minor_axis
operator|>
name|AET
operator|->
name|bres
operator|.
name|minor_axis
condition|)
name|pETEchase
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pETEchase
operator|!=
name|pETEinsert
condition|)
block|{
name|pETEchaseBackTMP
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|pETEinsert
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|next
operator|=
name|pETEchase
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|->
name|next
operator|=
name|pETEinsert
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|=
name|pETEinsert
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|=
name|pETEchaseBackTMP
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function
begin_comment
comment|/*  *     Clean up our act.  */
end_comment
begin_function
DECL|function|FreeStorage
specifier|static
name|void
name|FreeStorage
parameter_list|(
specifier|register
name|ScanLineListBlock
modifier|*
name|pSLLBlock
parameter_list|)
block|{
specifier|register
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
while|while
condition|(
name|pSLLBlock
condition|)
block|{
name|tmpSLLBlock
operator|=
name|pSLLBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pSLLBlock
argument_list|)
expr_stmt|;
name|pSLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     Create an array of rectangles from a list of points.  *     If indeed these things (POINTS, RECTS) are the same,  *     then this proc is still needed, because it allocates  *     storage for the array, which was allocated on the  *     stack by the calling procedure.  *  */
end_comment
begin_function
DECL|function|PtsToRegion
specifier|static
name|void
name|PtsToRegion
parameter_list|(
specifier|register
name|int
name|numFullPtBlocks
parameter_list|,
specifier|register
name|int
name|iCurPtBlock
parameter_list|,
name|POINTBLOCK
modifier|*
name|FirstPtBlock
parameter_list|,
name|QRegionPrivate
modifier|*
name|reg
parameter_list|)
block|{
specifier|register
name|QRect
modifier|*
name|rects
decl_stmt|;
specifier|register
name|QPoint
modifier|*
name|pts
decl_stmt|;
specifier|register
name|POINTBLOCK
modifier|*
name|CurPtBlock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|QRect
modifier|*
name|extents
decl_stmt|;
specifier|register
name|int
name|numRects
decl_stmt|;
name|extents
operator|=
operator|&
name|reg
operator|->
name|extents
expr_stmt|;
name|numRects
operator|=
operator|(
operator|(
name|numFullPtBlocks
operator|*
name|NUMPTSTOBUFFER
operator|)
operator|+
name|iCurPtBlock
operator|)
operator|>>
literal|1
expr_stmt|;
name|reg
operator|->
name|rects
operator|.
name|resize
argument_list|(
name|numRects
argument_list|)
expr_stmt|;
name|CurPtBlock
operator|=
name|FirstPtBlock
expr_stmt|;
name|rects
operator|=
name|reg
operator|->
name|rects
operator|.
name|data
argument_list|()
operator|-
literal|1
expr_stmt|;
name|numRects
operator|=
literal|0
expr_stmt|;
name|extents
operator|->
name|setLeft
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
name|extents
operator|->
name|setRight
argument_list|(
name|INT_MIN
argument_list|)
expr_stmt|;
name|reg
operator|->
name|innerArea
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|numFullPtBlocks
operator|>=
literal|0
condition|;
operator|--
name|numFullPtBlocks
control|)
block|{
comment|/* the loop uses 2 points per iteration */
name|i
operator|=
name|NUMPTSTOBUFFER
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numFullPtBlocks
condition|)
name|i
operator|=
name|iCurPtBlock
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
for|for
control|(
name|pts
operator|=
name|CurPtBlock
operator|->
name|pts
init|;
name|i
operator|--
condition|;
name|pts
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pts
operator|->
name|x
argument_list|()
operator|==
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|numRects
operator|&&
name|pts
operator|->
name|x
argument_list|()
operator|==
name|rects
operator|->
name|left
argument_list|()
operator|&&
name|pts
operator|->
name|y
argument_list|()
operator|==
name|rects
operator|->
name|bottom
argument_list|()
operator|+
literal|1
operator|&&
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|==
name|rects
operator|->
name|right
argument_list|()
operator|+
literal|1
operator|&&
operator|(
name|numRects
operator|==
literal|1
operator|||
name|rects
index|[
operator|-
literal|1
index|]
operator|.
name|top
argument_list|()
operator|!=
name|rects
operator|->
name|top
argument_list|()
operator|)
operator|&&
operator|(
name|i
operator|&&
name|pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|>
name|pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|)
condition|)
block|{
name|rects
operator|->
name|setBottom
argument_list|(
name|pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|reg
operator|->
name|updateInnerRect
argument_list|(
operator|*
name|rects
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|numRects
expr_stmt|;
operator|++
name|rects
expr_stmt|;
name|rects
operator|->
name|setCoords
argument_list|(
name|pts
operator|->
name|x
argument_list|()
argument_list|,
name|pts
operator|->
name|y
argument_list|()
argument_list|,
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|-
literal|1
argument_list|,
name|pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rects
operator|->
name|left
argument_list|()
operator|<
name|extents
operator|->
name|left
argument_list|()
condition|)
name|extents
operator|->
name|setLeft
argument_list|(
name|rects
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rects
operator|->
name|right
argument_list|()
operator|>
name|extents
operator|->
name|right
argument_list|()
condition|)
name|extents
operator|->
name|setRight
argument_list|(
name|rects
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|reg
operator|->
name|updateInnerRect
argument_list|(
operator|*
name|rects
argument_list|)
expr_stmt|;
block|}
block|}
name|CurPtBlock
operator|=
name|CurPtBlock
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|numRects
condition|)
block|{
name|extents
operator|->
name|setTop
argument_list|(
name|reg
operator|->
name|rects
index|[
literal|0
index|]
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|extents
operator|->
name|setBottom
argument_list|(
name|rects
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extents
operator|->
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg
operator|->
name|numRects
operator|=
name|numRects
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  *     polytoregion  *  *     Scan converts a polygon by returning a run-length  *     encoding of the resultant bitmap -- the run-length  *     encoding is in the form of an array of rectangles.  */
end_comment
begin_function
DECL|function|PolygonRegion
specifier|static
name|QRegionPrivate
modifier|*
name|PolygonRegion
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|Pts
parameter_list|,
name|int
name|Count
parameter_list|,
name|int
name|rule
parameter_list|,
name|QRegionPrivate
modifier|*
name|region
parameter_list|)
comment|//Point     *Pts;                /* the pts                 */
comment|//int       Count;                 /* number of pts           */
comment|//int       rule;                        /* winding rule */
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pAET
decl_stmt|;
comment|/* Active Edge Table       */
specifier|register
name|int
name|y
decl_stmt|;
comment|/* current scanline        */
specifier|register
name|int
name|iPts
init|=
literal|0
decl_stmt|;
comment|/* number of pts in buffer */
specifier|register
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
comment|/* Winding Edge Table Entry*/
specifier|register
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|;
comment|/* current scanLineList    */
specifier|register
name|QPoint
modifier|*
name|pts
decl_stmt|;
comment|/* output buffer           */
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
comment|/* ptr to previous AET     */
name|EdgeTable
name|ET
decl_stmt|;
comment|/* header node for ET      */
name|EdgeTableEntry
name|AET
decl_stmt|;
comment|/* header node for AET     */
name|EdgeTableEntry
modifier|*
name|pETEs
decl_stmt|;
comment|/* EdgeTableEntries pool   */
name|ScanLineListBlock
name|SLLBlock
decl_stmt|;
comment|/* header for scanlinelist */
name|int
name|fixWAET
init|=
literal|false
decl_stmt|;
name|POINTBLOCK
name|FirstPtBlock
decl_stmt|,
modifier|*
name|curPtBlock
decl_stmt|;
comment|/* PtBlock buffers    */
name|POINTBLOCK
modifier|*
name|tmpPtBlock
decl_stmt|;
name|int
name|numFullPtBlocks
init|=
literal|0
decl_stmt|;
name|region
operator|->
name|vector
argument_list|()
expr_stmt|;
comment|/* special case a rectangle */
if|if
condition|(
operator|(
operator|(
name|Count
operator|==
literal|4
operator|)
operator|||
operator|(
operator|(
name|Count
operator|==
literal|5
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|4
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|4
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|x
init|=
name|qMin
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|->
name|extents
operator|.
name|setLeft
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|int
name|y
init|=
name|qMin
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|->
name|extents
operator|.
name|setTop
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|setWidth
argument_list|(
name|qMax
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|-
name|x
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|setHeight
argument_list|(
name|qMax
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|region
operator|->
name|extents
operator|.
name|left
argument_list|()
operator|<=
name|region
operator|->
name|extents
operator|.
name|right
argument_list|()
operator|)
operator|&&
operator|(
name|region
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|<=
name|region
operator|->
name|extents
operator|.
name|bottom
argument_list|()
operator|)
condition|)
block|{
name|region
operator|->
name|numRects
operator|=
literal|1
expr_stmt|;
name|region
operator|->
name|rects
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|region
operator|->
name|rects
index|[
literal|0
index|]
operator|=
name|region
operator|->
name|extents
expr_stmt|;
name|region
operator|->
name|innerRect
operator|=
name|region
operator|->
name|extents
expr_stmt|;
name|region
operator|->
name|innerArea
operator|=
name|region
operator|->
name|innerRect
operator|.
name|width
argument_list|()
operator|*
name|region
operator|->
name|innerRect
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
return|return
name|region
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pETEs
operator|=
cast|static_cast
argument_list|<
name|EdgeTableEntry
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EdgeTableEntry
argument_list|)
operator|*
name|Count
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|pts
operator|=
name|FirstPtBlock
operator|.
name|pts
expr_stmt|;
name|CreateETandAET
argument_list|(
name|Count
argument_list|,
name|Pts
argument_list|,
operator|&
name|ET
argument_list|,
operator|&
name|AET
argument_list|,
name|pETEs
argument_list|,
operator|&
name|SLLBlock
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|ET
operator|.
name|scanlines
operator|.
name|next
expr_stmt|;
name|curPtBlock
operator|=
operator|&
name|FirstPtBlock
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|EvenOddRule
condition|)
block|{
comment|/*          *  for each scanline          */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
operator|++
name|y
control|)
block|{
comment|/*              *  Add a new edge to the active edge table when we              *  get to the next edge.              */
if|if
condition|(
name|pSLL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
operator|&
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
operator|&
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|.
name|next
expr_stmt|;
comment|/*              *  for each active edge              */
while|while
condition|(
name|pAET
condition|)
block|{
name|pts
operator|->
name|setX
argument_list|(
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
argument_list|)
expr_stmt|;
name|pts
operator|->
name|setY
argument_list|(
name|y
argument_list|)
expr_stmt|;
operator|++
name|pts
expr_stmt|;
operator|++
name|iPts
expr_stmt|;
comment|/*                  *  send out the buffer                  */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
operator|(
name|POINTBLOCK
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
operator|++
name|numFullPtBlocks
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|EVALUATEEDGEEVENODD
argument_list|(
argument|pAET
argument_list|,
argument|pPrevAET
argument_list|,
argument|y
argument_list|)
block|}
name|InsertionSort
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          *  for each scanline          */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
operator|++
name|y
control|)
block|{
comment|/*              *  Add a new edge to the active edge table when we              *  get to the next edge.              */
if|if
condition|(
name|pSLL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
operator|&
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|computeWAET
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
operator|&
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|.
name|next
expr_stmt|;
name|pWETE
operator|=
name|pAET
expr_stmt|;
comment|/*              *  for each active edge              */
while|while
condition|(
name|pAET
condition|)
block|{
comment|/*                  *  add to the buffer only those edges that                  *  are in the Winding active edge table.                  */
if|if
condition|(
name|pWETE
operator|==
name|pAET
condition|)
block|{
name|pts
operator|->
name|setX
argument_list|(
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
argument_list|)
expr_stmt|;
name|pts
operator|->
name|setY
argument_list|(
name|y
argument_list|)
expr_stmt|;
operator|++
name|pts
expr_stmt|;
operator|++
name|iPts
expr_stmt|;
comment|/*                      *  send out the buffer                      */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
cast|static_cast
argument_list|<
name|POINTBLOCK
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
operator|++
name|numFullPtBlocks
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|pWETE
operator|=
name|pWETE
operator|->
name|nextWETE
expr_stmt|;
block|}
name|EVALUATEEDGEWINDING
argument_list|(
argument|pAET
argument_list|,
argument|pPrevAET
argument_list|,
argument|y
argument_list|,
argument|fixWAET
argument_list|)
block|}
comment|/*              *  recompute the winding active edge table if              *  we just resorted or have exited an edge.              */
if|if
condition|(
name|InsertionSort
argument_list|(
operator|&
name|AET
argument_list|)
operator|||
name|fixWAET
condition|)
block|{
name|computeWAET
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
name|fixWAET
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|FreeStorage
argument_list|(
name|SLLBlock
operator|.
name|next
argument_list|)
expr_stmt|;
name|PtsToRegion
argument_list|(
name|numFullPtBlocks
argument_list|,
name|iPts
argument_list|,
operator|&
name|FirstPtBlock
argument_list|,
name|region
argument_list|)
expr_stmt|;
for|for
control|(
name|curPtBlock
operator|=
name|FirstPtBlock
operator|.
name|next
init|;
operator|--
name|numFullPtBlocks
operator|>=
literal|0
condition|;
control|)
block|{
name|tmpPtBlock
operator|=
name|curPtBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curPtBlock
argument_list|)
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
block|}
name|free
argument_list|(
name|pETEs
argument_list|)
expr_stmt|;
return|return
name|region
return|;
block|}
end_function
begin_comment
comment|// END OF PolyReg.c extract
end_comment
begin_function
DECL|function|qt_bitmapToRegion
name|QRegionPrivate
modifier|*
name|qt_bitmapToRegion
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bitmap
parameter_list|,
name|QRegionPrivate
modifier|*
name|region
parameter_list|)
block|{
name|region
operator|->
name|vector
argument_list|()
expr_stmt|;
name|QImage
name|image
init|=
name|bitmap
operator|.
name|toImage
argument_list|()
decl_stmt|;
name|QRect
name|xr
decl_stmt|;
DECL|macro|AddSpan
define|#
directive|define
name|AddSpan
define|\
value|{ \             xr.setCoords(prev1, y, x-1, y); \             UnionRectWithRegion(&xr, region, *region); \         }
specifier|const
name|uchar
name|zero
init|=
literal|0
decl_stmt|;
name|bool
name|little
init|=
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_MonoLSB
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|image
operator|.
name|height
argument_list|()
condition|;
operator|++
name|y
control|)
block|{
name|uchar
modifier|*
name|line
init|=
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|uchar
name|all
init|=
name|zero
decl_stmt|;
name|int
name|prev1
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
control|)
block|{
name|uchar
name|byte
init|=
name|line
index|[
name|x
operator|/
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|w
operator|-
literal|8
operator|||
name|byte
operator|!=
name|all
condition|)
block|{
if|if
condition|(
name|little
condition|)
block|{
for|for
control|(
name|int
name|b
init|=
literal|8
init|;
name|b
operator|>
literal|0
operator|&&
name|x
operator|<
name|w
condition|;
operator|--
name|b
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|byte
operator|&
literal|0x01
operator|)
operator|==
operator|!
name|all
condition|)
block|{
comment|// More of the same
block|}
else|else
block|{
comment|// A change.
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
name|all
init|=
name|zero
decl_stmt|;
block|}
else|else
block|{
name|prev1
operator|=
name|x
expr_stmt|;
name|all
operator|=
operator|~
name|zero
expr_stmt|;
block|}
block|}
name|byte
operator|>>=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|b
init|=
literal|8
init|;
name|b
operator|>
literal|0
operator|&&
name|x
operator|<
name|w
condition|;
operator|--
name|b
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
operator|!
name|all
condition|)
block|{
comment|// More of the same
block|}
else|else
block|{
comment|// A change.
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
name|all
init|=
name|zero
decl_stmt|;
block|}
else|else
block|{
name|prev1
operator|=
name|x
expr_stmt|;
name|all
operator|=
operator|~
name|zero
expr_stmt|;
block|}
block|}
name|byte
operator|<<=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|x
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
block|}
block|}
DECL|macro|AddSpan
undef|#
directive|undef
name|AddSpan
return|return
name|region
return|;
block|}
end_function
begin_comment
comment|/*     Constructs an empty region.      \sa isEmpty() */
end_comment
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|&
name|shared_empty
argument_list|)
block|{
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*     \overload      Create a region based on the rectange \a r with region type \a t.      If the rectangle is invalid a null region will be created.      \sa QRegion::RegionType */
end_comment
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|RegionType
name|t
parameter_list|)
block|{
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|=
operator|&
name|shared_empty
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
else|else
block|{
comment|//        d = new QRegionData;
name|QRegionPrivate
modifier|*
name|rp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Rectangle
condition|)
block|{
comment|//            rp = new QRegionPrivate(r);
name|rp
operator|=
name|qt_allocRegion
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|Ellipse
condition|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addEllipse
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QPolygon
name|a
init|=
name|path
operator|.
name|toSubpathPolygons
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toPolygon
argument_list|()
decl_stmt|;
name|rp
operator|=
name|qt_allocRegion
argument_list|()
expr_stmt|;
comment|//            rp = new QRegionPrivate;
name|PolygonRegion
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|,
name|EvenOddRule
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|rp
expr_stmt|;
name|d
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|xrectangles
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|qt_rgn
operator|=
name|rp
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*     Constructs a polygon region from the point array \a a with the fill rule     specified by \a fillRule.      If \a fillRule is \l{Qt::WindingFill}, the polygon region is defined     using the winding algorithm; if it is \l{Qt::OddEvenFill}, the odd-even fill     algorithm is used.      \warning This constructor can be used to create complex regions that will     slow down painting when used. */
end_comment
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|//d =  new QRegionData;
comment|// QRegionPrivate *rp = new QRegionPrivate;
name|QRegionPrivate
modifier|*
name|rp
init|=
name|qt_allocRegion
argument_list|()
decl_stmt|;
name|PolygonRegion
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|,
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
name|WindingRule
else|:
name|EvenOddRule
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|d
operator|=
name|rp
expr_stmt|;
name|d
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|xrectangles
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|qt_rgn
operator|=
name|rp
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|&
name|shared_empty
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*     Constructs a new region which is equal to region \a r. */
end_comment
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|d
operator|=
name|r
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*     Constructs a region from the bitmap \a bm.      The resulting region consists of the pixels in bitmap \a bm that     are Qt::color1, as if each pixel was a 1 by 1 rectangle.      This constructor may create complex regions that will slow down     painting when used. Note that drawing masked pixmaps can be done     much faster using QPixmap::setMask(). */
end_comment
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bm
parameter_list|)
block|{
if|if
condition|(
name|bm
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|=
operator|&
name|shared_empty
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
else|else
block|{
comment|// d = new QRegionData;
comment|//        QRegionPrivate *rp = new QRegionPrivate;
name|QRegionPrivate
modifier|*
name|rp
init|=
name|qt_allocRegion
argument_list|()
decl_stmt|;
name|qt_bitmapToRegion
argument_list|(
name|bm
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|d
operator|=
name|rp
expr_stmt|;
name|d
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|xrectangles
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|qt_rgn
operator|=
name|rp
expr_stmt|;
block|}
block|}
end_constructor
begin_function
DECL|function|cleanUp
name|void
name|QRegion
operator|::
name|cleanUp
parameter_list|(
name|QRegion
operator|::
name|QRegionData
modifier|*
name|x
parameter_list|)
block|{
comment|// delete x->qt_rgn;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|x
operator|->
name|rgn
condition|)
name|XDestroyRegion
argument_list|(
name|x
operator|->
name|rgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|xrectangles
condition|)
name|free
argument_list|(
name|x
operator|->
name|xrectangles
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|x
operator|->
name|rgn
condition|)
name|qt_mac_dispose_rgn
argument_list|(
name|x
operator|->
name|rgn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|->
name|qt_rgn
condition|)
block|{
comment|//        delete x->qt_rgn;
name|qt_freeRegion
argument_list|(
name|x
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|x
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     Destroys the region. */
end_comment
begin_destructor
DECL|function|~QRegion
name|QRegion
operator|::
name|~
name|QRegion
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*     Assigns \a r to this region and returns a reference to the region. */
end_comment
begin_function
DECL|function|operator =
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|r
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|r
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|copy
name|QRegion
name|QRegion
operator|::
name|copy
parameter_list|()
specifier|const
block|{
name|QRegion
name|r
decl_stmt|;
name|QRegionData
modifier|*
name|x
init|=
literal|0
decl_stmt|;
comment|// new QRegionData;
name|QRegionPrivate
modifier|*
name|rp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
condition|)
comment|//        rp = new QRegionPrivate(*d->qt_rgn);
name|rp
operator|=
name|qt_allocRegion
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
else|else
name|rp
operator|=
name|qt_allocRegion
argument_list|()
expr_stmt|;
name|x
operator|=
name|rp
expr_stmt|;
name|x
operator|->
name|qt_rgn
operator|=
name|rp
expr_stmt|;
name|x
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|x
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|xrectangles
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|x
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|r
operator|.
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|r
operator|.
name|d
argument_list|)
expr_stmt|;
name|r
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if the region is empty; otherwise returns false. An     empty region is a region that contains no points.      Example:     \snippet doc/src/snippets/code/src.gui.painting.qregion_qws.cpp 0 */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QRegion
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
operator|&
name|shared_empty
operator|||
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if the region contains the point \a p; otherwise     returns false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QRegion
operator|::
name|contains
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
return|return
name|PointInRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \overload      Returns true if the region overlaps the rectangle \a r; otherwise     returns false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QRegion
operator|::
name|contains
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|qt_rgn
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
return|return
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|.
name|contains
argument_list|(
name|r
argument_list|)
return|;
return|return
name|RectInRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
operator|!=
name|RectangleOut
return|;
block|}
end_function
begin_comment
comment|/*     Translates (moves) the region \a dx along the X axis and \a dy     along the Y axis. */
end_comment
begin_function
DECL|function|translate
name|void
name|QRegion
operator|::
name|translate
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|)
operator|||
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|OffsetRegion
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|d
operator|->
name|xrectangles
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|xrectangles
argument_list|)
expr_stmt|;
name|d
operator|->
name|xrectangles
operator|=
literal|0
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|d
operator|->
name|rgn
condition|)
block|{
name|qt_mac_dispose_rgn
argument_list|(
name|d
operator|->
name|rgn
argument_list|)
expr_stmt|;
name|d
operator|->
name|rgn
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     \fn QRegion QRegion::unite(const QRegion&r) const     \obsolete      Use united(\a r) instead. */
end_comment
begin_comment
comment|/*     \fn QRegion QRegion::united(const QRegion&r) const     \since 4.2      Returns a region which is the union of this region and \a r.      \img runion.png Region Union      The figure shows the union of two elliptical regions.      \sa intersected(), subtracted(), xored() */
end_comment
begin_function
DECL|function|unite
name|QRegion
name|QRegion
operator|::
name|unite
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|UnionRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function
begin_function
DECL|function|operator +=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|+=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
operator|=
name|r
return|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
operator|=
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canPrepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|prepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
return|return
operator|*
name|this
operator|=
name|unite
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \fn QRegion QRegion::intersect(const QRegion&r) const     \obsolete      Use intersected(\a r) instead. */
end_comment
begin_comment
comment|/*     \fn QRegion QRegion::intersected(const QRegion&r) const     \since 4.2      Returns a region which is the intersection of this region and \a r.      \img rintersect.png Region Intersection      The figure shows the intersection of two elliptical regions. */
end_comment
begin_function
DECL|function|intersect
name|QRegion
name|QRegion
operator|::
name|intersect
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
comment|/* this is fully contained in r */
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
comment|/* r is fully contained in this */
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
operator|&&
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
return|return
name|QRegion
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|.
name|intersected
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|single
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|QT_GREENPHONE_OPT
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
return|return
name|intersect
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|single
argument_list|)
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
return|return
name|r
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|single
argument_list|)
return|;
endif|#
directive|endif
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|miRegionOp
argument_list|(
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
name|miIntersectO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Can't alter dest's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the same. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_GREENPHONE_OPT
end_ifdef
begin_comment
comment|/*   \overload   */
end_comment
begin_function
DECL|function|intersect
name|QRegion
name|QRegion
operator|::
name|intersect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
comment|// No intersection
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
operator|||
name|isEmpty
argument_list|()
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
comment|// This is fully contained in r
if|if
condition|(
name|CONTAINSCHECK
argument_list|(
name|r
argument_list|,
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
comment|// r is fully contained in this
if|if
condition|(
name|CONTAINSCHECK
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
argument_list|,
name|r
argument_list|)
condition|)
return|return
name|QRegion
argument_list|(
name|r
argument_list|)
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
block|{
return|return
name|QRegion
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|&
name|r
argument_list|)
return|;
block|}
else|else
block|{
name|QRegion
name|rv
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|rv
operator|.
name|detach
argument_list|()
expr_stmt|;
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|&=
name|r
expr_stmt|;
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|&=
name|r
expr_stmt|;
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerArea
operator|=
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|.
name|height
argument_list|()
operator|*
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|.
name|width
argument_list|()
expr_stmt|;
name|int
name|numRects
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
condition|;
operator|++
name|ii
control|)
block|{
name|QRect
name|result
init|=
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|ii
index|]
operator|&
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|numRects
operator|++
index|]
operator|=
name|result
expr_stmt|;
block|}
name|rv
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|=
name|numRects
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
end_function
begin_comment
comment|/*    \overload  */
end_comment
begin_function
DECL|function|operator &
specifier|const
name|QRegion
name|QRegion
operator|::
name|operator
name|&
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|intersect
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    \overload  */
end_comment
begin_function
DECL|function|operator &=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|&=
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|CONTAINSCHECK
argument_list|(
name|r
argument_list|,
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
block|{
comment|// Do nothing
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONTAINSCHECK
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
argument_list|,
name|r
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QRegion
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
condition|)
block|{
name|QRect
name|result
init|=
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|&
name|r
decl_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|=
name|result
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|=
name|result
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|=
name|result
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerArea
operator|=
name|result
operator|.
name|height
argument_list|()
operator|*
name|result
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|&=
name|r
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|&=
name|r
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerArea
operator|=
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|.
name|height
argument_list|()
operator|*
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|.
name|width
argument_list|()
expr_stmt|;
name|int
name|numRects
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
condition|;
operator|++
name|ii
control|)
block|{
name|QRect
name|result
init|=
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|ii
index|]
operator|&
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|numRects
operator|++
index|]
operator|=
name|result
expr_stmt|;
block|}
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|=
name|numRects
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*     \fn QRegion QRegion::subtract(const QRegion&r) const     \obsolete      Use subtracted(\a r) instead. */
end_comment
begin_comment
comment|/*     \fn QRegion QRegion::subtracted(const QRegion&r) const     \since 4.2      Returns a region which is \a r subtracted from this region.      \img rsubtract.png Region Subtraction      The figure shows the result when the ellipse on the right is     subtracted from the ellipse on the left (\c {left - right}).      \sa intersected(), united(), xored() */
end_comment
begin_function
DECL|function|subtract
name|QRegion
name|QRegion
operator|::
name|subtract
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
if|if
condition|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|SubtractRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*     \fn QRegion QRegion::eor(const QRegion&r) const     \obsolete      Use xored(\a r) instead. */
end_comment
begin_comment
comment|/*     \fn QRegion QRegion::xored(const QRegion&r) const     \since 4.2      Returns a region which is the exclusive or (XOR) of this region     and \a r.      \img rxor.png Region XORed      The figure shows the exclusive or of two elliptical regions.      \sa intersected(), united(), subtracted() */
end_comment
begin_function
DECL|function|eor
name|QRegion
name|QRegion
operator|::
name|eor
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
block|{
return|return
operator|(
operator|*
name|this
operator|+
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|QRegion
argument_list|()
return|;
block|}
else|else
block|{
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|XorRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function
begin_comment
comment|/*     Returns the bounding rectangle of this region. An empty region     gives a rectangle that is QRect::isNull(). */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QRegion
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
return|return
name|d
operator|->
name|qt_rgn
operator|->
name|extents
return|;
block|}
end_function
begin_comment
comment|/* \internal     Returns true if \a rect is guaranteed to be fully contained in \a region.     A false return value does not guarantee the opposite. */
end_comment
begin_function
DECL|function|qt_region_strictContains
name|bool
name|qt_region_strictContains
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|region
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
operator|!
name|rect
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|#
directive|if
literal|0
comment|// TEST_INNERRECT
block|static bool guard = false;     if (guard)         return QRect();     guard = true;     QRegion inner = region.d->qt_rgn->innerRect;     Q_ASSERT((inner - region).isEmpty());     guard = false;      int maxArea = 0;     for (int i = 0; i< region.d->qt_rgn->numRects; ++i) {         const QRect r = region.d->qt_rgn->rects.at(i);         if (r.width() * r.height()> maxArea)             maxArea = r.width() * r.height();     }      if (maxArea> region.d->qt_rgn->innerArea) {         qDebug()<< "not largest rectangle"<< region<< region.d->qt_rgn->innerRect;     }     Q_ASSERT(maxArea<= region.d->qt_rgn->innerArea);
endif|#
directive|endif
specifier|const
name|QRect
name|r1
init|=
name|region
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
decl_stmt|;
return|return
operator|(
name|rect
operator|.
name|left
argument_list|()
operator|>=
name|r1
operator|.
name|left
argument_list|()
operator|&&
name|rect
operator|.
name|right
argument_list|()
operator|<=
name|r1
operator|.
name|right
argument_list|()
operator|&&
name|rect
operator|.
name|top
argument_list|()
operator|>=
name|r1
operator|.
name|top
argument_list|()
operator|&&
name|rect
operator|.
name|bottom
argument_list|()
operator|<=
name|r1
operator|.
name|bottom
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*     Returns an array of non-overlapping rectangles that make up the     region.      The union of all the rectangles is equal to the original region. */
end_comment
begin_function
DECL|function|rects
name|QVector
argument_list|<
name|QRect
argument_list|>
name|QRegion
operator|::
name|rects
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|qt_rgn
condition|)
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|vector
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
operator|.
name|resize
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qt_rgn
operator|->
name|rects
return|;
block|}
else|else
block|{
return|return
name|QVector
argument_list|<
name|QRect
argument_list|>
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*   \fn void QRegion::setRects(const QRect *rects, int number)    Sets the region using the array of rectangles specified by \a rects and   \a number.   The rectangles \e must be optimally Y-X sorted and follow these restrictions:    \list   \o The rectangles must not intersect.   \o All rectangles with a given top coordinate must have the same height.   \o No two rectangles may abut horizontally (they should be combined      into a single wider rectangle in that case).   \o The rectangles must be sorted in ascending order, with Y as the major      sort key and X as the minor sort key.   \endlist   \omit   Only some platforms have these restrictions (Qt for Embedded Linux, X11 and Mac OS X).   \endomit */
end_comment
begin_function
DECL|function|setRects
name|void
name|QRegion
operator|::
name|setRects
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rects
parameter_list|,
name|int
name|num
parameter_list|)
block|{
operator|*
name|this
operator|=
name|QRegion
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rects
operator|||
name|num
operator|==
literal|0
operator|||
operator|(
name|num
operator|==
literal|1
operator|&&
name|rects
operator|->
name|isEmpty
argument_list|()
operator|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|single
operator|=
operator|*
name|rects
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|=
name|QRegionPrivate
operator|::
name|Single
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|=
name|num
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|=
operator|*
name|rects
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|=
operator|*
name|rects
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|=
name|QRegionPrivate
operator|::
name|Vector
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
operator|.
name|resize
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|=
name|num
expr_stmt|;
name|int
name|left
init|=
name|INT_MAX
decl_stmt|,
name|right
init|=
name|INT_MIN
decl_stmt|,
name|top
init|=
name|INT_MAX
decl_stmt|,
name|bottom
init|=
name|INT_MIN
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
modifier|&
name|rect
init|=
name|rects
index|[
name|i
index|]
decl_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|i
index|]
operator|=
name|rect
expr_stmt|;
name|left
operator|=
name|qMin
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|qMax
argument_list|(
name|rect
operator|.
name|right
argument_list|()
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|qMax
argument_list|(
name|rect
operator|.
name|bottom
argument_list|()
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|updateInnerRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|left
argument_list|,
name|top
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     Returns true if the region is equal to \a r; otherwise returns     false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QRegion
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|qt_rgn
operator|||
operator|!
name|r
operator|.
name|d
operator|->
name|qt_rgn
condition|)
return|return
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|==
name|d
operator|->
name|qt_rgn
return|;
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
condition|)
return|return
literal|true
return|;
else|else
return|return
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_GREENPHONE_OPT
end_ifdef
begin_function
DECL|function|isRect
name|bool
name|QRegion
operator|::
name|isRect
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|qt_rgn
operator|&&
name|d
operator|->
name|qt_rgn
operator|->
name|mode
operator|==
name|QRegionPrivate
operator|::
name|Single
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
