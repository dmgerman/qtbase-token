begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtransform.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qregion.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath_p.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<qnumeric.h>
end_include
begin_include
include|#
directive|include
file|<private/qbezier_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|Q_NEAR_CLIP
define|#
directive|define
name|Q_NEAR_CLIP
value|(sizeof(qreal) == sizeof(double) ? 0.000001 : 0.0001)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|MAP
end_ifdef
begin_undef
DECL|macro|MAP
undef|#
directive|undef
name|MAP
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|MAP
define|#
directive|define
name|MAP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|nx
parameter_list|,
name|ny
parameter_list|)
define|\
value|do { \         qreal FX_ = x; \         qreal FY_ = y; \         switch(t) {   \         case TxNone:  \             nx = FX_;   \             ny = FY_;   \             break;    \         case TxTranslate:    \             nx = FX_ + affine._dx;                \             ny = FY_ + affine._dy;                \             break;                              \         case TxScale:                           \             nx = affine._m11 * FX_ + affine._dx;  \             ny = affine._m22 * FY_ + affine._dy;  \             break;                              \         case TxRotate:                          \         case TxShear:                           \         case TxProject:                                      \             nx = affine._m11 * FX_ + affine._m21 * FY_ + affine._dx;        \             ny = affine._m12 * FX_ + affine._m22 * FY_ + affine._dy;        \             if (t == TxProject) {                                       \                 qreal w = (m_13 * FX_ + m_23 * FY_ + m_33);              \                 if (w< qreal(Q_NEAR_CLIP)) w = qreal(Q_NEAR_CLIP);     \                 w = 1./w;                                               \                 nx *= w;                                                \                 ny *= w;                                                \             }                                                           \         }                                                               \     } while (0)
end_define
begin_comment
comment|/*!     \class QTransform     \brief The QTransform class specifies 2D transformations of a coordinate system.     \since 4.3     \ingroup painting     \inmodule QtGui      A transformation specifies how to translate, scale, shear, rotate     or project the coordinate system, and is typically used when     rendering graphics.      QTransform differs from QMatrix in that it is a true 3x3 matrix,     allowing perspective transformations. QTransform's toAffine()     method allows casting QTransform to QMatrix. If a perspective     transformation has been specified on the matrix, then the     conversion will cause loss of data.      QTransform is the recommended transformation class in Qt.      A QTransform object can be built using the setMatrix(), scale(),     rotate(), translate() and shear() functions.  Alternatively, it     can be built by applying \l {QTransform#Basic Matrix     Operations}{basic matrix operations}. The matrix can also be     defined when constructed, and it can be reset to the identity     matrix (the default) using the reset() function.      The QTransform class supports mapping of graphic primitives: A given     point, line, polygon, region, or painter path can be mapped to the     coordinate system defined by \e this matrix using the map()     function. In case of a rectangle, its coordinates can be     transformed using the mapRect() function. A rectangle can also be     transformed into a \e polygon (mapped to the coordinate system     defined by \e this matrix), using the mapToPolygon() function.      QTransform provides the isIdentity() function which returns true if     the matrix is the identity matrix, and the isInvertible() function     which returns true if the matrix is non-singular (i.e. AB = BA =     I). The inverted() function returns an inverted copy of \e this     matrix if it is invertible (otherwise it returns the identity     matrix), and adjoint() returns the matrix's classical adjoint.     In addition, QTransform provides the determinant() function which     returns the matrix's determinant.      Finally, the QTransform class supports matrix multiplication, addition     and subtraction, and objects of the class can be streamed as well     as compared.      \tableofcontents      \section1 Rendering Graphics      When rendering graphics, the matrix defines the transformations     but the actual transformation is performed by the drawing routines     in QPainter.      By default, QPainter operates on the associated device's own     coordinate system.  The standard coordinate system of a     QPaintDevice has its origin located at the top-left position. The     \e x values increase to the right; \e y values increase     downward. For a complete description, see the \l {Coordinate     System} {coordinate system} documentation.      QPainter has functions to translate, scale, shear and rotate the     coordinate system without using a QTransform. For example:      \table 100%     \row     \li \inlineimage qtransform-simpletransformation.png     \li     \snippet transform/main.cpp 0     \endtable      Although these functions are very convenient, it can be more     efficient to build a QTransform and call QPainter::setTransform() if you     want to perform more than a single transform operation. For     example:      \table 100%     \row     \li \inlineimage qtransform-combinedtransformation.png     \li     \snippet transform/main.cpp 1     \endtable      \section1 Basic Matrix Operations      \image qtransform-representation.png      A QTransform object contains a 3 x 3 matrix.  The \c m31 (\c dx) and     \c m32 (\c dy) elements specify horizontal and vertical translation.     The \c m11 and \c m22 elements specify horizontal and vertical scaling.     The \c m21 and \c m12 elements specify horizontal and vertical \e shearing.     And finally, the \c m13 and \c m23 elements specify horizontal and vertical     projection, with \c m33 as an additional projection factor.      QTransform transforms a point in the plane to another point using the     following formulas:      \snippet code/src_gui_painting_qtransform.cpp 0      The point \e (x, y) is the original point, and \e (x', y') is the     transformed point. \e (x', y') can be transformed back to \e (x,     y) by performing the same operation on the inverted() matrix.      The various matrix elements can be set when constructing the     matrix, or by using the setMatrix() function later on. They can also     be manipulated using the translate(), rotate(), scale() and     shear() convenience functions. The currently set values can be     retrieved using the m11(), m12(), m13(), m21(), m22(), m23(),     m31(), m32(), m33(), dx() and dy() functions.      Translation is the simplest transformation. Setting \c dx and \c     dy will move the coordinate system \c dx units along the X axis     and \c dy units along the Y axis.  Scaling can be done by setting     \c m11 and \c m22. For example, setting \c m11 to 2 and \c m22 to     1.5 will double the height and increase the width by 50%.  The     identity matrix has \c m11, \c m22, and \c m33 set to 1 (all others are set     to 0) mapping a point to itself. Shearing is controlled by \c m12     and \c m21. Setting these elements to values different from zero     will twist the coordinate system. Rotation is achieved by     setting both the shearing factors and the scaling factors. Perspective     transformation is achieved by setting both the projection factors and     the scaling factors.      Here's the combined transformations example using basic matrix     operations:      \table 100%     \row     \li \inlineimage qtransform-combinedtransformation2.png     \li     \snippet transform/main.cpp 2     \endtable      \sa QPainter, {Coordinate System}, {painting/affine}{Affine     Transformations Example}, {Transformations Example} */
end_comment
begin_comment
comment|/*!     \enum QTransform::TransformationType      \value TxNone     \value TxTranslate     \value TxScale     \value TxRotate     \value TxShear     \value TxProject */
end_comment
begin_comment
comment|/*!     \fn QTransform::QTransform(Qt::Initialization)     \internal */
end_comment
begin_comment
comment|/*!     Constructs an identity matrix.      All elements are set to zero except \c m11 and \c m22 (specifying     the scale) and \c m33 which are set to 1.      \sa reset() */
end_comment
begin_constructor
DECL|function|QTransform
name|QTransform
operator|::
name|QTransform
parameter_list|()
member_init_list|:
name|affine
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|m_13
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_23
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_33
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|m_type
argument_list|(
name|TxNone
argument_list|)
member_init_list|,
name|m_dirty
argument_list|(
name|TxNone
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \fn QTransform::QTransform(qreal m11, qreal m12, qreal m13, qreal m21, qreal m22, qreal m23, qreal m31, qreal m32, qreal m33)      Constructs a matrix with the elements, \a m11, \a m12, \a m13,     \a m21, \a m22, \a m23, \a m31, \a m32, \a m33.      \sa setMatrix() */
end_comment
begin_constructor
DECL|function|QTransform
name|QTransform
operator|::
name|QTransform
parameter_list|(
name|qreal
name|h11
parameter_list|,
name|qreal
name|h12
parameter_list|,
name|qreal
name|h13
parameter_list|,
name|qreal
name|h21
parameter_list|,
name|qreal
name|h22
parameter_list|,
name|qreal
name|h23
parameter_list|,
name|qreal
name|h31
parameter_list|,
name|qreal
name|h32
parameter_list|,
name|qreal
name|h33
parameter_list|)
member_init_list|:
name|affine
argument_list|(
name|h11
argument_list|,
name|h12
argument_list|,
name|h21
argument_list|,
name|h22
argument_list|,
name|h31
argument_list|,
name|h32
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|m_13
argument_list|(
name|h13
argument_list|)
member_init_list|,
name|m_23
argument_list|(
name|h23
argument_list|)
member_init_list|,
name|m_33
argument_list|(
name|h33
argument_list|)
member_init_list|,
name|m_type
argument_list|(
name|TxNone
argument_list|)
member_init_list|,
name|m_dirty
argument_list|(
name|TxProject
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \fn QTransform::QTransform(qreal m11, qreal m12, qreal m21, qreal m22, qreal dx, qreal dy)      Constructs a matrix with the elements, \a m11, \a m12, \a m21, \a m22, \a dx and \a dy.      \sa setMatrix() */
end_comment
begin_constructor
DECL|function|QTransform
name|QTransform
operator|::
name|QTransform
parameter_list|(
name|qreal
name|h11
parameter_list|,
name|qreal
name|h12
parameter_list|,
name|qreal
name|h21
parameter_list|,
name|qreal
name|h22
parameter_list|,
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
member_init_list|:
name|affine
argument_list|(
name|h11
argument_list|,
name|h12
argument_list|,
name|h21
argument_list|,
name|h22
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|m_13
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_23
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_33
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|m_type
argument_list|(
name|TxNone
argument_list|)
member_init_list|,
name|m_dirty
argument_list|(
name|TxShear
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \fn QTransform::QTransform(const QMatrix&matrix)      Constructs a matrix that is a copy of the given \a matrix.     Note that the \c m13, \c m23, and \c m33 elements are set to 0, 0,     and 1 respectively.  */
end_comment
begin_constructor
DECL|function|QTransform
name|QTransform
operator|::
name|QTransform
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|mtx
parameter_list|)
member_init_list|:
name|affine
argument_list|(
name|mtx
operator|.
name|_m11
argument_list|,
name|mtx
operator|.
name|_m12
argument_list|,
name|mtx
operator|.
name|_m21
argument_list|,
name|mtx
operator|.
name|_m22
argument_list|,
name|mtx
operator|.
name|_dx
argument_list|,
name|mtx
operator|.
name|_dy
argument_list|,
literal|true
argument_list|)
member_init_list|,
name|m_13
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_23
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_33
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|m_type
argument_list|(
name|TxNone
argument_list|)
member_init_list|,
name|m_dirty
argument_list|(
name|TxShear
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Returns the adjoint of this matrix. */
end_comment
begin_function
DECL|function|adjoint
name|QTransform
name|QTransform
operator|::
name|adjoint
parameter_list|()
specifier|const
block|{
name|qreal
name|h11
decl_stmt|,
name|h12
decl_stmt|,
name|h13
decl_stmt|,
name|h21
decl_stmt|,
name|h22
decl_stmt|,
name|h23
decl_stmt|,
name|h31
decl_stmt|,
name|h32
decl_stmt|,
name|h33
decl_stmt|;
name|h11
operator|=
name|affine
operator|.
name|_m22
operator|*
name|m_33
operator|-
name|m_23
operator|*
name|affine
operator|.
name|_dy
expr_stmt|;
name|h21
operator|=
name|m_23
operator|*
name|affine
operator|.
name|_dx
operator|-
name|affine
operator|.
name|_m21
operator|*
name|m_33
expr_stmt|;
name|h31
operator|=
name|affine
operator|.
name|_m21
operator|*
name|affine
operator|.
name|_dy
operator|-
name|affine
operator|.
name|_m22
operator|*
name|affine
operator|.
name|_dx
expr_stmt|;
name|h12
operator|=
name|m_13
operator|*
name|affine
operator|.
name|_dy
operator|-
name|affine
operator|.
name|_m12
operator|*
name|m_33
expr_stmt|;
name|h22
operator|=
name|affine
operator|.
name|_m11
operator|*
name|m_33
operator|-
name|m_13
operator|*
name|affine
operator|.
name|_dx
expr_stmt|;
name|h32
operator|=
name|affine
operator|.
name|_m12
operator|*
name|affine
operator|.
name|_dx
operator|-
name|affine
operator|.
name|_m11
operator|*
name|affine
operator|.
name|_dy
expr_stmt|;
name|h13
operator|=
name|affine
operator|.
name|_m12
operator|*
name|m_23
operator|-
name|m_13
operator|*
name|affine
operator|.
name|_m22
expr_stmt|;
name|h23
operator|=
name|m_13
operator|*
name|affine
operator|.
name|_m21
operator|-
name|affine
operator|.
name|_m11
operator|*
name|m_23
expr_stmt|;
name|h33
operator|=
name|affine
operator|.
name|_m11
operator|*
name|affine
operator|.
name|_m22
operator|-
name|affine
operator|.
name|_m12
operator|*
name|affine
operator|.
name|_m21
expr_stmt|;
return|return
name|QTransform
argument_list|(
name|h11
argument_list|,
name|h12
argument_list|,
name|h13
argument_list|,
name|h21
argument_list|,
name|h22
argument_list|,
name|h23
argument_list|,
name|h31
argument_list|,
name|h32
argument_list|,
name|h33
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the transpose of this matrix. */
end_comment
begin_function
DECL|function|transposed
name|QTransform
name|QTransform
operator|::
name|transposed
parameter_list|()
specifier|const
block|{
name|QTransform
name|t
argument_list|(
name|affine
operator|.
name|_m11
argument_list|,
name|affine
operator|.
name|_m21
argument_list|,
name|affine
operator|.
name|_dx
argument_list|,
name|affine
operator|.
name|_m12
argument_list|,
name|affine
operator|.
name|_m22
argument_list|,
name|affine
operator|.
name|_dy
argument_list|,
name|m_13
argument_list|,
name|m_23
argument_list|,
name|m_33
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|t
operator|.
name|m_type
operator|=
name|m_type
expr_stmt|;
name|t
operator|.
name|m_dirty
operator|=
name|m_dirty
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an inverted copy of this matrix.      If the matrix is singular (not invertible), the returned matrix is     the identity matrix. If \a invertible is valid (i.e. not 0), its     value is set to true if the matrix is invertible, otherwise it is     set to false.      \sa isInvertible() */
end_comment
begin_function
DECL|function|inverted
name|QTransform
name|QTransform
operator|::
name|inverted
parameter_list|(
name|bool
modifier|*
name|invertible
parameter_list|)
specifier|const
block|{
name|QTransform
name|invert
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|bool
name|inv
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
break|break;
case|case
name|TxTranslate
case|:
name|invert
operator|.
name|affine
operator|.
name|_dx
operator|=
operator|-
name|affine
operator|.
name|_dx
expr_stmt|;
name|invert
operator|.
name|affine
operator|.
name|_dy
operator|=
operator|-
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|inv
operator|=
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m11
argument_list|)
expr_stmt|;
name|inv
operator|&=
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m22
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
block|{
name|invert
operator|.
name|affine
operator|.
name|_m11
operator|=
literal|1.
operator|/
name|affine
operator|.
name|_m11
expr_stmt|;
name|invert
operator|.
name|affine
operator|.
name|_m22
operator|=
literal|1.
operator|/
name|affine
operator|.
name|_m22
expr_stmt|;
name|invert
operator|.
name|affine
operator|.
name|_dx
operator|=
operator|-
name|affine
operator|.
name|_dx
operator|*
name|invert
operator|.
name|affine
operator|.
name|_m11
expr_stmt|;
name|invert
operator|.
name|affine
operator|.
name|_dy
operator|=
operator|-
name|affine
operator|.
name|_dy
operator|*
name|invert
operator|.
name|affine
operator|.
name|_m22
expr_stmt|;
block|}
break|break;
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
name|invert
operator|.
name|affine
operator|=
name|affine
operator|.
name|inverted
argument_list|(
operator|&
name|inv
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// general case
name|qreal
name|det
init|=
name|determinant
argument_list|()
decl_stmt|;
name|inv
operator|=
operator|!
name|qFuzzyIsNull
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|invert
operator|=
name|adjoint
argument_list|()
operator|/
name|det
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
name|inv
expr_stmt|;
if|if
condition|(
name|inv
condition|)
block|{
comment|// inverting doesn't change the type
name|invert
operator|.
name|m_type
operator|=
name|m_type
expr_stmt|;
name|invert
operator|.
name|m_dirty
operator|=
name|m_dirty
expr_stmt|;
block|}
return|return
name|invert
return|;
block|}
end_function
begin_comment
comment|/*!     Moves the coordinate system \a dx along the x axis and \a dy along     the y axis, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|translate
name|QTransform
modifier|&
name|QTransform
operator|::
name|translate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|dx
argument_list|)
operator||
name|qIsNaN
argument_list|(
name|dy
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::translate with NaN called"
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
name|affine
operator|.
name|_dx
operator|=
name|dx
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|dy
expr_stmt|;
break|break;
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_dx
operator|+=
name|dx
expr_stmt|;
name|affine
operator|.
name|_dy
operator|+=
name|dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|affine
operator|.
name|_dx
operator|+=
name|dx
operator|*
name|affine
operator|.
name|_m11
expr_stmt|;
name|affine
operator|.
name|_dy
operator|+=
name|dy
operator|*
name|affine
operator|.
name|_m22
expr_stmt|;
break|break;
case|case
name|TxProject
case|:
name|m_33
operator|+=
name|dx
operator|*
name|m_13
operator|+
name|dy
operator|*
name|m_23
expr_stmt|;
comment|// Fall through
case|case
name|TxShear
case|:
case|case
name|TxRotate
case|:
name|affine
operator|.
name|_dx
operator|+=
name|dx
operator|*
name|affine
operator|.
name|_m11
operator|+
name|dy
operator|*
name|affine
operator|.
name|_m21
expr_stmt|;
name|affine
operator|.
name|_dy
operator|+=
name|dy
operator|*
name|affine
operator|.
name|_m22
operator|+
name|dx
operator|*
name|affine
operator|.
name|_m12
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m_dirty
operator|<
name|TxTranslate
condition|)
name|m_dirty
operator|=
name|TxTranslate
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a matrix which corresponds to a translation of \a dx along     the x axis and \a dy along the y axis. This is the same as     QTransform().translate(dx, dy) but slightly faster.      \since 4.5 */
end_comment
begin_function
DECL|function|fromTranslate
name|QTransform
name|QTransform
operator|::
name|fromTranslate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|dx
argument_list|)
operator||
name|qIsNaN
argument_list|(
name|dy
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::fromTranslate with NaN called"
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
endif|#
directive|endif
name|QTransform
name|transform
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
name|transform
operator|.
name|m_type
operator|=
name|TxNone
expr_stmt|;
else|else
name|transform
operator|.
name|m_type
operator|=
name|TxTranslate
expr_stmt|;
name|transform
operator|.
name|m_dirty
operator|=
name|TxNone
expr_stmt|;
return|return
name|transform
return|;
block|}
end_function
begin_comment
comment|/*!     Scales the coordinate system by \a sx horizontally and \a sy     vertically, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|scale
name|QTransform
modifier|&
name|QTransform
operator|::
name|scale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
if|if
condition|(
name|sx
operator|==
literal|1
operator|&&
name|sy
operator|==
literal|1
condition|)
return|return
operator|*
name|this
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|sx
argument_list|)
operator||
name|qIsNaN
argument_list|(
name|sy
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::scale with NaN called"
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_m11
operator|=
name|sx
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|sy
expr_stmt|;
break|break;
case|case
name|TxProject
case|:
name|m_13
operator|*=
name|sx
expr_stmt|;
name|m_23
operator|*=
name|sy
expr_stmt|;
comment|// fall through
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
name|affine
operator|.
name|_m12
operator|*=
name|sx
expr_stmt|;
name|affine
operator|.
name|_m21
operator|*=
name|sy
expr_stmt|;
comment|// fall through
case|case
name|TxScale
case|:
name|affine
operator|.
name|_m11
operator|*=
name|sx
expr_stmt|;
name|affine
operator|.
name|_m22
operator|*=
name|sy
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m_dirty
operator|<
name|TxScale
condition|)
name|m_dirty
operator|=
name|TxScale
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a matrix which corresponds to a scaling of     \a sx horizontally and \a sy vertically.     This is the same as QTransform().scale(sx, sy) but slightly faster.      \since 4.5 */
end_comment
begin_function
DECL|function|fromScale
name|QTransform
name|QTransform
operator|::
name|fromScale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|sx
argument_list|)
operator||
name|qIsNaN
argument_list|(
name|sy
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::fromScale with NaN called"
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
endif|#
directive|endif
name|QTransform
name|transform
argument_list|(
name|sx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|sx
operator|==
literal|1.
operator|&&
name|sy
operator|==
literal|1.
condition|)
name|transform
operator|.
name|m_type
operator|=
name|TxNone
expr_stmt|;
else|else
name|transform
operator|.
name|m_type
operator|=
name|TxScale
expr_stmt|;
name|transform
operator|.
name|m_dirty
operator|=
name|TxNone
expr_stmt|;
return|return
name|transform
return|;
block|}
end_function
begin_comment
comment|/*!     Shears the coordinate system by \a sh horizontally and \a sv     vertically, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|shear
name|QTransform
modifier|&
name|QTransform
operator|::
name|shear
parameter_list|(
name|qreal
name|sh
parameter_list|,
name|qreal
name|sv
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|==
literal|0
operator|&&
name|sv
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|sh
argument_list|)
operator||
name|qIsNaN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::shear with NaN called"
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_m12
operator|=
name|sv
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|sh
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|affine
operator|.
name|_m12
operator|=
name|sv
operator|*
name|affine
operator|.
name|_m22
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|sh
operator|*
name|affine
operator|.
name|_m11
expr_stmt|;
break|break;
case|case
name|TxProject
case|:
block|{
name|qreal
name|tm13
init|=
name|sv
operator|*
name|m_23
decl_stmt|;
name|qreal
name|tm23
init|=
name|sh
operator|*
name|m_13
decl_stmt|;
name|m_13
operator|+=
name|tm13
expr_stmt|;
name|m_23
operator|+=
name|tm23
expr_stmt|;
block|}
comment|// fall through
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
block|{
name|qreal
name|tm11
init|=
name|sv
operator|*
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
name|sh
operator|*
name|affine
operator|.
name|_m12
decl_stmt|;
name|qreal
name|tm12
init|=
name|sv
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
name|sh
operator|*
name|affine
operator|.
name|_m11
decl_stmt|;
name|affine
operator|.
name|_m11
operator|+=
name|tm11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|+=
name|tm12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|+=
name|tm21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|+=
name|tm22
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m_dirty
operator|<
name|TxShear
condition|)
name|m_dirty
operator|=
name|TxShear
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|deg2rad
specifier|const
name|qreal
name|deg2rad
init|=
name|qreal
argument_list|(
literal|0.017453292519943295769
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|deg2rad
comment|// pi/180
end_comment
begin_decl_stmt
DECL|variable|inv_dist_to_plane
specifier|const
name|qreal
name|inv_dist_to_plane
init|=
literal|1.
operator|/
literal|1024.
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \fn QTransform&QTransform::rotate(qreal angle, Qt::Axis axis)      Rotates the coordinate system counterclockwise by the given \a angle     about the specified \a axis and returns a reference to the matrix.      Note that if you apply a QTransform to a point defined in widget     coordinates, the direction of the rotation will be clockwise     because the y-axis points downwards.      The angle is specified in degrees.      \sa setMatrix() */
end_comment
begin_function
DECL|function|rotate
name|QTransform
modifier|&
name|QTransform
operator|::
name|rotate
parameter_list|(
name|qreal
name|a
parameter_list|,
name|Qt
operator|::
name|Axis
name|axis
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::rotate with NaN called"
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
name|qreal
name|sina
init|=
literal|0
decl_stmt|;
name|qreal
name|cosa
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|90.
operator|||
name|a
operator|==
operator|-
literal|270.
condition|)
name|sina
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|270.
operator|||
name|a
operator|==
operator|-
literal|90.
condition|)
name|sina
operator|=
operator|-
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|180.
condition|)
name|cosa
operator|=
operator|-
literal|1.
expr_stmt|;
else|else
block|{
name|qreal
name|b
init|=
name|deg2rad
operator|*
name|a
decl_stmt|;
comment|// convert to radians
name|sina
operator|=
name|qSin
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|// fast and convenient
name|cosa
operator|=
name|qCos
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|axis
operator|==
name|Qt
operator|::
name|ZAxis
condition|)
block|{
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_m11
operator|=
name|cosa
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|sina
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
operator|-
name|sina
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|cosa
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
block|{
name|qreal
name|tm11
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|tm12
init|=
name|sina
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|tm22
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|tm11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|tm12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|tm21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|tm22
expr_stmt|;
break|break;
block|}
case|case
name|TxProject
case|:
block|{
name|qreal
name|tm13
init|=
name|cosa
operator|*
name|m_13
operator|+
name|sina
operator|*
name|m_23
decl_stmt|;
name|qreal
name|tm23
init|=
operator|-
name|sina
operator|*
name|m_13
operator|+
name|cosa
operator|*
name|m_23
decl_stmt|;
name|m_13
operator|=
name|tm13
expr_stmt|;
name|m_23
operator|=
name|tm23
expr_stmt|;
comment|// fall through
block|}
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
block|{
name|qreal
name|tm11
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m11
operator|+
name|sina
operator|*
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m12
operator|+
name|sina
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m11
operator|+
name|cosa
operator|*
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m12
operator|+
name|cosa
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|tm11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|tm12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|tm21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|tm22
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m_dirty
operator|<
name|TxRotate
condition|)
name|m_dirty
operator|=
name|TxRotate
expr_stmt|;
block|}
else|else
block|{
name|QTransform
name|result
decl_stmt|;
if|if
condition|(
name|axis
operator|==
name|Qt
operator|::
name|YAxis
condition|)
block|{
name|result
operator|.
name|affine
operator|.
name|_m11
operator|=
name|cosa
expr_stmt|;
name|result
operator|.
name|m_13
operator|=
operator|-
name|sina
operator|*
name|inv_dist_to_plane
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|affine
operator|.
name|_m22
operator|=
name|cosa
expr_stmt|;
name|result
operator|.
name|m_23
operator|=
operator|-
name|sina
operator|*
name|inv_dist_to_plane
expr_stmt|;
block|}
name|result
operator|.
name|m_type
operator|=
name|TxProject
expr_stmt|;
operator|*
name|this
operator|=
name|result
operator|*
operator|*
name|this
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform& QTransform::rotateRadians(qreal angle, Qt::Axis axis)      Rotates the coordinate system counterclockwise by the given \a angle     about the specified \a axis and returns a reference to the matrix.      Note that if you apply a QTransform to a point defined in widget     coordinates, the direction of the rotation will be clockwise     because the y-axis points downwards.      The angle is specified in radians.      \sa setMatrix() */
end_comment
begin_function
DECL|function|rotateRadians
name|QTransform
modifier|&
name|QTransform
operator|::
name|rotateRadians
parameter_list|(
name|qreal
name|a
parameter_list|,
name|Qt
operator|::
name|Axis
name|axis
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qIsNaN
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTransform::rotateRadians with NaN called"
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
name|qreal
name|sina
init|=
name|qSin
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|qreal
name|cosa
init|=
name|qCos
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|axis
operator|==
name|Qt
operator|::
name|ZAxis
condition|)
block|{
switch|switch
condition|(
name|inline_type
argument_list|()
condition|)
block|{
case|case
name|TxNone
case|:
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_m11
operator|=
name|cosa
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|sina
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
operator|-
name|sina
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|cosa
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
block|{
name|qreal
name|tm11
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|tm12
init|=
name|sina
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|tm22
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|tm11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|tm12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|tm21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|tm22
expr_stmt|;
break|break;
block|}
case|case
name|TxProject
case|:
block|{
name|qreal
name|tm13
init|=
name|cosa
operator|*
name|m_13
operator|+
name|sina
operator|*
name|m_23
decl_stmt|;
name|qreal
name|tm23
init|=
operator|-
name|sina
operator|*
name|m_13
operator|+
name|cosa
operator|*
name|m_23
decl_stmt|;
name|m_13
operator|=
name|tm13
expr_stmt|;
name|m_23
operator|=
name|tm23
expr_stmt|;
comment|// fall through
block|}
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
block|{
name|qreal
name|tm11
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m11
operator|+
name|sina
operator|*
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|cosa
operator|*
name|affine
operator|.
name|_m12
operator|+
name|sina
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m11
operator|+
name|cosa
operator|*
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
operator|-
name|sina
operator|*
name|affine
operator|.
name|_m12
operator|+
name|cosa
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|tm11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|tm12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|tm21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|tm22
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m_dirty
operator|<
name|TxRotate
condition|)
name|m_dirty
operator|=
name|TxRotate
expr_stmt|;
block|}
else|else
block|{
name|QTransform
name|result
decl_stmt|;
if|if
condition|(
name|axis
operator|==
name|Qt
operator|::
name|YAxis
condition|)
block|{
name|result
operator|.
name|affine
operator|.
name|_m11
operator|=
name|cosa
expr_stmt|;
name|result
operator|.
name|m_13
operator|=
operator|-
name|sina
operator|*
name|inv_dist_to_plane
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|affine
operator|.
name|_m22
operator|=
name|cosa
expr_stmt|;
name|result
operator|.
name|m_23
operator|=
operator|-
name|sina
operator|*
name|inv_dist_to_plane
expr_stmt|;
block|}
name|result
operator|.
name|m_type
operator|=
name|TxProject
expr_stmt|;
operator|*
name|this
operator|=
name|result
operator|*
operator|*
name|this
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTransform::operator==(const QTransform&matrix) const     Returns true if this matrix is equal to the given \a matrix,     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QTransform
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|o
parameter_list|)
specifier|const
block|{
return|return
name|affine
operator|.
name|_m11
operator|==
name|o
operator|.
name|affine
operator|.
name|_m11
operator|&&
name|affine
operator|.
name|_m12
operator|==
name|o
operator|.
name|affine
operator|.
name|_m12
operator|&&
name|affine
operator|.
name|_m21
operator|==
name|o
operator|.
name|affine
operator|.
name|_m21
operator|&&
name|affine
operator|.
name|_m22
operator|==
name|o
operator|.
name|affine
operator|.
name|_m22
operator|&&
name|affine
operator|.
name|_dx
operator|==
name|o
operator|.
name|affine
operator|.
name|_dx
operator|&&
name|affine
operator|.
name|_dy
operator|==
name|o
operator|.
name|affine
operator|.
name|_dy
operator|&&
name|m_13
operator|==
name|o
operator|.
name|m_13
operator|&&
name|m_23
operator|==
name|o
operator|.
name|m_23
operator|&&
name|m_33
operator|==
name|o
operator|.
name|m_33
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTransform::operator!=(const QTransform&matrix) const     Returns true if this matrix is not equal to the given \a matrix,     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QTransform
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|o
parameter_list|)
specifier|const
block|{
return|return
operator|!
name|operator
name|==
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform& QTransform::operator*=(const QTransform&matrix)     \overload      Returns the result of multiplying this matrix by the given \a     matrix. */
end_comment
begin_function
DECL|function|operator *=
name|QTransform
modifier|&
name|QTransform
operator|::
name|operator
name|*=
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|o
parameter_list|)
block|{
specifier|const
name|TransformationType
name|otherType
init|=
name|o
operator|.
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherType
operator|==
name|TxNone
condition|)
return|return
operator|*
name|this
return|;
specifier|const
name|TransformationType
name|thisType
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisType
operator|==
name|TxNone
condition|)
return|return
name|operator
name|=
argument_list|(
name|o
argument_list|)
return|;
name|TransformationType
name|t
init|=
name|qMax
argument_list|(
name|thisType
argument_list|,
name|otherType
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TxNone
case|:
break|break;
case|case
name|TxTranslate
case|:
name|affine
operator|.
name|_dx
operator|+=
name|o
operator|.
name|affine
operator|.
name|_dx
expr_stmt|;
name|affine
operator|.
name|_dy
operator|+=
name|o
operator|.
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|o
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
operator|+
name|o
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
break|break;
block|}
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m12
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|m12
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m12
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m21
init|=
name|affine
operator|.
name|_m21
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m21
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
operator|+
name|o
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
operator|+
name|o
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|m12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|m21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
break|break;
block|}
case|case
name|TxProject
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m12
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_13
operator|*
name|o
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m12
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m12
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_13
operator|*
name|o
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m13
init|=
name|affine
operator|.
name|_m11
operator|*
name|o
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_m12
operator|*
name|o
operator|.
name|m_23
operator|+
name|m_13
operator|*
name|o
operator|.
name|m_33
decl_stmt|;
name|qreal
name|m21
init|=
name|affine
operator|.
name|_m21
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_23
operator|*
name|o
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m21
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_23
operator|*
name|o
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m23
init|=
name|affine
operator|.
name|_m21
operator|*
name|o
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_m22
operator|*
name|o
operator|.
name|m_23
operator|+
name|m_23
operator|*
name|o
operator|.
name|m_33
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_33
operator|*
name|o
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_33
operator|*
name|o
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m33
init|=
name|affine
operator|.
name|_dx
operator|*
name|o
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_dy
operator|*
name|o
operator|.
name|m_23
operator|+
name|m_33
operator|*
name|o
operator|.
name|m_33
decl_stmt|;
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|m12
expr_stmt|;
name|m_13
operator|=
name|m13
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|m21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|m_23
operator|=
name|m23
expr_stmt|;
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
name|m_33
operator|=
name|m33
expr_stmt|;
block|}
block|}
name|m_dirty
operator|=
name|t
expr_stmt|;
name|m_type
operator|=
name|t
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform QTransform::operator*(const QTransform&matrix) const     Returns the result of multiplying this matrix by the given \a     matrix.      Note that matrix multiplication is not commutative, i.e. a*b !=     b*a. */
end_comment
begin_function
DECL|function|operator *
name|QTransform
name|QTransform
operator|::
name|operator
name|*
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|)
specifier|const
block|{
specifier|const
name|TransformationType
name|otherType
init|=
name|m
operator|.
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherType
operator|==
name|TxNone
condition|)
return|return
operator|*
name|this
return|;
specifier|const
name|TransformationType
name|thisType
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisType
operator|==
name|TxNone
condition|)
return|return
name|m
return|;
name|QTransform
name|t
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|TransformationType
name|type
init|=
name|qMax
argument_list|(
name|thisType
argument_list|,
name|otherType
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TxNone
case|:
break|break;
case|case
name|TxTranslate
case|:
name|t
operator|.
name|affine
operator|.
name|_dx
operator|=
name|affine
operator|.
name|_dx
operator|+
name|m
operator|.
name|affine
operator|.
name|_dx
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dy
operator|+=
name|affine
operator|.
name|_dy
operator|+
name|m
operator|.
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|m
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
break|break;
block|}
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m12
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|m12
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m12
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m21
init|=
name|affine
operator|.
name|_m21
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m21
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m12
operator|=
name|m12
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m21
operator|=
name|m21
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
break|break;
block|}
case|case
name|TxProject
case|:
block|{
name|qreal
name|m11
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m12
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_13
operator|*
name|m
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m12
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m12
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_13
operator|*
name|m
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m13
init|=
name|affine
operator|.
name|_m11
operator|*
name|m
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_m12
operator|*
name|m
operator|.
name|m_23
operator|+
name|m_13
operator|*
name|m
operator|.
name|m_33
decl_stmt|;
name|qreal
name|m21
init|=
name|affine
operator|.
name|_m21
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_23
operator|*
name|m
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m22
init|=
name|affine
operator|.
name|_m21
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_23
operator|*
name|m
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m23
init|=
name|affine
operator|.
name|_m21
operator|*
name|m
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_m22
operator|*
name|m
operator|.
name|m_23
operator|+
name|m_23
operator|*
name|m
operator|.
name|m_33
decl_stmt|;
name|qreal
name|m31
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|affine
operator|.
name|_m11
operator|+
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|affine
operator|.
name|_m21
operator|+
name|m_33
operator|*
name|m
operator|.
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|m32
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|affine
operator|.
name|_m22
operator|+
name|m_33
operator|*
name|m
operator|.
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|m33
init|=
name|affine
operator|.
name|_dx
operator|*
name|m
operator|.
name|m_13
operator|+
name|affine
operator|.
name|_dy
operator|*
name|m
operator|.
name|m_23
operator|+
name|m_33
operator|*
name|m
operator|.
name|m_33
decl_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m12
operator|=
name|m12
expr_stmt|;
name|t
operator|.
name|m_13
operator|=
name|m13
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m21
operator|=
name|m21
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|t
operator|.
name|m_23
operator|=
name|m23
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|t
operator|.
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
name|t
operator|.
name|m_33
operator|=
name|m33
expr_stmt|;
block|}
block|}
name|t
operator|.
name|m_dirty
operator|=
name|type
expr_stmt|;
name|t
operator|.
name|m_type
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform& QTransform::operator*=(qreal scalar)     \overload      Returns the result of performing an element-wise multiplication of this     matrix with the given \a scalar. */
end_comment
begin_comment
comment|/*!     \fn QTransform& QTransform::operator/=(qreal scalar)     \overload      Returns the result of performing an element-wise division of this     matrix by the given \a scalar. */
end_comment
begin_comment
comment|/*!     \fn QTransform& QTransform::operator+=(qreal scalar)     \overload      Returns the matrix obtained by adding the given \a scalar to each     element of this matrix. */
end_comment
begin_comment
comment|/*!     \fn QTransform& QTransform::operator-=(qreal scalar)     \overload      Returns the matrix obtained by subtracting the given \a scalar from each     element of this matrix. */
end_comment
begin_comment
comment|/*!     Assigns the given \a matrix's values to this matrix. */
end_comment
begin_function
DECL|function|operator =
name|QTransform
modifier|&
name|QTransform
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|affine
operator|.
name|_m11
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_m11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_m12
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_m21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_m22
expr_stmt|;
name|affine
operator|.
name|_dx
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_dx
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|matrix
operator|.
name|affine
operator|.
name|_dy
expr_stmt|;
name|m_13
operator|=
name|matrix
operator|.
name|m_13
expr_stmt|;
name|m_23
operator|=
name|matrix
operator|.
name|m_23
expr_stmt|;
name|m_33
operator|=
name|matrix
operator|.
name|m_33
expr_stmt|;
name|m_type
operator|=
name|matrix
operator|.
name|m_type
expr_stmt|;
name|m_dirty
operator|=
name|matrix
operator|.
name|m_dirty
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the matrix to an identity matrix, i.e. all elements are set     to zero, except \c m11 and \c m22 (specifying the scale) and \c m33     which are set to 1.      \sa QTransform(), isIdentity(), {QTransform#Basic Matrix     Operations}{Basic Matrix Operations} */
end_comment
begin_function
DECL|function|reset
name|void
name|QTransform
operator|::
name|reset
parameter_list|()
block|{
name|affine
operator|.
name|_m11
operator|=
name|affine
operator|.
name|_m22
operator|=
name|m_33
operator|=
literal|1.0
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|m_13
operator|=
name|affine
operator|.
name|_m21
operator|=
name|m_23
operator|=
name|affine
operator|.
name|_dx
operator|=
name|affine
operator|.
name|_dy
operator|=
literal|0
expr_stmt|;
name|m_type
operator|=
name|TxNone
expr_stmt|;
name|m_dirty
operator|=
name|TxNone
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QTransform&matrix)     \since 4.3     \relates QTransform      Writes the given \a matrix to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|)
block|{
name|s
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m11
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m12
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m13
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m21
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m22
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m23
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m31
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m32
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m33
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QTransform&matrix)     \since 4.3     \relates QTransform      Reads the given \a matrix from the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QTransform
modifier|&
name|t
parameter_list|)
block|{
name|double
name|m11
decl_stmt|,
name|m12
decl_stmt|,
name|m13
decl_stmt|,
name|m21
decl_stmt|,
name|m22
decl_stmt|,
name|m23
decl_stmt|,
name|m31
decl_stmt|,
name|m32
decl_stmt|,
name|m33
decl_stmt|;
name|s
operator|>>
name|m11
expr_stmt|;
name|s
operator|>>
name|m12
expr_stmt|;
name|s
operator|>>
name|m13
expr_stmt|;
name|s
operator|>>
name|m21
expr_stmt|;
name|s
operator|>>
name|m22
expr_stmt|;
name|s
operator|>>
name|m23
expr_stmt|;
name|s
operator|>>
name|m31
expr_stmt|;
name|s
operator|>>
name|m32
expr_stmt|;
name|s
operator|>>
name|m33
expr_stmt|;
name|t
operator|.
name|setMatrix
argument_list|(
name|m11
argument_list|,
name|m12
argument_list|,
name|m13
argument_list|,
name|m21
argument_list|,
name|m22
argument_list|,
name|m23
argument_list|,
name|m31
argument_list|,
name|m32
argument_list|,
name|m33
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|typeStr
index|[]
init|=
block|{
literal|"TxNone"
block|,
literal|"TxTranslate"
block|,
literal|"TxScale"
block|,
literal|0
block|,
literal|"TxRotate"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"TxShear"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"TxProject"
block|}
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QTransform(type="
operator|<<
name|typeStr
index|[
name|m
operator|.
name|type
argument_list|()
index|]
operator|<<
literal|','
operator|<<
literal|" 11="
operator|<<
name|m
operator|.
name|m11
argument_list|()
operator|<<
literal|" 12="
operator|<<
name|m
operator|.
name|m12
argument_list|()
operator|<<
literal|" 13="
operator|<<
name|m
operator|.
name|m13
argument_list|()
operator|<<
literal|" 21="
operator|<<
name|m
operator|.
name|m21
argument_list|()
operator|<<
literal|" 22="
operator|<<
name|m
operator|.
name|m22
argument_list|()
operator|<<
literal|" 23="
operator|<<
name|m
operator|.
name|m23
argument_list|()
operator|<<
literal|" 31="
operator|<<
name|m
operator|.
name|m31
argument_list|()
operator|<<
literal|" 32="
operator|<<
name|m
operator|.
name|m32
argument_list|()
operator|<<
literal|" 33="
operator|<<
name|m
operator|.
name|m33
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QPoint operator*(const QPoint&point, const QTransform&matrix)     \relates QTransform      This is the same as \a{matrix}.map(\a{point}).      \sa QTransform::map() */
end_comment
begin_function
DECL|function|map
name|QPoint
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|qreal
name|fx
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|fy
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|;
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TxNone
case|:
name|x
operator|=
name|fx
expr_stmt|;
name|y
operator|=
name|fy
expr_stmt|;
break|break;
case|case
name|TxTranslate
case|:
name|x
operator|=
name|fx
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|x
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
case|case
name|TxProject
case|:
name|x
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TxProject
condition|)
block|{
name|qreal
name|w
init|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx
operator|+
name|m_23
operator|*
name|fy
operator|+
name|m_33
operator|)
decl_stmt|;
name|x
operator|*=
name|w
expr_stmt|;
name|y
operator|*=
name|w
expr_stmt|;
block|}
block|}
return|return
name|QPoint
argument_list|(
name|qRound
argument_list|(
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF operator*(const QPointF&point, const QTransform&matrix)     \relates QTransform      Same as \a{matrix}.map(\a{point}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QPointF object that is a copy of the given point,     \a p, mapped into the coordinate system defined by this matrix. */
end_comment
begin_function
DECL|function|map
name|QPointF
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|qreal
name|fx
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|fy
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|;
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TxNone
case|:
name|x
operator|=
name|fx
expr_stmt|;
name|y
operator|=
name|fy
expr_stmt|;
break|break;
case|case
name|TxTranslate
case|:
name|x
operator|=
name|fx
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|x
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
case|case
name|TxProject
case|:
name|x
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TxProject
condition|)
block|{
name|qreal
name|w
init|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx
operator|+
name|m_23
operator|*
name|fy
operator|+
name|m_33
operator|)
decl_stmt|;
name|x
operator|*=
name|w
expr_stmt|;
name|y
operator|*=
name|w
expr_stmt|;
block|}
block|}
return|return
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QTransform::map(const QPoint&point) const     \overload      Creates and returns a QPoint object that is a copy of the given \a     point, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_comment
comment|/*!     \fn QLineF operator*(const QLineF&line, const QTransform&matrix)     \relates QTransform      This is the same as \a{matrix}.map(\a{line}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \fn QLine operator*(const QLine&line, const QTransform&matrix)     \relates QTransform      This is the same as \a{matrix}.map(\a{line}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QLineF object that is a copy of the given line,     \a l, mapped into the coordinate system defined by this matrix. */
end_comment
begin_function
DECL|function|map
name|QLine
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QLine
modifier|&
name|l
parameter_list|)
specifier|const
block|{
name|qreal
name|fx1
init|=
name|l
operator|.
name|x1
argument_list|()
decl_stmt|;
name|qreal
name|fy1
init|=
name|l
operator|.
name|y1
argument_list|()
decl_stmt|;
name|qreal
name|fx2
init|=
name|l
operator|.
name|x2
argument_list|()
decl_stmt|;
name|qreal
name|fy2
init|=
name|l
operator|.
name|y2
argument_list|()
decl_stmt|;
name|qreal
name|x1
init|=
literal|0
decl_stmt|,
name|y1
init|=
literal|0
decl_stmt|,
name|x2
init|=
literal|0
decl_stmt|,
name|y2
init|=
literal|0
decl_stmt|;
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TxNone
case|:
name|x1
operator|=
name|fx1
expr_stmt|;
name|y1
operator|=
name|fy1
expr_stmt|;
name|x2
operator|=
name|fx2
expr_stmt|;
name|y2
operator|=
name|fy2
expr_stmt|;
break|break;
case|case
name|TxTranslate
case|:
name|x1
operator|=
name|fx1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|fx2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|x1
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
case|case
name|TxProject
case|:
name|x1
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TxProject
condition|)
block|{
name|qreal
name|w
init|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx1
operator|+
name|m_23
operator|*
name|fy1
operator|+
name|m_33
operator|)
decl_stmt|;
name|x1
operator|*=
name|w
expr_stmt|;
name|y1
operator|*=
name|w
expr_stmt|;
name|w
operator|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx2
operator|+
name|m_23
operator|*
name|fy2
operator|+
name|m_33
operator|)
expr_stmt|;
name|x2
operator|*=
name|w
expr_stmt|;
name|y2
operator|*=
name|w
expr_stmt|;
block|}
block|}
return|return
name|QLine
argument_list|(
name|qRound
argument_list|(
name|x1
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y1
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x2
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y2
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \fn QLineF QTransform::map(const QLineF&line) const      Creates and returns a QLine object that is a copy of the given \a     line, mapped into the coordinate system defined by this matrix.     Note that the transformed coordinates are rounded to the nearest     integer. */
end_comment
begin_function
DECL|function|map
name|QLineF
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|l
parameter_list|)
specifier|const
block|{
name|qreal
name|fx1
init|=
name|l
operator|.
name|x1
argument_list|()
decl_stmt|;
name|qreal
name|fy1
init|=
name|l
operator|.
name|y1
argument_list|()
decl_stmt|;
name|qreal
name|fx2
init|=
name|l
operator|.
name|x2
argument_list|()
decl_stmt|;
name|qreal
name|fy2
init|=
name|l
operator|.
name|y2
argument_list|()
decl_stmt|;
name|qreal
name|x1
init|=
literal|0
decl_stmt|,
name|y1
init|=
literal|0
decl_stmt|,
name|x2
init|=
literal|0
decl_stmt|,
name|y2
init|=
literal|0
decl_stmt|;
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TxNone
case|:
name|x1
operator|=
name|fx1
expr_stmt|;
name|y1
operator|=
name|fy1
expr_stmt|;
name|x2
operator|=
name|fx2
expr_stmt|;
name|y2
operator|=
name|fy2
expr_stmt|;
break|break;
case|case
name|TxTranslate
case|:
name|x1
operator|=
name|fx1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|fx2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxScale
case|:
name|x1
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|affine
operator|.
name|_m22
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
break|break;
case|case
name|TxRotate
case|:
case|case
name|TxShear
case|:
case|case
name|TxProject
case|:
name|x1
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y1
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx1
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy1
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|x2
operator|=
name|affine
operator|.
name|_m11
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_m21
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y2
operator|=
name|affine
operator|.
name|_m12
operator|*
name|fx2
operator|+
name|affine
operator|.
name|_m22
operator|*
name|fy2
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TxProject
condition|)
block|{
name|qreal
name|w
init|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx1
operator|+
name|m_23
operator|*
name|fy1
operator|+
name|m_33
operator|)
decl_stmt|;
name|x1
operator|*=
name|w
expr_stmt|;
name|y1
operator|*=
name|w
expr_stmt|;
name|w
operator|=
literal|1.
operator|/
operator|(
name|m_13
operator|*
name|fx2
operator|+
name|m_23
operator|*
name|fy2
operator|+
name|m_33
operator|)
expr_stmt|;
name|x2
operator|*=
name|w
expr_stmt|;
name|y2
operator|*=
name|w
expr_stmt|;
block|}
block|}
return|return
name|QLineF
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mapProjective
specifier|static
name|QPolygonF
name|mapProjective
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|poly
parameter_list|)
block|{
if|if
condition|(
name|poly
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|poly
return|;
if|if
condition|(
name|poly
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|QPolygonF
argument_list|()
operator|<<
name|transform
operator|.
name|map
argument_list|(
name|poly
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addPolygon
argument_list|(
name|poly
argument_list|)
expr_stmt|;
name|path
operator|=
name|transform
operator|.
name|map
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|QPolygonF
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
name|result
operator|<<
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF operator *(const QPolygonF&polygon, const QTransform&matrix)     \since 4.3     \relates QTransform      This is the same as \a{matrix}.map(\a{polygon}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \fn QPolygon operator*(const QPolygon&polygon, const QTransform&matrix)     \relates QTransform      This is the same as \a{matrix}.map(\a{polygon}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \fn QPolygonF QTransform::map(const QPolygonF&polygon) const     \overload      Creates and returns a QPolygonF object that is a copy of the given     \a polygon, mapped into the coordinate system defined by this     matrix. */
end_comment
begin_function
DECL|function|map
name|QPolygonF
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|a
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|<=
name|TxTranslate
condition|)
return|return
name|a
operator|.
name|translated
argument_list|(
name|affine
operator|.
name|_dx
argument_list|,
name|affine
operator|.
name|_dy
argument_list|)
return|;
if|if
condition|(
name|t
operator|>=
name|QTransform
operator|::
name|TxProject
condition|)
return|return
name|mapProjective
argument_list|(
operator|*
name|this
argument_list|,
name|a
argument_list|)
return|;
name|int
name|size
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|QPolygonF
name|p
argument_list|(
name|size
argument_list|)
decl_stmt|;
specifier|const
name|QPointF
modifier|*
name|da
init|=
name|a
operator|.
name|constData
argument_list|()
decl_stmt|;
name|QPointF
modifier|*
name|dp
init|=
name|p
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|MAP
argument_list|(
name|da
index|[
name|i
index|]
operator|.
name|xp
argument_list|,
name|da
index|[
name|i
index|]
operator|.
name|yp
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|xp
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|yp
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygon QTransform::map(const QPolygon&polygon) const     \overload      Creates and returns a QPolygon object that is a copy of the given     \a polygon, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_function
DECL|function|map
name|QPolygon
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|<=
name|TxTranslate
condition|)
return|return
name|a
operator|.
name|translated
argument_list|(
name|qRound
argument_list|(
name|affine
operator|.
name|_dx
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|affine
operator|.
name|_dy
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|t
operator|>=
name|QTransform
operator|::
name|TxProject
condition|)
return|return
name|mapProjective
argument_list|(
operator|*
name|this
argument_list|,
name|QPolygonF
argument_list|(
name|a
argument_list|)
argument_list|)
operator|.
name|toPolygon
argument_list|()
return|;
name|int
name|size
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|QPolygon
name|p
argument_list|(
name|size
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|*
name|da
init|=
name|a
operator|.
name|constData
argument_list|()
decl_stmt|;
name|QPoint
modifier|*
name|dp
init|=
name|p
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|qreal
name|nx
init|=
literal|0
decl_stmt|,
name|ny
init|=
literal|0
decl_stmt|;
name|MAP
argument_list|(
name|da
index|[
name|i
index|]
operator|.
name|xp
argument_list|,
name|da
index|[
name|i
index|]
operator|.
name|yp
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|dp
index|[
name|i
index|]
operator|.
name|xp
operator|=
name|qRound
argument_list|(
name|nx
argument_list|)
expr_stmt|;
name|dp
index|[
name|i
index|]
operator|.
name|yp
operator|=
name|qRound
argument_list|(
name|ny
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRegion operator*(const QRegion&region, const QTransform&matrix)     \relates QTransform      This is the same as \a{matrix}.map(\a{region}).      \sa QTransform::map() */
end_comment
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     \fn QRegion QTransform::map(const QRegion&region) const     \overload      Creates and returns a QRegion object that is a copy of the given     \a region, mapped into the coordinate system defined by this matrix.      Calling this method can be rather expensive if rotations or     shearing are used. */
end_comment
begin_function
DECL|function|map
name|QRegion
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TxNone
condition|)
return|return
name|r
return|;
if|if
condition|(
name|t
operator|==
name|TxTranslate
condition|)
block|{
name|QRegion
name|copy
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|copy
operator|.
name|translate
argument_list|(
name|qRound
argument_list|(
name|affine
operator|.
name|_dx
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|affine
operator|.
name|_dy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
if|if
condition|(
name|t
operator|==
name|TxScale
operator|&&
name|r
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
return|return
name|QRegion
argument_list|(
name|mapRect
argument_list|(
name|r
operator|.
name|boundingRect
argument_list|()
argument_list|)
argument_list|)
return|;
name|QPainterPath
name|p
init|=
name|map
argument_list|(
name|qt_regionToPath
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|p
operator|.
name|toFillPolygon
argument_list|(
name|QTransform
argument_list|()
argument_list|)
operator|.
name|toPolygon
argument_list|()
return|;
block|}
end_function
begin_struct
DECL|struct|QHomogeneousCoordinate
struct|struct
name|QHomogeneousCoordinate
block|{
DECL|member|x
name|qreal
name|x
decl_stmt|;
DECL|member|y
name|qreal
name|y
decl_stmt|;
DECL|member|w
name|qreal
name|w
decl_stmt|;
DECL|function|QHomogeneousCoordinate
name|QHomogeneousCoordinate
parameter_list|()
block|{}
DECL|function|QHomogeneousCoordinate
name|QHomogeneousCoordinate
parameter_list|(
name|qreal
name|x_
parameter_list|,
name|qreal
name|y_
parameter_list|,
name|qreal
name|w_
parameter_list|)
member_init_list|:
name|x
argument_list|(
name|x_
argument_list|)
member_init_list|,
name|y
argument_list|(
name|y_
argument_list|)
member_init_list|,
name|w
argument_list|(
name|w_
argument_list|)
block|{}
DECL|function|toPoint
specifier|const
name|QPointF
name|toPoint
parameter_list|()
specifier|const
block|{
name|qreal
name|iw
init|=
literal|1.
operator|/
name|w
decl_stmt|;
return|return
name|QPointF
argument_list|(
name|x
operator|*
name|iw
argument_list|,
name|y
operator|*
name|iw
argument_list|)
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|mapHomogeneous
specifier|static
specifier|inline
name|QHomogeneousCoordinate
name|mapHomogeneous
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
name|QHomogeneousCoordinate
name|c
decl_stmt|;
name|c
operator|.
name|x
operator|=
name|transform
operator|.
name|m11
argument_list|()
operator|*
name|p
operator|.
name|x
argument_list|()
operator|+
name|transform
operator|.
name|m21
argument_list|()
operator|*
name|p
operator|.
name|y
argument_list|()
operator|+
name|transform
operator|.
name|m31
argument_list|()
expr_stmt|;
name|c
operator|.
name|y
operator|=
name|transform
operator|.
name|m12
argument_list|()
operator|*
name|p
operator|.
name|x
argument_list|()
operator|+
name|transform
operator|.
name|m22
argument_list|()
operator|*
name|p
operator|.
name|y
argument_list|()
operator|+
name|transform
operator|.
name|m32
argument_list|()
expr_stmt|;
name|c
operator|.
name|w
operator|=
name|transform
operator|.
name|m13
argument_list|()
operator|*
name|p
operator|.
name|x
argument_list|()
operator|+
name|transform
operator|.
name|m23
argument_list|()
operator|*
name|p
operator|.
name|y
argument_list|()
operator|+
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|lineTo_clipped
specifier|static
specifier|inline
name|bool
name|lineTo_clipped
parameter_list|(
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|a
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|b
parameter_list|,
name|bool
name|needsMoveTo
parameter_list|,
name|bool
name|needsLineTo
init|=
literal|true
parameter_list|)
block|{
name|QHomogeneousCoordinate
name|ha
init|=
name|mapHomogeneous
argument_list|(
name|transform
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|QHomogeneousCoordinate
name|hb
init|=
name|mapHomogeneous
argument_list|(
name|transform
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|ha
operator|.
name|w
operator|<
name|Q_NEAR_CLIP
operator|&&
name|hb
operator|.
name|w
operator|<
name|Q_NEAR_CLIP
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|hb
operator|.
name|w
operator|<
name|Q_NEAR_CLIP
condition|)
block|{
specifier|const
name|qreal
name|t
init|=
operator|(
name|Q_NEAR_CLIP
operator|-
name|hb
operator|.
name|w
operator|)
operator|/
operator|(
name|ha
operator|.
name|w
operator|-
name|hb
operator|.
name|w
operator|)
decl_stmt|;
name|hb
operator|.
name|x
operator|+=
operator|(
name|ha
operator|.
name|x
operator|-
name|hb
operator|.
name|x
operator|)
operator|*
name|t
expr_stmt|;
name|hb
operator|.
name|y
operator|+=
operator|(
name|ha
operator|.
name|y
operator|-
name|hb
operator|.
name|y
operator|)
operator|*
name|t
expr_stmt|;
name|hb
operator|.
name|w
operator|=
name|qreal
argument_list|(
name|Q_NEAR_CLIP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ha
operator|.
name|w
operator|<
name|Q_NEAR_CLIP
condition|)
block|{
specifier|const
name|qreal
name|t
init|=
operator|(
name|Q_NEAR_CLIP
operator|-
name|ha
operator|.
name|w
operator|)
operator|/
operator|(
name|hb
operator|.
name|w
operator|-
name|ha
operator|.
name|w
operator|)
decl_stmt|;
name|ha
operator|.
name|x
operator|+=
operator|(
name|hb
operator|.
name|x
operator|-
name|ha
operator|.
name|x
operator|)
operator|*
name|t
expr_stmt|;
name|ha
operator|.
name|y
operator|+=
operator|(
name|hb
operator|.
name|y
operator|-
name|ha
operator|.
name|y
operator|)
operator|*
name|t
expr_stmt|;
name|ha
operator|.
name|w
operator|=
name|qreal
argument_list|(
name|Q_NEAR_CLIP
argument_list|)
expr_stmt|;
specifier|const
name|QPointF
name|p
init|=
name|ha
operator|.
name|toPoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|needsMoveTo
condition|)
block|{
name|path
operator|.
name|moveTo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|needsMoveTo
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|lineTo
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needsMoveTo
condition|)
name|path
operator|.
name|moveTo
argument_list|(
name|ha
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsLineTo
condition|)
name|path
operator|.
name|lineTo
argument_list|(
name|hb
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|bool
name|qt_scaleForTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|qreal
modifier|*
name|scale
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|cubicTo_clipped
specifier|static
specifier|inline
name|bool
name|cubicTo_clipped
parameter_list|(
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|a
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|b
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|c
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|d
parameter_list|,
name|bool
name|needsMoveTo
parameter_list|)
block|{
comment|// Convert projective xformed curves to line
comment|// segments so they can be transformed more accurately
name|qreal
name|scale
decl_stmt|;
name|qt_scaleForTransform
argument_list|(
name|transform
argument_list|,
operator|&
name|scale
argument_list|)
expr_stmt|;
name|qreal
name|curveThreshold
init|=
name|scale
operator|==
literal|0
condition|?
name|qreal
argument_list|(
literal|0.25
argument_list|)
else|:
operator|(
name|qreal
argument_list|(
literal|0.25
argument_list|)
operator|/
name|scale
operator|)
decl_stmt|;
name|QPolygonF
name|segment
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
operator|.
name|toPolygon
argument_list|(
name|curveThreshold
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segment
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lineTo_clipped
argument_list|(
name|path
argument_list|,
name|transform
argument_list|,
name|segment
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|segment
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|needsMoveTo
argument_list|)
condition|)
name|needsMoveTo
operator|=
literal|false
expr_stmt|;
return|return
operator|!
name|needsMoveTo
return|;
block|}
end_function
begin_function
DECL|function|mapProjective
specifier|static
name|QPainterPath
name|mapProjective
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
name|QPainterPath
name|result
decl_stmt|;
name|QPointF
name|last
decl_stmt|;
name|QPointF
name|lastMoveTo
decl_stmt|;
name|bool
name|needsMoveTo
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|lastMoveTo
operator|!=
name|last
condition|)
name|lineTo_clipped
argument_list|(
name|result
argument_list|,
name|transform
argument_list|,
name|last
argument_list|,
name|lastMoveTo
argument_list|,
name|needsMoveTo
argument_list|)
expr_stmt|;
name|lastMoveTo
operator|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|last
operator|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|needsMoveTo
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
if|if
condition|(
name|lineTo_clipped
argument_list|(
name|result
argument_list|,
name|transform
argument_list|,
name|last
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|,
name|needsMoveTo
argument_list|)
condition|)
name|needsMoveTo
operator|=
literal|false
expr_stmt|;
name|last
operator|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
if|if
condition|(
name|cubicTo_clipped
argument_list|(
name|result
argument_list|,
name|transform
argument_list|,
name|last
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
name|needsMoveTo
argument_list|)
condition|)
name|needsMoveTo
operator|=
literal|false
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|last
operator|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
operator|.
name|elementCount
argument_list|()
operator|>
literal|0
operator|&&
name|lastMoveTo
operator|!=
name|last
condition|)
name|lineTo_clipped
argument_list|(
name|result
argument_list|,
name|transform
argument_list|,
name|last
argument_list|,
name|lastMoveTo
argument_list|,
name|needsMoveTo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|result
operator|.
name|setFillRule
argument_list|(
name|path
operator|.
name|fillRule
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath operator *(const QPainterPath&path, const QTransform&matrix)     \since 4.3     \relates QTransform      This is the same as \a{matrix}.map(\a{path}).      \sa QTransform::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QPainterPath object that is a copy of the     given \a path, mapped into the coordinate system defined by this     matrix. */
end_comment
begin_function
DECL|function|map
name|QPainterPath
name|QTransform
operator|::
name|map
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TxNone
operator|||
name|path
operator|.
name|elementCount
argument_list|()
operator|==
literal|0
condition|)
return|return
name|path
return|;
if|if
condition|(
name|t
operator|>=
name|TxProject
condition|)
return|return
name|mapProjective
argument_list|(
operator|*
name|this
argument_list|,
name|path
argument_list|)
return|;
name|QPainterPath
name|copy
init|=
name|path
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TxTranslate
condition|)
block|{
name|copy
operator|.
name|translate
argument_list|(
name|affine
operator|.
name|_dx
argument_list|,
name|affine
operator|.
name|_dy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// Full xform
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|copy
operator|.
name|d_ptr
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
name|MAP
argument_list|(
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|,
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygon QTransform::mapToPolygon(const QRect&rectangle) const      Creates and returns a QPolygon representation of the given \a     rectangle, mapped into the coordinate system defined by this     matrix.      The rectangle's coordinates are transformed using the following     formulas:      \snippet code/src_gui_painting_qtransform.cpp 1      Polygons and rectangles behave slightly differently when     transformed (due to integer rounding), so     \c{matrix.map(QPolygon(rectangle))} is not always the same as     \c{matrix.mapToPolygon(rectangle)}.      \sa mapRect(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_function
DECL|function|mapToPolygon
name|QPolygon
name|QTransform
operator|::
name|mapToPolygon
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
name|QPolygon
name|a
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|qreal
name|x
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|y
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|<=
name|TxScale
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|affine
operator|.
name|_dx
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|affine
operator|.
name|_dy
expr_stmt|;
name|qreal
name|w
init|=
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|-=
name|h
expr_stmt|;
block|}
name|x
index|[
literal|1
index|]
operator|=
name|x
index|[
literal|0
index|]
operator|+
name|w
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|x
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|y
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
name|y
index|[
literal|0
index|]
operator|+
name|h
expr_stmt|;
name|y
index|[
literal|3
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|right
init|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|right
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|bottom
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|y
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|// all coordinates are correctly, tranform to a pointarray
comment|// (rounding to the next integer)
name|a
operator|.
name|setPoints
argument_list|(
literal|4
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a transformation matrix, \a trans, that maps a unit square     to a four-sided polygon, \a quad. Returns true if the transformation     is constructed or false if such a transformation does not exist.      \sa quadToSquare(), quadToQuad() */
end_comment
begin_function
DECL|function|squareToQuad
name|bool
name|QTransform
operator|::
name|squareToQuad
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|quad
parameter_list|,
name|QTransform
modifier|&
name|trans
parameter_list|)
block|{
if|if
condition|(
name|quad
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
return|return
literal|false
return|;
name|qreal
name|dx0
init|=
name|quad
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dx1
init|=
name|quad
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dx2
init|=
name|quad
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dx3
init|=
name|quad
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dy0
init|=
name|quad
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|dy1
init|=
name|quad
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|dy2
init|=
name|quad
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|dy3
init|=
name|quad
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
decl_stmt|;
name|double
name|ax
init|=
name|dx0
operator|-
name|dx1
operator|+
name|dx2
operator|-
name|dx3
decl_stmt|;
name|double
name|ay
init|=
name|dy0
operator|-
name|dy1
operator|+
name|dy2
operator|-
name|dy3
decl_stmt|;
if|if
condition|(
operator|!
name|ax
operator|&&
operator|!
name|ay
condition|)
block|{
comment|//afine transform
name|trans
operator|.
name|setMatrix
argument_list|(
name|dx1
operator|-
name|dx0
argument_list|,
name|dy1
operator|-
name|dy0
argument_list|,
literal|0
argument_list|,
name|dx2
operator|-
name|dx1
argument_list|,
name|dy2
operator|-
name|dy1
argument_list|,
literal|0
argument_list|,
name|dx0
argument_list|,
name|dy0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|ax1
init|=
name|dx1
operator|-
name|dx2
decl_stmt|;
name|double
name|ax2
init|=
name|dx3
operator|-
name|dx2
decl_stmt|;
name|double
name|ay1
init|=
name|dy1
operator|-
name|dy2
decl_stmt|;
name|double
name|ay2
init|=
name|dy3
operator|-
name|dy2
decl_stmt|;
comment|/*determinants */
name|double
name|gtop
init|=
name|ax
operator|*
name|ay2
operator|-
name|ax2
operator|*
name|ay
decl_stmt|;
name|double
name|htop
init|=
name|ax1
operator|*
name|ay
operator|-
name|ax
operator|*
name|ay1
decl_stmt|;
name|double
name|bottom
init|=
name|ax1
operator|*
name|ay2
operator|-
name|ax2
operator|*
name|ay1
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|h
decl_stmt|;
comment|/*i is always 1*/
if|if
condition|(
operator|!
name|bottom
condition|)
return|return
literal|false
return|;
name|g
operator|=
name|gtop
operator|/
name|bottom
expr_stmt|;
name|h
operator|=
name|htop
operator|/
name|bottom
expr_stmt|;
name|a
operator|=
name|dx1
operator|-
name|dx0
operator|+
name|g
operator|*
name|dx1
expr_stmt|;
name|b
operator|=
name|dx3
operator|-
name|dx0
operator|+
name|h
operator|*
name|dx3
expr_stmt|;
name|c
operator|=
name|dx0
expr_stmt|;
name|d
operator|=
name|dy1
operator|-
name|dy0
operator|+
name|g
operator|*
name|dy1
expr_stmt|;
name|e
operator|=
name|dy3
operator|-
name|dy0
operator|+
name|h
operator|*
name|dy3
expr_stmt|;
name|f
operator|=
name|dy0
expr_stmt|;
name|trans
operator|.
name|setMatrix
argument_list|(
name|a
argument_list|,
name|d
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|e
argument_list|,
name|h
argument_list|,
name|c
argument_list|,
name|f
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTransform::quadToSquare(const QPolygonF&quad, QTransform&trans)      Creates a transformation matrix, \a trans, that maps a four-sided polygon,     \a quad, to a unit square. Returns true if the transformation is constructed     or false if such a transformation does not exist.      \sa squareToQuad(), quadToQuad() */
end_comment
begin_function
DECL|function|quadToSquare
name|bool
name|QTransform
operator|::
name|quadToSquare
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|quad
parameter_list|,
name|QTransform
modifier|&
name|trans
parameter_list|)
block|{
if|if
condition|(
operator|!
name|squareToQuad
argument_list|(
name|quad
argument_list|,
name|trans
argument_list|)
condition|)
return|return
literal|false
return|;
name|bool
name|invertible
init|=
literal|false
decl_stmt|;
name|trans
operator|=
name|trans
operator|.
name|inverted
argument_list|(
operator|&
name|invertible
argument_list|)
expr_stmt|;
return|return
name|invertible
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a transformation matrix, \a trans, that maps a four-sided     polygon, \a one, to another four-sided polygon, \a two.     Returns true if the transformation is possible; otherwise returns     false.      This is a convenience method combining quadToSquare() and     squareToQuad() methods. It allows the input quad to be     transformed into any other quad.      \sa squareToQuad(), quadToSquare() */
end_comment
begin_function
DECL|function|quadToQuad
name|bool
name|QTransform
operator|::
name|quadToQuad
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|one
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|two
parameter_list|,
name|QTransform
modifier|&
name|trans
parameter_list|)
block|{
name|QTransform
name|stq
decl_stmt|;
if|if
condition|(
operator|!
name|quadToSquare
argument_list|(
name|one
argument_list|,
name|trans
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|squareToQuad
argument_list|(
name|two
argument_list|,
name|stq
argument_list|)
condition|)
return|return
literal|false
return|;
name|trans
operator|*=
name|stq
expr_stmt|;
comment|//qDebug()<<"Final = "<<trans;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the matrix elements to the specified values, \a m11,     \a m12, \a m13 \a m21, \a m22, \a m23 \a m31, \a m32 and     \a m33. Note that this function replaces the previous values.     QTransform provides the translate(), rotate(), scale() and shear()     convenience functions to manipulate the various matrix elements     based on the currently defined coordinate system.      \sa QTransform() */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QTransform
operator|::
name|setMatrix
parameter_list|(
name|qreal
name|m11
parameter_list|,
name|qreal
name|m12
parameter_list|,
name|qreal
name|m13
parameter_list|,
name|qreal
name|m21
parameter_list|,
name|qreal
name|m22
parameter_list|,
name|qreal
name|m23
parameter_list|,
name|qreal
name|m31
parameter_list|,
name|qreal
name|m32
parameter_list|,
name|qreal
name|m33
parameter_list|)
block|{
name|affine
operator|.
name|_m11
operator|=
name|m11
expr_stmt|;
name|affine
operator|.
name|_m12
operator|=
name|m12
expr_stmt|;
name|m_13
operator|=
name|m13
expr_stmt|;
name|affine
operator|.
name|_m21
operator|=
name|m21
expr_stmt|;
name|affine
operator|.
name|_m22
operator|=
name|m22
expr_stmt|;
name|m_23
operator|=
name|m23
expr_stmt|;
name|affine
operator|.
name|_dx
operator|=
name|m31
expr_stmt|;
name|affine
operator|.
name|_dy
operator|=
name|m32
expr_stmt|;
name|m_33
operator|=
name|m33
expr_stmt|;
name|m_type
operator|=
name|TxNone
expr_stmt|;
name|m_dirty
operator|=
name|TxProject
expr_stmt|;
block|}
end_function
begin_function
DECL|function|needsPerspectiveClipping
specifier|static
specifier|inline
name|bool
name|needsPerspectiveClipping
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
specifier|const
name|qreal
name|wx
init|=
name|qMin
argument_list|(
name|transform
operator|.
name|m13
argument_list|()
operator|*
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|transform
operator|.
name|m13
argument_list|()
operator|*
name|rect
operator|.
name|right
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|wy
init|=
name|qMin
argument_list|(
name|transform
operator|.
name|m23
argument_list|()
operator|*
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|transform
operator|.
name|m23
argument_list|()
operator|*
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|wx
operator|+
name|wy
operator|+
name|transform
operator|.
name|m33
argument_list|()
operator|<
name|Q_NEAR_CLIP
return|;
block|}
end_function
begin_function
DECL|function|mapRect
name|QRect
name|QTransform
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|<=
name|TxTranslate
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|qRound
argument_list|(
name|affine
operator|.
name|_dx
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|affine
operator|.
name|_dy
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|t
operator|<=
name|TxScale
condition|)
block|{
name|int
name|x
init|=
name|qRound
argument_list|(
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|affine
operator|.
name|_dx
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|qRound
argument_list|(
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|affine
operator|.
name|_dy
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|qRound
argument_list|(
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|h
init|=
name|qRound
argument_list|(
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
return|return
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
name|TxProject
operator|||
operator|!
name|needsPerspectiveClipping
argument_list|(
name|rect
argument_list|,
operator|*
name|this
argument_list|)
condition|)
block|{
comment|// see mapToPolygon for explanations of the algorithm.
name|qreal
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|qreal
name|xmin
init|=
name|x
decl_stmt|;
name|qreal
name|ymin
init|=
name|y
decl_stmt|;
name|qreal
name|xmax
init|=
name|x
decl_stmt|;
name|qreal
name|ymax
init|=
name|y
decl_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|xmin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|ymin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|xmax
argument_list|)
operator|-
name|qRound
argument_list|(
name|xmin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|ymax
argument_list|)
operator|-
name|qRound
argument_list|(
name|ymin
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return
name|map
argument_list|(
name|path
argument_list|)
operator|.
name|boundingRect
argument_list|()
operator|.
name|toRect
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QTransform::mapRect(const QRectF&rectangle) const      Creates and returns a QRectF object that is a copy of the given \a     rectangle, mapped into the coordinate system defined by this     matrix.      The rectangle's coordinates are transformed using the following     formulas:      \snippet code/src_gui_painting_qtransform.cpp 2      If rotation or shearing has been specified, this function returns     the \e bounding rectangle. To retrieve the exact region the given     \a rectangle maps to, use the mapToPolygon() function instead.      \sa mapToPolygon(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_function
DECL|function|mapRect
name|QRectF
name|QTransform
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|<=
name|TxTranslate
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|affine
operator|.
name|_dx
argument_list|,
name|affine
operator|.
name|_dy
argument_list|)
return|;
if|if
condition|(
name|t
operator|<=
name|TxScale
condition|)
block|{
name|qreal
name|x
init|=
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|affine
operator|.
name|_dx
decl_stmt|;
name|qreal
name|y
init|=
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|affine
operator|.
name|_dy
decl_stmt|;
name|qreal
name|w
init|=
name|affine
operator|.
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|affine
operator|.
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
return|return
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
name|TxProject
operator|||
operator|!
name|needsPerspectiveClipping
argument_list|(
name|rect
argument_list|,
operator|*
name|this
argument_list|)
condition|)
block|{
name|qreal
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|qreal
name|xmin
init|=
name|x
decl_stmt|;
name|qreal
name|ymin
init|=
name|y
decl_stmt|;
name|qreal
name|xmax
init|=
name|x
decl_stmt|;
name|qreal
name|ymax
init|=
name|y
decl_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|(
name|xmin
argument_list|,
name|ymin
argument_list|,
name|xmax
operator|-
name|xmin
argument_list|,
name|ymax
operator|-
name|ymin
argument_list|)
return|;
block|}
else|else
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return
name|map
argument_list|(
name|path
argument_list|)
operator|.
name|boundingRect
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QRect QTransform::mapRect(const QRect&rectangle) const     \overload      Creates and returns a QRect object that is a copy of the given \a     rectangle, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_comment
comment|/*!     Maps the given coordinates \a x and \a y into the coordinate     system defined by this matrix. The resulting values are put in *\a     tx and *\a ty, respectively.      The coordinates are transformed using the following formulas:      \snippet code/src_gui_painting_qtransform.cpp 3      The point (x, y) is the original point, and (x', y') is the     transformed point.      \sa {QTransform#Basic Matrix Operations}{Basic Matrix Operations} */
end_comment
begin_function
DECL|function|map
name|void
name|QTransform
operator|::
name|map
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
modifier|*
name|tx
parameter_list|,
name|qreal
modifier|*
name|ty
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
name|MAP
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|*
name|tx
argument_list|,
operator|*
name|ty
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Maps the given coordinates \a x and \a y into the coordinate     system defined by this matrix. The resulting values are put in *\a     tx and *\a ty, respectively. Note that the transformed coordinates     are rounded to the nearest integer. */
end_comment
begin_function
DECL|function|map
name|void
name|QTransform
operator|::
name|map
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|ty
parameter_list|)
specifier|const
block|{
name|TransformationType
name|t
init|=
name|inline_type
argument_list|()
decl_stmt|;
name|qreal
name|fx
init|=
literal|0
decl_stmt|,
name|fy
init|=
literal|0
decl_stmt|;
name|MAP
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|fx
argument_list|,
name|fy
argument_list|)
expr_stmt|;
operator|*
name|tx
operator|=
name|qRound
argument_list|(
name|fx
argument_list|)
expr_stmt|;
operator|*
name|ty
operator|=
name|qRound
argument_list|(
name|fy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the QTransform as an affine matrix.    \warning If a perspective transformation has been specified,   then the conversion will cause loss of data. */
end_comment
begin_function
DECL|function|toAffine
specifier|const
name|QMatrix
modifier|&
name|QTransform
operator|::
name|toAffine
parameter_list|()
specifier|const
block|{
return|return
name|affine
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the transformation type of this matrix.    The transformation type is the highest enumeration value   capturing all of the matrix's transformations. For example,   if the matrix both scales and shears, the type would be \c TxShear,   because \c TxShear has a higher enumeration value than \c TxScale.    Knowing the transformation type of a matrix is useful for optimization:   you can often handle specific types more optimally than handling   the generic case.   */
end_comment
begin_function
DECL|function|type
name|QTransform
operator|::
name|TransformationType
name|QTransform
operator|::
name|type
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_dirty
operator|==
name|TxNone
operator|||
name|m_dirty
operator|<
name|m_type
condition|)
return|return
cast|static_cast
argument_list|<
name|TransformationType
argument_list|>
argument_list|(
name|m_type
argument_list|)
return|;
switch|switch
condition|(
cast|static_cast
argument_list|<
name|TransformationType
argument_list|>
argument_list|(
name|m_dirty
argument_list|)
condition|)
block|{
case|case
name|TxProject
case|:
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|m_13
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|m_23
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|m_33
operator|-
literal|1
argument_list|)
condition|)
block|{
name|m_type
operator|=
name|TxProject
expr_stmt|;
break|break;
block|}
case|case
name|TxShear
case|:
case|case
name|TxRotate
case|:
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m12
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m21
argument_list|)
condition|)
block|{
specifier|const
name|qreal
name|dot
init|=
name|affine
operator|.
name|_m11
operator|*
name|affine
operator|.
name|_m12
operator|+
name|affine
operator|.
name|_m21
operator|*
name|affine
operator|.
name|_m22
decl_stmt|;
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|dot
argument_list|)
condition|)
name|m_type
operator|=
name|TxRotate
expr_stmt|;
else|else
name|m_type
operator|=
name|TxShear
expr_stmt|;
break|break;
block|}
case|case
name|TxScale
case|:
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m11
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_m22
operator|-
literal|1
argument_list|)
condition|)
block|{
name|m_type
operator|=
name|TxScale
expr_stmt|;
break|break;
block|}
case|case
name|TxTranslate
case|:
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_dx
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|affine
operator|.
name|_dy
argument_list|)
condition|)
block|{
name|m_type
operator|=
name|TxTranslate
expr_stmt|;
break|break;
block|}
case|case
name|TxNone
case|:
name|m_type
operator|=
name|TxNone
expr_stmt|;
break|break;
block|}
name|m_dirty
operator|=
name|TxNone
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|TransformationType
argument_list|>
argument_list|(
name|m_type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      Returns the transform as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QTransform
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Transform
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTransform::isInvertible() const      Returns true if the matrix is invertible, otherwise returns false.      \sa inverted() */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::det() const     \obsolete      Returns the matrix's determinant. Use determinant() instead. */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m11() const      Returns the horizontal scaling factor.      \sa scale(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m12() const      Returns the vertical shearing factor.      \sa shear(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m21() const      Returns the horizontal shearing factor.      \sa shear(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m22() const      Returns the vertical scaling factor.      \sa scale(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::dx() const      Returns the horizontal translation factor.      \sa m31(), translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::dy() const      Returns the vertical translation factor.      \sa translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m13() const      Returns the horizontal projection factor.      \sa translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m23() const      Returns the vertical projection factor.      \sa translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m31() const      Returns the horizontal translation factor.      \sa dx(), translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m32() const      Returns the vertical translation factor.      \sa dy(), translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::m33() const      Returns the division factor.      \sa translate(), {QTransform#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QTransform::determinant() const      Returns the matrix's determinant. */
end_comment
begin_comment
comment|/*!     \fn bool QTransform::isIdentity() const      Returns true if the matrix is the identity matrix, otherwise     returns false.      \sa reset() */
end_comment
begin_comment
comment|/*!     \fn bool QTransform::isAffine() const      Returns true if the matrix represent an affine transformation,     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTransform::isScaling() const      Returns true if the matrix represents a scaling     transformation, otherwise returns false.      \sa reset() */
end_comment
begin_comment
comment|/*!     \fn bool QTransform::isRotating() const      Returns true if the matrix represents some kind of a     rotating transformation, otherwise returns false.      \note A rotation transformation of 180 degrees and/or 360 degrees is treated as a scaling transformation.      \sa reset() */
end_comment
begin_comment
comment|/*!     \fn bool QTransform::isTranslating() const      Returns true if the matrix represents a translating     transformation, otherwise returns false.      \sa reset() */
end_comment
begin_comment
comment|/*!     \fn bool qFuzzyCompare(const QTransform& t1, const QTransform& t2)      \relates QTransform     \since 4.6      Returns true if \a t1 and \a t2 are equal, allowing for a small     fuzziness factor for floating-point comparisons; false otherwise. */
end_comment
begin_comment
comment|// returns true if the transform is uniformly scaling
end_comment
begin_comment
comment|// (same scale in x and y direction)
end_comment
begin_comment
comment|// scale is set to the max of x and y scaling factors
end_comment
begin_function
name|Q_GUI_EXPORT
DECL|function|qt_scaleForTransform
name|bool
name|qt_scaleForTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|qreal
modifier|*
name|scale
parameter_list|)
block|{
specifier|const
name|QTransform
operator|::
name|TransformationType
name|type
init|=
name|transform
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
if|if
condition|(
name|scale
condition|)
operator|*
name|scale
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|qreal
name|xScale
init|=
name|qAbs
argument_list|(
name|transform
operator|.
name|m11
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|yScale
init|=
name|qAbs
argument_list|(
name|transform
operator|.
name|m22
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scale
condition|)
operator|*
name|scale
operator|=
name|qMax
argument_list|(
name|xScale
argument_list|,
name|yScale
argument_list|)
expr_stmt|;
return|return
name|qFuzzyCompare
argument_list|(
name|xScale
argument_list|,
name|yScale
argument_list|)
return|;
block|}
comment|// rotate then scale: compare columns
specifier|const
name|qreal
name|xScale1
init|=
name|transform
operator|.
name|m11
argument_list|()
operator|*
name|transform
operator|.
name|m11
argument_list|()
operator|+
name|transform
operator|.
name|m21
argument_list|()
operator|*
name|transform
operator|.
name|m21
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|yScale1
init|=
name|transform
operator|.
name|m12
argument_list|()
operator|*
name|transform
operator|.
name|m12
argument_list|()
operator|+
name|transform
operator|.
name|m22
argument_list|()
operator|*
name|transform
operator|.
name|m22
argument_list|()
decl_stmt|;
comment|// scale then rotate: compare rows
specifier|const
name|qreal
name|xScale2
init|=
name|transform
operator|.
name|m11
argument_list|()
operator|*
name|transform
operator|.
name|m11
argument_list|()
operator|+
name|transform
operator|.
name|m12
argument_list|()
operator|*
name|transform
operator|.
name|m12
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|yScale2
init|=
name|transform
operator|.
name|m21
argument_list|()
operator|*
name|transform
operator|.
name|m21
argument_list|()
operator|+
name|transform
operator|.
name|m22
argument_list|()
operator|*
name|transform
operator|.
name|m22
argument_list|()
decl_stmt|;
comment|// decide the order of rotate and scale operations
if|if
condition|(
name|qAbs
argument_list|(
name|xScale1
operator|-
name|yScale1
argument_list|)
operator|>
name|qAbs
argument_list|(
name|xScale2
operator|-
name|yScale2
argument_list|)
condition|)
block|{
if|if
condition|(
name|scale
condition|)
operator|*
name|scale
operator|=
name|qSqrt
argument_list|(
name|qMax
argument_list|(
name|xScale1
argument_list|,
name|yScale1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
operator|==
name|QTransform
operator|::
name|TxRotate
operator|&&
name|qFuzzyCompare
argument_list|(
name|xScale1
argument_list|,
name|yScale1
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|scale
condition|)
operator|*
name|scale
operator|=
name|qSqrt
argument_list|(
name|qMax
argument_list|(
name|xScale2
argument_list|,
name|yScale2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
operator|==
name|QTransform
operator|::
name|TxRotate
operator|&&
name|qFuzzyCompare
argument_list|(
name|xScale2
argument_list|,
name|yScale2
argument_list|)
return|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
