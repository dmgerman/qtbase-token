begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"private/qstroker_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qbezier_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qmath_p.h"
end_include
begin_include
include|#
directive|include
file|"qline.h"
end_include
begin_include
include|#
directive|include
file|"qtransform.h"
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// #define QPP_STROKE_DEBUG
end_comment
begin_class
DECL|class|QSubpathForwardIterator
class|class
name|QSubpathForwardIterator
block|{
public|public:
DECL|function|QSubpathForwardIterator
name|QSubpathForwardIterator
parameter_list|(
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|path
parameter_list|)
member_init_list|:
name|m_path
argument_list|(
name|path
argument_list|)
member_init_list|,
name|m_pos
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|position
specifier|inline
name|int
name|position
parameter_list|()
specifier|const
block|{
return|return
name|m_pos
return|;
block|}
DECL|function|hasNext
specifier|inline
name|bool
name|hasNext
parameter_list|()
specifier|const
block|{
return|return
name|m_pos
operator|<
name|m_path
operator|->
name|size
argument_list|()
return|;
block|}
DECL|function|next
specifier|inline
name|QStrokerOps
operator|::
name|Element
name|next
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|++
argument_list|)
return|;
block|}
private|private:
DECL|member|m_path
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|m_path
decl_stmt|;
DECL|member|m_pos
name|int
name|m_pos
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QSubpathBackwardIterator
class|class
name|QSubpathBackwardIterator
block|{
public|public:
DECL|function|QSubpathBackwardIterator
name|QSubpathBackwardIterator
parameter_list|(
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|path
parameter_list|)
member_init_list|:
name|m_path
argument_list|(
name|path
argument_list|)
member_init_list|,
name|m_pos
argument_list|(
name|path
operator|->
name|size
argument_list|()
operator|-
literal|1
argument_list|)
block|{ }
DECL|function|position
specifier|inline
name|int
name|position
parameter_list|()
specifier|const
block|{
return|return
name|m_pos
return|;
block|}
DECL|function|hasNext
specifier|inline
name|bool
name|hasNext
parameter_list|()
specifier|const
block|{
return|return
name|m_pos
operator|>=
literal|0
return|;
block|}
DECL|function|next
specifier|inline
name|QStrokerOps
operator|::
name|Element
name|next
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|QStrokerOps
operator|::
name|Element
name|ce
init|=
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
argument_list|)
decl_stmt|;
comment|// current element
if|if
condition|(
name|m_pos
operator|==
name|m_path
operator|->
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
operator|--
name|m_pos
expr_stmt|;
name|ce
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|MoveToElement
expr_stmt|;
return|return
name|ce
return|;
block|}
specifier|const
name|QStrokerOps
operator|::
name|Element
modifier|&
name|pe
init|=
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// previous element
switch|switch
condition|(
name|pe
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|ce
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|LineToElement
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
comment|// First control point?
if|if
condition|(
name|ce
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|CurveToElement
condition|)
block|{
name|ce
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|CurveToDataElement
expr_stmt|;
block|}
else|else
block|{
comment|// Second control point then
name|ce
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|CurveToElement
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
name|ce
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|CurveToDataElement
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QSubpathReverseIterator::next: Case %d unhandled"
argument_list|,
name|ce
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|m_pos
expr_stmt|;
return|return
name|ce
return|;
block|}
private|private:
DECL|member|m_path
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|m_path
decl_stmt|;
DECL|member|m_pos
name|int
name|m_pos
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QSubpathFlatIterator
class|class
name|QSubpathFlatIterator
block|{
public|public:
DECL|function|QSubpathFlatIterator
name|QSubpathFlatIterator
parameter_list|(
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|path
parameter_list|,
name|qreal
name|threshold
parameter_list|)
member_init_list|:
name|m_path
argument_list|(
name|path
argument_list|)
member_init_list|,
name|m_pos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_curve_index
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|m_curve_threshold
argument_list|(
name|threshold
argument_list|)
block|{ }
DECL|function|hasNext
specifier|inline
name|bool
name|hasNext
parameter_list|()
specifier|const
block|{
return|return
name|m_curve_index
operator|>=
literal|0
operator|||
name|m_pos
operator|<
name|m_path
operator|->
name|size
argument_list|()
return|;
block|}
DECL|function|next
name|QStrokerOps
operator|::
name|Element
name|next
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_curve_index
operator|>=
literal|0
condition|)
block|{
name|QStrokerOps
operator|::
name|Element
name|e
init|=
block|{
name|QPainterPath
operator|::
name|LineToElement
block|,
name|qt_real_to_fixed
argument_list|(
name|m_curve
operator|.
name|at
argument_list|(
name|m_curve_index
argument_list|)
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|qt_real_to_fixed
argument_list|(
argument|m_curve.at(m_curve_index).y()
argument_list|)
block|}
decl_stmt|;
operator|++
name|m_curve_index
expr_stmt|;
if|if
condition|(
name|m_curve_index
operator|>=
name|m_curve
operator|.
name|size
argument_list|()
condition|)
name|m_curve_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
name|QStrokerOps
operator|::
name|Element
name|e
init|=
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isCurveTo
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|m_pos
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_pos
operator|<
name|m_path
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_curve
operator|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|-
literal|1
argument_list|)
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|-
literal|1
argument_list|)
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|+
literal|1
argument_list|)
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|+
literal|1
argument_list|)
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|+
literal|2
argument_list|)
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_path
operator|->
name|at
argument_list|(
name|m_pos
operator|+
literal|2
argument_list|)
operator|.
name|y
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toPolygon
argument_list|(
name|m_curve_threshold
argument_list|)
expr_stmt|;
name|m_curve_index
operator|=
literal|1
expr_stmt|;
name|e
operator|.
name|type
operator|=
name|QPainterPath
operator|::
name|LineToElement
expr_stmt|;
name|e
operator|.
name|x
operator|=
name|m_curve
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|e
operator|.
name|y
operator|=
name|m_curve
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_pos
operator|+=
literal|2
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|e
operator|.
name|isLineTo
argument_list|()
operator|||
name|e
operator|.
name|isMoveTo
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|m_pos
expr_stmt|;
return|return
name|e
return|;
block|}
private|private:
DECL|member|m_path
specifier|const
name|QDataBuffer
argument_list|<
name|QStrokerOps
operator|::
name|Element
argument_list|>
modifier|*
name|m_path
decl_stmt|;
DECL|member|m_pos
name|int
name|m_pos
decl_stmt|;
DECL|member|m_curve
name|QPolygonF
name|m_curve
decl_stmt|;
DECL|member|m_curve_index
name|int
name|m_curve_index
decl_stmt|;
DECL|member|m_curve_threshold
name|qreal
name|m_curve_threshold
decl_stmt|;
block|}
class|;
end_class
begin_function_decl
template|template
parameter_list|<
name|class
name|Iterator
parameter_list|>
name|bool
name|qt_stroke_side
parameter_list|(
name|Iterator
modifier|*
name|it
parameter_list|,
name|QStroker
modifier|*
name|stroker
parameter_list|,
name|bool
name|capFirst
parameter_list|,
name|QLineF
modifier|*
name|startTangent
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*******************************************************************************  * QLineF::angle gives us the smalles angle between two lines. Here we  * want to identify the line's angle direction on the unit circle.  */
end_comment
begin_function
DECL|function|adapted_angle_on_x
specifier|static
specifier|inline
name|qreal
name|adapted_angle_on_x
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|qreal
name|angle
init|=
name|line
operator|.
name|angle
argument_list|(
name|QLineF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|dy
argument_list|()
operator|>
literal|0
condition|)
name|angle
operator|=
literal|360
operator|-
name|angle
expr_stmt|;
return|return
name|angle
return|;
block|}
end_function
begin_constructor
DECL|function|QStrokerOps
name|QStrokerOps
operator|::
name|QStrokerOps
parameter_list|()
member_init_list|:
name|m_elements
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_curveThreshold
argument_list|(
name|qt_real_to_fixed
argument_list|(
literal|0.25
argument_list|)
argument_list|)
member_init_list|,
name|m_dashThreshold
argument_list|(
name|qt_real_to_fixed
argument_list|(
literal|0.25
argument_list|)
argument_list|)
member_init_list|,
name|m_customData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_moveTo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_lineTo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_cubicTo
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QStrokerOps
name|QStrokerOps
operator|::
name|~
name|QStrokerOps
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Prepares the stroker. Call this function once before starting a     stroke by calling moveTo, lineTo or cubicTo.      The \a customData is passed back through that callback functions     and can be used by the user to for instance maintain state     information. */
end_comment
begin_function
DECL|function|begin
name|void
name|QStrokerOps
operator|::
name|begin
parameter_list|(
name|void
modifier|*
name|customData
parameter_list|)
block|{
name|m_customData
operator|=
name|customData
expr_stmt|;
name|m_elements
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Finishes the stroke. Call this function once when an entire     primitive has been stroked. */
end_comment
begin_function
DECL|function|end
name|void
name|QStrokerOps
operator|::
name|end
parameter_list|()
block|{
if|if
condition|(
name|m_elements
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|processCurrentSubpath
argument_list|()
expr_stmt|;
name|m_customData
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Convenience function that decomposes \a path into begin(),     moveTo(), lineTo(), curevTo() and end() calls.      The \a customData parameter is used in the callback functions      The \a matrix is used to transform the points before input to the     stroker.      \sa begin() */
end_comment
begin_function
DECL|function|strokePath
name|void
name|QStrokerOps
operator|::
name|strokePath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|void
modifier|*
name|customData
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|setCurveThresholdFromTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|begin
argument_list|(
name|customData
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|matrix
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
name|moveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|cp2
init|=
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|ep
init|=
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
name|cubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|x
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|y
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|x
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QPointF
name|pt
init|=
name|QPointF
argument_list|(
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
operator|*
name|matrix
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
name|moveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|QPointF
name|cp2
init|=
operator|(
operator|(
name|QPointF
operator|)
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
operator|)
operator|*
name|matrix
decl_stmt|;
name|QPointF
name|ep
init|=
operator|(
operator|(
name|QPointF
operator|)
name|path
operator|.
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
operator|)
operator|*
name|matrix
decl_stmt|;
name|cubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Convenience function for stroking a polygon of the \a pointCount     first points in \a points. If \a implicit_close is set to true a     line is implictly drawn between the first and last point in the     polygon. Typically true for polygons and false for polylines.      The \a matrix is used to transform the points before they enter the     stroker.      \sa begin() */
end_comment
begin_function
DECL|function|strokePolygon
name|void
name|QStrokerOps
operator|::
name|strokePolygon
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|bool
name|implicit_close
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pointCount
condition|)
return|return;
name|setCurveThresholdFromTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|begin
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|matrix
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
name|moveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_close
condition|)
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|start
init|=
name|points
index|[
literal|0
index|]
operator|*
name|matrix
decl_stmt|;
name|moveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pt
init|=
name|points
index|[
name|i
index|]
operator|*
name|matrix
decl_stmt|;
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|implicit_close
condition|)
name|lineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Convenience function for stroking an ellipse with bounding rect \a     rect. The \a matrix is used to transform the coordinates before     they enter the stroker. */
end_comment
begin_function
DECL|function|strokeEllipse
name|void
name|QStrokerOps
operator|::
name|strokeEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|QPointF
name|pts
index|[
literal|12
index|]
decl_stmt|;
name|QPointF
name|start
init|=
name|qt_curves_for_arc
argument_list|(
name|rect
argument_list|,
literal|0
argument_list|,
operator|-
literal|360
argument_list|,
name|pts
argument_list|,
operator|&
name|count
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|count
operator|==
literal|12
argument_list|)
expr_stmt|;
comment|// a perfect circle..
if|if
condition|(
operator|!
name|matrix
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
name|start
operator|=
name|start
operator|*
name|matrix
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
name|pts
index|[
name|i
index|]
operator|=
name|pts
index|[
name|i
index|]
operator|*
name|matrix
expr_stmt|;
block|}
block|}
name|setCurveThresholdFromTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|begin
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|moveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|start
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|cubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pts
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QStroker
name|QStroker
operator|::
name|QStroker
parameter_list|()
member_init_list|:
name|m_capStyle
argument_list|(
name|SquareJoin
argument_list|)
member_init_list|,
name|m_joinStyle
argument_list|(
name|FlatJoin
argument_list|)
member_init_list|,
name|m_back1X
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_back1Y
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_back2X
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_back2Y
argument_list|(
literal|0
argument_list|)
block|{
name|m_strokeWidth
operator|=
name|qt_real_to_fixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|m_miterLimit
operator|=
name|qt_real_to_fixed
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QStroker
name|QStroker
operator|::
name|~
name|QStroker
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|capForJoinMode
name|Qt
operator|::
name|PenCapStyle
name|QStroker
operator|::
name|capForJoinMode
parameter_list|(
name|LineJoinMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|FlatJoin
condition|)
return|return
name|Qt
operator|::
name|FlatCap
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SquareJoin
condition|)
return|return
name|Qt
operator|::
name|SquareCap
return|;
else|else
return|return
name|Qt
operator|::
name|RoundCap
return|;
block|}
end_function
begin_function
DECL|function|joinModeForCap
name|QStroker
operator|::
name|LineJoinMode
name|QStroker
operator|::
name|joinModeForCap
parameter_list|(
name|Qt
operator|::
name|PenCapStyle
name|style
parameter_list|)
block|{
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|FlatCap
condition|)
return|return
name|FlatJoin
return|;
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|SquareCap
condition|)
return|return
name|SquareJoin
return|;
else|else
return|return
name|RoundCap
return|;
block|}
end_function
begin_function
DECL|function|joinForJoinMode
name|Qt
operator|::
name|PenJoinStyle
name|QStroker
operator|::
name|joinForJoinMode
parameter_list|(
name|LineJoinMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|FlatJoin
condition|)
return|return
name|Qt
operator|::
name|BevelJoin
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|MiterJoin
condition|)
return|return
name|Qt
operator|::
name|MiterJoin
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SvgMiterJoin
condition|)
return|return
name|Qt
operator|::
name|SvgMiterJoin
return|;
else|else
return|return
name|Qt
operator|::
name|RoundJoin
return|;
block|}
end_function
begin_function
DECL|function|joinModeForJoin
name|QStroker
operator|::
name|LineJoinMode
name|QStroker
operator|::
name|joinModeForJoin
parameter_list|(
name|Qt
operator|::
name|PenJoinStyle
name|joinStyle
parameter_list|)
block|{
if|if
condition|(
name|joinStyle
operator|==
name|Qt
operator|::
name|BevelJoin
condition|)
return|return
name|FlatJoin
return|;
elseif|else
if|if
condition|(
name|joinStyle
operator|==
name|Qt
operator|::
name|MiterJoin
condition|)
return|return
name|MiterJoin
return|;
elseif|else
if|if
condition|(
name|joinStyle
operator|==
name|Qt
operator|::
name|SvgMiterJoin
condition|)
return|return
name|SvgMiterJoin
return|;
else|else
return|return
name|RoundJoin
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called to stroke the currently built up     subpath. The subpath is cleared when the function completes. */
end_comment
begin_function
DECL|function|processCurrentSubpath
name|void
name|QStroker
operator|::
name|processCurrentSubpath
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_elements
operator|.
name|first
argument_list|()
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|MoveToElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_elements
operator|.
name|size
argument_list|()
operator|>
literal|1
argument_list|)
expr_stmt|;
name|QSubpathForwardIterator
name|fwit
argument_list|(
operator|&
name|m_elements
argument_list|)
decl_stmt|;
name|QSubpathBackwardIterator
name|bwit
argument_list|(
operator|&
name|m_elements
argument_list|)
decl_stmt|;
name|QLineF
name|fwStartTangent
decl_stmt|,
name|bwStartTangent
decl_stmt|;
name|bool
name|fwclosed
init|=
name|qt_stroke_side
argument_list|(
operator|&
name|fwit
argument_list|,
name|this
argument_list|,
literal|false
argument_list|,
operator|&
name|fwStartTangent
argument_list|)
decl_stmt|;
name|bool
name|bwclosed
init|=
name|qt_stroke_side
argument_list|(
operator|&
name|bwit
argument_list|,
name|this
argument_list|,
operator|!
name|fwclosed
argument_list|,
operator|&
name|bwStartTangent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bwclosed
condition|)
name|joinPoints
argument_list|(
name|m_elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
argument_list|,
name|m_elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
argument_list|,
name|fwStartTangent
argument_list|,
name|m_capStyle
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|joinPoints
name|void
name|QStroker
operator|::
name|joinPoints
parameter_list|(
name|qfixed
name|focal_x
parameter_list|,
name|qfixed
name|focal_y
parameter_list|,
specifier|const
name|QLineF
modifier|&
name|nextLine
parameter_list|,
name|LineJoinMode
name|join
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|printf
argument_list|(
literal|" -----> joinPoints: around=(%.0f, %.0f), next_p1=(%.0f, %.f) next_p2=(%.0f, %.f)\n"
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|focal_x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|focal_y
argument_list|)
argument_list|,
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|,
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|,
name|nextLine
operator|.
name|x2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|y2
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// points connected already, don't join
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QFIXED_26_6
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_FIXED_32_32
argument_list|)
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|m_back1X
argument_list|,
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|m_back1Y
argument_list|,
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|m_back1X
operator|==
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
operator|&&
name|m_back1Y
operator|==
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|join
operator|==
name|FlatJoin
condition|)
block|{
name|QLineF
name|prevLine
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_back2X
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back2Y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back1X
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back1Y
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|isect
decl_stmt|;
name|QLineF
operator|::
name|IntersectType
name|type
init|=
name|prevLine
operator|.
name|intersect
argument_list|(
name|nextLine
argument_list|,
operator|&
name|isect
argument_list|)
decl_stmt|;
name|QLineF
name|shortCut
argument_list|(
name|prevLine
operator|.
name|p2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|angle
init|=
name|shortCut
operator|.
name|angleTo
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|BoundedIntersection
operator|||
operator|(
name|angle
operator|>
literal|90
operator|&&
operator|!
name|qFuzzyCompare
argument_list|(
name|angle
argument_list|,
operator|(
name|qreal
operator|)
literal|90
argument_list|)
operator|)
condition|)
block|{
name|emitLineTo
argument_list|(
name|focal_x
argument_list|,
name|focal_y
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QLineF
name|prevLine
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_back2X
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back2Y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back1X
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back1Y
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|isect
decl_stmt|;
name|QLineF
operator|::
name|IntersectType
name|type
init|=
name|prevLine
operator|.
name|intersect
argument_list|(
name|nextLine
argument_list|,
operator|&
name|isect
argument_list|)
decl_stmt|;
if|if
condition|(
name|join
operator|==
name|MiterJoin
condition|)
block|{
name|qreal
name|appliedMiterLimit
init|=
name|qt_fixed_to_real
argument_list|(
name|m_strokeWidth
operator|*
name|m_miterLimit
argument_list|)
decl_stmt|;
comment|// If we are on the inside, do the short cut...
name|QLineF
name|shortCut
argument_list|(
name|prevLine
operator|.
name|p2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|angle
init|=
name|shortCut
operator|.
name|angleTo
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|BoundedIntersection
operator|||
operator|(
name|angle
operator|>
literal|90
operator|&&
operator|!
name|qFuzzyCompare
argument_list|(
name|angle
argument_list|,
operator|(
name|qreal
operator|)
literal|90
argument_list|)
operator|)
condition|)
block|{
name|emitLineTo
argument_list|(
name|focal_x
argument_list|,
name|focal_y
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QLineF
name|miterLine
argument_list|(
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|m_back1X
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|m_back1Y
argument_list|)
argument_list|)
argument_list|,
name|isect
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|NoIntersection
operator|||
name|miterLine
operator|.
name|length
argument_list|()
operator|>
name|appliedMiterLimit
condition|)
block|{
name|QLineF
name|l1
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
name|l1
operator|.
name|setLength
argument_list|(
name|appliedMiterLimit
argument_list|)
expr_stmt|;
name|l1
operator|.
name|translate
argument_list|(
name|prevLine
operator|.
name|dx
argument_list|()
argument_list|,
name|prevLine
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|QLineF
name|l2
argument_list|(
name|nextLine
argument_list|)
decl_stmt|;
name|l2
operator|.
name|setLength
argument_list|(
name|appliedMiterLimit
argument_list|)
expr_stmt|;
name|l2
operator|.
name|translate
argument_list|(
operator|-
name|l2
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|l2
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|isect
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|isect
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|join
operator|==
name|SquareJoin
condition|)
block|{
name|qfixed
name|offset
init|=
name|m_strokeWidth
operator|/
literal|2
decl_stmt|;
name|QLineF
name|l1
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
name|l1
operator|.
name|translate
argument_list|(
name|l1
operator|.
name|dx
argument_list|()
argument_list|,
name|l1
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|l1
operator|.
name|setLength
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|QLineF
name|l2
argument_list|(
name|nextLine
operator|.
name|p2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|l2
operator|.
name|translate
argument_list|(
name|l2
operator|.
name|dx
argument_list|()
argument_list|,
name|l2
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|l2
operator|.
name|setLength
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|join
operator|==
name|RoundJoin
condition|)
block|{
name|qfixed
name|offset
init|=
name|m_strokeWidth
operator|/
literal|2
decl_stmt|;
name|QLineF
name|shortCut
argument_list|(
name|prevLine
operator|.
name|p2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|angle
init|=
name|shortCut
operator|.
name|angleTo
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|BoundedIntersection
operator|||
operator|(
name|angle
operator|>
literal|90
operator|&&
operator|!
name|qFuzzyCompare
argument_list|(
name|angle
argument_list|,
operator|(
name|qreal
operator|)
literal|90
argument_list|)
operator|)
condition|)
block|{
name|emitLineTo
argument_list|(
name|focal_x
argument_list|,
name|focal_y
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|qreal
name|l1_on_x
init|=
name|adapted_angle_on_x
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
name|qreal
name|l2_on_x
init|=
name|adapted_angle_on_x
argument_list|(
name|nextLine
argument_list|)
decl_stmt|;
name|qreal
name|sweepLength
init|=
name|qAbs
argument_list|(
name|l2_on_x
operator|-
name|l1_on_x
argument_list|)
decl_stmt|;
name|int
name|point_count
decl_stmt|;
name|QPointF
name|curves
index|[
literal|15
index|]
decl_stmt|;
name|QPointF
name|curve_start
init|=
name|qt_curves_for_arc
argument_list|(
name|QRectF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|focal_x
operator|-
name|offset
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|focal_y
operator|-
name|offset
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|)
argument_list|,
name|l1_on_x
operator|+
literal|90
argument_list|,
operator|-
name|sweepLength
argument_list|,
name|curves
argument_list|,
operator|&
name|point_count
argument_list|)
decl_stmt|;
comment|//             // line to the beginning of the arc segment, (should not be needed).
comment|//             emitLineTo(qt_real_to_fixed(curve_start.x()), qt_real_to_fixed(curve_start.y()));
name|Q_UNUSED
argument_list|(
name|curve_start
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|point_count
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|emitCubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|curves
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// line to the end of the arc segment, (should also not be needed).
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Same as round join except we know its 180 degrees. Can also optimize this
comment|// later based on the addEllipse logic
block|}
elseif|else
if|if
condition|(
name|join
operator|==
name|RoundCap
condition|)
block|{
name|qfixed
name|offset
init|=
name|m_strokeWidth
operator|/
literal|2
decl_stmt|;
comment|// first control line
name|QLineF
name|l1
init|=
name|prevLine
decl_stmt|;
name|l1
operator|.
name|translate
argument_list|(
name|l1
operator|.
name|dx
argument_list|()
argument_list|,
name|l1
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|l1
operator|.
name|setLength
argument_list|(
name|QT_PATH_KAPPA
operator|*
name|offset
argument_list|)
expr_stmt|;
comment|// second control line, find through normal between prevLine and focal.
name|QLineF
name|l2
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|focal_x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|focal_y
argument_list|)
argument_list|,
name|prevLine
operator|.
name|x2
argument_list|()
argument_list|,
name|prevLine
operator|.
name|y2
argument_list|()
argument_list|)
decl_stmt|;
name|l2
operator|.
name|translate
argument_list|(
operator|-
name|l2
operator|.
name|dy
argument_list|()
argument_list|,
name|l2
operator|.
name|dx
argument_list|()
argument_list|)
expr_stmt|;
name|l2
operator|.
name|setLength
argument_list|(
name|QT_PATH_KAPPA
operator|*
name|offset
argument_list|)
expr_stmt|;
name|emitCubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// move so that it matches
name|l2
operator|=
name|QLineF
argument_list|(
name|l2
operator|.
name|x1
argument_list|()
argument_list|,
name|l2
operator|.
name|y1
argument_list|()
argument_list|,
name|l2
operator|.
name|x1
argument_list|()
operator|-
name|l2
operator|.
name|dx
argument_list|()
argument_list|,
name|l2
operator|.
name|y1
argument_list|()
operator|-
name|l2
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
comment|// last line is parallel to l1 so just shift it down.
name|l1
operator|.
name|translate
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
operator|-
name|l1
operator|.
name|x1
argument_list|()
argument_list|,
name|nextLine
operator|.
name|y1
argument_list|()
operator|-
name|l1
operator|.
name|y1
argument_list|()
argument_list|)
expr_stmt|;
name|emitCubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l2
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|l1
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|join
operator|==
name|SvgMiterJoin
condition|)
block|{
name|QLineF
name|shortCut
argument_list|(
name|prevLine
operator|.
name|p2
argument_list|()
argument_list|,
name|nextLine
operator|.
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|angle
init|=
name|shortCut
operator|.
name|angleTo
argument_list|(
name|prevLine
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|BoundedIntersection
operator|||
operator|(
name|angle
operator|>
literal|90
operator|&&
operator|!
name|qFuzzyCompare
argument_list|(
name|angle
argument_list|,
operator|(
name|qreal
operator|)
literal|90
argument_list|)
operator|)
condition|)
block|{
name|emitLineTo
argument_list|(
name|focal_x
argument_list|,
name|focal_y
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QLineF
name|miterLine
argument_list|(
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|focal_x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|focal_y
argument_list|)
argument_list|)
argument_list|,
name|isect
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QLineF
operator|::
name|NoIntersection
operator|||
name|miterLine
operator|.
name|length
argument_list|()
operator|>
name|qt_fixed_to_real
argument_list|(
name|m_strokeWidth
operator|*
name|m_miterLimit
argument_list|)
operator|/
literal|2
condition|)
block|{
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|isect
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|isect
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|nextLine
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
literal|"QStroker::joinPoints(), bad join style..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*    Strokes a subpath side using the \a it as source. Results are put into    \a stroke. The function returns true if the subpath side was closed.    If \a capFirst is true, we will use capPoints instead of joinPoints to    connect the first segment, other segments will be joined using joinPoints.    This is to put capping in order... */
end_comment
begin_function
DECL|function|qt_stroke_side
template|template
parameter_list|<
name|class
name|Iterator
parameter_list|>
name|bool
name|qt_stroke_side
parameter_list|(
name|Iterator
modifier|*
name|it
parameter_list|,
name|QStroker
modifier|*
name|stroker
parameter_list|,
name|bool
name|capFirst
parameter_list|,
name|QLineF
modifier|*
name|startTangent
parameter_list|)
block|{
comment|// Used in CurveToElement section below.
specifier|const
name|int
name|MAX_OFFSET
init|=
literal|16
decl_stmt|;
name|QBezier
name|offsetCurves
index|[
name|MAX_OFFSET
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|it
operator|->
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|// The initaial move to
name|QStrokerOps
operator|::
name|Element
name|first_element
init|=
name|it
operator|->
name|next
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|first_element
operator|.
name|isMoveTo
argument_list|()
argument_list|)
expr_stmt|;
name|qfixed2d
name|start
init|=
name|first_element
decl_stmt|;
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|qDebug
argument_list|(
literal|" -> (side) [%.2f, %.2f], startPos=%d"
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|start
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|start
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qfixed2d
name|prev
init|=
name|start
decl_stmt|;
name|bool
name|first
init|=
literal|true
decl_stmt|;
name|qfixed
name|offset
init|=
name|stroker
operator|->
name|strokeWidth
argument_list|()
operator|/
literal|2
decl_stmt|;
while|while
condition|(
name|it
operator|->
name|hasNext
argument_list|()
condition|)
block|{
name|QStrokerOps
operator|::
name|Element
name|e
init|=
name|it
operator|->
name|next
argument_list|()
decl_stmt|;
comment|// LineToElement
if|if
condition|(
name|e
operator|.
name|isLineTo
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|qDebug
argument_list|(
literal|"\n ---> (side) lineto [%.2f, %.2f]"
argument_list|,
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QLineF
name|line
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|p1
argument_list|()
operator|!=
name|line
operator|.
name|p2
argument_list|()
condition|)
block|{
name|QLineF
name|normal
init|=
name|line
operator|.
name|normalVector
argument_list|()
decl_stmt|;
name|normal
operator|.
name|setLength
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|line
operator|.
name|translate
argument_list|(
name|normal
operator|.
name|dx
argument_list|()
argument_list|,
name|normal
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
comment|// If we are starting a new subpath, move to correct starting point.
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|capFirst
condition|)
name|stroker
operator|->
name|joinPoints
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
name|line
argument_list|,
name|stroker
operator|->
name|capStyleMode
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|stroker
operator|->
name|emitMoveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|line
operator|.
name|x1
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|line
operator|.
name|y1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|startTangent
operator|=
name|line
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|stroker
operator|->
name|joinPoints
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
name|line
argument_list|,
name|stroker
operator|->
name|joinStyleMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add the stroke for this line.
name|stroker
operator|->
name|emitLineTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|line
operator|.
name|x2
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|line
operator|.
name|y2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|e
expr_stmt|;
block|}
comment|// CurveToElement
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|isCurveTo
argument_list|()
condition|)
block|{
name|QStrokerOps
operator|::
name|Element
name|cp2
init|=
name|it
operator|->
name|next
argument_list|()
decl_stmt|;
comment|// control point 2
name|QStrokerOps
operator|::
name|Element
name|ep
init|=
name|it
operator|->
name|next
argument_list|()
decl_stmt|;
comment|// end point
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|qDebug
argument_list|(
literal|"\n ---> (side) cubicTo [%.2f, %.2f]"
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|ep
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|ep
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QBezier
name|bezier
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|cp2
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|cp2
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|ep
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|ep
operator|.
name|y
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|bezier
operator|.
name|shifted
argument_list|(
name|offsetCurves
argument_list|,
name|MAX_OFFSET
argument_list|,
name|offset
argument_list|,
name|stroker
operator|->
name|curveThreshold
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
comment|// If we are starting a new subpath, move to correct starting point
name|QLineF
name|tangent
init|=
name|bezier
operator|.
name|startTangent
argument_list|()
decl_stmt|;
name|tangent
operator|.
name|translate
argument_list|(
name|offsetCurves
index|[
literal|0
index|]
operator|.
name|pt1
argument_list|()
operator|-
name|bezier
operator|.
name|pt1
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|QPointF
name|pt
init|=
name|offsetCurves
index|[
literal|0
index|]
operator|.
name|pt1
argument_list|()
decl_stmt|;
if|if
condition|(
name|capFirst
condition|)
block|{
name|stroker
operator|->
name|joinPoints
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
name|tangent
argument_list|,
name|stroker
operator|->
name|capStyleMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stroker
operator|->
name|emitMoveTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|startTangent
operator|=
name|tangent
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|stroker
operator|->
name|joinPoints
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
name|tangent
argument_list|,
name|stroker
operator|->
name|joinStyleMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add these beziers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|cp1
init|=
name|offsetCurves
index|[
name|i
index|]
operator|.
name|pt2
argument_list|()
decl_stmt|;
name|QPointF
name|cp2
init|=
name|offsetCurves
index|[
name|i
index|]
operator|.
name|pt3
argument_list|()
decl_stmt|;
name|QPointF
name|ep
init|=
name|offsetCurves
index|[
name|i
index|]
operator|.
name|pt4
argument_list|()
decl_stmt|;
name|stroker
operator|->
name|emitCubicTo
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|cp1
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp1
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|cp2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qt_real_to_fixed
argument_list|(
name|ep
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|ep
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|==
name|prev
condition|)
block|{
comment|// closed subpath, join first and last point
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|qDebug
argument_list|(
literal|"\n ---> (side) closed subpath"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// don't join empty subpaths
if|if
condition|(
operator|!
name|first
condition|)
name|stroker
operator|->
name|joinPoints
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
operator|*
name|startTangent
argument_list|,
name|stroker
operator|->
name|joinStyleMode
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QPP_STROKE_DEBUG
name|qDebug
argument_list|(
literal|"\n ---> (side) open subpath"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      For a given angle in the range [0 .. 90], finds the corresponding parameter t     of the prototype cubic bezier arc segment     b = fromPoints(QPointF(1, 0), QPointF(1, KAPPA), QPointF(KAPPA, 1), QPointF(0, 1));      From the bezier equation:     b.pointAt(t).x() = (1-t)^3 + t*(1-t)^2 + t^2*(1-t)*KAPPA     b.pointAt(t).y() = t*(1-t)^2 * KAPPA + t^2*(1-t) + t^3      Third degree coefficients:     b.pointAt(t).x() = at^3 + bt^2 + ct + d     where a = 2-3*KAPPA, b = 3*(KAPPA-1), c = 0, d = 1      b.pointAt(t).y() = at^3 + bt^2 + ct + d     where a = 3*KAPPA-2, b = 6*KAPPA+3, c = 3*KAPPA, d = 0      Newton's method to find the zero of a function:     given a function f(x) and initial guess x_0     x_1 = f(x_0) / f'(x_0)     x_2 = f(x_1) / f'(x_1)     etc... */
end_comment
begin_function
DECL|function|qt_t_for_arc_angle
name|qreal
name|qt_t_for_arc_angle
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|angle
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|angle
argument_list|,
name|qreal
argument_list|(
literal|90
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|qreal
name|radians
init|=
name|Q_PI
operator|*
name|angle
operator|/
literal|180
decl_stmt|;
name|qreal
name|cosAngle
init|=
name|qCos
argument_list|(
name|radians
argument_list|)
decl_stmt|;
name|qreal
name|sinAngle
init|=
name|qSin
argument_list|(
name|radians
argument_list|)
decl_stmt|;
comment|// initial guess
name|qreal
name|tc
init|=
name|angle
operator|/
literal|90
decl_stmt|;
comment|// do some iterations of newton's method to approximate cosAngle
comment|// finds the zero of the function b.pointAt(tc).x() - cosAngle
name|tc
operator|-=
operator|(
operator|(
operator|(
operator|(
literal|2
operator|-
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|tc
operator|+
literal|3
operator|*
operator|(
name|QT_PATH_KAPPA
operator|-
literal|1
operator|)
operator|)
operator|*
name|tc
operator|)
operator|*
name|tc
operator|+
literal|1
operator|-
name|cosAngle
operator|)
comment|// value
operator|/
operator|(
operator|(
operator|(
literal|6
operator|-
literal|9
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|tc
operator|+
literal|6
operator|*
operator|(
name|QT_PATH_KAPPA
operator|-
literal|1
operator|)
operator|)
operator|*
name|tc
operator|)
expr_stmt|;
comment|// derivative
name|tc
operator|-=
operator|(
operator|(
operator|(
operator|(
literal|2
operator|-
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|tc
operator|+
literal|3
operator|*
operator|(
name|QT_PATH_KAPPA
operator|-
literal|1
operator|)
operator|)
operator|*
name|tc
operator|)
operator|*
name|tc
operator|+
literal|1
operator|-
name|cosAngle
operator|)
comment|// value
operator|/
operator|(
operator|(
operator|(
literal|6
operator|-
literal|9
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|tc
operator|+
literal|6
operator|*
operator|(
name|QT_PATH_KAPPA
operator|-
literal|1
operator|)
operator|)
operator|*
name|tc
operator|)
expr_stmt|;
comment|// derivative
comment|// initial guess
name|qreal
name|ts
init|=
name|tc
decl_stmt|;
comment|// do some iterations of newton's method to approximate sinAngle
comment|// finds the zero of the function b.pointAt(tc).y() - sinAngle
name|ts
operator|-=
operator|(
operator|(
operator|(
operator|(
literal|3
operator|*
name|QT_PATH_KAPPA
operator|-
literal|2
operator|)
operator|*
name|ts
operator|-
literal|6
operator|*
name|QT_PATH_KAPPA
operator|+
literal|3
operator|)
operator|*
name|ts
operator|+
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|ts
operator|-
name|sinAngle
operator|)
operator|/
operator|(
operator|(
operator|(
literal|9
operator|*
name|QT_PATH_KAPPA
operator|-
literal|6
operator|)
operator|*
name|ts
operator|+
literal|12
operator|*
name|QT_PATH_KAPPA
operator|-
literal|6
operator|)
operator|*
name|ts
operator|+
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
expr_stmt|;
name|ts
operator|-=
operator|(
operator|(
operator|(
operator|(
literal|3
operator|*
name|QT_PATH_KAPPA
operator|-
literal|2
operator|)
operator|*
name|ts
operator|-
literal|6
operator|*
name|QT_PATH_KAPPA
operator|+
literal|3
operator|)
operator|*
name|ts
operator|+
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
operator|*
name|ts
operator|-
name|sinAngle
operator|)
operator|/
operator|(
operator|(
operator|(
literal|9
operator|*
name|QT_PATH_KAPPA
operator|-
literal|6
operator|)
operator|*
name|ts
operator|+
literal|12
operator|*
name|QT_PATH_KAPPA
operator|-
literal|6
operator|)
operator|*
name|ts
operator|+
literal|3
operator|*
name|QT_PATH_KAPPA
operator|)
expr_stmt|;
comment|// use the average of the t that best approximates cosAngle
comment|// and the t that best approximates sinAngle
name|qreal
name|t
init|=
literal|0.5
operator|*
operator|(
name|tc
operator|+
name|ts
operator|)
decl_stmt|;
if|#
directive|if
literal|0
block|printf("angle: %f, t: %f\n", angle, t);     qreal a, b, c, d;     bezierCoefficients(t, a, b, c, d);     printf("cosAngle: %.10f, value: %.10f\n", cosAngle, a + b + c * QT_PATH_KAPPA);     printf("sinAngle: %.10f, value: %.10f\n", sinAngle, b * QT_PATH_KAPPA + c + d);
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|void
name|qt_find_ellipse_coords
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|qreal
name|angle
parameter_list|,
name|qreal
name|length
parameter_list|,
name|QPointF
modifier|*
name|startPoint
parameter_list|,
name|QPointF
modifier|*
name|endPoint
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     \internal      Creates a number of curves for a given arc definition. The arc is     defined an arc along the ellipses that fits into \a rect starting     at \a startAngle and an arc length of \a sweepLength.      The function has three out parameters. The return value is the     starting point of the arc. The \a curves array represents the list     of cubicTo elements up to a maximum of \a point_count. There are of course     3 points pr curve. */
end_comment
begin_function
DECL|function|qt_curves_for_arc
name|QPointF
name|qt_curves_for_arc
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|startAngle
parameter_list|,
name|qreal
name|sweepLength
parameter_list|,
name|QPointF
modifier|*
name|curves
parameter_list|,
name|int
modifier|*
name|point_count
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|point_count
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|curves
argument_list|)
expr_stmt|;
operator|*
name|point_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qt_is_nan
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|)
operator|||
name|qt_is_nan
argument_list|(
name|rect
operator|.
name|y
argument_list|()
argument_list|)
operator|||
name|qt_is_nan
argument_list|(
name|rect
operator|.
name|width
argument_list|()
argument_list|)
operator|||
name|qt_is_nan
argument_list|(
name|rect
operator|.
name|height
argument_list|()
argument_list|)
operator|||
name|qt_is_nan
argument_list|(
name|startAngle
argument_list|)
operator|||
name|qt_is_nan
argument_list|(
name|sweepLength
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainterPath::arcTo: Adding arc where a parameter is NaN, results are undefined"
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|()
return|;
block|}
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
block|{
return|return
name|QPointF
argument_list|()
return|;
block|}
name|qreal
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|w2
init|=
name|rect
operator|.
name|width
argument_list|()
operator|/
literal|2
decl_stmt|;
name|qreal
name|w2k
init|=
name|w2
operator|*
name|QT_PATH_KAPPA
decl_stmt|;
name|qreal
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|h2
init|=
name|rect
operator|.
name|height
argument_list|()
operator|/
literal|2
decl_stmt|;
name|qreal
name|h2k
init|=
name|h2
operator|*
name|QT_PATH_KAPPA
decl_stmt|;
name|QPointF
name|points
index|[
literal|16
index|]
init|=
block|{
comment|// start point
name|QPointF
argument_list|(
name|x
operator|+
name|w
argument_list|,
name|y
operator|+
name|h2
argument_list|)
block|,
comment|// 0 -> 270 degrees
name|QPointF
argument_list|(
name|x
operator|+
name|w
argument_list|,
name|y
operator|+
name|h2
operator|+
name|h2k
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
operator|+
name|w2
operator|+
name|w2k
argument_list|,
name|y
operator|+
name|h
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
operator|+
name|w2
argument_list|,
name|y
operator|+
name|h
argument_list|)
block|,
comment|// 270 -> 180 degrees
name|QPointF
argument_list|(
name|x
operator|+
name|w2
operator|-
name|w2k
argument_list|,
name|y
operator|+
name|h
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h2
operator|+
name|h2k
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h2
argument_list|)
block|,
comment|// 180 -> 90 degrees
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h2
operator|-
name|h2k
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
operator|+
name|w2
operator|-
name|w2k
argument_list|,
name|y
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
operator|+
name|w2
argument_list|,
name|y
argument_list|)
block|,
comment|// 90 -> 0 degrees
name|QPointF
argument_list|(
name|x
operator|+
name|w2
operator|+
name|w2k
argument_list|,
name|y
argument_list|)
block|,
name|QPointF
argument_list|(
name|x
operator|+
name|w
argument_list|,
name|y
operator|+
name|h2
operator|-
name|h2k
argument_list|)
block|,
name|QPointF
argument_list|(
argument|x + w
argument_list|,
argument|y + h2
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|sweepLength
operator|>
literal|360
condition|)
name|sweepLength
operator|=
literal|360
expr_stmt|;
elseif|else
if|if
condition|(
name|sweepLength
operator|<
operator|-
literal|360
condition|)
name|sweepLength
operator|=
operator|-
literal|360
expr_stmt|;
comment|// Special case fast paths
if|if
condition|(
name|startAngle
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|sweepLength
operator|==
literal|360.0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|11
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|curves
index|[
operator|(
operator|*
name|point_count
operator|)
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
return|return
name|points
index|[
literal|12
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|sweepLength
operator|==
operator|-
literal|360.0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
name|curves
index|[
operator|(
operator|*
name|point_count
operator|)
operator|++
index|]
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
return|return
name|points
index|[
literal|0
index|]
return|;
block|}
block|}
name|int
name|startSegment
init|=
name|int
argument_list|(
name|qFloor
argument_list|(
name|startAngle
operator|/
literal|90
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endSegment
init|=
name|int
argument_list|(
name|qFloor
argument_list|(
operator|(
name|startAngle
operator|+
name|sweepLength
operator|)
operator|/
literal|90
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|startT
init|=
operator|(
name|startAngle
operator|-
name|startSegment
operator|*
literal|90
operator|)
operator|/
literal|90
decl_stmt|;
name|qreal
name|endT
init|=
operator|(
name|startAngle
operator|+
name|sweepLength
operator|-
name|endSegment
operator|*
literal|90
operator|)
operator|/
literal|90
decl_stmt|;
name|int
name|delta
init|=
name|sweepLength
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|startT
operator|=
literal|1
operator|-
name|startT
expr_stmt|;
name|endT
operator|=
literal|1
operator|-
name|endT
expr_stmt|;
block|}
comment|// avoid empty start segment
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|startT
operator|-
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|startT
operator|=
literal|0
expr_stmt|;
name|startSegment
operator|+=
name|delta
expr_stmt|;
block|}
comment|// avoid empty end segment
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|endT
argument_list|)
condition|)
block|{
name|endT
operator|=
literal|1
expr_stmt|;
name|endSegment
operator|-=
name|delta
expr_stmt|;
block|}
name|startT
operator|=
name|qt_t_for_arc_angle
argument_list|(
name|startT
operator|*
literal|90
argument_list|)
expr_stmt|;
name|endT
operator|=
name|qt_t_for_arc_angle
argument_list|(
name|endT
operator|*
literal|90
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|splitAtStart
init|=
operator|!
name|qFuzzyIsNull
argument_list|(
name|startT
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|splitAtEnd
init|=
operator|!
name|qFuzzyIsNull
argument_list|(
name|endT
operator|-
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|end
init|=
name|endSegment
operator|+
name|delta
decl_stmt|;
comment|// empty arc?
if|if
condition|(
name|startSegment
operator|==
name|end
condition|)
block|{
specifier|const
name|int
name|quadrant
init|=
literal|3
operator|-
operator|(
operator|(
name|startSegment
operator|%
literal|4
operator|)
operator|+
literal|4
operator|)
operator|%
literal|4
decl_stmt|;
specifier|const
name|int
name|j
init|=
literal|3
operator|*
name|quadrant
decl_stmt|;
return|return
name|delta
operator|>
literal|0
condition|?
name|points
index|[
name|j
operator|+
literal|3
index|]
else|:
name|points
index|[
name|j
index|]
return|;
block|}
name|QPointF
name|startPoint
decl_stmt|,
name|endPoint
decl_stmt|;
name|qt_find_ellipse_coords
argument_list|(
name|rect
argument_list|,
name|startAngle
argument_list|,
name|sweepLength
argument_list|,
operator|&
name|startPoint
argument_list|,
operator|&
name|endPoint
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startSegment
init|;
name|i
operator|!=
name|end
condition|;
name|i
operator|+=
name|delta
control|)
block|{
specifier|const
name|int
name|quadrant
init|=
literal|3
operator|-
operator|(
operator|(
name|i
operator|%
literal|4
operator|)
operator|+
literal|4
operator|)
operator|%
literal|4
decl_stmt|;
specifier|const
name|int
name|j
init|=
literal|3
operator|*
name|quadrant
decl_stmt|;
name|QBezier
name|b
decl_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|b
operator|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|points
index|[
name|j
operator|+
literal|3
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|points
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|points
index|[
name|j
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|points
index|[
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
comment|// empty arc?
if|if
condition|(
name|startSegment
operator|==
name|endSegment
operator|&&
name|qFuzzyCompare
argument_list|(
name|startT
argument_list|,
name|endT
argument_list|)
condition|)
return|return
name|startPoint
return|;
if|if
condition|(
name|i
operator|==
name|startSegment
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|endSegment
operator|&&
name|splitAtEnd
condition|)
name|b
operator|=
name|b
operator|.
name|bezierOnInterval
argument_list|(
name|startT
argument_list|,
name|endT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|splitAtStart
condition|)
name|b
operator|=
name|b
operator|.
name|bezierOnInterval
argument_list|(
name|startT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|endSegment
operator|&&
name|splitAtEnd
condition|)
block|{
name|b
operator|=
name|b
operator|.
name|bezierOnInterval
argument_list|(
literal|0
argument_list|,
name|endT
argument_list|)
expr_stmt|;
block|}
comment|// push control points
name|curves
index|[
operator|(
operator|*
name|point_count
operator|)
operator|++
index|]
operator|=
name|b
operator|.
name|pt2
argument_list|()
expr_stmt|;
name|curves
index|[
operator|(
operator|*
name|point_count
operator|)
operator|++
index|]
operator|=
name|b
operator|.
name|pt3
argument_list|()
expr_stmt|;
name|curves
index|[
operator|(
operator|*
name|point_count
operator|)
operator|++
index|]
operator|=
name|b
operator|.
name|pt4
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|*
name|point_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|curves
index|[
operator|*
operator|(
name|point_count
operator|)
operator|-
literal|1
index|]
operator|=
name|endPoint
expr_stmt|;
return|return
name|startPoint
return|;
block|}
end_function
begin_function
DECL|function|qdashstroker_moveTo
specifier|static
specifier|inline
name|void
name|qdashstroker_moveTo
parameter_list|(
name|qfixed
name|x
parameter_list|,
name|qfixed
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QStroker
operator|*
operator|)
name|data
operator|)
operator|->
name|moveTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qdashstroker_lineTo
specifier|static
specifier|inline
name|void
name|qdashstroker_lineTo
parameter_list|(
name|qfixed
name|x
parameter_list|,
name|qfixed
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QStroker
operator|*
operator|)
name|data
operator|)
operator|->
name|lineTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qdashstroker_cubicTo
specifier|static
specifier|inline
name|void
name|qdashstroker_cubicTo
parameter_list|(
name|qfixed
parameter_list|,
name|qfixed
parameter_list|,
name|qfixed
parameter_list|,
name|qfixed
parameter_list|,
name|qfixed
parameter_list|,
name|qfixed
parameter_list|,
name|void
modifier|*
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//     ((QStroker *) data)->cubicTo(c1x, c1y, c2x, c2y, ex, ey);
block|}
end_function
begin_comment
comment|/*******************************************************************************  * QDashStroker members  */
end_comment
begin_constructor
DECL|function|QDashStroker
name|QDashStroker
operator|::
name|QDashStroker
parameter_list|(
name|QStroker
modifier|*
name|stroker
parameter_list|)
member_init_list|:
name|m_stroker
argument_list|(
name|stroker
argument_list|)
member_init_list|,
name|m_dashOffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_stroke_width
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|m_miter_limit
argument_list|(
literal|1
argument_list|)
block|{
if|if
condition|(
name|m_stroker
condition|)
block|{
name|setMoveToHook
argument_list|(
name|qdashstroker_moveTo
argument_list|)
expr_stmt|;
name|setLineToHook
argument_list|(
name|qdashstroker_lineTo
argument_list|)
expr_stmt|;
name|setCubicToHook
argument_list|(
name|qdashstroker_cubicTo
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QDashStroker
name|QDashStroker
operator|::
name|~
name|QDashStroker
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|patternForStyle
name|QVector
argument_list|<
name|qfixed
argument_list|>
name|QDashStroker
operator|::
name|patternForStyle
parameter_list|(
name|Qt
operator|::
name|PenStyle
name|style
parameter_list|)
block|{
specifier|const
name|qfixed
name|space
init|=
literal|2
decl_stmt|;
specifier|const
name|qfixed
name|dot
init|=
literal|1
decl_stmt|;
specifier|const
name|qfixed
name|dash
init|=
literal|4
decl_stmt|;
name|QVector
argument_list|<
name|qfixed
argument_list|>
name|pattern
decl_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|DashLine
case|:
name|pattern
operator|<<
name|dash
operator|<<
name|space
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|DotLine
case|:
name|pattern
operator|<<
name|dot
operator|<<
name|space
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|DashDotLine
case|:
name|pattern
operator|<<
name|dash
operator|<<
name|space
operator|<<
name|dot
operator|<<
name|space
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|DashDotDotLine
case|:
name|pattern
operator|<<
name|dash
operator|<<
name|space
operator|<<
name|dot
operator|<<
name|space
operator|<<
name|dot
operator|<<
name|space
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|pattern
return|;
block|}
end_function
begin_function
DECL|function|lineRectIntersectsRect
specifier|static
specifier|inline
name|bool
name|lineRectIntersectsRect
parameter_list|(
name|qfixed2d
name|p1
parameter_list|,
name|qfixed2d
name|p2
parameter_list|,
specifier|const
name|qfixed2d
modifier|&
name|tl
parameter_list|,
specifier|const
name|qfixed2d
modifier|&
name|br
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p1
operator|.
name|x
operator|>
name|tl
operator|.
name|x
operator|||
name|p2
operator|.
name|x
operator|>
name|tl
operator|.
name|x
operator|)
operator|&&
operator|(
name|p1
operator|.
name|x
operator|<
name|br
operator|.
name|x
operator|||
name|p2
operator|.
name|x
operator|<
name|br
operator|.
name|x
operator|)
operator|&&
operator|(
name|p1
operator|.
name|y
operator|>
name|tl
operator|.
name|y
operator|||
name|p2
operator|.
name|y
operator|>
name|tl
operator|.
name|y
operator|)
operator|&&
operator|(
name|p1
operator|.
name|y
operator|<
name|br
operator|.
name|y
operator|||
name|p2
operator|.
name|y
operator|<
name|br
operator|.
name|y
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|// If the line intersects the rectangle, this function will return true.
end_comment
begin_function
DECL|function|lineIntersectsRect
specifier|static
name|bool
name|lineIntersectsRect
parameter_list|(
name|qfixed2d
name|p1
parameter_list|,
name|qfixed2d
name|p2
parameter_list|,
specifier|const
name|qfixed2d
modifier|&
name|tl
parameter_list|,
specifier|const
name|qfixed2d
modifier|&
name|br
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lineRectIntersectsRect
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tl
argument_list|,
name|br
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|p1
operator|.
name|x
operator|==
name|p2
operator|.
name|x
operator|||
name|p1
operator|.
name|y
operator|==
name|p2
operator|.
name|y
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|p1
operator|.
name|y
operator|>
name|p2
operator|.
name|y
condition|)
name|qSwap
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|// make p1 above p2
name|qfixed2d
name|u
decl_stmt|;
name|qfixed2d
name|v
decl_stmt|;
name|qfixed2d
name|w
init|=
block|{
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
block|,
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
block|}
decl_stmt|;
if|if
condition|(
name|p1
operator|.
name|x
operator|<
name|p2
operator|.
name|x
condition|)
block|{
comment|// backslash
name|u
operator|.
name|x
operator|=
name|tl
operator|.
name|x
operator|-
name|p1
operator|.
name|x
expr_stmt|;
name|u
operator|.
name|y
operator|=
name|br
operator|.
name|y
operator|-
name|p1
operator|.
name|y
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|br
operator|.
name|x
operator|-
name|p1
operator|.
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|tl
operator|.
name|y
operator|-
name|p1
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
comment|// slash
name|u
operator|.
name|x
operator|=
name|tl
operator|.
name|x
operator|-
name|p1
operator|.
name|x
expr_stmt|;
name|u
operator|.
name|y
operator|=
name|tl
operator|.
name|y
operator|-
name|p1
operator|.
name|y
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|br
operator|.
name|x
operator|-
name|p1
operator|.
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|br
operator|.
name|y
operator|-
name|p1
operator|.
name|y
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QFIXED_IS_26_6
argument_list|)
operator|||
name|defined
argument_list|(
name|QFIXED_IS_16_16
argument_list|)
name|qint64
name|val1
init|=
name|qint64
argument_list|(
name|u
operator|.
name|x
argument_list|)
operator|*
name|qint64
argument_list|(
name|w
operator|.
name|y
argument_list|)
operator|-
name|qint64
argument_list|(
name|u
operator|.
name|y
argument_list|)
operator|*
name|qint64
argument_list|(
name|w
operator|.
name|x
argument_list|)
decl_stmt|;
name|qint64
name|val2
init|=
name|qint64
argument_list|(
name|v
operator|.
name|x
argument_list|)
operator|*
name|qint64
argument_list|(
name|w
operator|.
name|y
argument_list|)
operator|-
name|qint64
argument_list|(
name|v
operator|.
name|y
argument_list|)
operator|*
name|qint64
argument_list|(
name|w
operator|.
name|x
argument_list|)
decl_stmt|;
return|return
operator|(
name|val1
argument_list|<
literal|0
operator|&&
name|val2
argument_list|>
literal|0
operator|)
operator|||
operator|(
name|val1
operator|>
literal|0
operator|&&
name|val2
operator|<
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|QFIXED_IS_32_32
argument_list|)
comment|// Cannot do proper test because it may overflow.
return|return
literal|true
return|;
else|#
directive|else
name|qreal
name|val1
init|=
name|u
operator|.
name|x
operator|*
name|w
operator|.
name|y
operator|-
name|u
operator|.
name|y
operator|*
name|w
operator|.
name|x
decl_stmt|;
name|qreal
name|val2
init|=
name|v
operator|.
name|x
operator|*
name|w
operator|.
name|y
operator|-
name|v
operator|.
name|y
operator|*
name|w
operator|.
name|x
decl_stmt|;
return|return
operator|(
name|val1
argument_list|<
literal|0
operator|&&
name|val2
argument_list|>
literal|0
operator|)
operator|||
operator|(
name|val1
operator|>
literal|0
operator|&&
name|val2
operator|<
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processCurrentSubpath
name|void
name|QDashStroker
operator|::
name|processCurrentSubpath
parameter_list|()
block|{
name|int
name|dashCount
init|=
name|qMin
argument_list|(
name|m_dashPattern
operator|.
name|size
argument_list|()
argument_list|,
literal|32
argument_list|)
decl_stmt|;
name|qfixed
name|dashes
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|m_stroker
condition|)
block|{
name|m_customData
operator|=
name|m_stroker
expr_stmt|;
name|m_stroke_width
operator|=
name|m_stroker
operator|->
name|strokeWidth
argument_list|()
expr_stmt|;
name|m_miter_limit
operator|=
name|m_stroker
operator|->
name|miterLimit
argument_list|()
expr_stmt|;
block|}
name|qreal
name|longestLength
init|=
literal|0
decl_stmt|;
name|qreal
name|sumLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dashCount
condition|;
operator|++
name|i
control|)
block|{
name|dashes
index|[
name|i
index|]
operator|=
name|qMax
argument_list|(
name|m_dashPattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|*
name|m_stroke_width
expr_stmt|;
name|sumLength
operator|+=
name|dashes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dashes
index|[
name|i
index|]
operator|>
name|longestLength
condition|)
name|longestLength
operator|=
name|dashes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|sumLength
argument_list|)
condition|)
return|return;
name|qreal
name|invSumLength
init|=
name|qreal
argument_list|(
literal|1
argument_list|)
operator|/
name|sumLength
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dashCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dashCount
operator|=
name|dashCount
operator|&
operator|-
literal|2
expr_stmt|;
comment|// Round down to even number
name|int
name|idash
init|=
literal|0
decl_stmt|;
comment|// Index to current dash
name|qreal
name|pos
init|=
literal|0
decl_stmt|;
comment|// The position on the curve, 0<= pos<= path.length
name|qreal
name|elen
init|=
literal|0
decl_stmt|;
comment|// element length
name|qreal
name|doffset
init|=
name|m_dashOffset
operator|*
name|m_stroke_width
decl_stmt|;
comment|// make sure doffset is in range [0..sumLength)
name|doffset
operator|-=
name|qFloor
argument_list|(
name|doffset
operator|*
name|invSumLength
argument_list|)
operator|*
name|sumLength
expr_stmt|;
while|while
condition|(
name|doffset
operator|>=
name|dashes
index|[
name|idash
index|]
condition|)
block|{
name|doffset
operator|-=
name|dashes
index|[
name|idash
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|idash
operator|>=
name|dashCount
condition|)
name|idash
operator|=
literal|0
expr_stmt|;
block|}
name|qreal
name|estart
init|=
literal|0
decl_stmt|;
comment|// The elements starting position
name|qreal
name|estop
init|=
literal|0
decl_stmt|;
comment|// The element stop position
name|QLineF
name|cline
decl_stmt|;
name|QPainterPath
name|dashPath
decl_stmt|;
name|QSubpathFlatIterator
name|it
argument_list|(
operator|&
name|m_elements
argument_list|,
name|m_dashThreshold
argument_list|)
decl_stmt|;
name|qfixed2d
name|prev
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|bool
name|clipping
init|=
operator|!
name|m_clip_rect
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|qfixed2d
name|move_to_pos
init|=
name|prev
decl_stmt|;
name|qfixed2d
name|line_to_pos
decl_stmt|;
comment|// Pad to avoid clipping the borders of thick pens.
name|qfixed
name|padding
init|=
name|qt_real_to_fixed
argument_list|(
name|qMax
argument_list|(
name|m_stroke_width
argument_list|,
name|m_miter_limit
argument_list|)
operator|*
name|longestLength
argument_list|)
decl_stmt|;
name|qfixed2d
name|clip_tl
init|=
block|{
name|qt_real_to_fixed
argument_list|(
name|m_clip_rect
operator|.
name|left
argument_list|()
argument_list|)
operator|-
name|padding
block|,
name|qt_real_to_fixed
argument_list|(
name|m_clip_rect
operator|.
name|top
argument_list|()
argument_list|)
operator|-
name|padding
block|}
decl_stmt|;
name|qfixed2d
name|clip_br
init|=
block|{
name|qt_real_to_fixed
argument_list|(
name|m_clip_rect
operator|.
name|right
argument_list|()
argument_list|)
operator|+
name|padding
block|,
name|qt_real_to_fixed
argument_list|(
name|m_clip_rect
operator|.
name|bottom
argument_list|()
argument_list|)
operator|+
name|padding
block|}
decl_stmt|;
name|bool
name|hasMoveTo
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QStrokerOps
operator|::
name|Element
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|e
operator|.
name|isLineTo
argument_list|()
argument_list|)
expr_stmt|;
name|cline
operator|=
name|QLineF
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|prev
operator|.
name|y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|e
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|elen
operator|=
name|cline
operator|.
name|length
argument_list|()
expr_stmt|;
name|estop
operator|=
name|estart
operator|+
name|elen
expr_stmt|;
name|bool
name|done
init|=
name|pos
operator|>=
name|estop
decl_stmt|;
if|if
condition|(
name|clipping
condition|)
block|{
comment|// Check if the entire line can be clipped away.
if|if
condition|(
operator|!
name|lineIntersectsRect
argument_list|(
name|prev
argument_list|,
name|e
argument_list|,
name|clip_tl
argument_list|,
name|clip_br
argument_list|)
condition|)
block|{
comment|// Cut away full dash sequences.
name|elen
operator|-=
name|qFloor
argument_list|(
name|elen
operator|*
name|invSumLength
argument_list|)
operator|*
name|sumLength
expr_stmt|;
comment|// Update dash offset.
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|qreal
name|dpos
init|=
name|pos
operator|+
name|dashes
index|[
name|idash
index|]
operator|-
name|doffset
operator|-
name|estart
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dpos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpos
operator|>
name|elen
condition|)
block|{
comment|// dash extends this line
name|doffset
operator|=
name|dashes
index|[
name|idash
index|]
operator|-
operator|(
name|dpos
operator|-
name|elen
operator|)
expr_stmt|;
comment|// subtract the part already used
name|pos
operator|=
name|estop
expr_stmt|;
comment|// move pos to next path element
name|done
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Dash is on this line
name|pos
operator|=
name|dpos
operator|+
name|estart
expr_stmt|;
name|done
operator|=
name|pos
operator|>=
name|estop
expr_stmt|;
if|if
condition|(
operator|++
name|idash
operator|>=
name|dashCount
condition|)
name|idash
operator|=
literal|0
expr_stmt|;
name|doffset
operator|=
literal|0
expr_stmt|;
comment|// full segment so no offset on next.
block|}
block|}
name|hasMoveTo
operator|=
literal|false
expr_stmt|;
name|move_to_pos
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|// Dash away...
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|QPointF
name|p2
decl_stmt|;
name|bool
name|has_offset
init|=
name|doffset
operator|>
literal|0
decl_stmt|;
name|bool
name|evenDash
init|=
operator|(
name|idash
operator|&
literal|1
operator|)
operator|==
literal|0
decl_stmt|;
name|qreal
name|dpos
init|=
name|pos
operator|+
name|dashes
index|[
name|idash
index|]
operator|-
name|doffset
operator|-
name|estart
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dpos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpos
operator|>
name|elen
condition|)
block|{
comment|// dash extends this line
name|doffset
operator|=
name|dashes
index|[
name|idash
index|]
operator|-
operator|(
name|dpos
operator|-
name|elen
operator|)
expr_stmt|;
comment|// subtract the part already used
name|pos
operator|=
name|estop
expr_stmt|;
comment|// move pos to next path element
name|done
operator|=
literal|true
expr_stmt|;
name|p2
operator|=
name|cline
operator|.
name|p2
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Dash is on this line
name|p2
operator|=
name|cline
operator|.
name|pointAt
argument_list|(
name|dpos
operator|/
name|elen
argument_list|)
expr_stmt|;
name|pos
operator|=
name|dpos
operator|+
name|estart
expr_stmt|;
name|done
operator|=
name|pos
operator|>=
name|estop
expr_stmt|;
if|if
condition|(
operator|++
name|idash
operator|>=
name|dashCount
condition|)
name|idash
operator|=
literal|0
expr_stmt|;
name|doffset
operator|=
literal|0
expr_stmt|;
comment|// full segment so no offset on next.
block|}
if|if
condition|(
name|evenDash
condition|)
block|{
name|line_to_pos
operator|.
name|x
operator|=
name|qt_real_to_fixed
argument_list|(
name|p2
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|line_to_pos
operator|.
name|y
operator|=
name|qt_real_to_fixed
argument_list|(
name|p2
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clipping
operator|||
name|lineRectIntersectsRect
argument_list|(
name|move_to_pos
argument_list|,
name|line_to_pos
argument_list|,
name|clip_tl
argument_list|,
name|clip_br
argument_list|)
condition|)
block|{
comment|// If we have an offset, we're continuing a dash
comment|// from a previous element and should only
comment|// continue the current dash, without starting a
comment|// new subpath.
if|if
condition|(
operator|!
name|has_offset
operator|||
operator|!
name|hasMoveTo
condition|)
block|{
name|emitMoveTo
argument_list|(
name|move_to_pos
operator|.
name|x
argument_list|,
name|move_to_pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|hasMoveTo
operator|=
literal|true
expr_stmt|;
block|}
name|emitLineTo
argument_list|(
name|line_to_pos
operator|.
name|x
argument_list|,
name|line_to_pos
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hasMoveTo
operator|=
literal|false
expr_stmt|;
block|}
name|move_to_pos
operator|=
name|line_to_pos
expr_stmt|;
block|}
else|else
block|{
name|move_to_pos
operator|.
name|x
operator|=
name|qt_real_to_fixed
argument_list|(
name|p2
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|move_to_pos
operator|.
name|y
operator|=
name|qt_real_to_fixed
argument_list|(
name|p2
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Shuffle to the next cycle...
name|estart
operator|=
name|estop
expr_stmt|;
name|prev
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
