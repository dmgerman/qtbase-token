begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtessellator_p.h"
end_include
begin_include
include|#
directive|include
file|<QRect>
end_include
begin_include
include|#
directive|include
file|<QList>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|//#define DEBUG
ifdef|#
directive|ifdef
name|DEBUG
DECL|macro|QDEBUG
define|#
directive|define
name|QDEBUG
value|qDebug
else|#
directive|else
define|#
directive|define
name|QDEBUG
value|if (1){} else qDebug
endif|#
directive|endif
DECL|variable|emit_clever
specifier|static
specifier|const
name|bool
name|emit_clever
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|mark_clever
specifier|static
specifier|const
name|bool
name|mark_clever
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|VertexFlags
enum|enum
name|VertexFlags
block|{
DECL|enumerator|LineBeforeStarts
name|LineBeforeStarts
init|=
literal|0x1
block|,
DECL|enumerator|LineBeforeEnds
name|LineBeforeEnds
init|=
literal|0x2
block|,
DECL|enumerator|LineBeforeHorizontal
name|LineBeforeHorizontal
init|=
literal|0x4
block|,
DECL|enumerator|LineAfterStarts
name|LineAfterStarts
init|=
literal|0x8
block|,
DECL|enumerator|LineAfterEnds
name|LineAfterEnds
init|=
literal|0x10
block|,
DECL|enumerator|LineAfterHorizontal
name|LineAfterHorizontal
init|=
literal|0x20
block|}
enum|;
end_enum
begin_class
DECL|class|QTessellatorPrivate
class|class
name|QTessellatorPrivate
block|{
public|public:
struct_decl|struct
name|Vertices
struct_decl|;
DECL|function|QTessellatorPrivate
name|QTessellatorPrivate
parameter_list|()
block|{}
name|QRectF
name|collectAndSortVertices
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
modifier|*
name|maxActiveEdges
parameter_list|)
function_decl|;
name|void
name|cancelCoincidingEdges
parameter_list|()
function_decl|;
name|void
name|emitEdges
parameter_list|(
name|QTessellator
modifier|*
name|tessellator
parameter_list|)
function_decl|;
name|void
name|processIntersections
parameter_list|()
function_decl|;
name|void
name|removeEdges
parameter_list|()
function_decl|;
name|void
name|addEdges
parameter_list|()
function_decl|;
name|void
name|addIntersections
parameter_list|()
function_decl|;
DECL|struct|Vertex
struct|struct
name|Vertex
super|:
specifier|public
name|QTessellator
operator|::
name|Vertex
block|{
DECL|member|flags
name|int
name|flags
decl_stmt|;
block|}
struct|;
DECL|struct|Intersection
struct|struct
name|Intersection
block|{
DECL|member|y
name|Q27Dot5
name|y
decl_stmt|;
DECL|member|edge
name|int
name|edge
decl_stmt|;
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Intersection
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|y
operator|!=
name|other
operator|.
name|y
condition|)
return|return
name|y
operator|<
name|other
operator|.
name|y
return|;
return|return
name|edge
operator|<
name|other
operator|.
name|edge
return|;
block|}
block|}
struct|;
DECL|struct|IntersectionLink
struct|struct
name|IntersectionLink
block|{
DECL|member|next
name|int
name|next
decl_stmt|;
DECL|member|prev
name|int
name|prev
decl_stmt|;
block|}
struct|;
DECL|typedef|Intersections
typedef|typedef
name|QMap
argument_list|<
name|Intersection
argument_list|,
name|IntersectionLink
argument_list|>
name|Intersections
typedef|;
DECL|struct|Edge
struct|struct
name|Edge
block|{
name|Edge
parameter_list|(
specifier|const
name|Vertices
modifier|&
name|v
parameter_list|,
name|int
name|_edge
parameter_list|)
constructor_decl|;
DECL|member|edge
name|int
name|edge
decl_stmt|;
DECL|member|v0
specifier|const
name|Vertex
modifier|*
name|v0
decl_stmt|;
DECL|member|v1
specifier|const
name|Vertex
modifier|*
name|v1
decl_stmt|;
DECL|member|y_left
name|Q27Dot5
name|y_left
decl_stmt|;
DECL|member|y_right
name|Q27Dot5
name|y_right
decl_stmt|;
DECL|member|winding
name|signed
name|int
name|winding
range|:
literal|8
decl_stmt|;
DECL|member|mark
name|bool
name|mark
decl_stmt|;
DECL|member|free
name|bool
name|free
decl_stmt|;
DECL|member|intersect_left
name|bool
name|intersect_left
decl_stmt|;
DECL|member|intersect_right
name|bool
name|intersect_right
decl_stmt|;
name|bool
name|isLeftOf
parameter_list|(
specifier|const
name|Edge
modifier|&
name|other
parameter_list|,
name|Q27Dot5
name|y
parameter_list|)
specifier|const
function_decl|;
name|Q27Dot5
name|positionAt
parameter_list|(
name|Q27Dot5
name|y
parameter_list|)
specifier|const
function_decl|;
name|bool
name|intersect
parameter_list|(
specifier|const
name|Edge
modifier|&
name|other
parameter_list|,
name|Q27Dot5
modifier|*
name|y
parameter_list|,
name|bool
modifier|*
name|det_positive
parameter_list|)
specifier|const
function_decl|;
block|}
struct|;
DECL|class|EdgeSorter
class|class
name|EdgeSorter
block|{
public|public:
DECL|function|EdgeSorter
name|EdgeSorter
parameter_list|(
name|int
name|_y
parameter_list|)
member_init_list|:
name|y
argument_list|(
name|_y
argument_list|)
block|{}
name|bool
name|operator
name|()
parameter_list|(
specifier|const
name|Edge
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edge
modifier|*
name|e2
parameter_list|)
function_decl|;
DECL|member|y
name|int
name|y
decl_stmt|;
block|}
class|;
DECL|class|Scanline
class|class
name|Scanline
block|{
public|public:
name|Scanline
parameter_list|()
constructor_decl|;
name|~
name|Scanline
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|(
name|int
name|maxActiveEdges
parameter_list|)
function_decl|;
name|void
name|done
parameter_list|()
function_decl|;
name|int
name|findEdgePosition
parameter_list|(
name|Q27Dot5
name|x
parameter_list|,
name|Q27Dot5
name|y
parameter_list|)
specifier|const
function_decl|;
name|int
name|findEdgePosition
parameter_list|(
specifier|const
name|Edge
modifier|&
name|e
parameter_list|)
specifier|const
function_decl|;
name|int
name|findEdge
parameter_list|(
name|int
name|edge
parameter_list|)
specifier|const
function_decl|;
name|void
name|clearMarks
parameter_list|()
function_decl|;
DECL|function|swap
name|void
name|swap
parameter_list|(
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|)
block|{
name|Edge
modifier|*
name|tmp
init|=
name|edges
index|[
name|p1
index|]
decl_stmt|;
name|edges
index|[
name|p1
index|]
operator|=
name|edges
index|[
name|p2
index|]
expr_stmt|;
name|edges
index|[
name|p2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|void
name|insert
parameter_list|(
name|int
name|pos
parameter_list|,
specifier|const
name|Edge
modifier|&
name|e
parameter_list|)
function_decl|;
name|void
name|removeAt
parameter_list|(
name|int
name|pos
parameter_list|)
function_decl|;
name|void
name|markEdges
parameter_list|(
name|int
name|pos1
parameter_list|,
name|int
name|pos2
parameter_list|)
function_decl|;
name|void
name|prepareLine
parameter_list|()
function_decl|;
name|void
name|lineDone
parameter_list|()
function_decl|;
DECL|member|old
name|Edge
modifier|*
modifier|*
name|old
decl_stmt|;
DECL|member|old_size
name|int
name|old_size
decl_stmt|;
DECL|member|edges
name|Edge
modifier|*
modifier|*
name|edges
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
private|private:
DECL|member|edge_table
name|Edge
modifier|*
name|edge_table
decl_stmt|;
DECL|member|first_unused
name|int
name|first_unused
decl_stmt|;
DECL|member|max_edges
name|int
name|max_edges
decl_stmt|;
DECL|enumerator|default_alloc
enum|enum
block|{
name|default_alloc
init|=
literal|32
block|}
enum|;
block|}
class|;
DECL|struct|Vertices
struct|struct
name|Vertices
block|{
DECL|enumerator|default_alloc
enum|enum
block|{
name|default_alloc
init|=
literal|128
block|}
enum|;
name|Vertices
parameter_list|()
constructor_decl|;
name|~
name|Vertices
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|(
name|int
name|maxVertices
parameter_list|)
function_decl|;
name|void
name|done
parameter_list|()
function_decl|;
DECL|member|storage
name|Vertex
modifier|*
name|storage
decl_stmt|;
DECL|member|sorted
name|Vertex
modifier|*
modifier|*
name|sorted
decl_stmt|;
DECL|function|operator []
name|Vertex
modifier|*
name|operator
name|[]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|storage
operator|+
name|i
return|;
block|}
DECL|function|operator []
specifier|const
name|Vertex
modifier|*
name|operator
name|[]
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
return|return
name|storage
operator|+
name|i
return|;
block|}
DECL|function|position
name|int
name|position
parameter_list|(
specifier|const
name|Vertex
modifier|*
name|v
parameter_list|)
specifier|const
block|{
return|return
name|v
operator|-
name|storage
return|;
block|}
DECL|function|next
name|Vertex
modifier|*
name|next
parameter_list|(
name|Vertex
modifier|*
name|v
parameter_list|)
block|{
operator|++
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|storage
operator|+
name|nPoints
condition|)
name|v
operator|=
name|storage
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|function|next
specifier|const
name|Vertex
modifier|*
name|next
parameter_list|(
specifier|const
name|Vertex
modifier|*
name|v
parameter_list|)
specifier|const
block|{
operator|++
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|storage
operator|+
name|nPoints
condition|)
name|v
operator|=
name|storage
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|function|nextPos
name|int
name|nextPos
parameter_list|(
specifier|const
name|Vertex
modifier|*
name|v
parameter_list|)
specifier|const
block|{
operator|++
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|storage
operator|+
name|nPoints
condition|)
return|return
literal|0
return|;
return|return
name|v
operator|-
name|storage
return|;
block|}
DECL|function|prev
name|Vertex
modifier|*
name|prev
parameter_list|(
name|Vertex
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
name|storage
condition|)
name|v
operator|=
name|storage
operator|+
name|nPoints
expr_stmt|;
operator|--
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|function|prev
specifier|const
name|Vertex
modifier|*
name|prev
parameter_list|(
specifier|const
name|Vertex
modifier|*
name|v
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|v
operator|==
name|storage
condition|)
name|v
operator|=
name|storage
operator|+
name|nPoints
expr_stmt|;
operator|--
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|function|prevPos
name|int
name|prevPos
parameter_list|(
specifier|const
name|Vertex
modifier|*
name|v
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|v
operator|==
name|storage
condition|)
name|v
operator|=
name|storage
operator|+
name|nPoints
expr_stmt|;
operator|--
name|v
expr_stmt|;
return|return
name|v
operator|-
name|storage
return|;
block|}
DECL|member|nPoints
name|int
name|nPoints
decl_stmt|;
DECL|member|allocated
name|int
name|allocated
decl_stmt|;
block|}
struct|;
DECL|member|vertices
name|Vertices
name|vertices
decl_stmt|;
DECL|member|intersections
name|Intersections
name|intersections
decl_stmt|;
DECL|member|scanline
name|Scanline
name|scanline
decl_stmt|;
DECL|member|winding
name|bool
name|winding
decl_stmt|;
DECL|member|y
name|Q27Dot5
name|y
decl_stmt|;
DECL|member|currentVertex
name|int
name|currentVertex
decl_stmt|;
private|private:
name|void
name|addIntersection
parameter_list|(
specifier|const
name|Edge
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edge
modifier|*
name|e2
parameter_list|)
function_decl|;
name|bool
name|edgeInChain
parameter_list|(
name|Intersection
name|i
parameter_list|,
name|int
name|edge
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|Edge
name|QTessellatorPrivate
operator|::
name|Edge
operator|::
name|Edge
parameter_list|(
specifier|const
name|QTessellatorPrivate
operator|::
name|Vertices
modifier|&
name|vertices
parameter_list|,
name|int
name|edge
parameter_list|)
block|{
name|this
operator|->
name|edge
operator|=
name|edge
expr_stmt|;
name|intersect_left
operator|=
name|intersect_right
operator|=
literal|true
expr_stmt|;
name|mark
operator|=
literal|false
expr_stmt|;
name|free
operator|=
literal|false
expr_stmt|;
name|v0
operator|=
name|vertices
index|[
name|edge
index|]
expr_stmt|;
name|v1
operator|=
name|vertices
operator|.
name|next
argument_list|(
name|v0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|v0
operator|->
name|y
operator|!=
name|v1
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|v0
operator|->
name|y
operator|>
name|v1
operator|->
name|y
condition|)
block|{
name|qSwap
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|winding
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|winding
operator|=
literal|1
expr_stmt|;
block|}
name|y_left
operator|=
name|y_right
operator|=
name|v0
operator|->
name|y
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// This is basically the algorithm from graphics gems. The algorithm
end_comment
begin_comment
comment|// is cubic in the coordinates at one place.  Since we use 64bit
end_comment
begin_comment
comment|// integers, this implies, that the allowed range for our coordinates
end_comment
begin_comment
comment|// is limited to 21 bits.  With 5 bits behind the decimal, this
end_comment
begin_comment
comment|// implies that differences in coordaintes can range from 2*SHORT_MIN
end_comment
begin_comment
comment|// to 2*SHORT_MAX, giving us efficiently a coordinate system from
end_comment
begin_comment
comment|// SHORT_MIN to SHORT_MAX.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// WARNING: It's absolutely critical that the intersect() and isLeftOf() methods use
end_comment
begin_comment
comment|// exactly the same algorithm to calulate yi. It's also important to be sure the algorithms
end_comment
begin_comment
comment|// are transitive (ie. the conditions below are true for all input data):
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// a.intersect(b) == b.intersect(a)
end_comment
begin_comment
comment|// a.isLeftOf(b) != b.isLeftOf(a)
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This is tricky to get right, so be very careful when changing anything in here!
end_comment
begin_function
DECL|function|sameSign
specifier|static
specifier|inline
name|bool
name|sameSign
parameter_list|(
name|qint64
name|a
parameter_list|,
name|qint64
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
call|(
name|qint64
call|)
argument_list|(
operator|(
name|quint64
operator|)
name|a
operator|^
operator|(
name|quint64
operator|)
name|b
argument_list|)
operator|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|intersect
name|bool
name|QTessellatorPrivate
operator|::
name|Edge
operator|::
name|intersect
parameter_list|(
specifier|const
name|Edge
modifier|&
name|other
parameter_list|,
name|Q27Dot5
modifier|*
name|y
parameter_list|,
name|bool
modifier|*
name|det_positive
parameter_list|)
specifier|const
block|{
name|qint64
name|a1
init|=
name|v1
operator|->
name|y
operator|-
name|v0
operator|->
name|y
decl_stmt|;
name|qint64
name|b1
init|=
name|v0
operator|->
name|x
operator|-
name|v1
operator|->
name|x
decl_stmt|;
name|qint64
name|a2
init|=
name|other
operator|.
name|v1
operator|->
name|y
operator|-
name|other
operator|.
name|v0
operator|->
name|y
decl_stmt|;
name|qint64
name|b2
init|=
name|other
operator|.
name|v0
operator|->
name|x
operator|-
name|other
operator|.
name|v1
operator|->
name|x
decl_stmt|;
name|qint64
name|det
init|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|qint64
name|c1
init|=
name|qint64
argument_list|(
name|v1
operator|->
name|x
argument_list|)
operator|*
name|v0
operator|->
name|y
operator|-
name|qint64
argument_list|(
name|v0
operator|->
name|x
argument_list|)
operator|*
name|v1
operator|->
name|y
decl_stmt|;
name|qint64
name|r3
init|=
name|a1
operator|*
name|other
operator|.
name|v0
operator|->
name|x
operator|+
name|b1
operator|*
name|other
operator|.
name|v0
operator|->
name|y
operator|+
name|c1
decl_stmt|;
name|qint64
name|r4
init|=
name|a1
operator|*
name|other
operator|.
name|v1
operator|->
name|x
operator|+
name|b1
operator|*
name|other
operator|.
name|v1
operator|->
name|y
operator|+
name|c1
decl_stmt|;
comment|// Check signs of r3 and r4.  If both point 3 and point 4 lie on
comment|// same side of line 1, the line segments do not intersect.
name|QDEBUG
argument_list|()
operator|<<
literal|"        "
operator|<<
name|r3
operator|<<
name|r4
expr_stmt|;
if|if
condition|(
name|r3
operator|!=
literal|0
operator|&&
name|r4
operator|!=
literal|0
operator|&&
name|sameSign
argument_list|(
name|r3
argument_list|,
name|r4
argument_list|)
condition|)
return|return
literal|false
return|;
name|qint64
name|c2
init|=
name|qint64
argument_list|(
name|other
operator|.
name|v1
operator|->
name|x
argument_list|)
operator|*
name|other
operator|.
name|v0
operator|->
name|y
operator|-
name|qint64
argument_list|(
name|other
operator|.
name|v0
operator|->
name|x
argument_list|)
operator|*
name|other
operator|.
name|v1
operator|->
name|y
decl_stmt|;
name|qint64
name|r1
init|=
name|a2
operator|*
name|v0
operator|->
name|x
operator|+
name|b2
operator|*
name|v0
operator|->
name|y
operator|+
name|c2
decl_stmt|;
name|qint64
name|r2
init|=
name|a2
operator|*
name|v1
operator|->
name|x
operator|+
name|b2
operator|*
name|v1
operator|->
name|y
operator|+
name|c2
decl_stmt|;
comment|// Check signs of r1 and r2.  If both point 1 and point 2 lie
comment|// on same side of second line segment, the line segments do not intersect.
name|QDEBUG
argument_list|()
operator|<<
literal|"        "
operator|<<
name|r1
operator|<<
name|r2
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
literal|0
operator|&&
name|r2
operator|!=
literal|0
operator|&&
name|sameSign
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// The det/2 is to get rounding instead of truncating.  It
comment|// is added or subtracted to the numerator, depending upon the
comment|// sign of the numerator.
name|qint64
name|offset
init|=
name|det
operator|<
literal|0
condition|?
operator|-
name|det
else|:
name|det
decl_stmt|;
name|offset
operator|>>=
literal|1
expr_stmt|;
name|qint64
name|num
init|=
name|a2
operator|*
name|c1
operator|-
name|a1
operator|*
name|c2
decl_stmt|;
operator|*
name|y
operator|=
operator|(
name|num
operator|<
literal|0
condition|?
name|num
operator|-
name|offset
else|:
name|num
operator|+
name|offset
operator|)
operator|/
name|det
expr_stmt|;
operator|*
name|det_positive
operator|=
operator|(
name|det
operator|>
literal|0
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_undef
DECL|macro|SAME_SIGNS
undef|#
directive|undef
name|SAME_SIGNS
end_undef
begin_function
DECL|function|isLeftOf
name|bool
name|QTessellatorPrivate
operator|::
name|Edge
operator|::
name|isLeftOf
parameter_list|(
specifier|const
name|Edge
modifier|&
name|other
parameter_list|,
name|Q27Dot5
name|y
parameter_list|)
specifier|const
block|{
comment|//     QDEBUG()<< "isLeftOf"<< edge<< other.edge<< y;
name|qint64
name|a1
init|=
name|v1
operator|->
name|y
operator|-
name|v0
operator|->
name|y
decl_stmt|;
name|qint64
name|b1
init|=
name|v0
operator|->
name|x
operator|-
name|v1
operator|->
name|x
decl_stmt|;
name|qint64
name|a2
init|=
name|other
operator|.
name|v1
operator|->
name|y
operator|-
name|other
operator|.
name|v0
operator|->
name|y
decl_stmt|;
name|qint64
name|b2
init|=
name|other
operator|.
name|v0
operator|->
name|x
operator|-
name|other
operator|.
name|v1
operator|->
name|x
decl_stmt|;
name|qint64
name|c2
init|=
name|qint64
argument_list|(
name|other
operator|.
name|v1
operator|->
name|x
argument_list|)
operator|*
name|other
operator|.
name|v0
operator|->
name|y
operator|-
name|qint64
argument_list|(
name|other
operator|.
name|v0
operator|->
name|x
argument_list|)
operator|*
name|other
operator|.
name|v1
operator|->
name|y
decl_stmt|;
name|qint64
name|det
init|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0
condition|)
block|{
comment|// lines are parallel. Only need to check side of one point
comment|// fixed ordering for coincident edges
name|qint64
name|r1
init|=
name|a2
operator|*
name|v0
operator|->
name|x
operator|+
name|b2
operator|*
name|v0
operator|->
name|y
operator|+
name|c2
decl_stmt|;
comment|//         QDEBUG()<< "det = 0"<< r1;
if|if
condition|(
name|r1
operator|==
literal|0
condition|)
return|return
name|edge
operator|<
name|other
operator|.
name|edge
return|;
return|return
operator|(
name|r1
operator|<
literal|0
operator|)
return|;
block|}
comment|// not parallel, need to find the y coordinate of the intersection point
name|qint64
name|c1
init|=
name|qint64
argument_list|(
name|v1
operator|->
name|x
argument_list|)
operator|*
name|v0
operator|->
name|y
operator|-
name|qint64
argument_list|(
name|v0
operator|->
name|x
argument_list|)
operator|*
name|v1
operator|->
name|y
decl_stmt|;
name|qint64
name|offset
init|=
name|det
operator|<
literal|0
condition|?
operator|-
name|det
else|:
name|det
decl_stmt|;
name|offset
operator|>>=
literal|1
expr_stmt|;
name|qint64
name|num
init|=
name|a2
operator|*
name|c1
operator|-
name|a1
operator|*
name|c2
decl_stmt|;
name|qint64
name|yi
init|=
operator|(
name|num
operator|<
literal|0
condition|?
name|num
operator|-
name|offset
else|:
name|num
operator|+
name|offset
operator|)
operator|/
name|det
decl_stmt|;
comment|//     QDEBUG()<< "    num="<< num<< "offset="<< offset<< "det="<< det;
return|return
operator|(
operator|(
name|yi
operator|>
name|y
operator|)
operator|^
operator|(
name|det
operator|<
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|compareVertex
specifier|static
specifier|inline
name|bool
name|compareVertex
parameter_list|(
specifier|const
name|QTessellatorPrivate
operator|::
name|Vertex
modifier|*
name|p1
parameter_list|,
specifier|const
name|QTessellatorPrivate
operator|::
name|Vertex
modifier|*
name|p2
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|y
operator|==
name|p2
operator|->
name|y
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|x
operator|==
name|p2
operator|->
name|x
condition|)
return|return
name|p1
operator|<
name|p2
return|;
return|return
name|p1
operator|->
name|x
operator|<
name|p2
operator|->
name|x
return|;
block|}
return|return
name|p1
operator|->
name|y
operator|<
name|p2
operator|->
name|y
return|;
block|}
end_function
begin_function
DECL|function|positionAt
name|Q27Dot5
name|QTessellatorPrivate
operator|::
name|Edge
operator|::
name|positionAt
parameter_list|(
name|Q27Dot5
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|y
operator|==
name|v0
operator|->
name|y
condition|)
return|return
name|v0
operator|->
name|x
return|;
elseif|else
if|if
condition|(
name|y
operator|==
name|v1
operator|->
name|y
condition|)
return|return
name|v1
operator|->
name|x
return|;
name|qint64
name|d
init|=
name|v1
operator|->
name|x
operator|-
name|v0
operator|->
name|x
decl_stmt|;
return|return
operator|(
name|v0
operator|->
name|x
operator|+
name|d
operator|*
operator|(
name|y
operator|-
name|v0
operator|->
name|y
operator|)
operator|/
operator|(
name|v1
operator|->
name|y
operator|-
name|v0
operator|->
name|y
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator ()
name|bool
name|QTessellatorPrivate
operator|::
name|EdgeSorter
operator|::
name|operator
name|()
parameter_list|(
specifier|const
name|Edge
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edge
modifier|*
name|e2
parameter_list|)
block|{
return|return
name|e1
operator|->
name|isLeftOf
argument_list|(
operator|*
name|e2
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|Scanline
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|Scanline
parameter_list|()
block|{
name|edges
operator|=
literal|0
expr_stmt|;
name|edge_table
operator|=
literal|0
expr_stmt|;
name|old
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|init
parameter_list|(
name|int
name|maxActiveEdges
parameter_list|)
block|{
name|maxActiveEdges
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|edges
operator|||
name|maxActiveEdges
operator|>
name|default_alloc
condition|)
block|{
name|max_edges
operator|=
name|maxActiveEdges
expr_stmt|;
name|int
name|s
init|=
name|qMax
argument_list|(
name|maxActiveEdges
operator|+
literal|1
argument_list|,
name|default_alloc
operator|+
literal|1
argument_list|)
decl_stmt|;
name|edges
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Edge
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|edges
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|Edge
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|edge_table
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Edge
operator|*
operator|)
name|realloc
argument_list|(
name|edge_table
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|Edge
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Edge
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|Edge
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
name|old_size
operator|=
literal|0
expr_stmt|;
name|first_unused
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxActiveEdges
condition|;
operator|++
name|i
control|)
name|edge_table
index|[
name|i
index|]
operator|.
name|edge
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|edge_table
index|[
name|maxActiveEdges
index|]
operator|.
name|edge
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|done
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|done
parameter_list|()
block|{
if|if
condition|(
name|max_edges
operator|>
name|default_alloc
condition|)
block|{
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_table
argument_list|)
expr_stmt|;
name|edges
operator|=
literal|0
expr_stmt|;
name|old
operator|=
literal|0
expr_stmt|;
name|edge_table
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_destructor
DECL|function|~Scanline
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|~
name|Scanline
parameter_list|()
block|{
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_table
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|findEdgePosition
name|int
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|findEdgePosition
parameter_list|(
name|Q27Dot5
name|x
parameter_list|,
name|Q27Dot5
name|y
parameter_list|)
specifier|const
block|{
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|size
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|int
name|pos
init|=
name|min
operator|+
operator|(
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
decl_stmt|;
name|Q27Dot5
name|ax
init|=
name|edges
index|[
name|pos
index|]
operator|->
name|positionAt
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|ax
operator|>
name|x
condition|)
block|{
name|max
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|pos
expr_stmt|;
block|}
block|}
return|return
name|min
return|;
block|}
end_function
begin_function
DECL|function|findEdgePosition
name|int
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|findEdgePosition
parameter_list|(
specifier|const
name|Edge
modifier|&
name|e
parameter_list|)
specifier|const
block|{
comment|//     qDebug()<< ">>      findEdgePosition";
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|size
decl_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|int
name|pos
init|=
name|min
operator|+
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
decl_stmt|;
comment|//         qDebug()<< "        "<< min<< max<< pos<< edges[pos]->isLeftOf(e, e.y0);
if|if
condition|(
name|edges
index|[
name|pos
index|]
operator|->
name|isLeftOf
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|v0
operator|->
name|y
argument_list|)
condition|)
block|{
name|min
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|pos
expr_stmt|;
block|}
block|}
comment|//     qDebug()<< "<<      findEdgePosition got"<< min;
return|return
name|min
return|;
block|}
end_function
begin_function
DECL|function|findEdge
name|int
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|findEdge
parameter_list|(
name|int
name|edge
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|int
name|item_edge
init|=
name|edges
index|[
name|i
index|]
operator|->
name|edge
decl_stmt|;
if|if
condition|(
name|item_edge
operator|==
name|edge
condition|)
return|return
name|i
return|;
block|}
comment|//Q_ASSERT(false);
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|clearMarks
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|clearMarks
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|edges
index|[
name|i
index|]
operator|->
name|mark
operator|=
literal|false
expr_stmt|;
name|edges
index|[
name|i
index|]
operator|->
name|intersect_left
operator|=
literal|false
expr_stmt|;
name|edges
index|[
name|i
index|]
operator|->
name|intersect_right
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|prepareLine
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|prepareLine
parameter_list|()
block|{
name|Edge
modifier|*
modifier|*
name|end
init|=
name|edges
operator|+
name|size
decl_stmt|;
name|Edge
modifier|*
modifier|*
name|e
init|=
name|edges
decl_stmt|;
name|Edge
modifier|*
modifier|*
name|o
init|=
name|old
decl_stmt|;
while|while
condition|(
name|e
operator|<
name|end
condition|)
block|{
operator|*
name|o
operator|=
operator|*
name|e
expr_stmt|;
operator|++
name|o
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
name|old_size
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lineDone
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|lineDone
parameter_list|()
block|{
name|Edge
modifier|*
modifier|*
name|end
init|=
name|old
operator|+
name|old_size
decl_stmt|;
name|Edge
modifier|*
modifier|*
name|e
init|=
name|old
decl_stmt|;
while|while
condition|(
name|e
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|e
operator|)
operator|->
name|free
condition|)
block|{
operator|(
operator|*
name|e
operator|)
operator|->
name|edge
operator|=
name|first_unused
expr_stmt|;
name|first_unused
operator|=
operator|(
operator|*
name|e
operator|-
name|edge_table
operator|)
expr_stmt|;
block|}
operator|++
name|e
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|insert
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|insert
parameter_list|(
name|int
name|pos
parameter_list|,
specifier|const
name|Edge
modifier|&
name|e
parameter_list|)
block|{
name|Edge
modifier|*
name|edge
init|=
name|edge_table
operator|+
name|first_unused
decl_stmt|;
name|first_unused
operator|=
name|edge
operator|->
name|edge
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first_unused
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|edge
operator|=
name|e
expr_stmt|;
name|memmove
argument_list|(
name|edges
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|edges
operator|+
name|pos
argument_list|,
operator|(
name|size
operator|-
name|pos
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|edges
index|[
name|pos
index|]
operator|=
name|edge
expr_stmt|;
operator|++
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeAt
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|removeAt
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Edge
modifier|*
name|e
init|=
name|edges
index|[
name|pos
index|]
decl_stmt|;
name|e
operator|->
name|free
operator|=
literal|true
expr_stmt|;
operator|--
name|size
expr_stmt|;
name|memmove
argument_list|(
name|edges
operator|+
name|pos
argument_list|,
name|edges
operator|+
name|pos
operator|+
literal|1
argument_list|,
operator|(
name|size
operator|-
name|pos
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|markEdges
name|void
name|QTessellatorPrivate
operator|::
name|Scanline
operator|::
name|markEdges
parameter_list|(
name|int
name|pos1
parameter_list|,
name|int
name|pos2
parameter_list|)
block|{
if|if
condition|(
name|pos2
operator|<
name|pos1
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
name|pos1
init|;
name|i
operator|<=
name|pos2
condition|;
operator|++
name|i
control|)
name|edges
index|[
name|i
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|Vertices
name|QTessellatorPrivate
operator|::
name|Vertices
operator|::
name|Vertices
parameter_list|()
block|{
name|storage
operator|=
literal|0
expr_stmt|;
name|sorted
operator|=
literal|0
expr_stmt|;
name|allocated
operator|=
literal|0
expr_stmt|;
name|nPoints
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~Vertices
name|QTessellatorPrivate
operator|::
name|Vertices
operator|::
name|~
name|Vertices
parameter_list|()
block|{
if|if
condition|(
name|storage
condition|)
block|{
name|free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QTessellatorPrivate
operator|::
name|Vertices
operator|::
name|init
parameter_list|(
name|int
name|maxVertices
parameter_list|)
block|{
if|if
condition|(
operator|!
name|storage
operator|||
name|maxVertices
operator|>
name|allocated
condition|)
block|{
name|int
name|size
init|=
name|qMax
argument_list|(
operator|(
name|int
operator|)
name|default_alloc
argument_list|,
name|maxVertices
argument_list|)
decl_stmt|;
name|storage
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Vertex
operator|*
operator|)
name|realloc
argument_list|(
name|storage
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|Vertex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sorted
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|Vertex
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|sorted
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|Vertex
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|allocated
operator|=
name|maxVertices
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|done
name|void
name|QTessellatorPrivate
operator|::
name|Vertices
operator|::
name|done
parameter_list|()
block|{
if|if
condition|(
name|allocated
operator|>
name|default_alloc
condition|)
block|{
name|free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
name|storage
operator|=
literal|0
expr_stmt|;
name|sorted
operator|=
literal|0
expr_stmt|;
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fillTrapezoid
specifier|static
specifier|inline
name|void
name|fillTrapezoid
parameter_list|(
name|Q27Dot5
name|y1
parameter_list|,
name|Q27Dot5
name|y2
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
specifier|const
name|QTessellatorPrivate
operator|::
name|Vertices
modifier|&
name|vertices
parameter_list|,
name|QTessellator
operator|::
name|Trapezoid
modifier|*
name|trap
parameter_list|)
block|{
name|trap
operator|->
name|top
operator|=
name|y1
expr_stmt|;
name|trap
operator|->
name|bottom
operator|=
name|y2
expr_stmt|;
specifier|const
name|QTessellatorPrivate
operator|::
name|Vertex
modifier|*
name|v
init|=
name|vertices
index|[
name|left
index|]
decl_stmt|;
name|trap
operator|->
name|topLeft
operator|=
name|v
expr_stmt|;
name|trap
operator|->
name|bottomLeft
operator|=
name|vertices
operator|.
name|next
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap
operator|->
name|topLeft
operator|->
name|y
operator|>
name|trap
operator|->
name|bottomLeft
operator|->
name|y
condition|)
name|qSwap
argument_list|(
name|trap
operator|->
name|topLeft
argument_list|,
name|trap
operator|->
name|bottomLeft
argument_list|)
expr_stmt|;
name|v
operator|=
name|vertices
index|[
name|right
index|]
expr_stmt|;
name|trap
operator|->
name|topRight
operator|=
name|v
expr_stmt|;
name|trap
operator|->
name|bottomRight
operator|=
name|vertices
operator|.
name|next
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap
operator|->
name|topRight
operator|->
name|y
operator|>
name|trap
operator|->
name|bottomRight
operator|->
name|y
condition|)
name|qSwap
argument_list|(
name|trap
operator|->
name|topRight
argument_list|,
name|trap
operator|->
name|bottomRight
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|collectAndSortVertices
name|QRectF
name|QTessellatorPrivate
operator|::
name|collectAndSortVertices
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
modifier|*
name|maxActiveEdges
parameter_list|)
block|{
operator|*
name|maxActiveEdges
operator|=
literal|0
expr_stmt|;
name|Vertex
modifier|*
name|v
init|=
name|vertices
operator|.
name|storage
decl_stmt|;
name|Vertex
modifier|*
modifier|*
name|vv
init|=
name|vertices
operator|.
name|sorted
decl_stmt|;
name|qreal
name|xmin
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|xmax
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|ymin
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|ymax
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
comment|// collect vertex data
name|Q27Dot5
name|y_prev
init|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
name|vertices
operator|.
name|nPoints
operator|-
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|Q27Dot5
name|x_next
init|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|Q27Dot5
name|y_next
init|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|vertices
operator|.
name|nPoints
condition|)
block|{
name|Q27Dot5
name|y_curr
init|=
name|y_next
decl_stmt|;
operator|*
name|vv
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|x
operator|=
name|x_next
expr_stmt|;
name|v
operator|->
name|y
operator|=
name|y_next
expr_stmt|;
name|v
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|next_point
label|:
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|y_next
operator|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|x_next
operator|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
comment|// skip vertices on top of each other
if|if
condition|(
name|v
operator|->
name|x
operator|==
name|x_next
operator|&&
name|v
operator|->
name|y
operator|==
name|y_next
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|vertices
operator|.
name|nPoints
condition|)
goto|goto
name|next_point
goto|;
name|Vertex
modifier|*
name|v0
init|=
name|vertices
operator|.
name|storage
decl_stmt|;
name|v0
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineBeforeStarts
operator||
name|LineBeforeEnds
operator||
name|LineBeforeHorizontal
operator|)
expr_stmt|;
if|if
condition|(
name|y_prev
operator|<
name|y_curr
condition|)
name|v0
operator|->
name|flags
operator||=
name|LineBeforeEnds
expr_stmt|;
elseif|else
if|if
condition|(
name|y_prev
operator|>
name|y_curr
condition|)
name|v0
operator|->
name|flags
operator||=
name|LineBeforeStarts
expr_stmt|;
else|else
name|v0
operator|->
name|flags
operator||=
name|LineBeforeHorizontal
expr_stmt|;
if|if
condition|(
operator|(
name|v0
operator|->
name|flags
operator|&
operator|(
name|LineBeforeStarts
operator||
name|LineAfterStarts
operator|)
operator|)
operator|&&
operator|!
operator|(
name|v0
operator|->
name|flags
operator|&
operator|(
name|LineAfterEnds
operator||
name|LineBeforeEnds
operator|)
operator|)
condition|)
operator|*
name|maxActiveEdges
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|y_prev
operator|<
name|y_curr
condition|)
name|v
operator|->
name|flags
operator||=
name|LineBeforeEnds
expr_stmt|;
elseif|else
if|if
condition|(
name|y_prev
operator|>
name|y_curr
condition|)
name|v
operator|->
name|flags
operator||=
name|LineBeforeStarts
expr_stmt|;
else|else
name|v
operator|->
name|flags
operator||=
name|LineBeforeHorizontal
expr_stmt|;
if|if
condition|(
name|y_curr
operator|<
name|y_next
condition|)
name|v
operator|->
name|flags
operator||=
name|LineAfterStarts
expr_stmt|;
elseif|else
if|if
condition|(
name|y_curr
operator|>
name|y_next
condition|)
name|v
operator|->
name|flags
operator||=
name|LineAfterEnds
expr_stmt|;
else|else
name|v
operator|->
name|flags
operator||=
name|LineAfterHorizontal
expr_stmt|;
comment|// ### could probably get better limit by looping over sorted list and counting down on ending edges
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
operator|(
name|LineBeforeStarts
operator||
name|LineAfterStarts
operator|)
operator|)
operator|&&
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
operator|(
name|LineAfterEnds
operator||
name|LineBeforeEnds
operator|)
operator|)
condition|)
operator|*
name|maxActiveEdges
operator|+=
literal|2
expr_stmt|;
name|y_prev
operator|=
name|y_curr
expr_stmt|;
operator|++
name|v
expr_stmt|;
operator|++
name|vv
expr_stmt|;
operator|++
name|j
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|vertices
operator|.
name|nPoints
operator|=
name|j
expr_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"maxActiveEdges="
operator|<<
operator|*
name|maxActiveEdges
expr_stmt|;
name|vv
operator|=
name|vertices
operator|.
name|sorted
expr_stmt|;
name|qSort
argument_list|(
name|vv
argument_list|,
name|vv
operator|+
name|vertices
operator|.
name|nPoints
argument_list|,
name|compareVertex
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|(
name|xmin
argument_list|,
name|ymin
argument_list|,
name|xmax
operator|-
name|xmin
argument_list|,
name|ymax
operator|-
name|ymin
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|QCoincidingEdge
struct|struct
name|QCoincidingEdge
block|{
DECL|member|start
name|QTessellatorPrivate
operator|::
name|Vertex
modifier|*
name|start
decl_stmt|;
DECL|member|end
name|QTessellatorPrivate
operator|::
name|Vertex
modifier|*
name|end
decl_stmt|;
DECL|member|used
name|bool
name|used
decl_stmt|;
DECL|member|before
name|bool
name|before
decl_stmt|;
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QCoincidingEdge
modifier|&
name|e2
parameter_list|)
specifier|const
block|{
return|return
name|end
operator|->
name|y
operator|==
name|e2
operator|.
name|end
operator|->
name|y
condition|?
name|end
operator|->
name|x
operator|<
name|e2
operator|.
name|end
operator|->
name|x
else|:
name|end
operator|->
name|y
operator|<
name|e2
operator|.
name|end
operator|->
name|y
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|cancelEdges
specifier|static
name|void
name|cancelEdges
parameter_list|(
name|QCoincidingEdge
modifier|&
name|e1
parameter_list|,
name|QCoincidingEdge
modifier|&
name|e2
parameter_list|)
block|{
if|if
condition|(
name|e1
operator|.
name|before
condition|)
block|{
name|e1
operator|.
name|start
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineBeforeStarts
operator||
name|LineBeforeHorizontal
operator|)
expr_stmt|;
name|e1
operator|.
name|end
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineAfterEnds
operator||
name|LineAfterHorizontal
operator|)
expr_stmt|;
block|}
else|else
block|{
name|e1
operator|.
name|start
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineAfterStarts
operator||
name|LineAfterHorizontal
operator|)
expr_stmt|;
name|e1
operator|.
name|end
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineBeforeEnds
operator||
name|LineBeforeHorizontal
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|e2
operator|.
name|before
condition|)
block|{
name|e2
operator|.
name|start
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineBeforeStarts
operator||
name|LineBeforeHorizontal
operator|)
expr_stmt|;
name|e2
operator|.
name|end
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineAfterEnds
operator||
name|LineAfterHorizontal
operator|)
expr_stmt|;
block|}
else|else
block|{
name|e2
operator|.
name|start
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineAfterStarts
operator||
name|LineAfterHorizontal
operator|)
expr_stmt|;
name|e2
operator|.
name|end
operator|->
name|flags
operator|&=
operator|~
operator|(
name|LineBeforeEnds
operator||
name|LineBeforeHorizontal
operator|)
expr_stmt|;
block|}
name|e1
operator|.
name|used
operator|=
name|e2
operator|.
name|used
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cancelCoincidingEdges
name|void
name|QTessellatorPrivate
operator|::
name|cancelCoincidingEdges
parameter_list|()
block|{
name|Vertex
modifier|*
modifier|*
name|vv
init|=
name|vertices
operator|.
name|sorted
decl_stmt|;
name|QCoincidingEdge
modifier|*
name|tl
init|=
literal|0
decl_stmt|;
name|int
name|tlSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|nPoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Vertex
modifier|*
name|v
init|=
name|vv
index|[
name|i
index|]
decl_stmt|;
name|int
name|testListSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|vertices
operator|.
name|nPoints
operator|-
literal|1
condition|)
block|{
name|Vertex
modifier|*
name|n
init|=
name|vv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|x
operator|!=
name|n
operator|->
name|x
operator|||
name|v
operator|->
name|y
operator|!=
name|n
operator|->
name|y
condition|)
break|break;
if|if
condition|(
name|testListSize
operator|>
name|tlSize
operator|-
literal|2
condition|)
block|{
name|tlSize
operator|=
name|qMax
argument_list|(
name|tlSize
operator|*
literal|2
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|tl
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|QCoincidingEdge
operator|*
operator|)
name|realloc
argument_list|(
name|tl
argument_list|,
name|tlSize
operator|*
sizeof|sizeof
argument_list|(
name|QCoincidingEdge
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|flags
operator|&
operator|(
name|LineBeforeStarts
operator||
name|LineBeforeHorizontal
operator|)
condition|)
block|{
name|tl
index|[
name|testListSize
index|]
operator|.
name|start
operator|=
name|n
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|end
operator|=
name|vertices
operator|.
name|prev
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|used
operator|=
literal|false
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|before
operator|=
literal|true
expr_stmt|;
operator|++
name|testListSize
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|flags
operator|&
operator|(
name|LineAfterStarts
operator||
name|LineAfterHorizontal
operator|)
condition|)
block|{
name|tl
index|[
name|testListSize
index|]
operator|.
name|start
operator|=
name|n
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|end
operator|=
name|vertices
operator|.
name|next
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|used
operator|=
literal|false
expr_stmt|;
name|tl
index|[
name|testListSize
index|]
operator|.
name|before
operator|=
literal|false
expr_stmt|;
operator|++
name|testListSize
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|testListSize
condition|)
continue|continue;
name|qSort
argument_list|(
name|tl
argument_list|,
name|tl
operator|+
name|testListSize
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|testListSize
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|tl
index|[
name|j
index|]
operator|.
name|used
condition|)
continue|continue;
for|for
control|(
name|int
name|k
init|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
name|testListSize
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|tl
index|[
name|j
index|]
operator|.
name|end
operator|->
name|x
operator|!=
name|tl
index|[
name|k
index|]
operator|.
name|end
operator|->
name|x
operator|||
name|tl
index|[
name|j
index|]
operator|.
name|end
operator|->
name|y
operator|!=
name|tl
index|[
name|k
index|]
operator|.
name|end
operator|->
name|y
operator|||
name|tl
index|[
name|k
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
operator|!
name|winding
operator|||
name|tl
index|[
name|j
index|]
operator|.
name|before
operator|!=
name|tl
index|[
name|k
index|]
operator|.
name|before
condition|)
block|{
name|cancelEdges
argument_list|(
name|tl
index|[
name|j
index|]
argument_list|,
name|tl
index|[
name|k
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|k
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitEdges
name|void
name|QTessellatorPrivate
operator|::
name|emitEdges
parameter_list|(
name|QTessellator
modifier|*
name|tessellator
parameter_list|)
block|{
comment|//QDEBUG()<< "TRAPS:";
if|if
condition|(
operator|!
name|scanline
operator|.
name|old_size
condition|)
return|return;
comment|// emit edges
if|if
condition|(
name|winding
condition|)
block|{
comment|// winding fill rule
name|int
name|w
init|=
literal|0
decl_stmt|;
name|scanline
operator|.
name|old
index|[
literal|0
index|]
operator|->
name|y_left
operator|=
name|y
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scanline
operator|.
name|old_size
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Edge
modifier|*
name|left
init|=
name|scanline
operator|.
name|old
index|[
name|i
index|]
decl_stmt|;
name|Edge
modifier|*
name|right
init|=
name|scanline
operator|.
name|old
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|w
operator|+=
name|left
operator|->
name|winding
expr_stmt|;
comment|//             qDebug()<< "i="<< i<< "edge->winding="<< left->winding<< "winding="<< winding;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
name|left
operator|->
name|y_right
operator|=
name|y
expr_stmt|;
name|right
operator|->
name|y_left
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|emit_clever
operator|||
name|left
operator|->
name|mark
operator|||
name|right
operator|->
name|mark
condition|)
block|{
name|Q27Dot5
name|top
init|=
name|qMax
argument_list|(
name|left
operator|->
name|y_right
argument_list|,
name|right
operator|->
name|y_left
argument_list|)
decl_stmt|;
if|if
condition|(
name|top
operator|!=
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|trap
decl_stmt|;
name|fillTrapezoid
argument_list|(
name|top
argument_list|,
name|y
argument_list|,
name|left
operator|->
name|edge
argument_list|,
name|right
operator|->
name|edge
argument_list|,
name|vertices
argument_list|,
operator|&
name|trap
argument_list|)
expr_stmt|;
name|tessellator
operator|->
name|addTrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
comment|//                     QDEBUG()<< "    top="<< Q27Dot5ToDouble(top)<< "left="<< left->edge<< "right="<< right->edge;
block|}
name|right
operator|->
name|y_left
operator|=
name|y
expr_stmt|;
name|left
operator|->
name|y_right
operator|=
name|y
expr_stmt|;
block|}
name|left
operator|->
name|mark
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|scanline
operator|.
name|old
index|[
name|scanline
operator|.
name|old_size
operator|-
literal|1
index|]
operator|->
name|mark
condition|)
block|{
name|scanline
operator|.
name|old
index|[
name|scanline
operator|.
name|old_size
operator|-
literal|1
index|]
operator|->
name|y_right
operator|=
name|y
expr_stmt|;
name|scanline
operator|.
name|old
index|[
name|scanline
operator|.
name|old_size
operator|-
literal|1
index|]
operator|->
name|mark
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// odd-even fill rule
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scanline
operator|.
name|old_size
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|Edge
modifier|*
name|left
init|=
name|scanline
operator|.
name|old
index|[
name|i
index|]
decl_stmt|;
name|Edge
modifier|*
name|right
init|=
name|scanline
operator|.
name|old
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|emit_clever
operator|||
name|left
operator|->
name|mark
operator|||
name|right
operator|->
name|mark
condition|)
block|{
name|Q27Dot5
name|top
init|=
name|qMax
argument_list|(
name|left
operator|->
name|y_right
argument_list|,
name|right
operator|->
name|y_left
argument_list|)
decl_stmt|;
if|if
condition|(
name|top
operator|!=
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|trap
decl_stmt|;
name|fillTrapezoid
argument_list|(
name|top
argument_list|,
name|y
argument_list|,
name|left
operator|->
name|edge
argument_list|,
name|right
operator|->
name|edge
argument_list|,
name|vertices
argument_list|,
operator|&
name|trap
argument_list|)
expr_stmt|;
name|tessellator
operator|->
name|addTrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
block|}
comment|//                 QDEBUG()<< "    top="<< Q27Dot5ToDouble(top)<< "left="<< left->edge<< "right="<< right->edge;
name|left
operator|->
name|y_left
operator|=
name|y
expr_stmt|;
name|left
operator|->
name|y_right
operator|=
name|y
expr_stmt|;
name|right
operator|->
name|y_left
operator|=
name|y
expr_stmt|;
name|right
operator|->
name|y_right
operator|=
name|y
expr_stmt|;
name|left
operator|->
name|mark
operator|=
name|right
operator|->
name|mark
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|processIntersections
name|void
name|QTessellatorPrivate
operator|::
name|processIntersections
parameter_list|()
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"PROCESS INTERSECTIONS"
expr_stmt|;
comment|// process intersections
while|while
condition|(
operator|!
name|intersections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Intersections
operator|::
name|iterator
name|it
init|=
name|intersections
operator|.
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|key
argument_list|()
operator|.
name|y
operator|!=
name|y
condition|)
break|break;
comment|// swap edges
name|QDEBUG
argument_list|()
operator|<<
literal|"    swapping intersecting edges "
expr_stmt|;
name|int
name|min
init|=
name|scanline
operator|.
name|size
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
name|Q27Dot5
name|xmin
init|=
name|INT_MAX
decl_stmt|;
name|Q27Dot5
name|xmax
init|=
name|INT_MIN
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|Intersection
modifier|&
name|i
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|int
name|next
init|=
name|it
operator|->
name|next
decl_stmt|;
name|int
name|edgePos
init|=
name|scanline
operator|.
name|findEdge
argument_list|(
name|i
operator|.
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|edgePos
operator|>=
literal|0
condition|)
block|{
operator|++
name|num
expr_stmt|;
name|min
operator|=
name|qMin
argument_list|(
name|edgePos
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|max
operator|=
name|qMax
argument_list|(
name|edgePos
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|Edge
modifier|*
name|edge
init|=
name|scanline
operator|.
name|edges
index|[
name|edgePos
index|]
decl_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|edge
operator|->
name|positionAt
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|edge
operator|->
name|positionAt
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Intersection
name|key
decl_stmt|;
name|key
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|key
operator|.
name|edge
operator|=
name|next
expr_stmt|;
name|it
operator|=
name|intersections
operator|.
name|find
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|intersections
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|intersections
operator|.
name|end
argument_list|()
condition|)
break|break;
block|}
if|if
condition|(
name|num
operator|<
literal|2
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
name|min
operator|!=
name|max
argument_list|)
expr_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"sorting between"
operator|<<
name|min
operator|<<
literal|"and"
operator|<<
name|max
operator|<<
literal|"xpos="
operator|<<
name|xmin
operator|<<
name|xmax
expr_stmt|;
while|while
condition|(
name|min
operator|>
literal|0
operator|&&
name|scanline
operator|.
name|edges
index|[
name|min
operator|-
literal|1
index|]
operator|->
name|positionAt
argument_list|(
name|y
argument_list|)
operator|>=
name|xmin
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    adding edge on left"
expr_stmt|;
operator|--
name|min
expr_stmt|;
block|}
while|while
condition|(
name|max
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
operator|&&
name|scanline
operator|.
name|edges
index|[
name|max
operator|+
literal|1
index|]
operator|->
name|positionAt
argument_list|(
name|y
argument_list|)
operator|<=
name|xmax
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    adding edge on right"
expr_stmt|;
operator|++
name|max
expr_stmt|;
block|}
name|qSort
argument_list|(
name|scanline
operator|.
name|edges
operator|+
name|min
argument_list|,
name|scanline
operator|.
name|edges
operator|+
name|max
operator|+
literal|1
argument_list|,
name|EdgeSorter
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|int
name|i
init|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
name|QDEBUG
argument_list|()
operator|<<
literal|"        "
operator|<<
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|edge
operator|<<
literal|"at pos"
operator|<<
name|i
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
block|{
name|Edge
modifier|*
name|edge
init|=
name|scanline
operator|.
name|edges
index|[
name|i
index|]
decl_stmt|;
name|edge
operator|->
name|intersect_left
operator|=
literal|true
expr_stmt|;
name|edge
operator|->
name|intersect_right
operator|=
literal|true
expr_stmt|;
name|edge
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|removeEdges
name|void
name|QTessellatorPrivate
operator|::
name|removeEdges
parameter_list|()
block|{
name|int
name|cv
init|=
name|currentVertex
decl_stmt|;
while|while
condition|(
name|cv
operator|<
name|vertices
operator|.
name|nPoints
condition|)
block|{
specifier|const
name|Vertex
modifier|*
name|v
init|=
name|vertices
operator|.
name|sorted
index|[
name|cv
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|y
operator|>
name|y
condition|)
break|break;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|LineBeforeEnds
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    removing edge"
operator|<<
name|vertices
operator|.
name|prevPos
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|scanline
operator|.
name|findEdge
argument_list|(
name|vertices
operator|.
name|prevPos
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|scanline
operator|.
name|edges
index|[
name|pos
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|-
literal|1
index|]
operator|->
name|intersect_right
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|intersect_left
operator|=
literal|true
expr_stmt|;
name|scanline
operator|.
name|removeAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|LineAfterEnds
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    removing edge"
operator|<<
name|vertices
operator|.
name|position
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|scanline
operator|.
name|findEdge
argument_list|(
name|vertices
operator|.
name|position
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|scanline
operator|.
name|edges
index|[
name|pos
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|-
literal|1
index|]
operator|->
name|intersect_right
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|intersect_left
operator|=
literal|true
expr_stmt|;
name|scanline
operator|.
name|removeAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
operator|++
name|cv
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addEdges
name|void
name|QTessellatorPrivate
operator|::
name|addEdges
parameter_list|()
block|{
while|while
condition|(
name|currentVertex
operator|<
name|vertices
operator|.
name|nPoints
condition|)
block|{
specifier|const
name|Vertex
modifier|*
name|v
init|=
name|vertices
operator|.
name|sorted
index|[
name|currentVertex
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|y
operator|>
name|y
condition|)
break|break;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|LineBeforeStarts
condition|)
block|{
comment|// add new edge
name|int
name|start
init|=
name|vertices
operator|.
name|prevPos
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|Edge
name|e
argument_list|(
name|vertices
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|scanline
operator|.
name|findEdgePosition
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"    adding edge"
operator|<<
name|start
operator|<<
literal|"at position"
operator|<<
name|pos
expr_stmt|;
name|scanline
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mark_clever
operator|||
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|LineAfterEnds
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|-
literal|1
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|LineAfterStarts
condition|)
block|{
name|Edge
name|e
argument_list|(
name|vertices
argument_list|,
name|vertices
operator|.
name|position
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|scanline
operator|.
name|findEdgePosition
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"    adding edge"
operator|<<
name|vertices
operator|.
name|position
argument_list|(
name|v
argument_list|)
operator|<<
literal|"at position"
operator|<<
name|pos
expr_stmt|;
name|scanline
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mark_clever
operator|||
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|LineBeforeEnds
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|-
literal|1
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
condition|)
name|scanline
operator|.
name|edges
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|mark
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|LineAfterHorizontal
condition|)
block|{
name|int
name|pos1
init|=
name|scanline
operator|.
name|findEdgePosition
argument_list|(
name|v
operator|->
name|x
argument_list|,
name|v
operator|->
name|y
argument_list|)
decl_stmt|;
specifier|const
name|Vertex
modifier|*
name|next
init|=
name|vertices
operator|.
name|next
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|v
operator|->
name|y
operator|==
name|next
operator|->
name|y
argument_list|)
expr_stmt|;
name|int
name|pos2
init|=
name|scanline
operator|.
name|findEdgePosition
argument_list|(
name|next
operator|->
name|x
argument_list|,
name|next
operator|->
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos2
operator|<
name|pos1
condition|)
name|qSwap
argument_list|(
name|pos1
argument_list|,
name|pos2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos1
operator|>
literal|0
condition|)
operator|--
name|pos1
expr_stmt|;
if|if
condition|(
name|pos2
operator|==
name|scanline
operator|.
name|size
condition|)
operator|--
name|pos2
expr_stmt|;
comment|//QDEBUG()<< "marking horizontal edge from "<< pos1<< "to"<< pos2;
name|scanline
operator|.
name|markEdges
argument_list|(
name|pos1
argument_list|,
name|pos2
argument_list|)
expr_stmt|;
block|}
operator|++
name|currentVertex
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef
begin_function
DECL|function|checkLinkChain
specifier|static
name|void
name|checkLinkChain
parameter_list|(
specifier|const
name|QTessellatorPrivate
operator|::
name|Intersections
modifier|&
name|intersections
parameter_list|,
name|QTessellatorPrivate
operator|::
name|Intersection
name|i
parameter_list|)
block|{
comment|//     qDebug()<< "              Link chain: ";
name|int
name|end
init|=
name|i
operator|.
name|edge
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|QTessellatorPrivate
operator|::
name|IntersectionLink
name|l
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//         qDebug()<< "                     "<< i.edge<< "next="<< l.next<< "prev="<< l.prev;
if|if
condition|(
name|l
operator|.
name|next
operator|==
name|end
condition|)
break|break;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|next
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|prev
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QTessellatorPrivate
operator|::
name|Intersection
name|i2
init|=
name|i
decl_stmt|;
name|i2
operator|.
name|edge
operator|=
name|l
operator|.
name|next
expr_stmt|;
name|QTessellatorPrivate
operator|::
name|IntersectionLink
name|l2
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|next
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|prev
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|next
operator|==
name|i2
operator|.
name|edge
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|prev
operator|==
name|i
operator|.
name|edge
argument_list|)
expr_stmt|;
name|i
operator|=
name|i2
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|edgeInChain
name|bool
name|QTessellatorPrivate
operator|::
name|edgeInChain
parameter_list|(
name|Intersection
name|i
parameter_list|,
name|int
name|edge
parameter_list|)
block|{
name|int
name|end
init|=
name|i
operator|.
name|edge
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|edge
operator|==
name|edge
condition|)
return|return
literal|true
return|;
name|IntersectionLink
name|l
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|next
operator|==
name|end
condition|)
break|break;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|next
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|prev
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Intersection
name|i2
init|=
name|i
decl_stmt|;
name|i2
operator|.
name|edge
operator|=
name|l
operator|.
name|next
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|IntersectionLink
name|l2
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|next
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|prev
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|next
operator|==
name|i2
operator|.
name|edge
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l2
operator|.
name|prev
operator|==
name|i
operator|.
name|edge
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|i2
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|addIntersection
name|void
name|QTessellatorPrivate
operator|::
name|addIntersection
parameter_list|(
specifier|const
name|Edge
modifier|*
name|e1
parameter_list|,
specifier|const
name|Edge
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|IntersectionLink
name|emptyLink
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|next
init|=
name|vertices
operator|.
name|nextPos
argument_list|(
name|vertices
index|[
name|e1
operator|->
name|edge
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|e2
operator|->
name|edge
operator|==
name|next
condition|)
return|return;
name|int
name|prev
init|=
name|vertices
operator|.
name|prevPos
argument_list|(
name|vertices
index|[
name|e1
operator|->
name|edge
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|e2
operator|->
name|edge
operator|==
name|prev
condition|)
return|return;
name|Q27Dot5
name|yi
decl_stmt|;
name|bool
name|det_positive
decl_stmt|;
name|bool
name|isect
init|=
name|e1
operator|->
name|intersect
argument_list|(
operator|*
name|e2
argument_list|,
operator|&
name|yi
argument_list|,
operator|&
name|det_positive
argument_list|)
decl_stmt|;
name|QDEBUG
argument_list|(
literal|"checking edges %d and %d"
argument_list|,
name|e1
operator|->
name|edge
argument_list|,
name|e2
operator|->
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isect
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    no intersection"
expr_stmt|;
return|return;
block|}
comment|// don't emit an intersection if it's at the start of a line segment or above us
if|if
condition|(
name|yi
operator|<=
name|y
condition|)
block|{
if|if
condition|(
operator|!
name|det_positive
condition|)
return|return;
name|QDEBUG
argument_list|()
operator|<<
literal|"        ----->>>>>> WRONG ORDER!"
expr_stmt|;
name|yi
operator|=
name|y
expr_stmt|;
block|}
name|QDEBUG
argument_list|()
operator|<<
literal|"   between edges "
operator|<<
name|e1
operator|->
name|edge
operator|<<
literal|"and"
operator|<<
name|e2
operator|->
name|edge
operator|<<
literal|"at point ("
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|yi
argument_list|)
operator|<<
literal|')'
expr_stmt|;
name|Intersection
name|i1
decl_stmt|;
name|i1
operator|.
name|y
operator|=
name|yi
expr_stmt|;
name|i1
operator|.
name|edge
operator|=
name|e1
operator|->
name|edge
expr_stmt|;
name|IntersectionLink
name|link1
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i1
argument_list|,
name|emptyLink
argument_list|)
decl_stmt|;
name|Intersection
name|i2
decl_stmt|;
name|i2
operator|.
name|y
operator|=
name|yi
expr_stmt|;
name|i2
operator|.
name|edge
operator|=
name|e2
operator|->
name|edge
expr_stmt|;
name|IntersectionLink
name|link2
init|=
name|intersections
operator|.
name|value
argument_list|(
name|i2
argument_list|,
name|emptyLink
argument_list|)
decl_stmt|;
comment|// new pair of edges
if|if
condition|(
name|link1
operator|.
name|next
operator|==
operator|-
literal|1
operator|&&
name|link2
operator|.
name|next
operator|==
operator|-
literal|1
condition|)
block|{
name|link1
operator|.
name|next
operator|=
name|link1
operator|.
name|prev
operator|=
name|i2
operator|.
name|edge
expr_stmt|;
name|link2
operator|.
name|next
operator|=
name|link2
operator|.
name|prev
operator|=
name|i1
operator|.
name|edge
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link1
operator|.
name|next
operator|==
name|i2
operator|.
name|edge
operator|||
name|link1
operator|.
name|prev
operator|==
name|i2
operator|.
name|edge
operator|||
name|link2
operator|.
name|next
operator|==
name|i1
operator|.
name|edge
operator|||
name|link2
operator|.
name|prev
operator|==
name|i1
operator|.
name|edge
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|edgeInChain
argument_list|(
name|i1
argument_list|,
name|i2
operator|.
name|edge
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
elseif|else
if|if
condition|(
name|link1
operator|.
name|next
operator|==
operator|-
literal|1
operator|||
name|link2
operator|.
name|next
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|link2
operator|.
name|next
operator|==
operator|-
literal|1
condition|)
block|{
name|qSwap
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|link1
operator|.
name|next
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// only i2 in list
name|link1
operator|.
name|next
operator|=
name|i2
operator|.
name|edge
expr_stmt|;
name|link1
operator|.
name|prev
operator|=
name|link2
operator|.
name|prev
expr_stmt|;
name|link2
operator|.
name|prev
operator|=
name|i1
operator|.
name|edge
expr_stmt|;
name|Intersection
name|other
decl_stmt|;
name|other
operator|.
name|y
operator|=
name|yi
expr_stmt|;
name|other
operator|.
name|edge
operator|=
name|link1
operator|.
name|prev
expr_stmt|;
name|IntersectionLink
name|link
init|=
name|intersections
operator|.
name|value
argument_list|(
name|other
argument_list|,
name|emptyLink
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|link
operator|.
name|next
operator|==
name|i2
operator|.
name|edge
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|link
operator|.
name|prev
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|i1
operator|.
name|edge
expr_stmt|;
name|intersections
operator|.
name|insert
argument_list|(
name|other
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|connected
init|=
name|edgeInChain
argument_list|(
name|i1
argument_list|,
name|i2
operator|.
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|connected
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// both already in some list. Have to make sure they are connected
comment|// this can be done by cutting open the ring(s) after the two eges and
comment|// connecting them again
name|Intersection
name|other1
decl_stmt|;
name|other1
operator|.
name|y
operator|=
name|yi
expr_stmt|;
name|other1
operator|.
name|edge
operator|=
name|link1
operator|.
name|next
expr_stmt|;
name|IntersectionLink
name|linko1
init|=
name|intersections
operator|.
name|value
argument_list|(
name|other1
argument_list|,
name|emptyLink
argument_list|)
decl_stmt|;
name|Intersection
name|other2
decl_stmt|;
name|other2
operator|.
name|y
operator|=
name|yi
expr_stmt|;
name|other2
operator|.
name|edge
operator|=
name|link2
operator|.
name|next
expr_stmt|;
name|IntersectionLink
name|linko2
init|=
name|intersections
operator|.
name|value
argument_list|(
name|other2
argument_list|,
name|emptyLink
argument_list|)
decl_stmt|;
name|linko1
operator|.
name|prev
operator|=
name|i2
operator|.
name|edge
expr_stmt|;
name|link2
operator|.
name|next
operator|=
name|other1
operator|.
name|edge
expr_stmt|;
name|linko2
operator|.
name|prev
operator|=
name|i1
operator|.
name|edge
expr_stmt|;
name|link1
operator|.
name|next
operator|=
name|other2
operator|.
name|edge
expr_stmt|;
name|intersections
operator|.
name|insert
argument_list|(
name|other1
argument_list|,
name|linko1
argument_list|)
expr_stmt|;
name|intersections
operator|.
name|insert
argument_list|(
name|other2
argument_list|,
name|linko2
argument_list|)
expr_stmt|;
block|}
name|intersections
operator|.
name|insert
argument_list|(
name|i1
argument_list|,
name|link1
argument_list|)
expr_stmt|;
name|intersections
operator|.
name|insert
argument_list|(
name|i2
argument_list|,
name|link2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|checkLinkChain
argument_list|(
name|intersections
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|edgeInChain
argument_list|(
name|i1
argument_list|,
name|i2
operator|.
name|edge
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function
begin_function
DECL|function|addIntersections
name|void
name|QTessellatorPrivate
operator|::
name|addIntersections
parameter_list|()
block|{
if|if
condition|(
name|scanline
operator|.
name|size
condition|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"INTERSECTIONS"
expr_stmt|;
comment|// check marked edges for intersections
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scanline
operator|.
name|size
condition|;
operator|++
name|i
control|)
block|{
name|Edge
modifier|*
name|e
init|=
name|scanline
operator|.
name|edges
index|[
name|i
index|]
decl_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"    "
operator|<<
name|i
operator|<<
name|e
operator|->
name|edge
operator|<<
literal|"isect=("
operator|<<
name|e
operator|->
name|intersect_left
operator|<<
name|e
operator|->
name|intersect_right
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scanline
operator|.
name|size
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Edge
modifier|*
name|e1
init|=
name|scanline
operator|.
name|edges
index|[
name|i
index|]
decl_stmt|;
name|Edge
modifier|*
name|e2
init|=
name|scanline
operator|.
name|edges
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
comment|// check for intersection
if|if
condition|(
name|e1
operator|->
name|intersect_right
operator|||
name|e2
operator|->
name|intersect_left
condition|)
name|addIntersection
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (intersections.constBegin().key().y == y) {         QDEBUG()<< "----------------> intersection on same line";         scanline.clearMarks();         scanline.processIntersections(y,&intersections);         goto redo;     }
endif|#
directive|endif
block|}
end_function
begin_constructor
DECL|function|QTessellator
name|QTessellator
operator|::
name|QTessellator
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QTessellatorPrivate
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QTessellator
name|QTessellator
operator|::
name|~
name|QTessellator
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setWinding
name|void
name|QTessellator
operator|::
name|setWinding
parameter_list|(
name|bool
name|w
parameter_list|)
block|{
name|d
operator|->
name|winding
operator|=
name|w
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tessellate
name|QRectF
name|QTessellator
operator|::
name|tessellate
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|nPoints
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|points
index|[
literal|0
index|]
operator|==
name|points
index|[
name|nPoints
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|--
name|nPoints
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|QDEBUG
argument_list|()
operator|<<
literal|"POINTS:"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPoints
condition|;
operator|++
name|i
control|)
block|{
name|QDEBUG
argument_list|()
operator|<<
name|points
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|// collect edges and calculate bounds
name|d
operator|->
name|vertices
operator|.
name|nPoints
operator|=
name|nPoints
expr_stmt|;
name|d
operator|->
name|vertices
operator|.
name|init
argument_list|(
name|nPoints
argument_list|)
expr_stmt|;
name|int
name|maxActiveEdges
init|=
literal|0
decl_stmt|;
name|QRectF
name|br
init|=
name|d
operator|->
name|collectAndSortVertices
argument_list|(
name|points
argument_list|,
operator|&
name|maxActiveEdges
argument_list|)
decl_stmt|;
name|d
operator|->
name|cancelCoincidingEdges
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|QDEBUG
argument_list|()
operator|<<
literal|"nPoints = "
operator|<<
name|nPoints
operator|<<
literal|"using "
operator|<<
name|d
operator|->
name|vertices
operator|.
name|nPoints
expr_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"VERTICES:"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|vertices
operator|.
name|nPoints
condition|;
operator|++
name|i
control|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"    "
operator|<<
name|i
operator|<<
literal|": "
operator|<<
literal|"point="
operator|<<
name|d
operator|->
name|vertices
operator|.
name|position
argument_list|(
name|d
operator|->
name|vertices
operator|.
name|sorted
index|[
name|i
index|]
argument_list|)
operator|<<
literal|"flags="
operator|<<
name|d
operator|->
name|vertices
operator|.
name|sorted
index|[
name|i
index|]
operator|->
name|flags
operator|<<
literal|"pos=("
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|vertices
operator|.
name|sorted
index|[
name|i
index|]
operator|->
name|x
argument_list|)
operator|<<
literal|'/'
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|vertices
operator|.
name|sorted
index|[
name|i
index|]
operator|->
name|y
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|scanline
operator|.
name|init
argument_list|(
name|maxActiveEdges
argument_list|)
expr_stmt|;
name|d
operator|->
name|y
operator|=
name|INT_MIN
operator|/
literal|256
expr_stmt|;
name|d
operator|->
name|currentVertex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|currentVertex
operator|<
name|d
operator|->
name|vertices
operator|.
name|nPoints
condition|)
block|{
name|d
operator|->
name|scanline
operator|.
name|clearMarks
argument_list|()
expr_stmt|;
name|d
operator|->
name|y
operator|=
name|d
operator|->
name|vertices
operator|.
name|sorted
index|[
name|d
operator|->
name|currentVertex
index|]
operator|->
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|intersections
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|y
operator|=
name|qMin
argument_list|(
name|d
operator|->
name|y
argument_list|,
name|d
operator|->
name|intersections
operator|.
name|constBegin
argument_list|()
operator|.
name|key
argument_list|()
operator|.
name|y
argument_list|)
expr_stmt|;
name|QDEBUG
argument_list|()
operator|<<
literal|"===== SCANLINE: y ="
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|y
argument_list|)
operator|<<
literal|" ====="
expr_stmt|;
name|d
operator|->
name|scanline
operator|.
name|prepareLine
argument_list|()
expr_stmt|;
name|d
operator|->
name|processIntersections
argument_list|()
expr_stmt|;
name|d
operator|->
name|removeEdges
argument_list|()
expr_stmt|;
name|d
operator|->
name|addEdges
argument_list|()
expr_stmt|;
name|d
operator|->
name|addIntersections
argument_list|()
expr_stmt|;
name|d
operator|->
name|emitEdges
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|scanline
operator|.
name|lineDone
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|QDEBUG
argument_list|()
operator|<<
literal|"===== edges:"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|scanline
operator|.
name|size
condition|;
operator|++
name|i
control|)
block|{
name|QDEBUG
argument_list|()
operator|<<
literal|"   "
operator|<<
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|edge
operator|<<
literal|"p0= ("
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|v0
operator|->
name|x
argument_list|)
operator|<<
literal|'/'
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|v0
operator|->
name|y
argument_list|)
operator|<<
literal|") p1= ("
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|v1
operator|->
name|x
argument_list|)
operator|<<
literal|'/'
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|v1
operator|->
name|y
argument_list|)
operator|<<
literal|')'
operator|<<
literal|"x="
operator|<<
name|Q27Dot5ToDouble
argument_list|(
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|positionAt
argument_list|(
name|d
operator|->
name|y
argument_list|)
argument_list|)
operator|<<
literal|"isLeftOfNext="
operator|<<
operator|(
operator|(
name|i
operator|<
name|d
operator|->
name|scanline
operator|.
name|size
operator|-
literal|1
operator|)
condition|?
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
index|]
operator|->
name|isLeftOf
argument_list|(
operator|*
name|d
operator|->
name|scanline
operator|.
name|edges
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|d
operator|->
name|y
argument_list|)
else|:
literal|true
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|d
operator|->
name|scanline
operator|.
name|done
argument_list|()
expr_stmt|;
name|d
operator|->
name|intersections
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|br
return|;
block|}
end_function
begin_comment
comment|// tessellates the given convex polygon
end_comment
begin_function
DECL|function|tessellateConvex
name|void
name|QTessellator
operator|::
name|tessellateConvex
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|nPoints
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|points
index|[
literal|0
index|]
operator|==
name|points
index|[
name|nPoints
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|--
name|nPoints
expr_stmt|;
name|d
operator|->
name|vertices
operator|.
name|nPoints
operator|=
name|nPoints
expr_stmt|;
name|d
operator|->
name|vertices
operator|.
name|init
argument_list|(
name|nPoints
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nPoints
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|vertices
index|[
name|i
index|]
operator|->
name|x
operator|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|vertices
index|[
name|i
index|]
operator|->
name|y
operator|=
name|FloatToQ27Dot5
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|left
init|=
literal|0
decl_stmt|,
name|right
init|=
literal|0
decl_stmt|;
name|int
name|top
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nPoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|vertices
index|[
name|i
index|]
operator|->
name|y
operator|<
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|y
condition|)
name|top
operator|=
name|i
expr_stmt|;
block|}
name|left
operator|=
operator|(
name|top
operator|+
name|nPoints
operator|-
literal|1
operator|)
operator|%
name|nPoints
expr_stmt|;
name|right
operator|=
operator|(
name|top
operator|+
literal|1
operator|)
operator|%
name|nPoints
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|x
operator|==
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|x
operator|&&
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
name|left
operator|=
operator|(
name|left
operator|+
name|nPoints
operator|-
literal|1
operator|)
operator|%
name|nPoints
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|x
operator|==
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|x
operator|&&
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
name|right
operator|=
operator|(
name|right
operator|+
literal|1
operator|)
operator|%
name|nPoints
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|right
condition|)
return|return;
name|int
name|dir
init|=
literal|1
decl_stmt|;
name|Vertex
name|dLeft
init|=
block|{
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|x
operator|-
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|x
block|,
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|y
operator|-
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
block|}
decl_stmt|;
name|Vertex
name|dRight
init|=
block|{
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|x
operator|-
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|x
block|,
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
operator|-
name|d
operator|->
name|vertices
index|[
name|top
index|]
operator|->
name|y
block|}
decl_stmt|;
name|Q27Dot5
name|cross
init|=
name|dLeft
operator|.
name|x
operator|*
name|dRight
operator|.
name|y
operator|-
name|dLeft
operator|.
name|y
operator|*
name|dRight
operator|.
name|x
decl_stmt|;
comment|// flip direction if polygon is clockwise
if|if
condition|(
name|cross
operator|<
literal|0
operator|||
operator|(
name|cross
operator|==
literal|0
operator|&&
name|dLeft
operator|.
name|x
operator|>
literal|0
operator|)
condition|)
block|{
name|qSwap
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|Vertex
modifier|*
name|lastLeft
init|=
name|d
operator|->
name|vertices
index|[
name|top
index|]
decl_stmt|;
name|Vertex
modifier|*
name|lastRight
init|=
name|d
operator|->
name|vertices
index|[
name|top
index|]
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|trap
decl_stmt|;
while|while
condition|(
name|lastLeft
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
block|{
name|lastLeft
operator|=
name|d
operator|->
name|vertices
index|[
name|left
index|]
expr_stmt|;
name|left
operator|=
operator|(
name|left
operator|+
name|nPoints
operator|-
name|dir
operator|)
operator|%
name|nPoints
expr_stmt|;
block|}
while|while
condition|(
name|lastRight
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
block|{
name|lastRight
operator|=
name|d
operator|->
name|vertices
index|[
name|right
index|]
expr_stmt|;
name|right
operator|=
operator|(
name|right
operator|+
name|nPoints
operator|+
name|dir
operator|)
operator|%
name|nPoints
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|trap
operator|.
name|top
operator|=
name|qMax
argument_list|(
name|lastRight
operator|->
name|y
argument_list|,
name|lastLeft
operator|->
name|y
argument_list|)
expr_stmt|;
name|trap
operator|.
name|bottom
operator|=
name|qMin
argument_list|(
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
argument_list|,
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
argument_list|)
expr_stmt|;
name|trap
operator|.
name|topLeft
operator|=
name|lastLeft
expr_stmt|;
name|trap
operator|.
name|topRight
operator|=
name|lastRight
expr_stmt|;
name|trap
operator|.
name|bottomLeft
operator|=
name|d
operator|->
name|vertices
index|[
name|left
index|]
expr_stmt|;
name|trap
operator|.
name|bottomRight
operator|=
name|d
operator|->
name|vertices
index|[
name|right
index|]
expr_stmt|;
if|if
condition|(
name|trap
operator|.
name|bottom
operator|>
name|trap
operator|.
name|top
condition|)
name|addTrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|right
condition|)
break|break;
if|if
condition|(
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
operator|<
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
condition|)
block|{
do|do
block|{
name|lastRight
operator|=
name|d
operator|->
name|vertices
index|[
name|right
index|]
expr_stmt|;
name|right
operator|=
operator|(
name|right
operator|+
name|nPoints
operator|+
name|dir
operator|)
operator|%
name|nPoints
expr_stmt|;
block|}
do|while
condition|(
name|lastRight
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|right
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|lastLeft
operator|=
name|d
operator|->
name|vertices
index|[
name|left
index|]
expr_stmt|;
name|left
operator|=
operator|(
name|left
operator|+
name|nPoints
operator|-
name|dir
operator|)
operator|%
name|nPoints
expr_stmt|;
block|}
do|while
condition|(
name|lastLeft
operator|->
name|y
operator|==
name|d
operator|->
name|vertices
index|[
name|left
index|]
operator|->
name|y
operator|&&
name|left
operator|!=
name|right
condition|)
do|;
block|}
block|}
block|}
end_function
begin_comment
comment|// tessellates the stroke of the line from a_ to b_ with the given width and a flat cap
end_comment
begin_function
DECL|function|tessellateRect
name|void
name|QTessellator
operator|::
name|tessellateRect
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|a_
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|b_
parameter_list|,
name|qreal
name|width
parameter_list|)
block|{
name|Vertex
name|a
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|a_
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|a_.y()
argument_list|)
block|}
decl_stmt|;
name|Vertex
name|b
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|b_
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|b_.y()
argument_list|)
block|}
decl_stmt|;
name|QPointF
name|pa
init|=
name|a_
decl_stmt|,
name|pb
init|=
name|b_
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|y
operator|>
name|b
operator|.
name|y
condition|)
block|{
name|qSwap
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|pa
argument_list|,
name|pb
argument_list|)
expr_stmt|;
block|}
name|Vertex
name|delta
init|=
block|{
name|b
operator|.
name|x
operator|-
name|a
operator|.
name|x
block|,
name|b
operator|.
name|y
operator|-
name|a
operator|.
name|y
block|}
decl_stmt|;
if|if
condition|(
name|delta
operator|.
name|x
operator|==
literal|0
operator|&&
name|delta
operator|.
name|y
operator|==
literal|0
condition|)
return|return;
name|qreal
name|hw
init|=
literal|0.5
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|delta
operator|.
name|x
operator|==
literal|0
condition|)
block|{
name|Q27Dot5
name|halfWidth
init|=
name|FloatToQ27Dot5
argument_list|(
name|hw
argument_list|)
decl_stmt|;
if|if
condition|(
name|halfWidth
operator|==
literal|0
condition|)
return|return;
name|Vertex
name|topLeft
init|=
block|{
name|a
operator|.
name|x
operator|-
name|halfWidth
block|,
name|a
operator|.
name|y
block|}
decl_stmt|;
name|Vertex
name|topRight
init|=
block|{
name|a
operator|.
name|x
operator|+
name|halfWidth
block|,
name|a
operator|.
name|y
block|}
decl_stmt|;
name|Vertex
name|bottomLeft
init|=
block|{
name|a
operator|.
name|x
operator|-
name|halfWidth
block|,
name|b
operator|.
name|y
block|}
decl_stmt|;
name|Vertex
name|bottomRight
init|=
block|{
name|a
operator|.
name|x
operator|+
name|halfWidth
block|,
name|b
operator|.
name|y
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|trap
init|=
block|{
name|topLeft
operator|.
name|y
block|,
name|bottomLeft
operator|.
name|y
block|,
operator|&
name|topLeft
block|,
operator|&
name|bottomLeft
block|,
operator|&
name|topRight
block|,
operator|&
name|bottomRight
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|.
name|y
operator|==
literal|0
condition|)
block|{
name|Q27Dot5
name|halfWidth
init|=
name|FloatToQ27Dot5
argument_list|(
name|hw
argument_list|)
decl_stmt|;
if|if
condition|(
name|halfWidth
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|a
operator|.
name|x
operator|>
name|b
operator|.
name|x
condition|)
name|qSwap
argument_list|(
name|a
operator|.
name|x
argument_list|,
name|b
operator|.
name|x
argument_list|)
expr_stmt|;
name|Vertex
name|topLeft
init|=
block|{
name|a
operator|.
name|x
block|,
name|a
operator|.
name|y
operator|-
name|halfWidth
block|}
decl_stmt|;
name|Vertex
name|topRight
init|=
block|{
name|b
operator|.
name|x
block|,
name|a
operator|.
name|y
operator|-
name|halfWidth
block|}
decl_stmt|;
name|Vertex
name|bottomLeft
init|=
block|{
name|a
operator|.
name|x
block|,
name|a
operator|.
name|y
operator|+
name|halfWidth
block|}
decl_stmt|;
name|Vertex
name|bottomRight
init|=
block|{
name|b
operator|.
name|x
block|,
name|a
operator|.
name|y
operator|+
name|halfWidth
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|trap
init|=
block|{
name|topLeft
operator|.
name|y
block|,
name|bottomLeft
operator|.
name|y
block|,
operator|&
name|topLeft
block|,
operator|&
name|bottomLeft
block|,
operator|&
name|topRight
block|,
operator|&
name|bottomRight
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|perp
argument_list|(
name|pb
operator|.
name|y
argument_list|()
operator|-
name|pa
operator|.
name|y
argument_list|()
argument_list|,
name|pa
operator|.
name|x
argument_list|()
operator|-
name|pb
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|length
init|=
name|qSqrt
argument_list|(
name|perp
operator|.
name|x
argument_list|()
operator|*
name|perp
operator|.
name|x
argument_list|()
operator|+
name|perp
operator|.
name|y
argument_list|()
operator|*
name|perp
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|length
argument_list|)
condition|)
return|return;
comment|// need the half of the width
name|perp
operator|*=
name|hw
operator|/
name|length
expr_stmt|;
name|QPointF
name|pta
init|=
name|pa
operator|+
name|perp
decl_stmt|;
name|QPointF
name|ptb
init|=
name|pa
operator|-
name|perp
decl_stmt|;
name|QPointF
name|ptc
init|=
name|pb
operator|-
name|perp
decl_stmt|;
name|QPointF
name|ptd
init|=
name|pb
operator|+
name|perp
decl_stmt|;
name|Vertex
name|ta
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|pta
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|pta.y()
argument_list|)
block|}
decl_stmt|;
name|Vertex
name|tb
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|ptb
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|ptb.y()
argument_list|)
block|}
decl_stmt|;
name|Vertex
name|tc
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|ptc
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|ptc.y()
argument_list|)
block|}
decl_stmt|;
name|Vertex
name|td
init|=
block|{
name|FloatToQ27Dot5
argument_list|(
name|ptd
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|FloatToQ27Dot5
argument_list|(
argument|ptd.y()
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|ta
operator|.
name|y
operator|<
name|tb
operator|.
name|y
condition|)
block|{
if|if
condition|(
name|tb
operator|.
name|y
operator|<
name|td
operator|.
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|top
init|=
block|{
name|ta
operator|.
name|y
block|,
name|tb
operator|.
name|y
block|,
operator|&
name|ta
block|,
operator|&
name|tb
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|bottom
init|=
block|{
name|td
operator|.
name|y
block|,
name|tc
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|td
block|,
operator|&
name|tc
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|addTrap
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|middle
init|=
block|{
name|tb
operator|.
name|y
block|,
name|td
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|middle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTessellator
operator|::
name|Trapezoid
name|top
init|=
block|{
name|ta
operator|.
name|y
block|,
name|td
operator|.
name|y
block|,
operator|&
name|ta
block|,
operator|&
name|tb
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|bottom
init|=
block|{
name|tb
operator|.
name|y
block|,
name|tc
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|td
block|,
operator|&
name|tc
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|addTrap
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|.
name|y
operator|!=
name|td
operator|.
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|middle
init|=
block|{
name|td
operator|.
name|y
block|,
name|tb
operator|.
name|y
block|,
operator|&
name|ta
block|,
operator|&
name|tb
block|,
operator|&
name|td
block|,
operator|&
name|tc
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|middle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|ta
operator|.
name|y
operator|<
name|tc
operator|.
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|top
init|=
block|{
name|tb
operator|.
name|y
block|,
name|ta
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|tb
block|,
operator|&
name|ta
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|bottom
init|=
block|{
name|tc
operator|.
name|y
block|,
name|td
operator|.
name|y
block|,
operator|&
name|tc
block|,
operator|&
name|td
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|addTrap
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|middle
init|=
block|{
name|ta
operator|.
name|y
block|,
name|tc
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|middle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTessellator
operator|::
name|Trapezoid
name|top
init|=
block|{
name|tb
operator|.
name|y
block|,
name|tc
operator|.
name|y
block|,
operator|&
name|tb
block|,
operator|&
name|tc
block|,
operator|&
name|tb
block|,
operator|&
name|ta
block|}
decl_stmt|;
name|QTessellator
operator|::
name|Trapezoid
name|bottom
init|=
block|{
name|ta
operator|.
name|y
block|,
name|td
operator|.
name|y
block|,
operator|&
name|tc
block|,
operator|&
name|td
block|,
operator|&
name|ta
block|,
operator|&
name|td
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|addTrap
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|.
name|y
operator|!=
name|tc
operator|.
name|y
condition|)
block|{
name|QTessellator
operator|::
name|Trapezoid
name|middle
init|=
block|{
name|tc
operator|.
name|y
block|,
name|ta
operator|.
name|y
block|,
operator|&
name|tc
block|,
operator|&
name|td
block|,
operator|&
name|tb
block|,
operator|&
name|ta
block|}
decl_stmt|;
name|addTrap
argument_list|(
name|middle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
