begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDeclarative module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpathsimplifier_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qglobal.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qpoint.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qalgorithms.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_include
include|#
directive|include
file|<private/qopengl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qrbtree_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|Q_FIXED_POINT_SCALE
define|#
directive|define
name|Q_FIXED_POINT_SCALE
value|256
DECL|macro|Q_TRIANGULATE_END_OF_POLYGON
define|#
directive|define
name|Q_TRIANGULATE_END_OF_POLYGON
value|quint32(-1)
comment|//============================================================================//
comment|//                                   QPoint                                   //
comment|//============================================================================//
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|y
argument_list|()
operator|<
name|b
operator|.
name|y
argument_list|()
operator|||
operator|(
name|a
operator|.
name|y
argument_list|()
operator|==
name|b
operator|.
name|y
argument_list|()
operator|&&
name|a
operator|.
name|x
argument_list|()
operator|<
name|b
operator|.
name|x
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator >
specifier|inline
name|bool
name|operator
name|>
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|b
parameter_list|)
block|{
return|return
name|b
operator|<
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <=
specifier|inline
name|bool
name|operator
name|<=
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|b
parameter_list|)
block|{
return|return
operator|!
operator|(
name|a
operator|>
name|b
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator >=
specifier|inline
name|bool
name|operator
name|>=
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|b
parameter_list|)
block|{
return|return
operator|!
operator|(
name|a
operator|<
name|b
operator|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|cross
specifier|inline
name|int
name|cross
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|)
block|{
return|return
name|u
operator|.
name|x
argument_list|()
operator|*
name|v
operator|.
name|y
argument_list|()
operator|-
name|u
operator|.
name|y
argument_list|()
operator|*
name|v
operator|.
name|x
argument_list|()
return|;
block|}
DECL|function|dot
specifier|inline
name|int
name|dot
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|)
block|{
return|return
name|u
operator|.
name|x
argument_list|()
operator|*
name|v
operator|.
name|x
argument_list|()
operator|+
name|u
operator|.
name|y
argument_list|()
operator|*
name|v
operator|.
name|y
argument_list|()
return|;
block|}
comment|//============================================================================//
comment|//                                  Fraction                                  //
comment|//============================================================================//
comment|// Fraction must be in the range [0, 1)
DECL|struct|Fraction
struct|struct
name|Fraction
block|{
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|denominator
operator|!=
literal|0
return|;
block|}
comment|// numerator and denominator must not have common denominators.
DECL|member|numerator
DECL|member|denominator
name|unsigned
name|int
name|numerator
decl_stmt|,
name|denominator
decl_stmt|;
block|}
struct|;
DECL|function|gcd
specifier|inline
name|unsigned
name|int
name|gcd
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|)
block|{
while|while
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|z
init|=
name|y
decl_stmt|;
name|y
operator|=
name|x
operator|%
name|y
expr_stmt|;
name|x
operator|=
name|z
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|// Fraction must be in the range [0, 1)
comment|// Assume input is valid.
DECL|function|fraction
name|Fraction
name|fraction
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
name|d
parameter_list|)
block|{
name|Fraction
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|numerator
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|denominator
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|g
init|=
name|gcd
argument_list|(
name|n
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|result
operator|.
name|numerator
operator|=
name|n
operator|/
name|g
expr_stmt|;
name|result
operator|.
name|denominator
operator|=
name|d
operator|/
name|g
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|//============================================================================//
comment|//                                  Rational                                  //
comment|//============================================================================//
DECL|struct|Rational
struct|struct
name|Rational
block|{
DECL|member|integer
name|int
name|integer
decl_stmt|;
DECL|member|fraction
name|Fraction
name|fraction
decl_stmt|;
block|}
struct|;
comment|//============================================================================//
comment|//                             IntersectionPoint                              //
comment|//============================================================================//
DECL|struct|IntersectionPoint
struct|struct
name|IntersectionPoint
block|{
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|x
operator|.
name|fraction
operator|.
name|isValid
argument_list|()
operator|&&
name|y
operator|.
name|fraction
operator|.
name|isValid
argument_list|()
return|;
block|}
name|QPoint
name|round
parameter_list|()
specifier|const
function_decl|;
DECL|function|isAccurate
name|bool
name|isAccurate
parameter_list|()
specifier|const
block|{
return|return
name|x
operator|.
name|fraction
operator|.
name|numerator
operator|==
literal|0
operator|&&
name|y
operator|.
name|fraction
operator|.
name|numerator
operator|==
literal|0
return|;
block|}
DECL|member|x
name|Rational
name|x
decl_stmt|;
comment|// 8:8 signed, 32/32
DECL|member|y
name|Rational
name|y
decl_stmt|;
comment|// 8:8 signed, 32/32
block|}
struct|;
DECL|function|round
name|QPoint
name|IntersectionPoint
operator|::
name|round
parameter_list|()
specifier|const
block|{
name|QPoint
name|result
argument_list|(
name|x
operator|.
name|integer
argument_list|,
name|y
operator|.
name|integer
argument_list|)
decl_stmt|;
if|if
condition|(
literal|2
operator|*
name|x
operator|.
name|fraction
operator|.
name|numerator
operator|>=
name|x
operator|.
name|fraction
operator|.
name|denominator
condition|)
operator|++
name|result
operator|.
name|rx
argument_list|()
expr_stmt|;
if|if
condition|(
literal|2
operator|*
name|y
operator|.
name|fraction
operator|.
name|numerator
operator|>=
name|y
operator|.
name|fraction
operator|.
name|denominator
condition|)
operator|++
name|result
operator|.
name|ry
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Return positive value if 'p' is to the right of the line 'v1'->'v2', negative if left of the
comment|// line and zero if exactly on the line.
comment|// The returned value is the z-component of the qCross product between 'v2-v1' and 'p-v1',
comment|// which is twice the signed area of the triangle 'p'->'v1'->'v2' (positive for CW order).
DECL|function|pointDistanceFromLine
specifier|inline
name|int
name|pointDistanceFromLine
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v2
parameter_list|)
block|{
return|return
name|cross
argument_list|(
name|v2
operator|-
name|v1
argument_list|,
name|p
operator|-
name|v1
argument_list|)
return|;
block|}
DECL|function|intersectionPoint
name|IntersectionPoint
name|intersectionPoint
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|u2
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v2
parameter_list|)
block|{
name|IntersectionPoint
name|result
init|=
block|{
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
name|QPoint
name|u
init|=
name|u2
operator|-
name|u1
decl_stmt|;
name|QPoint
name|v
init|=
name|v2
operator|-
name|v1
decl_stmt|;
name|int
name|d1
init|=
name|cross
argument_list|(
name|u
argument_list|,
name|v1
operator|-
name|u1
argument_list|)
decl_stmt|;
name|int
name|d2
init|=
name|cross
argument_list|(
name|u
argument_list|,
name|v2
operator|-
name|u1
argument_list|)
decl_stmt|;
name|int
name|det
init|=
name|d2
operator|-
name|d1
decl_stmt|;
name|int
name|d3
init|=
name|cross
argument_list|(
name|v
argument_list|,
name|u1
operator|-
name|v1
argument_list|)
decl_stmt|;
name|int
name|d4
init|=
name|d3
operator|-
name|det
decl_stmt|;
comment|//qCross(v, u2 - v1);
comment|// Check that the math is correct.
name|Q_ASSERT
argument_list|(
name|d4
operator|==
name|cross
argument_list|(
name|v
argument_list|,
name|u2
operator|-
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// The intersection point can be expressed as:
comment|// v1 - v * d1/det
comment|// v2 - v * d2/det
comment|// u1 + u * d3/det
comment|// u2 + u * d4/det
comment|// I'm only interested in lines that are crossing, so ignore parallel lines even if they overlap.
if|if
condition|(
name|det
operator|==
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|det
operator|<
literal|0
condition|)
block|{
name|det
operator|=
operator|-
name|det
expr_stmt|;
name|d1
operator|=
operator|-
name|d1
expr_stmt|;
name|d2
operator|=
operator|-
name|d2
expr_stmt|;
name|d3
operator|=
operator|-
name|d3
expr_stmt|;
name|d4
operator|=
operator|-
name|d4
expr_stmt|;
block|}
comment|// I'm only interested in lines intersecting at their interior, not at their end points.
comment|// The lines intersect at their interior if and only if 'd1< 0', 'd2> 0', 'd3< 0' and 'd4> 0'.
if|if
condition|(
name|d1
operator|>=
literal|0
operator|||
name|d2
operator|<=
literal|0
operator|||
name|d3
operator|<=
literal|0
operator|||
name|d4
operator|>=
literal|0
condition|)
return|return
name|result
return|;
comment|// Calculate the intersection point as follows:
comment|// v1 - v * d1/det | v1<= v2 (component-wise)
comment|// v2 - v * d2/det | v2< v1 (component-wise)
comment|// Assuming 16 bits per vector component.
if|if
condition|(
name|v
operator|.
name|x
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|x
operator|.
name|integer
operator|=
name|v1
operator|.
name|x
argument_list|()
operator|+
name|int
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
operator|*
name|d1
operator|/
name|det
argument_list|)
expr_stmt|;
name|result
operator|.
name|x
operator|.
name|fraction
operator|=
name|fraction
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
operator|*
name|d1
operator|%
name|det
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|det
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|x
operator|.
name|integer
operator|=
name|v2
operator|.
name|x
argument_list|()
operator|+
name|int
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
operator|*
name|d2
operator|/
name|det
argument_list|)
expr_stmt|;
name|result
operator|.
name|x
operator|.
name|fraction
operator|=
name|fraction
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
operator|*
name|d2
operator|%
name|det
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|det
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|.
name|y
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|y
operator|.
name|integer
operator|=
name|v1
operator|.
name|y
argument_list|()
operator|+
name|int
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|)
operator|*
name|d1
operator|/
name|det
argument_list|)
expr_stmt|;
name|result
operator|.
name|y
operator|.
name|fraction
operator|=
name|fraction
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|)
operator|*
name|d1
operator|%
name|det
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|det
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|y
operator|.
name|integer
operator|=
name|v2
operator|.
name|y
argument_list|()
operator|+
name|int
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|)
operator|*
name|d2
operator|/
name|det
argument_list|)
expr_stmt|;
name|result
operator|.
name|y
operator|.
name|fraction
operator|=
name|fraction
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|qint64
argument_list|(
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|)
operator|*
name|d2
operator|%
name|det
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|det
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|result
operator|.
name|x
operator|.
name|fraction
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|result
operator|.
name|y
operator|.
name|fraction
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|//============================================================================//
comment|//                               PathSimplifier                               //
comment|//============================================================================//
DECL|class|PathSimplifier
class|class
name|PathSimplifier
block|{
public|public:
name|PathSimplifier
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|QDataBuffer
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|vertices
parameter_list|,
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
modifier|&
name|indices
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
constructor_decl|;
private|private:
struct_decl|struct
name|Element
struct_decl|;
DECL|class|BoundingVolumeHierarchy
class|class
name|BoundingVolumeHierarchy
block|{
public|public:
DECL|struct|Node
struct|struct
name|Node
block|{
DECL|enum|Type
enum|enum
name|Type
block|{
DECL|enumerator|Leaf
name|Leaf
block|,
DECL|enumerator|Split
name|Split
block|}
enum|;
DECL|member|type
name|Type
name|type
decl_stmt|;
DECL|member|minimum
name|QPoint
name|minimum
decl_stmt|;
DECL|member|maximum
name|QPoint
name|maximum
decl_stmt|;
union|union
block|{
DECL|member|element
name|Element
modifier|*
name|element
decl_stmt|;
comment|// type == Leaf
DECL|member|left
name|Node
modifier|*
name|left
decl_stmt|;
comment|// type == Split
block|}
union|;
DECL|member|right
name|Node
modifier|*
name|right
decl_stmt|;
block|}
struct|;
name|BoundingVolumeHierarchy
parameter_list|()
constructor_decl|;
name|~
name|BoundingVolumeHierarchy
parameter_list|()
destructor_decl|;
name|void
name|allocate
parameter_list|(
name|int
name|nodeCount
parameter_list|)
function_decl|;
name|void
name|free
parameter_list|()
function_decl|;
name|Node
modifier|*
name|newNode
parameter_list|()
function_decl|;
DECL|member|root
name|Node
modifier|*
name|root
decl_stmt|;
private|private:
name|void
name|freeNode
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
function_decl|;
DECL|member|nodeBlock
name|Node
modifier|*
name|nodeBlock
decl_stmt|;
DECL|member|blockSize
name|int
name|blockSize
decl_stmt|;
DECL|member|firstFree
name|int
name|firstFree
decl_stmt|;
block|}
class|;
DECL|struct|Element
struct|struct
name|Element
block|{
DECL|enum|Degree
enum|enum
name|Degree
block|{
DECL|enumerator|Line
name|Line
init|=
literal|1
block|,
DECL|enumerator|Quadratic
name|Quadratic
init|=
literal|2
block|,
DECL|enumerator|Cubic
name|Cubic
init|=
literal|3
block|}
enum|;
DECL|function|upperIndex
name|quint32
modifier|&
name|upperIndex
parameter_list|()
block|{
return|return
name|indices
index|[
name|pointingUp
condition|?
name|degree
else|:
literal|0
index|]
return|;
block|}
DECL|function|lowerIndex
name|quint32
modifier|&
name|lowerIndex
parameter_list|()
block|{
return|return
name|indices
index|[
name|pointingUp
condition|?
literal|0
else|:
name|degree
index|]
return|;
block|}
DECL|function|upperIndex
name|quint32
name|upperIndex
parameter_list|()
specifier|const
block|{
return|return
name|indices
index|[
name|pointingUp
condition|?
name|degree
else|:
literal|0
index|]
return|;
block|}
DECL|function|lowerIndex
name|quint32
name|lowerIndex
parameter_list|()
specifier|const
block|{
return|return
name|indices
index|[
name|pointingUp
condition|?
literal|0
else|:
name|degree
index|]
return|;
block|}
name|void
name|flip
parameter_list|()
function_decl|;
DECL|member|middle
name|QPoint
name|middle
decl_stmt|;
DECL|member|indices
name|quint32
name|indices
index|[
literal|4
index|]
decl_stmt|;
comment|// index to points
DECL|member|next
DECL|member|previous
name|Element
modifier|*
name|next
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
comment|// used in connectElements()
DECL|member|winding
name|int
name|winding
decl_stmt|;
comment|// used in connectElements()
union|union
block|{
DECL|member|edgeNode
name|QRBTree
argument_list|<
name|Element
modifier|*
argument_list|>
operator|::
name|Node
modifier|*
name|edgeNode
decl_stmt|;
comment|// used in connectElements()
DECL|member|bvhNode
name|BoundingVolumeHierarchy
operator|::
name|Node
modifier|*
name|bvhNode
decl_stmt|;
block|}
union|;
DECL|member|degree
name|Degree
name|degree
range|:
literal|8
decl_stmt|;
DECL|member|processed
name|uint
name|processed
range|:
literal|1
decl_stmt|;
comment|// initially false, true when the element has been checked for intersections.
DECL|member|pointingUp
name|uint
name|pointingUp
range|:
literal|1
decl_stmt|;
comment|// used in connectElements()
DECL|member|originallyPointingUp
name|uint
name|originallyPointingUp
range|:
literal|1
decl_stmt|;
comment|// used in connectElements()
block|}
struct|;
DECL|class|ElementAllocator
class|class
name|ElementAllocator
block|{
public|public:
name|ElementAllocator
parameter_list|()
constructor_decl|;
name|~
name|ElementAllocator
parameter_list|()
destructor_decl|;
name|void
name|allocate
parameter_list|(
name|int
name|count
parameter_list|)
function_decl|;
name|Element
modifier|*
name|newElement
parameter_list|()
function_decl|;
private|private:
DECL|struct|ElementBlock
struct|struct
name|ElementBlock
block|{
DECL|member|next
name|ElementBlock
modifier|*
name|next
decl_stmt|;
DECL|member|blockSize
name|int
name|blockSize
decl_stmt|;
DECL|member|firstFree
name|int
name|firstFree
decl_stmt|;
DECL|member|elements
name|Element
name|elements
index|[
literal|1
index|]
decl_stmt|;
DECL|member|blocks
block|}
modifier|*
name|blocks
struct|;
block|}
class|;
DECL|struct|Event
struct|struct
name|Event
block|{
DECL|enum|Type
DECL|enumerator|Upper
DECL|enumerator|Lower
enum|enum
name|Type
block|{
name|Upper
block|,
name|Lower
block|}
enum|;
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Event
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
DECL|member|point
name|QPoint
name|point
decl_stmt|;
DECL|member|type
name|Type
name|type
decl_stmt|;
DECL|member|element
name|Element
modifier|*
name|element
decl_stmt|;
block|}
struct|;
DECL|typedef|RBNode
typedef|typedef
name|QRBTree
argument_list|<
name|Element
modifier|*
argument_list|>
operator|::
name|Node
name|RBNode
typedef|;
DECL|typedef|BVHNode
typedef|typedef
name|BoundingVolumeHierarchy
operator|::
name|Node
name|BVHNode
typedef|;
name|void
name|initElements
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
function_decl|;
name|void
name|removeIntersections
parameter_list|()
function_decl|;
name|void
name|connectElements
parameter_list|()
function_decl|;
name|void
name|fillIndices
parameter_list|()
function_decl|;
name|BVHNode
modifier|*
name|buildTree
parameter_list|(
name|Element
modifier|*
modifier|*
name|elements
parameter_list|,
name|int
name|elementCount
parameter_list|)
function_decl|;
name|bool
name|intersectNodes
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|elementNode
parameter_list|,
name|BVHNode
modifier|*
name|treeNode
parameter_list|)
function_decl|;
name|bool
name|equalElements
parameter_list|(
specifier|const
name|Element
modifier|*
name|e1
parameter_list|,
specifier|const
name|Element
modifier|*
name|e2
parameter_list|)
function_decl|;
name|bool
name|splitLineAt
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|node
parameter_list|,
name|quint32
name|pointIndex
parameter_list|,
name|bool
name|processAgain
parameter_list|)
function_decl|;
name|void
name|appendSeparatingAxes
parameter_list|(
name|QVarLengthArray
argument_list|<
name|QPoint
argument_list|,
literal|12
argument_list|>
modifier|&
name|axes
parameter_list|,
name|Element
modifier|*
name|element
parameter_list|)
function_decl|;
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|calculateSeparatingAxisRange
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|axis
parameter_list|,
name|Element
modifier|*
name|element
parameter_list|)
function_decl|;
name|void
name|splitCurve
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|node
parameter_list|)
function_decl|;
name|bool
name|setElementToQuadratic
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
function_decl|;
name|bool
name|setElementToCubic
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl2
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
function_decl|;
name|void
name|setElementToCubicAndSimplify
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl2
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
function_decl|;
name|RBNode
modifier|*
name|findElementLeftOf
parameter_list|(
specifier|const
name|Element
modifier|*
name|element
parameter_list|,
specifier|const
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
modifier|&
name|bounds
parameter_list|)
function_decl|;
name|bool
name|elementIsLeftOf
parameter_list|(
specifier|const
name|Element
modifier|*
name|left
parameter_list|,
specifier|const
name|Element
modifier|*
name|right
parameter_list|)
function_decl|;
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
name|outerBounds
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
function_decl|;
specifier|static
name|bool
name|flattenQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|)
function_decl|;
specifier|static
name|bool
name|flattenCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|)
function_decl|;
specifier|static
name|bool
name|splitQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
name|QPoint
modifier|*
name|result
parameter_list|)
function_decl|;
specifier|static
name|bool
name|splitCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|,
name|QPoint
modifier|*
name|result
parameter_list|)
function_decl|;
name|void
name|subDivQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|)
function_decl|;
name|void
name|subDivCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|)
function_decl|;
specifier|static
name|void
name|sortEvents
parameter_list|(
name|Event
modifier|*
name|events
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
DECL|member|m_elementAllocator
name|ElementAllocator
name|m_elementAllocator
decl_stmt|;
DECL|member|m_elements
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
name|m_elements
decl_stmt|;
DECL|member|m_points
name|QDataBuffer
argument_list|<
name|QPoint
argument_list|>
modifier|*
name|m_points
decl_stmt|;
DECL|member|m_bvh
name|BoundingVolumeHierarchy
name|m_bvh
decl_stmt|;
DECL|member|m_indices
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
modifier|*
name|m_indices
decl_stmt|;
DECL|member|m_elementList
name|QRBTree
argument_list|<
name|Element
modifier|*
argument_list|>
name|m_elementList
decl_stmt|;
DECL|member|m_hints
name|uint
name|m_hints
decl_stmt|;
block|}
class|;
DECL|function|BoundingVolumeHierarchy
specifier|inline
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|BoundingVolumeHierarchy
parameter_list|()
member_init_list|:
name|root
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|nodeBlock
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|blockSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|firstFree
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~BoundingVolumeHierarchy
specifier|inline
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|~
name|BoundingVolumeHierarchy
parameter_list|()
block|{
name|free
argument_list|()
expr_stmt|;
block|}
DECL|function|allocate
specifier|inline
name|void
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|allocate
parameter_list|(
name|int
name|nodeCount
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|nodeBlock
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|firstFree
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nodeBlock
operator|=
operator|new
name|Node
index|[
name|blockSize
operator|=
name|nodeCount
index|]
expr_stmt|;
block|}
DECL|function|free
specifier|inline
name|void
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|free
parameter_list|()
block|{
name|freeNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|nodeBlock
expr_stmt|;
name|nodeBlock
operator|=
literal|0
expr_stmt|;
name|firstFree
operator|=
name|blockSize
operator|=
literal|0
expr_stmt|;
name|root
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|newNode
specifier|inline
name|PathSimplifier
operator|::
name|BVHNode
modifier|*
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|newNode
parameter_list|()
block|{
if|if
condition|(
name|firstFree
operator|<
name|blockSize
condition|)
return|return
operator|&
name|nodeBlock
index|[
name|firstFree
operator|++
index|]
return|;
return|return
operator|new
name|Node
return|;
block|}
DECL|function|freeNode
specifier|inline
name|void
name|PathSimplifier
operator|::
name|BoundingVolumeHierarchy
operator|::
name|freeNode
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|n
operator|->
name|type
operator|==
name|Node
operator|::
name|Split
operator|||
name|n
operator|->
name|type
operator|==
name|Node
operator|::
name|Leaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node
operator|::
name|Split
condition|)
block|{
name|freeNode
argument_list|(
name|n
operator|->
name|left
argument_list|)
expr_stmt|;
name|freeNode
argument_list|(
name|n
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|n
operator|>=
name|nodeBlock
operator|&&
name|n
operator|<
name|nodeBlock
operator|+
name|blockSize
operator|)
condition|)
operator|delete
name|n
expr_stmt|;
block|}
DECL|function|ElementAllocator
specifier|inline
name|PathSimplifier
operator|::
name|ElementAllocator
operator|::
name|ElementAllocator
parameter_list|()
member_init_list|:
name|blocks
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~ElementAllocator
specifier|inline
name|PathSimplifier
operator|::
name|ElementAllocator
operator|::
name|~
name|ElementAllocator
parameter_list|()
block|{
while|while
condition|(
name|blocks
condition|)
block|{
name|ElementBlock
modifier|*
name|block
init|=
name|blocks
decl_stmt|;
name|blocks
operator|=
name|blocks
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|allocate
specifier|inline
name|void
name|PathSimplifier
operator|::
name|ElementAllocator
operator|::
name|allocate
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|blocks
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
name|ElementBlock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ElementBlock
argument_list|)
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Element
argument_list|)
argument_list|)
expr_stmt|;
name|blocks
operator|->
name|blockSize
operator|=
name|count
expr_stmt|;
name|blocks
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|blocks
operator|->
name|firstFree
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|newElement
specifier|inline
name|PathSimplifier
operator|::
name|Element
modifier|*
name|PathSimplifier
operator|::
name|ElementAllocator
operator|::
name|newElement
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|->
name|firstFree
operator|<
name|blocks
operator|->
name|blockSize
condition|)
return|return
operator|&
name|blocks
operator|->
name|elements
index|[
name|blocks
operator|->
name|firstFree
operator|++
index|]
return|;
name|ElementBlock
modifier|*
name|oldBlock
init|=
name|blocks
decl_stmt|;
name|blocks
operator|=
operator|(
name|ElementBlock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ElementBlock
argument_list|)
operator|+
operator|(
name|oldBlock
operator|->
name|blockSize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Element
argument_list|)
argument_list|)
expr_stmt|;
name|blocks
operator|->
name|blockSize
operator|=
name|oldBlock
operator|->
name|blockSize
expr_stmt|;
name|blocks
operator|->
name|next
operator|=
name|oldBlock
expr_stmt|;
name|blocks
operator|->
name|firstFree
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|blocks
operator|->
name|elements
index|[
name|blocks
operator|->
name|firstFree
operator|++
index|]
return|;
block|}
DECL|function|operator <
specifier|inline
name|bool
name|PathSimplifier
operator|::
name|Event
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|Event
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|point
operator|==
name|other
operator|.
name|point
condition|)
return|return
name|type
operator|<
name|other
operator|.
name|type
return|;
return|return
name|other
operator|.
name|point
operator|<
name|point
return|;
block|}
DECL|function|flip
specifier|inline
name|void
name|PathSimplifier
operator|::
name|Element
operator|::
name|flip
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
operator|(
name|degree
operator|+
literal|1
operator|)
argument_list|>
operator|>
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
name|degree
operator|>=
name|Line
operator|&&
name|degree
operator|<=
name|Cubic
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|degree
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|indices
index|[
name|i
index|]
argument_list|,
name|indices
index|[
name|degree
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pointingUp
operator|=
operator|!
name|pointingUp
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|next
operator|==
literal|0
operator|&&
name|previous
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|PathSimplifier
name|PathSimplifier
operator|::
name|PathSimplifier
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|QDataBuffer
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|vertices
parameter_list|,
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
modifier|&
name|indices
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
member_init_list|:
name|m_elements
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_points
argument_list|(
operator|&
name|vertices
argument_list|)
member_init_list|,
name|m_indices
argument_list|(
operator|&
name|indices
argument_list|)
block|{
name|m_points
operator|->
name|reset
argument_list|()
expr_stmt|;
name|m_indices
operator|->
name|reset
argument_list|()
expr_stmt|;
name|initElements
argument_list|(
name|path
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_elements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeIntersections
argument_list|()
expr_stmt|;
name|connectElements
argument_list|()
expr_stmt|;
name|fillIndices
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|initElements
name|void
name|PathSimplifier
operator|::
name|initElements
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|m_hints
operator|=
name|path
operator|.
name|hints
argument_list|()
expr_stmt|;
name|int
name|pathElementCount
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathElementCount
operator|==
literal|0
condition|)
return|return;
name|m_elements
operator|.
name|reserve
argument_list|(
literal|2
operator|*
name|pathElementCount
argument_list|)
expr_stmt|;
name|m_elementAllocator
operator|.
name|allocate
argument_list|(
literal|2
operator|*
name|pathElementCount
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|reserve
argument_list|(
literal|2
operator|*
name|pathElementCount
argument_list|)
expr_stmt|;
specifier|const
name|QPainterPath
operator|::
name|ElementType
modifier|*
name|e
init|=
name|path
operator|.
name|elements
argument_list|()
decl_stmt|;
specifier|const
name|qreal
modifier|*
name|p
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|quint32
name|moveToIndex
init|=
literal|0
decl_stmt|;
name|quint32
name|previousIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pathElementCount
condition|;
operator|++
name|i
operator|,
operator|++
name|e
operator|,
name|p
operator|+=
literal|2
control|)
block|{
switch|switch
condition|(
operator|*
name|e
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
if|if
condition|(
operator|!
name|m_points
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QPoint
modifier|&
name|from
init|=
name|m_points
operator|->
name|at
argument_list|(
name|previousIndex
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|to
init|=
name|m_points
operator|->
name|at
argument_list|(
name|moveToIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|previousIndex
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|moveToIndex
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|from
operator|.
name|x
argument_list|()
operator|+
name|to
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|from
operator|.
name|y
argument_list|()
operator|+
name|to
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|previousIndex
operator|=
name|moveToIndex
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|to
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|Q_ASSERT
argument_list|(
operator|!
name|m_points
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|{
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|to
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|from
init|=
name|m_points
operator|->
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|to
operator|!=
name|from
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|previousIndex
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|quint32
argument_list|(
name|m_points
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|from
operator|.
name|x
argument_list|()
operator|+
name|to
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|from
operator|.
name|y
argument_list|()
operator|+
name|to
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|previousIndex
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
name|Q_ASSERT
argument_list|(
name|i
operator|+
literal|2
operator|<
name|pathElementCount
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|m_points
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|e
index|[
literal|1
index|]
operator|==
name|QPainterPath
operator|::
name|CurveToDataElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|e
index|[
literal|2
index|]
operator|==
name|QPainterPath
operator|::
name|CurveToDataElement
argument_list|)
expr_stmt|;
block|{
name|quint32
name|startPointIndex
init|=
name|previousIndex
decl_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|end
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
name|previousIndex
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|// See if this cubic bezier is really quadratic.
name|qreal
name|x1
init|=
name|p
index|[
operator|-
literal|2
index|]
operator|+
name|qreal
argument_list|(
literal|1.5
argument_list|)
operator|*
operator|(
name|p
index|[
literal|0
index|]
operator|-
name|p
index|[
operator|-
literal|2
index|]
operator|)
decl_stmt|;
name|qreal
name|y1
init|=
name|p
index|[
operator|-
literal|1
index|]
operator|+
name|qreal
argument_list|(
literal|1.5
argument_list|)
operator|*
operator|(
name|p
index|[
literal|1
index|]
operator|-
name|p
index|[
operator|-
literal|1
index|]
operator|)
decl_stmt|;
name|qreal
name|x2
init|=
name|p
index|[
literal|4
index|]
operator|+
name|qreal
argument_list|(
literal|1.5
argument_list|)
operator|*
operator|(
name|p
index|[
literal|2
index|]
operator|-
name|p
index|[
literal|4
index|]
operator|)
decl_stmt|;
name|qreal
name|y2
init|=
name|p
index|[
literal|5
index|]
operator|+
name|qreal
argument_list|(
literal|1.5
argument_list|)
operator|*
operator|(
name|p
index|[
literal|3
index|]
operator|-
name|p
index|[
literal|5
index|]
operator|)
decl_stmt|;
name|Element
modifier|*
name|element
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
operator|<
name|qreal
argument_list|(
literal|1e-3
argument_list|)
operator|&&
name|qAbs
argument_list|(
name|y1
operator|-
name|y2
argument_list|)
operator|<
name|qreal
argument_list|(
literal|1e-3
argument_list|)
condition|)
block|{
comment|// The bezier curve is quadratic.
name|matrix
operator|.
name|map
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|ctrl
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
name|setElementToQuadratic
argument_list|(
name|element
argument_list|,
name|startPointIndex
argument_list|,
name|ctrl
argument_list|,
name|previousIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The bezier curve is cubic.
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|ctrl1
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|ctrl2
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
name|setElementToCubicAndSimplify
argument_list|(
name|element
argument_list|,
name|startPointIndex
argument_list|,
name|ctrl1
argument_list|,
name|ctrl2
argument_list|,
name|previousIndex
argument_list|)
expr_stmt|;
block|}
name|m_elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
name|e
operator|+=
literal|2
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|0
argument_list|,
literal|"QSGPathSimplifier::initialize"
argument_list|,
literal|"Unexpected element type."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|m_points
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QPoint
modifier|&
name|from
init|=
name|m_points
operator|->
name|at
argument_list|(
name|previousIndex
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|to
init|=
name|m_points
operator|->
name|at
argument_list|(
name|moveToIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|previousIndex
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|moveToIndex
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|from
operator|.
name|x
argument_list|()
operator|+
name|to
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|from
operator|.
name|y
argument_list|()
operator|+
name|to
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pathElementCount
condition|;
operator|++
name|i
operator|,
name|p
operator|+=
literal|2
control|)
block|{
name|matrix
operator|.
name|map
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|QPoint
name|to
argument_list|(
name|qRound
argument_list|(
name|x
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
operator|*
name|Q_FIXED_POINT_SCALE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|to
operator|!=
name|m_points
operator|->
name|last
argument_list|()
condition|)
name|m_points
operator|->
name|add
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|m_points
operator|->
name|isEmpty
argument_list|()
operator|&&
name|m_points
operator|->
name|last
argument_list|()
operator|==
name|m_points
operator|->
name|first
argument_list|()
condition|)
name|m_points
operator|->
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_points
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
name|quint32
name|prev
init|=
name|quint32
argument_list|(
name|m_points
operator|->
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_points
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPoint
modifier|&
name|to
init|=
name|m_points
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QPoint
modifier|&
name|from
init|=
name|m_points
operator|->
name|at
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|Element
modifier|*
name|element
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|prev
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|quint32
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|from
operator|.
name|x
argument_list|()
operator|+
name|to
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|from
operator|.
name|y
argument_list|()
operator|+
name|to
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|prev
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|processed
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|removeIntersections
name|void
name|PathSimplifier
operator|::
name|removeIntersections
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
name|elements
argument_list|(
name|m_elements
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|elements
operator|.
name|add
argument_list|(
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|m_bvh
operator|.
name|allocate
argument_list|(
literal|2
operator|*
name|m_elements
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_bvh
operator|.
name|root
operator|=
name|buildTree
argument_list|(
name|elements
operator|.
name|data
argument_list|()
argument_list|,
name|elements
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|elements
operator|.
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|elements
operator|.
name|add
argument_list|(
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|elements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|elements
operator|.
name|last
argument_list|()
decl_stmt|;
name|elements
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|BVHNode
modifier|*
name|node
init|=
name|element
operator|->
name|bvhNode
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|node
operator|->
name|type
operator|==
name|BVHNode
operator|::
name|Leaf
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|node
operator|->
name|element
operator|==
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|element
operator|->
name|processed
condition|)
block|{
if|if
condition|(
operator|!
name|intersectNodes
argument_list|(
name|elements
argument_list|,
name|node
argument_list|,
name|m_bvh
operator|.
name|root
argument_list|)
condition|)
name|element
operator|->
name|processed
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|m_bvh
operator|.
name|free
argument_list|()
expr_stmt|;
comment|// The bounding volume hierarchy is not needed anymore.
block|}
DECL|function|connectElements
name|void
name|PathSimplifier
operator|::
name|connectElements
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|Event
argument_list|>
name|events
argument_list|(
name|m_elements
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Element
modifier|*
name|element
init|=
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|element
operator|->
name|next
operator|=
name|element
operator|->
name|previous
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|winding
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|edgeNode
operator|=
literal|0
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
name|element
operator|->
name|degree
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|!=
name|v
condition|)
block|{
name|element
operator|->
name|pointingUp
operator|=
name|element
operator|->
name|originallyPointingUp
operator|=
name|v
operator|<
name|u
expr_stmt|;
name|Event
name|event
decl_stmt|;
name|event
operator|.
name|element
operator|=
name|element
expr_stmt|;
name|event
operator|.
name|point
operator|=
name|u
expr_stmt|;
name|event
operator|.
name|type
operator|=
name|element
operator|->
name|pointingUp
condition|?
name|Event
operator|::
name|Lower
else|:
name|Event
operator|::
name|Upper
expr_stmt|;
name|events
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|event
operator|.
name|point
operator|=
name|v
expr_stmt|;
name|event
operator|.
name|type
operator|=
name|element
operator|->
name|pointingUp
condition|?
name|Event
operator|::
name|Upper
else|:
name|Event
operator|::
name|Lower
expr_stmt|;
name|events
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
name|QVarLengthArray
argument_list|<
name|Element
modifier|*
argument_list|,
literal|8
argument_list|>
name|orderedElements
decl_stmt|;
if|if
condition|(
operator|!
name|events
operator|.
name|isEmpty
argument_list|()
condition|)
name|sortEvents
argument_list|(
name|events
operator|.
name|data
argument_list|()
argument_list|,
name|events
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|events
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|Event
modifier|*
name|event
init|=
operator|&
name|events
operator|.
name|last
argument_list|()
decl_stmt|;
name|QPoint
name|eventPoint
init|=
name|event
operator|->
name|point
decl_stmt|;
comment|// Find all elements passing through the event point.
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
name|bounds
init|=
name|outerBounds
argument_list|(
name|eventPoint
argument_list|)
decl_stmt|;
comment|// Special case: single element above and single element below event point.
name|int
name|eventCount
init|=
name|events
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|Event
operator|::
name|Lower
operator|&&
name|eventCount
operator|>
literal|2
condition|)
block|{
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
name|range
decl_stmt|;
name|range
operator|.
name|first
operator|=
name|bounds
operator|.
name|first
condition|?
name|m_elementList
operator|.
name|next
argument_list|(
name|bounds
operator|.
name|first
argument_list|)
else|:
name|m_elementList
operator|.
name|front
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
expr_stmt|;
name|range
operator|.
name|second
operator|=
name|bounds
operator|.
name|second
condition|?
name|m_elementList
operator|.
name|previous
argument_list|(
name|bounds
operator|.
name|second
argument_list|)
else|:
name|m_elementList
operator|.
name|back
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
expr_stmt|;
specifier|const
name|Event
modifier|*
name|event2
init|=
operator|&
name|events
operator|.
name|at
argument_list|(
name|eventCount
operator|-
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|Event
modifier|*
name|event3
init|=
operator|&
name|events
operator|.
name|at
argument_list|(
name|eventCount
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|event2
operator|->
name|point
operator|==
name|eventPoint
argument_list|)
expr_stmt|;
comment|// There are always at least two events at a point.
if|if
condition|(
name|range
operator|.
name|first
operator|==
name|range
operator|.
name|second
operator|&&
name|event2
operator|->
name|type
operator|==
name|Event
operator|::
name|Upper
operator|&&
name|event3
operator|->
name|point
operator|!=
name|eventPoint
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|event
operator|->
name|element
decl_stmt|;
name|Element
modifier|*
name|element2
init|=
name|event2
operator|->
name|element
decl_stmt|;
name|element
operator|->
name|edgeNode
operator|->
name|data
operator|=
name|event2
operator|->
name|element
expr_stmt|;
name|element2
operator|->
name|edgeNode
operator|=
name|element
operator|->
name|edgeNode
expr_stmt|;
name|element
operator|->
name|edgeNode
operator|=
literal|0
expr_stmt|;
name|events
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|events
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
name|element2
operator|->
name|pointingUp
operator|!=
name|element
operator|->
name|pointingUp
condition|)
name|element2
operator|->
name|flip
argument_list|()
expr_stmt|;
name|element2
operator|->
name|winding
operator|=
name|element
operator|->
name|winding
expr_stmt|;
name|int
name|winding
init|=
name|element
operator|->
name|winding
decl_stmt|;
if|if
condition|(
name|element
operator|->
name|originallyPointingUp
condition|)
operator|++
name|winding
expr_stmt|;
if|if
condition|(
name|winding
operator|==
literal|0
operator|||
name|winding
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|element
operator|->
name|pointingUp
condition|)
block|{
name|element
operator|->
name|previous
operator|=
name|event2
operator|->
name|element
expr_stmt|;
name|element2
operator|->
name|next
operator|=
name|event
operator|->
name|element
expr_stmt|;
block|}
else|else
block|{
name|element
operator|->
name|next
operator|=
name|event2
operator|->
name|element
expr_stmt|;
name|element2
operator|->
name|previous
operator|=
name|event
operator|->
name|element
expr_stmt|;
block|}
block|}
continue|continue;
block|}
block|}
name|orderedElements
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// First, find the ones above the event point.
if|if
condition|(
name|m_elementList
operator|.
name|root
condition|)
block|{
name|RBNode
modifier|*
name|current
init|=
name|bounds
operator|.
name|first
condition|?
name|m_elementList
operator|.
name|next
argument_list|(
name|bounds
operator|.
name|first
argument_list|)
else|:
name|m_elementList
operator|.
name|front
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
decl_stmt|;
while|while
condition|(
name|current
operator|!=
name|bounds
operator|.
name|second
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
name|int
name|winding
init|=
name|element
operator|->
name|winding
decl_stmt|;
if|if
condition|(
name|element
operator|->
name|originallyPointingUp
condition|)
operator|++
name|winding
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|lower
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lower
operator|==
name|eventPoint
condition|)
block|{
if|if
condition|(
name|winding
operator|==
literal|0
operator|||
name|winding
operator|==
literal|1
condition|)
name|orderedElements
operator|.
name|append
argument_list|(
name|current
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The element is passing through 'event.point'.
name|Q_ASSERT
argument_list|(
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
operator|!=
name|eventPoint
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
argument_list|)
expr_stmt|;
comment|// Split the line.
name|Element
modifier|*
name|eventElement
init|=
name|event
operator|->
name|element
decl_stmt|;
name|int
name|indexIndex
init|=
operator|(
name|event
operator|->
name|type
operator|==
name|Event
operator|::
name|Upper
operator|)
operator|==
name|eventElement
operator|->
name|pointingUp
condition|?
name|eventElement
operator|->
name|degree
else|:
literal|0
decl_stmt|;
name|quint32
name|pointIndex
init|=
name|eventElement
operator|->
name|indices
index|[
name|indexIndex
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|eventPoint
operator|==
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex
argument_list|)
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|upperElement
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
operator|*
name|upperElement
operator|=
operator|*
name|element
expr_stmt|;
name|upperElement
operator|->
name|lowerIndex
argument_list|()
operator|=
name|element
operator|->
name|upperIndex
argument_list|()
operator|=
name|pointIndex
expr_stmt|;
name|upperElement
operator|->
name|edgeNode
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|next
operator|=
name|element
operator|->
name|previous
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|upperElement
operator|->
name|next
condition|)
name|upperElement
operator|->
name|next
operator|->
name|previous
operator|=
name|upperElement
expr_stmt|;
elseif|else
if|if
condition|(
name|upperElement
operator|->
name|previous
condition|)
name|upperElement
operator|->
name|previous
operator|->
name|next
operator|=
name|upperElement
expr_stmt|;
if|if
condition|(
name|element
operator|->
name|pointingUp
operator|!=
name|element
operator|->
name|originallyPointingUp
condition|)
name|element
operator|->
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
name|winding
operator|==
literal|0
operator|||
name|winding
operator|==
literal|1
condition|)
name|orderedElements
operator|.
name|append
argument_list|(
name|upperElement
argument_list|)
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|upperElement
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
name|m_elementList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|events
operator|.
name|isEmpty
argument_list|()
operator|&&
name|events
operator|.
name|last
argument_list|()
operator|.
name|point
operator|==
name|eventPoint
condition|)
block|{
name|event
operator|=
operator|&
name|events
operator|.
name|last
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|Event
operator|::
name|Upper
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|event
operator|->
name|point
operator|==
name|m_points
operator|->
name|at
argument_list|(
name|event
operator|->
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|RBNode
modifier|*
name|left
init|=
name|findElementLeftOf
argument_list|(
name|event
operator|->
name|element
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
name|RBNode
modifier|*
name|node
init|=
name|m_elementList
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|node
operator|->
name|data
operator|=
name|event
operator|->
name|element
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
operator|->
name|element
operator|->
name|edgeNode
operator|==
literal|0
argument_list|)
expr_stmt|;
name|event
operator|->
name|element
operator|->
name|edgeNode
operator|=
name|node
expr_stmt|;
name|m_elementList
operator|.
name|attachAfter
argument_list|(
name|left
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|event
operator|->
name|type
operator|==
name|Event
operator|::
name|Lower
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
operator|->
name|point
operator|==
name|m_points
operator|->
name|at
argument_list|(
name|event
operator|->
name|element
operator|->
name|lowerIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|element
init|=
name|event
operator|->
name|element
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
argument_list|)
expr_stmt|;
name|m_elementList
operator|.
name|deleteNode
argument_list|(
name|element
operator|->
name|edgeNode
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|events
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|m_elementList
operator|.
name|root
condition|)
block|{
name|RBNode
modifier|*
name|current
init|=
name|bounds
operator|.
name|first
condition|?
name|m_elementList
operator|.
name|next
argument_list|(
name|bounds
operator|.
name|first
argument_list|)
else|:
name|m_elementList
operator|.
name|front
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
decl_stmt|;
name|int
name|winding
init|=
name|bounds
operator|.
name|first
condition|?
name|bounds
operator|.
name|first
operator|->
name|data
operator|->
name|winding
else|:
literal|0
decl_stmt|;
comment|// Calculate winding numbers and flip elements if necessary.
while|while
condition|(
name|current
operator|!=
name|bounds
operator|.
name|second
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
name|int
name|ccw
init|=
name|winding
operator|&
literal|1
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|pointingUp
operator|==
name|element
operator|->
name|originallyPointingUp
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|->
name|originallyPointingUp
condition|)
block|{
operator|--
name|winding
expr_stmt|;
block|}
else|else
block|{
operator|++
name|winding
expr_stmt|;
name|ccw
operator|^=
literal|1
expr_stmt|;
block|}
name|element
operator|->
name|winding
operator|=
name|winding
expr_stmt|;
if|if
condition|(
name|ccw
operator|==
literal|0
condition|)
name|element
operator|->
name|flip
argument_list|()
expr_stmt|;
name|current
operator|=
name|m_elementList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|// Pick elements with correct winding number.
name|current
operator|=
name|bounds
operator|.
name|second
condition|?
name|m_elementList
operator|.
name|previous
argument_list|(
name|bounds
operator|.
name|second
argument_list|)
else|:
name|m_elementList
operator|.
name|back
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|bounds
operator|.
name|first
condition|)
block|{
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
operator|==
name|eventPoint
argument_list|)
expr_stmt|;
name|int
name|winding
init|=
name|element
operator|->
name|winding
decl_stmt|;
if|if
condition|(
name|element
operator|->
name|originallyPointingUp
condition|)
operator|++
name|winding
expr_stmt|;
if|if
condition|(
name|winding
operator|==
literal|0
operator|||
name|winding
operator|==
literal|1
condition|)
name|orderedElements
operator|.
name|append
argument_list|(
name|current
operator|->
name|data
argument_list|)
expr_stmt|;
name|current
operator|=
name|m_elementList
operator|.
name|previous
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|orderedElements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|(
name|orderedElements
operator|.
name|size
argument_list|()
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Element
modifier|*
name|firstElement
init|=
name|orderedElements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_points
operator|->
name|at
argument_list|(
name|firstElement
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
operator|!=
name|eventPoint
condition|)
block|{
name|orderedElements
operator|.
name|append
argument_list|(
name|firstElement
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|orderedElements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|+
literal|1
operator|<
name|orderedElements
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|next
init|=
name|orderedElements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Element
modifier|*
name|previous
init|=
name|orderedElements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|next
operator|->
name|previous
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|previous
operator|->
name|next
operator|==
literal|0
argument_list|)
expr_stmt|;
name|next
operator|->
name|previous
operator|=
name|previous
expr_stmt|;
name|previous
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|*
name|element
init|=
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|next
operator|==
literal|0
operator|||
name|element
operator|->
name|next
operator|->
name|previous
operator|==
name|element
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|previous
operator|==
literal|0
operator|||
name|element
operator|->
name|previous
operator|->
name|next
operator|==
name|element
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|(
name|element
operator|->
name|next
operator|==
literal|0
operator|)
operator|==
operator|(
name|element
operator|->
name|previous
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
DECL|function|fillIndices
name|void
name|PathSimplifier
operator|::
name|fillIndices
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|processed
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Element
modifier|*
name|element
init|=
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|->
name|processed
operator|||
name|element
operator|->
name|next
operator|==
literal|0
condition|)
continue|continue;
do|do
block|{
name|m_indices
operator|->
name|add
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|element
operator|->
name|degree
condition|)
block|{
case|case
name|Element
operator|::
name|Quadratic
case|:
block|{
name|QPoint
name|pts
index|[]
init|=
block|{
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
block|,
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
block|,
name|m_points
operator|->
name|at
argument_list|(
argument|element->indices[
literal|2
argument|]
argument_list|)
block|}
decl_stmt|;
name|subDivQuadratic
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Element
operator|::
name|Cubic
case|:
block|{
name|QPoint
name|pts
index|[]
init|=
block|{
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
block|,
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
block|,
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
block|,
name|m_points
operator|->
name|at
argument_list|(
argument|element->indices[
literal|3
argument|]
argument_list|)
block|}
decl_stmt|;
name|subDivCubic
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|,
name|pts
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|next
argument_list|)
expr_stmt|;
name|element
operator|->
name|processed
operator|=
literal|true
expr_stmt|;
name|element
operator|=
name|element
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|element
operator|!=
name|m_elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
do|;
name|m_indices
operator|->
name|add
argument_list|(
name|Q_TRIANGULATE_END_OF_POLYGON
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|buildTree
name|PathSimplifier
operator|::
name|BVHNode
modifier|*
name|PathSimplifier
operator|::
name|buildTree
parameter_list|(
name|Element
modifier|*
modifier|*
name|elements
parameter_list|,
name|int
name|elementCount
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|elementCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BVHNode
modifier|*
name|node
init|=
name|m_bvh
operator|.
name|newNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementCount
operator|==
literal|1
condition|)
block|{
name|Element
modifier|*
name|element
init|=
operator|*
name|elements
decl_stmt|;
name|element
operator|->
name|bvhNode
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Leaf
expr_stmt|;
name|node
operator|->
name|element
operator|=
name|element
expr_stmt|;
name|node
operator|->
name|minimum
operator|=
name|node
operator|->
name|maximum
operator|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|element
operator|->
name|degree
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPoint
modifier|&
name|p
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|node
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|qMin
argument_list|(
name|node
operator|->
name|minimum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|qMin
argument_list|(
name|node
operator|->
name|minimum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|qMax
argument_list|(
name|node
operator|->
name|maximum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|qMax
argument_list|(
name|node
operator|->
name|maximum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
name|node
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Split
expr_stmt|;
name|QPoint
name|minimum
decl_stmt|,
name|maximum
decl_stmt|;
name|minimum
operator|=
name|maximum
operator|=
name|elements
index|[
literal|0
index|]
operator|->
name|middle
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|elementCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPoint
modifier|&
name|p
init|=
name|elements
index|[
name|i
index|]
operator|->
name|middle
decl_stmt|;
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|qMin
argument_list|(
name|minimum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|qMin
argument_list|(
name|minimum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|qMax
argument_list|(
name|maximum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|qMax
argument_list|(
name|maximum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|comp
decl_stmt|,
name|pivot
decl_stmt|;
if|if
condition|(
name|maximum
operator|.
name|x
argument_list|()
operator|-
name|minimum
operator|.
name|x
argument_list|()
operator|>
name|maximum
operator|.
name|y
argument_list|()
operator|-
name|minimum
operator|.
name|y
argument_list|()
condition|)
block|{
name|comp
operator|=
literal|0
expr_stmt|;
name|pivot
operator|=
operator|(
name|maximum
operator|.
name|x
argument_list|()
operator|+
name|minimum
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
literal|1
expr_stmt|;
name|pivot
operator|=
operator|(
name|maximum
operator|.
name|y
argument_list|()
operator|+
name|minimum
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
name|int
name|lo
init|=
literal|0
decl_stmt|;
name|int
name|hi
init|=
name|elementCount
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
while|while
condition|(
name|lo
operator|<
name|hi
operator|&&
operator|(
operator|&
name|elements
index|[
name|lo
index|]
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|)
index|[
name|comp
index|]
operator|<=
name|pivot
condition|)
operator|++
name|lo
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
operator|&&
operator|(
operator|&
name|elements
index|[
name|hi
index|]
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|)
index|[
name|comp
index|]
operator|>
name|pivot
condition|)
operator|--
name|hi
expr_stmt|;
if|if
condition|(
name|lo
operator|<
name|hi
condition|)
name|qSwap
argument_list|(
name|elements
index|[
name|lo
index|]
argument_list|,
name|elements
index|[
name|hi
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|==
name|elementCount
condition|)
block|{
comment|// All points are the same.
name|Q_ASSERT
argument_list|(
name|minimum
operator|.
name|x
argument_list|()
operator|==
name|maximum
operator|.
name|x
argument_list|()
operator|&&
name|minimum
operator|.
name|y
argument_list|()
operator|==
name|maximum
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|lo
operator|=
name|elementCount
operator|>>
literal|1
expr_stmt|;
block|}
name|node
operator|->
name|left
operator|=
name|buildTree
argument_list|(
name|elements
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|buildTree
argument_list|(
name|elements
operator|+
name|lo
argument_list|,
name|elementCount
operator|-
name|lo
argument_list|)
expr_stmt|;
specifier|const
name|BVHNode
modifier|*
name|left
init|=
name|node
operator|->
name|left
decl_stmt|;
specifier|const
name|BVHNode
modifier|*
name|right
init|=
name|node
operator|->
name|right
decl_stmt|;
name|node
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|qMin
argument_list|(
name|left
operator|->
name|minimum
operator|.
name|x
argument_list|()
argument_list|,
name|right
operator|->
name|minimum
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|qMin
argument_list|(
name|left
operator|->
name|minimum
operator|.
name|y
argument_list|()
argument_list|,
name|right
operator|->
name|minimum
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|qMax
argument_list|(
name|left
operator|->
name|maximum
operator|.
name|x
argument_list|()
argument_list|,
name|right
operator|->
name|maximum
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|qMax
argument_list|(
name|left
operator|->
name|maximum
operator|.
name|y
argument_list|()
argument_list|,
name|right
operator|->
name|maximum
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
DECL|function|intersectNodes
name|bool
name|PathSimplifier
operator|::
name|intersectNodes
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|elementNode
parameter_list|,
name|BVHNode
modifier|*
name|treeNode
parameter_list|)
block|{
if|if
condition|(
name|elementNode
operator|->
name|minimum
operator|.
name|x
argument_list|()
operator|>=
name|treeNode
operator|->
name|maximum
operator|.
name|x
argument_list|()
operator|||
name|elementNode
operator|->
name|minimum
operator|.
name|y
argument_list|()
operator|>=
name|treeNode
operator|->
name|maximum
operator|.
name|y
argument_list|()
operator|||
name|elementNode
operator|->
name|maximum
operator|.
name|x
argument_list|()
operator|<=
name|treeNode
operator|->
name|minimum
operator|.
name|x
argument_list|()
operator|||
name|elementNode
operator|->
name|maximum
operator|.
name|y
argument_list|()
operator|<=
name|treeNode
operator|->
name|minimum
operator|.
name|y
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Q_ASSERT
argument_list|(
name|elementNode
operator|->
name|type
operator|==
name|BVHNode
operator|::
name|Leaf
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|element
init|=
name|elementNode
operator|->
name|element
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|element
operator|->
name|processed
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeNode
operator|->
name|type
operator|==
name|BVHNode
operator|::
name|Leaf
condition|)
block|{
name|Element
modifier|*
name|nodeElement
init|=
name|treeNode
operator|->
name|element
decl_stmt|;
if|if
condition|(
operator|!
name|nodeElement
operator|->
name|processed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|treeNode
operator|->
name|element
operator|==
name|elementNode
operator|->
name|element
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|equalElements
argument_list|(
name|treeNode
operator|->
name|element
argument_list|,
name|elementNode
operator|->
name|element
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// element doesn't split itself.
if|if
condition|(
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
operator|&&
name|nodeElement
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
condition|)
block|{
specifier|const
name|QPoint
modifier|&
name|u1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|u2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|nodeElement
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|nodeElement
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|IntersectionPoint
name|intersection
init|=
name|intersectionPoint
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|intersection
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|x
operator|.
name|integer
operator|>=
name|qMin
argument_list|(
name|u1
operator|.
name|x
argument_list|()
argument_list|,
name|u2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|y
operator|.
name|integer
operator|>=
name|qMin
argument_list|(
name|u1
operator|.
name|y
argument_list|()
argument_list|,
name|u2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|x
operator|.
name|integer
operator|>=
name|qMin
argument_list|(
name|v1
operator|.
name|x
argument_list|()
argument_list|,
name|v2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|y
operator|.
name|integer
operator|>=
name|qMin
argument_list|(
name|v1
operator|.
name|y
argument_list|()
argument_list|,
name|v2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|x
operator|.
name|integer
operator|<=
name|qMax
argument_list|(
name|u1
operator|.
name|x
argument_list|()
argument_list|,
name|u2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|y
operator|.
name|integer
operator|<=
name|qMax
argument_list|(
name|u1
operator|.
name|y
argument_list|()
argument_list|,
name|u2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|x
operator|.
name|integer
operator|<=
name|qMax
argument_list|(
name|v1
operator|.
name|x
argument_list|()
argument_list|,
name|v2
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|intersection
operator|.
name|y
operator|.
name|integer
operator|<=
name|qMax
argument_list|(
name|v1
operator|.
name|y
argument_list|()
argument_list|,
name|v2
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|intersection
operator|.
name|round
argument_list|()
argument_list|)
expr_stmt|;
name|splitLineAt
argument_list|(
name|elements
argument_list|,
name|treeNode
argument_list|,
name|m_points
operator|->
name|size
argument_list|()
operator|-
literal|1
argument_list|,
operator|!
name|intersection
operator|.
name|isAccurate
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|splitLineAt
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|,
name|m_points
operator|->
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
name|QVarLengthArray
argument_list|<
name|QPoint
argument_list|,
literal|12
argument_list|>
name|axes
decl_stmt|;
name|appendSeparatingAxes
argument_list|(
name|axes
argument_list|,
name|elementNode
operator|->
name|element
argument_list|)
expr_stmt|;
name|appendSeparatingAxes
argument_list|(
name|axes
argument_list|,
name|treeNode
operator|->
name|element
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|axes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|range1
init|=
name|calculateSeparatingAxisRange
argument_list|(
name|axes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|elementNode
operator|->
name|element
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|range2
init|=
name|calculateSeparatingAxisRange
argument_list|(
name|axes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|treeNode
operator|->
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|range1
operator|.
name|first
operator|>=
name|range2
operator|.
name|second
operator|||
name|range1
operator|.
name|second
operator|<=
name|range2
operator|.
name|first
condition|)
block|{
return|return
literal|false
return|;
comment|// Separating axis found.
block|}
block|}
comment|// Bounding areas overlap.
if|if
condition|(
name|nodeElement
operator|->
name|degree
operator|>
name|Element
operator|::
name|Line
condition|)
name|splitCurve
argument_list|(
name|elements
argument_list|,
name|treeNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|->
name|degree
operator|>
name|Element
operator|::
name|Line
condition|)
block|{
name|splitCurve
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The element was not split, so it can be processed further.
if|if
condition|(
name|intersectNodes
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|,
name|treeNode
operator|->
name|left
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|intersectNodes
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|,
name|treeNode
operator|->
name|right
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|intersectNodes
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|,
name|treeNode
operator|->
name|left
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|intersectNodes
argument_list|(
name|elements
argument_list|,
name|elementNode
argument_list|,
name|treeNode
operator|->
name|right
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
block|}
DECL|function|equalElements
name|bool
name|PathSimplifier
operator|::
name|equalElements
parameter_list|(
specifier|const
name|Element
modifier|*
name|e1
parameter_list|,
specifier|const
name|Element
modifier|*
name|e2
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|e1
operator|!=
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|->
name|degree
operator|!=
name|e2
operator|->
name|degree
condition|)
return|return
literal|false
return|;
comment|// Possibly equal and in the same direction.
name|bool
name|equalSame
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|e1
operator|->
name|degree
condition|;
operator|++
name|i
control|)
name|equalSame
operator|&=
name|m_points
operator|->
name|at
argument_list|(
name|e1
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
operator|==
name|m_points
operator|->
name|at
argument_list|(
name|e2
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// Possibly equal and in opposite directions.
name|bool
name|equalOpposite
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|e1
operator|->
name|degree
condition|;
operator|++
name|i
control|)
name|equalOpposite
operator|&=
name|m_points
operator|->
name|at
argument_list|(
name|e1
operator|->
name|indices
index|[
name|e1
operator|->
name|degree
operator|-
name|i
index|]
argument_list|)
operator|==
name|m_points
operator|->
name|at
argument_list|(
name|e2
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|equalSame
operator|||
name|equalOpposite
return|;
block|}
DECL|function|splitLineAt
name|bool
name|PathSimplifier
operator|::
name|splitLineAt
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|node
parameter_list|,
name|quint32
name|pointIndex
parameter_list|,
name|bool
name|processAgain
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|node
operator|->
name|type
operator|==
name|BVHNode
operator|::
name|Leaf
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|element
init|=
name|node
operator|->
name|element
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|p
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
name|p
operator|||
name|v
operator|==
name|p
condition|)
return|return
literal|false
return|;
comment|// No split needed.
if|if
condition|(
name|processAgain
condition|)
name|element
operator|->
name|processed
operator|=
literal|false
expr_stmt|;
comment|// Needs to be processed again.
name|Element
modifier|*
name|first
init|=
name|node
operator|->
name|element
decl_stmt|;
name|Element
modifier|*
name|second
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
operator|*
name|second
operator|=
operator|*
name|first
expr_stmt|;
name|first
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|second
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex
expr_stmt|;
name|first
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|u
operator|.
name|x
argument_list|()
operator|+
name|p
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|first
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|u
operator|.
name|y
argument_list|()
operator|+
name|p
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|second
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|v
operator|.
name|x
argument_list|()
operator|+
name|p
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|second
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|v
operator|.
name|y
argument_list|()
operator|+
name|p
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|BVHNode
modifier|*
name|left
init|=
name|m_bvh
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|BVHNode
modifier|*
name|right
init|=
name|m_bvh
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|left
operator|->
name|type
operator|=
name|right
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Leaf
expr_stmt|;
name|left
operator|->
name|element
operator|=
name|first
expr_stmt|;
name|right
operator|->
name|element
operator|=
name|second
expr_stmt|;
name|left
operator|->
name|minimum
operator|=
name|right
operator|->
name|minimum
operator|=
name|node
operator|->
name|minimum
expr_stmt|;
name|left
operator|->
name|maximum
operator|=
name|right
operator|->
name|maximum
operator|=
name|node
operator|->
name|maximum
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|x
argument_list|()
operator|<
name|v
operator|.
name|x
argument_list|()
condition|)
name|left
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|right
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
else|else
name|left
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|right
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|y
argument_list|()
operator|<
name|v
operator|.
name|y
argument_list|()
condition|)
name|left
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|right
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
else|else
name|left
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|right
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
name|left
operator|->
name|element
operator|->
name|bvhNode
operator|=
name|left
expr_stmt|;
name|right
operator|->
name|element
operator|->
name|bvhNode
operator|=
name|right
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Split
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|->
name|processed
condition|)
block|{
name|elements
operator|.
name|add
argument_list|(
name|left
operator|->
name|element
argument_list|)
expr_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|right
operator|->
name|element
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|appendSeparatingAxes
name|void
name|PathSimplifier
operator|::
name|appendSeparatingAxes
parameter_list|(
name|QVarLengthArray
argument_list|<
name|QPoint
argument_list|,
literal|12
argument_list|>
modifier|&
name|axes
parameter_list|,
name|Element
modifier|*
name|element
parameter_list|)
block|{
switch|switch
condition|(
name|element
operator|->
name|degree
condition|)
block|{
case|case
name|Element
operator|::
name|Cubic
case|:
block|{
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|w
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|q
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|QPoint
name|ns
index|[]
init|=
block|{
name|QPoint
argument_list|(
name|u
operator|.
name|y
argument_list|()
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|,
name|v
operator|.
name|x
argument_list|()
operator|-
name|u
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
name|v
operator|.
name|y
argument_list|()
operator|-
name|w
operator|.
name|y
argument_list|()
argument_list|,
name|w
operator|.
name|x
argument_list|()
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
name|w
operator|.
name|y
argument_list|()
operator|-
name|q
operator|.
name|y
argument_list|()
argument_list|,
name|q
operator|.
name|x
argument_list|()
operator|-
name|w
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
name|q
operator|.
name|y
argument_list|()
operator|-
name|u
operator|.
name|y
argument_list|()
argument_list|,
name|u
operator|.
name|x
argument_list|()
operator|-
name|q
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
name|u
operator|.
name|y
argument_list|()
operator|-
name|w
operator|.
name|y
argument_list|()
argument_list|,
name|w
operator|.
name|x
argument_list|()
operator|-
name|u
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
argument|v.y() - q.y()
argument_list|,
argument|q.x() - v.x()
argument_list|)
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ns
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|||
name|ns
index|[
name|i
index|]
operator|.
name|y
argument_list|()
condition|)
name|axes
operator|.
name|append
argument_list|(
name|ns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Element
operator|::
name|Quadratic
case|:
block|{
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|w
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|QPoint
name|ns
index|[]
init|=
block|{
name|QPoint
argument_list|(
name|u
operator|.
name|y
argument_list|()
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|,
name|v
operator|.
name|x
argument_list|()
operator|-
name|u
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
name|v
operator|.
name|y
argument_list|()
operator|-
name|w
operator|.
name|y
argument_list|()
argument_list|,
name|w
operator|.
name|x
argument_list|()
operator|-
name|v
operator|.
name|x
argument_list|()
argument_list|)
block|,
name|QPoint
argument_list|(
argument|w.y() - u.y()
argument_list|,
argument|u.x() - w.x()
argument_list|)
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ns
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|||
name|ns
index|[
name|i
index|]
operator|.
name|y
argument_list|()
condition|)
name|axes
operator|.
name|append
argument_list|(
name|ns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Element
operator|::
name|Line
case|:
block|{
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|QPoint
name|n
argument_list|(
name|u
operator|.
name|y
argument_list|()
operator|-
name|v
operator|.
name|y
argument_list|()
argument_list|,
name|v
operator|.
name|x
argument_list|()
operator|-
name|u
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|x
argument_list|()
operator|||
name|n
operator|.
name|y
argument_list|()
condition|)
name|axes
operator|.
name|append
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|0
argument_list|,
literal|"QSGPathSimplifier::appendSeparatingAxes"
argument_list|,
literal|"Unexpected element type."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|calculateSeparatingAxisRange
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|PathSimplifier
operator|::
name|calculateSeparatingAxisRange
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|axis
parameter_list|,
name|Element
modifier|*
name|element
parameter_list|)
block|{
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|range
argument_list|(
literal|0x7fffffff
argument_list|,
operator|-
literal|0x7fffffff
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|element
operator|->
name|degree
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPoint
modifier|&
name|p
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|dist
init|=
name|dot
argument_list|(
name|axis
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|range
operator|.
name|first
operator|=
name|qMin
argument_list|(
name|range
operator|.
name|first
argument_list|,
name|dist
argument_list|)
expr_stmt|;
name|range
operator|.
name|second
operator|=
name|qMax
argument_list|(
name|range
operator|.
name|second
argument_list|,
name|dist
argument_list|)
expr_stmt|;
block|}
return|return
name|range
return|;
block|}
DECL|function|splitCurve
name|void
name|PathSimplifier
operator|::
name|splitCurve
parameter_list|(
name|QDataBuffer
argument_list|<
name|Element
modifier|*
argument_list|>
modifier|&
name|elements
parameter_list|,
name|BVHNode
modifier|*
name|node
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|node
operator|->
name|type
operator|==
name|BVHNode
operator|::
name|Leaf
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|first
init|=
name|node
operator|->
name|element
decl_stmt|;
name|Element
modifier|*
name|second
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
operator|*
name|second
operator|=
operator|*
name|first
expr_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|degree
operator|>
name|Element
operator|::
name|Line
argument_list|)
expr_stmt|;
name|bool
name|accurate
init|=
literal|true
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|first
operator|->
name|indices
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v
init|=
name|m_points
operator|->
name|at
argument_list|(
name|first
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|w
init|=
name|m_points
operator|->
name|at
argument_list|(
name|first
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|->
name|degree
operator|==
name|Element
operator|::
name|Quadratic
condition|)
block|{
name|QPoint
name|pts
index|[
literal|3
index|]
decl_stmt|;
name|accurate
operator|=
name|splitQuadratic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|int
name|pointIndex
init|=
name|m_points
operator|->
name|size
argument_list|()
decl_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|accurate
operator|&=
name|setElementToQuadratic
argument_list|(
name|first
argument_list|,
name|first
operator|->
name|indices
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pointIndex
argument_list|)
expr_stmt|;
name|accurate
operator|&=
name|setElementToQuadratic
argument_list|(
name|second
argument_list|,
name|pointIndex
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|,
name|second
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|degree
operator|==
name|Element
operator|::
name|Cubic
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|q
init|=
name|m_points
operator|->
name|at
argument_list|(
name|first
operator|->
name|indices
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|QPoint
name|pts
index|[
literal|5
index|]
decl_stmt|;
name|accurate
operator|=
name|splitCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|int
name|pointIndex
init|=
name|m_points
operator|->
name|size
argument_list|()
decl_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|accurate
operator|&=
name|setElementToCubic
argument_list|(
name|first
argument_list|,
name|first
operator|->
name|indices
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pointIndex
argument_list|)
expr_stmt|;
name|accurate
operator|&=
name|setElementToCubic
argument_list|(
name|second
argument_list|,
name|pointIndex
argument_list|,
name|pts
index|[
literal|3
index|]
argument_list|,
name|pts
index|[
literal|4
index|]
argument_list|,
name|second
operator|->
name|indices
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|accurate
condition|)
name|first
operator|->
name|processed
operator|=
name|second
operator|->
name|processed
operator|=
literal|false
expr_stmt|;
comment|// Needs to be processed again.
name|BVHNode
modifier|*
name|left
init|=
name|m_bvh
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|BVHNode
modifier|*
name|right
init|=
name|m_bvh
operator|.
name|newNode
argument_list|()
decl_stmt|;
name|left
operator|->
name|type
operator|=
name|right
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Leaf
expr_stmt|;
name|left
operator|->
name|element
operator|=
name|first
expr_stmt|;
name|right
operator|->
name|element
operator|=
name|second
expr_stmt|;
name|left
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|left
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|right
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|right
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|INT_MAX
expr_stmt|;
name|left
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|left
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|right
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|right
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|INT_MIN
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|first
operator|->
name|degree
condition|;
operator|++
name|i
control|)
block|{
name|QPoint
modifier|&
name|p
init|=
name|m_points
operator|->
name|at
argument_list|(
name|first
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|left
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|qMin
argument_list|(
name|left
operator|->
name|minimum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|left
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|qMin
argument_list|(
name|left
operator|->
name|minimum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|left
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|qMax
argument_list|(
name|left
operator|->
name|maximum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|left
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|qMax
argument_list|(
name|left
operator|->
name|maximum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|second
operator|->
name|degree
condition|;
operator|++
name|i
control|)
block|{
name|QPoint
modifier|&
name|p
init|=
name|m_points
operator|->
name|at
argument_list|(
name|second
operator|->
name|indices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|right
operator|->
name|minimum
operator|.
name|rx
argument_list|()
operator|=
name|qMin
argument_list|(
name|right
operator|->
name|minimum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|right
operator|->
name|minimum
operator|.
name|ry
argument_list|()
operator|=
name|qMin
argument_list|(
name|right
operator|->
name|minimum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|right
operator|->
name|maximum
operator|.
name|rx
argument_list|()
operator|=
name|qMax
argument_list|(
name|right
operator|->
name|maximum
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|right
operator|->
name|maximum
operator|.
name|ry
argument_list|()
operator|=
name|qMax
argument_list|(
name|right
operator|->
name|maximum
operator|.
name|y
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|left
operator|->
name|element
operator|->
name|bvhNode
operator|=
name|left
expr_stmt|;
name|right
operator|->
name|element
operator|->
name|bvhNode
operator|=
name|right
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|BVHNode
operator|::
name|Split
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|->
name|processed
condition|)
block|{
name|elements
operator|.
name|add
argument_list|(
name|left
operator|->
name|element
argument_list|)
expr_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|right
operator|->
name|element
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setElementToQuadratic
name|bool
name|PathSimplifier
operator|::
name|setElementToQuadratic
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|ctrl
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
block|{
specifier|const
name|QPoint
modifier|&
name|p1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex1
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|p2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex2
argument_list|)
decl_stmt|;
if|if
condition|(
name|flattenQuadratic
argument_list|(
name|p1
argument_list|,
name|ctrl
argument_list|,
name|p2
argument_list|)
condition|)
block|{
comment|// Insert line.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|p1
operator|.
name|x
argument_list|()
operator|+
name|p2
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|p1
operator|.
name|y
argument_list|()
operator|+
name|p2
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// Insert bezier.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Quadratic
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|2
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|p1
operator|.
name|x
argument_list|()
operator|+
name|ctrl
operator|.
name|x
argument_list|()
operator|+
name|p2
operator|.
name|x
argument_list|()
operator|)
operator|/
literal|3
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|p1
operator|.
name|y
argument_list|()
operator|+
name|ctrl
operator|.
name|y
argument_list|()
operator|+
name|p2
operator|.
name|y
argument_list|()
operator|)
operator|/
literal|3
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|function|setElementToCubic
name|bool
name|PathSimplifier
operator|::
name|setElementToCubic
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
block|{
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex1
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|q
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex2
argument_list|)
decl_stmt|;
if|if
condition|(
name|flattenCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|)
condition|)
block|{
comment|// Insert line.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|u
operator|.
name|x
argument_list|()
operator|+
name|q
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|u
operator|.
name|y
argument_list|()
operator|+
name|q
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// Insert bezier.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Cubic
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|2
index|]
operator|=
name|m_points
operator|->
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|3
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|u
operator|.
name|x
argument_list|()
operator|+
name|v
operator|.
name|x
argument_list|()
operator|+
name|w
operator|.
name|x
argument_list|()
operator|+
name|q
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|u
operator|.
name|y
argument_list|()
operator|+
name|v
operator|.
name|y
argument_list|()
operator|+
name|w
operator|.
name|y
argument_list|()
operator|+
name|q
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|2
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|function|setElementToCubicAndSimplify
name|void
name|PathSimplifier
operator|::
name|setElementToCubicAndSimplify
parameter_list|(
name|Element
modifier|*
name|element
parameter_list|,
name|quint32
name|pointIndex1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
name|quint32
name|pointIndex2
parameter_list|)
block|{
specifier|const
name|QPoint
modifier|&
name|u
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex1
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|q
init|=
name|m_points
operator|->
name|at
argument_list|(
name|pointIndex2
argument_list|)
decl_stmt|;
if|if
condition|(
name|flattenCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|)
condition|)
block|{
comment|// Insert line.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Line
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|u
operator|.
name|x
argument_list|()
operator|+
name|q
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|u
operator|.
name|y
argument_list|()
operator|+
name|q
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|1
expr_stmt|;
return|return;
block|}
name|bool
name|intersecting
init|=
operator|(
name|u
operator|==
name|q
operator|)
operator|||
name|intersectionPoint
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|)
operator|.
name|isValid
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|intersecting
condition|)
block|{
comment|// Insert bezier.
name|element
operator|->
name|degree
operator|=
name|Element
operator|::
name|Cubic
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|0
index|]
operator|=
name|pointIndex1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|1
index|]
operator|=
name|m_points
operator|->
name|size
argument_list|()
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|2
index|]
operator|=
name|m_points
operator|->
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|element
operator|->
name|indices
index|[
literal|3
index|]
operator|=
name|pointIndex2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|rx
argument_list|()
operator|=
operator|(
name|u
operator|.
name|x
argument_list|()
operator|+
name|v
operator|.
name|x
argument_list|()
operator|+
name|w
operator|.
name|x
argument_list|()
operator|+
name|q
operator|.
name|x
argument_list|()
operator|)
operator|>>
literal|2
expr_stmt|;
name|element
operator|->
name|middle
operator|.
name|ry
argument_list|()
operator|=
operator|(
name|u
operator|.
name|y
argument_list|()
operator|+
name|v
operator|.
name|y
argument_list|()
operator|+
name|w
operator|.
name|y
argument_list|()
operator|+
name|q
operator|.
name|y
argument_list|()
operator|)
operator|>>
literal|2
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPoint
name|pts
index|[
literal|5
index|]
decl_stmt|;
name|splitCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|int
name|pointIndex
init|=
name|m_points
operator|->
name|size
argument_list|()
decl_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Element
modifier|*
name|element2
init|=
name|m_elementAllocator
operator|.
name|newElement
argument_list|()
decl_stmt|;
name|m_elements
operator|.
name|add
argument_list|(
name|element2
argument_list|)
expr_stmt|;
name|setElementToCubicAndSimplify
argument_list|(
name|element
argument_list|,
name|pointIndex1
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pointIndex
argument_list|)
expr_stmt|;
name|setElementToCubicAndSimplify
argument_list|(
name|element2
argument_list|,
name|pointIndex
argument_list|,
name|pts
index|[
literal|3
index|]
argument_list|,
name|pts
index|[
literal|4
index|]
argument_list|,
name|pointIndex2
argument_list|)
expr_stmt|;
block|}
DECL|function|findElementLeftOf
name|PathSimplifier
operator|::
name|RBNode
modifier|*
name|PathSimplifier
operator|::
name|findElementLeftOf
parameter_list|(
specifier|const
name|Element
modifier|*
name|element
parameter_list|,
specifier|const
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
modifier|&
name|bounds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_elementList
operator|.
name|root
condition|)
return|return
literal|0
return|;
name|RBNode
modifier|*
name|current
init|=
name|bounds
operator|.
name|first
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|current
operator|||
operator|!
name|elementIsLeftOf
argument_list|(
name|element
argument_list|,
name|current
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|m_elementList
operator|.
name|front
argument_list|(
name|m_elementList
operator|.
name|root
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|RBNode
modifier|*
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current
operator|!=
name|bounds
operator|.
name|second
operator|&&
operator|!
name|elementIsLeftOf
argument_list|(
name|element
argument_list|,
name|current
operator|->
name|data
argument_list|)
condition|)
block|{
name|result
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|m_elementList
operator|.
name|next
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|function|elementIsLeftOf
name|bool
name|PathSimplifier
operator|::
name|elementIsLeftOf
parameter_list|(
specifier|const
name|Element
modifier|*
name|left
parameter_list|,
specifier|const
name|Element
modifier|*
name|right
parameter_list|)
block|{
specifier|const
name|QPoint
modifier|&
name|leftU
init|=
name|m_points
operator|->
name|at
argument_list|(
name|left
operator|->
name|upperIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|leftL
init|=
name|m_points
operator|->
name|at
argument_list|(
name|left
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|rightU
init|=
name|m_points
operator|->
name|at
argument_list|(
name|right
operator|->
name|upperIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|rightL
init|=
name|m_points
operator|->
name|at
argument_list|(
name|right
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|leftL
operator|>=
name|rightU
operator|&&
name|rightL
operator|>=
name|leftU
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftU
operator|.
name|x
argument_list|()
operator|<
name|qMin
argument_list|(
name|rightL
operator|.
name|x
argument_list|()
argument_list|,
name|rightU
operator|.
name|x
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|leftU
operator|.
name|x
argument_list|()
operator|>
name|qMax
argument_list|(
name|rightL
operator|.
name|x
argument_list|()
argument_list|,
name|rightU
operator|.
name|x
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
name|int
name|d
init|=
name|pointDistanceFromLine
argument_list|(
name|leftU
argument_list|,
name|rightL
argument_list|,
name|rightU
argument_list|)
decl_stmt|;
comment|// d< 0: left, d> 0: right, d == 0: on top
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|leftL
argument_list|,
name|rightL
argument_list|,
name|rightU
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|right
operator|->
name|degree
operator|>
name|Element
operator|::
name|Line
condition|)
block|{
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|leftL
argument_list|,
name|rightL
argument_list|,
name|m_points
operator|->
name|at
argument_list|(
name|right
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|leftL
argument_list|,
name|rightL
argument_list|,
name|m_points
operator|->
name|at
argument_list|(
name|right
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
operator|->
name|degree
operator|>
name|Element
operator|::
name|Line
condition|)
block|{
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|m_points
operator|->
name|at
argument_list|(
name|left
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|rightL
argument_list|,
name|rightU
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|m_points
operator|->
name|at
argument_list|(
name|left
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|rightL
argument_list|,
name|rightU
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|d
operator|<
literal|0
return|;
block|}
DECL|function|outerBounds
name|QPair
argument_list|<
name|PathSimplifier
operator|::
name|RBNode
operator|*
argument_list|,
name|PathSimplifier
operator|::
name|RBNode
operator|*
argument_list|>
name|PathSimplifier
operator|::
name|outerBounds
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
block|{
name|RBNode
modifier|*
name|current
init|=
name|m_elementList
operator|.
name|root
decl_stmt|;
name|QPair
argument_list|<
name|RBNode
modifier|*
argument_list|,
name|RBNode
modifier|*
argument_list|>
name|result
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|v1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|point
operator|>=
name|v2
operator|&&
name|point
operator|<=
name|v1
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|v1
operator|||
name|point
operator|==
name|v2
condition|)
break|break;
name|int
name|d
init|=
name|pointDistanceFromLine
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
condition|)
break|break;
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|pointDistanceFromLine
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|indices
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|first
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current
condition|)
return|return
name|result
return|;
name|RBNode
modifier|*
name|mid
init|=
name|current
decl_stmt|;
name|current
operator|=
name|mid
operator|->
name|left
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|v1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|point
operator|>=
name|v2
operator|&&
name|point
operator|<=
name|v1
argument_list|)
expr_stmt|;
name|bool
name|equal
init|=
operator|(
name|point
operator|==
name|v1
operator|||
name|point
operator|==
name|v2
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
block|{
name|int
name|d
init|=
name|pointDistanceFromLine
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|equal
operator|=
operator|(
name|d
operator|==
literal|0
operator|&&
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|equal
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|first
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
block|}
name|current
operator|=
name|mid
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
specifier|const
name|Element
modifier|*
name|element
init|=
name|current
operator|->
name|data
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
operator|->
name|edgeNode
operator|==
name|current
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
modifier|&
name|v1
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|lowerIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|&
name|v2
init|=
name|m_points
operator|->
name|at
argument_list|(
name|element
operator|->
name|upperIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|point
operator|>=
name|v2
operator|&&
name|point
operator|<=
name|v1
argument_list|)
expr_stmt|;
name|bool
name|equal
init|=
operator|(
name|point
operator|==
name|v1
operator|||
name|point
operator|==
name|v2
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
block|{
name|int
name|d
init|=
name|pointDistanceFromLine
argument_list|(
name|point
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|equal
operator|=
operator|(
name|d
operator|==
literal|0
operator|&&
name|element
operator|->
name|degree
operator|==
name|Element
operator|::
name|Line
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|equal
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|second
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|function|flattenQuadratic
specifier|inline
name|bool
name|PathSimplifier
operator|::
name|flattenQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|)
block|{
name|QPoint
name|deltas
index|[
literal|2
index|]
init|=
block|{
name|v
operator|-
name|u
block|,
name|w
operator|-
name|v
block|}
decl_stmt|;
name|int
name|d
init|=
name|qAbs
argument_list|(
name|cross
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|deltas
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|qAbs
argument_list|(
name|deltas
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|<
operator|(
name|Q_FIXED_POINT_SCALE
operator|*
name|Q_FIXED_POINT_SCALE
operator|*
literal|3
operator|/
literal|2
operator|)
operator|||
name|l
operator|<=
name|Q_FIXED_POINT_SCALE
operator|*
literal|2
return|;
block|}
DECL|function|flattenCubic
specifier|inline
name|bool
name|PathSimplifier
operator|::
name|flattenCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|)
block|{
name|QPoint
name|deltas
index|[]
init|=
block|{
name|v
operator|-
name|u
block|,
name|w
operator|-
name|v
block|,
name|q
operator|-
name|w
block|,
name|q
operator|-
name|u
block|}
decl_stmt|;
name|int
name|d
init|=
name|qAbs
argument_list|(
name|cross
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|deltas
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|+
name|qAbs
argument_list|(
name|cross
argument_list|(
name|deltas
index|[
literal|1
index|]
argument_list|,
name|deltas
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|+
name|qAbs
argument_list|(
name|cross
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|deltas
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|+
name|qAbs
argument_list|(
name|cross
argument_list|(
name|deltas
index|[
literal|3
index|]
argument_list|,
name|deltas
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|qAbs
argument_list|(
name|deltas
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|+
name|qAbs
argument_list|(
name|deltas
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|<
operator|(
name|Q_FIXED_POINT_SCALE
operator|*
name|Q_FIXED_POINT_SCALE
operator|*
literal|3
operator|)
operator|||
name|l
operator|<=
name|Q_FIXED_POINT_SCALE
operator|*
literal|2
return|;
block|}
DECL|function|splitQuadratic
specifier|inline
name|bool
name|PathSimplifier
operator|::
name|splitQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
name|QPoint
modifier|*
name|result
parameter_list|)
block|{
name|result
index|[
literal|0
index|]
operator|=
name|u
operator|+
name|v
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|v
operator|+
name|w
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|0
index|]
operator|+
name|result
index|[
literal|2
index|]
expr_stmt|;
name|bool
name|accurate
init|=
operator|(
operator|(
name|result
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator||
name|result
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|result
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|1
expr_stmt|;
return|return
name|accurate
return|;
block|}
DECL|function|splitCubic
specifier|inline
name|bool
name|PathSimplifier
operator|::
name|splitCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|,
name|QPoint
modifier|*
name|result
parameter_list|)
block|{
name|result
index|[
literal|0
index|]
operator|=
name|u
operator|+
name|v
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|v
operator|+
name|w
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
name|w
operator|+
name|q
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|0
index|]
operator|+
name|result
index|[
literal|2
index|]
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
name|result
index|[
literal|2
index|]
operator|+
name|result
index|[
literal|4
index|]
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|result
index|[
literal|1
index|]
operator|+
name|result
index|[
literal|3
index|]
expr_stmt|;
name|bool
name|accurate
init|=
operator|(
operator|(
name|result
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator||
name|result
index|[
literal|4
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|4
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|result
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator||
name|result
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|result
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator||
name|result
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&
literal|7
operator|)
operator|==
literal|0
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|3
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|3
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|2
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|.
name|rx
argument_list|()
operator|>>=
literal|1
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|.
name|ry
argument_list|()
operator|>>=
literal|1
expr_stmt|;
return|return
name|accurate
return|;
block|}
DECL|function|subDivQuadratic
specifier|inline
name|void
name|PathSimplifier
operator|::
name|subDivQuadratic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|)
block|{
if|if
condition|(
name|flattenQuadratic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|)
condition|)
return|return;
name|QPoint
name|pts
index|[
literal|3
index|]
decl_stmt|;
name|splitQuadratic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|subDivQuadratic
argument_list|(
name|u
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m_indices
operator|->
name|add
argument_list|(
name|m_points
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|subDivQuadratic
argument_list|(
name|pts
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
DECL|function|subDivCubic
specifier|inline
name|void
name|PathSimplifier
operator|::
name|subDivCubic
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|u
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|v
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|w
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|q
parameter_list|)
block|{
if|if
condition|(
name|flattenCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|)
condition|)
return|return;
name|QPoint
name|pts
index|[
literal|5
index|]
decl_stmt|;
name|splitCubic
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|q
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|subDivCubic
argument_list|(
name|u
argument_list|,
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|m_indices
operator|->
name|add
argument_list|(
name|m_points
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|m_points
operator|->
name|add
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|subDivCubic
argument_list|(
name|pts
index|[
literal|2
index|]
argument_list|,
name|pts
index|[
literal|3
index|]
argument_list|,
name|pts
index|[
literal|4
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
DECL|function|sortEvents
name|void
name|PathSimplifier
operator|::
name|sortEvents
parameter_list|(
name|Event
modifier|*
name|events
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|// Bucket sort + insertion sort.
name|Q_ASSERT
argument_list|(
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|QDataBuffer
argument_list|<
name|Event
argument_list|>
name|buffer
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|QScopedArrayPointer
argument_list|<
name|int
argument_list|>
name|bins
argument_list|(
operator|new
name|int
index|[
name|count
index|]
argument_list|)
decl_stmt|;
name|int
name|counts
index|[
literal|0x101
index|]
decl_stmt|;
name|memset
argument_list|(
name|counts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|counts
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|minimum
decl_stmt|,
name|maximum
decl_stmt|;
name|minimum
operator|=
name|maximum
operator|=
name|events
index|[
literal|0
index|]
operator|.
name|point
operator|.
name|y
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|minimum
operator|=
name|qMin
argument_list|(
name|minimum
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|point
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|maximum
operator|=
name|qMax
argument_list|(
name|maximum
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|point
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|bins
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|maximum
operator|-
name|events
index|[
name|i
index|]
operator|.
name|point
operator|.
name|y
argument_list|()
operator|)
operator|<<
literal|8
operator|)
operator|/
operator|(
name|maximum
operator|-
name|minimum
operator|+
literal|1
operator|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|bins
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|bins
index|[
name|i
index|]
operator|<
literal|0x100
argument_list|)
expr_stmt|;
operator|++
name|counts
index|[
name|bins
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|0x100
condition|;
operator|++
name|i
control|)
name|counts
index|[
name|i
index|]
operator|+=
name|counts
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|counts
index|[
literal|0x100
index|]
operator|=
name|counts
index|[
literal|0xff
index|]
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|counts
index|[
literal|0x100
index|]
operator|==
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|buffer
operator|.
name|at
argument_list|(
operator|--
name|counts
index|[
name|bins
index|[
name|i
index|]
index|]
argument_list|)
operator|=
name|events
index|[
name|i
index|]
expr_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
init|;
name|j
operator|<
name|counts
index|[
name|i
operator|+
literal|1
index|]
condition|;
operator|++
name|j
control|)
block|{
name|int
name|k
init|=
name|j
decl_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
operator|(
name|buffer
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|<
name|events
index|[
name|k
operator|-
literal|1
index|]
operator|)
condition|)
block|{
name|events
index|[
name|k
index|]
operator|=
name|events
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|k
expr_stmt|;
block|}
name|events
index|[
name|k
index|]
operator|=
name|buffer
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
begin_comment
comment|// end anonymous namespace
end_comment
begin_function
DECL|function|qSimplifyPath
name|void
name|qSimplifyPath
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|QDataBuffer
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|vertices
parameter_list|,
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
modifier|&
name|indices
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|PathSimplifier
argument_list|(
name|path
argument_list|,
name|vertices
argument_list|,
name|indices
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qSimplifyPath
name|void
name|qSimplifyPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|QDataBuffer
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|vertices
parameter_list|,
name|QDataBuffer
argument_list|<
name|quint32
argument_list|>
modifier|&
name|indices
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|qSimplifyPath
argument_list|(
name|qtVectorPathForPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|vertices
argument_list|,
name|indices
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
