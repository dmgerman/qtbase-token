begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qregion.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath_p.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QMatrix     \brief The QMatrix class specifies 2D transformations of a     coordinate system.     \obsolete      \ingroup painting      A matrix specifies how to translate, scale, shear or rotate the     coordinate system, and is typically used when rendering graphics.     QMatrix, in contrast to QTransform, does not allow perspective     transformations. QTransform is the recommended transformation     class in Qt.      A QMatrix object can be built using the setMatrix(), scale(),     rotate(), translate() and shear() functions.  Alternatively, it     can be built by applying \l {QMatrix#Basic Matrix     Operations}{basic matrix operations}. The matrix can also be     defined when constructed, and it can be reset to the identity     matrix (the default) using the reset() function.      The QMatrix class supports mapping of graphic primitives: A given     point, line, polygon, region, or painter path can be mapped to the     coordinate system defined by \e this matrix using the map()     function. In case of a rectangle, its coordinates can be     transformed using the mapRect() function. A rectangle can also be     transformed into a \e polygon (mapped to the coordinate system     defined by \e this matrix), using the mapToPolygon() function.      QMatrix provides the isIdentity() function which returns true if     the matrix is the identity matrix, and the isInvertible() function     which returns true if the matrix is non-singular (i.e. AB = BA =     I). The inverted() function returns an inverted copy of \e this     matrix if it is invertible (otherwise it returns the identity     matrix). In addition, QMatrix provides the determinant() function     returning the matrix's determinant.      Finally, the QMatrix class supports matrix multiplication, and     objects of the class can be streamed as well as compared.      \tableofcontents      \section1 Rendering Graphics      When rendering graphics, the matrix defines the transformations     but the actual transformation is performed by the drawing routines     in QPainter.      By default, QPainter operates on the associated device's own     coordinate system.  The standard coordinate system of a     QPaintDevice has its origin located at the top-left position. The     \e x values increase to the right; \e y values increase     downward. For a complete description, see the \l {Coordinate     System}{coordinate system} documentation.      QPainter has functions to translate, scale, shear and rotate the     coordinate system without using a QMatrix. For example:      \table 100%     \row     \li \inlineimage qmatrix-simpletransformation.png     \li     \snippet matrix/matrix.cpp 0     \endtable      Although these functions are very convenient, it can be more     efficient to build a QMatrix and call QPainter::setMatrix() if you     want to perform more than a single transform operation. For     example:      \table 100%     \row     \li \inlineimage qmatrix-combinedtransformation.png     \li     \snippet matrix/matrix.cpp 1     \endtable      \section1 Basic Matrix Operations      \image qmatrix-representation.png      A QMatrix object contains a 3 x 3 matrix.  The \c dx and \c dy     elements specify horizontal and vertical translation. The \c m11     and \c m22 elements specify horizontal and vertical scaling. And     finally, the \c m21 and \c m12 elements specify horizontal and     vertical \e shearing.      QMatrix transforms a point in the plane to another point using the     following formulas:      \snippet code/src_gui_painting_qmatrix.cpp 0      The point \e (x, y) is the original point, and \e (x', y') is the     transformed point. \e (x', y') can be transformed back to \e (x,     y) by performing the same operation on the inverted() matrix.      The various matrix elements can be set when constructing the     matrix, or by using the setMatrix() function later on. They can also     be manipulated using the translate(), rotate(), scale() and     shear() convenience functions, The currently set values can be     retrieved using the m11(), m12(), m21(), m22(), dx() and dy()     functions.      Translation is the simplest transformation. Setting \c dx and \c     dy will move the coordinate system \c dx units along the X axis     and \c dy units along the Y axis.  Scaling can be done by setting     \c m11 and \c m22. For example, setting \c m11 to 2 and \c m22 to     1.5 will double the height and increase the width by 50%.  The     identity matrix has \c m11 and \c m22 set to 1 (all others are set     to 0) mapping a point to itself. Shearing is controlled by \c m12     and \c m21. Setting these elements to values different from zero     will twist the coordinate system. Rotation is achieved by     carefully setting both the shearing factors and the scaling     factors.      Here's the combined transformations example using basic matrix     operations:      \table 100%     \row     \li \inlineimage qmatrix-combinedtransformation.png     \li     \snippet matrix/matrix.cpp 2     \endtable      \sa QPainter, QTransform, {Coordinate System},         {painting/affine}{Affine Transformations Example}, {Transformations Example} */
end_comment
begin_comment
comment|// some defines to inline some code
end_comment
begin_define
DECL|macro|MAPDOUBLE
define|#
directive|define
name|MAPDOUBLE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|nx
parameter_list|,
name|ny
parameter_list|)
define|\
value|{ \     qreal fx = x; \     qreal fy = y; \     nx = _m11*fx + _m21*fy + _dx; \     ny = _m12*fx + _m22*fy + _dy; \ }
end_define
begin_define
DECL|macro|MAPINT
define|#
directive|define
name|MAPINT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|nx
parameter_list|,
name|ny
parameter_list|)
define|\
value|{ \     qreal fx = x; \     qreal fy = y; \     nx = qRound(_m11*fx + _m21*fy + _dx); \     ny = qRound(_m12*fx + _m22*fy + _dy); \ }
end_define
begin_comment
comment|/*****************************************************************************   QMatrix member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QMatrix::QMatrix(Qt::Initialization)     \internal */
end_comment
begin_comment
comment|/*!     Constructs an identity matrix.      All elements are set to zero except \c m11 and \c m22 (specifying     the scale), which are set to 1.      \sa reset() */
end_comment
begin_constructor
DECL|function|QMatrix
name|QMatrix
operator|::
name|QMatrix
parameter_list|()
member_init_list|:
name|_m11
argument_list|(
literal|1.
argument_list|)
member_init_list|,
name|_m12
argument_list|(
literal|0.
argument_list|)
member_init_list|,
name|_m21
argument_list|(
literal|0.
argument_list|)
member_init_list|,
name|_m22
argument_list|(
literal|1.
argument_list|)
member_init_list|,
name|_dx
argument_list|(
literal|0.
argument_list|)
member_init_list|,
name|_dy
argument_list|(
literal|0.
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a matrix with the elements, \a m11, \a m12, \a m21, \a     m22, \a dx and \a dy.      \sa setMatrix() */
end_comment
begin_constructor
DECL|function|QMatrix
name|QMatrix
operator|::
name|QMatrix
parameter_list|(
name|qreal
name|m11
parameter_list|,
name|qreal
name|m12
parameter_list|,
name|qreal
name|m21
parameter_list|,
name|qreal
name|m22
parameter_list|,
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
member_init_list|:
name|_m11
argument_list|(
name|m11
argument_list|)
member_init_list|,
name|_m12
argument_list|(
name|m12
argument_list|)
member_init_list|,
name|_m21
argument_list|(
name|m21
argument_list|)
member_init_list|,
name|_m22
argument_list|(
name|m22
argument_list|)
member_init_list|,
name|_dx
argument_list|(
name|dx
argument_list|)
member_init_list|,
name|_dy
argument_list|(
name|dy
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!      Constructs a matrix that is a copy of the given \a matrix.  */
end_comment
begin_constructor
DECL|function|QMatrix
name|QMatrix
operator|::
name|QMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
member_init_list|:
name|_m11
argument_list|(
name|matrix
operator|.
name|_m11
argument_list|)
member_init_list|,
name|_m12
argument_list|(
name|matrix
operator|.
name|_m12
argument_list|)
member_init_list|,
name|_m21
argument_list|(
name|matrix
operator|.
name|_m21
argument_list|)
member_init_list|,
name|_m22
argument_list|(
name|matrix
operator|.
name|_m22
argument_list|)
member_init_list|,
name|_dx
argument_list|(
name|matrix
operator|.
name|_dx
argument_list|)
member_init_list|,
name|_dy
argument_list|(
name|matrix
operator|.
name|_dy
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Sets the matrix elements to the specified values, \a m11, \a m12,     \a m21, \a m22, \a dx and \a dy.      Note that this function replaces the previous values. QMatrix     provide the translate(), rotate(), scale() and shear() convenience     functions to manipulate the various matrix elements based on the     currently defined coordinate system.      \sa QMatrix() */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QMatrix
operator|::
name|setMatrix
parameter_list|(
name|qreal
name|m11
parameter_list|,
name|qreal
name|m12
parameter_list|,
name|qreal
name|m21
parameter_list|,
name|qreal
name|m22
parameter_list|,
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
name|_m11
operator|=
name|m11
expr_stmt|;
name|_m12
operator|=
name|m12
expr_stmt|;
name|_m21
operator|=
name|m21
expr_stmt|;
name|_m22
operator|=
name|m22
expr_stmt|;
name|_dx
operator|=
name|dx
expr_stmt|;
name|_dy
operator|=
name|dy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn qreal QMatrix::m11() const      Returns the horizontal scaling factor.      \sa scale(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QMatrix::m12() const      Returns the vertical shearing factor.      \sa shear(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QMatrix::m21() const      Returns the horizontal shearing factor.      \sa shear(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QMatrix::m22() const      Returns the vertical scaling factor.      \sa scale(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QMatrix::dx() const      Returns the horizontal translation factor.      \sa translate(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     \fn qreal QMatrix::dy() const      Returns the vertical translation factor.      \sa translate(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_comment
comment|/*!     Maps the given coordinates \a x and \a y into the coordinate     system defined by this matrix. The resulting values are put in *\a     tx and *\a ty, respectively.      The coordinates are transformed using the following formulas:      \snippet code/src_gui_painting_qmatrix.cpp 1      The point (x, y) is the original point, and (x', y') is the     transformed point.      \sa {QMatrix#Basic Matrix Operations}{Basic Matrix Operations} */
end_comment
begin_function
DECL|function|map
name|void
name|QMatrix
operator|::
name|map
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
modifier|*
name|tx
parameter_list|,
name|qreal
modifier|*
name|ty
parameter_list|)
specifier|const
block|{
name|MAPDOUBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|*
name|tx
argument_list|,
operator|*
name|ty
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Maps the given coordinates \a x and \a y into the coordinate     system defined by this matrix. The resulting values are put in *\a     tx and *\a ty, respectively. Note that the transformed coordinates     are rounded to the nearest integer. */
end_comment
begin_function
DECL|function|map
name|void
name|QMatrix
operator|::
name|map
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|ty
parameter_list|)
specifier|const
block|{
name|MAPINT
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|*
name|tx
argument_list|,
operator|*
name|ty
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mapRect
name|QRect
name|QMatrix
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QRect
name|result
decl_stmt|;
if|if
condition|(
name|_m12
operator|==
literal|0.0F
operator|&&
name|_m21
operator|==
literal|0.0F
condition|)
block|{
name|int
name|x
init|=
name|qRound
argument_list|(
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|_dx
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|qRound
argument_list|(
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|_dy
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|qRound
argument_list|(
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|h
init|=
name|qRound
argument_list|(
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
name|result
operator|=
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// see mapToPolygon for explanations of the algorithm.
name|qreal
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
name|qreal
name|xmin
init|=
name|x0
decl_stmt|;
name|qreal
name|ymin
init|=
name|y0
decl_stmt|;
name|qreal
name|xmax
init|=
name|x0
decl_stmt|;
name|qreal
name|ymax
init|=
name|y0
decl_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|right
argument_list|()
operator|+
literal|1
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|result
operator|=
name|QRect
argument_list|(
name|qRound
argument_list|(
name|xmin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|ymin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|xmax
argument_list|)
operator|-
name|qRound
argument_list|(
name|xmin
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|ymax
argument_list|)
operator|-
name|qRound
argument_list|(
name|ymin
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QMatrix::mapRect(const QRectF&rectangle) const      Creates and returns a QRectF object that is a copy of the given \a     rectangle, mapped into the coordinate system defined by this     matrix.      The rectangle's coordinates are transformed using the following     formulas:      \snippet code/src_gui_painting_qmatrix.cpp 2      If rotation or shearing has been specified, this function returns     the \e bounding rectangle. To retrieve the exact region the given     \a rectangle maps to, use the mapToPolygon() function instead.      \sa mapToPolygon(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_function
DECL|function|mapRect
name|QRectF
name|QMatrix
operator|::
name|mapRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QRectF
name|result
decl_stmt|;
if|if
condition|(
name|_m12
operator|==
literal|0.0F
operator|&&
name|_m21
operator|==
literal|0.0F
condition|)
block|{
name|qreal
name|x
init|=
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|_dx
decl_stmt|;
name|qreal
name|y
init|=
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|_dy
decl_stmt|;
name|qreal
name|w
init|=
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
operator|-=
name|h
expr_stmt|;
block|}
name|result
operator|=
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|qreal
name|x
decl_stmt|,
name|y
decl_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
name|qreal
name|xmin
init|=
name|x0
decl_stmt|;
name|qreal
name|ymin
init|=
name|y0
decl_stmt|;
name|qreal
name|xmax
init|=
name|x0
decl_stmt|;
name|qreal
name|ymax
init|=
name|y0
decl_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmin
operator|=
name|qMin
argument_list|(
name|xmin
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymin
operator|=
name|qMin
argument_list|(
name|ymin
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|xmax
operator|=
name|qMax
argument_list|(
name|xmax
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|qMax
argument_list|(
name|ymax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|result
operator|=
name|QRectF
argument_list|(
name|xmin
argument_list|,
name|ymin
argument_list|,
name|xmax
operator|-
name|xmin
argument_list|,
name|ymax
operator|-
name|ymin
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QMatrix::mapRect(const QRect&rectangle) const     \overload      Creates and returns a QRect object that is a copy of the given \a     rectangle, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_comment
comment|/*!     \fn QPoint operator*(const QPoint&point, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{point}).      \sa QMatrix::map() */
end_comment
begin_function
DECL|function|map
name|QPoint
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|qreal
name|fx
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|fy
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
return|return
name|QPoint
argument_list|(
name|qRound
argument_list|(
name|_m11
operator|*
name|fx
operator|+
name|_m21
operator|*
name|fy
operator|+
name|_dx
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|_m12
operator|*
name|fx
operator|+
name|_m22
operator|*
name|fy
operator|+
name|_dy
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF operator*(const QPointF&point, const QMatrix&matrix)     \relates QMatrix      Same as \a{matrix}.map(\a{point}).      \sa QMatrix::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QPointF object that is a copy of the given     \a point, mapped into the coordinate system defined by this     matrix. */
end_comment
begin_function
DECL|function|map
name|QPointF
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|qreal
name|fx
init|=
name|point
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|fy
init|=
name|point
operator|.
name|y
argument_list|()
decl_stmt|;
return|return
name|QPointF
argument_list|(
name|_m11
operator|*
name|fx
operator|+
name|_m21
operator|*
name|fy
operator|+
name|_dx
argument_list|,
name|_m12
operator|*
name|fx
operator|+
name|_m22
operator|*
name|fy
operator|+
name|_dy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QMatrix::map(const QPoint&point) const     \overload      Creates and returns a QPoint object that is a copy of the given \a     point, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_comment
comment|/*!     \fn QLineF operator*(const QLineF&line, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{line}).      \sa QMatrix::map() */
end_comment
begin_comment
comment|/*!     \fn QLine operator*(const QLine&line, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{line}).      \sa QMatrix::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QLineF object that is a copy of the given \a     line, mapped into the coordinate system defined by this matrix. */
end_comment
begin_function
DECL|function|map
name|QLineF
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|)
specifier|const
block|{
return|return
name|QLineF
argument_list|(
name|map
argument_list|(
name|line
operator|.
name|p1
argument_list|()
argument_list|)
argument_list|,
name|map
argument_list|(
name|line
operator|.
name|p2
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates and returns a QLine object that is a copy of the given \a     line, mapped into the coordinate system defined by this matrix.     Note that the transformed coordinates are rounded to the nearest     integer. */
end_comment
begin_function
DECL|function|map
name|QLine
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QLine
modifier|&
name|line
parameter_list|)
specifier|const
block|{
return|return
name|QLine
argument_list|(
name|map
argument_list|(
name|line
operator|.
name|p1
argument_list|()
argument_list|)
argument_list|,
name|map
argument_list|(
name|line
operator|.
name|p2
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF operator *(const QPolygonF&polygon, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{polygon}).      \sa QMatrix::map() */
end_comment
begin_comment
comment|/*!     \fn QPolygon operator*(const QPolygon&polygon, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{polygon}).      \sa QMatrix::map() */
end_comment
begin_function
DECL|function|map
name|QPolygon
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|)
specifier|const
block|{
name|int
name|size
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|QPolygon
name|p
argument_list|(
name|size
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
modifier|*
name|da
init|=
name|a
operator|.
name|constData
argument_list|()
decl_stmt|;
name|QPoint
modifier|*
name|dp
init|=
name|p
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|MAPINT
argument_list|(
name|da
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|da
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|rx
argument_list|()
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|ry
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QMatrix::map(const QPolygonF&polygon) const     \overload      Creates and returns a QPolygonF object that is a copy of the given     \a polygon, mapped into the coordinate system defined by this     matrix. */
end_comment
begin_function
DECL|function|map
name|QPolygonF
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|a
parameter_list|)
specifier|const
block|{
name|int
name|size
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|QPolygonF
name|p
argument_list|(
name|size
argument_list|)
decl_stmt|;
specifier|const
name|QPointF
modifier|*
name|da
init|=
name|a
operator|.
name|constData
argument_list|()
decl_stmt|;
name|QPointF
modifier|*
name|dp
init|=
name|p
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|MAPDOUBLE
argument_list|(
name|da
index|[
name|i
index|]
operator|.
name|xp
argument_list|,
name|da
index|[
name|i
index|]
operator|.
name|yp
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|xp
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|yp
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygon QMatrix::map(const QPolygon&polygon) const     \overload      Creates and returns a QPolygon object that is a copy of the given     \a polygon, mapped into the coordinate system defined by this     matrix. Note that the transformed coordinates are rounded to the     nearest integer. */
end_comment
begin_comment
comment|/*!     \fn QRegion operator*(const QRegion&region, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{region}).      \sa QMatrix::map() */
end_comment
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     \fn QRegion QMatrix::map(const QRegion&region) const     \overload      Creates and returns a QRegion object that is a copy of the given     \a region, mapped into the coordinate system defined by this matrix.      Calling this method can be rather expensive if rotations or     shearing are used. */
end_comment
begin_function
DECL|function|map
name|QRegion
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|_m11
operator|==
literal|1.0
operator|&&
name|_m22
operator|==
literal|1.0
operator|&&
name|_m12
operator|==
literal|0.0
operator|&&
name|_m21
operator|==
literal|0.0
condition|)
block|{
comment|// translate or identity
if|if
condition|(
name|_dx
operator|==
literal|0.0
operator|&&
name|_dy
operator|==
literal|0.0
condition|)
comment|// Identity
return|return
name|r
return|;
name|QRegion
name|copy
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|copy
operator|.
name|translate
argument_list|(
name|qRound
argument_list|(
name|_dx
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|_dy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
name|QPainterPath
name|p
init|=
name|map
argument_list|(
name|qt_regionToPath
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|p
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath operator *(const QPainterPath&path, const QMatrix&matrix)     \relates QMatrix      This is the same as \a{matrix}.map(\a{path}).      \sa QMatrix::map() */
end_comment
begin_comment
comment|/*!     \overload      Creates and returns a QPainterPath object that is a copy of the     given \a path, mapped into the coordinate system defined by this     matrix. */
end_comment
begin_function
DECL|function|map
name|QPainterPath
name|QMatrix
operator|::
name|map
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPainterPath
argument_list|()
return|;
name|QPainterPath
name|copy
init|=
name|path
decl_stmt|;
comment|// Translate or identity
if|if
condition|(
name|_m11
operator|==
literal|1.0
operator|&&
name|_m22
operator|==
literal|1.0
operator|&&
name|_m12
operator|==
literal|0.0
operator|&&
name|_m21
operator|==
literal|0.0
condition|)
block|{
comment|// Translate
if|if
condition|(
name|_dx
operator|!=
literal|0.0
operator|||
name|_dy
operator|!=
literal|0.0
condition|)
block|{
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|copy
operator|.
name|d_ptr
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
name|e
operator|.
name|x
operator|+=
name|_dx
expr_stmt|;
name|e
operator|.
name|y
operator|+=
name|_dy
expr_stmt|;
block|}
block|}
comment|// Full xform
block|}
else|else
block|{
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|copy
operator|.
name|d_ptr
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
name|qreal
name|fx
init|=
name|e
operator|.
name|x
decl_stmt|,
name|fy
init|=
name|e
operator|.
name|y
decl_stmt|;
name|e
operator|.
name|x
operator|=
name|_m11
operator|*
name|fx
operator|+
name|_m21
operator|*
name|fy
operator|+
name|_dx
expr_stmt|;
name|e
operator|.
name|y
operator|=
name|_m12
operator|*
name|fx
operator|+
name|_m22
operator|*
name|fy
operator|+
name|_dy
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygon QMatrix::mapToPolygon(const QRect&rectangle) const      Creates and returns a QPolygon representation of the given \a     rectangle, mapped into the coordinate system defined by this     matrix.      The rectangle's coordinates are transformed using the following     formulas:      \snippet code/src_gui_painting_qmatrix.cpp 3      Polygons and rectangles behave slightly differently when     transformed (due to integer rounding), so     \c{matrix.map(QPolygon(rectangle))} is not always the same as     \c{matrix.mapToPolygon(rectangle)}.      \sa mapRect(), {QMatrix#Basic Matrix Operations}{Basic Matrix     Operations} */
end_comment
begin_function
DECL|function|mapToPolygon
name|QPolygon
name|QMatrix
operator|::
name|mapToPolygon
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QPolygon
name|a
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|qreal
name|x
index|[
literal|4
index|]
decl_stmt|,
name|y
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|_m12
operator|==
literal|0.0F
operator|&&
name|_m21
operator|==
literal|0.0F
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|_m11
operator|*
name|rect
operator|.
name|x
argument_list|()
operator|+
name|_dx
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
name|_m22
operator|*
name|rect
operator|.
name|y
argument_list|()
operator|+
name|_dy
expr_stmt|;
name|qreal
name|w
init|=
name|_m11
operator|*
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|_m22
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|-=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|-=
name|h
expr_stmt|;
block|}
name|x
index|[
literal|1
index|]
operator|=
name|x
index|[
literal|0
index|]
operator|+
name|w
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|x
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|y
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
name|y
index|[
literal|0
index|]
operator|+
name|h
expr_stmt|;
name|y
index|[
literal|3
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|right
init|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|right
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|y
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|MAPDOUBLE
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|bottom
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|y
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|int i;     for(i = 0; i< 4; i++)         qDebug("coords(%d) = (%f/%f) (%d/%d)", i, x[i], y[i], qRound(x[i]), qRound(y[i]));     qDebug("width=%f, height=%f", qSqrt((x[1]-x[0])*(x[1]-x[0]) + (y[1]-y[0])*(y[1]-y[0])),             qSqrt((x[0]-x[3])*(x[0]-x[3]) + (y[0]-y[3])*(y[0]-y[3])));
endif|#
directive|endif
comment|// all coordinates are correctly, tranform to a pointarray
comment|// (rounding to the next integer)
name|a
operator|.
name|setPoints
argument_list|(
literal|4
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|x
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|y
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the matrix to an identity matrix, i.e. all elements are set     to zero, except \c m11 and \c m22 (specifying the scale) which are     set to 1.      \sa QMatrix(), isIdentity(), {QMatrix#Basic Matrix     Operations}{Basic Matrix Operations} */
end_comment
begin_function
DECL|function|reset
name|void
name|QMatrix
operator|::
name|reset
parameter_list|()
block|{
name|_m11
operator|=
name|_m22
operator|=
literal|1.0
expr_stmt|;
name|_m12
operator|=
name|_m21
operator|=
name|_dx
operator|=
name|_dy
operator|=
literal|0.0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMatrix::isIdentity() const      Returns true if the matrix is the identity matrix, otherwise     returns false.      \sa reset() */
end_comment
begin_comment
comment|/*!     Moves the coordinate system \a dx along the x axis and \a dy along     the y axis, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|translate
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|translate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
name|_dx
operator|+=
name|dx
operator|*
name|_m11
operator|+
name|dy
operator|*
name|_m21
expr_stmt|;
name|_dy
operator|+=
name|dy
operator|*
name|_m22
operator|+
name|dx
operator|*
name|_m12
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix&QMatrix::scale(qreal sx, qreal sy)      Scales the coordinate system by \a sx horizontally and \a sy     vertically, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|scale
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|scale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
name|_m11
operator|*=
name|sx
expr_stmt|;
name|_m12
operator|*=
name|sx
expr_stmt|;
name|_m21
operator|*=
name|sy
expr_stmt|;
name|_m22
operator|*=
name|sy
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Shears the coordinate system by \a sh horizontally and \a sv     vertically, and returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|shear
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|shear
parameter_list|(
name|qreal
name|sh
parameter_list|,
name|qreal
name|sv
parameter_list|)
block|{
name|qreal
name|tm11
init|=
name|sv
operator|*
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|sv
operator|*
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
name|sh
operator|*
name|_m11
decl_stmt|;
name|qreal
name|tm22
init|=
name|sh
operator|*
name|_m12
decl_stmt|;
name|_m11
operator|+=
name|tm11
expr_stmt|;
name|_m12
operator|+=
name|tm12
expr_stmt|;
name|_m21
operator|+=
name|tm21
expr_stmt|;
name|_m22
operator|+=
name|tm22
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|deg2rad
specifier|const
name|qreal
name|deg2rad
init|=
name|qreal
argument_list|(
literal|0.017453292519943295769
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|deg2rad
comment|// pi/180
end_comment
begin_comment
comment|/*!     \fn QMatrix&QMatrix::rotate(qreal degrees)      Rotates the coordinate system the given \a degrees     counterclockwise.      Note that if you apply a QMatrix to a point defined in widget     coordinates, the direction of the rotation will be clockwise     because the y-axis points downwards.      Returns a reference to the matrix.      \sa setMatrix() */
end_comment
begin_function
DECL|function|rotate
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|rotate
parameter_list|(
name|qreal
name|a
parameter_list|)
block|{
name|qreal
name|sina
init|=
literal|0
decl_stmt|;
name|qreal
name|cosa
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|90.
operator|||
name|a
operator|==
operator|-
literal|270.
condition|)
name|sina
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|270.
operator|||
name|a
operator|==
operator|-
literal|90.
condition|)
name|sina
operator|=
operator|-
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|180.
condition|)
name|cosa
operator|=
operator|-
literal|1.
expr_stmt|;
else|else
block|{
name|qreal
name|b
init|=
name|deg2rad
operator|*
name|a
decl_stmt|;
comment|// convert to radians
name|sina
operator|=
name|qSin
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|// fast and convenient
name|cosa
operator|=
name|qCos
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|qreal
name|tm11
init|=
name|cosa
operator|*
name|_m11
operator|+
name|sina
operator|*
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|cosa
operator|*
name|_m12
operator|+
name|sina
operator|*
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
operator|-
name|sina
operator|*
name|_m11
operator|+
name|cosa
operator|*
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
operator|-
name|sina
operator|*
name|_m12
operator|+
name|cosa
operator|*
name|_m22
decl_stmt|;
name|_m11
operator|=
name|tm11
expr_stmt|;
name|_m12
operator|=
name|tm12
expr_stmt|;
name|_m21
operator|=
name|tm21
expr_stmt|;
name|_m22
operator|=
name|tm22
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMatrix::isInvertible() const      Returns true if the matrix is invertible, otherwise returns false.      \sa inverted() */
end_comment
begin_comment
comment|/*!     \since 4.6     \fn qreal QMatrix::determinant() const      Returns the matrix's determinant. */
end_comment
begin_comment
comment|/*!     Returns an inverted copy of this matrix.      If the matrix is singular (not invertible), the returned matrix is     the identity matrix. If \a invertible is valid (i.e. not 0), its     value is set to true if the matrix is invertible, otherwise it is     set to false.      \sa isInvertible() */
end_comment
begin_function
DECL|function|inverted
name|QMatrix
name|QMatrix
operator|::
name|inverted
parameter_list|(
name|bool
modifier|*
name|invertible
parameter_list|)
specifier|const
block|{
name|qreal
name|dtr
init|=
name|determinant
argument_list|()
decl_stmt|;
if|if
condition|(
name|dtr
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|false
expr_stmt|;
comment|// singular matrix
return|return
name|QMatrix
argument_list|(
literal|true
argument_list|)
return|;
block|}
else|else
block|{
comment|// invertible matrix
if|if
condition|(
name|invertible
condition|)
operator|*
name|invertible
operator|=
literal|true
expr_stmt|;
name|qreal
name|dinv
init|=
literal|1.0
operator|/
name|dtr
decl_stmt|;
return|return
name|QMatrix
argument_list|(
operator|(
name|_m22
operator|*
name|dinv
operator|)
argument_list|,
operator|(
operator|-
name|_m12
operator|*
name|dinv
operator|)
argument_list|,
operator|(
operator|-
name|_m21
operator|*
name|dinv
operator|)
argument_list|,
operator|(
name|_m11
operator|*
name|dinv
operator|)
argument_list|,
operator|(
operator|(
name|_m21
operator|*
name|_dy
operator|-
name|_m22
operator|*
name|_dx
operator|)
operator|*
name|dinv
operator|)
argument_list|,
operator|(
operator|(
name|_m12
operator|*
name|_dx
operator|-
name|_m11
operator|*
name|_dy
operator|)
operator|*
name|dinv
operator|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QMatrix::operator==(const QMatrix&matrix) const      Returns true if this matrix is equal to the given \a matrix,     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QMatrix
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
specifier|const
block|{
return|return
name|_m11
operator|==
name|m
operator|.
name|_m11
operator|&&
name|_m12
operator|==
name|m
operator|.
name|_m12
operator|&&
name|_m21
operator|==
name|m
operator|.
name|_m21
operator|&&
name|_m22
operator|==
name|m
operator|.
name|_m22
operator|&&
name|_dx
operator|==
name|m
operator|.
name|_dx
operator|&&
name|_dy
operator|==
name|m
operator|.
name|_dy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMatrix::operator!=(const QMatrix&matrix) const      Returns true if this matrix is not equal to the given \a matrix,     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QMatrix
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
specifier|const
block|{
return|return
name|_m11
operator|!=
name|m
operator|.
name|_m11
operator|||
name|_m12
operator|!=
name|m
operator|.
name|_m12
operator|||
name|_m21
operator|!=
name|m
operator|.
name|_m21
operator|||
name|_m22
operator|!=
name|m
operator|.
name|_m22
operator|||
name|_dx
operator|!=
name|m
operator|.
name|_dx
operator|||
name|_dy
operator|!=
name|m
operator|.
name|_dy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix&QMatrix::operator *=(const QMatrix&matrix)     \overload      Returns the result of multiplying this matrix by the given \a     matrix. */
end_comment
begin_function
DECL|function|operator *=
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|operator
name|*=
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
block|{
name|qreal
name|tm11
init|=
name|_m11
operator|*
name|m
operator|.
name|_m11
operator|+
name|_m12
operator|*
name|m
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|_m11
operator|*
name|m
operator|.
name|_m12
operator|+
name|_m12
operator|*
name|m
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
name|_m21
operator|*
name|m
operator|.
name|_m11
operator|+
name|_m22
operator|*
name|m
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
name|_m21
operator|*
name|m
operator|.
name|_m12
operator|+
name|_m22
operator|*
name|m
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tdx
init|=
name|_dx
operator|*
name|m
operator|.
name|_m11
operator|+
name|_dy
operator|*
name|m
operator|.
name|_m21
operator|+
name|m
operator|.
name|_dx
decl_stmt|;
name|qreal
name|tdy
init|=
name|_dx
operator|*
name|m
operator|.
name|_m12
operator|+
name|_dy
operator|*
name|m
operator|.
name|_m22
operator|+
name|m
operator|.
name|_dy
decl_stmt|;
name|_m11
operator|=
name|tm11
expr_stmt|;
name|_m12
operator|=
name|tm12
expr_stmt|;
name|_m21
operator|=
name|tm21
expr_stmt|;
name|_m22
operator|=
name|tm22
expr_stmt|;
name|_dx
operator|=
name|tdx
expr_stmt|;
name|_dy
operator|=
name|tdy
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix QMatrix::operator *(const QMatrix&matrix) const      Returns the result of multiplying this matrix by the given \a     matrix.      Note that matrix multiplication is not commutative, i.e. a*b !=     b*a. */
end_comment
begin_function
DECL|function|operator *
name|QMatrix
name|QMatrix
operator|::
name|operator
name|*
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
specifier|const
block|{
name|qreal
name|tm11
init|=
name|_m11
operator|*
name|m
operator|.
name|_m11
operator|+
name|_m12
operator|*
name|m
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm12
init|=
name|_m11
operator|*
name|m
operator|.
name|_m12
operator|+
name|_m12
operator|*
name|m
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tm21
init|=
name|_m21
operator|*
name|m
operator|.
name|_m11
operator|+
name|_m22
operator|*
name|m
operator|.
name|_m21
decl_stmt|;
name|qreal
name|tm22
init|=
name|_m21
operator|*
name|m
operator|.
name|_m12
operator|+
name|_m22
operator|*
name|m
operator|.
name|_m22
decl_stmt|;
name|qreal
name|tdx
init|=
name|_dx
operator|*
name|m
operator|.
name|_m11
operator|+
name|_dy
operator|*
name|m
operator|.
name|_m21
operator|+
name|m
operator|.
name|_dx
decl_stmt|;
name|qreal
name|tdy
init|=
name|_dx
operator|*
name|m
operator|.
name|_m12
operator|+
name|_dy
operator|*
name|m
operator|.
name|_m22
operator|+
name|m
operator|.
name|_dy
decl_stmt|;
return|return
name|QMatrix
argument_list|(
name|tm11
argument_list|,
name|tm12
argument_list|,
name|tm21
argument_list|,
name|tm22
argument_list|,
name|tdx
argument_list|,
name|tdy
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the given \a matrix's values to this matrix. */
end_comment
begin_function
DECL|function|operator =
name|QMatrix
modifier|&
name|QMatrix
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
block|{
name|_m11
operator|=
name|matrix
operator|.
name|_m11
expr_stmt|;
name|_m12
operator|=
name|matrix
operator|.
name|_m12
expr_stmt|;
name|_m21
operator|=
name|matrix
operator|.
name|_m21
expr_stmt|;
name|_m22
operator|=
name|matrix
operator|.
name|_m22
expr_stmt|;
name|_dx
operator|=
name|matrix
operator|.
name|_dx
expr_stmt|;
name|_dy
operator|=
name|matrix
operator|.
name|_dy
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the matrix as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QMatrix
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Matrix
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator *
name|Q_GUI_EXPORT
name|QPainterPath
name|operator
name|*
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|,
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
block|{
return|return
name|m
operator|.
name|map
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QMatrix stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QMatrix&matrix)     \relates QMatrix      Writes the given \a matrix to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|s
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|m11
argument_list|()
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|m12
argument_list|()
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|m21
argument_list|()
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|m22
argument_list|()
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|dx
argument_list|()
operator|<<
operator|(
name|float
operator|)
name|m
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m11
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m12
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m21
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|m22
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|dx
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|m
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QMatrix&matrix)     \relates QMatrix      Reads the given \a matrix from the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QMatrix
modifier|&
name|m
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|float
name|m11
decl_stmt|,
name|m12
decl_stmt|,
name|m21
decl_stmt|,
name|m22
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|s
operator|>>
name|m11
expr_stmt|;
name|s
operator|>>
name|m12
expr_stmt|;
name|s
operator|>>
name|m21
expr_stmt|;
name|s
operator|>>
name|m22
expr_stmt|;
name|s
operator|>>
name|dx
expr_stmt|;
name|s
operator|>>
name|dy
expr_stmt|;
name|m
operator|.
name|setMatrix
argument_list|(
name|m11
argument_list|,
name|m12
argument_list|,
name|m21
argument_list|,
name|m22
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|m11
decl_stmt|,
name|m12
decl_stmt|,
name|m21
decl_stmt|,
name|m22
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|s
operator|>>
name|m11
expr_stmt|;
name|s
operator|>>
name|m12
expr_stmt|;
name|s
operator|>>
name|m21
expr_stmt|;
name|s
operator|>>
name|m22
expr_stmt|;
name|s
operator|>>
name|dx
expr_stmt|;
name|s
operator|>>
name|dy
expr_stmt|;
name|m
operator|.
name|setMatrix
argument_list|(
name|m11
argument_list|,
name|m12
argument_list|,
name|m21
argument_list|,
name|m22
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QMatrix("
operator|<<
literal|"11="
operator|<<
name|m
operator|.
name|m11
argument_list|()
operator|<<
literal|" 12="
operator|<<
name|m
operator|.
name|m12
argument_list|()
operator|<<
literal|" 21="
operator|<<
name|m
operator|.
name|m21
argument_list|()
operator|<<
literal|" 22="
operator|<<
name|m
operator|.
name|m22
argument_list|()
operator|<<
literal|" dx="
operator|<<
name|m
operator|.
name|dx
argument_list|()
operator|<<
literal|" dy="
operator|<<
name|m
operator|.
name|dy
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn bool qFuzzyCompare(const QMatrix& m1, const QMatrix& m2)      \relates QMatrix     \since 4.6      \brief The qFuzzyCompare function is for comparing two matrices     using a fuzziness factor.      Returns true if \a m1 and \a m2 are equal, allowing for a small     fuzziness factor for floating-point comparisons; false otherwise. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
