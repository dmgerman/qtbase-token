begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpaintengine.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainter_p.h"
end_include
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengineex_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QTextItem      \brief The QTextItem class provides all the information required to draw     text in a custom paint engine.      When you reimplement your own paint engine, you must reimplement     QPaintEngine::drawTextItem(), a function that takes a QTextItem as     one of its arguments. */
comment|/*!   \enum QTextItem::RenderFlag    \value  RightToLeft Render the text from right to left.   \value  Overline    Paint a line above the text.   \value  Underline   Paint a line under the text.   \value  StrikeOut   Paint a line through the text.   \omitvalue Dummy */
comment|/*!     \fn qreal QTextItem::descent() const      Corresponds to the \l{QFontMetrics::descent()}{descent} of the piece of text that is drawn. */
DECL|function|descent
name|qreal
name|QTextItem
operator|::
name|descent
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|ti
operator|->
name|descent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn qreal QTextItem::ascent() const      Corresponds to the \l{QFontMetrics::ascent()}{ascent} of the piece of text that is drawn. */
end_comment
begin_function
DECL|function|ascent
name|qreal
name|QTextItem
operator|::
name|ascent
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|ti
operator|->
name|ascent
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn qreal QTextItem::width() const      Specifies the total width of the text to be drawn. */
end_comment
begin_function
DECL|function|width
name|qreal
name|QTextItem
operator|::
name|width
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|ti
operator|->
name|width
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextItem::RenderFlags QTextItem::renderFlags() const      Returns the render flags used. */
end_comment
begin_function
DECL|function|renderFlags
name|QTextItem
operator|::
name|RenderFlags
name|QTextItem
operator|::
name|renderFlags
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|ti
operator|->
name|flags
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QTextItem::text() const      Returns the text that should be drawn. */
end_comment
begin_function
DECL|function|text
name|QString
name|QTextItem
operator|::
name|text
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|QString
argument_list|(
name|ti
operator|->
name|chars
argument_list|,
name|ti
operator|->
name|num_chars
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QFont QTextItem::font() const      Returns the font that should be used to draw the text. */
end_comment
begin_function
DECL|function|font
name|QFont
name|QTextItem
operator|::
name|font
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextItemInt
modifier|*
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|ti
operator|->
name|f
condition|?
operator|*
name|ti
operator|->
name|f
else|:
name|QApplication
operator|::
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \class QPaintEngine   \ingroup painting    \brief The QPaintEngine class provides an abstract definition of how   QPainter draws to a given device on a given platform.    Qt 4.0 provides several premade implementations of QPaintEngine for the   different painter backends we support. We provide one paint engine for each   window system and painting framework we support. This includes X11 on   Unix/Linux and CoreGraphics on Mac OS X. In addition we provide QPaintEngine   implementations for OpenGL (accessible through QGLWidget) and PostScript   (accessible through QPSPrinter on X11). Additionally there is a raster-based   paint engine that is a fallback for when an engine does not support a certain   capability.    If one wants to use QPainter to draw to a different backend,   one must subclass QPaintEngine and reimplement all its virtual   functions. The QPaintEngine implementation is then made available by   subclassing QPaintDevice and reimplementing the virtual function   QPaintDevice::paintEngine().    QPaintEngine is created and owned by the QPaintDevice that created it.    The big advantage of the QPaintEngine approach opposed to   Qt 3's QPainter/QPaintDevice::cmd() approach is that it is now   possible to adapt to multiple technologies on each platform and take   advantage of each to the fullest.    \sa QPainter, QPaintDevice::paintEngine(), {Paint System} */
end_comment
begin_comment
comment|/*!   \enum QPaintEngine::PaintEngineFeature    This enum is used to describe the features or capabilities that the   paint engine has. If a feature is not supported by the engine,   QPainter will do a best effort to emulate that feature through other   means and pass on an alpha blended QImage to the engine with the   emulated results. Some features cannot be emulated: AlphaBlend and PorterDuff.    \value AlphaBlend         The engine can alpha blend primitives.   \value Antialiasing       The engine can use antialising to improve the appearance                             of rendered primitives.   \value BlendModes         The engine supports blending modes.   \value BrushStroke        The engine supports drawing strokes that                             contain brushes as fills, not just solid                             colors (e.g. a dashed gradient line of                             width 2).   \value ConicalGradientFill The engine supports conical gradient fills.   \value ConstantOpacity    The engine supports the feature provided by                             QPainter::setOpacity().   \value LinearGradientFill The engine supports linear gradient fills.   \value MaskedBrush        The engine is capable of rendering brushes that has a                             texture with an alpha channel or a mask.   \value ObjectBoundingModeGradients The engine has native support for gradients                             with coordinate mode QGradient::ObjectBoundingMode.                             Otherwise, if QPaintEngine::PatternTransform is                             supported, object bounding mode gradients are                             converted to gradients with coordinate mode                             QGradient::LogicalMode and a brush transform for                             the coordinate mapping.   \value PainterPaths       The engine has path support.   \value PaintOutsidePaintEvent The engine is capable of painting outside of                                 paint events.   \value PatternBrush       The engine is capable of rendering brushes with                             the brush patterns specified in Qt::BrushStyle.   \value PatternTransform   The engine has support for transforming brush                             patterns.   \value PerspectiveTransform The engine has support for performing perspective                             transformations on primitives.   \value PixmapTransform    The engine can transform pixmaps, including                             rotation and shearing.   \value PorterDuff         The engine supports Porter-Duff operations   \value PrimitiveTransform The engine has support for transforming                             drawing primitives.   \value RadialGradientFill The engine supports radial gradient fills.   \value RasterOpModes      The engine supports bitwise raster operations.   \value AllFeatures        All of the above features. This enum value is usually                             used as a bit mask. */
end_comment
begin_comment
comment|/*!     \enum QPaintEngine::PolygonDrawMode      \value OddEvenMode The polygon should be drawn using OddEven fill     rule.      \value WindingMode The polygon should be drawn using Winding fill rule.      \value ConvexMode The polygon is a convex polygon and can be drawn     using specialized algorithms where available.      \value PolylineMode Only the outline of the polygon should be     drawn.  */
end_comment
begin_comment
comment|/*!     \enum QPaintEngine::DirtyFlag      \value DirtyPen The pen is dirty and needs to be updated.      \value DirtyBrush The brush is dirty and needs to be updated.      \value DirtyBrushOrigin The brush origin is dirty and needs to     updated.      \value DirtyFont The font is dirty and needs to be updated.      \value DirtyBackground The background is dirty and needs to be     updated.      \value DirtyBackgroundMode The background mode is dirty and needs     to be updated.      \value DirtyTransform The transform is dirty and needs to be     updated.      \value DirtyClipRegion The clip region is dirty and needs to be     updated.      \value DirtyClipPath The clip path is dirty and needs to be     updated.      \value DirtyHints The render hints is dirty and needs to be     updated.      \value DirtyCompositionMode The composition mode is dirty and     needs to be updated.      \value DirtyClipEnabled Whether clipping is enabled or not is     dirty and needs to be updated.      \value DirtyOpacity The constant opacity has changed and needs to                         be updated as part of the state change in                         QPaintEngine::updateState().      \value AllDirty Convenience enum used internally.      These types are used by QPainter to trigger lazy updates of the     various states in the QPaintEngine using     QPaintEngine::updateState().      A paint engine must update every dirty state. */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::syncState()      \internal      Updates all dirty states in this engine. This function should ONLY     be used when drawing with native handles directly and immediate sync     from QPainters state to the native state is required. */
end_comment
begin_function
DECL|function|syncState
name|void
name|QPaintEngine
operator|::
name|syncState
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|updateState
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|isExtended
argument_list|()
condition|)
cast|static_cast
argument_list|<
name|QPaintEngineEx
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|sync
argument_list|()
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|qt_polygon_recursion
specifier|static
name|QPaintEngine
modifier|*
name|qt_polygon_recursion
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QT_Point
struct|struct
name|QT_Point
block|{
DECL|member|x
name|int
name|x
decl_stmt|;
DECL|member|y
name|int
name|y
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     \fn void QPaintEngine::drawPolygon(const QPointF *points, int pointCount,     PolygonDrawMode mode)      Reimplement this virtual function to draw the polygon defined     by the \a pointCount first points in \a points, using mode \a     mode.      \note At least one of the drawPolygon() functions must be reimplemented. */
end_comment
begin_function
DECL|function|drawPolygon
name|void
name|QPaintEngine
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|PolygonDrawMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|qt_polygon_recursion
operator|!=
name|this
argument_list|,
literal|"QPaintEngine::drawPolygon"
argument_list|,
literal|"At least one drawPolygon function must be implemented"
argument_list|)
expr_stmt|;
name|qt_polygon_recursion
operator|=
name|this
expr_stmt|;
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QT_Point
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QPoint
argument_list|)
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|QT_Point
argument_list|>
name|p
argument_list|(
name|pointCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
name|i
index|]
operator|.
name|x
operator|=
name|qRound
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|.
name|y
operator|=
name|qRound
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|drawPolygon
argument_list|(
operator|(
name|QPoint
operator|*
operator|)
name|p
operator|.
name|data
argument_list|()
argument_list|,
name|pointCount
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|qt_polygon_recursion
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|QT_PointF
struct|struct
name|QT_PointF
block|{
DECL|member|x
name|qreal
name|x
decl_stmt|;
DECL|member|y
name|qreal
name|y
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     \overload      Reimplement this virtual function to draw the polygon defined by the     \a pointCount first points in \a points, using mode \a mode.      \note At least one of the drawPolygon() functions must be reimplemented. */
end_comment
begin_function
DECL|function|drawPolygon
name|void
name|QPaintEngine
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|PolygonDrawMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|qt_polygon_recursion
operator|!=
name|this
argument_list|,
literal|"QPaintEngine::drawPolygon"
argument_list|,
literal|"At least one drawPolygon function must be implemented"
argument_list|)
expr_stmt|;
name|qt_polygon_recursion
operator|=
name|this
expr_stmt|;
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QT_PointF
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QPointF
argument_list|)
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|QT_PointF
argument_list|>
name|p
argument_list|(
name|pointCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
name|i
index|]
operator|.
name|x
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
name|p
index|[
name|i
index|]
operator|.
name|y
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|drawPolygon
argument_list|(
operator|(
name|QPointF
operator|*
operator|)
name|p
operator|.
name|data
argument_list|()
argument_list|,
name|pointCount
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|qt_polygon_recursion
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QPaintEngine::Type      \value X11     \value Windows     \value MacPrinter     \value CoreGraphics Mac OS X's Quartz2D (CoreGraphics)     \value QuickDraw Mac OS X's QuickDraw     \value QWindowSystem Qt for Embedded Linux     \value PostScript     \value OpenGL     \value Picture QPicture format     \value SVG Scalable Vector Graphics XML format     \value Raster     \value Direct3D Windows only, Direct3D based engine     \value Pdf Portable Document Format     \value OpenVG     \value User First user type ID     \value MaxUser Last user type ID     \value OpenGL2     \value PaintBuffer */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::isActive() const      Returns true if the paint engine is actively drawing; otherwise     returns false.      \sa setActive() */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::setActive(bool state)      Sets the active state of the paint engine to \a state.      \sa isActive() */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::begin(QPaintDevice *pdev)      Reimplement this function to initialise your paint engine when     painting is to start on the paint device \a pdev. Return true if     the initialization was successful; otherwise return false.      \sa end() isActive() */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::end()      Reimplement this function to finish painting on the current paint     device. Return true if painting was finished successfully;     otherwise return false.      \sa begin() isActive() */
end_comment
begin_comment
comment|/*!     Draws the first \a pointCount points in the buffer \a points */
end_comment
begin_function
DECL|function|drawPoints
name|void
name|QPaintEngine
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
name|QPainter
modifier|*
name|p
init|=
name|painter
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|qreal
name|penWidth
init|=
name|p
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|penWidth
operator|==
literal|0
condition|)
name|penWidth
operator|=
literal|1
expr_stmt|;
name|bool
name|ellipses
init|=
name|p
operator|->
name|pen
argument_list|()
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|RoundCap
decl_stmt|;
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|QTransform
name|transform
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pen
argument_list|()
operator|.
name|isCosmetic
argument_list|()
condition|)
block|{
name|transform
operator|=
name|p
operator|->
name|transform
argument_list|()
expr_stmt|;
name|p
operator|->
name|setTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|setBrush
argument_list|(
name|p
operator|->
name|pen
argument_list|()
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pos
init|=
name|transform
operator|.
name|map
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|QRectF
name|rect
argument_list|(
name|pos
operator|.
name|x
argument_list|()
operator|-
name|penWidth
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|-
name|penWidth
operator|/
literal|2
argument_list|,
name|penWidth
argument_list|,
name|penWidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|ellipses
condition|)
name|p
operator|->
name|drawEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|drawRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the first \a pointCount points in the buffer \a points      The default implementation converts the first \a pointCount QPoints in \a points     to QPointFs and calls the floating point version of drawPoints.  */
end_comment
begin_function
DECL|function|drawPoints
name|void
name|QPaintEngine
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QT_PointF
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QPointF
argument_list|)
argument_list|)
expr_stmt|;
name|QT_PointF
name|fp
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|pointCount
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|pointCount
operator|&&
name|i
operator|<
literal|256
condition|)
block|{
name|fp
index|[
name|i
index|]
operator|.
name|x
operator|=
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
name|fp
index|[
name|i
index|]
operator|.
name|y
operator|=
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|drawPoints
argument_list|(
operator|(
name|QPointF
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|points
operator|+=
name|i
expr_stmt|;
name|pointCount
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPaintEngine::drawEllipse(const QRectF&rect)      Reimplement this function to draw the largest ellipse that can be     contained within rectangle \a rect.      The default implementation calls drawPolygon(). */
end_comment
begin_function
DECL|function|drawEllipse
name|void
name|QPaintEngine
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFeature
argument_list|(
name|PainterPaths
argument_list|)
condition|)
block|{
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPolygonF
name|polygon
init|=
name|path
operator|.
name|toFillPolygon
argument_list|()
decl_stmt|;
name|drawPolygon
argument_list|(
name|polygon
operator|.
name|data
argument_list|()
argument_list|,
name|polygon
operator|.
name|size
argument_list|()
argument_list|,
name|ConvexMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     The default implementation of this function calls the floating     point version of this function */
end_comment
begin_function
DECL|function|drawEllipse
name|void
name|QPaintEngine
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|drawEllipse
argument_list|(
name|QRectF
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPaintEngine::drawPixmap(const QRectF&r, const QPixmap&pm, const QRectF&sr)      Reimplement this function to draw the part of the \a pm     specified by the \a sr rectangle in the given \a r. */
end_comment
begin_function
DECL|function|qt_fill_tile
name|void
name|qt_fill_tile
parameter_list|(
name|QPixmap
modifier|*
name|tile
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|QPainter
name|p
argument_list|(
name|tile
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
name|int
name|x
init|=
name|pixmap
operator|.
name|width
argument_list|()
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|tile
operator|->
name|width
argument_list|()
condition|)
block|{
name|p
operator|.
name|drawPixmap
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
operator|*
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|pixmap
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|x
operator|*=
literal|2
expr_stmt|;
block|}
name|int
name|y
init|=
name|pixmap
operator|.
name|height
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|tile
operator|->
name|height
argument_list|()
condition|)
block|{
name|p
operator|.
name|drawPixmap
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
operator|*
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tile
operator|->
name|width
argument_list|()
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|y
operator|*=
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_draw_tile
name|void
name|qt_draw_tile
parameter_list|(
name|QPaintEngine
modifier|*
name|gc
parameter_list|,
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
name|w
parameter_list|,
name|qreal
name|h
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|qreal
name|xOffset
parameter_list|,
name|qreal
name|yOffset
parameter_list|)
block|{
name|qreal
name|yPos
decl_stmt|,
name|xPos
decl_stmt|,
name|drawH
decl_stmt|,
name|drawW
decl_stmt|,
name|yOff
decl_stmt|,
name|xOff
decl_stmt|;
name|yPos
operator|=
name|y
expr_stmt|;
name|yOff
operator|=
name|yOffset
expr_stmt|;
while|while
condition|(
name|yPos
operator|<
name|y
operator|+
name|h
condition|)
block|{
name|drawH
operator|=
name|pixmap
operator|.
name|height
argument_list|()
operator|-
name|yOff
expr_stmt|;
comment|// Cropping first row
if|if
condition|(
name|yPos
operator|+
name|drawH
operator|>
name|y
operator|+
name|h
condition|)
comment|// Cropping last row
name|drawH
operator|=
name|y
operator|+
name|h
operator|-
name|yPos
expr_stmt|;
name|xPos
operator|=
name|x
expr_stmt|;
name|xOff
operator|=
name|xOffset
expr_stmt|;
while|while
condition|(
name|xPos
operator|<
name|x
operator|+
name|w
condition|)
block|{
name|drawW
operator|=
name|pixmap
operator|.
name|width
argument_list|()
operator|-
name|xOff
expr_stmt|;
comment|// Cropping first column
if|if
condition|(
name|xPos
operator|+
name|drawW
operator|>
name|x
operator|+
name|w
condition|)
comment|// Cropping last column
name|drawW
operator|=
name|x
operator|+
name|w
operator|-
name|xPos
expr_stmt|;
if|if
condition|(
name|drawW
operator|>
literal|0
operator|&&
name|drawH
operator|>
literal|0
condition|)
name|gc
operator|->
name|drawPixmap
argument_list|(
name|QRectF
argument_list|(
name|xPos
argument_list|,
name|yPos
argument_list|,
name|drawW
argument_list|,
name|drawH
argument_list|)
argument_list|,
name|pixmap
argument_list|,
name|QRectF
argument_list|(
name|xOff
argument_list|,
name|yOff
argument_list|,
name|drawW
argument_list|,
name|drawH
argument_list|)
argument_list|)
expr_stmt|;
name|xPos
operator|+=
name|drawW
expr_stmt|;
name|xOff
operator|=
literal|0
expr_stmt|;
block|}
name|yPos
operator|+=
name|drawH
expr_stmt|;
name|yOff
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Reimplement this function to draw the \a pixmap in the given \a     rect, starting at the given \a p. The pixmap will be     drawn repeatedly until the \a rect is filled. */
end_comment
begin_function
DECL|function|drawTiledPixmap
name|void
name|QPaintEngine
operator|::
name|drawTiledPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
name|int
name|sw
init|=
name|pixmap
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|sh
init|=
name|pixmap
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|sw
operator|*
name|sh
operator|<
literal|8192
operator|&&
name|sw
operator|*
name|sh
operator|<
literal|16
operator|*
name|rect
operator|.
name|width
argument_list|()
operator|*
name|rect
operator|.
name|height
argument_list|()
condition|)
block|{
name|int
name|tw
init|=
name|sw
decl_stmt|,
name|th
init|=
name|sh
decl_stmt|;
while|while
condition|(
name|tw
operator|*
name|th
operator|<
literal|32678
operator|&&
name|tw
operator|<
name|rect
operator|.
name|width
argument_list|()
operator|/
literal|2
condition|)
name|tw
operator|*=
literal|2
expr_stmt|;
while|while
condition|(
name|tw
operator|*
name|th
operator|<
literal|32678
operator|&&
name|th
operator|<
name|rect
operator|.
name|height
argument_list|()
operator|/
literal|2
condition|)
name|th
operator|*=
literal|2
expr_stmt|;
name|QPixmap
name|tile
decl_stmt|;
if|if
condition|(
name|pixmap
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|tile
operator|=
name|QBitmap
argument_list|(
name|tw
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tile
operator|=
name|QPixmap
argument_list|(
name|tw
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixmap
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|tile
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
block|}
name|qt_fill_tile
argument_list|(
operator|&
name|tile
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
name|qt_draw_tile
argument_list|(
name|this
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|tile
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_draw_tile
argument_list|(
name|this
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|pixmap
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPaintEngine::drawImage(const QRectF&rectangle, const QImage&image, const QRectF&sr, Qt::ImageConversionFlags flags)      Reimplement this function to draw the part of the \a image     specified by the \a sr rectangle in the given \a rectangle using     the given conversion flags \a flags, to convert it to a pixmap. */
end_comment
begin_function
DECL|function|drawImage
name|void
name|QPaintEngine
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|QRectF
name|baseSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QImage
name|im
init|=
name|image
decl_stmt|;
if|if
condition|(
name|baseSize
operator|!=
name|sr
condition|)
name|im
operator|=
name|im
operator|.
name|copy
argument_list|(
name|qFloor
argument_list|(
name|sr
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qFloor
argument_list|(
name|sr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qCeil
argument_list|(
name|sr
operator|.
name|width
argument_list|()
argument_list|)
argument_list|,
name|qCeil
argument_list|(
name|sr
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QPixmap
name|pm
init|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|im
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|drawPixmap
argument_list|(
name|r
argument_list|,
name|pm
argument_list|,
name|QRectF
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pm
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn Type QPaintEngine::type() const      Reimplement this function to return the paint engine \l{Type}. */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::fix_neg_rect(int *x, int *y, int *w, int *h);      \internal */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::testDirty(DirtyFlags df)      \internal */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::clearDirty(DirtyFlags df)      \internal */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::setDirty(DirtyFlags df)      \internal */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::hasFeature(PaintEngineFeatures feature) const      Returns true if the paint engine supports the specified \a     feature; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QPaintEngine::isExtended() const      \internal      Returns true if the paint engine is a QPaintEngineEx derivative. */
end_comment
begin_comment
comment|/*!     \fn void QPaintEngine::updateState(const QPaintEngineState&state)      Reimplement this function to update the state of a paint engine.      When implemented, this function is responsible for checking the     paint engine's current \a state and update the properties that are     changed. Use the QPaintEngineState::state() function to find out     which properties that must be updated, then use the corresponding     \l {GetFunction}{get function} to retrieve the current values for     the given properties.      \sa QPaintEngineState */
end_comment
begin_comment
comment|/*!     Creates a paint engine with the featureset specified by \a caps. */
end_comment
begin_constructor
DECL|function|QPaintEngine
name|QPaintEngine
operator|::
name|QPaintEngine
parameter_list|(
name|PaintEngineFeatures
name|caps
parameter_list|)
member_init_list|:
name|state
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|gccaps
argument_list|(
name|caps
argument_list|)
member_init_list|,
name|active
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|selfDestruct
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|extended
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QPaintEnginePrivate
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QPaintEngine
name|QPaintEngine
operator|::
name|QPaintEngine
parameter_list|(
name|QPaintEnginePrivate
modifier|&
name|dptr
parameter_list|,
name|PaintEngineFeatures
name|caps
parameter_list|)
member_init_list|:
name|state
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|gccaps
argument_list|(
name|caps
argument_list|)
member_init_list|,
name|active
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|selfDestruct
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|extended
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|&
name|dptr
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the paint engine. */
end_comment
begin_destructor
DECL|function|~QPaintEngine
name|QPaintEngine
operator|::
name|~
name|QPaintEngine
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the paint engine's painter. */
end_comment
begin_function
DECL|function|painter
name|QPainter
modifier|*
name|QPaintEngine
operator|::
name|painter
parameter_list|()
specifier|const
block|{
return|return
name|state
condition|?
name|state
operator|->
name|painter
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     The default implementation ignores the \a path and does nothing. */
end_comment
begin_function
DECL|function|drawPath
name|void
name|QPaintEngine
operator|::
name|drawPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
parameter_list|)
block|{
if|if
condition|(
name|hasFeature
argument_list|(
name|PainterPaths
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPaintEngine::drawPath: Must be implemented when feature PainterPaths is set"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function draws the text item \a textItem at position \a p. The     default implementation of this function converts the text to a     QPainterPath and paints the resulting path. */
end_comment
begin_function
DECL|function|drawTextItem
name|void
name|QPaintEngine
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItem
modifier|&
name|textItem
parameter_list|)
block|{
specifier|const
name|QTextItemInt
modifier|&
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|&
argument_list|>
argument_list|(
name|textItem
argument_list|)
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
name|path
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ti
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|)
name|ti
operator|.
name|fontEngine
operator|->
name|addOutlineToPath
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|,
name|ti
operator|.
name|glyphs
argument_list|,
operator|&
name|path
argument_list|,
name|ti
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|oldAA
init|=
name|painter
argument_list|()
operator|->
name|renderHints
argument_list|()
operator|&
name|QPainter
operator|::
name|Antialiasing
decl_stmt|;
name|painter
argument_list|()
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
name|bool
argument_list|(
operator|(
name|painter
argument_list|()
operator|->
name|renderHints
argument_list|()
operator|&
name|QPainter
operator|::
name|TextAntialiasing
operator|)
operator|&&
operator|!
operator|(
name|painter
argument_list|()
operator|->
name|font
argument_list|()
operator|.
name|styleStrategy
argument_list|()
operator|&
name|QFont
operator|::
name|NoAntialias
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|painter
argument_list|()
operator|->
name|fillPath
argument_list|(
name|path
argument_list|,
name|state
operator|->
name|pen
argument_list|()
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
name|painter
argument_list|()
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
name|oldAA
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     The default implementation splits the list of lines in \a lines     into \a lineCount separate calls to drawPath() or drawPolygon()     depending on the feature set of the paint engine. */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPaintEngine
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLineF
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pts
index|[
literal|2
index|]
init|=
block|{
name|lines
index|[
name|i
index|]
operator|.
name|p1
argument_list|()
block|,
name|lines
index|[
name|i
index|]
operator|.
name|p2
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|pts
index|[
literal|0
index|]
operator|==
name|pts
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|pen
argument_list|()
operator|.
name|capStyle
argument_list|()
operator|!=
name|Qt
operator|::
name|FlatCap
condition|)
name|drawPoints
argument_list|(
name|pts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|drawPolygon
argument_list|(
name|pts
argument_list|,
literal|2
argument_list|,
name|PolylineMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      The default implementation converts the first \a lineCount lines     in \a lines to a QLineF and calls the floating point version of     this function. */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPaintEngine
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLine
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
struct|struct
name|PointF
block|{
name|qreal
name|x
decl_stmt|;
name|qreal
name|y
decl_stmt|;
block|}
struct|;
struct|struct
name|LineF
block|{
name|PointF
name|p1
decl_stmt|;
name|PointF
name|p2
decl_stmt|;
block|}
struct|;
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|PointF
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QPointF
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|LineF
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QLineF
argument_list|)
argument_list|)
expr_stmt|;
name|LineF
name|fl
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|lineCount
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|lineCount
operator|&&
name|i
operator|<
literal|256
condition|)
block|{
name|fl
index|[
name|i
index|]
operator|.
name|p1
operator|.
name|x
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|x1
argument_list|()
expr_stmt|;
name|fl
index|[
name|i
index|]
operator|.
name|p1
operator|.
name|y
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|y1
argument_list|()
expr_stmt|;
name|fl
index|[
name|i
index|]
operator|.
name|p2
operator|.
name|x
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|x2
argument_list|()
expr_stmt|;
name|fl
index|[
name|i
index|]
operator|.
name|p2
operator|.
name|y
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|y2
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|drawLines
argument_list|(
operator|(
name|QLineF
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|fl
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lines
operator|+=
name|i
expr_stmt|;
name|lineCount
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      The default implementation converts the first \a rectCount     rectangles in the buffer \a rects to a QRectF and calls the     floating point version of this function. */
end_comment
begin_function
DECL|function|drawRects
name|void
name|QPaintEngine
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
struct|struct
name|RectF
block|{
name|qreal
name|x
decl_stmt|;
name|qreal
name|y
decl_stmt|;
name|qreal
name|w
decl_stmt|;
name|qreal
name|h
decl_stmt|;
block|}
struct|;
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|RectF
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QRectF
argument_list|)
argument_list|)
expr_stmt|;
name|RectF
name|fr
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|rectCount
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|rectCount
operator|&&
name|i
operator|<
literal|256
condition|)
block|{
name|fr
index|[
name|i
index|]
operator|.
name|x
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
name|fr
index|[
name|i
index|]
operator|.
name|y
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
expr_stmt|;
name|fr
index|[
name|i
index|]
operator|.
name|w
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
expr_stmt|;
name|fr
index|[
name|i
index|]
operator|.
name|h
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|drawRects
argument_list|(
operator|(
name|QRectF
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|fr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rects
operator|+=
name|i
expr_stmt|;
name|rectCount
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Draws the first \a rectCount rectangles in the buffer \a     rects. The default implementation of this function calls drawPath()     or drawPolygon() depending on the feature set of the paint engine. */
end_comment
begin_function
DECL|function|drawRects
name|void
name|QPaintEngine
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRectF
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
if|if
condition|(
name|hasFeature
argument_list|(
name|PainterPaths
argument_list|)
operator|&&
operator|!
name|state
operator|->
name|penNeedsResolving
argument_list|()
operator|&&
operator|!
name|state
operator|->
name|brushNeedsResolving
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|rf
init|=
name|rects
index|[
name|i
index|]
decl_stmt|;
name|QPointF
name|pts
index|[
literal|4
index|]
init|=
block|{
name|QPointF
argument_list|(
name|rf
operator|.
name|x
argument_list|()
argument_list|,
name|rf
operator|.
name|y
argument_list|()
argument_list|)
block|,
name|QPointF
argument_list|(
name|rf
operator|.
name|x
argument_list|()
operator|+
name|rf
operator|.
name|width
argument_list|()
argument_list|,
name|rf
operator|.
name|y
argument_list|()
argument_list|)
block|,
name|QPointF
argument_list|(
name|rf
operator|.
name|x
argument_list|()
operator|+
name|rf
operator|.
name|width
argument_list|()
argument_list|,
name|rf
operator|.
name|y
argument_list|()
operator|+
name|rf
operator|.
name|height
argument_list|()
argument_list|)
block|,
name|QPointF
argument_list|(
argument|rf.x()
argument_list|,
argument|rf.y() + rf.height()
argument_list|)
block|}
decl_stmt|;
name|drawPolygon
argument_list|(
name|pts
argument_list|,
literal|4
argument_list|,
name|ConvexMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Sets the paintdevice that this engine operates on to \a device */
end_comment
begin_function
DECL|function|setPaintDevice
name|void
name|QPaintEngine
operator|::
name|setPaintDevice
parameter_list|(
name|QPaintDevice
modifier|*
name|device
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|pdev
operator|=
name|device
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the device that this engine is painting on, if painting is     active; otherwise returns 0. */
end_comment
begin_function
DECL|function|paintDevice
name|QPaintDevice
modifier|*
name|QPaintEngine
operator|::
name|paintDevice
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pdev
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_WIN
end_ifdef
begin_comment
comment|/*!     \internal      Empty default implementation. */
end_comment
begin_function
DECL|function|getDC
name|HDC
name|QPaintEngine
operator|::
name|getDC
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Empty default implementation. */
end_comment
begin_function
DECL|function|releaseDC
name|void
name|QPaintEngine
operator|::
name|releaseDC
parameter_list|(
name|HDC
parameter_list|)
specifier|const
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal      Returns the offset from the painters origo to the engines     origo. This value is used by QPainter for engines who have     internal double buffering.      This function only makes sense when the engine is active. */
end_comment
begin_function
DECL|function|coordinateOffset
name|QPoint
name|QPaintEngine
operator|::
name|coordinateOffset
parameter_list|()
specifier|const
block|{
return|return
name|QPoint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the system clip for this engine. The system clip defines the     basis area that the engine has to draw in. All clips that are     set will be be an intersection with the system clip.      Reset the systemclip to no clip by setting an empty region. */
end_comment
begin_function
DECL|function|setSystemClip
name|void
name|QPaintEngine
operator|::
name|setSystemClip
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|systemClip
operator|=
name|region
expr_stmt|;
comment|// Be backward compatible and only call d->systemStateChanged()
comment|// if we currently have a system transform/viewport set.
if|if
condition|(
name|d
operator|->
name|hasSystemTransform
operator|||
name|d
operator|->
name|hasSystemViewport
condition|)
block|{
name|d
operator|->
name|transformSystemClip
argument_list|()
expr_stmt|;
name|d
operator|->
name|systemStateChanged
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the system clip. The system clip is read only while the     painter is active. An empty region indicates that system clip     is not in use. */
end_comment
begin_function
DECL|function|systemClip
name|QRegion
name|QPaintEngine
operator|::
name|systemClip
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|systemClip
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the target rect for drawing within the backing store. This     function should ONLY be used by the backing store. */
end_comment
begin_function
DECL|function|setSystemRect
name|void
name|QPaintEngine
operator|::
name|setSystemRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPaintEngine::setSystemRect: Should not be changed while engine is active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_func
argument_list|()
operator|->
name|systemRect
operator|=
name|rect
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Retrieves the rect for drawing within the backing store. This     function should ONLY be used by the backing store.  */
end_comment
begin_function
DECL|function|systemRect
name|QRect
name|QPaintEngine
operator|::
name|systemRect
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|systemRect
return|;
block|}
end_function
begin_function
DECL|function|drawBoxTextItem
name|void
name|QPaintEnginePrivate
operator|::
name|drawBoxTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItemInt
modifier|&
name|ti
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ti
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|)
return|return;
comment|// any fixes here should probably also be done in QFontEngineBox::draw
specifier|const
name|int
name|size
init|=
name|qRound
argument_list|(
name|ti
operator|.
name|fontEngine
operator|->
name|ascent
argument_list|()
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QFixedPoint
argument_list|>
name|positions
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|glyph_t
argument_list|>
name|glyphs
decl_stmt|;
name|QTransform
name|matrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
operator|-
name|size
argument_list|)
decl_stmt|;
name|ti
operator|.
name|fontEngine
operator|->
name|getGlyphPositions
argument_list|(
name|ti
operator|.
name|glyphs
argument_list|,
name|matrix
argument_list|,
name|ti
operator|.
name|flags
argument_list|,
name|glyphs
argument_list|,
name|positions
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyphs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|QSize
name|s
argument_list|(
name|size
operator|-
literal|3
argument_list|,
name|size
operator|-
literal|3
argument_list|)
decl_stmt|;
name|QPainter
modifier|*
name|painter
init|=
name|q_func
argument_list|()
operator|->
name|state
operator|->
name|painter
argument_list|()
decl_stmt|;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|QPen
name|pen
init|=
name|painter
operator|->
name|pen
argument_list|()
decl_stmt|;
name|pen
operator|.
name|setWidthF
argument_list|(
name|ti
operator|.
name|fontEngine
operator|->
name|lineThickness
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|positions
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
name|painter
operator|->
name|drawRect
argument_list|(
name|QRectF
argument_list|(
name|positions
index|[
name|k
index|]
operator|.
name|toPointF
argument_list|()
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
