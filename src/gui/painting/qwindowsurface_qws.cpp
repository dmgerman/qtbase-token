begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindowsurface_qws_p.h"
end_include
begin_include
include|#
directive|include
file|<qwidget.h>
end_include
begin_include
include|#
directive|include
file|<qscreen_qws.h>
end_include
begin_include
include|#
directive|include
file|<qwsmanager_qws.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qwsdisplay_qws.h>
end_include
begin_include
include|#
directive|include
file|<qrgb.h>
end_include
begin_include
include|#
directive|include
file|<qpaintengine.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwsdisplay_qws_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwsmanager_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwslock_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qbackingstore_p.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifdef
ifdef|#
directive|ifdef
name|Q_BACKINGSTORE_SUBSURFACES
end_ifdef
begin_typedef
DECL|typedef|SurfaceMap
typedef|typedef
name|QMap
argument_list|<
name|int
argument_list|,
name|QWSWindowSurface
modifier|*
argument_list|>
name|SurfaceMap
typedef|;
end_typedef
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|SurfaceMap
argument_list|,
name|winIdToSurfaceMap
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|qt_findWindowSurface
name|QWSWindowSurface
modifier|*
name|qt_findWindowSurface
parameter_list|(
name|int
name|winId
parameter_list|)
block|{
return|return
name|winIdToSurfaceMap
argument_list|()
operator|->
name|value
argument_list|(
name|winId
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_insertWindowSurface
specifier|static
name|void
name|qt_insertWindowSurface
parameter_list|(
name|int
name|winId
parameter_list|,
name|QWSWindowSurface
modifier|*
name|surface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|surface
condition|)
name|winIdToSurfaceMap
argument_list|()
operator|->
name|remove
argument_list|(
name|winId
argument_list|)
expr_stmt|;
else|else
name|winIdToSurfaceMap
argument_list|()
operator|->
name|insert
argument_list|(
name|winId
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_BACKINGSTORE_SUBSURFACES
end_comment
begin_function
DECL|function|isWidgetOpaque
specifier|inline
name|bool
name|isWidgetOpaque
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
return|return
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|isOpaque
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getScreen
specifier|static
specifier|inline
name|QScreen
modifier|*
name|getScreen
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|subScreens
init|=
name|qt_screen
operator|->
name|subScreens
argument_list|()
decl_stmt|;
if|if
condition|(
name|subScreens
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|qt_screen
return|;
specifier|const
name|int
name|screen
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenNumber
argument_list|(
name|w
argument_list|)
decl_stmt|;
return|return
name|qt_screen
operator|->
name|subScreens
argument_list|()
operator|.
name|at
argument_list|(
name|screen
operator|<
literal|0
condition|?
literal|0
else|:
name|screen
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|bytesPerPixel
specifier|static
name|int
name|bytesPerPixel
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Invalid
case|:
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|qFatal
argument_list|(
literal|"QWSWindowSurface: Invalid backingstore format: %i"
argument_list|,
name|int
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
return|return
literal|1
return|;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
return|return
literal|4
return|;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
return|return
literal|2
return|;
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
return|return
literal|3
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qFatal
argument_list|(
literal|"QWSWindowSurface: Invalid backingstore format: %i"
argument_list|,
name|int
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|nextMulOf4
specifier|static
specifier|inline
name|int
name|nextMulOf4
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|n
operator|+
literal|3
operator|)
operator|&
literal|0xfffffffc
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setImageMetrics
specifier|static
specifier|inline
name|void
name|setImageMetrics
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
name|QWidget
modifier|*
name|window
parameter_list|)
block|{
name|QScreen
modifier|*
name|myScreen
init|=
name|getScreen
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|myScreen
condition|)
block|{
name|int
name|dpmx
init|=
name|myScreen
operator|->
name|width
argument_list|()
operator|*
literal|1000
operator|/
name|myScreen
operator|->
name|physicalWidth
argument_list|()
decl_stmt|;
name|int
name|dpmy
init|=
name|myScreen
operator|->
name|height
argument_list|()
operator|*
literal|1000
operator|/
name|myScreen
operator|->
name|physicalHeight
argument_list|()
decl_stmt|;
name|img
operator|.
name|setDotsPerMeterX
argument_list|(
name|dpmx
argument_list|)
expr_stmt|;
name|img
operator|.
name|setDotsPerMeterY
argument_list|(
name|dpmy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invalidateBuffer
name|void
name|QWSWindowSurface
operator|::
name|invalidateBuffer
parameter_list|()
block|{
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|win
condition|)
block|{
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|invalidateBuffer
argument_list|(
name|win
operator|->
name|rect
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MANAGER
name|QTLWExtra
modifier|*
name|topextra
init|=
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|topextra
decl_stmt|;
name|QWSManager
modifier|*
name|manager
init|=
name|topextra
operator|->
name|qwsManager
decl_stmt|;
if|if
condition|(
name|manager
condition|)
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|dirtyRegion
argument_list|(
name|QDecoration
operator|::
name|All
argument_list|,
name|QDecoration
operator|::
name|Normal
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_constructor
DECL|function|QWSWindowSurfacePrivate
name|QWSWindowSurfacePrivate
operator|::
name|QWSWindowSurfacePrivate
parameter_list|()
member_init_list|:
name|flags
argument_list|(
literal|0
argument_list|)
member_init_list|,
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|directId
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
endif|#
directive|endif
name|winId
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|setWinId
name|void
name|QWSWindowSurfacePrivate
operator|::
name|setWinId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|winId
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_function
DECL|function|winId
name|int
name|QWSWindowSurface
operator|::
name|winId
parameter_list|()
specifier|const
block|{
comment|// XXX: the widget winId may change during the lifetime of the widget!!!
specifier|const
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|win
operator|&&
name|win
operator|->
name|isWindow
argument_list|()
condition|)
return|return
name|win
operator|->
name|internalWinId
argument_list|()
return|;
ifdef|#
directive|ifdef
name|Q_BACKINGSTORE_SUBSURFACES
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|winId
condition|)
block|{
name|QWSWindowSurface
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QWSWindowSurface
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QWSDisplay
modifier|*
name|display
init|=
name|QWSDisplay
operator|::
name|instance
argument_list|()
decl_stmt|;
specifier|const
name|int
name|id
init|=
name|display
operator|->
name|takeId
argument_list|()
decl_stmt|;
name|qt_insertWindowSurface
argument_list|(
name|id
argument_list|,
name|that
argument_list|)
expr_stmt|;
name|that
operator|->
name|d_ptr
operator|->
name|winId
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|win
condition|)
name|display
operator|->
name|nameRegion
argument_list|(
name|id
argument_list|,
name|win
operator|->
name|objectName
argument_list|()
argument_list|,
name|win
operator|->
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|display
operator|->
name|nameRegion
argument_list|(
name|id
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|display
operator|->
name|setAltitude
argument_list|(
name|id
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// XXX
block|}
endif|#
directive|endif
return|return
name|d_ptr
operator|->
name|winId
return|;
block|}
end_function
begin_function
DECL|function|setWinId
name|void
name|QWSWindowSurface
operator|::
name|setWinId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|d_ptr
operator|->
name|winId
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QWSWindowSurface     \since 4.2     \ingroup qws     \preliminary     \internal      \brief The QWSWindowSurface class provides the drawing area for top-level     windows in Qt for Embedded Linux.      Note that this class is only available in Qt for Embedded Linux.      In \l{Qt for Embedded Linux}, the default behavior is for each client to     render its widgets into memory while the server is responsible for     putting the contents of the memory onto the     screen. QWSWindowSurface is used by the window system to implement     the associated memory allocation.      When a screen update is required, the server runs through all the     top-level windows that intersect with the region that is about to     be updated, and ensures that the associated clients have updated     their memory buffer. Then the server uses the screen driver to     copy the content of the memory to the screen. To locate the     relevant parts of memory, the driver is provided with the list of     top-level windows that intersect with the given region. Associated     with each of the top-level windows there is a window surface     representing the drawing area of the window.      When deriving from the QWSWindowSurface class, e.g., when adding     an \l {Adding an Accelerated Graphics Driver to Qt for Embedded Linux}     {accelerated graphics driver}, there are several pure virtual     functions that must be implemented. In addition, QWSWindowSurface     provides several virtual functions that can be reimplemented to     customize the drawing process.      \tableofcontents      \section1 Pure Virtual Functions      There are in fact two window surface instances for each top-level     window; one used by the application when drawing a window, and     another used by the server application to perform window     compositioning. Implement the attach() to create the server-side     representation of the surface. The data() function must be     implemented to provide the required data.      Implement the key() function to uniquely identify the surface     class, and the isValid() function to determine is a surface     corresponds to a given widget.      The geometry() function must be implemented to let the window     system determine the area required by the window surface     (QWSWindowSurface also provides a corresponding virtual     setGeometry() function that is called whenever the area necessary     for the top-level window to be drawn, changes). The image()     function is called by the window system during window     compositioning, and must be implemented to return an image of the     top-level window.      Finally, the paintDevice() function must be implemented to return     the appropriate paint device, and the scroll() function must be     implemented to scroll the given region of the surface the given     number of pixels.      \section1 Virtual Functions      When painting onto the surface, the window system will always call     the beginPaint() function before any painting operations are     performed. Likewise the endPaint() function is automatically     called when the painting is done. Reimplement the painterOffset()     function to alter the offset that is applied when drawing.      The window system uses the flush() function to put a given region     of the widget onto the screen, and the release() function to     deallocate the screen region corresponding to this window surface.      \section1 Other Members      QWSWindowSurface provides the window() function returning a     pointer to the top-level window the surface is representing. The     currently visible region of the associated widget can be retrieved     and set using the clipRegion() and setClipRegion() functions,     respectively.      When the window system performs the window compositioning, it uses     the SurfaceFlag enum describing the surface content. The currently     set surface flags can be retrieved and altered using the     surfaceFlags() and setSurfaceFlags() functions. In addition,     QWSWindowSurface provides the isBuffered(), isOpaque() and     isRegionReserved() convenience functions.      \sa {Qt for Embedded Linux Architecture#Drawing on Screen}{Qt for     Embedded Linux Architecture} */
end_comment
begin_comment
comment|/*!     \enum QWSWindowSurface::SurfaceFlag      This enum is used to describe the window surface's contents.  It     is used by the screen driver to handle region allocation and     composition.      \value RegionReserved The surface contains a reserved area. Once     allocated, a reserved area can not not be changed by the window     system, i.e., no other widgets can be drawn on top of this.      \value Buffered     The surface is in a memory area which is not part of a framebuffer.     (A top-level window with QWidget::windowOpacity() other than 1.0 must use     a buffered surface in order to making blending with the background work.)      \value Opaque     The surface contains only opaque pixels.      \sa surfaceFlags(), setSurfaceFlags() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindowSurface::isValid() const     \since 4.3      Implement this function to return true if the surface is a valid     surface for the given top-level \a window; otherwise return     false.      \sa window(), key() */
end_comment
begin_comment
comment|/*!     \fn QString QWSWindowSurface::key() const      Implement this function to return a string that uniquely     identifies the class of this surface.      \sa window(), isValid() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QWSWindowSurface::permanentState() const     \since 4.3      Implement this function to return the data required for creating a     server-side representation of the surface.      \sa attach() */
end_comment
begin_comment
comment|/*!     \fn void QWSWindowSurface::setPermanentState(const QByteArray&data)     \since 4.3      Implement this function to attach a server-side surface instance     to the corresponding client side instance using the given \a     data. Return true if successful; otherwise return false.      \sa data() */
end_comment
begin_comment
comment|/*!     \fn const QImage QWSWindowSurface::image() const      Implement this function to return an image of the top-level window.      \sa geometry() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindowSurface::isRegionReserved() const      Returns true if the QWSWindowSurface::RegionReserved is set; otherwise     returns false.      \sa surfaceFlags() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindowSurface::isBuffered() const      Returns true if the QWSWindowSurface::Buffered is set; otherwise returns false.      \sa surfaceFlags() */
end_comment
begin_comment
comment|/*!     \fn bool QWSWindowSurface::isOpaque() const      Returns true if the QWSWindowSurface::Opaque is set; otherwise     returns false.      \sa surfaceFlags() */
end_comment
begin_comment
comment|/*!     Constructs an empty surface. */
end_comment
begin_constructor
DECL|function|QWSWindowSurface
name|QWSWindowSurface
operator|::
name|QWSWindowSurface
parameter_list|()
member_init_list|:
name|QWindowSurface
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QWSWindowSurfacePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs an empty surface for the given top-level \a widget. */
end_comment
begin_constructor
DECL|function|QWSWindowSurface
name|QWSWindowSurface
operator|::
name|QWSWindowSurface
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QWindowSurface
argument_list|(
name|widget
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QWSWindowSurfacePrivate
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QWSWindowSurface
name|QWSWindowSurface
operator|::
name|~
name|QWSWindowSurface
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_BACKINGSTORE_SUBSURFACES
if|if
condition|(
name|d_ptr
operator|->
name|winId
condition|)
name|winIdToSurfaceMap
argument_list|()
operator|->
name|remove
argument_list|(
name|d_ptr
operator|->
name|winId
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the offset to be used when painting.      \sa paintDevice() */
end_comment
begin_function
DECL|function|painterOffset
name|QPoint
name|QWSWindowSurface
operator|::
name|painterOffset
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|QPoint
argument_list|()
return|;
return|return
name|w
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
operator|-
name|w
operator|->
name|frameGeometry
argument_list|()
operator|.
name|topLeft
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|beginPaint
name|void
name|QWSWindowSurface
operator|::
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endPaint
name|void
name|QWSWindowSurface
operator|::
name|endPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// XXX: documentation!!!
end_comment
begin_function
DECL|function|transientState
name|QByteArray
name|QWSWindowSurface
operator|::
name|transientState
parameter_list|()
specifier|const
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSWindowSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setTransientState
name|void
name|QWSWindowSurface
operator|::
name|setTransientState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|state
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPermanentState
name|void
name|QWSWindowSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|state
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock
name|bool
name|QWSWindowSurface
operator|::
name|lock
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QWSWindowSurface
operator|::
name|unlock
parameter_list|()
block|{ }
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
end_ifdef
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|directRegion
specifier|const
name|QRegion
name|QWSWindowSurface
operator|::
name|directRegion
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|direct
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|directRegionId
name|int
name|QWSWindowSurface
operator|::
name|directRegionId
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|directId
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|setDirectRegion
name|void
name|QWSWindowSurface
operator|::
name|setDirectRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|d_ptr
operator|->
name|direct
operator|=
name|r
expr_stmt|;
name|d_ptr
operator|->
name|directId
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the region currently visible on the screen.      \sa setClipRegion() */
end_comment
begin_function
DECL|function|clipRegion
specifier|const
name|QRegion
name|QWSWindowSurface
operator|::
name|clipRegion
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|clip
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the region currently visible on the screen to be the given \a     clip region.      \sa clipRegion() */
end_comment
begin_function
DECL|function|setClipRegion
name|void
name|QWSWindowSurface
operator|::
name|setClipRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|clip
parameter_list|)
block|{
if|if
condition|(
name|clip
operator|==
name|d_ptr
operator|->
name|clip
condition|)
return|return;
name|QRegion
name|expose
init|=
operator|(
name|clip
operator|-
name|d_ptr
operator|->
name|clip
operator|)
decl_stmt|;
name|d_ptr
operator|->
name|clip
operator|=
name|clip
expr_stmt|;
if|if
condition|(
name|expose
operator|.
name|isEmpty
argument_list|()
operator|||
name|clip
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// No repaint or flush required.
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
return|return;
if|if
condition|(
name|isBuffered
argument_list|()
condition|)
block|{
comment|// No repaint required. Flush exposed area via the backing store.
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|syncBackingStore
argument_list|(
name|expose
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_QWS_MANAGER
comment|// Invalidate exposed decoration area.
if|if
condition|(
name|win
operator|&&
name|win
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QTLWExtra
modifier|*
name|topextra
init|=
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|topextra
decl_stmt|;
if|if
condition|(
name|QWSManager
modifier|*
name|manager
init|=
name|topextra
operator|->
name|qwsManager
condition|)
block|{
name|QRegion
name|decorationExpose
argument_list|(
name|manager
operator|->
name|region
argument_list|()
argument_list|)
decl_stmt|;
name|decorationExpose
operator|.
name|translate
argument_list|(
operator|-
name|win
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|decorationExpose
operator|&=
name|expose
expr_stmt|;
if|if
condition|(
operator|!
name|decorationExpose
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|expose
operator|-=
name|decorationExpose
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|dirtyRegion
argument_list|(
name|QDecoration
operator|::
name|All
argument_list|,
name|QDecoration
operator|::
name|Normal
argument_list|,
name|decorationExpose
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|// Invalidate exposed widget area.
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|invalidateBuffer
argument_list|(
name|expose
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the surface flags describing the contents of this surface.      \sa isBuffered(), isOpaque(), isRegionReserved() */
end_comment
begin_function
DECL|function|surfaceFlags
name|QWSWindowSurface
operator|::
name|SurfaceFlags
name|QWSWindowSurface
operator|::
name|surfaceFlags
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|flags
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the surface flags describing the contents of this surface, to     be the given \a flags.      \sa surfaceFlags() */
end_comment
begin_function
DECL|function|setSurfaceFlags
name|void
name|QWSWindowSurface
operator|::
name|setSurfaceFlags
parameter_list|(
name|SurfaceFlags
name|flags
parameter_list|)
block|{
name|d_ptr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setGeometry
name|void
name|QWSWindowSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QRegion
name|mask
init|=
name|rect
decl_stmt|;
specifier|const
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|win
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MANAGER
if|if
condition|(
name|win
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QTLWExtra
modifier|*
name|topextra
init|=
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|topextra
decl_stmt|;
name|QWSManager
modifier|*
name|manager
init|=
name|topextra
operator|->
name|qwsManager
decl_stmt|;
if|if
condition|(
name|manager
condition|)
block|{
comment|// The frame geometry is the bounding rect of manager->region,
comment|// which could be too much, so we need to clip.
name|mask
operator|&=
operator|(
name|manager
operator|->
name|region
argument_list|()
operator|+
name|win
operator|->
name|geometry
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
specifier|const
name|QRegion
name|winMask
init|=
name|win
operator|->
name|mask
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|winMask
operator|.
name|isEmpty
argument_list|()
condition|)
name|mask
operator|&=
name|winMask
operator|.
name|translated
argument_list|(
name|win
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setGeometry
argument_list|(
name|rect
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setGeometry
name|void
name|QWSWindowSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|mask
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|==
name|geometry
argument_list|()
condition|)
comment|// XXX:&& mask == prevMask
return|return;
specifier|const
name|bool
name|isResize
init|=
name|rect
operator|.
name|size
argument_list|()
operator|!=
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|needsRepaint
init|=
name|isResize
operator|||
operator|!
name|isBuffered
argument_list|()
decl_stmt|;
name|QWindowSurface
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
specifier|const
name|QRegion
name|region
init|=
name|mask
operator|&
name|rect
decl_stmt|;
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
comment|// Only request regions for widgets visible on the screen.
comment|// (Added the !win check for compatibility reasons, because
comment|// there was no "if (win)" check before).
specifier|const
name|bool
name|requestQWSRegion
init|=
operator|!
name|win
operator|||
operator|!
name|win
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestQWSRegion
condition|)
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|requestRegion
argument_list|(
name|winId
argument_list|()
argument_list|,
name|key
argument_list|()
argument_list|,
name|permanentState
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsRepaint
condition|)
name|invalidateBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|requestQWSRegion
condition|)
block|{
comment|// We didn't request a region, hence we won't get a QWSRegionEvent::Allocation
comment|// event back from the server so we set the clip directly. We have to
comment|// do this after the invalidateBuffer() call above, as it might trigger a
comment|// backing store sync, resulting in too many update requests.
name|setClipRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|flushUpdate
specifier|static
specifier|inline
name|void
name|flushUpdate
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_PAINT_DEBUG
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
name|int
name|delay
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|delay
operator|==
operator|-
literal|1
condition|)
name|delay
operator|=
name|qgetenv
argument_list|(
literal|"QT_FLUSH_UPDATE"
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|delay
operator|==
literal|0
condition|)
return|return;
specifier|static
name|QWSYellowSurface
name|surface
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|surface
operator|.
name|setDelay
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|surface
operator|.
name|flush
argument_list|(
name|widget
argument_list|,
name|region
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_PAINT_DEBUG
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QWSWindowSurface
operator|::
name|flush
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
specifier|const
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QWExtra
modifier|*
name|extra
init|=
name|win
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
return|return;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
name|Q_UNUSED
argument_list|(
name|offset
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|opaque
init|=
name|isOpaque
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_DISABLE_FLUSHCLIPPING
name|QRegion
name|toFlush
init|=
name|region
decl_stmt|;
else|#
directive|else
name|QRegion
name|toFlush
init|=
name|region
operator|&
name|d_ptr
operator|->
name|clip
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|toFlush
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|flushUpdate
argument_list|(
name|widget
argument_list|,
name|toFlush
argument_list|,
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|QPoint
name|globalZero
init|=
name|win
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|toFlush
operator|.
name|translate
argument_list|(
name|globalZero
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|bool
name|needRepaint
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|opaque
condition|)
block|{
name|QScreen
modifier|*
name|widgetScreen
init|=
name|getScreen
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|widgetScreen
operator|->
name|supportsBlitInClients
argument_list|()
condition|)
block|{
name|QWSDisplay
operator|::
name|grab
argument_list|()
expr_stmt|;
if|if
condition|(
name|directRegion
argument_list|()
operator|.
name|intersected
argument_list|(
name|toFlush
argument_list|)
operator|==
name|toFlush
condition|)
block|{
name|QPoint
name|translate
init|=
operator|-
name|globalZero
operator|+
name|painterOffset
argument_list|()
operator|+
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QRegion
name|flushRegion
init|=
name|toFlush
operator|.
name|translated
argument_list|(
name|translate
argument_list|)
decl_stmt|;
name|widgetScreen
operator|->
name|blit
argument_list|(
name|image
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|,
name|flushRegion
argument_list|)
expr_stmt|;
name|widgetScreen
operator|->
name|setDirty
argument_list|(
name|toFlush
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|needRepaint
operator|=
literal|false
expr_stmt|;
block|}
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needRepaint
condition|)
endif|#
directive|endif
name|win
operator|->
name|qwsDisplay
argument_list|()
operator|->
name|repaintRegion
argument_list|(
name|winId
argument_list|()
argument_list|,
name|win
operator|->
name|windowFlags
argument_list|()
argument_list|,
name|opaque
argument_list|,
name|toFlush
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Move the surface with the given \a offset.      A subclass may reimplement this function to enable accelerated window move.     It must return true if the move was successful and no repaint is necessary,     false otherwise.      The default implementation updates the QWindowSurface geometry and     returns true if the surface is buffered; false otherwise.      This function is called by the window system on the client instance.      \sa isBuffered() */
end_comment
begin_function
DECL|function|move
name|bool
name|QWSWindowSurface
operator|::
name|move
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
name|QWindowSurface
operator|::
name|setGeometry
argument_list|(
name|geometry
argument_list|()
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|isBuffered
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Move the surface with the given \a offset.      The new visible region after the window move is given by \a newClip     in screen coordinates.      A subclass may reimplement this function to enable accelerated window move.     The returned region indicates the area that still needs to be composed     on the screen.      The default implementation updates the QWindowSurface geometry and     returns the union of the old and new geometry.      This function is called by the window system on the server instance. */
end_comment
begin_function
DECL|function|move
name|QRegion
name|QWSWindowSurface
operator|::
name|move
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|newClip
parameter_list|)
block|{
specifier|const
name|QRegion
name|oldGeometry
init|=
name|geometry
argument_list|()
decl_stmt|;
name|QWindowSurface
operator|::
name|setGeometry
argument_list|(
name|geometry
argument_list|()
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|oldGeometry
operator|+
name|newClip
return|;
block|}
end_function
begin_function
DECL|function|releaseSurface
name|void
name|QWSWindowSurface
operator|::
name|releaseSurface
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|lock
name|bool
name|QWSMemorySurface
operator|::
name|lock
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|memlock
operator|&&
operator|!
name|memlock
operator|->
name|lock
argument_list|(
name|QWSLock
operator|::
name|BackingStore
argument_list|)
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|threadLock
operator|.
name|lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QWSMemorySurface
operator|::
name|unlock
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|threadLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|memlock
condition|)
name|memlock
operator|->
name|unlock
argument_list|(
name|QWSLock
operator|::
name|BackingStore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_constructor
DECL|function|QWSMemorySurface
name|QWSMemorySurface
operator|::
name|QWSMemorySurface
parameter_list|()
member_init_list|:
name|QWSWindowSurface
argument_list|()
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
member_init_list|,
name|memlock
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|setSurfaceFlags
argument_list|(
name|Buffered
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QWSMemorySurface
name|QWSMemorySurface
operator|::
name|QWSMemorySurface
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QWSWindowSurface
argument_list|(
name|w
argument_list|)
block|{
name|SurfaceFlags
name|flags
init|=
name|Buffered
decl_stmt|;
if|if
condition|(
name|isWidgetOpaque
argument_list|(
name|w
argument_list|)
condition|)
name|flags
operator||=
name|Opaque
expr_stmt|;
name|setSurfaceFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
name|memlock
operator|=
name|QWSDisplay
operator|::
name|Data
operator|::
name|getClientLock
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QWSMemorySurface
name|QWSMemorySurface
operator|::
name|~
name|QWSMemorySurface
parameter_list|()
block|{ }
end_destructor
begin_function
name|QImage
operator|::
name|Format
DECL|function|preferredImageFormat
name|QWSMemorySurface
operator|::
name|preferredImageFormat
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|QScreen
modifier|*
name|screen
init|=
name|getScreen
argument_list|(
name|widget
argument_list|)
decl_stmt|;
specifier|const
name|int
name|depth
init|=
name|screen
operator|->
name|depth
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|opaque
init|=
name|isWidgetOpaque
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|opaque
condition|)
block|{
if|if
condition|(
name|depth
operator|<=
literal|12
condition|)
return|return
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|15
condition|)
return|return
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|16
condition|)
return|return
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|18
condition|)
return|return
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
return|;
else|else
return|return
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
return|;
block|}
name|QImage
operator|::
name|Format
name|format
init|=
name|screen
operator|->
name|pixelFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|>
name|QImage
operator|::
name|Format_Indexed8
condition|)
comment|// ### assumes all new image formats supports a QPainter
return|return
name|format
return|;
if|if
condition|(
name|depth
operator|<=
literal|12
condition|)
return|return
name|QImage
operator|::
name|Format_RGB444
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|15
condition|)
return|return
name|QImage
operator|::
name|Format_RGB555
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|16
condition|)
return|return
name|QImage
operator|::
name|Format_RGB16
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|18
condition|)
return|return
name|QImage
operator|::
name|Format_RGB666
return|;
elseif|else
if|if
condition|(
name|depth
operator|<=
literal|24
condition|)
return|return
name|QImage
operator|::
name|Format_RGB888
return|;
else|else
return|return
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_function
DECL|function|setLock
name|void
name|QWSMemorySurface
operator|::
name|setLock
parameter_list|(
name|int
name|lockId
parameter_list|)
block|{
if|if
condition|(
name|memlock
operator|&&
name|memlock
operator|->
name|id
argument_list|()
operator|==
name|lockId
condition|)
return|return;
operator|delete
name|memlock
expr_stmt|;
name|memlock
operator|=
operator|(
name|lockId
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|new
name|QWSLock
argument_list|(
name|lockId
argument_list|)
operator|)
expr_stmt|;
return|return;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_MULTIPROCESS
end_comment
begin_function
DECL|function|isValid
name|bool
name|QWSMemorySurface
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|true
return|;
specifier|const
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|preferredImageFormat
argument_list|(
name|win
argument_list|)
operator|!=
name|img
operator|.
name|format
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isOpaque
argument_list|()
operator|!=
name|isWidgetOpaque
argument_list|(
name|win
argument_list|)
condition|)
comment|// XXX: use QWidgetPrivate::isOpaque()
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// ### copied from qwindowsurface_raster.cpp -- should be cross-platform
end_comment
begin_function
DECL|function|beginPaint
name|void
name|QWSMemorySurface
operator|::
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWidgetOpaque
argument_list|(
name|window
argument_list|()
argument_list|)
condition|)
block|{
name|QPainter
name|p
argument_list|(
operator|&
name|img
argument_list|)
decl_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|rgn
operator|.
name|rects
argument_list|()
decl_stmt|;
specifier|const
name|QColor
name|blank
init|=
name|Qt
operator|::
name|transparent
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|QRect
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|rects
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|rects
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QRect
name|r
init|=
operator|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_BACKINGSTORE_SUBSURFACES
name|r
operator|.
name|translate
argument_list|(
name|painterOffset
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|.
name|fillRect
argument_list|(
name|r
argument_list|,
name|blank
argument_list|)
expr_stmt|;
block|}
block|}
name|QWSWindowSurface
operator|::
name|beginPaint
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// from qwindowsurface.cpp
end_comment
begin_function_decl
specifier|extern
name|void
name|qt_scrollRectInImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|scroll
name|bool
name|QWSMemorySurface
operator|::
name|scroll
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|area
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|area
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|qt_scrollRectInImage
argument_list|(
name|img
argument_list|,
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|painterOffset
name|QPoint
name|QWSMemorySurface
operator|::
name|painterOffset
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|QPoint
argument_list|()
return|;
if|if
condition|(
name|w
operator|->
name|mask
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QWSWindowSurface
operator|::
name|painterOffset
argument_list|()
return|;
specifier|const
name|QRegion
name|region
init|=
name|w
operator|->
name|mask
argument_list|()
operator|&
name|w
operator|->
name|frameGeometry
argument_list|()
operator|.
name|translated
argument_list|(
operator|-
name|w
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|-
name|region
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QWSLocalMemSurface
name|QWSLocalMemSurface
operator|::
name|QWSLocalMemSurface
parameter_list|()
member_init_list|:
name|QWSMemorySurface
argument_list|()
member_init_list|,
name|mem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|memsize
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QWSLocalMemSurface
name|QWSLocalMemSurface
operator|::
name|QWSLocalMemSurface
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QWSMemorySurface
argument_list|(
name|w
argument_list|)
member_init_list|,
name|mem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|memsize
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QWSLocalMemSurface
name|QWSLocalMemSurface
operator|::
name|~
name|QWSLocalMemSurface
parameter_list|()
block|{
if|if
condition|(
name|memsize
condition|)
operator|delete
index|[]
name|mem
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setGeometry
name|void
name|QWSLocalMemSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QSize
name|size
init|=
name|rect
operator|.
name|size
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|win
operator|&&
operator|!
name|win
operator|->
name|mask
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QRegion
name|region
init|=
name|win
operator|->
name|mask
argument_list|()
operator|&
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|win
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|size
operator|=
name|region
operator|.
name|boundingRect
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|uchar
modifier|*
name|deleteLater
init|=
literal|0
decl_stmt|;
comment|// In case of a Hide event we need to delete the memory after sending the
comment|// event to the server in order to let the server animate the event.
if|if
condition|(
name|size
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|deleteLater
operator|=
name|mem
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|img
operator|.
name|size
argument_list|()
operator|!=
name|size
condition|)
block|{
operator|delete
index|[]
name|mem
expr_stmt|;
if|if
condition|(
name|size
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mem
operator|=
literal|0
expr_stmt|;
name|img
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QImage
operator|::
name|Format
name|format
init|=
name|preferredImageFormat
argument_list|(
name|win
argument_list|)
decl_stmt|;
specifier|const
name|int
name|bpl
init|=
name|nextMulOf4
argument_list|(
name|bytesPerPixel
argument_list|(
name|format
argument_list|)
operator|*
name|size
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|memsize
init|=
name|bpl
operator|*
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|mem
operator|=
operator|new
name|uchar
index|[
name|memsize
index|]
expr_stmt|;
name|img
operator|=
name|QImage
argument_list|(
name|mem
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|bpl
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|setImageMetrics
argument_list|(
name|img
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
block|}
name|QWSWindowSurface
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|deleteLater
expr_stmt|;
block|}
end_function
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSLocalMemSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|array
decl_stmt|;
name|array
operator|.
name|resize
argument_list|(
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SurfaceFlags
argument_list|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|ptr
init|=
name|array
operator|.
name|data
argument_list|()
decl_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
operator|=
name|mem
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
expr_stmt|;
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
index|[
literal|0
index|]
operator|=
name|img
operator|.
name|width
argument_list|()
expr_stmt|;
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
index|[
literal|1
index|]
operator|=
name|img
operator|.
name|height
argument_list|()
expr_stmt|;
name|ptr
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
operator|=
name|img
operator|.
name|format
argument_list|()
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|SurfaceFlags
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
operator|=
name|surfaceFlags
argument_list|()
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_function
DECL|function|setPermanentState
name|void
name|QWSLocalMemSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
name|SurfaceFlags
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|data
operator|.
name|constData
argument_list|()
decl_stmt|;
name|mem
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
specifier|const
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
expr_stmt|;
name|width
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|height
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
index|[
literal|1
index|]
expr_stmt|;
name|ptr
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|SurfaceFlags
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
specifier|const
name|int
name|bpl
init|=
name|nextMulOf4
argument_list|(
name|bytesPerPixel
argument_list|(
name|format
argument_list|)
operator|*
name|width
argument_list|)
decl_stmt|;
name|QWSMemorySurface
operator|::
name|img
operator|=
name|QImage
argument_list|(
name|mem
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpl
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|setSurfaceFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|releaseSurface
name|void
name|QWSLocalMemSurface
operator|::
name|releaseSurface
parameter_list|()
block|{
name|mem
operator|=
literal|0
expr_stmt|;
name|img
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
end_ifndef
begin_constructor
DECL|function|QWSSharedMemSurface
name|QWSSharedMemSurface
operator|::
name|QWSSharedMemSurface
parameter_list|()
member_init_list|:
name|QWSMemorySurface
argument_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|QWSSharedMemSurface
name|QWSSharedMemSurface
operator|::
name|QWSSharedMemSurface
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QWSMemorySurface
argument_list|(
name|widget
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QWSSharedMemSurface
name|QWSSharedMemSurface
operator|::
name|~
name|QWSSharedMemSurface
parameter_list|()
block|{
comment|// mem.detach() is done automatically by ~QSharedMemory
block|}
end_destructor
begin_function
DECL|function|setMemory
name|bool
name|QWSSharedMemSurface
operator|::
name|setMemory
parameter_list|(
name|int
name|memId
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|.
name|id
argument_list|()
operator|==
name|memId
condition|)
return|return
literal|true
return|;
name|mem
operator|.
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mem
operator|.
name|attach
argument_list|(
name|memId
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QWSSharedMemSurface: attaching to shared memory"
argument_list|)
expr_stmt|;
name|qCritical
argument_list|(
literal|"QWSSharedMemSurface: Error attaching to"
literal|" shared memory 0x%x"
argument_list|,
name|memId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
end_ifdef
begin_function
DECL|function|setDirectRegion
name|void
name|QWSSharedMemSurface
operator|::
name|setDirectRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|QWSMemorySurface
operator|::
name|setDirectRegion
argument_list|(
name|r
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|.
name|address
argument_list|()
condition|)
operator|*
operator|(
name|uint
operator|*
operator|)
name|mem
operator|.
name|address
argument_list|()
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_function
DECL|function|directRegion
specifier|const
name|QRegion
name|QWSSharedMemSurface
operator|::
name|directRegion
parameter_list|()
specifier|const
block|{
name|QWSSharedMemory
modifier|*
name|cmem
init|=
cast|const_cast
argument_list|<
name|QWSSharedMemory
operator|*
argument_list|>
argument_list|(
operator|&
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmem
operator|->
name|address
argument_list|()
operator|&&
operator|(
operator|(
name|int
operator|*
operator|)
name|cmem
operator|->
name|address
argument_list|()
operator|)
index|[
literal|0
index|]
operator|==
name|directRegionId
argument_list|()
condition|)
return|return
name|QWSMemorySurface
operator|::
name|directRegion
argument_list|()
return|;
else|else
return|return
name|QRegion
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setPermanentState
name|void
name|QWSSharedMemSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|int
name|memId
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|lockId
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
name|SurfaceFlags
name|flags
decl_stmt|;
specifier|const
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|memId
operator|=
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|width
operator|=
name|ptr
index|[
literal|1
index|]
expr_stmt|;
name|height
operator|=
name|ptr
index|[
literal|2
index|]
expr_stmt|;
name|lockId
operator|=
name|ptr
index|[
literal|3
index|]
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format
argument_list|(
name|ptr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SurfaceFlags
argument_list|(
name|ptr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|setSurfaceFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|setMemory
argument_list|(
name|memId
argument_list|)
expr_stmt|;
name|setLock
argument_list|(
name|lockId
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
name|uchar
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|mem
operator|.
name|address
argument_list|()
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
else|#
directive|else
name|uchar
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|mem
operator|.
name|address
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|const
name|int
name|bpl
init|=
name|nextMulOf4
argument_list|(
name|bytesPerPixel
argument_list|(
name|format
argument_list|)
operator|*
name|width
argument_list|)
decl_stmt|;
name|QWSMemorySurface
operator|::
name|img
operator|=
name|QImage
argument_list|(
name|base
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpl
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setGeometry
name|void
name|QWSSharedMemSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|QSize
name|size
init|=
name|rect
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|size
argument_list|()
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|size
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mem
operator|.
name|detach
argument_list|()
expr_stmt|;
name|img
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mem
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
specifier|const
name|QImage
operator|::
name|Format
name|format
init|=
name|preferredImageFormat
argument_list|(
name|win
argument_list|)
decl_stmt|;
specifier|const
name|int
name|bpl
init|=
name|nextMulOf4
argument_list|(
name|bytesPerPixel
argument_list|(
name|format
argument_list|)
operator|*
name|size
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
specifier|const
name|int
name|imagesize
init|=
name|bpl
operator|*
name|size
operator|.
name|height
argument_list|()
operator|+
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|imagesize
init|=
name|bpl
operator|*
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mem
operator|.
name|create
argument_list|(
name|imagesize
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"QWSSharedMemSurface::setGeometry allocating shared memory"
argument_list|)
expr_stmt|;
name|qFatal
argument_list|(
literal|"Error creating shared memory of size %d"
argument_list|,
name|imagesize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_QWS_CLIENTBLIT
operator|*
operator|(
operator|(
name|uint
operator|*
operator|)
name|mem
operator|.
name|address
argument_list|()
operator|)
operator|=
literal|0
expr_stmt|;
name|uchar
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|mem
operator|.
name|address
argument_list|()
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
else|#
directive|else
name|uchar
modifier|*
name|base
init|=
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|mem
operator|.
name|address
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|img
operator|=
name|QImage
argument_list|(
name|base
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|bpl
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|setImageMetrics
argument_list|(
name|img
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
block|}
name|QWSWindowSurface
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSSharedMemSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|array
decl_stmt|;
name|array
operator|.
name|resize
argument_list|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|array
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|mem
operator|.
name|id
argument_list|()
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|img
operator|.
name|width
argument_list|()
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|img
operator|.
name|height
argument_list|()
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
operator|(
name|memlock
condition|?
name|memlock
operator|->
name|id
argument_list|()
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|ptr
index|[
literal|4
index|]
operator|=
name|int
argument_list|(
name|img
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|5
index|]
operator|=
name|int
argument_list|(
name|surfaceFlags
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_function
DECL|function|releaseSurface
name|void
name|QWSSharedMemSurface
operator|::
name|releaseSurface
parameter_list|()
block|{
name|mem
operator|.
name|detach
argument_list|()
expr_stmt|;
name|img
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QWS_MULTIPROCESS
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PAINTONSCREEN
end_ifndef
begin_constructor
DECL|function|QWSOnScreenSurface
name|QWSOnScreenSurface
operator|::
name|QWSOnScreenSurface
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QWSMemorySurface
argument_list|(
name|w
argument_list|)
block|{
name|attachToScreen
argument_list|(
name|getScreen
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|setSurfaceFlags
argument_list|(
name|Opaque
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QWSOnScreenSurface
name|QWSOnScreenSurface
operator|::
name|QWSOnScreenSurface
parameter_list|()
member_init_list|:
name|QWSMemorySurface
argument_list|()
block|{
name|setSurfaceFlags
argument_list|(
name|Opaque
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|attachToScreen
name|void
name|QWSOnScreenSurface
operator|::
name|attachToScreen
parameter_list|(
specifier|const
name|QScreen
modifier|*
name|s
parameter_list|)
block|{
name|screen
operator|=
name|s
expr_stmt|;
name|uchar
modifier|*
name|base
init|=
name|screen
operator|->
name|base
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|screen
operator|->
name|pixelFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Invalid
operator|||
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
comment|//### currently we have no paint engine for indexed image formats
name|qFatal
argument_list|(
literal|"QWSOnScreenSurface::attachToScreen(): screen depth %d "
literal|"not implemented"
argument_list|,
name|screen
operator|->
name|depth
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|QWSMemorySurface
operator|::
name|img
operator|=
name|QImage
argument_list|(
name|base
argument_list|,
name|screen
operator|->
name|width
argument_list|()
argument_list|,
name|screen
operator|->
name|height
argument_list|()
argument_list|,
name|screen
operator|->
name|linestep
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QWSOnScreenSurface
name|QWSOnScreenSurface
operator|::
name|~
name|QWSOnScreenSurface
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|painterOffset
name|QPoint
name|QWSOnScreenSurface
operator|::
name|painterOffset
parameter_list|()
specifier|const
block|{
return|return
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
operator|+
name|QWSWindowSurface
operator|::
name|painterOffset
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QWSOnScreenSurface
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|win
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|screen
operator|!=
name|getScreen
argument_list|(
name|win
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|QScreen
operator|::
name|isWidgetPaintOnScreen
argument_list|(
name|win
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSOnScreenSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|array
decl_stmt|;
name|array
operator|.
name|resize
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|array
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenNumber
argument_list|(
name|window
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_function
DECL|function|setPermanentState
name|void
name|QWSOnScreenSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|screenNo
init|=
name|ptr
index|[
literal|0
index|]
decl_stmt|;
name|QScreen
modifier|*
name|screen
init|=
name|qt_screen
decl_stmt|;
if|if
condition|(
name|screenNo
operator|>
literal|0
condition|)
name|screen
operator|=
name|qt_screen
operator|->
name|subScreens
argument_list|()
operator|.
name|at
argument_list|(
name|screenNo
argument_list|)
expr_stmt|;
name|attachToScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PAINTONSCREEN
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PAINT_DEBUG
end_ifndef
begin_constructor
DECL|function|QWSYellowSurface
name|QWSYellowSurface
operator|::
name|QWSYellowSurface
parameter_list|(
name|bool
name|isClient
parameter_list|)
member_init_list|:
name|QWSWindowSurface
argument_list|()
member_init_list|,
name|delay
argument_list|(
literal|10
argument_list|)
block|{
if|if
condition|(
name|isClient
condition|)
block|{
name|setWinId
argument_list|(
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|takeId
argument_list|()
argument_list|)
expr_stmt|;
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|nameRegion
argument_list|(
name|winId
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"Debug flush paint"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Silly yellow thing"
argument_list|)
argument_list|)
expr_stmt|;
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|setAltitude
argument_list|(
name|winId
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|setSurfaceFlags
argument_list|(
name|Buffered
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWSYellowSurface
name|QWSYellowSurface
operator|::
name|~
name|QWSYellowSurface
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSYellowSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|array
decl_stmt|;
name|array
operator|.
name|resize
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|array
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|surfaceSize
operator|.
name|width
argument_list|()
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|surfaceSize
operator|.
name|height
argument_list|()
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_function
DECL|function|setPermanentState
name|void
name|QWSYellowSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|ptr
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|ptr
index|[
literal|1
index|]
decl_stmt|;
name|img
operator|=
name|QImage
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|img
operator|.
name|fill
argument_list|(
name|qRgba
argument_list|(
literal|255
argument_list|,
literal|255
argument_list|,
literal|31
argument_list|,
literal|127
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QWSYellowSurface
operator|::
name|flush
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|QWSDisplay
modifier|*
name|display
init|=
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
decl_stmt|;
name|QRegion
name|rgn
init|=
name|region
decl_stmt|;
if|if
condition|(
name|widget
condition|)
name|rgn
operator|.
name|translate
argument_list|(
name|widget
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|surfaceSize
operator|=
name|region
operator|.
name|boundingRect
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
specifier|const
name|int
name|id
init|=
name|winId
argument_list|()
decl_stmt|;
name|display
operator|->
name|requestRegion
argument_list|(
name|id
argument_list|,
name|key
argument_list|()
argument_list|,
name|permanentState
argument_list|()
argument_list|,
name|rgn
argument_list|)
expr_stmt|;
name|display
operator|->
name|setAltitude
argument_list|(
name|id
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|display
operator|->
name|repaintRegion
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|rgn
argument_list|)
expr_stmt|;
operator|::
name|usleep
argument_list|(
literal|500
operator|*
name|delay
argument_list|)
expr_stmt|;
name|display
operator|->
name|requestRegion
argument_list|(
name|id
argument_list|,
name|key
argument_list|()
argument_list|,
name|permanentState
argument_list|()
argument_list|,
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
operator|::
name|usleep
argument_list|(
literal|500
operator|*
name|delay
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PAINT_DEBUG
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DIRECTPAINTER
end_ifndef
begin_function
DECL|function|getPrimaryScreen
specifier|static
specifier|inline
name|QScreen
modifier|*
name|getPrimaryScreen
parameter_list|()
block|{
name|QScreen
modifier|*
name|screen
init|=
name|QScreen
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|screen
operator|->
name|base
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|subScreens
init|=
name|screen
operator|->
name|subScreens
argument_list|()
decl_stmt|;
if|if
condition|(
name|subScreens
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|screen
operator|=
name|subScreens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|screen
return|;
block|}
end_function
begin_constructor
DECL|function|QWSDirectPainterSurface
name|QWSDirectPainterSurface
operator|::
name|QWSDirectPainterSurface
parameter_list|(
name|bool
name|isClient
parameter_list|,
name|QDirectPainter
operator|::
name|SurfaceFlag
name|flags
parameter_list|)
member_init_list|:
name|QWSWindowSurface
argument_list|()
member_init_list|,
name|flushingRegionEvents
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|doLocking
argument_list|(
literal|false
argument_list|)
block|{
name|setSurfaceFlags
argument_list|(
name|Opaque
argument_list|)
expr_stmt|;
name|synchronous
operator|=
operator|(
name|flags
operator|==
name|QDirectPainter
operator|::
name|ReservedSynchronous
operator|)
expr_stmt|;
if|if
condition|(
name|isClient
condition|)
block|{
name|setWinId
argument_list|(
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|takeId
argument_list|()
argument_list|)
expr_stmt|;
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|nameRegion
argument_list|(
name|winId
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"QDirectPainter reserved space"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"reserved"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setWinId
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|_screen
operator|=
name|QScreen
operator|::
name|instance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|_screen
operator|->
name|base
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QScreen
modifier|*
argument_list|>
name|subScreens
init|=
name|_screen
operator|->
name|subScreens
argument_list|()
decl_stmt|;
if|if
condition|(
name|subScreens
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
name|_screen
operator|=
literal|0
expr_stmt|;
else|else
name|_screen
operator|=
name|subScreens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QWSDirectPainterSurface
name|QWSDirectPainterSurface
operator|::
name|~
name|QWSDirectPainterSurface
parameter_list|()
block|{
if|if
condition|(
name|winId
argument_list|()
operator|&&
name|QWSDisplay
operator|::
name|instance
argument_list|()
condition|)
comment|// make sure not in QApplication destructor
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|destroyRegion
argument_list|(
name|winId
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setRegion
name|void
name|QWSDirectPainterSurface
operator|::
name|setRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
specifier|const
name|int
name|id
init|=
name|winId
argument_list|()
decl_stmt|;
name|QWidget
operator|::
name|qwsDisplay
argument_list|()
operator|->
name|requestRegion
argument_list|(
name|id
argument_list|,
name|key
argument_list|()
argument_list|,
name|permanentState
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|synchronous
condition|)
name|QWSDisplay
operator|::
name|instance
argument_list|()
operator|->
name|d
operator|->
name|waitForRegionAck
argument_list|(
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QWSDirectPainterSurface
operator|::
name|flush
parameter_list|(
name|QWidget
modifier|*
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
specifier|const
name|QPoint
modifier|&
parameter_list|)
block|{
name|QWSDisplay
operator|::
name|instance
argument_list|()
operator|->
name|repaintRegion
argument_list|(
name|winId
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|permanentState
name|QByteArray
name|QWSDirectPainterSurface
operator|::
name|permanentState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|res
decl_stmt|;
if|if
condition|(
name|isRegionReserved
argument_list|()
condition|)
name|res
operator|.
name|append
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|setPermanentState
name|void
name|QWSDirectPainterSurface
operator|::
name|setPermanentState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|ba
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'r'
condition|)
name|setReserved
argument_list|()
expr_stmt|;
name|setSurfaceFlags
argument_list|(
name|surfaceFlags
argument_list|()
operator||
name|Opaque
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beginPaint
name|void
name|QWSDirectPainterSurface
operator|::
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QWSWindowSurface
operator|::
name|beginPaint
argument_list|(
name|region
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
operator|!
name|synchronous
condition|)
block|{
name|flushingRegionEvents
operator|=
literal|true
expr_stmt|;
name|QWSDisplay
operator|::
name|instance
argument_list|()
operator|->
name|d
operator|->
name|waitForRegionEvents
argument_list|(
name|winId
argument_list|()
argument_list|,
name|doLocking
argument_list|)
expr_stmt|;
name|flushingRegionEvents
operator|=
literal|false
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|hasPendingRegionEvents
name|bool
name|QWSDirectPainterSurface
operator|::
name|hasPendingRegionEvents
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_QWS_MULTIPROCESS
if|if
condition|(
name|synchronous
condition|)
return|return
literal|false
return|;
return|return
name|QWSDisplay
operator|::
name|instance
argument_list|()
operator|->
name|d
operator|->
name|hasPendingRegionEvents
argument_list|()
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|lock
name|bool
name|QWSDirectPainterSurface
operator|::
name|lock
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|threadLock
operator|.
name|lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Q_UNUSED
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|doLocking
condition|)
name|QWSDisplay
operator|::
name|grab
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QWSDirectPainterSurface
operator|::
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|doLocking
condition|)
name|QWSDisplay
operator|::
name|ungrab
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|threadLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DIRECTPAINTER
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
