begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qregion.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|<private/qdebug_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QRegion     \brief The QRegion class specifies a clip region for a painter.      \inmodule QtGui     \ingroup painting     \ingroup shared      QRegion is used with QPainter::setClipRegion() to limit the paint     area to what needs to be painted. There is also a QWidget::repaint()     function that takes a QRegion parameter. QRegion is the best tool for     minimizing the amount of screen area to be updated by a repaint.      This class is not suitable for constructing shapes for rendering, especially     as outlines. Use QPainterPath to create paths and shapes for use with     QPainter.      QRegion is an \l{implicitly shared} class.      \section1 Creating and Using Regions      A region can be created from a rectangle, an ellipse, a polygon or     a bitmap. Complex regions may be created by combining simple     regions using united(), intersected(), subtracted(), or xored() (exclusive     or). You can move a region using translate().      You can test whether a region isEmpty() or if it     contains() a QPoint or QRect. The bounding rectangle can be found     with boundingRect().      The function rects() gives a decomposition of the region into     rectangles.      Example of using complex regions:     \snippet code/src_gui_painting_qregion.cpp 0      \section1 Additional License Information      On Embedded Linux, Windows CE and X11 platforms, parts of this class rely on     code obtained under the following licenses:      \legalese     Copyright (c) 1987  X Consortium      Permission is hereby granted, free of charge, to any person obtaining a copy     of this software and associated documentation files (the "Software"), to deal     in the Software without restriction, including without limitation the rights     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     copies of the Software, and to permit persons to whom the Software is     furnished to do so, subject to the following conditions:      The above copyright notice and this permission notice shall be included in     all copies or substantial portions of the Software.      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE     X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN     AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.      Except as contained in this notice, the name of the X Consortium shall not be     used in advertising or otherwise to promote the sale, use or other dealings     in this Software without prior written authorization from the X Consortium.     \endlegalese      \br      \legalese     Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                              All Rights Reserved      Permission to use, copy, modify, and distribute this software and its     documentation for any purpose and without fee is hereby granted,     provided that the above copyright notice appear in all copies and that     both that copyright notice and this permission notice appear in     supporting documentation, and that the name of Digital not be     used in advertising or publicity pertaining to distribution of the     software without specific, written prior permission.      DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING     ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL     DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR     ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,     WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,     ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS     SOFTWARE.     \endlegalese      \sa QPainter::setClipRegion(), QPainter::setClipRect(), QPainterPath */
comment|/*!     \enum QRegion::RegionType      Specifies the shape of the region to be created.      \value Rectangle  the region covers the entire rectangle.     \value Ellipse  the region is an ellipse inside the rectangle. */
comment|/*!     \fn void QRegion::translate(const QPoint&point)      \overload      Translates the region \a{point}\e{.x()} along the x axis and     \a{point}\e{.y()} along the y axis, relative to the current     position. Positive values move the region to the right and down.      Translates to the given \a point. */
comment|/*****************************************************************************   QRegion member functions  *****************************************************************************/
comment|/*!     \fn QRegion::QRegion()      Constructs an empty region.      \sa isEmpty() */
comment|/*!     \fn QRegion::QRegion(const QRect&r, RegionType t)     \overload      Create a region based on the rectange \a r with region type \a t.      If the rectangle is invalid a null region will be created.      \sa QRegion::RegionType */
comment|/*!     \fn QRegion::QRegion(const QPolygon&a, Qt::FillRule fillRule)      Constructs a polygon region from the point array \a a with the fill rule     specified by \a fillRule.      If \a fillRule is \l{Qt::WindingFill}, the polygon region is defined     using the winding algorithm; if it is \l{Qt::OddEvenFill}, the odd-even fill     algorithm is used.      \warning This constructor can be used to create complex regions that will     slow down painting when used. */
comment|/*!     \fn QRegion::QRegion(const QRegion&r)      Constructs a new region which is equal to region \a r. */
comment|/*!     \fn QRegion::QRegion(const QBitmap&bm)      Constructs a region from the bitmap \a bm.      The resulting region consists of the pixels in bitmap \a bm that     are Qt::color1, as if each pixel was a 1 by 1 rectangle.      This constructor may create complex regions that will slow down     painting when used. Note that drawing masked pixmaps can be done     much faster using QPixmap::setMask(). */
comment|/*!     Constructs a rectangular or elliptic region.      If \a t is \c Rectangle, the region is the filled rectangle (\a x,     \a y, \a w, \a h). If \a t is \c Ellipse, the region is the filled     ellipse with center at (\a x + \a w / 2, \a y + \a h / 2) and size     (\a w ,\a h). */
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|RegionType
name|t
parameter_list|)
block|{
name|QRegion
name|tmp
argument_list|(
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|=
name|tmp
operator|.
name|d
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QRegion::~QRegion()     \internal      Destroys the region. */
end_comment
begin_function
DECL|function|detach
name|void
name|QRegion
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
condition|)
operator|*
name|this
operator|=
name|copy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// duplicates in qregion_win.cpp and qregion_wce.cpp
end_comment
begin_define
DECL|macro|QRGN_SETRECT
define|#
directive|define
name|QRGN_SETRECT
value|1
end_define
begin_comment
DECL|macro|QRGN_SETRECT
comment|// region stream commands
end_comment
begin_define
DECL|macro|QRGN_SETELLIPSE
define|#
directive|define
name|QRGN_SETELLIPSE
value|2
end_define
begin_comment
DECL|macro|QRGN_SETELLIPSE
comment|//  (these are internal)
end_comment
begin_define
DECL|macro|QRGN_SETPTARRAY_ALT
define|#
directive|define
name|QRGN_SETPTARRAY_ALT
value|3
end_define
begin_define
DECL|macro|QRGN_SETPTARRAY_WIND
define|#
directive|define
name|QRGN_SETPTARRAY_WIND
value|4
end_define
begin_define
DECL|macro|QRGN_TRANSLATE
define|#
directive|define
name|QRGN_TRANSLATE
value|5
end_define
begin_define
DECL|macro|QRGN_OR
define|#
directive|define
name|QRGN_OR
value|6
end_define
begin_define
DECL|macro|QRGN_AND
define|#
directive|define
name|QRGN_AND
value|7
end_define
begin_define
DECL|macro|QRGN_SUB
define|#
directive|define
name|QRGN_SUB
value|8
end_define
begin_define
DECL|macro|QRGN_XOR
define|#
directive|define
name|QRGN_XOR
value|9
end_define
begin_define
DECL|macro|QRGN_RECTS
define|#
directive|define
name|QRGN_RECTS
value|10
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*     Executes region commands in the internal buffer and rebuilds the     original region.      We do this when we read a region from the data stream.      If \a ver is non-0, uses the format version \a ver on reading the     byte array. */
end_comment
begin_function
DECL|function|exec
name|void
name|QRegion
operator|::
name|exec
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|buffer
parameter_list|,
name|int
name|ver
parameter_list|,
name|QDataStream
operator|::
name|ByteOrder
name|byteOrder
parameter_list|)
block|{
name|QByteArray
name|copy
init|=
name|buffer
decl_stmt|;
name|QDataStream
name|s
argument_list|(
operator|&
name|copy
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
if|if
condition|(
name|ver
condition|)
name|s
operator|.
name|setVersion
argument_list|(
name|ver
argument_list|)
expr_stmt|;
name|s
operator|.
name|setByteOrder
argument_list|(
name|byteOrder
argument_list|)
expr_stmt|;
name|QRegion
name|rgn
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|int
name|test_cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|s
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|qint32
name|id
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|id_int
decl_stmt|;
name|s
operator|>>
name|id_int
expr_stmt|;
name|id
operator|=
name|id_int
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|id
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|test_cnt
operator|>
literal|0
operator|&&
name|id
operator|!=
name|QRGN_TRANSLATE
condition|)
name|qWarning
argument_list|(
literal|"QRegion::exec: Internal error"
argument_list|)
expr_stmt|;
name|test_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|id
operator|==
name|QRGN_SETRECT
operator|||
name|id
operator|==
name|QRGN_SETELLIPSE
condition|)
block|{
name|QRect
name|r
decl_stmt|;
name|s
operator|>>
name|r
expr_stmt|;
name|rgn
operator|=
name|QRegion
argument_list|(
name|r
argument_list|,
name|id
operator|==
name|QRGN_SETRECT
condition|?
name|Rectangle
else|:
name|Ellipse
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|QRGN_SETPTARRAY_ALT
operator|||
name|id
operator|==
name|QRGN_SETPTARRAY_WIND
condition|)
block|{
name|QPolygon
name|a
decl_stmt|;
name|s
operator|>>
name|a
expr_stmt|;
name|rgn
operator|=
name|QRegion
argument_list|(
name|a
argument_list|,
name|id
operator|==
name|QRGN_SETPTARRAY_WIND
condition|?
name|Qt
operator|::
name|WindingFill
else|:
name|Qt
operator|::
name|OddEvenFill
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|QRGN_TRANSLATE
condition|)
block|{
name|QPoint
name|p
decl_stmt|;
name|s
operator|>>
name|p
expr_stmt|;
name|rgn
operator|.
name|translate
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|>=
name|QRGN_OR
operator|&&
name|id
operator|<=
name|QRGN_XOR
condition|)
block|{
name|QByteArray
name|bop1
decl_stmt|,
name|bop2
decl_stmt|;
name|QRegion
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|s
operator|>>
name|bop1
expr_stmt|;
name|r1
operator|.
name|exec
argument_list|(
name|bop1
argument_list|)
expr_stmt|;
name|s
operator|>>
name|bop2
expr_stmt|;
name|r2
operator|.
name|exec
argument_list|(
name|bop2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|QRGN_OR
case|:
name|rgn
operator|=
name|r1
operator|.
name|united
argument_list|(
name|r2
argument_list|)
expr_stmt|;
break|break;
case|case
name|QRGN_AND
case|:
name|rgn
operator|=
name|r1
operator|.
name|intersected
argument_list|(
name|r2
argument_list|)
expr_stmt|;
break|break;
case|case
name|QRGN_SUB
case|:
name|rgn
operator|=
name|r1
operator|.
name|subtracted
argument_list|(
name|r2
argument_list|)
expr_stmt|;
break|break;
case|case
name|QRGN_XOR
case|:
name|rgn
operator|=
name|r1
operator|.
name|xored
argument_list|(
name|r2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|QRGN_RECTS
condition|)
block|{
comment|// (This is the only form used in Qt 2.0)
name|quint32
name|n
decl_stmt|;
name|s
operator|>>
name|n
expr_stmt|;
name|QRect
name|r
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|n
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|>>
name|r
expr_stmt|;
name|rgn
operator|=
name|rgn
operator|.
name|united
argument_list|(
name|QRegion
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|this
operator|=
name|rgn
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QRegion stream functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QRegion&QRegion::operator=(const QRegion&r)      Assigns \a r to this region and returns a reference to the region. */
end_comment
begin_comment
comment|/*!     \fn QRegion&QRegion::operator=(QRegion&&other)      Move-assigns \a other to this QRegion instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn void QRegion::swap(QRegion&other)     \since 4.8      Swaps region \a other with this region. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     \relates QRegion      Writes the region \a r to the stream \a s and returns a reference     to the stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|QVector
argument_list|<
name|QRect
argument_list|>
name|a
init|=
name|r
operator|.
name|rects
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|<<
operator|(
name|quint32
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|a
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|s
operator|<<
call|(
name|quint32
call|)
argument_list|(
literal|12
operator|+
name|i
operator|*
literal|24
argument_list|)
expr_stmt|;
name|s
operator|<<
operator|(
name|int
operator|)
name|QRGN_OR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|<<
call|(
name|quint32
call|)
argument_list|(
literal|4
operator|+
literal|8
argument_list|)
operator|<<
operator|(
name|int
operator|)
name|QRGN_SETRECT
operator|<<
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|s
operator|<<
call|(
name|quint32
call|)
argument_list|(
literal|4
operator|+
literal|4
operator|+
literal|16
operator|*
name|a
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// 16: storage size of QRect
name|s
operator|<<
operator|(
name|qint32
operator|)
name|QRGN_RECTS
expr_stmt|;
name|s
operator|<<
name|a
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QRegion      Reads a region from the stream \a s into \a r and returns a     reference to the stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|QByteArray
name|b
decl_stmt|;
name|s
operator|>>
name|b
expr_stmt|;
name|r
operator|.
name|exec
argument_list|(
name|b
argument_list|,
name|s
operator|.
name|version
argument_list|()
argument_list|,
name|s
operator|.
name|byteOrder
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|s
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s
operator|.
name|nospace
argument_list|()
expr_stmt|;
name|s
operator|<<
literal|"QRegion("
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|"null"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|"empty"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|r
operator|.
name|rects
argument_list|()
decl_stmt|;
specifier|const
name|int
name|count
init|=
name|rects
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|s
operator|<<
literal|"size="
operator|<<
name|count
operator|<<
literal|", bounds=("
expr_stmt|;
name|QtDebugUtils
operator|::
name|formatQRect
argument_list|(
name|s
argument_list|,
name|r
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|s
operator|<<
literal|") - ["
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|s
operator|<<
literal|", "
expr_stmt|;
name|s
operator|<<
literal|'('
expr_stmt|;
name|QtDebugUtils
operator|::
name|formatQRect
argument_list|(
name|s
argument_list|,
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
literal|')'
expr_stmt|;
block|}
name|s
operator|<<
literal|']'
expr_stmt|;
block|}
block|}
name|s
operator|<<
literal|')'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// These are not inline - they can be implemented better on some platforms
end_comment
begin_comment
comment|//  (eg. Windows at least provides 3-variable operations).  For now, simple.
end_comment
begin_comment
comment|/*!     Applies the united() function to this region and \a r. \c r1|r2 is     equivalent to \c r1.united(r2).      \sa united(), operator+() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator |
name|QRegion
name|QRegion
operator|::
name|operator
name||
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|united
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the united() function to this region and \a r. \c r1+r2 is     equivalent to \c r1.united(r2).      \sa united(), operator|() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator +
name|QRegion
name|QRegion
operator|::
name|operator
name|+
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|united
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    \overload    \since 4.4  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator +
name|QRegion
name|QRegion
operator|::
name|operator
name|+
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|united
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the intersected() function to this region and \a r. \c r1&r2     is equivalent to \c r1.intersected(r2).      \sa intersected() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator &
name|QRegion
name|QRegion
operator|::
name|operator
name|&
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|intersected
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    \overload    \since 4.4  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator &
name|QRegion
name|QRegion
operator|::
name|operator
name|&
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|intersected
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the subtracted() function to this region and \a r. \c r1-r2     is equivalent to \c r1.subtracted(r2).      \sa subtracted() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator -
name|QRegion
name|QRegion
operator|::
name|operator
name|-
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|subtracted
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the xored() function to this region and \a r. \c r1^r2 is     equivalent to \c r1.xored(r2).      \sa xored() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_MANGLES_RETURN_TYPE
end_ifdef
begin_function
specifier|const
endif|#
directive|endif
DECL|function|operator ^
name|QRegion
name|QRegion
operator|::
name|operator
name|^
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|xored
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the united() function to this region and \a r and assigns     the result to this region. \c r1|=r2 is equivalent to \c     {r1 = r1.united(r2)}.      \sa united() */
end_comment
begin_function
DECL|function|operator |=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name||=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|*
name|this
operator||
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRegion& QRegion::operator+=(const QRect&rect)      Returns a region that is the union of this region with the specified \a rect.      \sa united() */
end_comment
begin_comment
comment|/*!     \fn QRegion& QRegion::operator+=(const QRegion&r)      Applies the united() function to this region and \a r and assigns     the result to this region. \c r1+=r2 is equivalent to \c     {r1 = r1.united(r2)}.      \sa intersected() */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|operator +=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|+=
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
return|return
name|operator
name|+=
argument_list|(
name|QRegion
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn QRegion& QRegion::operator&=(const QRegion&r)    Applies the intersected() function to this region and \a r and   assigns the result to this region. \c r1&=r2 is equivalent to \c   r1 = r1.intersected(r2).    \sa intersected() */
end_comment
begin_function
DECL|function|operator &=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|&=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|*
name|this
operator|&
name|r
return|;
block|}
end_function
begin_comment
comment|/*!    \overload    \since 4.4  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|operator &=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|&=
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|*
name|this
operator|&
name|r
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|operator &=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|&=
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|&=
operator|(
name|QRegion
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn QRegion& QRegion::operator-=(const QRegion&r)    Applies the subtracted() function to this region and \a r and   assigns the result to this region. \c r1-=r2 is equivalent to \c   {r1 = r1.subtracted(r2)}.    \sa subtracted() */
end_comment
begin_function
DECL|function|operator -=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|-=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|*
name|this
operator|-
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     Applies the xored() function to this region and \a r and     assigns the result to this region. \c r1^=r2 is equivalent to \c     {r1 = r1.xored(r2)}.      \sa xored() */
end_comment
begin_function
DECL|function|operator ^=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|^=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|*
name|this
operator|^
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QRegion::operator!=(const QRegion&other) const      Returns \c true if this region is different from the \a other region;     otherwise returns \c false. */
end_comment
begin_comment
comment|/*!    Returns the region as a QVariant */
end_comment
begin_function
DECL|function|operator QVariant
name|QRegion
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Region
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QRegion::operator==(const QRegion&r) const      Returns \c true if the region is equal to \a r; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn void QRegion::translate(int dx, int dy)      Translates (moves) the region \a dx along the X axis and \a dy     along the Y axis. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::translated(const QPoint&p) const     \overload     \since 4.1      Returns a copy of the regtion that is translated \a{p}\e{.x()}     along the x axis and \a{p}\e{.y()} along the y axis, relative to     the current position.  Positive values move the rectangle to the     right and down.      \sa translate() */
end_comment
begin_comment
comment|/*!     \since 4.1      Returns a copy of the region that is translated \a dx along the     x axis and \a dy along the y axis, relative to the current     position. Positive values move the region to the right and     down.      \sa translate() */
end_comment
begin_function
name|QRegion
DECL|function|translated
name|QRegion
operator|::
name|translated
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
specifier|const
block|{
name|QRegion
name|ret
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|rect_intersects
specifier|inline
name|bool
name|rect_intersects
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r2
parameter_list|)
block|{
return|return
operator|(
name|r1
operator|.
name|right
argument_list|()
operator|>=
name|r2
operator|.
name|left
argument_list|()
operator|&&
name|r1
operator|.
name|left
argument_list|()
operator|<=
name|r2
operator|.
name|right
argument_list|()
operator|&&
name|r1
operator|.
name|bottom
argument_list|()
operator|>=
name|r2
operator|.
name|top
argument_list|()
operator|&&
name|r1
operator|.
name|top
argument_list|()
operator|<=
name|r2
operator|.
name|bottom
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns \c true if this region intersects with \a region, otherwise     returns \c false. */
end_comment
begin_function
DECL|function|intersects
name|bool
name|QRegion
operator|::
name|intersects
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|rect_intersects
argument_list|(
name|boundingRect
argument_list|()
argument_list|,
name|region
operator|.
name|boundingRect
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|rectCount
argument_list|()
operator|==
literal|1
operator|&&
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
return|return
literal|true
return|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|myRects
init|=
name|rects
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|otherRects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|QRect
argument_list|>
operator|::
name|const_iterator
name|i1
init|=
name|myRects
operator|.
name|constBegin
argument_list|()
init|;
name|i1
operator|<
name|myRects
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i1
control|)
for|for
control|(
name|QVector
argument_list|<
name|QRect
argument_list|>
operator|::
name|const_iterator
name|i2
init|=
name|otherRects
operator|.
name|constBegin
argument_list|()
init|;
name|i2
operator|<
name|otherRects
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i2
control|)
if|if
condition|(
name|rect_intersects
argument_list|(
operator|*
name|i1
argument_list|,
operator|*
name|i2
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QRegion::intersects(const QRect&rect) const     \since 4.2      Returns \c true if this region intersects with \a rect, otherwise     returns \c false. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_comment
comment|/*!     \overload     \since 4.4 */
end_comment
begin_function
DECL|function|intersect
name|QRegion
name|QRegion
operator|::
name|intersect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|intersect
argument_list|(
name|QRegion
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn int QRegion::rectCount() const     \since 4.6      Returns the number of rectangles that will be returned in rects(). */
end_comment
begin_comment
comment|/*!     \fn bool QRegion::isEmpty() const      Returns \c true if the region is empty; otherwise returns \c false. An     empty region is a region that contains no points.      Example:     \snippet code/src_gui_painting_qregion_unix.cpp 0 */
end_comment
begin_comment
comment|/*!     \fn bool QRegion::isNull() const     \since 5.0      Returns \c true if the region is empty; otherwise returns \c false. An     empty region is a region that contains no points. This function is     the same as isEmpty      \sa isEmpty() */
end_comment
begin_comment
comment|/*!     \fn bool QRegion::contains(const QPoint&p) const      Returns \c true if the region contains the point \a p; otherwise     returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QRegion::contains(const QRect&r) const     \overload      Returns \c true if the region overlaps the rectangle \a r; otherwise     returns \c false. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::unite(const QRegion&r) const     \obsolete      Use united(\a r) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::unite(const QRect&rect) const     \since 4.4     \obsolete      Use united(\a rect) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::united(const QRect&rect) const     \since 4.4      Returns a region which is the union of this region and the given \a rect.      \sa intersected(), subtracted(), xored() */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::united(const QRegion&r) const     \since 4.2      Returns a region which is the union of this region and \a r.      \image runion.png Region Union      The figure shows the union of two elliptical regions.      \sa intersected(), subtracted(), xored() */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::intersect(const QRegion&r) const     \obsolete      Use intersected(\a r) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::intersect(const QRect&rect) const     \since 4.4     \obsolete      Use intersected(\a rect) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::intersected(const QRect&rect) const     \since 4.4      Returns a region which is the intersection of this region and the given \a rect.      \sa subtracted(), united(), xored() */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::intersected(const QRegion&r) const     \since 4.2      Returns a region which is the intersection of this region and \a r.      \image rintersect.png Region Intersection      The figure shows the intersection of two elliptical regions.      \sa subtracted(), united(), xored() */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::subtract(const QRegion&r) const     \obsolete      Use subtracted(\a r) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::subtracted(const QRegion&r) const     \since 4.2      Returns a region which is \a r subtracted from this region.      \image rsubtract.png Region Subtraction      The figure shows the result when the ellipse on the right is     subtracted from the ellipse on the left (\c {left - right}).      \sa intersected(), united(), xored() */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::eor(const QRegion&r) const     \obsolete      Use xored(\a r) instead. */
end_comment
begin_comment
comment|/*!     \fn QRegion QRegion::xored(const QRegion&r) const     \since 4.2      Returns a region which is the exclusive or (XOR) of this region     and \a r.      \image rxor.png Region XORed      The figure shows the exclusive or of two elliptical regions.      \sa intersected(), united(), subtracted() */
end_comment
begin_comment
comment|/*!     \fn QRect QRegion::boundingRect() const      Returns the bounding rectangle of this region. An empty region     gives a rectangle that is QRect::isNull(). */
end_comment
begin_comment
comment|/*!     \fn QVector<QRect> QRegion::rects() const      Returns an array of non-overlapping rectangles that make up the     region.      The union of all the rectangles is equal to the original region. */
end_comment
begin_comment
comment|/*!     \fn void QRegion::setRects(const QRect *rects, int number)      Sets the region using the array of rectangles specified by \a rects and     \a number.     The rectangles \e must be optimally Y-X sorted and follow these restrictions:      \list     \li The rectangles must not intersect.     \li All rectangles with a given top coordinate must have the same height.     \li No two rectangles may abut horizontally (they should be combined        into a single wider rectangle in that case).     \li The rectangles must be sorted in ascending order, with Y as the major        sort key and X as the minor sort key.     \endlist     \omit     Only some platforms have these restrictions (Qt for Embedded Linux, X11 and OS X).     \endomit */
end_comment
begin_namespace
namespace|namespace
block|{
DECL|struct|Segment
struct|struct
name|Segment
block|{
DECL|function|Segment
name|Segment
parameter_list|()
block|{}
DECL|function|Segment
name|Segment
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
member_init_list|:
name|added
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|point
argument_list|(
name|p
argument_list|)
block|{     }
DECL|function|left
name|int
name|left
parameter_list|()
specifier|const
block|{
return|return
name|qMin
argument_list|(
name|point
operator|.
name|x
argument_list|()
argument_list|,
name|next
operator|->
name|point
operator|.
name|x
argument_list|()
argument_list|)
return|;
block|}
DECL|function|right
name|int
name|right
parameter_list|()
specifier|const
block|{
return|return
name|qMax
argument_list|(
name|point
operator|.
name|x
argument_list|()
argument_list|,
name|next
operator|->
name|point
operator|.
name|x
argument_list|()
argument_list|)
return|;
block|}
DECL|function|overlaps
name|bool
name|overlaps
parameter_list|(
specifier|const
name|Segment
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|left
argument_list|()
operator|<
name|other
operator|.
name|right
argument_list|()
operator|&&
name|other
operator|.
name|left
argument_list|()
operator|<
name|right
argument_list|()
return|;
block|}
DECL|function|connect
name|void
name|connect
parameter_list|(
name|Segment
modifier|&
name|other
parameter_list|)
block|{
name|next
operator|=
operator|&
name|other
expr_stmt|;
name|other
operator|.
name|prev
operator|=
name|this
expr_stmt|;
name|horizontal
operator|=
operator|(
name|point
operator|.
name|y
argument_list|()
operator|==
name|other
operator|.
name|point
operator|.
name|y
argument_list|()
operator|)
expr_stmt|;
block|}
DECL|function|merge
name|void
name|merge
parameter_list|(
name|Segment
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|right
argument_list|()
operator|<=
name|other
operator|.
name|right
argument_list|()
condition|)
block|{
name|QPoint
name|p
init|=
name|other
operator|.
name|point
decl_stmt|;
name|Segment
modifier|*
name|oprev
init|=
name|other
operator|.
name|prev
decl_stmt|;
name|other
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|other
operator|.
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
operator|&
name|other
expr_stmt|;
name|point
operator|=
name|p
expr_stmt|;
name|prev
operator|=
name|oprev
expr_stmt|;
name|oprev
operator|->
name|next
operator|=
name|this
expr_stmt|;
block|}
else|else
block|{
name|Segment
modifier|*
name|onext
init|=
name|other
operator|.
name|next
decl_stmt|;
name|other
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
operator|&
name|other
expr_stmt|;
name|next
operator|=
name|onext
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|this
expr_stmt|;
block|}
block|}
DECL|member|horizontal
name|int
name|horizontal
range|:
literal|1
decl_stmt|;
DECL|member|added
name|int
name|added
range|:
literal|1
decl_stmt|;
DECL|member|point
name|QPoint
name|point
decl_stmt|;
DECL|member|prev
name|Segment
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|Segment
modifier|*
name|next
decl_stmt|;
block|}
struct|;
DECL|function|mergeSegments
name|void
name|mergeSegments
parameter_list|(
name|Segment
modifier|*
name|a
parameter_list|,
name|int
name|na
parameter_list|,
name|Segment
modifier|*
name|b
parameter_list|,
name|int
name|nb
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|na
operator|&&
name|j
operator|!=
name|nb
condition|)
block|{
name|Segment
modifier|&
name|sa
init|=
name|a
index|[
name|i
index|]
decl_stmt|;
name|Segment
modifier|&
name|sb
init|=
name|b
index|[
name|j
index|]
decl_stmt|;
specifier|const
name|int
name|ra
init|=
name|sa
operator|.
name|right
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rb
init|=
name|sb
operator|.
name|right
argument_list|()
decl_stmt|;
if|if
condition|(
name|sa
operator|.
name|overlaps
argument_list|(
name|sb
argument_list|)
condition|)
name|sa
operator|.
name|merge
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|i
operator|+=
operator|(
name|rb
operator|>=
name|ra
operator|)
expr_stmt|;
name|j
operator|+=
operator|(
name|ra
operator|>=
name|rb
operator|)
expr_stmt|;
block|}
block|}
DECL|function|addSegmentsToPath
name|void
name|addSegmentsToPath
parameter_list|(
name|Segment
modifier|*
name|segment
parameter_list|,
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
name|Segment
modifier|*
name|current
init|=
name|segment
decl_stmt|;
name|path
operator|.
name|moveTo
argument_list|(
name|current
operator|->
name|point
argument_list|)
expr_stmt|;
name|current
operator|->
name|added
operator|=
literal|true
expr_stmt|;
name|Segment
modifier|*
name|last
init|=
name|current
decl_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|segment
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|horizontal
operator|!=
name|last
operator|->
name|horizontal
condition|)
name|path
operator|.
name|lineTo
argument_list|(
name|current
operator|->
name|point
argument_list|)
expr_stmt|;
name|current
operator|->
name|added
operator|=
literal|true
expr_stmt|;
name|last
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_namespace
begin_function
DECL|function|qt_regionToPath
name|Q_GUI_EXPORT
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QPainterPath
name|result
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|addRect
argument_list|(
name|region
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|Segment
argument_list|>
name|segments
decl_stmt|;
name|segments
operator|.
name|resize
argument_list|(
literal|4
operator|*
name|rects
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|rect
init|=
name|rects
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|end
init|=
name|rect
operator|+
name|rects
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lastRowSegmentCount
init|=
literal|0
decl_stmt|;
name|Segment
modifier|*
name|lastRowSegments
init|=
literal|0
decl_stmt|;
name|int
name|lastSegment
init|=
literal|0
decl_stmt|;
name|int
name|lastY
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rect
operator|!=
name|end
condition|)
block|{
specifier|const
name|int
name|y
init|=
name|rect
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|&
name|rect
index|[
name|count
index|]
operator|!=
name|end
operator|&&
name|rect
index|[
name|count
index|]
operator|.
name|y
argument_list|()
operator|==
name|y
condition|)
operator|++
name|count
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|offset
init|=
name|lastSegment
operator|+
name|i
decl_stmt|;
name|segments
index|[
name|offset
index|]
operator|=
name|Segment
argument_list|(
name|rect
index|[
name|i
index|]
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|segments
index|[
name|offset
operator|+=
name|count
index|]
operator|=
name|Segment
argument_list|(
name|rect
index|[
name|i
index|]
operator|.
name|topRight
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|segments
index|[
name|offset
operator|+=
name|count
index|]
operator|=
name|Segment
argument_list|(
name|rect
index|[
name|i
index|]
operator|.
name|bottomRight
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|segments
index|[
name|offset
operator|+=
name|count
index|]
operator|=
name|Segment
argument_list|(
name|rect
index|[
name|i
index|]
operator|.
name|bottomLeft
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lastSegment
operator|+
name|i
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
name|segments
index|[
name|offset
operator|+
name|j
operator|*
name|count
index|]
operator|.
name|connect
argument_list|(
name|segments
index|[
name|offset
operator|+
operator|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
literal|4
operator|)
operator|*
name|count
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastRowSegments
operator|&&
name|lastY
operator|==
name|y
condition|)
name|mergeSegments
argument_list|(
name|lastRowSegments
argument_list|,
name|lastRowSegmentCount
argument_list|,
operator|&
name|segments
index|[
name|lastSegment
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|lastRowSegments
operator|=
operator|&
name|segments
index|[
name|lastSegment
operator|+
literal|2
operator|*
name|count
index|]
expr_stmt|;
name|lastRowSegmentCount
operator|=
name|count
expr_stmt|;
name|lastSegment
operator|+=
literal|4
operator|*
name|count
expr_stmt|;
name|lastY
operator|=
name|y
operator|+
name|rect
index|[
literal|0
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
name|rect
operator|+=
name|count
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastSegment
condition|;
operator|++
name|i
control|)
block|{
name|Segment
modifier|*
name|segment
init|=
operator|&
name|segments
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|segment
operator|->
name|added
condition|)
name|addSegmentsToPath
argument_list|(
name|segment
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_comment
comment|//#define QT_REGION_DEBUG
end_comment
begin_comment
comment|/*  *   clip region  */
end_comment
begin_struct
DECL|struct|QRegionPrivate
struct|struct
name|QRegionPrivate
block|{
DECL|member|numRects
name|int
name|numRects
decl_stmt|;
DECL|member|innerArea
name|int
name|innerArea
decl_stmt|;
DECL|member|rects
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
decl_stmt|;
DECL|member|extents
name|QRect
name|extents
decl_stmt|;
DECL|member|innerRect
name|QRect
name|innerRect
decl_stmt|;
DECL|function|QRegionPrivate
specifier|inline
name|QRegionPrivate
parameter_list|()
member_init_list|:
name|numRects
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|innerArea
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|function|QRegionPrivate
specifier|inline
name|QRegionPrivate
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
member_init_list|:
name|numRects
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|innerArea
argument_list|(
name|r
operator|.
name|width
argument_list|()
operator|*
name|r
operator|.
name|height
argument_list|()
argument_list|)
member_init_list|,
name|extents
argument_list|(
name|r
argument_list|)
member_init_list|,
name|innerRect
argument_list|(
name|r
argument_list|)
block|{     }
name|void
name|intersect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
function_decl|;
comment|/*      * Returns \c true if r is guaranteed to be fully contained in this region.      * A false return value does not guarantee the opposite.      */
DECL|function|contains
specifier|inline
name|bool
name|contains
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|contains
argument_list|(
name|r
operator|.
name|extents
argument_list|)
return|;
block|}
DECL|function|contains
specifier|inline
name|bool
name|contains
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r2
parameter_list|)
specifier|const
block|{
specifier|const
name|QRect
modifier|&
name|r1
init|=
name|innerRect
decl_stmt|;
return|return
name|r2
operator|.
name|left
argument_list|()
operator|>=
name|r1
operator|.
name|left
argument_list|()
operator|&&
name|r2
operator|.
name|right
argument_list|()
operator|<=
name|r1
operator|.
name|right
argument_list|()
operator|&&
name|r2
operator|.
name|top
argument_list|()
operator|>=
name|r1
operator|.
name|top
argument_list|()
operator|&&
name|r2
operator|.
name|bottom
argument_list|()
operator|<=
name|r1
operator|.
name|bottom
argument_list|()
return|;
block|}
comment|/*      * Returns \c true if this region is guaranteed to be fully contained in r.      */
DECL|function|within
specifier|inline
name|bool
name|within
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r1
parameter_list|)
specifier|const
block|{
specifier|const
name|QRect
modifier|&
name|r2
init|=
name|extents
decl_stmt|;
return|return
name|r2
operator|.
name|left
argument_list|()
operator|>=
name|r1
operator|.
name|left
argument_list|()
operator|&&
name|r2
operator|.
name|right
argument_list|()
operator|<=
name|r1
operator|.
name|right
argument_list|()
operator|&&
name|r2
operator|.
name|top
argument_list|()
operator|>=
name|r1
operator|.
name|top
argument_list|()
operator|&&
name|r2
operator|.
name|bottom
argument_list|()
operator|<=
name|r1
operator|.
name|bottom
argument_list|()
return|;
block|}
DECL|function|updateInnerRect
specifier|inline
name|void
name|updateInnerRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|area
init|=
name|rect
operator|.
name|width
argument_list|()
operator|*
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|area
operator|>
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|area
expr_stmt|;
name|innerRect
operator|=
name|rect
expr_stmt|;
block|}
block|}
DECL|function|vectorize
specifier|inline
name|void
name|vectorize
parameter_list|()
block|{
if|if
condition|(
name|numRects
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rects
operator|.
name|size
argument_list|()
condition|)
name|rects
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rects
index|[
literal|0
index|]
operator|=
name|extents
expr_stmt|;
block|}
block|}
specifier|inline
name|void
name|append
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
function_decl|;
name|void
name|append
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
function_decl|;
name|void
name|prepend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
function_decl|;
name|void
name|prepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
function_decl|;
specifier|inline
name|bool
name|canAppend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|canAppend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|canPrepend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|canPrepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|bool
name|mergeFromRight
parameter_list|(
name|QRect
modifier|*
name|left
parameter_list|,
specifier|const
name|QRect
modifier|*
name|right
parameter_list|)
function_decl|;
specifier|inline
name|bool
name|mergeFromLeft
parameter_list|(
name|QRect
modifier|*
name|left
parameter_list|,
specifier|const
name|QRect
modifier|*
name|right
parameter_list|)
function_decl|;
specifier|inline
name|bool
name|mergeFromBelow
parameter_list|(
name|QRect
modifier|*
name|top
parameter_list|,
specifier|const
name|QRect
modifier|*
name|bottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToTop
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToBottom
parameter_list|)
function_decl|;
specifier|inline
name|bool
name|mergeFromAbove
parameter_list|(
name|QRect
modifier|*
name|bottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|top
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToBottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToTop
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|void
name|selfTest
parameter_list|()
specifier|const
function_decl|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_function
DECL|function|isEmptyHelper
specifier|static
specifier|inline
name|bool
name|isEmptyHelper
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|preg
parameter_list|)
block|{
return|return
operator|!
name|preg
operator|||
name|preg
operator|->
name|numRects
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|canMergeFromRight
specifier|static
specifier|inline
name|bool
name|canMergeFromRight
parameter_list|(
specifier|const
name|QRect
modifier|*
name|left
parameter_list|,
specifier|const
name|QRect
modifier|*
name|right
parameter_list|)
block|{
return|return
operator|(
name|right
operator|->
name|top
argument_list|()
operator|==
name|left
operator|->
name|top
argument_list|()
operator|&&
name|right
operator|->
name|bottom
argument_list|()
operator|==
name|left
operator|->
name|bottom
argument_list|()
operator|&&
name|right
operator|->
name|left
argument_list|()
operator|<=
operator|(
name|left
operator|->
name|right
argument_list|()
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|canMergeFromLeft
specifier|static
specifier|inline
name|bool
name|canMergeFromLeft
parameter_list|(
specifier|const
name|QRect
modifier|*
name|right
parameter_list|,
specifier|const
name|QRect
modifier|*
name|left
parameter_list|)
block|{
return|return
name|canMergeFromRight
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mergeFromRight
name|bool
name|QRegionPrivate
operator|::
name|mergeFromRight
parameter_list|(
name|QRect
modifier|*
name|left
parameter_list|,
specifier|const
name|QRect
modifier|*
name|right
parameter_list|)
block|{
if|if
condition|(
name|canMergeFromRight
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
name|left
operator|->
name|setRight
argument_list|(
name|right
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|left
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|mergeFromLeft
name|bool
name|QRegionPrivate
operator|::
name|mergeFromLeft
parameter_list|(
name|QRect
modifier|*
name|right
parameter_list|,
specifier|const
name|QRect
modifier|*
name|left
parameter_list|)
block|{
if|if
condition|(
name|canMergeFromLeft
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
condition|)
block|{
name|right
operator|->
name|setLeft
argument_list|(
name|left
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|right
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canMergeFromBelow
specifier|static
specifier|inline
name|bool
name|canMergeFromBelow
parameter_list|(
specifier|const
name|QRect
modifier|*
name|top
parameter_list|,
specifier|const
name|QRect
modifier|*
name|bottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToTop
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToBottom
parameter_list|)
block|{
if|if
condition|(
name|nextToTop
operator|&&
name|nextToTop
operator|->
name|y
argument_list|()
operator|==
name|top
operator|->
name|y
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|nextToBottom
operator|&&
name|nextToBottom
operator|->
name|y
argument_list|()
operator|==
name|bottom
operator|->
name|y
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|(
name|top
operator|->
name|bottom
argument_list|()
operator|>=
operator|(
name|bottom
operator|->
name|top
argument_list|()
operator|-
literal|1
operator|)
operator|)
operator|&&
name|top
operator|->
name|left
argument_list|()
operator|==
name|bottom
operator|->
name|left
argument_list|()
operator|&&
name|top
operator|->
name|right
argument_list|()
operator|==
name|bottom
operator|->
name|right
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|mergeFromBelow
name|bool
name|QRegionPrivate
operator|::
name|mergeFromBelow
parameter_list|(
name|QRect
modifier|*
name|top
parameter_list|,
specifier|const
name|QRect
modifier|*
name|bottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToTop
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToBottom
parameter_list|)
block|{
if|if
condition|(
name|canMergeFromBelow
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|nextToTop
argument_list|,
name|nextToBottom
argument_list|)
condition|)
block|{
name|top
operator|->
name|setBottom
argument_list|(
name|bottom
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|top
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|mergeFromAbove
name|bool
name|QRegionPrivate
operator|::
name|mergeFromAbove
parameter_list|(
name|QRect
modifier|*
name|bottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|top
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToBottom
parameter_list|,
specifier|const
name|QRect
modifier|*
name|nextToTop
parameter_list|)
block|{
if|if
condition|(
name|canMergeFromBelow
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|nextToTop
argument_list|,
name|nextToBottom
argument_list|)
condition|)
block|{
name|bottom
operator|->
name|setTop
argument_list|(
name|top
operator|->
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|bottom
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|qt_rect_intersect_normalized
specifier|static
specifier|inline
name|QRect
name|qt_rect_intersect_normalized
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r2
parameter_list|)
block|{
name|QRect
name|r
decl_stmt|;
name|r
operator|.
name|setLeft
argument_list|(
name|qMax
argument_list|(
name|r1
operator|.
name|left
argument_list|()
argument_list|,
name|r2
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|setRight
argument_list|(
name|qMin
argument_list|(
name|r1
operator|.
name|right
argument_list|()
argument_list|,
name|r2
operator|.
name|right
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|setTop
argument_list|(
name|qMax
argument_list|(
name|r1
operator|.
name|top
argument_list|()
argument_list|,
name|r2
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|setBottom
argument_list|(
name|qMin
argument_list|(
name|r1
operator|.
name|bottom
argument_list|()
argument_list|,
name|r2
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|intersect
name|void
name|QRegionPrivate
operator|::
name|intersect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|extents
operator|.
name|intersects
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|numRects
operator|>
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QRect
name|r
init|=
name|rect
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|extents
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|innerRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|innerArea
operator|=
operator|-
literal|1
expr_stmt|;
name|QRect
modifier|*
name|dest
init|=
name|rects
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|src
init|=
name|dest
decl_stmt|;
name|int
name|n
init|=
name|numRects
decl_stmt|;
name|numRects
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|dest
operator|=
name|qt_rect_intersect_normalized
argument_list|(
operator|*
name|src
operator|++
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|numRects
operator|==
literal|0
condition|)
block|{
name|extents
operator|=
operator|*
name|dest
expr_stmt|;
block|}
else|else
block|{
name|extents
operator|.
name|setLeft
argument_list|(
name|qMin
argument_list|(
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|dest
operator|->
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// hw: extents.top() will never change after initialization
comment|//extents.setTop(qMin(extents.top(), dest->top()));
name|extents
operator|.
name|setRight
argument_list|(
name|qMax
argument_list|(
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|dest
operator|->
name|right
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|extents
operator|.
name|setBottom
argument_list|(
name|qMax
argument_list|(
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|dest
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|nextToLast
init|=
operator|(
name|numRects
operator|>
literal|1
condition|?
name|dest
operator|-
literal|2
else|:
literal|0
operator|)
decl_stmt|;
comment|// mergeFromBelow inlined and optimized
if|if
condition|(
name|canMergeFromBelow
argument_list|(
name|dest
operator|-
literal|1
argument_list|,
name|dest
argument_list|,
name|nextToLast
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|n
operator|||
name|src
operator|->
name|y
argument_list|()
operator|!=
name|dest
operator|->
name|y
argument_list|()
operator|||
name|src
operator|->
name|left
argument_list|()
operator|>
name|r
operator|.
name|right
argument_list|()
condition|)
block|{
name|QRect
modifier|*
name|prev
init|=
name|dest
operator|-
literal|1
decl_stmt|;
name|prev
operator|->
name|setBottom
argument_list|(
name|dest
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|updateInnerRect
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|numRects
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|append
name|void
name|QRegionPrivate
operator|::
name|append
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|r
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QRect
modifier|*
name|myLast
init|=
operator|(
name|numRects
operator|==
literal|1
condition|?
operator|&
name|extents
else|:
name|rects
operator|.
name|data
argument_list|()
operator|+
operator|(
name|numRects
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromRight
argument_list|(
name|myLast
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|numRects
operator|>
literal|1
condition|)
block|{
specifier|const
name|QRect
modifier|*
name|nextToTop
init|=
operator|(
name|numRects
operator|>
literal|2
condition|?
name|myLast
operator|-
literal|2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromBelow
argument_list|(
name|myLast
operator|-
literal|1
argument_list|,
name|myLast
argument_list|,
name|nextToTop
argument_list|,
literal|0
argument_list|)
condition|)
operator|--
name|numRects
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mergeFromBelow
argument_list|(
name|myLast
argument_list|,
name|r
argument_list|,
operator|(
name|numRects
operator|>
literal|1
condition|?
name|myLast
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// nothing
block|}
else|else
block|{
name|vectorize
argument_list|()
expr_stmt|;
operator|++
name|numRects
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|rects
operator|.
name|size
argument_list|()
operator|<
name|numRects
condition|)
name|rects
operator|.
name|resize
argument_list|(
name|numRects
argument_list|)
expr_stmt|;
name|rects
index|[
name|numRects
operator|-
literal|1
index|]
operator|=
operator|*
name|r
expr_stmt|;
block|}
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|->
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|extents
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|->
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|r
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|append
name|void
name|QRegionPrivate
operator|::
name|append
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
name|append
argument_list|(
operator|&
name|r
operator|->
name|extents
argument_list|)
expr_stmt|;
return|return;
block|}
name|vectorize
argument_list|()
expr_stmt|;
name|QRect
modifier|*
name|destRect
init|=
name|rects
operator|.
name|data
argument_list|()
operator|+
name|numRects
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|srcRect
init|=
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
decl_stmt|;
name|int
name|numAppend
init|=
name|r
operator|->
name|numRects
decl_stmt|;
comment|// try merging
block|{
specifier|const
name|QRect
modifier|*
name|rFirst
init|=
name|srcRect
decl_stmt|;
name|QRect
modifier|*
name|myLast
init|=
name|destRect
operator|-
literal|1
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|nextToLast
init|=
operator|(
name|numRects
operator|>
literal|1
condition|?
name|myLast
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromRight
argument_list|(
name|myLast
argument_list|,
name|rFirst
argument_list|)
condition|)
block|{
operator|++
name|srcRect
expr_stmt|;
operator|--
name|numAppend
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|rNextToFirst
init|=
operator|(
name|numAppend
operator|>
literal|1
condition|?
name|rFirst
operator|+
literal|2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromBelow
argument_list|(
name|myLast
argument_list|,
name|rFirst
operator|+
literal|1
argument_list|,
name|nextToLast
argument_list|,
name|rNextToFirst
argument_list|)
condition|)
block|{
operator|++
name|srcRect
expr_stmt|;
operator|--
name|numAppend
expr_stmt|;
block|}
if|if
condition|(
name|numRects
operator|>
literal|1
condition|)
block|{
name|nextToLast
operator|=
operator|(
name|numRects
operator|>
literal|2
condition|?
name|myLast
operator|-
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|rNextToFirst
operator|=
operator|(
name|numAppend
operator|>
literal|0
condition|?
name|srcRect
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mergeFromBelow
argument_list|(
name|myLast
operator|-
literal|1
argument_list|,
name|myLast
argument_list|,
name|nextToLast
argument_list|,
name|rNextToFirst
argument_list|)
condition|)
block|{
operator|--
name|destRect
expr_stmt|;
operator|--
name|numRects
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mergeFromBelow
argument_list|(
name|myLast
argument_list|,
name|rFirst
argument_list|,
name|nextToLast
argument_list|,
name|rFirst
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|++
name|srcRect
expr_stmt|;
operator|--
name|numAppend
expr_stmt|;
block|}
block|}
comment|// append rectangles
if|if
condition|(
name|numAppend
operator|>
literal|0
condition|)
block|{
specifier|const
name|int
name|newNumRects
init|=
name|numRects
operator|+
name|numAppend
decl_stmt|;
if|if
condition|(
name|newNumRects
operator|>
name|rects
operator|.
name|size
argument_list|()
condition|)
block|{
name|rects
operator|.
name|resize
argument_list|(
name|newNumRects
argument_list|)
expr_stmt|;
name|destRect
operator|=
name|rects
operator|.
name|data
argument_list|()
operator|+
name|numRects
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|destRect
argument_list|,
name|srcRect
argument_list|,
name|numAppend
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
name|numRects
operator|=
name|newNumRects
expr_stmt|;
block|}
comment|// update inner rectangle
if|if
condition|(
name|innerArea
operator|<
name|r
operator|->
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|r
operator|->
name|innerArea
expr_stmt|;
name|innerRect
operator|=
name|r
operator|->
name|innerRect
expr_stmt|;
block|}
comment|// update extents
name|destRect
operator|=
operator|&
name|extents
expr_stmt|;
name|srcRect
operator|=
operator|&
name|r
operator|->
name|extents
expr_stmt|;
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|destRect
operator|->
name|left
argument_list|()
argument_list|,
name|srcRect
operator|->
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|destRect
operator|->
name|top
argument_list|()
argument_list|,
name|srcRect
operator|->
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|right
argument_list|()
argument_list|,
name|srcRect
operator|->
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|destRect
operator|->
name|bottom
argument_list|()
argument_list|,
name|srcRect
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|prepend
name|void
name|QRegionPrivate
operator|::
name|prepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
name|prepend
argument_list|(
operator|&
name|r
operator|->
name|extents
argument_list|)
expr_stmt|;
return|return;
block|}
name|vectorize
argument_list|()
expr_stmt|;
name|int
name|numPrepend
init|=
name|r
operator|->
name|numRects
decl_stmt|;
name|int
name|numSkip
init|=
literal|0
decl_stmt|;
comment|// try merging
block|{
name|QRect
modifier|*
name|myFirst
init|=
name|rects
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|nextToFirst
init|=
operator|(
name|numRects
operator|>
literal|1
condition|?
name|myFirst
operator|+
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|rLast
init|=
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
operator|+
name|r
operator|->
name|numRects
operator|-
literal|1
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|rNextToLast
init|=
operator|(
name|r
operator|->
name|numRects
operator|>
literal|1
condition|?
name|rLast
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromLeft
argument_list|(
name|myFirst
argument_list|,
name|rLast
argument_list|)
condition|)
block|{
operator|--
name|numPrepend
expr_stmt|;
operator|--
name|rLast
expr_stmt|;
name|rNextToLast
operator|=
operator|(
name|numPrepend
operator|>
literal|1
condition|?
name|rLast
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mergeFromAbove
argument_list|(
name|myFirst
argument_list|,
name|rLast
argument_list|,
name|nextToFirst
argument_list|,
name|rNextToLast
argument_list|)
condition|)
block|{
operator|--
name|numPrepend
expr_stmt|;
operator|--
name|rLast
expr_stmt|;
block|}
if|if
condition|(
name|numRects
operator|>
literal|1
condition|)
block|{
name|nextToFirst
operator|=
operator|(
name|numRects
operator|>
literal|2
condition|?
name|myFirst
operator|+
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|rNextToLast
operator|=
operator|(
name|numPrepend
operator|>
literal|0
condition|?
name|rLast
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mergeFromAbove
argument_list|(
name|myFirst
operator|+
literal|1
argument_list|,
name|myFirst
argument_list|,
name|nextToFirst
argument_list|,
name|rNextToLast
argument_list|)
condition|)
block|{
operator|--
name|numRects
expr_stmt|;
operator|++
name|numSkip
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mergeFromAbove
argument_list|(
name|myFirst
argument_list|,
name|rLast
argument_list|,
name|nextToFirst
argument_list|,
name|rNextToLast
argument_list|)
condition|)
block|{
operator|--
name|numPrepend
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numPrepend
operator|>
literal|0
condition|)
block|{
specifier|const
name|int
name|newNumRects
init|=
name|numRects
operator|+
name|numPrepend
decl_stmt|;
if|if
condition|(
name|newNumRects
operator|>
name|rects
operator|.
name|size
argument_list|()
condition|)
name|rects
operator|.
name|resize
argument_list|(
name|newNumRects
argument_list|)
expr_stmt|;
comment|// move existing rectangles
name|memmove
argument_list|(
name|rects
operator|.
name|data
argument_list|()
operator|+
name|numPrepend
argument_list|,
name|rects
operator|.
name|constData
argument_list|()
operator|+
name|numSkip
argument_list|,
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// prepend new rectangles
name|memcpy
argument_list|(
name|rects
operator|.
name|data
argument_list|()
argument_list|,
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
argument_list|,
name|numPrepend
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
name|numRects
operator|=
name|newNumRects
expr_stmt|;
block|}
comment|// update inner rectangle
if|if
condition|(
name|innerArea
operator|<
name|r
operator|->
name|innerArea
condition|)
block|{
name|innerArea
operator|=
name|r
operator|->
name|innerArea
expr_stmt|;
name|innerRect
operator|=
name|r
operator|->
name|innerRect
expr_stmt|;
block|}
comment|// update extents
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|->
name|extents
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|extents
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|->
name|extents
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|r
operator|->
name|extents
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|r
operator|->
name|extents
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|prepend
name|void
name|QRegionPrivate
operator|::
name|prepend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|r
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QRect
modifier|*
name|myFirst
init|=
operator|(
name|numRects
operator|==
literal|1
condition|?
operator|&
name|extents
else|:
name|rects
operator|.
name|data
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromLeft
argument_list|(
name|myFirst
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|numRects
operator|>
literal|1
condition|)
block|{
specifier|const
name|QRect
modifier|*
name|nextToFirst
init|=
operator|(
name|numRects
operator|>
literal|2
condition|?
name|myFirst
operator|+
literal|2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mergeFromAbove
argument_list|(
name|myFirst
operator|+
literal|1
argument_list|,
name|myFirst
argument_list|,
name|nextToFirst
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|--
name|numRects
expr_stmt|;
name|memmove
argument_list|(
name|rects
operator|.
name|data
argument_list|()
argument_list|,
name|rects
operator|.
name|constData
argument_list|()
operator|+
literal|1
argument_list|,
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|QRect
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mergeFromAbove
argument_list|(
name|myFirst
argument_list|,
name|r
argument_list|,
operator|(
name|numRects
operator|>
literal|1
condition|?
name|myFirst
operator|+
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// nothing
block|}
else|else
block|{
name|vectorize
argument_list|()
expr_stmt|;
operator|++
name|numRects
expr_stmt|;
name|updateInnerRect
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
name|rects
operator|.
name|prepend
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
block|}
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|->
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|extents
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|->
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|r
operator|->
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|canAppend
name|bool
name|QRegionPrivate
operator|::
name|canAppend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|r
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|myLast
init|=
operator|(
name|numRects
operator|==
literal|1
operator|)
condition|?
operator|&
name|extents
else|:
operator|(
name|rects
operator|.
name|constData
argument_list|()
operator|+
operator|(
name|numRects
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|top
argument_list|()
operator|>
name|myLast
operator|->
name|bottom
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|r
operator|->
name|top
argument_list|()
operator|==
name|myLast
operator|->
name|top
argument_list|()
operator|&&
name|r
operator|->
name|height
argument_list|()
operator|==
name|myLast
operator|->
name|height
argument_list|()
operator|&&
name|r
operator|->
name|left
argument_list|()
operator|>
name|myLast
operator|->
name|right
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canAppend
name|bool
name|QRegionPrivate
operator|::
name|canAppend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
block|{
return|return
name|canAppend
argument_list|(
name|r
operator|->
name|numRects
operator|==
literal|1
condition|?
operator|&
name|r
operator|->
name|extents
else|:
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|canPrepend
name|bool
name|QRegionPrivate
operator|::
name|canPrepend
parameter_list|(
specifier|const
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|r
operator|->
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|*
name|myFirst
init|=
operator|(
name|numRects
operator|==
literal|1
operator|)
condition|?
operator|&
name|extents
else|:
name|rects
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|bottom
argument_list|()
operator|<
name|myFirst
operator|->
name|top
argument_list|()
condition|)
comment|// not overlapping
return|return
literal|true
return|;
if|if
condition|(
name|r
operator|->
name|top
argument_list|()
operator|==
name|myFirst
operator|->
name|top
argument_list|()
operator|&&
name|r
operator|->
name|height
argument_list|()
operator|==
name|myFirst
operator|->
name|height
argument_list|()
operator|&&
name|r
operator|->
name|right
argument_list|()
operator|<
name|myFirst
operator|->
name|left
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canPrepend
name|bool
name|QRegionPrivate
operator|::
name|canPrepend
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r
parameter_list|)
specifier|const
block|{
return|return
name|canPrepend
argument_list|(
name|r
operator|->
name|numRects
operator|==
literal|1
condition|?
operator|&
name|r
operator|->
name|extents
else|:
name|r
operator|->
name|rects
operator|.
name|constData
argument_list|()
operator|+
name|r
operator|->
name|numRects
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
end_ifdef
begin_function
DECL|function|selfTest
name|void
name|QRegionPrivate
operator|::
name|selfTest
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|numRects
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|extents
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|innerRect
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|innerArea
operator|==
operator|(
name|innerRect
operator|.
name|width
argument_list|()
operator|*
name|innerRect
operator|.
name|height
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numRects
operator|==
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|innerRect
operator|==
name|extents
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|innerRect
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|.
name|width
argument_list|()
operator|*
name|r
operator|.
name|height
argument_list|()
operator|)
operator|>
name|innerArea
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"selfTest(): innerRect"
operator|<<
name|innerRect
operator|<<
literal|'<'
operator|<<
name|r
expr_stmt|;
block|}
name|QRect
name|r
init|=
name|rects
operator|.
name|first
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numRects
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
name|r2
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|r2
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|.
name|y
argument_list|()
operator|==
name|r
operator|.
name|y
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|r
operator|.
name|bottom
argument_list|()
operator|==
name|r2
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|r
operator|.
name|right
argument_list|()
operator|<
operator|(
name|r2
operator|.
name|left
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|r2
operator|.
name|y
argument_list|()
operator|>=
name|r
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|r2
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_REGION_DEBUG
end_comment
begin_decl_stmt
DECL|variable|qrp
specifier|static
name|QRegionPrivate
name|qrp
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|shared_empty
specifier|const
name|QRegion
operator|::
name|QRegionData
name|QRegion
operator|::
name|shared_empty
init|=
block|{
name|Q_REFCOUNT_INITIALIZE_STATIC
block|,
operator|&
name|qrp
block|}
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|OverlapFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|OverlapFunc
function_decl|)
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|NonOverlapFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|NonOverlapFunc
function_decl|)
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
specifier|static
name|bool
name|EqualRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|r2
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|UnionRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|miRegionOp
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|OverlapFunc
name|overlapFunc
parameter_list|,
name|NonOverlapFunc
name|nonOverlap1Func
parameter_list|,
name|NonOverlapFunc
name|nonOverlap2Func
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|RectangleOut
define|#
directive|define
name|RectangleOut
value|0
end_define
begin_define
DECL|macro|RectangleIn
define|#
directive|define
name|RectangleIn
value|1
end_define
begin_define
DECL|macro|RectanglePart
define|#
directive|define
name|RectanglePart
value|2
end_define
begin_define
DECL|macro|EvenOddRule
define|#
directive|define
name|EvenOddRule
value|0
end_define
begin_define
DECL|macro|WindingRule
define|#
directive|define
name|WindingRule
value|1
end_define
begin_comment
comment|// START OF region.h extract
end_comment
begin_comment
comment|/* $XConsortium: region.h,v 11.14 94/04/17 20:22:20 rws Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_XREGION_H
end_ifndef
begin_define
DECL|macro|_XREGION_H
define|#
directive|define
name|_XREGION_H
end_define
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<limits.h>
name|QT_END_INCLUDE_NAMESPACE
comment|/*  1 if two BOXes overlap.  *  0 if two BOXes do not overlap.  *  Remember, x2 and y2 are not in the region  */
DECL|macro|EXTENTCHECK
define|#
directive|define
name|EXTENTCHECK
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
define|\
value|((r1)->right()>= (r2)->left()&& \          (r1)->left()<= (r2)->right()&& \          (r1)->bottom()>= (r2)->top()&& \          (r1)->top()<= (r2)->bottom())
comment|/*  *  update region extents  */
DECL|macro|EXTENTS
define|#
directive|define
name|EXTENTS
parameter_list|(
name|r
parameter_list|,
name|idRect
parameter_list|)
value|{\             if((r)->left()< (idRect)->extents.left())\               (idRect)->extents.setLeft((r)->left());\             if((r)->top()< (idRect)->extents.top())\               (idRect)->extents.setTop((r)->top());\             if((r)->right()> (idRect)->extents.right())\               (idRect)->extents.setRight((r)->right());\             if((r)->bottom()> (idRect)->extents.bottom())\               (idRect)->extents.setBottom((r)->bottom());\         }
comment|/*  *   Check to see if there is enough memory in the present region.  */
DECL|macro|MEMCHECK
define|#
directive|define
name|MEMCHECK
parameter_list|(
name|dest
parameter_list|,
name|rect
parameter_list|,
name|firstrect
parameter_list|)
value|{\         if ((dest).numRects>= ((dest).rects.size()-1)){\           firstrect.resize(firstrect.size() * 2); \           (rect) = (firstrect).data() + (dest).numRects;\         }\       }
comment|/*  * number of points to buffer before sending them off  * to scanlines(): Must be an even number  */
DECL|macro|NUMPTSTOBUFFER
define|#
directive|define
name|NUMPTSTOBUFFER
value|200
comment|/*  * used to allocate buffers for points and link  * the buffers together  */
decl|typedef struct
DECL|struct|_POINTBLOCK
name|_POINTBLOCK
argument_list|{
DECL|member|data
name|char
name|data
index|[
name|NUMPTSTOBUFFER
operator|*
sizeof|sizeof
argument_list|(
name|QPoint
argument_list|)
index|]
argument_list|;
DECL|member|pts
name|QPoint
operator|*
name|pts
argument_list|;
DECL|member|next
expr|struct
name|_POINTBLOCK
operator|*
name|next
argument_list|; }
DECL|typedef|POINTBLOCK
name|POINTBLOCK
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// END OF region.h extract
end_comment
begin_comment
comment|// START OF Region.c extract
end_comment
begin_comment
comment|/* $XConsortium: Region.c /main/30 1996/10/22 14:21:24 kaleb $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987, 1988  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/*  * The functions in this file implement the Region abstraction, similar to one  * used in the X11 sample server. A Region is simply an area, as the name  * implies, and is implemented as a "y-x-banded" array of rectangles. To  * explain: Each Region is made up of a certain number of rectangles sorted  * by y coordinate first, and then by x coordinate.  *  * Furthermore, the rectangles are banded such that every rectangle with a  * given upper-left y coordinate (y1) will have the same lower-right y  * coordinate (y2) and vice versa. If a rectangle has scanlines in a band, it  * will span the entire vertical distance of the band. This means that some  * areas that could be merged into a taller rectangle will be represented as  * several shorter rectangles to account for shorter rectangles to its left  * or right but within its "vertical scope".  *  * An added constraint on the rectangles is that they must cover as much  * horizontal area as possible. E.g. no two rectangles in a band are allowed  * to touch.  *  * Whenever possible, bands will be merged together to cover a greater vertical  * distance (and thus reduce the number of rectangles). Two bands can be merged  * only if the bottom of one touches the top of the other and they have  * rectangles in the same places (of the same width, of course). This maintains  * the y-x-banding that's so nice to have...  */
end_comment
begin_comment
comment|/* $XFree86: xc/lib/X11/Region.c,v 1.1.1.2.2.2 1998/10/04 15:22:50 hohndel Exp $ */
end_comment
begin_function
DECL|function|UnionRectWithRegion
specifier|static
name|void
name|UnionRectWithRegion
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rect
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|source
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|EqualRegion
argument_list|(
name|source
argument_list|,
operator|&
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|QRegionPrivate
argument_list|(
operator|*
name|rect
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|.
name|canAppend
argument_list|(
name|rect
argument_list|)
condition|)
block|{
name|dest
operator|.
name|append
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRegionPrivate
name|p
argument_list|(
operator|*
name|rect
argument_list|)
decl_stmt|;
name|UnionRegion
argument_list|(
operator|&
name|p
argument_list|,
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSetExtents --  *      Reset the extents and innerRect of a region to what they should be.  *      Called by miSubtract and miIntersect b/c they can't figure it out  *      along the way or do so easily, as miUnion can.  *  * Results:  *      None.  *  * Side Effects:  *      The region's 'extents' and 'innerRect' structure is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSetExtents
specifier|static
name|void
name|miSetExtents
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
specifier|const
name|QRect
modifier|*
name|pBox
decl_stmt|,
modifier|*
name|pBoxEnd
decl_stmt|;
name|QRect
modifier|*
name|pExtents
decl_stmt|;
name|dest
operator|.
name|innerRect
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dest
operator|.
name|innerArea
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|==
literal|0
condition|)
block|{
name|dest
operator|.
name|extents
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|pExtents
operator|=
operator|&
name|dest
operator|.
name|extents
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|rects
operator|.
name|isEmpty
argument_list|()
condition|)
name|pBox
operator|=
operator|&
name|dest
operator|.
name|extents
expr_stmt|;
else|else
name|pBox
operator|=
name|dest
operator|.
name|rects
operator|.
name|constData
argument_list|()
expr_stmt|;
name|pBoxEnd
operator|=
name|pBox
operator|+
name|dest
operator|.
name|numRects
operator|-
literal|1
expr_stmt|;
comment|/*      * Since pBox is the first rectangle in the region, it must have the      * smallest y1 and since pBoxEnd is the last rectangle in the region,      * it must have the largest y2, because of banding. Initialize x1 and      * x2 from  pBox and pBoxEnd, resp., as good things to initialize them      * to...      */
name|pExtents
operator|->
name|setLeft
argument_list|(
name|pBox
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setTop
argument_list|(
name|pBox
operator|->
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setRight
argument_list|(
name|pBoxEnd
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|pExtents
operator|->
name|setBottom
argument_list|(
name|pBoxEnd
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|pExtents
operator|->
name|top
argument_list|()
operator|<=
name|pExtents
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|pBox
operator|<=
name|pBoxEnd
condition|)
block|{
if|if
condition|(
name|pBox
operator|->
name|left
argument_list|()
operator|<
name|pExtents
operator|->
name|left
argument_list|()
condition|)
name|pExtents
operator|->
name|setLeft
argument_list|(
name|pBox
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBox
operator|->
name|right
argument_list|()
operator|>
name|pExtents
operator|->
name|right
argument_list|()
condition|)
name|pExtents
operator|->
name|setRight
argument_list|(
name|pBox
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pBox
argument_list|)
expr_stmt|;
operator|++
name|pBox
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|pExtents
operator|->
name|left
argument_list|()
operator|<=
name|pExtents
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* TranslateRegion(pRegion, x, y)    translates in place    added by raymond */
end_comment
begin_function
DECL|function|OffsetRegion
specifier|static
name|void
name|OffsetRegion
parameter_list|(
name|QRegionPrivate
modifier|&
name|region
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|region
operator|.
name|rects
operator|.
name|size
argument_list|()
condition|)
block|{
name|QRect
modifier|*
name|pbox
init|=
name|region
operator|.
name|rects
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|nbox
init|=
name|region
operator|.
name|numRects
decl_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|pbox
operator|->
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|++
name|pbox
expr_stmt|;
block|}
block|}
name|region
operator|.
name|extents
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|region
operator|.
name|innerRect
operator|.
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *          Region Intersection  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miIntersectO --  *      Handle an overlapping band for miIntersect.  *  * Results:  *      None.  *  * Side Effects:  *      Rectangles may be added to the region.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miIntersectO
specifier|static
name|void
name|miIntersectO
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|int
name|x1
decl_stmt|;
name|int
name|x2
decl_stmt|;
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
name|x1
operator|=
name|qMax
argument_list|(
name|r1
operator|->
name|left
argument_list|()
argument_list|,
name|r2
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|x2
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|r2
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * If there's any overlap between the two rectangles, add that          * overlap to the new region.          * There's no need to check for subsumption because the only way          * such a need could arise is if some region has two rectangles          * right next to each other. Since that should never happen...          */
if|if
condition|(
name|x1
operator|<=
name|x2
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
block|}
comment|/*          * Need to advance the pointers. Shift the one that extends          * to the right the least, since the other still has a chance to          * overlap with that region's next rectangle, if you see what I mean.          */
if|if
condition|(
name|r1
operator|->
name|right
argument_list|()
operator|<
name|r2
operator|->
name|right
argument_list|()
condition|)
block|{
operator|++
name|r1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|right
argument_list|()
operator|<
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
operator|++
name|r2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|r1
expr_stmt|;
operator|++
name|r2
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*======================================================================  *          Generic Region Operator  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miCoalesce --  *      Attempt to merge the boxes in the current band with those in the  *      previous one. Used only by miRegionOp.  *  * Results:  *      The new index for the previous band.  *  * Side Effects:  *      If coalescing takes place:  *          - rectangles in the previous band will have their y2 fields  *            altered.  *          - dest.numRects will be decreased.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miCoalesce
specifier|static
name|int
name|miCoalesce
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
name|int
name|prevStart
parameter_list|,
name|int
name|curStart
parameter_list|)
block|{
name|QRect
modifier|*
name|pPrevBox
decl_stmt|;
comment|/* Current box in previous band */
name|QRect
modifier|*
name|pCurBox
decl_stmt|;
comment|/* Current box in current band */
name|QRect
modifier|*
name|pRegEnd
decl_stmt|;
comment|/* End of region */
name|int
name|curNumRects
decl_stmt|;
comment|/* Number of rectangles in current band */
name|int
name|prevNumRects
decl_stmt|;
comment|/* Number of rectangles in previous band */
name|int
name|bandY1
decl_stmt|;
comment|/* Y1 coordinate for current band */
name|QRect
modifier|*
name|rData
init|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
decl_stmt|;
name|pRegEnd
operator|=
name|rData
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|pPrevBox
operator|=
name|rData
operator|+
name|prevStart
expr_stmt|;
name|prevNumRects
operator|=
name|curStart
operator|-
name|prevStart
expr_stmt|;
comment|/*      * Figure out how many rectangles are in the current band. Have to do      * this because multiple bands could have been added in miRegionOp      * at the end when one region has been exhausted.      */
name|pCurBox
operator|=
name|rData
operator|+
name|curStart
expr_stmt|;
name|bandY1
operator|=
name|pCurBox
operator|->
name|top
argument_list|()
expr_stmt|;
for|for
control|(
name|curNumRects
operator|=
literal|0
init|;
name|pCurBox
operator|!=
name|pRegEnd
operator|&&
name|pCurBox
operator|->
name|top
argument_list|()
operator|==
name|bandY1
condition|;
operator|++
name|curNumRects
control|)
block|{
operator|++
name|pCurBox
expr_stmt|;
block|}
if|if
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
block|{
comment|/*          * If more than one band was added, we have to find the start          * of the last band added so the next coalescing job can start          * at the right place... (given when multiple bands are added,          * this may be pointless -- see above).          */
operator|--
name|pRegEnd
expr_stmt|;
while|while
condition|(
operator|(
name|pRegEnd
operator|-
literal|1
operator|)
operator|->
name|top
argument_list|()
operator|==
name|pRegEnd
operator|->
name|top
argument_list|()
condition|)
operator|--
name|pRegEnd
expr_stmt|;
name|curStart
operator|=
name|pRegEnd
operator|-
name|rData
expr_stmt|;
name|pRegEnd
operator|=
name|rData
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
block|}
if|if
condition|(
name|curNumRects
operator|==
name|prevNumRects
operator|&&
name|curNumRects
operator|!=
literal|0
condition|)
block|{
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/*          * The bands may only be coalesced if the bottom of the previous          * matches the top scanline of the current.          */
if|if
condition|(
name|pPrevBox
operator|->
name|bottom
argument_list|()
operator|==
name|pCurBox
operator|->
name|top
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|/*              * Make sure the bands have boxes in the same places. This              * assumes that boxes have been added in such a way that they              * cover the most area possible. I.e. two boxes in a band must              * have some horizontal space between them.              */
do|do
block|{
if|if
condition|(
name|pPrevBox
operator|->
name|left
argument_list|()
operator|!=
name|pCurBox
operator|->
name|left
argument_list|()
operator|||
name|pPrevBox
operator|->
name|right
argument_list|()
operator|!=
name|pCurBox
operator|->
name|right
argument_list|()
condition|)
block|{
comment|// The bands don't line up so they can't be coalesced.
return|return
name|curStart
return|;
block|}
operator|++
name|pPrevBox
expr_stmt|;
operator|++
name|pCurBox
expr_stmt|;
operator|--
name|prevNumRects
expr_stmt|;
block|}
do|while
condition|(
name|prevNumRects
operator|!=
literal|0
condition|)
do|;
name|dest
operator|.
name|numRects
operator|-=
name|curNumRects
expr_stmt|;
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
name|pPrevBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/*              * The bands may be merged, so set the bottom y of each box              * in the previous band to that of the corresponding box in              * the current band.              */
do|do
block|{
name|pPrevBox
operator|->
name|setBottom
argument_list|(
name|pCurBox
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pPrevBox
argument_list|)
expr_stmt|;
operator|++
name|pPrevBox
expr_stmt|;
operator|++
name|pCurBox
expr_stmt|;
name|curNumRects
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|curNumRects
operator|!=
literal|0
condition|)
do|;
comment|/*              * If only one band was added to the region, we have to backup              * curStart to the start of the previous band.              *              * If more than one band was added to the region, copy the              * other bands down. The assumption here is that the other bands              * came from the same region as the current one and no further              * coalescing can be done on them since it's all been done              * already... curStart is already in the right place.              */
if|if
condition|(
name|pCurBox
operator|==
name|pRegEnd
condition|)
block|{
name|curStart
operator|=
name|prevStart
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
operator|*
name|pPrevBox
operator|++
operator|=
operator|*
name|pCurBox
operator|++
expr_stmt|;
name|dest
operator|.
name|updateInnerRect
argument_list|(
operator|*
name|pPrevBox
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
do|;
block|}
block|}
block|}
return|return
name|curStart
return|;
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miRegionOp --  *      Apply an operation to two regions. Called by miUnion, miInverse,  *      miSubtract, miIntersect...  *  * Results:  *      None.  *  * Side Effects:  *      The new region is overwritten.  *  * Notes:  *      The idea behind this function is to view the two regions as sets.  *      Together they cover a rectangle of area that this function divides  *      into horizontal bands where points are covered only by one region  *      or by both. For the first case, the nonOverlapFunc is called with  *      each the band and the band's upper and lower extents. For the  *      second, the overlapFunc is called to process the entire band. It  *      is responsible for clipping the rectangles in the band, though  *      this function provides the boundaries.  *      At the end of each band, the new region is coalesced, if possible,  *      to reduce the number of rectangles in the region.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miRegionOp
specifier|static
name|void
name|miRegionOp
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|OverlapFunc
name|overlapFunc
parameter_list|,
name|NonOverlapFunc
name|nonOverlap1Func
parameter_list|,
name|NonOverlapFunc
name|nonOverlap2Func
parameter_list|)
block|{
specifier|const
name|QRect
modifier|*
name|r1
decl_stmt|;
comment|// Pointer into first region
specifier|const
name|QRect
modifier|*
name|r2
decl_stmt|;
comment|// Pointer into 2d region
specifier|const
name|QRect
modifier|*
name|r1End
decl_stmt|;
comment|// End of 1st region
specifier|const
name|QRect
modifier|*
name|r2End
decl_stmt|;
comment|// End of 2d region
name|int
name|ybot
decl_stmt|;
comment|// Bottom of intersection
name|int
name|ytop
decl_stmt|;
comment|// Top of intersection
name|int
name|prevBand
decl_stmt|;
comment|// Index of start of previous band in dest
name|int
name|curBand
decl_stmt|;
comment|// Index of start of current band in dest
specifier|const
name|QRect
modifier|*
name|r1BandEnd
decl_stmt|;
comment|// End of current band in r1
specifier|const
name|QRect
modifier|*
name|r2BandEnd
decl_stmt|;
comment|// End of current band in r2
name|int
name|top
decl_stmt|;
comment|// Top of non-overlapping band
name|int
name|bot
decl_stmt|;
comment|// Bottom of non-overlapping band
comment|/*      * Initialization:      *  set r1, r2, r1End and r2End appropriately, preserve the important      * parts of the destination region until the end in case it's one of      * the two source regions, then mark the "new" region empty, allocating      * another array of rectangles for it to use.      */
if|if
condition|(
name|reg1
operator|->
name|numRects
operator|==
literal|1
condition|)
name|r1
operator|=
operator|&
name|reg1
operator|->
name|extents
expr_stmt|;
else|else
name|r1
operator|=
name|reg1
operator|->
name|rects
operator|.
name|constData
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg2
operator|->
name|numRects
operator|==
literal|1
condition|)
name|r2
operator|=
operator|&
name|reg2
operator|->
name|extents
expr_stmt|;
else|else
name|r2
operator|=
name|reg2
operator|->
name|rects
operator|.
name|constData
argument_list|()
expr_stmt|;
name|r1End
operator|=
name|r1
operator|+
name|reg1
operator|->
name|numRects
expr_stmt|;
name|r2End
operator|=
name|r2
operator|+
name|reg2
operator|->
name|numRects
expr_stmt|;
name|dest
operator|.
name|vectorize
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|oldRects
init|=
name|dest
operator|.
name|rects
decl_stmt|;
name|dest
operator|.
name|numRects
operator|=
literal|0
expr_stmt|;
comment|/*      * Allocate a reasonable number of rectangles for the new region. The idea      * is to allocate enough so the individual functions don't need to      * reallocate and copy the array, which is time consuming, yet we don't      * have to worry about using too much memory. I hope to be able to      * nuke the realloc() at the end of this function eventually.      */
name|dest
operator|.
name|rects
operator|.
name|resize
argument_list|(
name|qMax
argument_list|(
name|reg1
operator|->
name|numRects
argument_list|,
name|reg2
operator|->
name|numRects
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Initialize ybot and ytop.      * In the upcoming loop, ybot and ytop serve different functions depending      * on whether the band being handled is an overlapping or non-overlapping      * band.      *  In the case of a non-overlapping band (only one of the regions      * has points in the band), ybot is the bottom of the most recent      * intersection and thus clips the top of the rectangles in that band.      * ytop is the top of the next intersection between the two regions and      * serves to clip the bottom of the rectangles in the current band.      *  For an overlapping band (where the two regions intersect), ytop clips      * the top of the rectangles of both regions and ybot clips the bottoms.      */
if|if
condition|(
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|<
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
condition|)
name|ybot
operator|=
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|-
literal|1
expr_stmt|;
else|else
name|ybot
operator|=
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/*      * prevBand serves to mark the start of the previous band so rectangles      * can be coalesced into larger rectangles. qv. miCoalesce, above.      * In the beginning, there is no previous band, so prevBand == curBand      * (curBand is set later on, of course, but the first band will always      * start at index 0). prevBand and curBand must be indices because of      * the possible expansion, and resultant moving, of the new region's      * array of rectangles.      */
name|prevBand
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
comment|/*          * This algorithm proceeds one source-band (as opposed to a          * destination band, which is determined by where the two regions          * intersect) at a time. r1BandEnd and r2BandEnd serve to mark the          * rectangle after the last one in the current band for their          * respective regions.          */
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
name|r1BandEnd
operator|!=
name|r1End
operator|&&
name|r1BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r1
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r1BandEnd
expr_stmt|;
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
name|r2BandEnd
operator|!=
name|r2End
operator|&&
name|r2BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r2
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r2BandEnd
expr_stmt|;
comment|/*          * First handle the band that doesn't intersect, if any.          *          * Note that attention is restricted to one band in the          * non-intersecting region at once, so if a region has n          * bands between the current position and the next place it overlaps          * the other, this entire loop will be passed through n times.          */
if|if
condition|(
name|r1
operator|->
name|top
argument_list|()
operator|<
name|r2
operator|->
name|top
argument_list|()
condition|)
block|{
name|top
operator|=
name|qMax
argument_list|(
name|r1
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|bottom
argument_list|()
argument_list|,
name|r2
operator|->
name|top
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonOverlap1Func
operator|!=
literal|0
operator|&&
name|bot
operator|>=
name|top
condition|)
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|ytop
operator|=
name|r2
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|top
argument_list|()
operator|<
name|r1
operator|->
name|top
argument_list|()
condition|)
block|{
name|top
operator|=
name|qMax
argument_list|(
name|r2
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|=
name|qMin
argument_list|(
name|r2
operator|->
name|bottom
argument_list|()
argument_list|,
name|r1
operator|->
name|top
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonOverlap2Func
operator|!=
literal|0
operator|&&
name|bot
operator|>=
name|top
condition|)
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|dest
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|ytop
operator|=
name|r1
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ytop
operator|=
name|r1
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
comment|/*          * If any rectangles got added to the region, try and coalesce them          * with rectangles from the previous band. Note we could just do          * this test in miCoalesce, but some machines incur a not          * inconsiderable cost for function calls, so...          */
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*          * Now see if we've hit an intersecting band. The two bands only          * intersect if ybot>= ytop          */
name|ybot
operator|=
name|qMin
argument_list|(
name|r1
operator|->
name|bottom
argument_list|()
argument_list|,
name|r2
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
if|if
condition|(
name|ybot
operator|>=
name|ytop
condition|)
call|(
modifier|*
name|overlapFunc
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|ytop
argument_list|,
name|ybot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*          * If we've finished with a band (y2 == ybot) we skip forward          * in the region to the next band.          */
if|if
condition|(
name|r1
operator|->
name|bottom
argument_list|()
operator|==
name|ybot
condition|)
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
if|if
condition|(
name|r2
operator|->
name|bottom
argument_list|()
operator|==
name|ybot
condition|)
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
do|;
comment|/*      * Deal with whichever region still has rectangles left.      */
name|curBand
operator|=
name|dest
operator|.
name|numRects
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
if|if
condition|(
name|nonOverlap1Func
operator|!=
literal|0
condition|)
block|{
do|do
block|{
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
name|r1BandEnd
operator|<
name|r1End
operator|&&
name|r1BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r1
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r1BandEnd
expr_stmt|;
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|dest
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|qMax
argument_list|(
name|r1
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
argument_list|,
name|r1
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|r2
operator|!=
name|r2End
operator|)
operator|&&
operator|(
name|nonOverlap2Func
operator|!=
literal|0
operator|)
condition|)
block|{
do|do
block|{
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
name|r2BandEnd
operator|<
name|r2End
operator|&&
name|r2BandEnd
operator|->
name|top
argument_list|()
operator|==
name|r2
operator|->
name|top
argument_list|()
condition|)
operator|++
name|r2BandEnd
expr_stmt|;
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|dest
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|qMax
argument_list|(
name|r2
operator|->
name|top
argument_list|()
argument_list|,
name|ybot
operator|+
literal|1
argument_list|)
argument_list|,
name|r2
operator|->
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
do|;
block|}
if|if
condition|(
name|dest
operator|.
name|numRects
operator|!=
name|curBand
condition|)
operator|(
name|void
operator|)
name|miCoalesce
argument_list|(
name|dest
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
comment|/*      * A bit of cleanup. To keep regions from growing without bound,      * we shrink the array of rectangles to match the new number of      * rectangles in the region.      *      * Only do this stuff if the number of rectangles allocated is more than      * twice the number of rectangles in the region (a simple optimization).      */
if|if
condition|(
name|qMax
argument_list|(
literal|4
argument_list|,
name|dest
operator|.
name|numRects
argument_list|)
operator|<
operator|(
name|dest
operator|.
name|rects
operator|.
name|size
argument_list|()
operator|>>
literal|1
operator|)
condition|)
name|dest
operator|.
name|rects
operator|.
name|resize
argument_list|(
name|dest
operator|.
name|numRects
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *          Region Union  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionNonO --  *      Handle a non-overlapping band for the union operation. Just  *      Adds the rectangles into the region. Doesn't have to check for  *      subsumption or anything.  *  * Results:  *      None.  *  * Side Effects:  *      dest.numRects is incremented and the final rectangles overwritten  *      with the rectangles we're passed.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miUnionNonO
specifier|static
name|void
name|miUnionNonO
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|left
argument_list|()
operator|<=
name|r
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|r
operator|->
name|left
argument_list|()
argument_list|,
name|y1
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|dest
operator|.
name|numRects
operator|++
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionO --  *      Handle an overlapping band for the union operation. Picks the  *      left-most rectangle each time and merges it into the region.  *  * Results:  *      None.  *  * Side Effects:  *      Rectangles are overwritten in dest.rects and dest.numRects will  *      be changed.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miUnionO
specifier|static
name|void
name|miUnionO
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
DECL|macro|MERGERECT
define|#
directive|define
name|MERGERECT
parameter_list|(
name|r
parameter_list|)
define|\
value|if ((dest.numRects != 0)&&  \         (pNextRect[-1].top() == y1)&&  \         (pNextRect[-1].bottom() == y2)&&  \         (pNextRect[-1].right()>= r->left()-1)) { \         if (pNextRect[-1].right()< r->right()) { \             pNextRect[-1].setRight(r->right());  \             dest.updateInnerRect(pNextRect[-1]); \             Q_ASSERT(pNextRect[-1].left()<= pNextRect[-1].right()); \         }  \     } else { \         MEMCHECK(dest, pNextRect, dest.rects)  \         pNextRect->setCoords(r->left(), y1, r->right(), y2); \         dest.updateInnerRect(*pNextRect); \         dest.numRects++;  \         pNextRect++;  \     }  \     r++;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|left
argument_list|()
operator|<
name|r2
operator|->
name|left
argument_list|()
condition|)
block|{
name|MERGERECT
argument_list|(
argument|r1
argument_list|)
block|}
else|else
block|{
name|MERGERECT
argument_list|(
argument|r2
argument_list|)
block|}
block|}
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
do|do
block|{
name|MERGERECT
argument_list|(
argument|r1
argument_list|)
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
block|{
name|MERGERECT
argument_list|(
argument|r2
argument_list|)
block|}
block|}
block|}
end_function
begin_function
DECL|function|UnionRegion
specifier|static
name|void
name|UnionRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|reg1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|reg2
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|reg1
argument_list|)
operator|&&
operator|!
name|isEmptyHelper
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg1
operator|->
name|contains
argument_list|(
operator|*
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg2
operator|->
name|contains
argument_list|(
operator|*
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg1
operator|->
name|canAppend
argument_list|(
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|reg2
operator|->
name|canAppend
argument_list|(
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg1
operator|->
name|innerArea
operator|>
name|reg2
operator|->
name|innerArea
condition|)
block|{
name|dest
operator|.
name|innerArea
operator|=
name|reg1
operator|->
name|innerArea
expr_stmt|;
name|dest
operator|.
name|innerRect
operator|=
name|reg1
operator|->
name|innerRect
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|.
name|innerArea
operator|=
name|reg2
operator|->
name|innerArea
expr_stmt|;
name|dest
operator|.
name|innerRect
operator|=
name|reg2
operator|->
name|innerRect
expr_stmt|;
block|}
name|miRegionOp
argument_list|(
name|dest
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|,
name|miUnionO
argument_list|,
name|miUnionNonO
argument_list|,
name|miUnionNonO
argument_list|)
expr_stmt|;
name|dest
operator|.
name|extents
operator|.
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|left
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|top
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|right
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|bottom
argument_list|()
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*======================================================================  *        Region Subtraction  *====================================================================*/
end_comment
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractNonO --  *      Deal with non-overlapping band for subtraction. Any parts from  *      region 2 we discard. Anything from region 1 we add to the region.  *  * Results:  *      None.  *  * Side Effects:  *      dest may be affected.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSubtractNonO1
specifier|static
name|void
name|miSubtractNonO1
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r
parameter_list|,
specifier|const
name|QRect
modifier|*
name|rEnd
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|left
argument_list|()
operator|<=
name|r
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|r
operator|->
name|left
argument_list|()
argument_list|,
name|y1
argument_list|,
name|r
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractO --  *      Overlapping band subtraction. x1 is the left-most point not yet  *      checked.  *  * Results:  *      None.  *  * Side Effects:  *      dest may have rectangles added to it.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|miSubtractO
specifier|static
name|void
name|miSubtractO
parameter_list|(
name|QRegionPrivate
modifier|&
name|dest
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r1End
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2
parameter_list|,
specifier|const
name|QRect
modifier|*
name|r2End
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|y2
parameter_list|)
block|{
name|QRect
modifier|*
name|pNextRect
decl_stmt|;
name|int
name|x1
decl_stmt|;
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|y1
operator|<=
name|y2
argument_list|)
expr_stmt|;
name|pNextRect
operator|=
name|dest
operator|.
name|rects
operator|.
name|data
argument_list|()
operator|+
name|dest
operator|.
name|numRects
expr_stmt|;
while|while
condition|(
name|r1
operator|!=
name|r1End
operator|&&
name|r2
operator|!=
name|r2End
condition|)
block|{
if|if
condition|(
name|r2
operator|->
name|right
argument_list|()
operator|<
name|x1
condition|)
block|{
comment|/*              * Subtrahend missed the boat: go to next subtrahend.              */
operator|++
name|r2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|left
argument_list|()
operator|<=
name|x1
condition|)
block|{
comment|/*              * Subtrahend precedes minuend: nuke left edge of minuend.              */
name|x1
operator|=
name|r2
operator|->
name|right
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*                  * Minuend completely covered: advance to next minuend and                  * reset left fence to edge of new minuend.                  */
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Subtrahend now used up since it doesn't extend beyond minuend
operator|++
name|r2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|left
argument_list|()
operator|<=
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*              * Left part of subtrahend covers part of minuend: add uncovered              * part of minuend to region and skip to next subtrahend.              */
name|Q_ASSERT
argument_list|(
name|x1
operator|<
name|r2
operator|->
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r2
operator|->
name|left
argument_list|()
operator|-
literal|1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
name|x1
operator|=
name|r2
operator|->
name|right
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|r1
operator|->
name|right
argument_list|()
condition|)
block|{
comment|/*                  * Minuend used up: advance to new...                  */
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Subtrahend used up
operator|++
name|r2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * Minuend used up: add any remaining piece before advancing.              */
if|if
condition|(
name|r1
operator|->
name|right
argument_list|()
operator|>=
name|x1
condition|)
block|{
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
block|}
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      * Add remaining minuend rectangles to region.      */
while|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|x1
operator|<=
name|r1
operator|->
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
argument|dest
argument_list|,
argument|pNextRect
argument_list|,
argument|dest.rects
argument_list|)
name|pNextRect
operator|->
name|setCoords
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|r1
operator|->
name|right
argument_list|()
argument_list|,
name|y2
argument_list|)
expr_stmt|;
operator|++
name|dest
operator|.
name|numRects
expr_stmt|;
operator|++
name|pNextRect
expr_stmt|;
operator|++
name|r1
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|left
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtract --  *      Subtract regS from regM and leave the result in regD.  *      S stands for subtrahend, M for minuend and D for difference.  *  * Side Effects:  *      regD is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment
begin_function
DECL|function|SubtractRegion
specifier|static
name|void
name|SubtractRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|regM
parameter_list|,
name|QRegionPrivate
modifier|*
name|regS
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|regM
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|regS
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|EXTENTCHECK
argument_list|(
operator|&
name|regM
operator|->
name|extents
argument_list|,
operator|&
name|regS
operator|->
name|extents
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|regS
operator|->
name|contains
argument_list|(
operator|*
name|regM
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|regM
argument_list|,
name|regS
argument_list|)
argument_list|)
expr_stmt|;
name|miRegionOp
argument_list|(
name|dest
argument_list|,
name|regM
argument_list|,
name|regS
argument_list|,
name|miSubtractO
argument_list|,
name|miSubtractNonO1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Can't alter dest's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the unaltered. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|XorRegion
specifier|static
name|void
name|XorRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|sra
parameter_list|,
name|QRegionPrivate
modifier|*
name|srb
parameter_list|,
name|QRegionPrivate
modifier|&
name|dest
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|isEmptyHelper
argument_list|(
name|sra
argument_list|)
operator|&&
operator|!
name|isEmptyHelper
argument_list|(
name|srb
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|EXTENTCHECK
argument_list|(
operator|&
name|sra
operator|->
name|extents
argument_list|,
operator|&
name|srb
operator|->
name|extents
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|EqualRegion
argument_list|(
name|sra
argument_list|,
name|srb
argument_list|)
argument_list|)
expr_stmt|;
name|QRegionPrivate
name|tra
decl_stmt|,
name|trb
decl_stmt|;
if|if
condition|(
operator|!
name|srb
operator|->
name|contains
argument_list|(
operator|*
name|sra
argument_list|)
condition|)
name|SubtractRegion
argument_list|(
name|sra
argument_list|,
name|srb
argument_list|,
name|tra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sra
operator|->
name|contains
argument_list|(
operator|*
name|srb
argument_list|)
condition|)
name|SubtractRegion
argument_list|(
name|srb
argument_list|,
name|sra
argument_list|,
name|trb
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|isEmptyHelper
argument_list|(
operator|&
name|trb
argument_list|)
operator|||
operator|!
name|tra
operator|.
name|contains
argument_list|(
name|trb
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|isEmptyHelper
argument_list|(
operator|&
name|tra
argument_list|)
operator|||
operator|!
name|trb
operator|.
name|contains
argument_list|(
name|tra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
operator|&
name|tra
argument_list|)
condition|)
block|{
name|dest
operator|=
name|trb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isEmptyHelper
argument_list|(
operator|&
name|trb
argument_list|)
condition|)
block|{
name|dest
operator|=
name|tra
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tra
operator|.
name|canAppend
argument_list|(
operator|&
name|trb
argument_list|)
condition|)
block|{
name|dest
operator|=
name|tra
expr_stmt|;
name|dest
operator|.
name|append
argument_list|(
operator|&
name|trb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trb
operator|.
name|canAppend
argument_list|(
operator|&
name|tra
argument_list|)
condition|)
block|{
name|dest
operator|=
name|trb
expr_stmt|;
name|dest
operator|.
name|append
argument_list|(
operator|&
name|tra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnionRegion
argument_list|(
operator|&
name|tra
argument_list|,
operator|&
name|trb
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *      Check to see if two regions are equal  */
end_comment
begin_function
DECL|function|EqualRegion
specifier|static
name|bool
name|EqualRegion
parameter_list|(
specifier|const
name|QRegionPrivate
modifier|*
name|r1
parameter_list|,
specifier|const
name|QRegionPrivate
modifier|*
name|r2
parameter_list|)
block|{
if|if
condition|(
name|r1
operator|->
name|numRects
operator|!=
name|r2
operator|->
name|numRects
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|numRects
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|!=
name|r2
operator|->
name|extents
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|numRects
operator|==
literal|1
operator|&&
name|r2
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
return|return
literal|true
return|;
comment|// equality tested in previous if-statement
block|}
else|else
block|{
specifier|const
name|QRect
modifier|*
name|rr1
init|=
operator|(
name|r1
operator|->
name|numRects
operator|==
literal|1
operator|)
condition|?
operator|&
name|r1
operator|->
name|extents
else|:
name|r1
operator|->
name|rects
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|rr2
init|=
operator|(
name|r2
operator|->
name|numRects
operator|==
literal|1
operator|)
condition|?
operator|&
name|r2
operator|->
name|extents
else|:
name|r2
operator|->
name|rects
operator|.
name|constData
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r1
operator|->
name|numRects
condition|;
operator|++
name|i
operator|,
operator|++
name|rr1
operator|,
operator|++
name|rr2
control|)
block|{
if|if
condition|(
operator|*
name|rr1
operator|!=
operator|*
name|rr2
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|PointInRegion
specifier|static
name|bool
name|PointInRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|pRegion
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|pRegion
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|pRegion
operator|->
name|extents
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|pRegion
operator|->
name|numRects
operator|==
literal|1
condition|)
return|return
name|pRegion
operator|->
name|extents
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|pRegion
operator|->
name|innerRect
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pRegion
operator|->
name|numRects
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pRegion
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|RectInRegion
specifier|static
name|bool
name|RectInRegion
parameter_list|(
name|QRegionPrivate
modifier|*
name|region
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|ry
parameter_list|,
name|uint
name|rwidth
parameter_list|,
name|uint
name|rheight
parameter_list|)
block|{
specifier|const
name|QRect
modifier|*
name|pbox
decl_stmt|;
specifier|const
name|QRect
modifier|*
name|pboxEnd
decl_stmt|;
name|QRect
name|rect
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|,
name|rwidth
argument_list|,
name|rheight
argument_list|)
decl_stmt|;
name|QRect
modifier|*
name|prect
init|=
operator|&
name|rect
decl_stmt|;
name|int
name|partIn
decl_stmt|,
name|partOut
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|||
name|region
operator|->
name|numRects
operator|==
literal|0
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|region
operator|->
name|extents
argument_list|,
name|prect
argument_list|)
condition|)
return|return
name|RectangleOut
return|;
name|partOut
operator|=
literal|false
expr_stmt|;
name|partIn
operator|=
literal|false
expr_stmt|;
comment|/* can stop when both partOut and partIn are true, or we reach prect->y2 */
name|pbox
operator|=
operator|(
name|region
operator|->
name|numRects
operator|==
literal|1
operator|)
condition|?
operator|&
name|region
operator|->
name|extents
else|:
name|region
operator|->
name|rects
operator|.
name|constData
argument_list|()
expr_stmt|;
name|pboxEnd
operator|=
name|pbox
operator|+
name|region
operator|->
name|numRects
expr_stmt|;
for|for
control|(
init|;
name|pbox
operator|<
name|pboxEnd
condition|;
operator|++
name|pbox
control|)
block|{
if|if
condition|(
name|pbox
operator|->
name|bottom
argument_list|()
operator|<
name|ry
condition|)
continue|continue;
if|if
condition|(
name|pbox
operator|->
name|top
argument_list|()
operator|>
name|ry
condition|)
block|{
name|partOut
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|partIn
operator|||
name|pbox
operator|->
name|top
argument_list|()
operator|>
name|prect
operator|->
name|bottom
argument_list|()
condition|)
break|break;
name|ry
operator|=
name|pbox
operator|->
name|top
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pbox
operator|->
name|right
argument_list|()
operator|<
name|rx
condition|)
continue|continue;
comment|/* not far enough over yet */
if|if
condition|(
name|pbox
operator|->
name|left
argument_list|()
operator|>
name|rx
condition|)
block|{
name|partOut
operator|=
literal|true
expr_stmt|;
comment|/* missed part of rectangle to left */
if|if
condition|(
name|partIn
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|left
argument_list|()
operator|<=
name|prect
operator|->
name|right
argument_list|()
condition|)
block|{
name|partIn
operator|=
literal|true
expr_stmt|;
comment|/* definitely overlap */
if|if
condition|(
name|partOut
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|right
argument_list|()
operator|>=
name|prect
operator|->
name|right
argument_list|()
condition|)
block|{
name|ry
operator|=
name|pbox
operator|->
name|bottom
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|/* finished with this band */
if|if
condition|(
name|ry
operator|>
name|prect
operator|->
name|bottom
argument_list|()
condition|)
break|break;
name|rx
operator|=
name|prect
operator|->
name|left
argument_list|()
expr_stmt|;
comment|/* reset x out to left again */
block|}
else|else
block|{
comment|/*              * Because boxes in a band are maximal width, if the first box              * to overlap the rectangle doesn't completely cover it in that              * band, the rectangle must be partially out, since some of it              * will be uncovered in that band. partIn will have been set true              * by now...              */
break|break;
block|}
block|}
return|return
name|partIn
condition|?
operator|(
operator|(
name|ry
operator|<=
name|prect
operator|->
name|bottom
argument_list|()
operator|)
condition|?
name|RectanglePart
else|:
name|RectangleIn
operator|)
else|:
name|RectangleOut
return|;
block|}
end_function
begin_comment
comment|// END OF Region.c extract
end_comment
begin_comment
comment|// START OF poly.h extract
end_comment
begin_comment
comment|/* $XConsortium: poly.h,v 1.4 94/04/17 20:22:19 rws Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/*  *     This file contains a few macros to help track  *     the edge of a filled object.  The object is assumed  *     to be filled in scanline order, and thus the  *     algorithm used is an extension of Bresenham's line  *     drawing algorithm which assumes that y is always the  *     major axis.  *     Since these pieces of code are the same for any filled shape,  *     it is more convenient to gather the library in one  *     place, but since these pieces of code are also in  *     the inner loops of output primitives, procedure call  *     overhead is out of the question.  *     See the author for a derivation if needed.  */
end_comment
begin_comment
comment|/*  *  In scan converting polygons, we want to choose those pixels  *  which are inside the polygon.  Thus, we add .5 to the starting  *  x coordinate for both left and right edges.  Now we choose the  *  first pixel which is inside the pgon for the left edge and the  *  first pixel which is outside the pgon for the right edge.  *  Draw the left pixel, but not the right.  *  *  How to add .5 to the starting x coordinate:  *      If the edge is moving to the right, then subtract dy from the  *  error term from the general form of the algorithm.  *      If the edge is moving to the left, then add dy to the error term.  *  *  The reason for the difference between edges moving to the left  *  and edges moving to the right is simple:  If an edge is moving  *  to the right, then we want the algorithm to flip immediately.  *  If it is moving to the left, then we don't want it to flip until  *  we traverse an entire pixel.  */
end_comment
begin_define
DECL|macro|BRESINITPGON
define|#
directive|define
name|BRESINITPGON
parameter_list|(
name|dy
parameter_list|,
name|x1
parameter_list|,
name|x2
parameter_list|,
name|xStart
parameter_list|,
name|d
parameter_list|,
name|m
parameter_list|,
name|m1
parameter_list|,
name|incr1
parameter_list|,
name|incr2
parameter_list|)
value|{ \     int dx;
comment|/* local storage */
value|\ \
comment|/* \      *  if the edge is horizontal, then it is ignored \      *  and assumed not to be processed.  Otherwise, do this stuff. \      */
value|\     if ((dy) != 0) { \         xStart = (x1); \         dx = (x2) - xStart; \         if (dx< 0) { \             m = dx / (dy); \             m1 = m - 1; \             incr1 = -2 * dx + 2 * (dy) * m1; \             incr2 = -2 * dx + 2 * (dy) * m; \             d = 2 * m * (dy) - 2 * dx - 2 * (dy); \         } else { \             m = dx / (dy); \             m1 = m + 1; \             incr1 = 2 * dx - 2 * (dy) * m1; \             incr2 = 2 * dx - 2 * (dy) * m; \             d = -2 * m * (dy) + 2 * dx; \         } \     } \ }
end_define
begin_define
DECL|macro|BRESINCRPGON
define|#
directive|define
name|BRESINCRPGON
parameter_list|(
name|d
parameter_list|,
name|minval
parameter_list|,
name|m
parameter_list|,
name|m1
parameter_list|,
name|incr1
parameter_list|,
name|incr2
parameter_list|)
value|{ \     if (m1> 0) { \         if (d> 0) { \             minval += m1; \             d += incr1; \         } \         else { \             minval += m; \             d += incr2; \         } \     } else {\         if (d>= 0) { \             minval += m1; \             d += incr1; \         } \         else { \             minval += m; \             d += incr2; \         } \     } \ }
end_define
begin_comment
comment|/*  *     This structure contains all of the information needed  *     to run the bresenham algorithm.  *     The variables may be hardcoded into the declarations  *     instead of using this structure to make use of  *     register declarations.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|minor_axis
name|int
name|minor_axis
decl_stmt|;
comment|/* minor axis        */
DECL|member|d
name|int
name|d
decl_stmt|;
comment|/* decision variable */
DECL|member|m
DECL|member|m1
name|int
name|m
decl_stmt|,
name|m1
decl_stmt|;
comment|/* slope and slope+1 */
DECL|member|incr1
DECL|member|incr2
name|int
name|incr1
decl_stmt|,
name|incr2
decl_stmt|;
comment|/* error increments */
block|}
DECL|typedef|BRESINFO
name|BRESINFO
typedef|;
end_typedef
begin_define
DECL|macro|BRESINITPGONSTRUCT
define|#
directive|define
name|BRESINITPGONSTRUCT
parameter_list|(
name|dmaj
parameter_list|,
name|min1
parameter_list|,
name|min2
parameter_list|,
name|bres
parameter_list|)
define|\
value|BRESINITPGON(dmaj, min1, min2, bres.minor_axis, bres.d, \                      bres.m, bres.m1, bres.incr1, bres.incr2)
end_define
begin_define
DECL|macro|BRESINCRPGONSTRUCT
define|#
directive|define
name|BRESINCRPGONSTRUCT
parameter_list|(
name|bres
parameter_list|)
define|\
value|BRESINCRPGON(bres.d, bres.minor_axis, bres.m, bres.m1, bres.incr1, bres.incr2)
end_define
begin_comment
comment|/*  *     These are the data structures needed to scan  *     convert regions.  Two different scan conversion  *     methods are available -- the even-odd method, and  *     the winding number method.  *     The even-odd rule states that a point is inside  *     the polygon if a ray drawn from that point in any  *     direction will pass through an odd number of  *     path segments.  *     By the winding number rule, a point is decided  *     to be inside the polygon if a ray drawn from that  *     point in any direction passes through a different  *     number of clockwise and counter-clockwise path  *     segments.  *  *     These data structures are adapted somewhat from  *     the algorithm in (Foley/Van Dam) for scan converting  *     polygons.  *     The basic algorithm is to start at the top (smallest y)  *     of the polygon, stepping down to the bottom of  *     the polygon by incrementing the y coordinate.  We  *     keep a list of edges which the current scanline crosses,  *     sorted by x.  This list is called the Active Edge Table (AET)  *     As we change the y-coordinate, we update each entry in  *     in the active edge table to reflect the edges new xcoord.  *     This list must be sorted at each scanline in case  *     two edges intersect.  *     We also keep a data structure known as the Edge Table (ET),  *     which keeps track of all the edges which the current  *     scanline has not yet reached.  The ET is basically a  *     list of ScanLineList structures containing a list of  *     edges which are entered at a given scanline.  There is one  *     ScanLineList per scanline at which an edge is entered.  *     When we enter a new edge, we move it from the ET to the AET.  *  *     From the AET, we can implement the even-odd rule as in  *     (Foley/Van Dam).  *     The winding number rule is a little trickier.  We also  *     keep the EdgeTableEntries in the AET linked by the  *     nextWETE (winding EdgeTableEntry) link.  This allows  *     the edges to be linked just as before for updating  *     purposes, but only uses the edges linked by the nextWETE  *     link as edges representing spans of the polygon to  *     drawn (as with the even-odd rule).  */
end_comment
begin_comment
comment|/*  * for the winding number rule  */
end_comment
begin_define
DECL|macro|CLOCKWISE
define|#
directive|define
name|CLOCKWISE
value|1
end_define
begin_define
DECL|macro|COUNTERCLOCKWISE
define|#
directive|define
name|COUNTERCLOCKWISE
value|-1
end_define
begin_typedef
DECL|struct|_EdgeTableEntry
typedef|typedef
struct|struct
name|_EdgeTableEntry
block|{
DECL|member|ymax
name|int
name|ymax
decl_stmt|;
comment|/* ycoord at which we exit this edge. */
DECL|member|ClockWise
name|int
name|ClockWise
decl_stmt|;
comment|/* flag for winding number rule       */
DECL|member|bres
name|BRESINFO
name|bres
decl_stmt|;
comment|/* Bresenham info to run the edge     */
DECL|member|next
name|struct
name|_EdgeTableEntry
modifier|*
name|next
decl_stmt|;
comment|/* next in the list     */
DECL|member|back
name|struct
name|_EdgeTableEntry
modifier|*
name|back
decl_stmt|;
comment|/* for insertion sort   */
DECL|member|nextWETE
name|struct
name|_EdgeTableEntry
modifier|*
name|nextWETE
decl_stmt|;
comment|/* for winding num rule */
block|}
DECL|typedef|EdgeTableEntry
name|EdgeTableEntry
typedef|;
end_typedef
begin_typedef
DECL|struct|_ScanLineList
typedef|typedef
struct|struct
name|_ScanLineList
block|{
DECL|member|scanline
name|int
name|scanline
decl_stmt|;
comment|/* the scanline represented */
DECL|member|edgelist
name|EdgeTableEntry
modifier|*
name|edgelist
decl_stmt|;
comment|/* header node              */
DECL|member|next
name|struct
name|_ScanLineList
modifier|*
name|next
decl_stmt|;
comment|/* next in the list       */
block|}
DECL|typedef|ScanLineList
name|ScanLineList
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|ymax
name|int
name|ymax
decl_stmt|;
comment|/* ymax for the polygon     */
DECL|member|ymin
name|int
name|ymin
decl_stmt|;
comment|/* ymin for the polygon     */
DECL|member|scanlines
name|ScanLineList
name|scanlines
decl_stmt|;
comment|/* header node              */
block|}
DECL|typedef|EdgeTable
name|EdgeTable
typedef|;
end_typedef
begin_comment
comment|/*  * Here is a struct to help with storage allocation  * so we can allocate a big chunk at a time, and then take  * pieces from this heap when we need to.  */
end_comment
begin_define
DECL|macro|SLLSPERBLOCK
define|#
directive|define
name|SLLSPERBLOCK
value|25
end_define
begin_typedef
DECL|struct|_ScanLineListBlock
typedef|typedef
struct|struct
name|_ScanLineListBlock
block|{
DECL|member|SLLs
name|ScanLineList
name|SLLs
index|[
name|SLLSPERBLOCK
index|]
decl_stmt|;
DECL|member|next
name|struct
name|_ScanLineListBlock
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|ScanLineListBlock
name|ScanLineListBlock
typedef|;
end_typedef
begin_comment
comment|/*  *  *     a few macros for the inner loops of the fill code where  *     performance considerations don't allow a procedure call.  *  *     Evaluate the given edge at the given scanline.  *     If the edge has expired, then we leave it and fix up  *     the active edge table; otherwise, we increment the  *     x value to be ready for the next scanline.  *     The winding number rule is in effect, so we must notify  *     the caller when the edge has been removed so he  *     can reorder the Winding Active Edge Table.  */
end_comment
begin_define
DECL|macro|EVALUATEEDGEWINDING
define|#
directive|define
name|EVALUATEEDGEWINDING
parameter_list|(
name|pAET
parameter_list|,
name|pPrevAET
parameter_list|,
name|y
parameter_list|,
name|fixWAET
parameter_list|)
value|{ \    if (pAET->ymax == y) {
comment|/* leaving this edge */
value|\       pPrevAET->next = pAET->next; \       pAET = pPrevAET->next; \       fixWAET = 1; \       if (pAET) \          pAET->back = pPrevAET; \    } \    else { \       BRESINCRPGONSTRUCT(pAET->bres) \       pPrevAET = pAET; \       pAET = pAET->next; \    } \ }
end_define
begin_comment
comment|/*  *     Evaluate the given edge at the given scanline.  *     If the edge has expired, then we leave it and fix up  *     the active edge table; otherwise, we increment the  *     x value to be ready for the next scanline.  *     The even-odd rule is in effect.  */
end_comment
begin_define
DECL|macro|EVALUATEEDGEEVENODD
define|#
directive|define
name|EVALUATEEDGEEVENODD
parameter_list|(
name|pAET
parameter_list|,
name|pPrevAET
parameter_list|,
name|y
parameter_list|)
value|{ \    if (pAET->ymax == y) {
comment|/* leaving this edge */
value|\       pPrevAET->next = pAET->next; \       pAET = pPrevAET->next; \       if (pAET) \          pAET->back = pPrevAET; \    } \    else { \       BRESINCRPGONSTRUCT(pAET->bres) \       pPrevAET = pAET; \       pAET = pAET->next; \    } \ }
end_define
begin_comment
comment|// END OF poly.h extract
end_comment
begin_comment
comment|// START OF PolyReg.c extract
end_comment
begin_comment
comment|/* $XConsortium: PolyReg.c,v 11.23 94/11/17 21:59:37 converse Exp $ */
end_comment
begin_comment
comment|/************************************************************************  Copyright (c) 1987  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.   Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Digital not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment
begin_comment
comment|/* $XFree86: xc/lib/X11/PolyReg.c,v 1.1.1.2.8.2 1998/10/04 15:22:49 hohndel Exp $ */
end_comment
begin_define
DECL|macro|LARGE_COORDINATE
define|#
directive|define
name|LARGE_COORDINATE
value|INT_MAX
end_define
begin_define
DECL|macro|SMALL_COORDINATE
define|#
directive|define
name|SMALL_COORDINATE
value|INT_MIN
end_define
begin_comment
comment|/*  *     InsertEdgeInET  *  *     Insert the given edge into the edge table.  *     First we must find the correct bucket in the  *     Edge table, then find the right slot in the  *     bucket.  Finally, we can insert it.  *  */
end_comment
begin_function
DECL|function|InsertEdgeInET
specifier|static
name|void
name|InsertEdgeInET
parameter_list|(
name|EdgeTable
modifier|*
name|ET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|ETE
parameter_list|,
name|int
name|scanline
parameter_list|,
name|ScanLineListBlock
modifier|*
modifier|*
name|SLLBlock
parameter_list|,
name|int
modifier|*
name|iSLLBlock
parameter_list|)
block|{
name|EdgeTableEntry
modifier|*
name|start
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|,
modifier|*
name|pPrevSLL
decl_stmt|;
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
comment|/*      * find the right bucket to put the edge into      */
name|pPrevSLL
operator|=
operator|&
name|ET
operator|->
name|scanlines
expr_stmt|;
name|pSLL
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|pSLL
operator|&&
operator|(
name|pSLL
operator|->
name|scanline
operator|<
name|scanline
operator|)
condition|)
block|{
name|pPrevSLL
operator|=
name|pSLL
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
comment|/*      * reassign pSLL (pointer to ScanLineList) if necessary      */
if|if
condition|(
operator|(
operator|!
name|pSLL
operator|)
operator|||
operator|(
name|pSLL
operator|->
name|scanline
operator|>
name|scanline
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|iSLLBlock
operator|>
name|SLLSPERBLOCK
operator|-
literal|1
condition|)
block|{
name|tmpSLLBlock
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ScanLineListBlock
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|tmpSLLBlock
argument_list|)
expr_stmt|;
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|next
operator|=
name|tmpSLLBlock
expr_stmt|;
name|tmpSLLBlock
operator|->
name|next
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|SLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
operator|*
name|iSLLBlock
operator|=
literal|0
expr_stmt|;
block|}
name|pSLL
operator|=
operator|&
operator|(
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|SLLs
index|[
operator|(
operator|*
name|iSLLBlock
operator|)
operator|++
index|]
operator|)
expr_stmt|;
name|pSLL
operator|->
name|next
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
name|pSLL
operator|->
name|edgelist
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|pPrevSLL
operator|->
name|next
operator|=
name|pSLL
expr_stmt|;
block|}
name|pSLL
operator|->
name|scanline
operator|=
name|scanline
expr_stmt|;
comment|/*      * now insert the edge in the right bucket      */
name|prev
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|pSLL
operator|->
name|edgelist
expr_stmt|;
while|while
condition|(
name|start
operator|&&
operator|(
name|start
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETE
operator|->
name|bres
operator|.
name|minor_axis
operator|)
condition|)
block|{
name|prev
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
block|}
name|ETE
operator|->
name|next
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|ETE
expr_stmt|;
else|else
name|pSLL
operator|->
name|edgelist
operator|=
name|ETE
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  *     CreateEdgeTable  *  *     This routine creates the edge table for  *     scan converting polygons.  *     The Edge Table (ET) looks like:  *  *    EdgeTable  *     --------  *    |  ymax  |        ScanLineLists  *    |scanline|-->------------>-------------->...  *     --------   |scanline|   |scanline|  *                |edgelist|   |edgelist|  *                ---------    ---------  *                    |             |  *                    |             |  *                    V             V  *              list of ETEs   list of ETEs  *  *     where ETE is an EdgeTableEntry data structure,  *     and there is one ScanLineList per scanline at  *     which an edge is initially entered.  *  */
end_comment
begin_function
DECL|function|CreateETandAET
specifier|static
name|void
name|CreateETandAET
parameter_list|(
name|int
name|count
parameter_list|,
specifier|const
name|QPoint
modifier|*
name|pts
parameter_list|,
name|EdgeTable
modifier|*
name|ET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|pETEs
parameter_list|,
name|ScanLineListBlock
modifier|*
name|pSLLBlock
parameter_list|)
block|{
specifier|const
name|QPoint
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|PrevPt
decl_stmt|,
modifier|*
name|CurrPt
decl_stmt|;
name|int
name|iSLLBlock
init|=
literal|0
decl_stmt|;
name|int
name|dy
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
return|return;
comment|/*      *  initialize the Active Edge Table      */
name|AET
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|back
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|=
name|SMALL_COORDINATE
expr_stmt|;
comment|/*      *  initialize the Edge Table.      */
name|ET
operator|->
name|scanlines
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|ET
operator|->
name|ymax
operator|=
name|SMALL_COORDINATE
expr_stmt|;
name|ET
operator|->
name|ymin
operator|=
name|LARGE_COORDINATE
expr_stmt|;
name|pSLLBlock
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|PrevPt
operator|=
operator|&
name|pts
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
comment|/*      *  for each vertex in the array of points.      *  In this loop we are dealing with two vertices at      *  a time -- these make up one edge of the polygon.      */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|CurrPt
operator|=
name|pts
operator|++
expr_stmt|;
comment|/*          *  find out which point is above and which is below.          */
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|>
name|CurrPt
operator|->
name|y
argument_list|()
condition|)
block|{
name|bottom
operator|=
name|PrevPt
expr_stmt|;
name|top
operator|=
name|CurrPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|CurrPt
expr_stmt|;
name|top
operator|=
name|PrevPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|1
expr_stmt|;
block|}
comment|/*          * don't add horizontal edges to the Edge table.          */
if|if
condition|(
name|bottom
operator|->
name|y
argument_list|()
operator|!=
name|top
operator|->
name|y
argument_list|()
condition|)
block|{
name|pETEs
operator|->
name|ymax
operator|=
name|bottom
operator|->
name|y
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* -1 so we don't get last scanline */
comment|/*              *  initialize integer edge algorithm              */
name|dy
operator|=
name|bottom
operator|->
name|y
argument_list|()
operator|-
name|top
operator|->
name|y
argument_list|()
expr_stmt|;
name|BRESINITPGONSTRUCT
argument_list|(
argument|dy
argument_list|,
argument|top->x()
argument_list|,
argument|bottom->x()
argument_list|,
argument|pETEs->bres
argument_list|)
name|InsertEdgeInET
argument_list|(
name|ET
argument_list|,
name|pETEs
argument_list|,
name|top
operator|->
name|y
argument_list|()
argument_list|,
operator|&
name|pSLLBlock
argument_list|,
operator|&
name|iSLLBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|>
name|ET
operator|->
name|ymax
condition|)
name|ET
operator|->
name|ymax
operator|=
name|PrevPt
operator|->
name|y
argument_list|()
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
argument_list|()
operator|<
name|ET
operator|->
name|ymin
condition|)
name|ET
operator|->
name|ymin
operator|=
name|PrevPt
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pETEs
expr_stmt|;
block|}
name|PrevPt
operator|=
name|CurrPt
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     loadAET  *  *     This routine moves EdgeTableEntries from the  *     EdgeTable into the Active Edge Table,  *     leaving them sorted by smaller x coordinate.  *  */
end_comment
begin_function
DECL|function|loadAET
specifier|static
name|void
name|loadAET
parameter_list|(
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|,
name|EdgeTableEntry
modifier|*
name|ETEs
parameter_list|)
block|{
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|tmp
decl_stmt|;
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|ETEs
condition|)
block|{
while|while
condition|(
name|AET
operator|&&
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETEs
operator|->
name|bres
operator|.
name|minor_axis
condition|)
block|{
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|tmp
operator|=
name|ETEs
operator|->
name|next
expr_stmt|;
name|ETEs
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|->
name|back
operator|=
name|pPrevAET
expr_stmt|;
name|pPrevAET
operator|->
name|next
operator|=
name|ETEs
expr_stmt|;
name|pPrevAET
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     computeWAET  *  *     This routine links the AET by the  *     nextWETE (winding EdgeTableEntry) link for  *     use by the winding number rule.  The final  *     Active Edge Table (AET) might look something  *     like:  *  *     AET  *     ----------  ---------   ---------  *     |ymax    |  |ymax    |  |ymax    |  *     | ...    |  |...     |  |...     |  *     |next    |->|next    |->|next    |->...  *     |nextWETE|  |nextWETE|  |nextWETE|  *     ---------   ---------   ^--------  *         |                   |       |  *         V------------------->       V---> ...  *  */
end_comment
begin_function
DECL|function|computeWAET
specifier|static
name|void
name|computeWAET
parameter_list|(
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|)
block|{
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
name|int
name|inside
init|=
literal|1
decl_stmt|;
name|int
name|isInside
init|=
literal|0
decl_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
if|if
condition|(
name|AET
operator|->
name|ClockWise
condition|)
operator|++
name|isInside
expr_stmt|;
else|else
operator|--
name|isInside
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|inside
operator|&&
operator|!
name|isInside
operator|)
operator|||
operator|(
name|inside
operator|&&
name|isInside
operator|)
condition|)
block|{
name|pWETE
operator|->
name|nextWETE
operator|=
name|AET
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
block|}
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|pWETE
operator|->
name|nextWETE
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  *     InsertionSort  *  *     Just a simple insertion sort using  *     pointers and back pointers to sort the Active  *     Edge Table.  *  */
end_comment
begin_function
DECL|function|InsertionSort
specifier|static
name|int
name|InsertionSort
parameter_list|(
name|EdgeTableEntry
modifier|*
name|AET
parameter_list|)
block|{
name|EdgeTableEntry
modifier|*
name|pETEchase
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|pETEinsert
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|pETEchaseBackTMP
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
name|pETEinsert
operator|=
name|AET
expr_stmt|;
name|pETEchase
operator|=
name|AET
expr_stmt|;
while|while
condition|(
name|pETEchase
operator|->
name|back
operator|->
name|bres
operator|.
name|minor_axis
operator|>
name|AET
operator|->
name|bres
operator|.
name|minor_axis
condition|)
name|pETEchase
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pETEchase
operator|!=
name|pETEinsert
condition|)
block|{
name|pETEchaseBackTMP
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|pETEinsert
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|next
operator|=
name|pETEchase
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|->
name|next
operator|=
name|pETEinsert
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|=
name|pETEinsert
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|=
name|pETEchaseBackTMP
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function
begin_comment
comment|/*  *     Clean up our act.  */
end_comment
begin_function
DECL|function|FreeStorage
specifier|static
name|void
name|FreeStorage
parameter_list|(
name|ScanLineListBlock
modifier|*
name|pSLLBlock
parameter_list|)
block|{
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
while|while
condition|(
name|pSLLBlock
condition|)
block|{
name|tmpSLLBlock
operator|=
name|pSLLBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pSLLBlock
argument_list|)
expr_stmt|;
name|pSLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|QRegionSpan
struct|struct
name|QRegionSpan
block|{
DECL|function|QRegionSpan
name|QRegionSpan
parameter_list|()
block|{}
DECL|function|QRegionSpan
name|QRegionSpan
parameter_list|(
name|int
name|x1_
parameter_list|,
name|int
name|x2_
parameter_list|)
member_init_list|:
name|x1
argument_list|(
name|x1_
argument_list|)
member_init_list|,
name|x2
argument_list|(
name|x2_
argument_list|)
block|{}
DECL|member|x1
name|int
name|x1
decl_stmt|;
DECL|member|x2
name|int
name|x2
decl_stmt|;
DECL|function|width
name|int
name|width
parameter_list|()
specifier|const
block|{
return|return
name|x2
operator|-
name|x1
return|;
block|}
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegionSpan
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|flushRow
specifier|static
specifier|inline
name|void
name|flushRow
parameter_list|(
specifier|const
name|QRegionSpan
modifier|*
name|spans
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|numSpans
parameter_list|,
name|QRegionPrivate
modifier|*
name|reg
parameter_list|,
name|int
modifier|*
name|lastRow
parameter_list|,
name|int
modifier|*
name|extendTo
parameter_list|,
name|bool
modifier|*
name|needsExtend
parameter_list|)
block|{
name|QRect
modifier|*
name|regRects
init|=
name|reg
operator|->
name|rects
operator|.
name|data
argument_list|()
operator|+
operator|*
name|lastRow
decl_stmt|;
name|bool
name|canExtend
init|=
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
operator|-
operator|*
name|lastRow
operator|==
name|numSpans
operator|&&
operator|!
operator|(
operator|*
name|needsExtend
operator|&&
operator|*
name|extendTo
operator|+
literal|1
operator|!=
name|y
operator|)
operator|&&
operator|(
operator|*
name|needsExtend
operator|||
name|regRects
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|+
name|regRects
index|[
literal|0
index|]
operator|.
name|height
argument_list|()
operator|==
name|y
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSpans
operator|&&
name|canExtend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|regRects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|!=
name|spans
index|[
name|i
index|]
operator|.
name|x1
operator|||
name|regRects
index|[
name|i
index|]
operator|.
name|right
argument_list|()
operator|!=
name|spans
index|[
name|i
index|]
operator|.
name|x2
operator|-
literal|1
condition|)
name|canExtend
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|canExtend
condition|)
block|{
operator|*
name|extendTo
operator|=
name|y
expr_stmt|;
operator|*
name|needsExtend
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|needsExtend
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
operator|-
operator|*
name|lastRow
condition|;
operator|++
name|i
control|)
name|regRects
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
operator|*
name|extendTo
argument_list|)
expr_stmt|;
block|}
operator|*
name|lastRow
operator|=
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
expr_stmt|;
name|reg
operator|->
name|rects
operator|.
name|reserve
argument_list|(
operator|*
name|lastRow
operator|+
name|numSpans
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSpans
condition|;
operator|++
name|i
control|)
name|reg
operator|->
name|rects
operator|<<
name|QRect
argument_list|(
name|spans
index|[
name|i
index|]
operator|.
name|x1
argument_list|,
name|y
argument_list|,
name|spans
index|[
name|i
index|]
operator|.
name|width
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spans
index|[
literal|0
index|]
operator|.
name|x1
operator|<
name|reg
operator|->
name|extents
operator|.
name|left
argument_list|()
condition|)
name|reg
operator|->
name|extents
operator|.
name|setLeft
argument_list|(
name|spans
index|[
literal|0
index|]
operator|.
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spans
index|[
name|numSpans
operator|-
literal|1
index|]
operator|.
name|x2
operator|-
literal|1
operator|>
name|reg
operator|->
name|extents
operator|.
name|right
argument_list|()
condition|)
name|reg
operator|->
name|extents
operator|.
name|setRight
argument_list|(
name|spans
index|[
name|numSpans
operator|-
literal|1
index|]
operator|.
name|x2
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|needsExtend
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     Create an array of rectangles from a list of points.  *     If indeed these things (POINTS, RECTS) are the same,  *     then this proc is still needed, because it allocates  *     storage for the array, which was allocated on the  *     stack by the calling procedure.  *  */
end_comment
begin_function
DECL|function|PtsToRegion
specifier|static
name|void
name|PtsToRegion
parameter_list|(
name|int
name|numFullPtBlocks
parameter_list|,
name|int
name|iCurPtBlock
parameter_list|,
name|POINTBLOCK
modifier|*
name|FirstPtBlock
parameter_list|,
name|QRegionPrivate
modifier|*
name|reg
parameter_list|)
block|{
name|int
name|lastRow
init|=
literal|0
decl_stmt|;
name|int
name|extendTo
init|=
literal|0
decl_stmt|;
name|bool
name|needsExtend
init|=
literal|false
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QRegionSpan
argument_list|>
name|row
decl_stmt|;
name|int
name|rowSize
init|=
literal|0
decl_stmt|;
name|reg
operator|->
name|extents
operator|.
name|setLeft
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
name|reg
operator|->
name|extents
operator|.
name|setRight
argument_list|(
name|INT_MIN
argument_list|)
expr_stmt|;
name|reg
operator|->
name|innerArea
operator|=
operator|-
literal|1
expr_stmt|;
name|POINTBLOCK
modifier|*
name|CurPtBlock
init|=
name|FirstPtBlock
decl_stmt|;
for|for
control|(
init|;
name|numFullPtBlocks
operator|>=
literal|0
condition|;
operator|--
name|numFullPtBlocks
control|)
block|{
comment|/* the loop uses 2 points per iteration */
name|int
name|i
init|=
name|NUMPTSTOBUFFER
operator|>>
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|numFullPtBlocks
condition|)
name|i
operator|=
name|iCurPtBlock
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|row
operator|.
name|resize
argument_list|(
name|qMax
argument_list|(
name|row
operator|.
name|size
argument_list|()
argument_list|,
name|rowSize
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|QPoint
modifier|*
name|pts
init|=
name|CurPtBlock
operator|->
name|pts
init|;
name|i
operator|--
condition|;
name|pts
operator|+=
literal|2
control|)
block|{
specifier|const
name|int
name|width
init|=
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|-
name|pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
condition|)
block|{
if|if
condition|(
name|rowSize
operator|&&
name|row
index|[
name|rowSize
operator|-
literal|1
index|]
operator|.
name|x2
operator|==
name|pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
condition|)
name|row
index|[
name|rowSize
operator|-
literal|1
index|]
operator|.
name|x2
operator|=
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
else|else
name|row
index|[
name|rowSize
operator|++
index|]
operator|=
name|QRegionSpan
argument_list|(
name|pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rowSize
condition|)
block|{
name|QPoint
modifier|*
name|next
init|=
name|i
condition|?
operator|&
name|pts
index|[
literal|2
index|]
else|:
operator|(
name|numFullPtBlocks
operator|&&
name|iCurPtBlock
condition|?
name|CurPtBlock
operator|->
name|next
operator|->
name|pts
else|:
name|Q_NULLPTR
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|||
name|next
operator|->
name|y
argument_list|()
operator|!=
name|pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
condition|)
block|{
name|flushRow
argument_list|(
name|row
operator|.
name|data
argument_list|()
argument_list|,
name|pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|rowSize
argument_list|,
name|reg
argument_list|,
operator|&
name|lastRow
argument_list|,
operator|&
name|extendTo
argument_list|,
operator|&
name|needsExtend
argument_list|)
expr_stmt|;
name|rowSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|CurPtBlock
operator|=
name|CurPtBlock
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|needsExtend
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|lastRow
init|;
name|i
operator|<
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|reg
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|extendTo
argument_list|)
expr_stmt|;
block|}
name|reg
operator|->
name|numRects
operator|=
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|numRects
condition|)
block|{
name|reg
operator|->
name|extents
operator|.
name|setTop
argument_list|(
name|reg
operator|->
name|rects
index|[
literal|0
index|]
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|reg
operator|->
name|extents
operator|.
name|setBottom
argument_list|(
name|reg
operator|->
name|rects
index|[
name|lastRow
index|]
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reg
operator|->
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|reg
operator|->
name|updateInnerRect
argument_list|(
name|reg
operator|->
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|->
name|extents
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  *     polytoregion  *  *     Scan converts a polygon by returning a run-length  *     encoding of the resultant bitmap -- the run-length  *     encoding is in the form of an array of rectangles.  *  *     Can return 0 in case of errors.  */
end_comment
begin_function
DECL|function|PolygonRegion
specifier|static
name|QRegionPrivate
modifier|*
name|PolygonRegion
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|Pts
parameter_list|,
name|int
name|Count
parameter_list|,
name|int
name|rule
parameter_list|)
comment|//Point     *Pts;                /* the pts                 */
comment|//int       Count;                 /* number of pts           */
comment|//int       rule;                        /* winding rule */
block|{
name|QRegionPrivate
modifier|*
name|region
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|pAET
decl_stmt|;
comment|/* Active Edge Table       */
name|int
name|y
decl_stmt|;
comment|/* current scanline        */
name|int
name|iPts
init|=
literal|0
decl_stmt|;
comment|/* number of pts in buffer */
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
comment|/* Winding Edge Table Entry*/
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|;
comment|/* current scanLineList    */
name|QPoint
modifier|*
name|pts
decl_stmt|;
comment|/* output buffer           */
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
comment|/* ptr to previous AET     */
name|EdgeTable
name|ET
decl_stmt|;
comment|/* header node for ET      */
name|EdgeTableEntry
modifier|*
name|AET
decl_stmt|;
comment|/* header node for AET     */
name|EdgeTableEntry
modifier|*
name|pETEs
decl_stmt|;
comment|/* EdgeTableEntries pool   */
name|ScanLineListBlock
name|SLLBlock
decl_stmt|;
comment|/* header for scanlinelist */
name|int
name|fixWAET
init|=
literal|false
decl_stmt|;
name|POINTBLOCK
name|FirstPtBlock
decl_stmt|,
modifier|*
name|curPtBlock
decl_stmt|;
comment|/* PtBlock buffers    */
name|FirstPtBlock
operator|.
name|pts
operator|=
cast|reinterpret_cast
argument_list|<
name|QPoint
operator|*
argument_list|>
argument_list|(
name|FirstPtBlock
operator|.
name|data
argument_list|)
expr_stmt|;
name|POINTBLOCK
modifier|*
name|tmpPtBlock
decl_stmt|;
name|int
name|numFullPtBlocks
init|=
literal|0
decl_stmt|;
name|region
operator|=
operator|new
name|QRegionPrivate
expr_stmt|;
comment|/* special case a rectangle */
if|if
condition|(
operator|(
operator|(
name|Count
operator|==
literal|4
operator|)
operator|||
operator|(
operator|(
name|Count
operator|==
literal|5
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|4
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|4
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|1
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|1
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
operator|==
name|Pts
index|[
literal|3
index|]
operator|.
name|x
argument_list|()
operator|)
operator|&&
operator|(
name|Pts
index|[
literal|3
index|]
operator|.
name|y
argument_list|()
operator|==
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|x
init|=
name|qMin
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|->
name|extents
operator|.
name|setLeft
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|int
name|y
init|=
name|qMin
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|->
name|extents
operator|.
name|setTop
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|setWidth
argument_list|(
name|qMax
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|)
operator|-
name|x
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|setHeight
argument_list|(
name|qMax
argument_list|(
name|Pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|Pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|region
operator|->
name|extents
operator|.
name|left
argument_list|()
operator|<=
name|region
operator|->
name|extents
operator|.
name|right
argument_list|()
operator|)
operator|&&
operator|(
name|region
operator|->
name|extents
operator|.
name|top
argument_list|()
operator|<=
name|region
operator|->
name|extents
operator|.
name|bottom
argument_list|()
operator|)
condition|)
block|{
name|region
operator|->
name|numRects
operator|=
literal|1
expr_stmt|;
name|region
operator|->
name|innerRect
operator|=
name|region
operator|->
name|extents
expr_stmt|;
name|region
operator|->
name|innerArea
operator|=
name|region
operator|->
name|innerRect
operator|.
name|width
argument_list|()
operator|*
name|region
operator|->
name|innerRect
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
return|return
name|region
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pETEs
operator|=
cast|static_cast
argument_list|<
name|EdgeTableEntry
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EdgeTableEntry
argument_list|)
operator|*
name|Count
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|delete
name|region
expr_stmt|;
return|return
literal|0
return|;
block|}
name|region
operator|->
name|vectorize
argument_list|()
expr_stmt|;
name|AET
operator|=
operator|new
name|EdgeTableEntry
expr_stmt|;
name|pts
operator|=
name|FirstPtBlock
operator|.
name|pts
expr_stmt|;
name|CreateETandAET
argument_list|(
name|Count
argument_list|,
name|Pts
argument_list|,
operator|&
name|ET
argument_list|,
name|AET
argument_list|,
name|pETEs
argument_list|,
operator|&
name|SLLBlock
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|ET
operator|.
name|scanlines
operator|.
name|next
expr_stmt|;
name|curPtBlock
operator|=
operator|&
name|FirstPtBlock
expr_stmt|;
comment|// sanity check that the region won't become too big...
if|if
condition|(
name|ET
operator|.
name|ymax
operator|-
name|ET
operator|.
name|ymin
operator|>
literal|100000
condition|)
block|{
comment|// clean up region ptr
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QRegion: creating region from big polygon failed...!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|AET
expr_stmt|;
operator|delete
name|region
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QT_TRY
block|{
if|if
condition|(
name|rule
operator|==
name|EvenOddRule
condition|)
block|{
comment|/*              *  for each scanline              */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
operator|++
name|y
control|)
block|{
comment|/*                  *  Add a new edge to the active edge table when we                  *  get to the next edge.                  */
if|if
condition|(
name|pSLL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
comment|/*                  *  for each active edge                  */
while|while
condition|(
name|pAET
condition|)
block|{
name|pts
operator|->
name|setX
argument_list|(
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
argument_list|)
expr_stmt|;
name|pts
operator|->
name|setY
argument_list|(
name|y
argument_list|)
expr_stmt|;
operator|++
name|pts
expr_stmt|;
operator|++
name|iPts
expr_stmt|;
comment|/*                      *  send out the buffer                      */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
operator|(
name|POINTBLOCK
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|tmpPtBlock
argument_list|)
expr_stmt|;
name|tmpPtBlock
operator|->
name|pts
operator|=
cast|reinterpret_cast
argument_list|<
name|QPoint
operator|*
argument_list|>
argument_list|(
name|tmpPtBlock
operator|->
name|data
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
operator|++
name|numFullPtBlocks
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|EVALUATEEDGEEVENODD
argument_list|(
argument|pAET
argument_list|,
argument|pPrevAET
argument_list|,
argument|y
argument_list|)
block|}
name|InsertionSort
argument_list|(
name|AET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              *  for each scanline              */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
operator|++
name|y
control|)
block|{
comment|/*                  *  Add a new edge to the active edge table when we                  *  get to the next edge.                  */
if|if
condition|(
name|pSLL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|computeWAET
argument_list|(
name|AET
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
name|pWETE
operator|=
name|pAET
expr_stmt|;
comment|/*                  *  for each active edge                  */
while|while
condition|(
name|pAET
condition|)
block|{
comment|/*                      *  add to the buffer only those edges that                      *  are in the Winding active edge table.                      */
if|if
condition|(
name|pWETE
operator|==
name|pAET
condition|)
block|{
name|pts
operator|->
name|setX
argument_list|(
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
argument_list|)
expr_stmt|;
name|pts
operator|->
name|setY
argument_list|(
name|y
argument_list|)
expr_stmt|;
operator|++
name|pts
expr_stmt|;
operator|++
name|iPts
expr_stmt|;
comment|/*                          *  send out the buffer                          */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
cast|static_cast
argument_list|<
name|POINTBLOCK
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmpPtBlock
operator|->
name|pts
operator|=
cast|reinterpret_cast
argument_list|<
name|QPoint
operator|*
argument_list|>
argument_list|(
name|tmpPtBlock
operator|->
name|data
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
operator|++
name|numFullPtBlocks
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|pWETE
operator|=
name|pWETE
operator|->
name|nextWETE
expr_stmt|;
block|}
name|EVALUATEEDGEWINDING
argument_list|(
argument|pAET
argument_list|,
argument|pPrevAET
argument_list|,
argument|y
argument_list|,
argument|fixWAET
argument_list|)
block|}
comment|/*                  *  recompute the winding active edge table if                  *  we just resorted or have exited an edge.                  */
if|if
condition|(
name|InsertionSort
argument_list|(
name|AET
argument_list|)
operator|||
name|fixWAET
condition|)
block|{
name|computeWAET
argument_list|(
name|AET
argument_list|)
expr_stmt|;
name|fixWAET
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|FreeStorage
argument_list|(
name|SLLBlock
operator|.
name|next
argument_list|)
expr_stmt|;
name|PtsToRegion
argument_list|(
name|numFullPtBlocks
argument_list|,
name|iPts
argument_list|,
operator|&
name|FirstPtBlock
argument_list|,
name|region
argument_list|)
expr_stmt|;
for|for
control|(
name|curPtBlock
operator|=
name|FirstPtBlock
operator|.
name|next
init|;
operator|--
name|numFullPtBlocks
operator|>=
literal|0
condition|;
control|)
block|{
name|tmpPtBlock
operator|=
name|curPtBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curPtBlock
argument_list|)
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
block|}
name|free
argument_list|(
name|pETEs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|// this function returns 0 in case of an error
block|}
name|FreeStorage
argument_list|(
name|SLLBlock
operator|.
name|next
argument_list|)
expr_stmt|;
name|PtsToRegion
argument_list|(
name|numFullPtBlocks
argument_list|,
name|iPts
argument_list|,
operator|&
name|FirstPtBlock
argument_list|,
name|region
argument_list|)
expr_stmt|;
for|for
control|(
name|curPtBlock
operator|=
name|FirstPtBlock
operator|.
name|next
init|;
operator|--
name|numFullPtBlocks
operator|>=
literal|0
condition|;
control|)
block|{
name|tmpPtBlock
operator|=
name|curPtBlock
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curPtBlock
argument_list|)
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
block|}
operator|delete
name|AET
expr_stmt|;
name|free
argument_list|(
name|pETEs
argument_list|)
expr_stmt|;
return|return
name|region
return|;
block|}
end_function
begin_comment
comment|// END OF PolyReg.c extract
end_comment
begin_function
DECL|function|qt_bitmapToRegion
name|QRegionPrivate
modifier|*
name|qt_bitmapToRegion
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bitmap
parameter_list|)
block|{
specifier|const
name|QImage
name|image
init|=
name|bitmap
operator|.
name|toImage
argument_list|()
decl_stmt|;
name|QRegionPrivate
modifier|*
name|region
init|=
operator|new
name|QRegionPrivate
decl_stmt|;
name|QRect
name|xr
decl_stmt|;
DECL|macro|AddSpan
define|#
directive|define
name|AddSpan
define|\
value|{ \             xr.setCoords(prev1, y, x-1, y); \             UnionRectWithRegion(&xr, region, *region); \         }
specifier|const
name|uchar
name|zero
init|=
literal|0
decl_stmt|;
name|bool
name|little
init|=
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_MonoLSB
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|image
operator|.
name|height
argument_list|()
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|line
init|=
name|image
operator|.
name|constScanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|uchar
name|all
init|=
name|zero
decl_stmt|;
name|int
name|prev1
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
control|)
block|{
name|uchar
name|byte
init|=
name|line
index|[
name|x
operator|/
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|w
operator|-
literal|8
operator|||
name|byte
operator|!=
name|all
condition|)
block|{
if|if
condition|(
name|little
condition|)
block|{
for|for
control|(
name|int
name|b
init|=
literal|8
init|;
name|b
operator|>
literal|0
operator|&&
name|x
operator|<
name|w
condition|;
operator|--
name|b
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|byte
operator|&
literal|0x01
operator|)
operator|==
operator|!
name|all
condition|)
block|{
comment|// More of the same
block|}
else|else
block|{
comment|// A change.
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
name|all
init|=
name|zero
decl_stmt|;
block|}
else|else
block|{
name|prev1
operator|=
name|x
expr_stmt|;
name|all
operator|=
operator|~
name|zero
expr_stmt|;
block|}
block|}
name|byte
operator|>>=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|b
init|=
literal|8
init|;
name|b
operator|>
literal|0
operator|&&
name|x
operator|<
name|w
condition|;
operator|--
name|b
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
operator|!
name|all
condition|)
block|{
comment|// More of the same
block|}
else|else
block|{
comment|// A change.
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
name|all
init|=
name|zero
decl_stmt|;
block|}
else|else
block|{
name|prev1
operator|=
name|x
expr_stmt|;
name|all
operator|=
operator|~
name|zero
expr_stmt|;
block|}
block|}
name|byte
operator|<<=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|x
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|all
operator|!=
name|zero
condition|)
block|{
name|AddSpan
block|}
block|}
DECL|macro|AddSpan
undef|#
directive|undef
name|AddSpan
return|return
name|region
return|;
block|}
end_function
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|()
member_init_list|:
name|d
argument_list|(
cast|const_cast
argument_list|<
name|QRegionData
operator|*
argument_list|>
argument_list|(
operator|&
name|shared_empty
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|RegionType
name|t
parameter_list|)
block|{
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|=
cast|const_cast
argument_list|<
name|QRegionData
operator|*
argument_list|>
argument_list|(
operator|&
name|shared_empty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|new
name|QRegionData
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|Rectangle
condition|)
block|{
name|d
operator|->
name|qt_rgn
operator|=
operator|new
name|QRegionPrivate
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|Ellipse
condition|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addEllipse
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QPolygon
name|a
init|=
name|path
operator|.
name|toSubpathPolygons
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toPolygon
argument_list|()
decl_stmt|;
name|d
operator|->
name|qt_rgn
operator|=
name|PolygonRegion
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|,
name|EvenOddRule
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_constructor
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QRegionPrivate
modifier|*
name|qt_rgn
init|=
name|PolygonRegion
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|,
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
name|WindingRule
else|:
name|EvenOddRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|qt_rgn
condition|)
block|{
name|d
operator|=
operator|new
name|QRegionData
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|=
name|qt_rgn
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
cast|const_cast
argument_list|<
name|QRegionData
operator|*
argument_list|>
argument_list|(
operator|&
name|shared_empty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|=
cast|const_cast
argument_list|<
name|QRegionData
operator|*
argument_list|>
argument_list|(
operator|&
name|shared_empty
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|d
operator|=
name|r
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_constructor
DECL|function|QRegion
name|QRegion
operator|::
name|QRegion
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bm
parameter_list|)
block|{
if|if
condition|(
name|bm
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|=
cast|const_cast
argument_list|<
name|QRegionData
operator|*
argument_list|>
argument_list|(
operator|&
name|shared_empty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|new
name|QRegionData
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|=
name|qt_bitmapToRegion
argument_list|(
name|bm
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_function
DECL|function|cleanUp
name|void
name|QRegion
operator|::
name|cleanUp
parameter_list|(
name|QRegion
operator|::
name|QRegionData
modifier|*
name|x
parameter_list|)
block|{
operator|delete
name|x
operator|->
name|qt_rgn
expr_stmt|;
operator|delete
name|x
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QRegion
name|QRegion
operator|::
name|~
name|QRegion
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|operator =
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
name|r
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|r
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|copy
name|QRegion
name|QRegion
operator|::
name|copy
parameter_list|()
specifier|const
block|{
name|QRegion
name|r
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QRegionData
argument_list|>
name|x
argument_list|(
operator|new
name|QRegionData
argument_list|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
condition|)
name|x
operator|->
name|qt_rgn
operator|=
operator|new
name|QRegionPrivate
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
else|else
name|x
operator|->
name|qt_rgn
operator|=
operator|new
name|QRegionPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|cleanUp
argument_list|(
name|r
operator|.
name|d
argument_list|)
expr_stmt|;
name|r
operator|.
name|d
operator|=
name|x
operator|.
name|take
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|isEmpty
name|bool
name|QRegion
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
operator|&
name|shared_empty
operator|||
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|isNull
name|bool
name|QRegion
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
operator|&
name|shared_empty
operator|||
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|contains
name|bool
name|QRegion
operator|::
name|contains
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
return|return
name|PointInRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|contains
name|bool
name|QRegion
operator|::
name|contains
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
return|return
name|RectInRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
operator|!=
name|RectangleOut
return|;
block|}
end_function
begin_function
DECL|function|translate
name|void
name|QRegion
operator|::
name|translate
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|)
operator|||
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|OffsetRegion
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|united
name|QRegion
name|QRegion
operator|::
name|united
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canPrepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|prepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|UnionRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function
begin_function
DECL|function|operator +=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|+=
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
operator|=
name|r
return|;
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
operator|=
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canPrepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|prepend
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
name|UnionRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
block|}
end_function
begin_function
DECL|function|united
name|QRegion
name|QRegion
operator|::
name|united
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|within
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
operator|&&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|==
name|r
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
operator|&
name|r
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canPrepend
argument_list|(
operator|&
name|r
argument_list|)
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|prepend
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QRegionPrivate
name|rp
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|UnionRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
operator|&
name|rp
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function
begin_function
DECL|function|operator +=
name|QRegion
modifier|&
name|QRegion
operator|::
name|operator
name|+=
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
operator|=
name|r
return|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|within
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
operator|=
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canAppend
argument_list|(
operator|&
name|r
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|append
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|canPrepend
argument_list|(
operator|&
name|r
argument_list|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|prepend
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
operator|&&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|==
name|r
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
name|QRegionPrivate
name|p
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|UnionRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
operator|&
name|p
argument_list|,
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
block|}
end_function
begin_function
DECL|function|intersected
name|QRegion
name|QRegion
operator|::
name|intersected
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
comment|/* this is fully contained in r */
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
comment|/* r is fully contained in this */
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
operator|&&
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
specifier|const
name|QRect
name|rect
init|=
name|qt_rect_intersect_normalized
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
decl_stmt|;
return|return
name|QRegion
argument_list|(
name|rect
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|intersect
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
name|QRegion
name|result
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|intersect
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|miRegionOp
argument_list|(
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
name|miIntersectO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Can't alter dest's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the same. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|intersected
name|QRegion
name|QRegion
operator|::
name|intersected
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|r
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
comment|/* this is fully contained in r */
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|within
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
comment|/* r is fully contained in this */
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
specifier|const
name|QRect
name|rect
init|=
name|qt_rect_intersect_normalized
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
name|r
operator|.
name|normalized
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QRegion
argument_list|(
name|rect
argument_list|)
return|;
block|}
name|QRegion
name|result
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|intersect
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|subtracted
name|QRegion
name|QRegion
operator|::
name|subtracted
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|contains
argument_list|(
operator|*
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
if|if
condition|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
operator|||
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|d
operator|->
name|qt_rgn
operator|->
name|selfTest
argument_list|()
expr_stmt|;
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|SubtractRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_REGION_DEBUG
name|result
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|selfTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|xored
name|QRegion
name|QRegion
operator|::
name|xored
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
operator|*
name|this
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
operator|&
name|r
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|)
condition|)
block|{
return|return
operator|(
operator|*
name|this
operator|+
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
operator|||
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
condition|)
block|{
return|return
name|QRegion
argument_list|()
return|;
block|}
else|else
block|{
name|QRegion
name|result
decl_stmt|;
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
name|XorRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|,
operator|*
name|result
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function
begin_function
DECL|function|boundingRect
name|QRect
name|QRegion
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
return|return
name|d
operator|->
name|qt_rgn
operator|->
name|extents
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns \c true if \a rect is guaranteed to be fully contained in \a region.     A false return value does not guarantee the opposite. */
end_comment
begin_function
name|Q_GUI_EXPORT
DECL|function|qt_region_strictContains
name|bool
name|qt_region_strictContains
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|region
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
operator|!
name|rect
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|#
directive|if
literal|0
comment|// TEST_INNERRECT
block|static bool guard = false;     if (guard)         return false;     guard = true;     QRegion inner = region.d->qt_rgn->innerRect;     Q_ASSERT((inner - region).isEmpty());     guard = false;      int maxArea = 0;     for (int i = 0; i< region.d->qt_rgn->numRects; ++i) {         const QRect r = region.d->qt_rgn->rects.at(i);         if (r.width() * r.height()> maxArea)             maxArea = r.width() * r.height();     }      if (maxArea> region.d->qt_rgn->innerArea) {         qDebug()<< "not largest rectangle"<< region<< region.d->qt_rgn->innerRect;     }     Q_ASSERT(maxArea<= region.d->qt_rgn->innerArea);
endif|#
directive|endif
specifier|const
name|QRect
name|r1
init|=
name|region
operator|.
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
decl_stmt|;
return|return
operator|(
name|rect
operator|.
name|left
argument_list|()
operator|>=
name|r1
operator|.
name|left
argument_list|()
operator|&&
name|rect
operator|.
name|right
argument_list|()
operator|<=
name|r1
operator|.
name|right
argument_list|()
operator|&&
name|rect
operator|.
name|top
argument_list|()
operator|>=
name|r1
operator|.
name|top
argument_list|()
operator|&&
name|rect
operator|.
name|bottom
argument_list|()
operator|<=
name|r1
operator|.
name|bottom
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|rects
name|QVector
argument_list|<
name|QRect
argument_list|>
name|QRegion
operator|::
name|rects
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|qt_rgn
condition|)
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|vectorize
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
operator|.
name|reserve
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
argument_list|)
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
operator|.
name|resize
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qt_rgn
operator|->
name|rects
return|;
block|}
else|else
block|{
return|return
name|QVector
argument_list|<
name|QRect
argument_list|>
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|setRects
name|void
name|QRegion
operator|::
name|setRects
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rects
parameter_list|,
name|int
name|num
parameter_list|)
block|{
operator|*
name|this
operator|=
name|QRegion
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rects
operator|||
name|num
operator|==
literal|0
operator|||
operator|(
name|num
operator|==
literal|1
operator|&&
name|rects
operator|->
name|isEmpty
argument_list|()
operator|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|=
operator|*
name|rects
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|innerRect
operator|=
operator|*
name|rects
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|qt_rgn
operator|->
name|rects
operator|.
name|resize
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|int
name|left
init|=
name|INT_MAX
decl_stmt|,
name|right
init|=
name|INT_MIN
decl_stmt|,
name|top
init|=
name|INT_MAX
decl_stmt|,
name|bottom
init|=
name|INT_MIN
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
modifier|&
name|rect
init|=
name|rects
index|[
name|i
index|]
decl_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|rects
index|[
name|i
index|]
operator|=
name|rect
expr_stmt|;
name|left
operator|=
name|qMin
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|qMax
argument_list|(
name|rect
operator|.
name|right
argument_list|()
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|qMax
argument_list|(
name|rect
operator|.
name|bottom
argument_list|()
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|d
operator|->
name|qt_rgn
operator|->
name|updateInnerRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|qt_rgn
operator|->
name|extents
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|left
argument_list|,
name|top
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|rectCount
name|int
name|QRegion
operator|::
name|rectCount
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|->
name|qt_rgn
condition|?
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|QRegion
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|qt_rgn
condition|)
return|return
name|r
operator|.
name|isEmpty
argument_list|()
return|;
if|if
condition|(
operator|!
name|r
operator|.
name|d
operator|->
name|qt_rgn
condition|)
return|return
name|isEmpty
argument_list|()
return|;
if|if
condition|(
name|d
operator|==
name|r
operator|.
name|d
condition|)
return|return
literal|true
return|;
else|else
return|return
name|EqualRegion
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|,
name|r
operator|.
name|d
operator|->
name|qt_rgn
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|intersects
name|bool
name|QRegion
operator|::
name|intersects
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmptyHelper
argument_list|(
name|d
operator|->
name|qt_rgn
argument_list|)
operator|||
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QRect
name|r
init|=
name|rect
operator|.
name|normalized
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rect_intersects
argument_list|(
name|d
operator|->
name|qt_rgn
operator|->
name|extents
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|qt_rgn
operator|->
name|numRects
operator|==
literal|1
condition|)
return|return
literal|true
return|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|myRects
init|=
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|QRect
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|myRects
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|<
name|myRects
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
name|rect_intersects
argument_list|(
name|r
argument_list|,
operator|*
name|it
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
