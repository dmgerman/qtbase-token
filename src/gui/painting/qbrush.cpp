begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qbrush.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qline.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|"private/qhexstring_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qnumeric.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_patternForBrush
specifier|const
name|uchar
modifier|*
name|qt_patternForBrush
parameter_list|(
name|int
name|brushStyle
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|brushStyle
operator|>
name|Qt
operator|::
name|SolidPattern
operator|&&
name|brushStyle
operator|<
name|Qt
operator|::
name|LinearGradientPattern
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|uchar
name|pat_tbl
index|[]
index|[
literal|2
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
comment|/* dense1 */
block|{
literal|0x00
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/*~dense1 */
block|{
literal|0xff
block|,
literal|0xbb
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xbb
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,         }
block|,
block|{
comment|/* dense2 */
block|{
literal|0x88
block|,
literal|0x00
block|,
literal|0x22
block|,
literal|0x00
block|,
literal|0x88
block|,
literal|0x00
block|,
literal|0x22
block|,
literal|0x00
block|}
block|,
comment|/*~dense2 */
block|{
literal|0x77
block|,
literal|0xff
block|,
literal|0xdd
block|,
literal|0xff
block|,
literal|0x77
block|,
literal|0xff
block|,
literal|0xdd
block|,
literal|0xff
block|}
block|,         }
block|,
block|{
comment|/* dense3 */
block|{
literal|0xaa
block|,
literal|0x44
block|,
literal|0xaa
block|,
literal|0x11
block|,
literal|0xaa
block|,
literal|0x44
block|,
literal|0xaa
block|,
literal|0x11
block|}
block|,
comment|/*~dense3 */
block|{
literal|0x55
block|,
literal|0xbb
block|,
literal|0x55
block|,
literal|0xee
block|,
literal|0x55
block|,
literal|0xbb
block|,
literal|0x55
block|,
literal|0xee
block|}
block|,         }
block|,
block|{
comment|/* dense4 */
block|{
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|}
block|,
comment|/*~dense4 */
block|{
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x55
block|}
block|,         }
block|,
block|{
comment|/* dense5 */
block|{
literal|0x55
block|,
literal|0xbb
block|,
literal|0x55
block|,
literal|0xee
block|,
literal|0x55
block|,
literal|0xbb
block|,
literal|0x55
block|,
literal|0xee
block|}
block|,
comment|/*~dense5 */
block|{
literal|0xaa
block|,
literal|0x44
block|,
literal|0xaa
block|,
literal|0x11
block|,
literal|0xaa
block|,
literal|0x44
block|,
literal|0xaa
block|,
literal|0x11
block|}
block|,         }
block|,
block|{
comment|/* dense6 */
block|{
literal|0x77
block|,
literal|0xff
block|,
literal|0xdd
block|,
literal|0xff
block|,
literal|0x77
block|,
literal|0xff
block|,
literal|0xdd
block|,
literal|0xff
block|}
block|,
comment|/*~dense6 */
block|{
literal|0x88
block|,
literal|0x00
block|,
literal|0x22
block|,
literal|0x00
block|,
literal|0x88
block|,
literal|0x00
block|,
literal|0x22
block|,
literal|0x00
block|}
block|,         }
block|,
block|{
comment|/* dense7 */
block|{
literal|0xff
block|,
literal|0xbb
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xbb
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*~dense7 */
block|{
literal|0x00
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x44
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,         }
block|,
block|{
comment|/* hor */
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/*~hor */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,         }
block|,
block|{
comment|/* ver */
block|{
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|}
block|,
comment|/*~ver */
block|{
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|}
block|,         }
block|,
block|{
comment|/* cross */
block|{
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0x00
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xef
block|}
block|,
comment|/*~cross */
block|{
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0xff
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|}
block|,         }
block|,
block|{
comment|/* bdiag */
block|{
literal|0x7f
block|,
literal|0xbf
block|,
literal|0xdf
block|,
literal|0xef
block|,
literal|0xf7
block|,
literal|0xfb
block|,
literal|0xfd
block|,
literal|0xfe
block|}
block|,
comment|/*~bdiag */
block|{
literal|0x80
block|,
literal|0x40
block|,
literal|0x20
block|,
literal|0x10
block|,
literal|0x08
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x01
block|}
block|,         }
block|,
block|{
comment|/* fdiag */
block|{
literal|0xfe
block|,
literal|0xfd
block|,
literal|0xfb
block|,
literal|0xf7
block|,
literal|0xef
block|,
literal|0xdf
block|,
literal|0xbf
block|,
literal|0x7f
block|}
block|,
comment|/*~fdiag */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
block|,         }
block|,
block|{
comment|/* dcross */
block|{
literal|0x7e
block|,
literal|0xbd
block|,
literal|0xdb
block|,
literal|0xe7
block|,
literal|0xe7
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0x7e
block|}
block|,
comment|/*~dcross */
block|{
literal|0x81
block|,
literal|0x42
block|,
literal|0x24
block|,
literal|0x18
block|,
literal|0x18
block|,
literal|0x24
block|,
literal|0x42
block|,
literal|0x81
block|}
block|,         }
block|,     }
decl_stmt|;
return|return
name|pat_tbl
index|[
name|brushStyle
operator|-
name|Qt
operator|::
name|Dense1Pattern
index|]
index|[
name|invert
index|]
return|;
block|}
end_function
begin_function
DECL|function|qt_pixmapForBrush
name|QPixmap
name|qt_pixmapForBrush
parameter_list|(
name|int
name|brushStyle
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
name|QPixmap
name|pm
decl_stmt|;
name|QString
name|key
init|=
name|QLatin1String
argument_list|(
literal|"$qt-brush$"
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|brushStyle
argument_list|)
operator|%
name|QLatin1Char
argument_list|(
name|invert
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
argument_list|,
name|pm
argument_list|)
condition|)
block|{
name|pm
operator|=
name|QBitmap
operator|::
name|fromData
argument_list|(
name|QSize
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
argument_list|,
name|qt_patternForBrush
argument_list|(
name|brushStyle
argument_list|,
name|invert
argument_list|)
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|key
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
return|return
name|pm
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|qt_cleanup_brush_pattern_image_cache
parameter_list|()
function_decl|;
end_function_decl
begin_class
DECL|class|QBrushPatternImageCache
class|class
name|QBrushPatternImageCache
block|{
public|public:
DECL|function|QBrushPatternImageCache
name|QBrushPatternImageCache
parameter_list|()
member_init_list|:
name|m_initialized
argument_list|(
literal|false
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
block|}
DECL|function|init
name|void
name|init
parameter_list|()
block|{
name|qAddPostRoutine
argument_list|(
name|qt_cleanup_brush_pattern_image_cache
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|style
init|=
name|Qt
operator|::
name|Dense1Pattern
init|;
name|style
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
condition|;
operator|++
name|style
control|)
block|{
name|int
name|i
init|=
name|style
operator|-
name|Qt
operator|::
name|Dense1Pattern
decl_stmt|;
name|m_images
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|QImage
argument_list|(
name|qt_patternForBrush
argument_list|(
name|style
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|m_images
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|QImage
argument_list|(
name|qt_patternForBrush
argument_list|(
name|style
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
block|}
name|m_initialized
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|getImage
name|QImage
name|getImage
parameter_list|(
name|int
name|brushStyle
parameter_list|,
name|bool
name|invert
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|brushStyle
operator|>=
name|Qt
operator|::
name|Dense1Pattern
operator|&&
name|brushStyle
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_initialized
condition|)
cast|const_cast
argument_list|<
name|QBrushPatternImageCache
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|init
argument_list|()
expr_stmt|;
return|return
name|m_images
index|[
name|brushStyle
operator|-
name|Qt
operator|::
name|Dense1Pattern
index|]
index|[
name|invert
index|]
return|;
block|}
DECL|function|cleanup
name|void
name|cleanup
parameter_list|()
block|{
for|for
control|(
name|int
name|style
init|=
name|Qt
operator|::
name|Dense1Pattern
init|;
name|style
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
condition|;
operator|++
name|style
control|)
block|{
name|int
name|i
init|=
name|style
operator|-
name|Qt
operator|::
name|Dense1Pattern
decl_stmt|;
name|m_images
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|QImage
argument_list|()
expr_stmt|;
name|m_images
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
name|m_initialized
operator|=
literal|false
expr_stmt|;
block|}
private|private:
DECL|member|m_images
name|QImage
name|m_images
index|[
name|Qt
operator|::
name|DiagCrossPattern
operator|-
name|Qt
operator|::
name|Dense1Pattern
operator|+
literal|1
index|]
index|[
literal|2
index|]
decl_stmt|;
DECL|member|m_initialized
name|bool
name|m_initialized
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QBrushPatternImageCache
argument_list|,
argument|qt_brushPatternImageCache
argument_list|)
end_macro
begin_function
DECL|function|qt_cleanup_brush_pattern_image_cache
specifier|static
name|void
name|qt_cleanup_brush_pattern_image_cache
parameter_list|()
block|{
name|qt_brushPatternImageCache
argument_list|()
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_imageForBrush
name|Q_GUI_EXPORT
name|QImage
name|qt_imageForBrush
parameter_list|(
name|int
name|brushStyle
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
return|return
name|qt_brushPatternImageCache
argument_list|()
operator|->
name|getImage
argument_list|(
name|brushStyle
argument_list|,
name|invert
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|QTexturedBrushData
struct|struct
name|QTexturedBrushData
super|:
specifier|public
name|QBrushData
block|{
DECL|function|QTexturedBrushData
name|QTexturedBrushData
parameter_list|()
block|{
name|m_has_pixmap_texture
operator|=
literal|false
expr_stmt|;
name|m_pixmap
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~QTexturedBrushData
name|~
name|QTexturedBrushData
parameter_list|()
block|{
operator|delete
name|m_pixmap
expr_stmt|;
block|}
DECL|function|setPixmap
name|void
name|setPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pm
parameter_list|)
block|{
operator|delete
name|m_pixmap
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|m_pixmap
operator|=
literal|0
expr_stmt|;
name|m_has_pixmap_texture
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|m_pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|m_has_pixmap_texture
operator|=
literal|true
expr_stmt|;
block|}
name|m_image
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
DECL|function|setImage
name|void
name|setImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|m_image
operator|=
name|image
expr_stmt|;
operator|delete
name|m_pixmap
expr_stmt|;
name|m_pixmap
operator|=
literal|0
expr_stmt|;
name|m_has_pixmap_texture
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|pixmap
name|QPixmap
modifier|&
name|pixmap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_pixmap
condition|)
block|{
name|m_pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|m_image
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|m_pixmap
return|;
block|}
DECL|function|image
name|QImage
modifier|&
name|image
parameter_list|()
block|{
if|if
condition|(
name|m_image
operator|.
name|isNull
argument_list|()
operator|&&
name|m_pixmap
condition|)
name|m_image
operator|=
name|m_pixmap
operator|->
name|toImage
argument_list|()
expr_stmt|;
return|return
name|m_image
return|;
block|}
DECL|member|m_pixmap
name|QPixmap
modifier|*
name|m_pixmap
decl_stmt|;
DECL|member|m_image
name|QImage
name|m_image
decl_stmt|;
DECL|member|m_has_pixmap_texture
name|bool
name|m_has_pixmap_texture
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// returns true if the brush has a pixmap (or bitmap) set as the
end_comment
begin_comment
comment|// brush texture, false otherwise
end_comment
begin_function
DECL|function|qHasPixmapTexture
name|bool
name|Q_GUI_EXPORT
name|qHasPixmapTexture
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|TexturePattern
condition|)
return|return
literal|false
return|;
name|QTexturedBrushData
modifier|*
name|tx_data
init|=
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|brush
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|tx_data
operator|->
name|m_has_pixmap_texture
return|;
block|}
end_function
begin_struct
DECL|struct|QGradientBrushData
struct|struct
name|QGradientBrushData
super|:
specifier|public
name|QBrushData
block|{
DECL|member|gradient
name|QGradient
name|gradient
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|QBrushDataPointerDeleter
struct|struct
name|QBrushDataPointerDeleter
block|{
DECL|function|deleteData
specifier|static
specifier|inline
name|void
name|deleteData
parameter_list|(
name|QBrushData
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|TexturePattern
case|:
operator|delete
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
operator|delete
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|delete
name|d
expr_stmt|;
block|}
block|}
DECL|function|cleanup
specifier|static
specifier|inline
name|void
name|cleanup
parameter_list|(
name|QBrushData
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
name|deleteData
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
struct|;
end_struct
begin_comment
comment|/*!     \class QBrush     \ingroup painting     \ingroup shared     \inmodule QtGui      \brief The QBrush class defines the fill pattern of shapes drawn     by QPainter.      A brush has a style, a color, a gradient and a texture.      The brush style() defines the fill pattern using the     Qt::BrushStyle enum. The default brush style is Qt::NoBrush     (depending on how you construct a brush). This style tells the     painter to not fill shapes. The standard style for filling is     Qt::SolidPattern. The style can be set when the brush is created     using the appropriate constructor, and in addition the setStyle()     function provides means for altering the style once the brush is     constructed.      \image brush-styles.png Brush Styles      The brush color() defines the color of the fill pattern. The color     can either be one of Qt's predefined colors, Qt::GlobalColor, or     any other custom QColor. The currently set color can be retrieved     and altered using the color() and setColor() functions,     respectively.      The gradient() defines the gradient fill used when the current     style is either Qt::LinearGradientPattern,     Qt::RadialGradientPattern or Qt::ConicalGradientPattern. Gradient     brushes are created by giving a QGradient as a constructor     argument when creating the QBrush. Qt provides three different     gradients: QLinearGradient, QConicalGradient, and QRadialGradient     - all of which inherit QGradient.      \snippet brush/gradientcreationsnippet.cpp 0      The texture() defines the pixmap used when the current style is     Qt::TexturePattern.  You can create a brush with a texture by     providing the pixmap when the brush is created or by using     setTexture().      Note that applying setTexture() makes style() ==     Qt::TexturePattern, regardless of previous style     settings. Also, calling setColor() will not make a difference if     the style is a gradient. The same is the case if the style is     Qt::TexturePattern style unless the current texture is a QBitmap.      The isOpaque() function returns \c true if the brush is fully opaque     otherwise false. A brush is considered opaque if:      \list     \li The alpha component of the color() is 255.     \li Its texture() does not have an alpha channel and is not a QBitmap.     \li The colors in the gradient() all have an alpha component that is 255.     \endlist      \table 100%     \row     \li \inlineimage brush-outline.png Outlines     \li      To specify the style and color of lines and outlines, use the     QPainter's \l {QPen}{pen} combined with Qt::PenStyle and     Qt::GlobalColor:      \snippet code/src_gui_painting_qbrush.cpp 0      Note that, by default, QPainter renders the outline (using the     currently set pen) when drawing shapes. Use \l {Qt::NoPen}{\c     painter.setPen(Qt::NoPen)} to disable this behavior.      \endtable      For more information about painting in general, see the \l{Paint     System}.      \sa Qt::BrushStyle, QPainter, QColor */
end_comment
begin_class
DECL|class|QNullBrushData
class|class
name|QNullBrushData
block|{
public|public:
DECL|member|brush
name|QBrushData
modifier|*
name|brush
decl_stmt|;
DECL|function|QNullBrushData
name|QNullBrushData
parameter_list|()
member_init_list|:
name|brush
argument_list|(
operator|new
name|QBrushData
argument_list|)
block|{
name|brush
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|brush
operator|->
name|style
operator|=
name|Qt
operator|::
name|BrushStyle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|brush
operator|->
name|color
operator|=
name|Qt
operator|::
name|black
expr_stmt|;
block|}
DECL|function|~QNullBrushData
name|~
name|QNullBrushData
parameter_list|()
block|{
if|if
condition|(
operator|!
name|brush
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|brush
expr_stmt|;
name|brush
operator|=
literal|0
expr_stmt|;
block|}
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QNullBrushData
argument_list|,
argument|nullBrushInstance_holder
argument_list|)
end_macro
begin_function
DECL|function|nullBrushInstance
specifier|static
name|QBrushData
modifier|*
name|nullBrushInstance
parameter_list|()
block|{
return|return
name|nullBrushInstance_holder
argument_list|()
operator|->
name|brush
return|;
block|}
end_function
begin_function
DECL|function|qbrush_check_type
specifier|static
name|bool
name|qbrush_check_type
parameter_list|(
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|TexturePattern
case|:
name|qWarning
argument_list|(
literal|"QBrush: Incorrect use of TexturePattern"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
name|qWarning
argument_list|(
literal|"QBrush: Wrong use of a gradient pattern"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Initializes the brush. */
end_comment
begin_function
DECL|function|init
name|void
name|QBrush
operator|::
name|init
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|NoBrush
case|:
name|d
operator|.
name|reset
argument_list|(
name|nullBrushInstance
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|->
name|color
operator|!=
name|color
condition|)
name|setColor
argument_list|(
name|color
argument_list|)
expr_stmt|;
return|return;
case|case
name|Qt
operator|::
name|TexturePattern
case|:
name|d
operator|.
name|reset
argument_list|(
operator|new
name|QTexturedBrushData
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
name|d
operator|.
name|reset
argument_list|(
operator|new
name|QGradientBrushData
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|.
name|reset
argument_list|(
operator|new
name|QBrushData
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|style
operator|=
name|style
expr_stmt|;
name|d
operator|->
name|color
operator|=
name|color
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a default black brush with the style Qt::NoBrush     (i.e. this brush will not fill shapes). */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|()
member_init_list|:
name|d
argument_list|(
name|nullBrushInstance
argument_list|()
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a brush with a black color and a texture set to the     given \a pixmap. The style is set to Qt::TexturePattern.      \sa setTexture() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|init
argument_list|(
name|Qt
operator|::
name|black
argument_list|,
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|setTexture
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a brush with a black color and a texture set to the     given \a image. The style is set to Qt::TexturePattern.      \sa setTextureImage() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|init
argument_list|(
name|Qt
operator|::
name|black
argument_list|,
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|setTextureImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a black brush with the given \a style.      \sa setStyle() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
if|if
condition|(
name|qbrush_check_type
argument_list|(
name|style
argument_list|)
condition|)
name|init
argument_list|(
name|Qt
operator|::
name|black
argument_list|,
name|style
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|.
name|reset
argument_list|(
name|nullBrushInstance
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a brush with the given \a color and \a style.      \sa setColor(), setStyle() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
if|if
condition|(
name|qbrush_check_type
argument_list|(
name|style
argument_list|)
condition|)
name|init
argument_list|(
name|color
argument_list|,
name|style
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|.
name|reset
argument_list|(
name|nullBrushInstance
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \fn QBrush::QBrush(Qt::GlobalColor color, Qt::BrushStyle style)      Constructs a brush with the given \a color and \a style.      \sa setColor(), setStyle() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
name|Qt
operator|::
name|GlobalColor
name|color
parameter_list|,
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
if|if
condition|(
name|qbrush_check_type
argument_list|(
name|style
argument_list|)
condition|)
name|init
argument_list|(
name|color
argument_list|,
name|style
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|.
name|reset
argument_list|(
name|nullBrushInstance
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a brush with the given \a color and the custom pattern     stored in \a pixmap.      The style is set to Qt::TexturePattern. The color will only have     an effect for QBitmaps.      \sa setColor(), setTexture() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|init
argument_list|(
name|color
argument_list|,
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|setTexture
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!      Constructs a brush with the given \a color and the custom pattern     stored in \a pixmap.      The style is set to Qt::TexturePattern. The color will only have     an effect for QBitmaps.      \sa setColor(), setTexture() */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
name|Qt
operator|::
name|GlobalColor
name|color
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|init
argument_list|(
name|color
argument_list|,
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|setTexture
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a brush based on the given \a gradient.      The brush style is set to the corresponding gradient style (either     Qt::LinearGradientPattern, Qt::RadialGradientPattern or     Qt::ConicalGradientPattern). */
end_comment
begin_constructor
DECL|function|QBrush
name|QBrush
operator|::
name|QBrush
parameter_list|(
specifier|const
name|QGradient
modifier|&
name|gradient
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|gradient
operator|.
name|type
argument_list|()
operator|!=
name|QGradient
operator|::
name|NoGradient
argument_list|,
literal|"QBrush::QBrush"
argument_list|,
literal|"QGradient should not be used directly, use the linear, radial\n"
literal|"or conical gradients instead"
argument_list|)
expr_stmt|;
specifier|const
name|Qt
operator|::
name|BrushStyle
name|enum_table
index|[]
init|=
block|{
name|Qt
operator|::
name|LinearGradientPattern
block|,
name|Qt
operator|::
name|RadialGradientPattern
block|,
name|Qt
operator|::
name|ConicalGradientPattern
block|}
decl_stmt|;
name|init
argument_list|(
name|QColor
argument_list|()
argument_list|,
name|enum_table
index|[
name|gradient
operator|.
name|type
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|QGradientBrushData
modifier|*
name|grad
init|=
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|grad
operator|->
name|gradient
operator|=
name|gradient
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the brush. */
end_comment
begin_destructor
DECL|function|~QBrush
name|QBrush
operator|::
name|~
name|QBrush
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|cleanUp
name|void
name|QBrush
operator|::
name|cleanUp
parameter_list|(
name|QBrushData
modifier|*
name|x
parameter_list|)
block|{
name|QBrushDataPointerDeleter
operator|::
name|deleteData
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detach
name|void
name|QBrush
operator|::
name|detach
parameter_list|(
name|Qt
operator|::
name|BrushStyle
name|newStyle
parameter_list|)
block|{
if|if
condition|(
name|newStyle
operator|==
name|d
operator|->
name|style
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QScopedPointer
argument_list|<
name|QBrushData
argument_list|>
name|x
decl_stmt|;
switch|switch
condition|(
name|newStyle
condition|)
block|{
case|case
name|Qt
operator|::
name|TexturePattern
case|:
block|{
name|QTexturedBrushData
modifier|*
name|tbd
init|=
operator|new
name|QTexturedBrushData
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
name|QTexturedBrushData
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m_has_pixmap_texture
condition|)
name|tbd
operator|->
name|setPixmap
argument_list|(
name|data
operator|->
name|pixmap
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tbd
operator|->
name|setImage
argument_list|(
name|data
operator|->
name|image
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|x
operator|.
name|reset
argument_list|(
name|tbd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
name|x
operator|.
name|reset
argument_list|(
operator|new
name|QGradientBrushData
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|x
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|gradient
operator|=
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|gradient
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
name|x
operator|.
name|reset
argument_list|(
operator|new
name|QBrushData
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|->
name|style
operator|=
name|newStyle
expr_stmt|;
name|x
operator|->
name|color
operator|=
name|d
operator|->
name|color
expr_stmt|;
name|x
operator|->
name|transform
operator|=
name|d
operator|->
name|transform
expr_stmt|;
name|d
operator|.
name|reset
argument_list|(
name|x
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QBrush&QBrush::operator=(const QBrush&brush)      Assigns the given \a brush to \e this brush and returns a     reference to \e this brush. */
end_comment
begin_function
DECL|function|operator =
name|QBrush
modifier|&
name|QBrush
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|b
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|b
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
name|b
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|.
name|reset
argument_list|(
name|b
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QBrush&QBrush::operator=(QBrush&&other)      Move-assigns \a other to this QBrush instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn void QBrush::swap(QBrush&other)     \since 4.8      Swaps brush \a other with this brush. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!    Returns the brush as a QVariant */
end_comment
begin_function
DECL|function|operator QVariant
name|QBrush
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Brush
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn Qt::BrushStyle QBrush::style() const      Returns the brush style.      \sa setStyle() */
end_comment
begin_comment
comment|/*!     Sets the brush style to \a style.      \sa style() */
end_comment
begin_function
DECL|function|setStyle
name|void
name|QBrush
operator|::
name|setStyle
parameter_list|(
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|style
condition|)
return|return;
if|if
condition|(
name|qbrush_check_type
argument_list|(
name|style
argument_list|)
condition|)
block|{
name|detach
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|d
operator|->
name|style
operator|=
name|style
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn const QColor&QBrush::color() const      Returns the brush color.      \sa setColor() */
end_comment
begin_comment
comment|/*!     \fn void QBrush::setColor(const QColor&color)      Sets the brush color to the given \a color.      Note that calling setColor() will not make a difference if the     style is a gradient. The same is the case if the style is     Qt::TexturePattern style unless the current texture is a QBitmap.      \sa color() */
end_comment
begin_function
DECL|function|setColor
name|void
name|QBrush
operator|::
name|setColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|color
operator|==
name|c
condition|)
return|return;
name|detach
argument_list|(
name|d
operator|->
name|style
argument_list|)
expr_stmt|;
name|d
operator|->
name|color
operator|=
name|c
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QBrush::setColor(Qt::GlobalColor color)     \overload      Sets the brush color to the given \a color. */
end_comment
begin_comment
comment|/*!     \fn QPixmap QBrush::texture() const      Returns the custom brush pattern, or a null pixmap if no custom brush pattern     has been set.      \sa setTexture() */
end_comment
begin_function
DECL|function|texture
name|QPixmap
name|QBrush
operator|::
name|texture
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|?
operator|(
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|)
operator|->
name|pixmap
argument_list|()
else|:
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the brush pixmap to \a pixmap. The style is set to     Qt::TexturePattern.      The current brush color will only have an effect for monochrome     pixmaps, i.e. for QPixmap::depth() == 1 (\l {QBitmap}{QBitmaps}).      \sa texture() */
end_comment
begin_function
DECL|function|setTexture
name|void
name|QBrush
operator|::
name|setTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|detach
argument_list|(
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|QTexturedBrushData
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|data
operator|->
name|setPixmap
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the custom brush pattern, or a null image if no custom     brush pattern has been set.      If the texture was set as a QPixmap it will be converted to a     QImage.      \sa setTextureImage() */
end_comment
begin_function
DECL|function|textureImage
name|QImage
name|QBrush
operator|::
name|textureImage
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|?
operator|(
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|)
operator|->
name|image
argument_list|()
else|:
name|QImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the brush image to \a image. The style is set to     Qt::TexturePattern.      Note the current brush color will \e not have any affect on     monochrome images, as opposed to calling setTexture() with a     QBitmap. If you want to change the color of monochrome image     brushes, either convert the image to QBitmap with \c     QBitmap::fromImage() and set the resulting QBitmap as a texture,     or change the entries in the color table for the image.      \sa textureImage(), setTexture() */
end_comment
begin_function
DECL|function|setTextureImage
name|void
name|QBrush
operator|::
name|setTextureImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|detach
argument_list|(
name|Qt
operator|::
name|TexturePattern
argument_list|)
expr_stmt|;
name|QTexturedBrushData
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|data
operator|->
name|setImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the gradient describing this brush. */
end_comment
begin_function
DECL|function|gradient
specifier|const
name|QGradient
modifier|*
name|QBrush
operator|::
name|gradient
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|||
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|||
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
block|{
return|return
operator|&
cast|static_cast
argument_list|<
specifier|const
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|gradient
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qt_isExtendedRadialGradient
name|Q_GUI_EXPORT
name|bool
name|qt_isExtendedRadialGradient
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|RadialGradientPattern
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
specifier|const
name|QRadialGradient
modifier|*
name|rg
init|=
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|g
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|rg
operator|->
name|focalRadius
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
name|QPointF
name|delta
init|=
name|rg
operator|->
name|focalPoint
argument_list|()
operator|-
name|rg
operator|->
name|center
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|.
name|x
argument_list|()
operator|*
name|delta
operator|.
name|x
argument_list|()
operator|+
name|delta
operator|.
name|y
argument_list|()
operator|*
name|delta
operator|.
name|y
argument_list|()
operator|>
name|rg
operator|->
name|radius
argument_list|()
operator|*
name|rg
operator|->
name|radius
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the brush is fully opaque otherwise false. A brush     is considered opaque if:      \list     \li The alpha component of the color() is 255.     \li Its texture() does not have an alpha channel and is not a QBitmap.     \li The colors in the gradient() all have an alpha component that is 255.     \li It is an extended radial gradient.     \endlist */
end_comment
begin_function
DECL|function|isOpaque
name|bool
name|QBrush
operator|::
name|isOpaque
parameter_list|()
specifier|const
block|{
name|bool
name|opaqueColor
init|=
name|d
operator|->
name|color
operator|.
name|alpha
argument_list|()
operator|==
literal|255
decl_stmt|;
comment|// Test awfully simple case first
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
return|return
name|opaqueColor
return|;
if|if
condition|(
name|qt_isExtendedRadialGradient
argument_list|(
operator|*
name|this
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|||
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|||
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
block|{
name|QGradientStops
name|stops
init|=
name|gradient
argument_list|()
operator|->
name|stops
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|stops
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
return|return
name|qHasPixmapTexture
argument_list|(
operator|*
name|this
argument_list|)
condition|?
operator|!
name|texture
argument_list|()
operator|.
name|hasAlphaChannel
argument_list|()
operator|&&
operator|!
name|texture
argument_list|()
operator|.
name|isQBitmap
argument_list|()
else|:
operator|!
name|textureImage
argument_list|()
operator|.
name|hasAlphaChannel
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets \a matrix as an explicit transformation matrix on the     current brush. The brush transformation matrix is merged with     QPainter transformation matrix to produce the final result.      \sa matrix() */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QBrush
operator|::
name|setMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Sets \a matrix as an explicit transformation matrix on the     current brush. The brush transformation matrix is merged with     QPainter transformation matrix to produce the final result.      \sa transform() */
end_comment
begin_function
DECL|function|setTransform
name|void
name|QBrush
operator|::
name|setTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
block|{
name|detach
argument_list|(
name|d
operator|->
name|style
argument_list|)
expr_stmt|;
name|d
operator|->
name|transform
operator|=
name|matrix
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QBrush::matrix() const     \since 4.2      Returns the current transformation matrix for the brush.      \sa setMatrix() */
end_comment
begin_comment
comment|/*!     \fn bool QBrush::operator!=(const QBrush&brush) const      Returns \c true if the brush is different from the given \a brush;     otherwise returns \c false.      Two brushes are different if they have different styles, colors or     transforms or different pixmaps or gradients depending on the style.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn bool QBrush::operator==(const QBrush&brush) const      Returns \c true if the brush is equal to the given \a brush;     otherwise returns \c false.      Two brushes are equal if they have equal styles, colors and     transforms and equal pixmaps or gradients depending on the style.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QBrush
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|b
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|b
operator|.
name|d
operator|==
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|b
operator|.
name|d
operator|->
name|style
operator|!=
name|d
operator|->
name|style
operator|||
name|b
operator|.
name|d
operator|->
name|color
operator|!=
name|d
operator|->
name|color
operator|||
name|b
operator|.
name|d
operator|->
name|transform
operator|!=
name|d
operator|->
name|transform
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|d
operator|->
name|style
condition|)
block|{
case|case
name|Qt
operator|::
name|TexturePattern
case|:
block|{
specifier|const
name|QPixmap
modifier|&
name|us
init|=
operator|(
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|)
operator|->
name|pixmap
argument_list|()
decl_stmt|;
specifier|const
name|QPixmap
modifier|&
name|them
init|=
operator|(
cast|static_cast
argument_list|<
name|QTexturedBrushData
operator|*
argument_list|>
argument_list|(
name|b
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
operator|)
operator|->
name|pixmap
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|us
operator|.
name|isNull
argument_list|()
operator|&&
name|them
operator|.
name|isNull
argument_list|()
operator|)
operator|||
name|us
operator|.
name|cacheKey
argument_list|()
operator|==
name|them
operator|.
name|cacheKey
argument_list|()
operator|)
return|;
block|}
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
block|{
specifier|const
name|QGradientBrushData
modifier|*
name|d1
init|=
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QGradientBrushData
modifier|*
name|d2
init|=
cast|static_cast
argument_list|<
name|QGradientBrushData
operator|*
argument_list|>
argument_list|(
name|b
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d1
operator|->
name|gradient
operator|==
name|d2
operator|->
name|gradient
return|;
block|}
default|default:
return|return
literal|true
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|b
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|BRUSH_STYLES
index|[]
init|=
block|{
literal|"NoBrush"
block|,
literal|"SolidPattern"
block|,
literal|"Dense1Pattern"
block|,
literal|"Dense2Pattern"
block|,
literal|"Dense3Pattern"
block|,
literal|"Dense4Pattern"
block|,
literal|"Dense5Pattern"
block|,
literal|"Dense6Pattern"
block|,
literal|"Dense7Pattern"
block|,
literal|"HorPattern"
block|,
literal|"VerPattern"
block|,
literal|"CrossPattern"
block|,
literal|"BDiagPattern"
block|,
literal|"FDiagPattern"
block|,
literal|"DiagCrossPattern"
block|,
literal|"LinearGradientPattern"
block|,
literal|"RadialGradientPattern"
block|,
literal|"ConicalGradientPattern"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"TexturePattern"
comment|// 24
block|}
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QBrush("
operator|<<
name|b
operator|.
name|color
argument_list|()
operator|<<
literal|','
operator|<<
name|BRUSH_STYLES
index|[
name|b
operator|.
name|style
argument_list|()
index|]
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*****************************************************************************   QBrush stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QBrush&brush)     \relates QBrush      Writes the given \a brush to the given \a stream and returns a     reference to the \a stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|b
parameter_list|)
block|{
name|quint8
name|style
init|=
operator|(
name|quint8
operator|)
name|b
operator|.
name|style
argument_list|()
decl_stmt|;
name|bool
name|gradient_style
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|||
name|style
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|||
name|style
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
name|gradient_style
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_4_0
operator|&&
name|gradient_style
condition|)
name|style
operator|=
name|Qt
operator|::
name|NoBrush
expr_stmt|;
name|s
operator|<<
name|style
operator|<<
name|b
operator|.
name|color
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
name|s
operator|<<
name|b
operator|.
name|texture
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
operator|&&
name|gradient_style
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|gradient
init|=
name|b
operator|.
name|gradient
argument_list|()
decl_stmt|;
name|int
name|type_as_int
init|=
name|int
argument_list|(
name|gradient
operator|->
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|s
operator|<<
name|type_as_int
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
block|{
name|s
operator|<<
name|int
argument_list|(
name|gradient
operator|->
name|spread
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|<<
name|int
argument_list|(
name|gradient
operator|->
name|coordinateMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_5
condition|)
name|s
operator|<<
name|int
argument_list|(
name|gradient
operator|->
name|interpolationMode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
name|s
operator|<<
name|gradient
operator|->
name|stops
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// ensure that we write doubles here instead of streaming the stops
comment|// directly; otherwise, platforms that redefine qreal might generate
comment|// data that cannot be read on other platforms.
name|QVector
argument_list|<
name|QGradientStop
argument_list|>
name|stops
init|=
name|gradient
operator|->
name|stops
argument_list|()
decl_stmt|;
name|s
operator|<<
name|quint32
argument_list|(
name|stops
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QGradientStop
modifier|&
name|stop
init|=
name|stops
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|s
operator|<<
name|QPair
argument_list|<
name|double
argument_list|,
name|QColor
argument_list|>
argument_list|(
name|double
argument_list|(
name|stop
operator|.
name|first
argument_list|)
argument_list|,
name|stop
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gradient
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|LinearGradient
condition|)
block|{
name|s
operator|<<
cast|static_cast
argument_list|<
specifier|const
name|QLinearGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|start
argument_list|()
expr_stmt|;
name|s
operator|<<
cast|static_cast
argument_list|<
specifier|const
name|QLinearGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|finalStop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gradient
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|RadialGradient
condition|)
block|{
name|s
operator|<<
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|center
argument_list|()
expr_stmt|;
name|s
operator|<<
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|focalPoint
argument_list|()
expr_stmt|;
name|s
operator|<<
operator|(
name|double
operator|)
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|radius
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// type == Conical
name|s
operator|<<
cast|static_cast
argument_list|<
specifier|const
name|QConicalGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|center
argument_list|()
expr_stmt|;
name|s
operator|<<
operator|(
name|double
operator|)
cast|static_cast
argument_list|<
specifier|const
name|QConicalGradient
operator|*
argument_list|>
argument_list|(
name|gradient
argument_list|)
operator|->
name|angle
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
name|s
operator|<<
name|b
operator|.
name|transform
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QBrush&brush)     \relates QBrush      Reads the given \a brush from the given \a stream and returns a     reference to the \a stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QBrush
modifier|&
name|b
parameter_list|)
block|{
name|quint8
name|style
decl_stmt|;
name|QColor
name|color
decl_stmt|;
name|s
operator|>>
name|style
expr_stmt|;
name|s
operator|>>
name|color
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
name|QPixmap
name|pm
decl_stmt|;
name|s
operator|>>
name|pm
expr_stmt|;
name|b
operator|=
name|QBrush
argument_list|(
name|color
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|||
name|style
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|||
name|style
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
block|{
name|int
name|type_as_int
decl_stmt|;
name|QGradient
operator|::
name|Type
name|type
decl_stmt|;
name|QGradientStops
name|stops
decl_stmt|;
name|QGradient
operator|::
name|CoordinateMode
name|cmode
init|=
name|QGradient
operator|::
name|LogicalMode
decl_stmt|;
name|QGradient
operator|::
name|Spread
name|spread
init|=
name|QGradient
operator|::
name|PadSpread
decl_stmt|;
name|QGradient
operator|::
name|InterpolationMode
name|imode
init|=
name|QGradient
operator|::
name|ColorInterpolation
decl_stmt|;
name|s
operator|>>
name|type_as_int
expr_stmt|;
name|type
operator|=
name|QGradient
operator|::
name|Type
argument_list|(
name|type_as_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
block|{
name|s
operator|>>
name|type_as_int
expr_stmt|;
name|spread
operator|=
name|QGradient
operator|::
name|Spread
argument_list|(
name|type_as_int
argument_list|)
expr_stmt|;
name|s
operator|>>
name|type_as_int
expr_stmt|;
name|cmode
operator|=
name|QGradient
operator|::
name|CoordinateMode
argument_list|(
name|type_as_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_5
condition|)
block|{
name|s
operator|>>
name|type_as_int
expr_stmt|;
name|imode
operator|=
name|QGradient
operator|::
name|InterpolationMode
argument_list|(
name|type_as_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
name|s
operator|>>
name|stops
expr_stmt|;
block|}
else|else
block|{
name|quint32
name|numStops
decl_stmt|;
name|double
name|n
decl_stmt|;
name|QColor
name|c
decl_stmt|;
name|s
operator|>>
name|numStops
expr_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStops
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|>>
name|n
operator|>>
name|c
expr_stmt|;
name|stops
operator|<<
name|QPair
argument_list|<
name|qreal
argument_list|,
name|QColor
argument_list|>
argument_list|(
name|n
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|QGradient
operator|::
name|LinearGradient
condition|)
block|{
name|QPointF
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|s
operator|>>
name|p1
expr_stmt|;
name|s
operator|>>
name|p2
expr_stmt|;
name|QLinearGradient
name|lg
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
name|lg
operator|.
name|setStops
argument_list|(
name|stops
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setSpread
argument_list|(
name|spread
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setCoordinateMode
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setInterpolationMode
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|b
operator|=
name|QBrush
argument_list|(
name|lg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QGradient
operator|::
name|RadialGradient
condition|)
block|{
name|QPointF
name|center
decl_stmt|,
name|focal
decl_stmt|;
name|double
name|radius
decl_stmt|;
name|s
operator|>>
name|center
expr_stmt|;
name|s
operator|>>
name|focal
expr_stmt|;
name|s
operator|>>
name|radius
expr_stmt|;
name|QRadialGradient
name|rg
argument_list|(
name|center
argument_list|,
name|radius
argument_list|,
name|focal
argument_list|)
decl_stmt|;
name|rg
operator|.
name|setStops
argument_list|(
name|stops
argument_list|)
expr_stmt|;
name|rg
operator|.
name|setSpread
argument_list|(
name|spread
argument_list|)
expr_stmt|;
name|rg
operator|.
name|setCoordinateMode
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|rg
operator|.
name|setInterpolationMode
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|b
operator|=
name|QBrush
argument_list|(
name|rg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// type == QGradient::ConicalGradient
name|QPointF
name|center
decl_stmt|;
name|double
name|angle
decl_stmt|;
name|s
operator|>>
name|center
expr_stmt|;
name|s
operator|>>
name|angle
expr_stmt|;
name|QConicalGradient
name|cg
argument_list|(
name|center
argument_list|,
name|angle
argument_list|)
decl_stmt|;
name|cg
operator|.
name|setStops
argument_list|(
name|stops
argument_list|)
expr_stmt|;
name|cg
operator|.
name|setSpread
argument_list|(
name|spread
argument_list|)
expr_stmt|;
name|cg
operator|.
name|setCoordinateMode
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|cg
operator|.
name|setInterpolationMode
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|b
operator|=
name|QBrush
argument_list|(
name|cg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|b
operator|=
name|QBrush
argument_list|(
name|color
argument_list|,
operator|(
name|Qt
operator|::
name|BrushStyle
operator|)
name|style
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
block|{
name|QTransform
name|transform
decl_stmt|;
name|s
operator|>>
name|transform
expr_stmt|;
name|b
operator|.
name|setTransform
argument_list|(
name|transform
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*******************************************************************************  * QGradient implementations  */
end_comment
begin_comment
comment|/*!     \class QGradient     \ingroup painting     \ingroup shared     \inmodule QtGui      \brief The QGradient class is used in combination with QBrush to     specify gradient fills.      Qt currently supports three types of gradient fills:      \list     \li \e Linear gradients interpolate colors between start and end points.     \li \e Simple radial gradients interpolate colors between a focal point         and end points on a circle surrounding it.     \li \e Extended radial gradients interpolate colors between a center and         a focal circle.     \li \e Conical gradients interpolate colors around a center point.     \endlist      A gradient's type can be retrieved using the type() function.     Each of the types is represented by a subclass of QGradient:      \table     \header     \li QLinearGradient     \li QRadialGradient     \li QConicalGradient     \row     \li \inlineimage qgradient-linear.png     \li \inlineimage qgradient-radial.png     \li \inlineimage qgradient-conical.png     \endtable      The colors in a gradient are defined using stop points of the     QGradientStop type; i.e., a position and a color. Use the setColorAt()     function to define a single stop point. Alternatively, use the     setStops() function to define several stop points in one go. Note that     the latter function \e replaces the current set of stop points.      It is the gradient's complete set of stop points (accessible     through the stops() function) that describes how the gradient area     should be filled. If no stop points have been specified, a gradient     of black at 0 to white at 1 is used.      A diagonal linear gradient from black at (100, 100) to white at     (200, 200) could be specified like this:      \snippet brush/brush.cpp 0      A gradient can have an arbitrary number of stop points. The     following would create a radial gradient starting with     red in the center, blue and then green on the edges:      \snippet brush/brush.cpp 1      It is possible to repeat or reflect the gradient outside its area     by specifiying the \l {QGradient::Spread}{spread method} using the     setSpread() function. The default is to pad the outside area with     the color at the closest stop point. The currently set \l     {QGradient::Spread}{spread method} can be retrieved using the     spread() function. The QGradient::Spread enum defines three     different methods:      \table     \row     \li \inlineimage qradialgradient-pad.png     \li \inlineimage qradialgradient-repeat.png     \li \inlineimage qradialgradient-reflect.png     \row     \li \l {QGradient::PadSpread}{PadSpread}     \li \l {QGradient::RepeatSpread}{RepeatSpread}     \li \l {QGradient::ReflectSpread}{ReflectSpread}     \endtable      Note that the setSpread() function only has effect for linear and     radial gradients. The reason is that the conical gradient is     closed by definition, i.e. the \e conical gradient fills the     entire circle from 0 - 360 degrees, while the boundary of a radial     or a linear gradient can be specified through its radius or final     stop points, respectively.      The gradient coordinates can be specified in logical coordinates,     relative to device coordinates, or relative to object bounding box coordinates.     The \l {QGradient::CoordinateMode}{coordinate mode} can be set using the     setCoordinateMode() function. The default is LogicalMode, where the     gradient coordinates are specified in the same way as the object     coordinates. To retrieve the currently set \l {QGradient::CoordinateMode}     {coordinate mode} use coordinateMode().       \sa {painting/gradients}{The Gradients Example}, QBrush */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGradient
name|QGradient
operator|::
name|QGradient
parameter_list|()
member_init_list|:
name|m_type
argument_list|(
name|NoGradient
argument_list|)
member_init_list|,
name|dummy
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \enum QGradient::Type      Specifies the type of gradient.      \value LinearGradient  Interpolates colors between start and end points     (QLinearGradient).      \value RadialGradient Interpolate colors between a focal point and end     points on a circle surrounding it (QRadialGradient).      \value ConicalGradient Interpolate colors around a center point (QConicalGradient).     \value NoGradient No gradient is used.      \sa type() */
end_comment
begin_comment
comment|/*!     \enum QGradient::Spread      Specifies how the area outside the gradient area should be     filled.      \value PadSpread The area is filled with the closest stop     color. This is the default.      \value RepeatSpread The gradient  is repeated outside the gradient     area.      \value ReflectSpread The gradient is reflected outside the     gradient area.      \sa spread(), setSpread() */
end_comment
begin_comment
comment|/*!     \fn void QGradient::setSpread(Spread method)      Specifies the spread \a method that should be used for this     gradient.      Note that this function only has effect for linear and radial     gradients.      \sa spread() */
end_comment
begin_comment
comment|/*!     \fn QGradient::Spread QGradient::spread() const      Returns the spread method use by this gradient. The default is     PadSpread.      \sa setSpread() */
end_comment
begin_comment
comment|/*!     \fn QGradient::Type QGradient::type() const      Returns the type of gradient. */
end_comment
begin_comment
comment|/*!     \fn void QGradient::setColorAt(qreal position, const QColor&color)      Creates a stop point at the given \a position with the given \a     color. The given \a position must be in the range 0 to 1.      \sa setStops(), stops() */
end_comment
begin_function
DECL|function|setColorAt
name|void
name|QGradient
operator|::
name|setColorAt
parameter_list|(
name|qreal
name|pos
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pos
operator|>
literal|1
operator|||
name|pos
operator|<
literal|0
operator|)
operator|&&
operator|!
name|qIsNaN
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGradient::setColorAt: Color position must be specified in the range 0 to 1"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|pos
argument_list|)
condition|)
while|while
condition|(
name|index
operator|<
name|m_stops
operator|.
name|size
argument_list|()
operator|&&
name|m_stops
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|first
operator|<
name|pos
condition|)
operator|++
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|m_stops
operator|.
name|size
argument_list|()
operator|&&
name|m_stops
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|first
operator|==
name|pos
condition|)
name|m_stops
index|[
name|index
index|]
operator|.
name|second
operator|=
name|color
expr_stmt|;
else|else
name|m_stops
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|QGradientStop
argument_list|(
name|pos
argument_list|,
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGradient::setStops(const QGradientStops&stopPoints)      Replaces the current set of stop points with the given \a     stopPoints. The positions of the points must be in the range 0 to     1, and must be sorted with the lowest point first.      \sa setColorAt(), stops() */
end_comment
begin_function
DECL|function|setStops
name|void
name|QGradient
operator|::
name|setStops
parameter_list|(
specifier|const
name|QGradientStops
modifier|&
name|stops
parameter_list|)
block|{
name|m_stops
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|setColorAt
argument_list|(
name|stops
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|,
name|stops
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the stop points for this gradient.      If no stop points have been specified, a gradient of black at 0 to white     at 1 is used.      \sa setStops(), setColorAt() */
end_comment
begin_function
DECL|function|stops
name|QGradientStops
name|QGradient
operator|::
name|stops
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_stops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGradientStops
name|tmp
decl_stmt|;
name|tmp
operator|<<
name|QGradientStop
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|black
argument_list|)
operator|<<
name|QGradientStop
argument_list|(
literal|1
argument_list|,
name|Qt
operator|::
name|white
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
return|return
name|m_stops
return|;
block|}
end_function
begin_define
DECL|macro|Q_DUMMY_ACCESSOR
define|#
directive|define
name|Q_DUMMY_ACCESSOR
value|union {void *p; uint i;}; p = dummy;
end_define
begin_comment
comment|/*!     \enum QGradient::CoordinateMode     \since 4.4      This enum specifies how gradient coordinates map to the paint     device on which the gradient is used.      \value LogicalMode This is the default mode. The gradient coordinates     are specified logical space just like the object coordinates.     \value StretchToDeviceMode In this mode the gradient coordinates     are relative to the bounding rectangle of the paint device,     with (0,0) in the top left corner, and (1,1) in the bottom right     corner of the paint device.     \value ObjectBoundingMode In this mode the gradient coordinates are     relative to the bounding rectangle of the object being drawn, with     (0,0) in the top left corner, and (1,1) in the bottom right corner     of the object's bounding rectangle. */
end_comment
begin_comment
comment|/*!     \since 4.4      Returns the coordinate mode of this gradient. The default mode is     LogicalMode. */
end_comment
begin_function
DECL|function|coordinateMode
name|QGradient
operator|::
name|CoordinateMode
name|QGradient
operator|::
name|coordinateMode
parameter_list|()
specifier|const
block|{
name|Q_DUMMY_ACCESSOR
return|return
name|CoordinateMode
argument_list|(
name|i
operator|&
literal|0x03
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the coordinate mode of this gradient to \a mode. The default     mode is LogicalMode. */
end_comment
begin_function
DECL|function|setCoordinateMode
name|void
name|QGradient
operator|::
name|setCoordinateMode
parameter_list|(
name|CoordinateMode
name|mode
parameter_list|)
block|{
name|Q_DUMMY_ACCESSOR
name|i
decl|&=
name|~
decl|0x03
decl_stmt|;
name|i
operator||=
name|uint
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QGradient::InterpolationMode     \since 4.5     \internal      \value ComponentInterpolation The color components and the alpha component are     independently linearly interpolated.     \value ColorInterpolation The colors are linearly interpolated in     premultiplied color space. */
end_comment
begin_comment
comment|/*!     \since 4.5     \internal      Returns the interpolation mode of this gradient. The default mode is     ColorInterpolation. */
end_comment
begin_function
DECL|function|interpolationMode
name|QGradient
operator|::
name|InterpolationMode
name|QGradient
operator|::
name|interpolationMode
parameter_list|()
specifier|const
block|{
name|Q_DUMMY_ACCESSOR
return|return
name|InterpolationMode
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|0x01
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     \internal      Sets the interpolation mode of this gradient to \a mode. The default     mode is ColorInterpolation. */
end_comment
begin_function
DECL|function|setInterpolationMode
name|void
name|QGradient
operator|::
name|setInterpolationMode
parameter_list|(
name|InterpolationMode
name|mode
parameter_list|)
block|{
name|Q_DUMMY_ACCESSOR
name|i
decl|&=
name|~
argument_list|(
literal|1
operator|<<
literal|2
argument_list|)
decl_stmt|;
name|i
operator||=
operator|(
name|uint
argument_list|(
name|mode
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|dummy
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGradient::operator!=(const QGradient&gradient) const     \since 4.2      Returns \c true if the gradient is the same as the other \a gradient     specified; otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns \c true if the gradient is the same as the other \a gradient     specified; otherwise returns \c false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QGradient
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QGradient
modifier|&
name|gradient
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|gradient
operator|.
name|m_type
operator|!=
name|m_type
operator|||
name|gradient
operator|.
name|m_spread
operator|!=
name|m_spread
operator|||
name|gradient
operator|.
name|dummy
operator|!=
name|dummy
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|m_type
operator|==
name|LinearGradient
condition|)
block|{
if|if
condition|(
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|||
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|||
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|||
name|m_data
operator|.
name|linear
operator|.
name|y2
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|linear
operator|.
name|y2
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|m_type
operator|==
name|RadialGradient
condition|)
block|{
if|if
condition|(
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|||
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|||
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|||
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|||
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|radial
operator|.
name|cradius
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// m_type == ConicalGradient
if|if
condition|(
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|||
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|||
name|m_data
operator|.
name|conical
operator|.
name|angle
operator|!=
name|gradient
operator|.
name|m_data
operator|.
name|conical
operator|.
name|angle
condition|)
return|return
literal|false
return|;
block|}
return|return
name|stops
argument_list|()
operator|==
name|gradient
operator|.
name|stops
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QLinearGradient     \ingroup painting     \inmodule QtGui      \brief The QLinearGradient class is used in combination with QBrush to     specify a linear gradient brush.      Linear gradients interpolate colors between start and end     points. Outside these points the gradient is either padded,     reflected or repeated depending on the currently set \l     {QGradient::Spread}{spread} method:      \table     \row     \li \inlineimage qlineargradient-pad.png     \li \inlineimage qlineargradient-reflect.png     \li \inlineimage qlineargradient-repeat.png     \row     \li \l {QGradient::PadSpread}{PadSpread} (default)     \li \l {QGradient::ReflectSpread}{ReflectSpread}     \li \l {QGradient::RepeatSpread}{RepeatSpread}     \endtable      The colors in a gradient is defined using stop points of the     QGradientStop type, i.e. a position and a color. Use the     QGradient::setColorAt() or the QGradient::setStops() function to     define the stop points. It is the gradient's complete set of stop     points that describes how the gradient area should be filled. If     no stop points have been specified, a gradient of black at 0 to     white at 1 is used.      In addition to the functions inherited from QGradient, the     QLinearGradient class provides the finalStop() function which     returns the final stop point of the gradient, and the start()     function returning the start point of the gradient.      \sa QRadialGradient, QConicalGradient, {painting/gradients}{The     Gradients Example} */
end_comment
begin_comment
comment|/*!     Constructs a default linear gradient with interpolation area     between (0, 0) and (1, 1).      \sa QGradient::setColorAt(), setStart(), setFinalStop() */
end_comment
begin_constructor
DECL|function|QLinearGradient
name|QLinearGradient
operator|::
name|QLinearGradient
parameter_list|()
block|{
name|m_type
operator|=
name|LinearGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|=
literal|1
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y2
operator|=
literal|1
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a linear gradient with interpolation area between the     given \a start point and \a finalStop.      \note The expected parameter values are in pixels.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QLinearGradient
name|QLinearGradient
operator|::
name|QLinearGradient
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|start
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|finalStop
parameter_list|)
block|{
name|m_type
operator|=
name|LinearGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|=
name|start
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|=
name|start
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|=
name|finalStop
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y2
operator|=
name|finalStop
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QLinearGradient::QLinearGradient(qreal x1, qreal y1, qreal x2, qreal y2)      Constructs a linear gradient with interpolation area between (\a     x1, \a y1) and (\a x2, \a y2).      \note The expected parameter values are in pixels.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QLinearGradient
name|QLinearGradient
operator|::
name|QLinearGradient
parameter_list|(
name|qreal
name|xStart
parameter_list|,
name|qreal
name|yStart
parameter_list|,
name|qreal
name|xFinalStop
parameter_list|,
name|qreal
name|yFinalStop
parameter_list|)
block|{
name|m_type
operator|=
name|LinearGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|=
name|xStart
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|=
name|yStart
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|=
name|xFinalStop
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y2
operator|=
name|yFinalStop
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Returns the start point of this linear gradient in logical coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|start
name|QPointF
name|QLinearGradient
operator|::
name|start
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|LinearGradient
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|m_data
operator|.
name|linear
operator|.
name|x1
argument_list|,
name|m_data
operator|.
name|linear
operator|.
name|y1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLinearGradient::setStart(qreal x, qreal y)     \overload     \since 4.2      Sets the start point of this linear gradient in logical     coordinates to \a x, \a y.      \sa start() */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the start point of this linear gradient in logical     coordinates to \a start.      \sa start() */
end_comment
begin_function
DECL|function|setStart
name|void
name|QLinearGradient
operator|::
name|setStart
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|start
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|LinearGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x1
operator|=
name|start
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y1
operator|=
name|start
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLinearGradient::setFinalStop(qreal x, qreal y)     \overload     \since 4.2      Sets the final stop point of this linear gradient in logical     coordinates to \a x, \a y.      \sa start() */
end_comment
begin_comment
comment|/*!     Returns the final stop point of this linear gradient in logical coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|finalStop
name|QPointF
name|QLinearGradient
operator|::
name|finalStop
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|LinearGradient
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|m_data
operator|.
name|linear
operator|.
name|x2
argument_list|,
name|m_data
operator|.
name|linear
operator|.
name|y2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the final stop point of this linear gradient in logical     coordinates to \a stop.      \sa finalStop() */
end_comment
begin_function
DECL|function|setFinalStop
name|void
name|QLinearGradient
operator|::
name|setFinalStop
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|stop
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|LinearGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|x2
operator|=
name|stop
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|linear
operator|.
name|y2
operator|=
name|stop
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QRadialGradient     \ingroup painting     \inmodule QtGui      \brief The QRadialGradient class is used in combination with QBrush to     specify a radial gradient brush.      Qt supports both simple and extended radial gradients.      Simple radial gradients interpolate colors between a focal point and end     points on a circle surrounding it. Extended radial gradients interpolate     colors between a focal circle and a center circle. Points outside the cone     defined by the two circles will be transparent. For simple radial gradients     the focal point is adjusted to lie inside the center circle, whereas the     focal point can have any position in an extended radial gradient.      Outside the end points the gradient is either padded, reflected or repeated     depending on the currently set \l {QGradient::Spread}{spread} method:      \table     \row     \li \inlineimage qradialgradient-pad.png     \li \inlineimage qradialgradient-reflect.png     \li \inlineimage qradialgradient-repeat.png     \row     \li \l {QGradient::PadSpread}{PadSpread} (default)     \li \l {QGradient::ReflectSpread}{ReflectSpread}     \li \l {QGradient::RepeatSpread}{RepeatSpread}     \endtable      The colors in a gradient is defined using stop points of the     QGradientStop type, i.e. a position and a color. Use the     QGradient::setColorAt() or the QGradient::setStops() function to     define the stop points. It is the gradient's complete set of stop     points that describes how the gradient area should be filled.  If     no stop points have been specified, a gradient of black at 0 to     white at 1 is used.      In addition to the functions inherited from QGradient, the     QRadialGradient class provides the center(), focalPoint() and     radius() functions returning the gradient's center, focal point     and radius respectively.      \sa QLinearGradient, QConicalGradient, {painting/gradients}{The     Gradients Example} */
end_comment
begin_function
DECL|function|qt_radial_gradient_adapt_focal_point
specifier|static
name|QPointF
name|qt_radial_gradient_adapt_focal_point
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|,
name|qreal
name|radius
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|focalPoint
parameter_list|)
block|{
comment|// We have a one pixel buffer zone to avoid numerical instability on the
comment|// circle border
comment|//### this is hacky because technically we should adjust based on current matrix
specifier|const
name|qreal
name|compensated_radius
init|=
name|radius
operator|-
name|radius
operator|*
name|qreal
argument_list|(
literal|0.001
argument_list|)
decl_stmt|;
name|QLineF
name|line
argument_list|(
name|center
argument_list|,
name|focalPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
operator|(
name|compensated_radius
operator|)
condition|)
name|line
operator|.
name|setLength
argument_list|(
name|compensated_radius
argument_list|)
expr_stmt|;
return|return
name|line
operator|.
name|p2
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a simple radial gradient with the given \a center, \a     radius and \a focalPoint.      \note If the given focal point is outside the circle defined by the     \a center point and \a radius, it will be re-adjusted to lie at a point on     the circle where it intersects with the line from \a center to     \a focalPoint.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|,
name|qreal
name|radius
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|focalPoint
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
name|QPointF
name|adapted_focal
init|=
name|qt_radial_gradient_adapt_focal_point
argument_list|(
name|center
argument_list|,
name|radius
argument_list|,
name|focalPoint
argument_list|)
decl_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|adapted_focal
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|adapted_focal
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a simple radial gradient with the given \a center, \a     radius and the focal point in the circle center.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|,
name|qreal
name|radius
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a simple radial gradient with the given center (\a cx, \a cy),     \a radius and focal point (\a fx, \a fy).      \note If the given focal point is outside the circle defined by the     center (\a cx, \a cy) and the \a radius it will be re-adjusted to     the intersection between the line from the center to the focal point     and the circle.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
name|qreal
name|cx
parameter_list|,
name|qreal
name|cy
parameter_list|,
name|qreal
name|radius
parameter_list|,
name|qreal
name|fx
parameter_list|,
name|qreal
name|fy
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|cy
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
name|QPointF
name|adapted_focal
init|=
name|qt_radial_gradient_adapt_focal_point
argument_list|(
name|QPointF
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|)
argument_list|,
name|radius
argument_list|,
name|QPointF
argument_list|(
name|fx
argument_list|,
name|fy
argument_list|)
argument_list|)
decl_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|adapted_focal
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|adapted_focal
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a simple radial gradient with the center at (\a cx, \a cy) and the     specified \a radius. The focal point lies at the center of the circle.      \sa QGradient::setColorAt(), QGradient::setStops()  */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
name|qreal
name|cx
parameter_list|,
name|qreal
name|cy
parameter_list|,
name|qreal
name|radius
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|cy
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|cx
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|cy
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a simple radial gradient with the center and focal point at     (0, 0) with a radius of 1. */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|()
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
literal|1
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \since 4.8      Constructs an extended radial gradient with the given \a center, \a     centerRadius, \a focalPoint, and \a focalRadius. */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|,
name|qreal
name|centerRadius
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|focalPoint
parameter_list|,
name|qreal
name|focalRadius
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|centerRadius
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|focalPoint
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|focalPoint
operator|.
name|y
argument_list|()
expr_stmt|;
name|setFocalRadius
argument_list|(
name|focalRadius
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \since 4.8      Constructs an extended radial gradient with the given center     (\a cx, \a cy), center radius, \a centerRadius, focal point, (\a fx, \a fy),     and focal radius \a focalRadius. */
end_comment
begin_constructor
DECL|function|QRadialGradient
name|QRadialGradient
operator|::
name|QRadialGradient
parameter_list|(
name|qreal
name|cx
parameter_list|,
name|qreal
name|cy
parameter_list|,
name|qreal
name|centerRadius
parameter_list|,
name|qreal
name|fx
parameter_list|,
name|qreal
name|fy
parameter_list|,
name|qreal
name|focalRadius
parameter_list|)
block|{
name|m_type
operator|=
name|RadialGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|cy
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|centerRadius
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|fx
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|fy
expr_stmt|;
name|setFocalRadius
argument_list|(
name|focalRadius
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Returns the center of this radial gradient in logical coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|center
name|QPointF
name|QRadialGradient
operator|::
name|center
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|m_data
operator|.
name|radial
operator|.
name|cx
argument_list|,
name|m_data
operator|.
name|radial
operator|.
name|cy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRadialGradient::setCenter(qreal x, qreal y)     \overload     \since 4.2      Sets the center of this radial gradient in logical coordinates     to (\a x, \a y).      \sa center() */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the center of this radial gradient in logical coordinates     to \a center.      \sa center() */
end_comment
begin_function
DECL|function|setCenter
name|void
name|QRadialGradient
operator|::
name|setCenter
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the radius of this radial gradient in logical coordinates.      Equivalent to centerRadius()      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|radius
name|qreal
name|QRadialGradient
operator|::
name|radius
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
return|return
name|m_data
operator|.
name|radial
operator|.
name|cradius
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the radius of this radial gradient in logical coordinates     to \a radius      Equivalent to setCenterRadius() */
end_comment
begin_function
DECL|function|setRadius
name|void
name|QRadialGradient
operator|::
name|setRadius
parameter_list|(
name|qreal
name|radius
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the center radius of this radial gradient in logical     coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|centerRadius
name|qreal
name|QRadialGradient
operator|::
name|centerRadius
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
return|return
name|m_data
operator|.
name|radial
operator|.
name|cradius
return|;
block|}
end_function
begin_comment
comment|/*!    \since 4.8     Sets the center radius of this radial gradient in logical coordinates    to \a radius */
end_comment
begin_function
DECL|function|setCenterRadius
name|void
name|QRadialGradient
operator|::
name|setCenterRadius
parameter_list|(
name|qreal
name|radius
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|cradius
operator|=
name|radius
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the focal radius of this radial gradient in logical     coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|focalRadius
name|qreal
name|QRadialGradient
operator|::
name|focalRadius
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|Q_DUMMY_ACCESSOR
comment|// mask away low three bits
union|union
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|i
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
operator|=
name|i
operator|&
operator|~
literal|0x07
expr_stmt|;
return|return
name|u
operator|.
name|f
return|;
block|}
end_function
begin_comment
comment|/*!    \since 4.8     Sets the focal radius of this radial gradient in logical coordinates    to \a radius */
end_comment
begin_function
DECL|function|setFocalRadius
name|void
name|QRadialGradient
operator|::
name|setFocalRadius
parameter_list|(
name|qreal
name|radius
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|Q_DUMMY_ACCESSOR
comment|// Since there's no QGradientData, we only have the dummy void * to
comment|// store additional data in. The three lowest bits are already
comment|// taken, thus we cut the three lowest bits from the significand
comment|// and store the radius as a float.
union|union
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|i
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|f
operator|=
name|float
argument_list|(
name|radius
argument_list|)
expr_stmt|;
comment|// add 0x04 to round up when we drop the three lowest bits
name|i
operator||=
operator|(
name|u
operator|.
name|i
operator|+
literal|0x04
operator|)
operator|&
operator|~
literal|0x07
expr_stmt|;
name|dummy
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the focal point of this radial gradient in logical     coordinates.      \sa QGradient::stops() */
end_comment
begin_function
DECL|function|focalPoint
name|QPointF
name|QRadialGradient
operator|::
name|focalPoint
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|m_data
operator|.
name|radial
operator|.
name|fx
argument_list|,
name|m_data
operator|.
name|radial
operator|.
name|fy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRadialGradient::setFocalPoint(qreal x, qreal y)     \overload     \since 4.2      Sets the focal point of this radial gradient in logical     coordinates to (\a x, \a y).      \sa focalPoint() */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the focal point of this radial gradient in logical     coordinates to \a focalPoint.      \sa focalPoint() */
end_comment
begin_function
DECL|function|setFocalPoint
name|void
name|QRadialGradient
operator|::
name|setFocalPoint
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|focalPoint
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|RadialGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fx
operator|=
name|focalPoint
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|radial
operator|.
name|fy
operator|=
name|focalPoint
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QConicalGradient     \ingroup painting     \inmodule QtGui      \brief The QConicalGradient class is used in combination with QBrush to     specify a conical gradient brush.      Conical gradients interpolate interpolate colors counter-clockwise     around a center point.      \image qconicalgradient.png      The colors in a gradient is defined using stop points of the     QGradientStop type, i.e. a position and a color. Use the     QGradient::setColorAt() or the QGradient::setStops() function to     define the stop points. It is the gradient's complete set of stop     points that describes how the gradient area should be filled. If     no stop points have been specified, a gradient of black at 0 to     white at 1 is used.      In addition to the functions inherited from QGradient, the     QConicalGradient class provides the angle() and center() functions     returning the start angle and center of the gradient.      Note that the setSpread() function has no effect for conical     gradients. The reason is that the conical gradient is closed by     definition, i.e. the conical gradient fills the entire circle from     0 - 360 degrees, while the boundary of a radial or a linear     gradient can be specified through its radius or final stop points,     respectively.      \sa QLinearGradient, QRadialGradient, {painting/gradients}{The     Gradients Example} */
end_comment
begin_comment
comment|/*!     Constructs a conical gradient with the given \a center, starting     the interpolation at the given \a angle. The \a angle must be     specified in degrees between 0 and 360.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QConicalGradient
name|QConicalGradient
operator|::
name|QConicalGradient
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|,
name|qreal
name|angle
parameter_list|)
block|{
name|m_type
operator|=
name|ConicalGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|angle
operator|=
name|angle
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a conical gradient with the given center (\a cx, \a     cy), starting the interpolation at the given \a angle. The angle     must be specified in degrees between 0 and 360.      \sa QGradient::setColorAt(), QGradient::setStops() */
end_comment
begin_constructor
DECL|function|QConicalGradient
name|QConicalGradient
operator|::
name|QConicalGradient
parameter_list|(
name|qreal
name|cx
parameter_list|,
name|qreal
name|cy
parameter_list|,
name|qreal
name|angle
parameter_list|)
block|{
name|m_type
operator|=
name|ConicalGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|=
name|cy
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|angle
operator|=
name|angle
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a conical with center at (0, 0) starting the     interpolation at angle 0.      \sa QGradient::setColorAt(), setCenter(), setAngle() */
end_comment
begin_constructor
DECL|function|QConicalGradient
name|QConicalGradient
operator|::
name|QConicalGradient
parameter_list|()
block|{
name|m_type
operator|=
name|ConicalGradient
expr_stmt|;
name|m_spread
operator|=
name|PadSpread
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|=
literal|0
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|angle
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Returns the center of the conical gradient in logical     coordinates.      \sa stops() */
end_comment
begin_function
DECL|function|center
name|QPointF
name|QConicalGradient
operator|::
name|center
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|ConicalGradient
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|m_data
operator|.
name|conical
operator|.
name|cx
argument_list|,
name|m_data
operator|.
name|conical
operator|.
name|cy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QConicalGradient::setCenter(qreal x, qreal y)      \overload      Sets the center of this conical gradient in logical coordinates to     (\a x, \a y).      \sa center() */
end_comment
begin_comment
comment|/*!     Sets the center of this conical gradient in logical coordinates to     \a center.      \sa center() */
end_comment
begin_function
DECL|function|setCenter
name|void
name|QConicalGradient
operator|::
name|setCenter
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|center
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|ConicalGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cx
operator|=
name|center
operator|.
name|x
argument_list|()
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|cy
operator|=
name|center
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the start angle of the conical gradient in logical     coordinates.      \sa stops() */
end_comment
begin_function
DECL|function|angle
name|qreal
name|QConicalGradient
operator|::
name|angle
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|ConicalGradient
argument_list|)
expr_stmt|;
return|return
name|m_data
operator|.
name|conical
operator|.
name|angle
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets \a angle to be the start angle for this conical gradient in     logical coordinates.      \sa angle() */
end_comment
begin_function
DECL|function|setAngle
name|void
name|QConicalGradient
operator|::
name|setAngle
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_type
operator|==
name|ConicalGradient
argument_list|)
expr_stmt|;
name|m_data
operator|.
name|conical
operator|.
name|angle
operator|=
name|angle
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QGradientStop     \relates QGradient      Typedef for QPair<\l qreal, QColor>. */
end_comment
begin_comment
comment|/*!     \typedef QGradientStops     \relates QGradient      Typedef for QVector<QGradientStop>. */
end_comment
begin_comment
comment|/*!     \typedef QBrush::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QBrush::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     \fn bool QBrush::isDetached() const     \internal */
end_comment
begin_comment
comment|/*!     \fn QTransform QBrush::transform() const     \since 4.3      Returns the current transformation matrix for the brush.      \sa setTransform() */
end_comment
begin_undef
DECL|macro|Q_DUMMY_ACCESSOR
undef|#
directive|undef
name|Q_DUMMY_ACCESSOR
end_undef
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
