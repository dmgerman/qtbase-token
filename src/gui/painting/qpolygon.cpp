begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath_p.h"
end_include
begin_include
include|#
directive|include
file|"qbezier_p.h"
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|//same as qt_painterpath_isect_line in qpainterpath.cpp
DECL|function|qt_polygon_isect_line
specifier|static
name|void
name|qt_polygon_isect_line
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p2
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|int
modifier|*
name|winding
parameter_list|)
block|{
name|qreal
name|x1
init|=
name|p1
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y1
init|=
name|p1
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|x2
init|=
name|p2
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y2
init|=
name|p2
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|dir
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
condition|)
block|{
comment|// ignore horizontal lines according to scan conversion rule
return|return;
block|}
elseif|else
if|if
condition|(
name|y2
operator|<
name|y1
condition|)
block|{
name|qreal
name|x_tmp
init|=
name|x2
decl_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|x_tmp
expr_stmt|;
name|qreal
name|y_tmp
init|=
name|y2
decl_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|y_tmp
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>=
name|y1
operator|&&
name|y
operator|<
name|y2
condition|)
block|{
name|qreal
name|x
init|=
name|x1
operator|+
operator|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
operator|(
name|y2
operator|-
name|y1
operator|)
operator|)
operator|*
operator|(
name|y
operator|-
name|y1
operator|)
decl_stmt|;
comment|// count up the winding number if we're
if|if
condition|(
name|x
operator|<=
name|pos
operator|.
name|x
argument_list|()
condition|)
block|{
operator|(
operator|*
name|winding
operator|)
operator|+=
name|dir
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \class QPolygon     \brief The QPolygon class provides a vector of points using     integer precision.     \inmodule QtGui      \reentrant      \ingroup painting     \ingroup shared      A QPolygon object is a QVector<QPoint>.  The easiest way to add     points to a QPolygon is to use QVector's streaming operator, as     illustrated below:      \snippet polygon/polygon.cpp 0      In addition to the functions provided by QVector, QPolygon     provides some point-specific functions.      Each point in a polygon can be retrieved by passing its index to     the point() function. To populate the polygon, QPolygon provides     the setPoint() function to set the point at a given index, the     setPoints() function to set all the points in the polygon     (resizing it to the given number of points), and the putPoints()     function which copies a number of given points into the polygon     from a specified index (resizing the polygon if necessary).      QPolygon provides the boundingRect() and translate() functions for     geometry functions. Use the QMatrix::map() function for more     general transformations of QPolygons.      The QPolygon class is \l {Implicit Data Sharing}{implicitly     shared}.      \sa QVector, QPolygonF, QLine */
end_comment
begin_comment
comment|/*****************************************************************************   QPolygon member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QPolygon::QPolygon()      Constructs a polygon with no points.      \sa QVector::isEmpty() */
end_comment
begin_comment
comment|/*!     \fn QPolygon::QPolygon(int size)      Constructs a polygon of the given \a size. Creates an empty     polygon if \a size == 0.      \sa QVector::isEmpty() */
end_comment
begin_comment
comment|/*!     \fn QPolygon::QPolygon(const QPolygon&polygon)      Constructs a copy of the given \a polygon.      \sa setPoints() */
end_comment
begin_comment
comment|/*!     \fn QPolygon::QPolygon(const QVector<QPoint>&points)      Constructs a polygon containing the specified \a points.      \sa setPoints() */
end_comment
begin_comment
comment|/*!     \fn QPolygon::QPolygon(const QRect&rectangle, bool closed)      Constructs a polygon from the given \a rectangle.  If \a closed is     false, the polygon just contains the four points of the rectangle     ordered clockwise, otherwise the polygon's fifth point is set to     \a {rectangle}.topLeft().      Note that the bottom-right corner of the rectangle is located at     (rectangle.x() + rectangle.width(), rectangle.y() +     rectangle.height()).      \sa setPoints() */
end_comment
begin_constructor
DECL|function|QPolygon
name|QPolygon
operator|::
name|QPolygon
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|bool
name|closed
parameter_list|)
block|{
name|reserve
argument_list|(
name|closed
condition|?
literal|5
else|:
literal|4
argument_list|)
expr_stmt|;
operator|*
name|this
operator|<<
name|QPoint
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
operator|<<
name|QPoint
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
operator|<<
name|QPoint
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
argument_list|)
operator|<<
name|QPoint
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|closed
condition|)
operator|*
name|this
operator|<<
name|QPoint
argument_list|(
name|r
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal     Constructs a point array with \a nPoints points, taken from the     \a points array.      Equivalent to setPoints(nPoints, points). */
end_comment
begin_constructor
DECL|function|QPolygon
name|QPolygon
operator|::
name|QPolygon
parameter_list|(
name|int
name|nPoints
parameter_list|,
specifier|const
name|int
modifier|*
name|points
parameter_list|)
block|{
name|setPoints
argument_list|(
name|nPoints
argument_list|,
name|points
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QPolygon::~QPolygon()      Destroys the polygon. */
end_comment
begin_comment
comment|/*!     Translates all points in the polygon by (\a{dx}, \a{dy}).      \sa translated() */
end_comment
begin_function
DECL|function|translate
name|void
name|QPolygon
operator|::
name|translate
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return;
name|QPoint
modifier|*
name|p
init|=
name|data
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|size
argument_list|()
decl_stmt|;
name|QPoint
name|pt
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
operator|*
name|p
operator|+=
name|pt
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygon::translate(const QPoint&offset)     \overload      Translates all points in the polygon by the given \a offset.      \sa translated() */
end_comment
begin_comment
comment|/*!     Returns a copy of the polygon that is translated by (\a{dx}, \a{dy}).      \since 4.6     \sa translate() */
end_comment
begin_function
DECL|function|translated
name|QPolygon
name|QPolygon
operator|::
name|translated
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
specifier|const
block|{
name|QPolygon
name|copy
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygon::translated(const QPoint&offset) const     \overload     \since 4.6      Returns a copy of the polygon that is translated by the given \a offset.      \sa translate() */
end_comment
begin_comment
comment|/*!     Extracts the coordinates of the point at the given \a index to     *\a{x} and *\a{y} (if they are valid pointers).      \sa setPoint() */
end_comment
begin_function
DECL|function|point
name|void
name|QPolygon
operator|::
name|point
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
specifier|const
block|{
name|QPoint
name|p
init|=
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
operator|*
name|x
operator|=
operator|(
name|int
operator|)
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|y
condition|)
operator|*
name|y
operator|=
operator|(
name|int
operator|)
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QPolygon::point(int index) const     \overload      Returns the point at the given \a index. */
end_comment
begin_comment
comment|/*!     \fn void QPolygon::setPoint(int index, const QPoint&point)     \overload      Sets the point at the given \a index to the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPolygon::setPoint(int index, int x, int y)      Sets the point at the given \a index to the point specified by     (\a{x}, \a{y}).      \sa point(), putPoints(), setPoints(), */
end_comment
begin_comment
comment|/*!     Resizes the polygon to \a nPoints and populates it with the given     \a points.      The example code creates a polygon with two points (10, 20) and     (30, 40):      \snippet polygon/polygon.cpp 2      \sa setPoint(), putPoints() */
end_comment
begin_function
DECL|function|setPoints
name|void
name|QPolygon
operator|::
name|setPoints
parameter_list|(
name|int
name|nPoints
parameter_list|,
specifier|const
name|int
modifier|*
name|points
parameter_list|)
block|{
name|resize
argument_list|(
name|nPoints
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nPoints
operator|--
condition|)
block|{
name|setPoint
argument_list|(
name|i
operator|++
argument_list|,
operator|*
name|points
argument_list|,
operator|*
operator|(
name|points
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|points
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Resizes the polygon to \a nPoints and populates it with the points     specified by the variable argument list.  The points are given as a     sequence of integers, starting with \a firstx then \a firsty, and     so on.      The example code creates a polygon with two points (10, 20) and     (30, 40):      \snippet polygon/polygon.cpp 3 */
end_comment
begin_function
DECL|function|setPoints
name|void
name|QPolygon
operator|::
name|setPoints
parameter_list|(
name|int
name|nPoints
parameter_list|,
name|int
name|firstx
parameter_list|,
name|int
name|firsty
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|resize
argument_list|(
name|nPoints
argument_list|)
expr_stmt|;
name|setPoint
argument_list|(
literal|0
argument_list|,
name|firstx
argument_list|,
name|firsty
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|firsty
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nPoints
condition|)
block|{
name|x
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|y
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|setPoint
argument_list|(
operator|++
name|i
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload     \internal      Copies \a nPoints points from the \a points coord array into this     point array, and resizes the point array if \c{index+nPoints}     exceeds the size of the array.      \sa setPoint() */
end_comment
begin_function
DECL|function|putPoints
name|void
name|QPolygon
operator|::
name|putPoints
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|nPoints
parameter_list|,
specifier|const
name|int
modifier|*
name|points
parameter_list|)
block|{
if|if
condition|(
name|index
operator|+
name|nPoints
operator|>
name|size
argument_list|()
condition|)
name|resize
argument_list|(
name|index
operator|+
name|nPoints
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|index
decl_stmt|;
while|while
condition|(
name|nPoints
operator|--
condition|)
block|{
name|setPoint
argument_list|(
name|i
operator|++
argument_list|,
operator|*
name|points
argument_list|,
operator|*
operator|(
name|points
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|points
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Copies \a nPoints points from the variable argument list into this     polygon from the given \a index.      The points are given as a sequence of integers, starting with \a     firstx then \a firsty, and so on. The polygon is resized if     \c{index+nPoints} exceeds its current size.      The example code creates a polygon with three points (4,5), (6,7)     and (8,9), by expanding the polygon from 1 to 3 points:      \snippet polygon/polygon.cpp 4      The following code has the same result, but here the putPoints()     function overwrites rather than extends:      \snippet polygon/polygon.cpp 5      \sa setPoints() */
end_comment
begin_function
DECL|function|putPoints
name|void
name|QPolygon
operator|::
name|putPoints
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|nPoints
parameter_list|,
name|int
name|firstx
parameter_list|,
name|int
name|firsty
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|index
operator|+
name|nPoints
operator|>
name|size
argument_list|()
condition|)
name|resize
argument_list|(
name|index
operator|+
name|nPoints
argument_list|)
expr_stmt|;
if|if
condition|(
name|nPoints
operator|<=
literal|0
condition|)
return|return;
name|setPoint
argument_list|(
name|index
argument_list|,
name|firstx
argument_list|,
name|firsty
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|index
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|firsty
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nPoints
condition|)
block|{
name|x
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|y
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|setPoint
argument_list|(
operator|++
name|i
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygon::putPoints(int index, int nPoints, const QPolygon&fromPolygon, int fromIndex)     \overload      Copies \a nPoints points from the given \a fromIndex ( 0 by     default) in \a fromPolygon into this polygon, starting at the     specified \a index. For example:      \snippet polygon/polygon.cpp 6 */
end_comment
begin_function
DECL|function|putPoints
name|void
name|QPolygon
operator|::
name|putPoints
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|nPoints
parameter_list|,
specifier|const
name|QPolygon
modifier|&
name|from
parameter_list|,
name|int
name|fromIndex
parameter_list|)
block|{
if|if
condition|(
name|index
operator|+
name|nPoints
operator|>
name|size
argument_list|()
condition|)
name|resize
argument_list|(
name|index
operator|+
name|nPoints
argument_list|)
expr_stmt|;
if|if
condition|(
name|nPoints
operator|<=
literal|0
condition|)
return|return;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|nPoints
condition|)
block|{
name|setPoint
argument_list|(
name|index
operator|+
name|n
argument_list|,
name|from
index|[
name|fromIndex
operator|+
name|n
index|]
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of the polygon, or QRect(0, 0, 0,     0) if the polygon is empty.      \sa QVector::isEmpty() */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QPolygon
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
specifier|const
name|QPoint
modifier|*
name|pd
init|=
name|constData
argument_list|()
decl_stmt|;
name|int
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pd
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|x
argument_list|()
operator|<
name|minx
condition|)
name|minx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|x
argument_list|()
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|y
argument_list|()
operator|<
name|miny
condition|)
name|miny
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|y
argument_list|()
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pd
expr_stmt|;
block|}
return|return
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|maxx
argument_list|,
name|maxy
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QPolygon("
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|a
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QPolygonF     \brief The QPolygonF class provides a vector of points using     floating point precision.     \inmodule QtGui      \reentrant     \ingroup painting     \ingroup shared      A QPolygonF is a QVector<QPointF>. The easiest way to add points     to a QPolygonF is to use its streaming operator, as illustrated     below:      \snippet polygon/polygon.cpp 1      In addition to the functions provided by QVector, QPolygonF     provides the boundingRect() and translate() functions for geometry     operations. Use the QMatrix::map() function for more general     transformations of QPolygonFs.      QPolygonF also provides the isClosed() function to determine     whether a polygon's start and end points are the same, and the     toPolygon() function returning an integer precision copy of this     polygon.      The QPolygonF class is \l {Implicit Data Sharing}{implicitly     shared}.      \sa QVector, QPolygon, QLineF */
end_comment
begin_comment
comment|/*****************************************************************************   QPolygonF member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF()      Constructs a polygon with no points.      \sa QVector::isEmpty() */
end_comment
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF(int size)      Constructs a polygon of the given \a size. Creates an empty     polygon if \a size == 0.      \sa QVector::isEmpty() */
end_comment
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF(const QPolygonF&polygon)      Constructs a copy of the given \a polygon. */
end_comment
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF(const QVector<QPointF>&points)      Constructs a polygon containing the specified \a points. */
end_comment
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF(const QRectF&rectangle)      Constructs a closed polygon from the specified \a rectangle.      The polygon contains the four vertices of the rectangle in     clockwise order starting and ending with the top-left vertex.      \sa isClosed() */
end_comment
begin_constructor
DECL|function|QPolygonF
name|QPolygonF
operator|::
name|QPolygonF
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
name|reserve
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QPolygonF::QPolygonF(const QPolygon&polygon)      Constructs a float based polygon from the specified integer based     \a polygon.      \sa toPolygon() */
end_comment
begin_constructor
DECL|function|QPolygonF
name|QPolygonF
operator|::
name|QPolygonF
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|)
block|{
name|reserve
argument_list|(
name|a
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|append
argument_list|(
name|a
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QPolygonF::~QPolygonF()      Destroys the polygon. */
end_comment
begin_comment
comment|/*!     Translate all points in the polygon by the given \a offset.      \sa translated() */
end_comment
begin_function
DECL|function|translate
name|void
name|QPolygonF
operator|::
name|translate
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QPointF
modifier|*
name|p
init|=
name|data
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
operator|*
name|p
operator|+=
name|offset
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygonF::translate(qreal dx, qreal dy)     \overload      Translates all points in the polygon by (\a{dx}, \a{dy}).      \sa translated() */
end_comment
begin_comment
comment|/*!     Returns a copy of the polygon that is translated by the given \a offset.      \since 4.6     \sa translate() */
end_comment
begin_function
DECL|function|translated
name|QPolygonF
name|QPolygonF
operator|::
name|translated
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|offset
parameter_list|)
specifier|const
block|{
name|QPolygonF
name|copy
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygonF::translated(qreal dx, qreal dy) const     \overload     \since 4.6      Returns a copy of the polygon that is translated by (\a{dx}, \a{dy}).      \sa translate() */
end_comment
begin_comment
comment|/*!     \fn bool QPolygonF::isClosed() const      Returns true if the polygon is closed; otherwise returns false.      A polygon is said to be closed if its start point and end point are equal.      \sa QVector::first(), QVector::last() */
end_comment
begin_comment
comment|/*!     Returns the bounding rectangle of the polygon, or QRectF(0,0,0,0)     if the polygon is empty.      \sa QVector::isEmpty() */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QPolygonF
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
specifier|const
name|QPointF
modifier|*
name|pd
init|=
name|constData
argument_list|()
decl_stmt|;
name|qreal
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pd
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|x
argument_list|()
operator|<
name|minx
condition|)
name|minx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|x
argument_list|()
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|pd
operator|->
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|y
argument_list|()
operator|<
name|miny
condition|)
name|miny
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|y
argument_list|()
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|pd
operator|->
name|y
argument_list|()
expr_stmt|;
operator|++
name|pd
expr_stmt|;
block|}
return|return
name|QRectF
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and returns a QPolygon by converting each QPointF to a     QPoint.      \sa QPointF::toPoint() */
end_comment
begin_function
DECL|function|toPolygon
name|QPolygon
name|QPolygonF
operator|::
name|toPolygon
parameter_list|()
specifier|const
block|{
name|QPolygon
name|a
decl_stmt|;
name|a
operator|.
name|reserve
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|a
operator|.
name|append
argument_list|(
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPolygon::swap(QPolygon&other)     \since 4.8      Swaps polygon \a other with this polygon. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     \fn void QPolygonF::swap(QPolygonF&other)     \since 4.8      Swaps polygon \a other with this polygon. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!    Returns the polygon as a QVariant */
end_comment
begin_function
DECL|function|operator QVariant
name|QPolygon
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Polygon
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPolygon stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QPolygon&polygon)     \since 4.4     \relates QPolygon      Writes the given \a polygon to the given \a stream, and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QPolygon
modifier|&
name|a
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|v
init|=
name|a
decl_stmt|;
return|return
name|s
operator|<<
name|v
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QPolygon&polygon)     \since 4.4     \relates QPolygon      Reads a polygon from the given \a stream into the given \a     polygon, and returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QPolygon
modifier|&
name|a
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPoint
argument_list|>
modifier|&
name|v
init|=
name|a
decl_stmt|;
return|return
name|s
operator|>>
name|v
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*****************************************************************************   QPolygonF stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QPolygonF&polygon)     \relates QPolygonF      Writes the given \a polygon to the given \a stream, and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|a
parameter_list|)
block|{
name|quint32
name|len
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|s
operator|<<
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|s
operator|<<
name|a
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QPolygonF&polygon)     \relates QPolygonF      Reads a polygon from the given \a stream into the given \a     polygon, and returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QPolygonF
modifier|&
name|a
parameter_list|)
block|{
name|quint32
name|len
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|s
operator|>>
name|len
expr_stmt|;
name|a
operator|.
name|reserve
argument_list|(
name|a
operator|.
name|size
argument_list|()
operator|+
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|QPointF
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|>>
name|p
expr_stmt|;
name|a
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|a
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QPolygonF("
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|a
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.3      \fn bool QPolygonF::containsPoint(const QPointF&point, Qt::FillRule fillRule) const      Returns true if the given \a point is inside the polygon according to     the specified \a fillRule; otherwise returns false. */
end_comment
begin_function
DECL|function|containsPoint
name|bool
name|QPolygonF
operator|::
name|containsPoint
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pt
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|winding_number
init|=
literal|0
decl_stmt|;
name|QPointF
name|last_pt
init|=
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QPointF
name|last_start
init|=
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPointF
modifier|&
name|e
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_polygon_isect_line
argument_list|(
name|last_pt
argument_list|,
name|e
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
name|last_pt
operator|=
name|e
expr_stmt|;
block|}
comment|// implicitly close last subpath
if|if
condition|(
name|last_pt
operator|!=
name|last_start
condition|)
name|qt_polygon_isect_line
argument_list|(
name|last_pt
argument_list|,
name|last_start
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
return|return
operator|(
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
operator|(
name|winding_number
operator|!=
literal|0
operator|)
else|:
operator|(
operator|(
name|winding_number
operator|%
literal|2
operator|)
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      \fn bool QPolygon::containsPoint(const QPoint&point, Qt::FillRule fillRule) const     Returns true if the given \a point is inside the polygon according to     the specified \a fillRule; otherwise returns false. */
end_comment
begin_function
DECL|function|containsPoint
name|bool
name|QPolygon
operator|::
name|containsPoint
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pt
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|winding_number
init|=
literal|0
decl_stmt|;
name|QPoint
name|last_pt
init|=
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QPoint
name|last_start
init|=
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPoint
modifier|&
name|e
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qt_polygon_isect_line
argument_list|(
name|last_pt
argument_list|,
name|e
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
name|last_pt
operator|=
name|e
expr_stmt|;
block|}
comment|// implicitly close last subpath
if|if
condition|(
name|last_pt
operator|!=
name|last_start
condition|)
name|qt_polygon_isect_line
argument_list|(
name|last_pt
argument_list|,
name|last_start
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
return|return
operator|(
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
operator|(
name|winding_number
operator|!=
literal|0
operator|)
else|:
operator|(
operator|(
name|winding_number
operator|%
literal|2
operator|)
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is the union of this polygon and \a r.      Set operations on polygons, will treat the polygons as areas, and     implicitly close the polygon.      \sa intersected(), subtracted() */
end_comment
begin_function
DECL|function|united
name|QPolygon
name|QPolygon
operator|::
name|united
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|united
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is the intersection of this polygon and \a r.      Set operations on polygons will treat the polygons as     areas. Non-closed polygons will be treated as implicitly closed. */
end_comment
begin_function
DECL|function|intersected
name|QPolygon
name|QPolygon
operator|::
name|intersected
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|intersected
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is \a r subtracted from this polygon.      Set operations on polygons will treat the polygons as     areas. Non-closed polygons will be treated as implicitly closed.  */
end_comment
begin_function
DECL|function|subtracted
name|QPolygon
name|QPolygon
operator|::
name|subtracted
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|subtracted
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is the union of this polygon and \a r.      Set operations on polygons will treat the polygons as     areas. Non-closed polygons will be treated as implicitly closed.      \sa intersected(), subtracted() */
end_comment
begin_function
DECL|function|united
name|QPolygonF
name|QPolygonF
operator|::
name|united
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|united
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is the intersection of this polygon and \a r.      Set operations on polygons will treat the polygons as     areas. Non-closed polygons will be treated as implicitly closed.  */
end_comment
begin_function
DECL|function|intersected
name|QPolygonF
name|QPolygonF
operator|::
name|intersected
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|intersected
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a polygon which is \a r subtracted from this polygon.      Set operations on polygons will treat the polygons as     areas. Non-closed polygons will be treated as implicitly closed.  */
end_comment
begin_function
DECL|function|subtracted
name|QPolygonF
name|QPolygonF
operator|::
name|subtracted
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|subject
decl_stmt|;
name|subject
operator|.
name|addPolygon
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QPainterPath
name|clip
decl_stmt|;
name|clip
operator|.
name|addPolygon
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|subject
operator|.
name|subtracted
argument_list|(
name|clip
argument_list|)
operator|.
name|toFillPolygon
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    Returns the polygon as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QPolygonF
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QMetaType
operator|::
name|QPolygonF
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
