begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath_p.h"
end_include
begin_include
include|#
directive|include
file|<qbitmap.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qmatrix.h>
end_include
begin_include
include|#
directive|include
file|<qpen.h>
end_include
begin_include
include|#
directive|include
file|<qpolygon.h>
end_include
begin_include
include|#
directive|include
file|<qtextlayout.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qbezier_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qnumeric_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpathclipper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qstroker_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<performance.h>
end_include
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PM_INIT
define|#
directive|define
name|PM_INIT
end_define
begin_define
DECL|macro|PM_MEASURE
define|#
directive|define
name|PM_MEASURE
parameter_list|(
name|x
parameter_list|)
end_define
begin_define
DECL|macro|PM_DISPLAY
define|#
directive|define
name|PM_DISPLAY
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_struct
DECL|struct|QPainterPathPrivateDeleter
struct|struct
name|QPainterPathPrivateDeleter
block|{
DECL|function|cleanup
specifier|static
specifier|inline
name|void
name|cleanup
parameter_list|(
name|QPainterPathPrivate
modifier|*
name|d
parameter_list|)
block|{
comment|// note - we must up-cast to QPainterPathData since QPainterPathPrivate
comment|// has a non-virtual destructor!
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
cast|static_cast
argument_list|<
name|QPainterPathData
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_comment
comment|// This value is used to determine the length of control point vectors
end_comment
begin_comment
comment|// when approximating arc segments as curves. The factor is multiplied
end_comment
begin_comment
comment|// with the radius of the circle.
end_comment
begin_comment
comment|// #define QPP_DEBUG
end_comment
begin_comment
comment|// #define QPP_STROKE_DEBUG
end_comment
begin_comment
comment|//#define QPP_FILLPOLYGONS_DEBUG
end_comment
begin_function_decl
name|QPainterPath
name|qt_stroke_dash
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|qreal
modifier|*
name|dashes
parameter_list|,
name|int
name|dashCount
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qt_find_ellipse_coords
name|void
name|qt_find_ellipse_coords
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|qreal
name|angle
parameter_list|,
name|qreal
name|length
parameter_list|,
name|QPointF
modifier|*
name|startPoint
parameter_list|,
name|QPointF
modifier|*
name|endPoint
parameter_list|)
block|{
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|startPoint
condition|)
operator|*
name|startPoint
operator|=
name|QPointF
argument_list|()
expr_stmt|;
if|if
condition|(
name|endPoint
condition|)
operator|*
name|endPoint
operator|=
name|QPointF
argument_list|()
expr_stmt|;
return|return;
block|}
name|qreal
name|w2
init|=
name|r
operator|.
name|width
argument_list|()
operator|/
literal|2
decl_stmt|;
name|qreal
name|h2
init|=
name|r
operator|.
name|height
argument_list|()
operator|/
literal|2
decl_stmt|;
name|qreal
name|angles
index|[
literal|2
index|]
init|=
block|{
name|angle
block|,
name|angle
operator|+
name|length
block|}
decl_stmt|;
name|QPointF
modifier|*
name|points
index|[
literal|2
index|]
init|=
block|{
name|startPoint
block|,
name|endPoint
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|points
index|[
name|i
index|]
condition|)
continue|continue;
name|qreal
name|theta
init|=
name|angles
index|[
name|i
index|]
operator|-
literal|360
operator|*
name|qFloor
argument_list|(
name|angles
index|[
name|i
index|]
operator|/
literal|360
argument_list|)
decl_stmt|;
name|qreal
name|t
init|=
name|theta
operator|/
literal|90
decl_stmt|;
comment|// truncate
name|int
name|quadrant
init|=
name|int
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|-=
name|quadrant
expr_stmt|;
name|t
operator|=
name|qt_t_for_arc_angle
argument_list|(
literal|90
operator|*
name|t
argument_list|)
expr_stmt|;
comment|// swap x and y?
if|if
condition|(
name|quadrant
operator|&
literal|1
condition|)
name|t
operator|=
literal|1
operator|-
name|t
expr_stmt|;
name|qreal
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|QBezier
operator|::
name|coefficients
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QPointF
name|p
argument_list|(
name|a
operator|+
name|b
operator|+
name|c
operator|*
name|QT_PATH_KAPPA
argument_list|,
name|d
operator|+
name|c
operator|+
name|b
operator|*
name|QT_PATH_KAPPA
argument_list|)
decl_stmt|;
comment|// left quadrants
if|if
condition|(
name|quadrant
operator|==
literal|1
operator|||
name|quadrant
operator|==
literal|2
condition|)
name|p
operator|.
name|rx
argument_list|()
operator|=
operator|-
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
comment|// top quadrants
if|if
condition|(
name|quadrant
operator|==
literal|0
operator|||
name|quadrant
operator|==
literal|1
condition|)
name|p
operator|.
name|ry
argument_list|()
operator|=
operator|-
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
operator|*
name|points
index|[
name|i
index|]
operator|=
name|r
operator|.
name|center
argument_list|()
operator|+
name|QPointF
argument_list|(
name|w2
operator|*
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|h2
operator|*
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QPP_DEBUG
end_ifdef
begin_function
DECL|function|qt_debug_path
specifier|static
name|void
name|qt_debug_path
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"MoveTo     "
block|,
literal|"LineTo     "
block|,
literal|"CurveTo    "
block|,
literal|"CurveToData"
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"\nQPainterPath: elementCount=%d\n"
argument_list|,
name|path
operator|.
name|elementCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|e
operator|.
name|type
operator|>=
literal|0
operator|&&
name|e
operator|.
name|type
operator|<=
name|QPainterPath
operator|::
name|CurveToDataElement
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" - %3d:: %s, (%.2f, %.2f)\n"
argument_list|,
name|i
argument_list|,
name|names
index|[
name|e
operator|.
name|type
index|]
argument_list|,
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QPainterPath     \ingroup painting     \ingroup shared     \inmodule QtGui      \brief The QPainterPath class provides a container for painting operations,     enabling graphical shapes to be constructed and reused.      A painter path is an object composed of a number of graphical     building blocks, such as rectangles, ellipses, lines, and curves.     Building blocks can be joined in closed subpaths, for example as a     rectangle or an ellipse. A closed path has coinciding start and     end points. Or they can exist independently as unclosed subpaths,     such as lines and curves.      A QPainterPath object can be used for filling, outlining, and     clipping. To generate fillable outlines for a given painter path,     use the QPainterPathStroker class.  The main advantage of painter     paths over normal drawing operations is that complex shapes only     need to be created once; then they can be drawn many times using     only calls to the QPainter::drawPath() function.      QPainterPath provides a collection of functions that can be used     to obtain information about the path and its elements. In addition     it is possible to reverse the order of the elements using the     toReversed() function. There are also several functions to convert     this painter path object into a polygon representation.      \tableofcontents      \section1 Composing a QPainterPath      A QPainterPath object can be constructed as an empty path, with a     given start point, or as a copy of another QPainterPath object.     Once created, lines and curves can be added to the path using the     lineTo(), arcTo(), cubicTo() and quadTo() functions. The lines and     curves stretch from the currentPosition() to the position passed     as argument.      The currentPosition() of the QPainterPath object is always the end     position of the last subpath that was added (or the initial start     point). Use the moveTo() function to move the currentPosition()     without adding a component. The moveTo() function implicitly     starts a new subpath, and closes the previous one.  Another way of     starting a new subpath is to call the closeSubpath() function     which closes the current path by adding a line from the     currentPosition() back to the path's start position. Note that the     new path will have (0, 0) as its initial currentPosition().      QPainterPath class also provides several convenience functions to     add closed subpaths to a painter path: addEllipse(), addPath(),     addRect(), addRegion() and addText(). The addPolygon() function     adds an \e unclosed subpath. In fact, these functions are all     collections of moveTo(), lineTo() and cubicTo() operations.      In addition, a path can be added to the current path using the     connectPath() function. But note that this function will connect     the last element of the current path to the first element of given     one by adding a line.      Below is a code snippet that shows how a QPainterPath object can     be used:      \table 100%     \row     \li \inlineimage qpainterpath-construction.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 0     \endtable      The painter path is initially empty when constructed. We first add     a rectangle, which is a closed subpath. Then we add two bezier     curves which together form a closed subpath even though they are     not closed individually. Finally we draw the entire path. The path     is filled using the default fill rule, Qt::OddEvenFill. Qt     provides two methods for filling paths:      \table     \header     \li Qt::OddEvenFill     \li Qt::WindingFill     \row     \li \inlineimage qt-fillrule-oddeven.png     \li \inlineimage qt-fillrule-winding.png     \endtable      See the Qt::FillRule documentation for the definition of the     rules. A painter path's currently set fill rule can be retrieved     using the fillRule() function, and altered using the setFillRule()     function.      \section1 QPainterPath Information      The QPainterPath class provides a collection of functions that     returns information about the path and its elements.      The currentPosition() function returns the end point of the last     subpath that was added (or the initial start point). The     elementAt() function can be used to retrieve the various subpath     elements, the \e number of elements can be retrieved using the     elementCount() function, and the isEmpty() function tells whether     this QPainterPath object contains any elements at all.      The controlPointRect() function returns the rectangle containing     all the points and control points in this path. This function is     significantly faster to compute than the exact boundingRect()     which returns the bounding rectangle of this painter path with     floating point precision.      Finally, QPainterPath provides the contains() function which can     be used to determine whether a given point or rectangle is inside     the path, and the intersects() function which determines if any of     the points inside a given rectangle also are inside this path.      \section1 QPainterPath Conversion      For compatibility reasons, it might be required to simplify the     representation of a painter path: QPainterPath provides the     toFillPolygon(), toFillPolygons() and toSubpathPolygons()     functions which convert the painter path into a polygon. The     toFillPolygon() returns the painter path as one single polygon,     while the two latter functions return a list of polygons.      The toFillPolygons() and toSubpathPolygons() functions are     provided because it is usually faster to draw several small     polygons than to draw one large polygon, even though the total     number of points drawn is the same. The difference between the two     is the \e number of polygons they return: The toSubpathPolygons()     creates one polygon for each subpath regardless of intersecting     subpaths (i.e. overlapping bounding rectangles), while the     toFillPolygons() functions creates only one polygon for     overlapping subpaths.      The toFillPolygon() and toFillPolygons() functions first convert     all the subpaths to polygons, then uses a rewinding technique to     make sure that overlapping subpaths can be filled using the     correct fill rule. Note that rewinding inserts additional lines in     the polygon so the outline of the fill polygon does not match the     outline of the path.      \section1 Examples      Qt provides the \l {painting/painterpaths}{Painter Paths Example}     and the \l {painting/deform}{Vector Deformation example} which are     located in Qt's example directory.      The \l {painting/painterpaths}{Painter Paths Example} shows how     painter paths can be used to build complex shapes for rendering     and lets the user experiment with the filling and stroking.  The     \l {painting/deform}{Vector Deformation Example} shows how to use     QPainterPath to draw text.      \table     \header     \li \l {painting/painterpaths}{Painter Paths Example}     \li \l {painting/deform}{Vector Deformation Example}     \row     \li \inlineimage qpainterpath-example.png     \li \inlineimage qpainterpath-demo.png     \endtable      \sa QPainterPathStroker, QPainter, QRegion, {Painter Paths Example} */
end_comment
begin_comment
comment|/*!     \enum QPainterPath::ElementType      This enum describes the types of elements used to connect vertices     in subpaths.      Note that elements added as closed subpaths using the     addEllipse(), addPath(), addPolygon(), addRect(), addRegion() and     addText() convenience functions, is actually added to the path as     a collection of separate elements using the moveTo(), lineTo() and     cubicTo() functions.      \value MoveToElement          A new subpath. See also moveTo().     \value LineToElement            A line. See also lineTo().     \value CurveToElement         A curve. See also cubicTo() and quadTo().     \value CurveToDataElement  The extra data required to describe a curve in                                                a CurveToElement element.      \sa elementAt(), elementCount() */
end_comment
begin_comment
comment|/*!     \class QPainterPath::Element     \inmodule QtGui      \brief The QPainterPath::Element class specifies the position and     type of a subpath.      Once a QPainterPath object is constructed, subpaths like lines and     curves can be added to the path (creating     QPainterPath::LineToElement and QPainterPath::CurveToElement     components).      The lines and curves stretch from the currentPosition() to the     position passed as argument. The currentPosition() of the     QPainterPath object is always the end position of the last subpath     that was added (or the initial start point). The moveTo() function     can be used to move the currentPosition() without adding a line or     curve, creating a QPainterPath::MoveToElement component.      \sa QPainterPath */
end_comment
begin_comment
comment|/*!     \variable QPainterPath::Element::x     \brief the x coordinate of the element's position.      \sa {operator QPointF()} */
end_comment
begin_comment
comment|/*!     \variable QPainterPath::Element::y     \brief the y coordinate of the element's position.      \sa {operator QPointF()} */
end_comment
begin_comment
comment|/*!     \variable QPainterPath::Element::type     \brief the type of element      \sa isCurveTo(), isLineTo(), isMoveTo() */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::Element::operator==(const Element&other) const     \since 4.2      Returns \c true if this element is equal to \a other;     otherwise returns \c false.      \sa operator!=() */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::Element::operator!=(const Element&other) const     \since 4.2      Returns \c true if this element is not equal to \a other;     otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::Element::isCurveTo () const      Returns \c true if the element is a curve, otherwise returns \c false.      \sa type, QPainterPath::CurveToElement */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::Element::isLineTo () const      Returns \c true if the element is a line, otherwise returns \c false.      \sa type, QPainterPath::LineToElement */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::Element::isMoveTo () const      Returns \c true if the element is moving the current position,     otherwise returns \c false.      \sa type, QPainterPath::MoveToElement */
end_comment
begin_comment
comment|/*!     \fn QPainterPath::Element::operator QPointF () const      Returns the element's position.      \sa x, y */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::addEllipse(qreal x, qreal y, qreal width, qreal height)     \overload      Creates an ellipse within the bounding rectangle defined by its top-left     corner at (\a x, \a y), \a width and \a height, and adds it to the     painter path as a closed subpath. */
end_comment
begin_comment
comment|/*!     \since 4.4      \fn void QPainterPath::addEllipse(const QPointF&center, qreal rx, qreal ry)     \overload      Creates an ellipse positioned at \a{center} with radii \a{rx} and \a{ry},     and adds it to the painter path as a closed subpath. */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::addText(qreal x, qreal y, const QFont&font, const QString&text)     \overload      Adds the given \a text to this path as a set of closed subpaths created     from the \a font supplied. The subpaths are positioned so that the left     end of the text's baseline lies at the point specified by (\a x, \a y). */
end_comment
begin_comment
comment|/*!     \fn int QPainterPath::elementCount() const      Returns the number of path elements in the painter path.      \sa ElementType, elementAt(), isEmpty() */
end_comment
begin_function
DECL|function|elementCount
name|int
name|QPainterPath
operator|::
name|elementCount
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
condition|?
name|d_ptr
operator|->
name|elements
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath::Element QPainterPath::elementAt(int index) const      Returns the element at the given \a index in the painter path.      \sa ElementType, elementCount(), isEmpty() */
end_comment
begin_function
DECL|function|elementAt
name|QPainterPath
operator|::
name|Element
name|QPainterPath
operator|::
name|elementAt
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|d_ptr
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|elementCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d_ptr
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::setElementPositionAt(int index, qreal x, qreal y)     \since 4.2      Sets the x and y coordinate of the element at index \a index to \a     x and \a y. */
end_comment
begin_function
DECL|function|setElementPositionAt
name|void
name|QPainterPath
operator|::
name|setElementPositionAt
parameter_list|(
name|int
name|i
parameter_list|,
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d_ptr
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|elementCount
argument_list|()
argument_list|)
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|d_ptr
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
name|e
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|e
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*###     \fn QPainterPath&QPainterPath::operator +=(const QPainterPath&other)      Appends the \a other painter path to this painter path and returns a     reference to the result. */
end_comment
begin_comment
comment|/*!     Constructs an empty QPainterPath object. */
end_comment
begin_constructor
name|QPainterPath
operator|::
name|QPainterPath
parameter_list|()
name|Q_DECL_NOEXCEPT
constructor|:
name|d_ptr
constructor|(0
end_constructor
begin_block
unit|)
block|{ }
end_block
begin_comment
comment|/*!     \fn QPainterPath::QPainterPath(const QPainterPath&path)      Creates a QPainterPath object that is a copy of the given \a path.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QPainterPath
name|QPainterPath
operator|::
name|QPainterPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|other
operator|.
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|)
block|{
if|if
condition|(
name|d_ptr
condition|)
name|d_ptr
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a QPainterPath object with the given \a startPoint as its     current position. */
end_comment
begin_constructor
DECL|function|QPainterPath
name|QPainterPath
operator|::
name|QPainterPath
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|startPoint
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QPainterPathData
argument_list|)
block|{
name|Element
name|e
init|=
block|{
name|startPoint
operator|.
name|x
argument_list|()
block|,
name|startPoint
operator|.
name|y
argument_list|()
block|,
name|MoveToElement
block|}
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|<<
name|e
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|detach
name|void
name|QPainterPath
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|detach_helper
argument_list|()
expr_stmt|;
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|detach_helper
name|void
name|QPainterPath
operator|::
name|detach_helper
parameter_list|()
block|{
name|QPainterPathPrivate
modifier|*
name|data
init|=
operator|new
name|QPainterPathData
argument_list|(
operator|*
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
name|d_ptr
operator|.
name|reset
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|ensureData_helper
name|void
name|QPainterPath
operator|::
name|ensureData_helper
parameter_list|()
block|{
name|QPainterPathPrivate
modifier|*
name|data
init|=
operator|new
name|QPainterPathData
decl_stmt|;
name|data
operator|->
name|elements
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|QPainterPath
operator|::
name|Element
name|e
init|=
block|{
literal|0
block|,
literal|0
block|,
name|QPainterPath
operator|::
name|MoveToElement
block|}
decl_stmt|;
name|data
operator|->
name|elements
operator|<<
name|e
expr_stmt|;
name|d_ptr
operator|.
name|reset
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath&QPainterPath::operator=(const QPainterPath&path)      Assigns the given \a path to this painter path.      \sa QPainterPath() */
end_comment
begin_function
DECL|function|operator =
name|QPainterPath
modifier|&
name|QPainterPath
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d_func
argument_list|()
operator|!=
name|d_func
argument_list|()
condition|)
block|{
name|QPainterPathPrivate
modifier|*
name|data
init|=
name|other
operator|.
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
condition|)
name|data
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d_ptr
operator|.
name|reset
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath&QPainterPath::operator=(QPainterPath&&other)      Move-assigns \a other to this QPainterPath instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::swap(QPainterPath&other)     \since 4.8      Swaps painter path \a other with this painter path. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     Destroys this QPainterPath object. */
end_comment
begin_destructor
DECL|function|~QPainterPath
name|QPainterPath
operator|::
name|~
name|QPainterPath
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Closes the current subpath by drawing a line to the beginning of     the subpath, automatically starting a new path. The current point     of the new path is (0, 0).      If the subpath does not contain any elements, this function does     nothing.      \sa moveTo(), {QPainterPath#Composing a QPainterPath}{Composing     a QPainterPath}  */
end_comment
begin_function
DECL|function|closeSubpath
name|void
name|QPainterPath
operator|::
name|closeSubpath
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::closeSubpath()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::moveTo(qreal x, qreal y)      \overload      Moves the current position to (\a{x}, \a{y}) and starts a new     subpath, implicitly closing the previous path. */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::moveTo(const QPointF&point)      Moves the current point to the given \a point, implicitly starting     a new subpath and closing the previous one.      \sa closeSubpath(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath} */
end_comment
begin_function
DECL|function|moveTo
name|void
name|QPainterPath
operator|::
name|moveTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::moveTo() (%.2f,%.2f)\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::moveTo: Adding point where x or y is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|require_moveTo
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|type
operator|==
name|MoveToElement
condition|)
block|{
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Element
name|elm
init|=
block|{
name|p
operator|.
name|x
argument_list|()
block|,
name|p
operator|.
name|y
argument_list|()
block|,
name|MoveToElement
block|}
decl_stmt|;
name|d
operator|->
name|elements
operator|.
name|append
argument_list|(
name|elm
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|cStart
operator|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::lineTo(qreal x, qreal y)      \overload      Draws a line from the current position to the point (\a{x},     \a{y}). */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::lineTo(const QPointF&endPoint)      Adds a straight line from the current position to the given \a     endPoint.  After the line is drawn, the current position is updated     to be at the end point of the line.      \sa addPolygon(), addRect(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath}  */
end_comment
begin_function
DECL|function|lineTo
name|void
name|QPainterPath
operator|::
name|lineTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::lineTo() (%.2f,%.2f)\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::lineTo: Adding point where x or y is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|maybeMoveTo
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|QPointF
argument_list|(
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
argument_list|)
condition|)
return|return;
name|Element
name|elm
init|=
block|{
name|p
operator|.
name|x
argument_list|()
block|,
name|p
operator|.
name|y
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|d
operator|->
name|elements
operator|.
name|append
argument_list|(
name|elm
argument_list|)
expr_stmt|;
name|d
operator|->
name|convex
operator|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|||
operator|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|4
operator|&&
name|d
operator|->
name|isClosed
argument_list|()
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::cubicTo(qreal c1X, qreal c1Y, qreal c2X,     qreal c2Y, qreal endPointX, qreal endPointY);      \overload      Adds a cubic Bezier curve between the current position and the end     point (\a{endPointX}, \a{endPointY}) with control points specified     by (\a{c1X}, \a{c1Y}) and (\a{c2X}, \a{c2Y}). */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::cubicTo(const QPointF&c1, const QPointF&c2, const QPointF&endPoint)      Adds a cubic Bezier curve between the current position and the     given \a endPoint using the control points specified by \a c1, and     \a c2.      After the curve is added, the current position is updated to be at     the end point of the curve.      \table 100%     \row     \li \inlineimage qpainterpath-cubicto.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 1     \endtable      \sa quadTo(), {QPainterPath#Composing a QPainterPath}{Composing     a QPainterPath} */
end_comment
begin_function
DECL|function|cubicTo
name|void
name|QPainterPath
operator|::
name|cubicTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|c1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|c2
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|e
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::cubicTo() (%.2f,%.2f), (%.2f,%.2f), (%.2f,%.2f)\n"
argument_list|,
name|c1
operator|.
name|x
argument_list|()
argument_list|,
name|c1
operator|.
name|y
argument_list|()
argument_list|,
name|c2
operator|.
name|x
argument_list|()
argument_list|,
name|c2
operator|.
name|y
argument_list|()
argument_list|,
name|e
operator|.
name|x
argument_list|()
argument_list|,
name|e
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|c1
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|c1
operator|.
name|y
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|c2
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|c2
operator|.
name|y
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|e
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|e
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::cubicTo: Adding point where x or y is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// Abort on empty curve as a stroker cannot handle this and the
comment|// curve is irrelevant anyway.
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|==
name|c1
operator|&&
name|c1
operator|==
name|c2
operator|&&
name|c2
operator|==
name|e
condition|)
return|return;
name|d
operator|->
name|maybeMoveTo
argument_list|()
expr_stmt|;
name|Element
name|ce1
init|=
block|{
name|c1
operator|.
name|x
argument_list|()
block|,
name|c1
operator|.
name|y
argument_list|()
block|,
name|CurveToElement
block|}
decl_stmt|;
name|Element
name|ce2
init|=
block|{
name|c2
operator|.
name|x
argument_list|()
block|,
name|c2
operator|.
name|y
argument_list|()
block|,
name|CurveToDataElement
block|}
decl_stmt|;
name|Element
name|ee
init|=
block|{
name|e
operator|.
name|x
argument_list|()
block|,
name|e
operator|.
name|y
argument_list|()
block|,
name|CurveToDataElement
block|}
decl_stmt|;
name|d
operator|->
name|elements
operator|<<
name|ce1
operator|<<
name|ce2
operator|<<
name|ee
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::quadTo(qreal cx, qreal cy, qreal endPointX, qreal endPointY);      \overload      Adds a quadratic Bezier curve between the current point and the endpoint     (\a{endPointX}, \a{endPointY}) with the control point specified by     (\a{cx}, \a{cy}). */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::quadTo(const QPointF&c, const QPointF&endPoint)      Adds a quadratic Bezier curve between the current position and the     given \a endPoint with the control point specified by \a c.      After the curve is added, the current point is updated to be at     the end point of the curve.      \sa cubicTo(), {QPainterPath#Composing a QPainterPath}{Composing a     QPainterPath} */
end_comment
begin_function
DECL|function|quadTo
name|void
name|QPainterPath
operator|::
name|quadTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|c
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|e
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::quadTo() (%.2f,%.2f), (%.2f,%.2f)\n"
argument_list|,
name|c
operator|.
name|x
argument_list|()
argument_list|,
name|c
operator|.
name|y
argument_list|()
argument_list|,
name|e
operator|.
name|x
argument_list|()
argument_list|,
name|e
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|c
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|c
operator|.
name|y
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|e
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|e
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::quadTo: Adding point where x or y is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|elements
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|elm
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|elementCount
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QPointF
name|prev
argument_list|(
name|elm
operator|.
name|x
argument_list|,
name|elm
operator|.
name|y
argument_list|)
decl_stmt|;
comment|// Abort on empty curve as a stroker cannot handle this and the
comment|// curve is irrelevant anyway.
if|if
condition|(
name|prev
operator|==
name|c
operator|&&
name|c
operator|==
name|e
condition|)
return|return;
name|QPointF
name|c1
argument_list|(
operator|(
name|prev
operator|.
name|x
argument_list|()
operator|+
literal|2
operator|*
name|c
operator|.
name|x
argument_list|()
operator|)
operator|/
literal|3
argument_list|,
operator|(
name|prev
operator|.
name|y
argument_list|()
operator|+
literal|2
operator|*
name|c
operator|.
name|y
argument_list|()
operator|)
operator|/
literal|3
argument_list|)
decl_stmt|;
name|QPointF
name|c2
argument_list|(
operator|(
name|e
operator|.
name|x
argument_list|()
operator|+
literal|2
operator|*
name|c
operator|.
name|x
argument_list|()
operator|)
operator|/
literal|3
argument_list|,
operator|(
name|e
operator|.
name|y
argument_list|()
operator|+
literal|2
operator|*
name|c
operator|.
name|y
argument_list|()
operator|)
operator|/
literal|3
argument_list|)
decl_stmt|;
name|cubicTo
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::arcTo(qreal x, qreal y, qreal width, qreal     height, qreal startAngle, qreal sweepLength)      \overload      Creates an arc that occupies the rectangle QRectF(\a x, \a y, \a     width, \a height), beginning at the specified \a startAngle and     extending \a sweepLength degrees counter-clockwise.  */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::arcTo(const QRectF&rectangle, qreal startAngle, qreal sweepLength)      Creates an arc that occupies the given \a rectangle, beginning at     the specified \a startAngle and extending \a sweepLength degrees     counter-clockwise.      Angles are specified in degrees. Clockwise arcs can be specified     using negative angles.      Note that this function connects the starting point of the arc to     the current position if they are not already connected. After the     arc has been added, the current position is the last point in     arc. To draw a line back to the first point, use the     closeSubpath() function.      \table 100%     \row     \li \inlineimage qpainterpath-arcto.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 2     \endtable      \sa arcMoveTo(), addEllipse(), QPainter::drawArc(), QPainter::drawPie(),     {QPainterPath#Composing a QPainterPath}{Composing a     QPainterPath} */
end_comment
begin_function
DECL|function|arcTo
name|void
name|QPainterPath
operator|::
name|arcTo
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|startAngle
parameter_list|,
name|qreal
name|sweepLength
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QPP_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::arcTo() (%.2f, %.2f, %.2f, %.2f, angle=%.2f, sweep=%.2f\n"
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|startAngle
argument_list|,
name|sweepLength
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
name|qt_is_finite
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|)
operator|&&
operator|!
name|qt_is_finite
argument_list|(
name|rect
operator|.
name|y
argument_list|()
argument_list|)
operator|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|rect
operator|.
name|width
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|rect
operator|.
name|height
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|startAngle
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|sweepLength
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::arcTo: Adding arc where a parameter is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|int
name|point_count
decl_stmt|;
name|QPointF
name|pts
index|[
literal|15
index|]
decl_stmt|;
name|QPointF
name|curve_start
init|=
name|qt_curves_for_arc
argument_list|(
name|rect
argument_list|,
name|startAngle
argument_list|,
name|sweepLength
argument_list|,
name|pts
argument_list|,
operator|&
name|point_count
argument_list|)
decl_stmt|;
name|lineTo
argument_list|(
name|curve_start
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|point_count
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|cubicTo
argument_list|(
name|pts
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|pts
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|pts
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|pts
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|pts
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|pts
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::arcMoveTo(qreal x, qreal y, qreal width, qreal height, qreal angle)     \overload     \since 4.2      Creates a move to that lies on the arc that occupies the     QRectF(\a x, \a y, \a width, \a height) at \a angle. */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::arcMoveTo(const QRectF&rectangle, qreal angle)     \since 4.2      Creates a move to that lies on the arc that occupies the given \a     rectangle at \a angle.      Angles are specified in degrees. Clockwise arcs can be specified     using negative angles.      \sa moveTo(), arcTo() */
end_comment
begin_function
DECL|function|arcMoveTo
name|void
name|QPainterPath
operator|::
name|arcMoveTo
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|angle
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QPointF
name|pt
decl_stmt|;
name|qt_find_ellipse_coords
argument_list|(
name|rect
argument_list|,
name|angle
argument_list|,
literal|0
argument_list|,
operator|&
name|pt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|moveTo
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QPainterPath::currentPosition() const      Returns the current position of the path. */
end_comment
begin_function
DECL|function|currentPosition
name|QPointF
name|QPainterPath
operator|::
name|currentPosition
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d_ptr
operator|||
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|isEmpty
argument_list|()
condition|?
name|QPointF
argument_list|()
else|:
name|QPointF
argument_list|(
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|x
argument_list|,
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::addRect(qreal x, qreal y, qreal width, qreal height)      \overload      Adds a rectangle at position (\a{x}, \a{y}), with the given \a     width and \a height, as a closed subpath. */
end_comment
begin_comment
comment|/*!     \fn void QPainterPath::addRect(const QRectF&rectangle)      Adds the given \a rectangle to this path as a closed subpath.      The \a rectangle is added as a clockwise set of lines. The painter     path's current position after the \a rectangle has been added is     at the top-left corner of the rectangle.      \table 100%     \row     \li \inlineimage qpainterpath-addrectangle.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 3     \endtable      \sa addRegion(), lineTo(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath} */
end_comment
begin_function
DECL|function|addRect
name|void
name|QPainterPath
operator|::
name|addRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|r
operator|.
name|y
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|r
operator|.
name|width
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|r
operator|.
name|height
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::addRect: Adding rect where a parameter is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|bool
name|first
init|=
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|<
literal|2
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|reserve
argument_list|(
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
literal|5
argument_list|)
expr_stmt|;
name|moveTo
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|Element
name|l1
init|=
block|{
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
block|,
name|r
operator|.
name|y
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|Element
name|l2
init|=
block|{
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
block|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|Element
name|l3
init|=
block|{
name|r
operator|.
name|x
argument_list|()
block|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|Element
name|l4
init|=
block|{
name|r
operator|.
name|x
argument_list|()
block|,
name|r
operator|.
name|y
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|<<
name|l1
operator|<<
name|l2
operator|<<
name|l3
operator|<<
name|l4
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|require_moveTo
operator|=
literal|true
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|convex
operator|=
name|first
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the given \a polygon to the path as an (unclosed) subpath.      Note that the current position after the polygon has been added,     is the last point in \a polygon. To draw a line back to the first     point, use the closeSubpath() function.      \table 100%     \row     \li \inlineimage qpainterpath-addpolygon.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 4     \endtable      \sa lineTo(), {QPainterPath#Composing a QPainterPath}{Composing     a QPainterPath} */
end_comment
begin_function
DECL|function|addPolygon
name|void
name|QPainterPath
operator|::
name|addPolygon
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
block|{
if|if
condition|(
name|polygon
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|reserve
argument_list|(
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
name|polygon
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|moveTo
argument_list|(
name|polygon
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|polygon
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Element
name|elm
init|=
block|{
name|polygon
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|x
argument_list|()
block|,
name|polygon
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|y
argument_list|()
block|,
name|LineToElement
block|}
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|<<
name|elm
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::addEllipse(const QRectF&boundingRectangle)      Creates an ellipse within the specified \a boundingRectangle     and adds it to the painter path as a closed subpath.      The ellipse is composed of a clockwise curve, starting and     finishing at zero degrees (the 3 o'clock position).      \table 100%     \row     \li \inlineimage qpainterpath-addellipse.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 5     \endtable      \sa arcTo(), QPainter::drawEllipse(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath} */
end_comment
begin_function
DECL|function|addEllipse
name|void
name|QPainterPath
operator|::
name|addEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|boundingRect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|boundingRect
operator|.
name|x
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|boundingRect
operator|.
name|y
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|boundingRect
operator|.
name|width
argument_list|()
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|boundingRect
operator|.
name|height
argument_list|()
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QPainterPath::addEllipse: Adding ellipse where a parameter is NaN or Inf, ignoring call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|boundingRect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
name|bool
name|first
init|=
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|<
literal|2
decl_stmt|;
name|d
operator|->
name|elements
operator|.
name|reserve
argument_list|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
literal|13
argument_list|)
expr_stmt|;
name|QPointF
name|pts
index|[
literal|12
index|]
decl_stmt|;
name|int
name|point_count
decl_stmt|;
name|QPointF
name|start
init|=
name|qt_curves_for_arc
argument_list|(
name|boundingRect
argument_list|,
literal|0
argument_list|,
operator|-
literal|360
argument_list|,
name|pts
argument_list|,
operator|&
name|point_count
argument_list|)
decl_stmt|;
name|moveTo
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|cubicTo
argument_list|(
name|pts
index|[
literal|0
index|]
argument_list|,
name|pts
index|[
literal|1
index|]
argument_list|,
name|pts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|// 0 -> 270
name|cubicTo
argument_list|(
name|pts
index|[
literal|3
index|]
argument_list|,
name|pts
index|[
literal|4
index|]
argument_list|,
name|pts
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|// 270 -> 180
name|cubicTo
argument_list|(
name|pts
index|[
literal|6
index|]
argument_list|,
name|pts
index|[
literal|7
index|]
argument_list|,
name|pts
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|// 180 -> 90
name|cubicTo
argument_list|(
name|pts
index|[
literal|9
index|]
argument_list|,
name|pts
index|[
literal|10
index|]
argument_list|,
name|pts
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
comment|// 90 ->0
name|d_func
argument_list|()
operator|->
name|require_moveTo
operator|=
literal|true
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|convex
operator|=
name|first
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::addText(const QPointF&point, const QFont&font, const QString&text)      Adds the given \a text to this path as a set of closed subpaths     created from the \a font supplied. The subpaths are positioned so     that the left end of the text's baseline lies at the specified \a     point.      \table 100%     \row     \li \inlineimage qpainterpath-addtext.png     \li     \snippet code/src_gui_painting_qpainterpath.cpp 6     \endtable      \sa QPainter::drawText(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath} */
end_comment
begin_function
DECL|function|addText
name|void
name|QPainterPath
operator|::
name|addText
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|,
specifier|const
name|QFont
modifier|&
name|f
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QTextLayout
name|layout
argument_list|(
name|text
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|layout
operator|.
name|setCacheEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QTextEngine
modifier|*
name|eng
init|=
name|layout
operator|.
name|engine
argument_list|()
decl_stmt|;
name|layout
operator|.
name|beginLayout
argument_list|()
expr_stmt|;
name|QTextLine
name|line
init|=
name|layout
operator|.
name|createLine
argument_list|()
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|layout
operator|.
name|endLayout
argument_list|()
expr_stmt|;
specifier|const
name|QScriptLine
modifier|&
name|sl
init|=
name|eng
operator|->
name|lines
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|length
operator|||
operator|!
name|eng
operator|->
name|layoutData
condition|)
return|return;
name|int
name|nItems
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
decl_stmt|;
name|qreal
name|x
argument_list|(
name|point
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|y
argument_list|(
name|point
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|visualOrder
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|uchar
argument_list|>
name|levels
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
name|levels
index|[
name|i
index|]
operator|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|i
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
expr_stmt|;
name|QTextEngine
operator|::
name|bidiReorder
argument_list|(
name|nItems
argument_list|,
name|levels
operator|.
name|data
argument_list|()
argument_list|,
name|visualOrder
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
block|{
name|int
name|item
init|=
name|visualOrder
index|[
name|i
index|]
decl_stmt|;
name|QScriptItem
modifier|&
name|si
init|=
name|eng
operator|->
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|<
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
name|QGlyphLayout
name|glyphs
init|=
name|eng
operator|->
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|fe
init|=
name|f
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|si
operator|.
name|analysis
operator|.
name|script
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|fe
argument_list|)
expr_stmt|;
name|fe
operator|->
name|addOutlineToPath
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|glyphs
argument_list|,
name|this
argument_list|,
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|?
name|QTextItem
operator|::
name|RenderFlags
argument_list|(
name|QTextItem
operator|::
name|RightToLeft
argument_list|)
else|:
name|QTextItem
operator|::
name|RenderFlags
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|lw
init|=
name|fe
operator|->
name|lineThickness
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|d
operator|->
name|underline
condition|)
block|{
name|qreal
name|pos
init|=
name|fe
operator|->
name|underlinePosition
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|addRect
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|pos
argument_list|,
name|si
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|d
operator|->
name|overline
condition|)
block|{
name|qreal
name|pos
init|=
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
operator|+
literal|1
decl_stmt|;
name|addRect
argument_list|(
name|x
argument_list|,
name|y
operator|-
name|pos
argument_list|,
name|si
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|d
operator|->
name|strikeOut
condition|)
block|{
name|qreal
name|pos
init|=
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
operator|/
literal|3
decl_stmt|;
name|addRect
argument_list|(
name|x
argument_list|,
name|y
operator|-
name|pos
argument_list|,
name|si
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|lw
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|+=
name|si
operator|.
name|width
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::addPath(const QPainterPath&path)      Adds the given \a path to \e this path as a closed subpath.      \sa connectPath(), {QPainterPath#Composing a     QPainterPath}{Composing a QPainterPath} */
end_comment
begin_function
DECL|function|addPath
name|void
name|QPainterPath
operator|::
name|addPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPathData
modifier|*
name|d
init|=
cast|reinterpret_cast
argument_list|<
name|QPainterPathData
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
comment|// Remove last moveto so we don't get multiple moveto's
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|type
operator|==
name|MoveToElement
condition|)
name|d
operator|->
name|elements
operator|.
name|remove
argument_list|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Locate where our own current subpath will start after the other path is added.
name|int
name|cStart
init|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
name|other
operator|.
name|d_func
argument_list|()
operator|->
name|cStart
decl_stmt|;
name|d
operator|->
name|elements
operator|+=
name|other
operator|.
name|d_func
argument_list|()
operator|->
name|elements
expr_stmt|;
name|d
operator|->
name|cStart
operator|=
name|cStart
expr_stmt|;
name|d
operator|->
name|require_moveTo
operator|=
name|other
operator|.
name|d_func
argument_list|()
operator|->
name|isClosed
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::connectPath(const QPainterPath&path)      Connects the given \a path to \e this path by adding a line from the     last element of this path to the first element of the given path.      \sa addPath(), {QPainterPath#Composing a QPainterPath}{Composing     a QPainterPath} */
end_comment
begin_function
DECL|function|connectPath
name|void
name|QPainterPath
operator|::
name|connectPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPathData
modifier|*
name|d
init|=
cast|reinterpret_cast
argument_list|<
name|QPainterPathData
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
comment|// Remove last moveto so we don't get multiple moveto's
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|last
argument_list|()
operator|.
name|type
operator|==
name|MoveToElement
condition|)
name|d
operator|->
name|elements
operator|.
name|remove
argument_list|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Locate where our own current subpath will start after the other path is added.
name|int
name|cStart
init|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
name|other
operator|.
name|d_func
argument_list|()
operator|->
name|cStart
decl_stmt|;
name|int
name|first
init|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
decl_stmt|;
name|d
operator|->
name|elements
operator|+=
name|other
operator|.
name|d_func
argument_list|()
operator|->
name|elements
expr_stmt|;
if|if
condition|(
name|first
operator|!=
literal|0
condition|)
name|d
operator|->
name|elements
index|[
name|first
index|]
operator|.
name|type
operator|=
name|LineToElement
expr_stmt|;
comment|// avoid duplicate points
if|if
condition|(
name|first
operator|>
literal|0
operator|&&
name|QPointF
argument_list|(
name|d
operator|->
name|elements
index|[
name|first
index|]
argument_list|)
operator|==
name|QPointF
argument_list|(
name|d
operator|->
name|elements
index|[
name|first
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|d
operator|->
name|elements
operator|.
name|remove
argument_list|(
name|first
operator|--
argument_list|)
expr_stmt|;
operator|--
name|cStart
expr_stmt|;
block|}
if|if
condition|(
name|cStart
operator|!=
name|first
condition|)
name|d
operator|->
name|cStart
operator|=
name|cStart
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the given \a region to the path by adding each rectangle in     the region as a separate closed subpath.      \sa addRect(), {QPainterPath#Composing a QPainterPath}{Composing     a QPainterPath} */
end_comment
begin_function
DECL|function|addRegion
name|void
name|QPainterPath
operator|::
name|addRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|reserve
argument_list|(
name|rects
operator|.
name|size
argument_list|()
operator|*
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|addRect
argument_list|(
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the painter path's currently set fill rule.      \sa setFillRule() */
end_comment
begin_function
DECL|function|fillRule
name|Qt
operator|::
name|FillRule
name|QPainterPath
operator|::
name|fillRule
parameter_list|()
specifier|const
block|{
return|return
name|isEmpty
argument_list|()
condition|?
name|Qt
operator|::
name|OddEvenFill
else|:
name|d_func
argument_list|()
operator|->
name|fillRule
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::setFillRule(Qt::FillRule fillRule)      Sets the fill rule of the painter path to the given \a     fillRule. Qt provides two methods for filling paths:      \table     \header     \li Qt::OddEvenFill (default)     \li Qt::WindingFill     \row     \li \inlineimage qt-fillrule-oddeven.png     \li \inlineimage qt-fillrule-winding.png     \endtable      \sa fillRule() */
end_comment
begin_function
DECL|function|setFillRule
name|void
name|QPainterPath
operator|::
name|setFillRule
parameter_list|(
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
name|ensureData
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|fillRule
operator|==
name|fillRule
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|fillRule
operator|=
name|fillRule
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|QT_BEZIER_A
define|#
directive|define
name|QT_BEZIER_A
parameter_list|(
name|bezier
parameter_list|,
name|coord
parameter_list|)
value|3 * (-bezier.coord##1 \                                         + 3*bezier.coord##2 \                                         - 3*bezier.coord##3 \                                         +bezier.coord##4)
end_define
begin_define
DECL|macro|QT_BEZIER_B
define|#
directive|define
name|QT_BEZIER_B
parameter_list|(
name|bezier
parameter_list|,
name|coord
parameter_list|)
value|6 * (bezier.coord##1 \                                         - 2*bezier.coord##2 \                                         + bezier.coord##3)
end_define
begin_define
DECL|macro|QT_BEZIER_C
define|#
directive|define
name|QT_BEZIER_C
parameter_list|(
name|bezier
parameter_list|,
name|coord
parameter_list|)
value|3 * (- bezier.coord##1 \                                         + bezier.coord##2)
end_define
begin_define
DECL|macro|QT_BEZIER_CHECK_T
define|#
directive|define
name|QT_BEZIER_CHECK_T
parameter_list|(
name|bezier
parameter_list|,
name|t
parameter_list|)
define|\
value|if (t>= 0&& t<= 1) { \         QPointF p(b.pointAt(t)); \         if (p.x()< minx) minx = p.x(); \         else if (p.x()> maxx) maxx = p.x(); \         if (p.y()< miny) miny = p.y(); \         else if (p.y()> maxy) maxy = p.y(); \     }
end_define
begin_function
DECL|function|qt_painterpath_bezier_extrema
specifier|static
name|QRectF
name|qt_painterpath_bezier_extrema
parameter_list|(
specifier|const
name|QBezier
modifier|&
name|b
parameter_list|)
block|{
name|qreal
name|minx
decl_stmt|,
name|miny
decl_stmt|,
name|maxx
decl_stmt|,
name|maxy
decl_stmt|;
comment|// initialize with end points
if|if
condition|(
name|b
operator|.
name|x1
operator|<
name|b
operator|.
name|x4
condition|)
block|{
name|minx
operator|=
name|b
operator|.
name|x1
expr_stmt|;
name|maxx
operator|=
name|b
operator|.
name|x4
expr_stmt|;
block|}
else|else
block|{
name|minx
operator|=
name|b
operator|.
name|x4
expr_stmt|;
name|maxx
operator|=
name|b
operator|.
name|x1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|.
name|y1
operator|<
name|b
operator|.
name|y4
condition|)
block|{
name|miny
operator|=
name|b
operator|.
name|y1
expr_stmt|;
name|maxy
operator|=
name|b
operator|.
name|y4
expr_stmt|;
block|}
else|else
block|{
name|miny
operator|=
name|b
operator|.
name|y4
expr_stmt|;
name|maxy
operator|=
name|b
operator|.
name|y1
expr_stmt|;
block|}
comment|// Update for the X extrema
block|{
name|qreal
name|ax
init|=
name|QT_BEZIER_A
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|qreal
name|bx
init|=
name|QT_BEZIER_B
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|qreal
name|cx
init|=
name|QT_BEZIER_C
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
decl_stmt|;
comment|// specialcase quadratic curves to avoid div by zero
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|ax
argument_list|)
condition|)
block|{
comment|// linear curves are covered by initialization.
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|bx
argument_list|)
condition|)
block|{
name|qreal
name|t
init|=
operator|-
name|cx
operator|/
name|bx
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|qreal
name|tx
init|=
name|bx
operator|*
name|bx
operator|-
literal|4
operator|*
name|ax
operator|*
name|cx
decl_stmt|;
if|if
condition|(
name|tx
operator|>=
literal|0
condition|)
block|{
name|qreal
name|temp
init|=
name|qSqrt
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|qreal
name|rcp
init|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|ax
operator|)
decl_stmt|;
name|qreal
name|t1
init|=
operator|(
operator|-
name|bx
operator|+
name|temp
operator|)
operator|*
name|rcp
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|qreal
name|t2
init|=
operator|(
operator|-
name|bx
operator|-
name|temp
operator|)
operator|*
name|rcp
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Update for the Y extrema
block|{
name|qreal
name|ay
init|=
name|QT_BEZIER_A
argument_list|(
name|b
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|qreal
name|by
init|=
name|QT_BEZIER_B
argument_list|(
name|b
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|qreal
name|cy
init|=
name|QT_BEZIER_C
argument_list|(
name|b
argument_list|,
name|y
argument_list|)
decl_stmt|;
comment|// specialcase quadratic curves to avoid div by zero
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|ay
argument_list|)
condition|)
block|{
comment|// linear curves are covered by initialization.
if|if
condition|(
operator|!
name|qFuzzyIsNull
argument_list|(
name|by
argument_list|)
condition|)
block|{
name|qreal
name|t
init|=
operator|-
name|cy
operator|/
name|by
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|qreal
name|ty
init|=
name|by
operator|*
name|by
operator|-
literal|4
operator|*
name|ay
operator|*
name|cy
decl_stmt|;
if|if
condition|(
name|ty
operator|>
literal|0
condition|)
block|{
name|qreal
name|temp
init|=
name|qSqrt
argument_list|(
name|ty
argument_list|)
decl_stmt|;
name|qreal
name|rcp
init|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|ay
operator|)
decl_stmt|;
name|qreal
name|t1
init|=
operator|(
operator|-
name|by
operator|+
name|temp
operator|)
operator|*
name|rcp
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|qreal
name|t2
init|=
operator|(
operator|-
name|by
operator|-
name|temp
operator|)
operator|*
name|rcp
decl_stmt|;
name|QT_BEZIER_CHECK_T
argument_list|(
name|b
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|QRectF
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of this painter path as a rectangle with     floating point precision.      \sa controlPointRect() */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QPainterPath
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
condition|)
return|return
name|QRectF
argument_list|()
return|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|dirtyBounds
condition|)
name|computeBoundingRect
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|bounds
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the rectangle containing all the points and control points     in this path.      This function is significantly faster to compute than the exact     boundingRect(), and the returned rectangle is always a superset of     the rectangle returned by boundingRect().      \sa boundingRect() */
end_comment
begin_function
DECL|function|controlPointRect
name|QRectF
name|QPainterPath
operator|::
name|controlPointRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
condition|)
return|return
name|QRectF
argument_list|()
return|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|dirtyControlBounds
condition|)
name|computeControlPointRect
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|controlBounds
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPainterPath::isEmpty() const      Returns \c true if either there are no elements in this path, or if the only     element is a MoveToElement; otherwise returns \c false.      \sa elementCount() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QPainterPath
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d_ptr
operator|||
operator|(
name|d_ptr
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|d_ptr
operator|->
name|elements
operator|.
name|first
argument_list|()
operator|.
name|type
operator|==
name|MoveToElement
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and returns a reversed copy of the path.      It is the order of the elements that is reversed: If a     QPainterPath is composed by calling the moveTo(), lineTo() and     cubicTo() functions in the specified order, the reversed copy is     composed by calling cubicTo(), lineTo() and moveTo(). */
end_comment
begin_function
DECL|function|toReversed
name|QPainterPath
name|QPainterPath
operator|::
name|toReversed
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainterPath
argument_list|)
expr_stmt|;
name|QPainterPath
name|rev
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|rev
operator|=
operator|*
name|this
expr_stmt|;
return|return
name|rev
return|;
block|}
name|rev
operator|.
name|moveTo
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|x
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|elm
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|prev
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elm
operator|.
name|type
condition|)
block|{
case|case
name|LineToElement
case|:
name|rev
operator|.
name|lineTo
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|MoveToElement
case|:
name|rev
operator|.
name|moveTo
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|CurveToDataElement
case|:
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|3
argument_list|)
expr_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|cp1
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|sp
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|prev
operator|.
name|type
operator|==
name|CurveToDataElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|cp1
operator|.
name|type
operator|==
name|CurveToElement
argument_list|)
expr_stmt|;
name|rev
operator|.
name|cubicTo
argument_list|(
name|prev
operator|.
name|x
argument_list|,
name|prev
operator|.
name|y
argument_list|,
name|cp1
operator|.
name|x
argument_list|,
name|cp1
operator|.
name|y
argument_list|,
name|sp
operator|.
name|x
argument_list|,
name|sp
operator|.
name|y
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
name|Q_ASSERT
argument_list|(
operator|!
literal|"qt_reversed_path"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|//qt_debug_path(rev);
return|return
name|rev
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the path into a list of polygons using the QTransform     \a matrix, and returns the list.      This function creates one polygon for each subpath regardless of     intersecting subpaths (i.e. overlapping bounding rectangles). To     make sure that such overlapping subpaths are filled correctly, use     the toFillPolygons() function instead.      \sa toFillPolygons(), toFillPolygon(), {QPainterPath#QPainterPath     Conversion}{QPainterPath Conversion} */
end_comment
begin_function
DECL|function|toSubpathPolygons
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|QPainterPath
operator|::
name|toSubpathPolygons
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainterPath
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|flatCurves
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|flatCurves
return|;
name|QPolygonF
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
if|if
condition|(
name|current
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|flatCurves
operator|+=
name|current
expr_stmt|;
name|current
operator|.
name|clear
argument_list|()
expr_stmt|;
name|current
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|current
operator|+=
name|QPointF
argument_list|(
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
operator|*
name|matrix
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|current
operator|+=
name|QPointF
argument_list|(
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
operator|*
name|matrix
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|CurveToDataElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|CurveToDataElement
argument_list|)
expr_stmt|;
name|QBezier
name|bezier
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|QPointF
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|x
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|y
argument_list|)
operator|*
name|matrix
argument_list|,
name|QPointF
argument_list|(
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|)
operator|*
name|matrix
argument_list|,
name|QPointF
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|x
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|y
argument_list|)
operator|*
name|matrix
argument_list|,
name|QPointF
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|.
name|x
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|.
name|y
argument_list|)
operator|*
name|matrix
argument_list|)
decl_stmt|;
name|bezier
operator|.
name|addToPolygon
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
name|Q_ASSERT
argument_list|(
operator|!
literal|"QPainterPath::toSubpathPolygons(), bad element type"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|current
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|flatCurves
operator|+=
name|current
expr_stmt|;
return|return
name|flatCurves
return|;
block|}
end_function
begin_comment
comment|/*!   \overload  */
end_comment
begin_function
DECL|function|toSubpathPolygons
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|QPainterPath
operator|::
name|toSubpathPolygons
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
return|return
name|toSubpathPolygons
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the path into a list of polygons using the     QTransform \a matrix, and returns the list.      The function differs from the toFillPolygon() function in that it     creates several polygons. It is provided because it is usually     faster to draw several small polygons than to draw one large     polygon, even though the total number of points drawn is the same.      The toFillPolygons() function differs from the toSubpathPolygons()     function in that it create only polygon for subpaths that have     overlapping bounding rectangles.      Like the toFillPolygon() function, this function uses a rewinding     technique to make sure that overlapping subpaths can be filled     using the correct fill rule. Note that rewinding inserts addition     lines in the polygons so the outline of the fill polygon does not     match the outline of the path.      \sa toSubpathPolygons(), toFillPolygon(),     {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion} */
end_comment
begin_function
DECL|function|toFillPolygons
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|QPainterPath
operator|::
name|toFillPolygons
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|polys
decl_stmt|;
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|subpaths
init|=
name|toSubpathPolygons
argument_list|(
name|matrix
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|subpaths
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|polys
return|;
name|QVector
argument_list|<
name|QRectF
argument_list|>
name|bounds
decl_stmt|;
name|bounds
operator|.
name|reserve
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|bounds
operator|+=
name|subpaths
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QPP_FILLPOLYGONS_DEBUG
name|printf
argument_list|(
literal|"QPainterPath::toFillPolygons, subpathCount=%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bounds
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|qDebug
argument_list|()
operator|<<
literal|" bounds"
operator|<<
name|i
operator|<<
name|bounds
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QVector
argument_list|<
name|QList
argument_list|<
name|int
argument_list|>
argument_list|>
name|isects
decl_stmt|;
name|isects
operator|.
name|resize
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|// find all intersections
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|subpaths
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
continue|continue;
name|QRectF
name|cbounds
init|=
name|bounds
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|cbounds
operator|.
name|intersects
argument_list|(
name|bounds
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|isects
index|[
name|j
index|]
operator|<<
name|i
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|QPP_FILLPOLYGONS_DEBUG
name|printf
argument_list|(
literal|"Intersections before flattening:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|isects
index|[
name|i
index|]
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|isects
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// flatten the sets of intersections
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|current_isects
init|=
name|isects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|current_isects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|isect_j
init|=
name|current_isects
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|isect_j
operator|==
name|i
condition|)
continue|continue;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|isects
index|[
name|isect_j
index|]
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|int
name|isect_k
init|=
name|isects
index|[
name|isect_j
index|]
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|isect_k
operator|!=
name|i
operator|&&
operator|!
name|isects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|isect_k
argument_list|)
condition|)
block|{
name|isects
index|[
name|i
index|]
operator|+=
name|isect_k
expr_stmt|;
block|}
block|}
name|isects
index|[
name|isect_j
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QPP_FILLPOLYGONS_DEBUG
name|printf
argument_list|(
literal|"Intersections after flattening:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|isects
index|[
name|i
index|]
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|isects
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Join the intersected subpaths as rewinded polygons
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|subpath_list
init|=
name|isects
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|subpath_list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPolygonF
name|buildUp
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|subpath_list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QPolygonF
modifier|&
name|subpath
init|=
name|subpaths
operator|.
name|at
argument_list|(
name|subpath_list
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|buildUp
operator|+=
name|subpath
expr_stmt|;
if|if
condition|(
operator|!
name|subpath
operator|.
name|isClosed
argument_list|()
condition|)
name|buildUp
operator|+=
name|subpath
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|buildUp
operator|.
name|isClosed
argument_list|()
condition|)
name|buildUp
operator|+=
name|buildUp
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
name|polys
operator|+=
name|buildUp
expr_stmt|;
block|}
block|}
return|return
name|polys
return|;
block|}
end_function
begin_comment
comment|/*!   \overload  */
end_comment
begin_function
DECL|function|toFillPolygons
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|QPainterPath
operator|::
name|toFillPolygons
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
return|return
name|toFillPolygons
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//same as qt_polygon_isect_line in qpolygon.cpp
end_comment
begin_function
DECL|function|qt_painterpath_isect_line
specifier|static
name|void
name|qt_painterpath_isect_line
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p2
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|int
modifier|*
name|winding
parameter_list|)
block|{
name|qreal
name|x1
init|=
name|p1
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y1
init|=
name|p1
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|x2
init|=
name|p2
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y2
init|=
name|p2
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|dir
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
condition|)
block|{
comment|// ignore horizontal lines according to scan conversion rule
return|return;
block|}
elseif|else
if|if
condition|(
name|y2
operator|<
name|y1
condition|)
block|{
name|qreal
name|x_tmp
init|=
name|x2
decl_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|x_tmp
expr_stmt|;
name|qreal
name|y_tmp
init|=
name|y2
decl_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|y_tmp
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>=
name|y1
operator|&&
name|y
operator|<
name|y2
condition|)
block|{
name|qreal
name|x
init|=
name|x1
operator|+
operator|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
operator|(
name|y2
operator|-
name|y1
operator|)
operator|)
operator|*
operator|(
name|y
operator|-
name|y1
operator|)
decl_stmt|;
comment|// count up the winding number if we're
if|if
condition|(
name|x
operator|<=
name|pos
operator|.
name|x
argument_list|()
condition|)
block|{
operator|(
operator|*
name|winding
operator|)
operator|+=
name|dir
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|qt_painterpath_isect_curve
specifier|static
name|void
name|qt_painterpath_isect_curve
parameter_list|(
specifier|const
name|QBezier
modifier|&
name|bezier
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pt
parameter_list|,
name|int
modifier|*
name|winding
parameter_list|,
name|int
name|depth
init|=
literal|0
parameter_list|)
block|{
name|qreal
name|y
init|=
name|pt
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|x
init|=
name|pt
operator|.
name|x
argument_list|()
decl_stmt|;
name|QRectF
name|bounds
init|=
name|bezier
operator|.
name|bounds
argument_list|()
decl_stmt|;
comment|// potential intersection, divide and try again...
comment|// Please note that a sideeffect of the bottom exclusion is that
comment|// horizontal lines are dropped, but this is correct according to
comment|// scan conversion rules.
if|if
condition|(
name|y
operator|>=
name|bounds
operator|.
name|y
argument_list|()
operator|&&
name|y
operator|<
name|bounds
operator|.
name|y
argument_list|()
operator|+
name|bounds
operator|.
name|height
argument_list|()
condition|)
block|{
comment|// hit lower limit... This is a rough threshold, but its a
comment|// tradeoff between speed and precision.
specifier|const
name|qreal
name|lower_bound
init|=
name|qreal
argument_list|(
literal|.001
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|32
operator|||
operator|(
name|bounds
operator|.
name|width
argument_list|()
operator|<
name|lower_bound
operator|&&
name|bounds
operator|.
name|height
argument_list|()
operator|<
name|lower_bound
operator|)
condition|)
block|{
comment|// We make the assumption here that the curve starts to
comment|// approximate a line after while (i.e. that it doesn't
comment|// change direction drastically during its slope)
if|if
condition|(
name|bezier
operator|.
name|pt1
argument_list|()
operator|.
name|x
argument_list|()
operator|<=
name|x
condition|)
block|{
operator|(
operator|*
name|winding
operator|)
operator|+=
operator|(
name|bezier
operator|.
name|pt4
argument_list|()
operator|.
name|y
argument_list|()
operator|>
name|bezier
operator|.
name|pt1
argument_list|()
operator|.
name|y
argument_list|()
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return;
block|}
comment|// split curve and try again...
name|QBezier
name|first_half
decl_stmt|,
name|second_half
decl_stmt|;
name|bezier
operator|.
name|split
argument_list|(
operator|&
name|first_half
argument_list|,
operator|&
name|second_half
argument_list|)
expr_stmt|;
name|qt_painterpath_isect_curve
argument_list|(
name|first_half
argument_list|,
name|pt
argument_list|,
name|winding
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qt_painterpath_isect_curve
argument_list|(
name|second_half
argument_list|,
name|pt
argument_list|,
name|winding
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QPainterPath::contains(const QPointF&point) const      Returns \c true if the given \a point is inside the path, otherwise     returns \c false.      \sa intersects() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QPainterPath
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pt
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
operator|!
name|controlPointRect
argument_list|()
operator|.
name|contains
argument_list|(
name|pt
argument_list|)
condition|)
return|return
literal|false
return|;
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|int
name|winding_number
init|=
literal|0
decl_stmt|;
name|QPointF
name|last_pt
decl_stmt|;
name|QPointF
name|last_start
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|MoveToElement
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|// implicitly close all paths.
name|qt_painterpath_isect_line
argument_list|(
name|last_pt
argument_list|,
name|last_start
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
name|last_start
operator|=
name|last_pt
operator|=
name|e
expr_stmt|;
break|break;
case|case
name|LineToElement
case|:
name|qt_painterpath_isect_line
argument_list|(
name|last_pt
argument_list|,
name|e
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
name|last_pt
operator|=
name|e
expr_stmt|;
break|break;
case|case
name|CurveToElement
case|:
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|cp2
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|ep
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
name|qt_painterpath_isect_curve
argument_list|(
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|last_pt
argument_list|,
name|e
argument_list|,
name|cp2
argument_list|,
name|ep
argument_list|)
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
name|last_pt
operator|=
name|ep
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|// implicitly close last subpath
if|if
condition|(
name|last_pt
operator|!=
name|last_start
condition|)
name|qt_painterpath_isect_line
argument_list|(
name|last_pt
argument_list|,
name|last_start
argument_list|,
name|pt
argument_list|,
operator|&
name|winding_number
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|fillRule
operator|==
name|Qt
operator|::
name|WindingFill
condition|?
operator|(
name|winding_number
operator|!=
literal|0
operator|)
else|:
operator|(
operator|(
name|winding_number
operator|%
literal|2
operator|)
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qt_painterpath_isect_line_rect
specifier|static
name|bool
name|qt_painterpath_isect_line_rect
parameter_list|(
name|qreal
name|x1
parameter_list|,
name|qreal
name|y1
parameter_list|,
name|qreal
name|x2
parameter_list|,
name|qreal
name|y2
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|qreal
name|left
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
name|qreal
name|right
init|=
name|rect
operator|.
name|right
argument_list|()
decl_stmt|;
name|qreal
name|top
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|rect
operator|.
name|bottom
argument_list|()
decl_stmt|;
enum|enum
block|{
name|Left
block|,
name|Right
block|,
name|Top
block|,
name|Bottom
block|}
enum|;
comment|// clip the lines, after cohen-sutherland, see e.g. http://www.nondot.org/~sabre/graphpro/line6.html
name|int
name|p1
init|=
operator|(
operator|(
name|x1
operator|<
name|left
operator|)
operator|<<
name|Left
operator|)
operator||
operator|(
operator|(
name|x1
operator|>
name|right
operator|)
operator|<<
name|Right
operator|)
operator||
operator|(
operator|(
name|y1
operator|<
name|top
operator|)
operator|<<
name|Top
operator|)
operator||
operator|(
operator|(
name|y1
operator|>
name|bottom
operator|)
operator|<<
name|Bottom
operator|)
decl_stmt|;
name|int
name|p2
init|=
operator|(
operator|(
name|x2
operator|<
name|left
operator|)
operator|<<
name|Left
operator|)
operator||
operator|(
operator|(
name|x2
operator|>
name|right
operator|)
operator|<<
name|Right
operator|)
operator||
operator|(
operator|(
name|y2
operator|<
name|top
operator|)
operator|<<
name|Top
operator|)
operator||
operator|(
operator|(
name|y2
operator|>
name|bottom
operator|)
operator|<<
name|Bottom
operator|)
decl_stmt|;
if|if
condition|(
name|p1
operator|&
name|p2
condition|)
comment|// completely inside
return|return
literal|false
return|;
if|if
condition|(
name|p1
operator||
name|p2
condition|)
block|{
name|qreal
name|dx
init|=
name|x2
operator|-
name|x1
decl_stmt|;
name|qreal
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
comment|// clip x coordinates
if|if
condition|(
name|x1
operator|<
name|left
condition|)
block|{
name|y1
operator|+=
name|dy
operator|/
name|dx
operator|*
operator|(
name|left
operator|-
name|x1
operator|)
expr_stmt|;
name|x1
operator|=
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
operator|>
name|right
condition|)
block|{
name|y1
operator|-=
name|dy
operator|/
name|dx
operator|*
operator|(
name|x1
operator|-
name|right
operator|)
expr_stmt|;
name|x1
operator|=
name|right
expr_stmt|;
block|}
if|if
condition|(
name|x2
operator|<
name|left
condition|)
block|{
name|y2
operator|+=
name|dy
operator|/
name|dx
operator|*
operator|(
name|left
operator|-
name|x2
operator|)
expr_stmt|;
name|x2
operator|=
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x2
operator|>
name|right
condition|)
block|{
name|y2
operator|-=
name|dy
operator|/
name|dx
operator|*
operator|(
name|x2
operator|-
name|right
operator|)
expr_stmt|;
name|x2
operator|=
name|right
expr_stmt|;
block|}
name|p1
operator|=
operator|(
operator|(
name|y1
operator|<
name|top
operator|)
operator|<<
name|Top
operator|)
operator||
operator|(
operator|(
name|y1
operator|>
name|bottom
operator|)
operator|<<
name|Bottom
operator|)
expr_stmt|;
name|p2
operator|=
operator|(
operator|(
name|y2
operator|<
name|top
operator|)
operator|<<
name|Top
operator|)
operator||
operator|(
operator|(
name|y2
operator|>
name|bottom
operator|)
operator|<<
name|Bottom
operator|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&
name|p2
condition|)
return|return
literal|false
return|;
comment|// clip y coordinates
if|if
condition|(
name|y1
operator|<
name|top
condition|)
block|{
name|x1
operator|+=
name|dx
operator|/
name|dy
operator|*
operator|(
name|top
operator|-
name|y1
operator|)
expr_stmt|;
name|y1
operator|=
name|top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y1
operator|>
name|bottom
condition|)
block|{
name|x1
operator|-=
name|dx
operator|/
name|dy
operator|*
operator|(
name|y1
operator|-
name|bottom
operator|)
expr_stmt|;
name|y1
operator|=
name|bottom
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|<
name|top
condition|)
block|{
name|x2
operator|+=
name|dx
operator|/
name|dy
operator|*
operator|(
name|top
operator|-
name|y2
operator|)
expr_stmt|;
name|y2
operator|=
name|top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y2
operator|>
name|bottom
condition|)
block|{
name|x2
operator|-=
name|dx
operator|/
name|dy
operator|*
operator|(
name|y2
operator|-
name|bottom
operator|)
expr_stmt|;
name|y2
operator|=
name|bottom
expr_stmt|;
block|}
name|p1
operator|=
operator|(
operator|(
name|x1
operator|<
name|left
operator|)
operator|<<
name|Left
operator|)
operator||
operator|(
operator|(
name|x1
operator|>
name|right
operator|)
operator|<<
name|Right
operator|)
expr_stmt|;
name|p2
operator|=
operator|(
operator|(
name|x2
operator|<
name|left
operator|)
operator|<<
name|Left
operator|)
operator||
operator|(
operator|(
name|x2
operator|>
name|right
operator|)
operator|<<
name|Right
operator|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&
name|p2
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|qt_isect_curve_horizontal
specifier|static
name|bool
name|qt_isect_curve_horizontal
parameter_list|(
specifier|const
name|QBezier
modifier|&
name|bezier
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
name|x1
parameter_list|,
name|qreal
name|x2
parameter_list|,
name|int
name|depth
init|=
literal|0
parameter_list|)
block|{
name|QRectF
name|bounds
init|=
name|bezier
operator|.
name|bounds
argument_list|()
decl_stmt|;
if|if
condition|(
name|y
operator|>=
name|bounds
operator|.
name|top
argument_list|()
operator|&&
name|y
operator|<
name|bounds
operator|.
name|bottom
argument_list|()
operator|&&
name|bounds
operator|.
name|right
argument_list|()
operator|>=
name|x1
operator|&&
name|bounds
operator|.
name|left
argument_list|()
operator|<
name|x2
condition|)
block|{
specifier|const
name|qreal
name|lower_bound
init|=
name|qreal
argument_list|(
literal|.01
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|32
operator|||
operator|(
name|bounds
operator|.
name|width
argument_list|()
operator|<
name|lower_bound
operator|&&
name|bounds
operator|.
name|height
argument_list|()
operator|<
name|lower_bound
operator|)
condition|)
return|return
literal|true
return|;
name|QBezier
name|first_half
decl_stmt|,
name|second_half
decl_stmt|;
name|bezier
operator|.
name|split
argument_list|(
operator|&
name|first_half
argument_list|,
operator|&
name|second_half
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_isect_curve_horizontal
argument_list|(
name|first_half
argument_list|,
name|y
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|||
name|qt_isect_curve_horizontal
argument_list|(
name|second_half
argument_list|,
name|y
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|qt_isect_curve_vertical
specifier|static
name|bool
name|qt_isect_curve_vertical
parameter_list|(
specifier|const
name|QBezier
modifier|&
name|bezier
parameter_list|,
name|qreal
name|x
parameter_list|,
name|qreal
name|y1
parameter_list|,
name|qreal
name|y2
parameter_list|,
name|int
name|depth
init|=
literal|0
parameter_list|)
block|{
name|QRectF
name|bounds
init|=
name|bezier
operator|.
name|bounds
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|bounds
operator|.
name|left
argument_list|()
operator|&&
name|x
operator|<
name|bounds
operator|.
name|right
argument_list|()
operator|&&
name|bounds
operator|.
name|bottom
argument_list|()
operator|>=
name|y1
operator|&&
name|bounds
operator|.
name|top
argument_list|()
operator|<
name|y2
condition|)
block|{
specifier|const
name|qreal
name|lower_bound
init|=
name|qreal
argument_list|(
literal|.01
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|32
operator|||
operator|(
name|bounds
operator|.
name|width
argument_list|()
operator|<
name|lower_bound
operator|&&
name|bounds
operator|.
name|height
argument_list|()
operator|<
name|lower_bound
operator|)
condition|)
return|return
literal|true
return|;
name|QBezier
name|first_half
decl_stmt|,
name|second_half
decl_stmt|;
name|bezier
operator|.
name|split
argument_list|(
operator|&
name|first_half
argument_list|,
operator|&
name|second_half
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_isect_curve_vertical
argument_list|(
name|first_half
argument_list|,
name|x
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|||
name|qt_isect_curve_vertical
argument_list|(
name|second_half
argument_list|,
name|x
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*     Returns \c true if any lines or curves cross the four edges in of rect */
end_comment
begin_function
DECL|function|qt_painterpath_check_crossing
specifier|static
name|bool
name|qt_painterpath_check_crossing
parameter_list|(
specifier|const
name|QPainterPath
modifier|*
name|path
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|QPointF
name|last_pt
decl_stmt|;
name|QPointF
name|last_start
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|->
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|path
operator|->
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|qFuzzyCompare
argument_list|(
name|last_pt
operator|.
name|x
argument_list|()
argument_list|,
name|last_start
operator|.
name|x
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|last_pt
operator|.
name|y
argument_list|()
argument_list|,
name|last_start
operator|.
name|y
argument_list|()
argument_list|)
operator|&&
name|qt_painterpath_isect_line_rect
argument_list|(
name|last_pt
operator|.
name|x
argument_list|()
argument_list|,
name|last_pt
operator|.
name|y
argument_list|()
argument_list|,
name|last_start
operator|.
name|x
argument_list|()
argument_list|,
name|last_start
operator|.
name|y
argument_list|()
argument_list|,
name|rect
argument_list|)
condition|)
return|return
literal|true
return|;
name|last_start
operator|=
name|last_pt
operator|=
name|e
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
if|if
condition|(
name|qt_painterpath_isect_line_rect
argument_list|(
name|last_pt
operator|.
name|x
argument_list|()
argument_list|,
name|last_pt
operator|.
name|y
argument_list|()
argument_list|,
name|e
operator|.
name|x
argument_list|,
name|e
operator|.
name|y
argument_list|,
name|rect
argument_list|)
condition|)
return|return
literal|true
return|;
name|last_pt
operator|=
name|e
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|QPointF
name|cp2
init|=
name|path
operator|->
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
name|QPointF
name|ep
init|=
name|path
operator|->
name|elementAt
argument_list|(
operator|++
name|i
argument_list|)
decl_stmt|;
name|QBezier
name|bezier
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|last_pt
argument_list|,
name|e
argument_list|,
name|cp2
argument_list|,
name|ep
argument_list|)
decl_stmt|;
if|if
condition|(
name|qt_isect_curve_horizontal
argument_list|(
name|bezier
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
operator|||
name|qt_isect_curve_horizontal
argument_list|(
name|bezier
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|,
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
operator|||
name|qt_isect_curve_vertical
argument_list|(
name|bezier
argument_list|,
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
operator|||
name|qt_isect_curve_vertical
argument_list|(
name|bezier
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
name|last_pt
operator|=
name|ep
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|// implicitly close last subpath
if|if
condition|(
name|last_pt
operator|!=
name|last_start
operator|&&
name|qt_painterpath_isect_line_rect
argument_list|(
name|last_pt
operator|.
name|x
argument_list|()
argument_list|,
name|last_pt
operator|.
name|y
argument_list|()
argument_list|,
name|last_start
operator|.
name|x
argument_list|()
argument_list|,
name|last_start
operator|.
name|y
argument_list|()
argument_list|,
name|rect
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPainterPath::intersects(const QRectF&rectangle) const      Returns \c true if any point in the given \a rectangle intersects the     path; otherwise returns \c false.      There is an intersection if any of the lines making up the     rectangle crosses a part of the path or if any part of the     rectangle overlaps with any area enclosed by the path. This     function respects the current fillRule to determine what is     considered inside the path.      \sa contains() */
end_comment
begin_function
DECL|function|intersects
name|bool
name|QPainterPath
operator|::
name|intersects
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|elementCount
argument_list|()
operator|==
literal|1
operator|&&
name|rect
operator|.
name|contains
argument_list|(
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QRectF
name|cp
init|=
name|controlPointRect
argument_list|()
decl_stmt|;
name|QRectF
name|rn
init|=
name|rect
operator|.
name|normalized
argument_list|()
decl_stmt|;
comment|// QRectF::intersects returns false if one of the rects is a null rect
comment|// which would happen for a painter path consisting of a vertical or
comment|// horizontal line
if|if
condition|(
name|qMax
argument_list|(
name|rn
operator|.
name|left
argument_list|()
argument_list|,
name|cp
operator|.
name|left
argument_list|()
argument_list|)
operator|>
name|qMin
argument_list|(
name|rn
operator|.
name|right
argument_list|()
argument_list|,
name|cp
operator|.
name|right
argument_list|()
argument_list|)
operator|||
name|qMax
argument_list|(
name|rn
operator|.
name|top
argument_list|()
argument_list|,
name|cp
operator|.
name|top
argument_list|()
argument_list|)
operator|>
name|qMin
argument_list|(
name|rn
operator|.
name|bottom
argument_list|()
argument_list|,
name|cp
operator|.
name|bottom
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// If any path element cross the rect its bound to be an intersection
if|if
condition|(
name|qt_painterpath_check_crossing
argument_list|(
name|this
argument_list|,
name|rect
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|contains
argument_list|(
name|rect
operator|.
name|center
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
comment|// Check if the rectangle surounds any subpath...
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|MoveToElement
operator|&&
name|rect
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Translates all elements in the path by (\a{dx}, \a{dy}).      \since 4.6     \sa translated() */
end_comment
begin_function
DECL|function|translate
name|void
name|QPainterPath
operator|::
name|translate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|||
operator|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|)
condition|)
return|return;
name|int
name|elementsLeft
init|=
name|d_ptr
operator|->
name|elements
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementsLeft
operator|<=
literal|0
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|QPainterPath
operator|::
name|Element
modifier|*
name|element
init|=
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|data
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|element
argument_list|)
expr_stmt|;
while|while
condition|(
name|elementsLeft
operator|--
condition|)
block|{
name|element
operator|->
name|x
operator|+=
name|dx
expr_stmt|;
name|element
operator|->
name|y
operator|+=
name|dy
expr_stmt|;
operator|++
name|element
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainterPath::translate(const QPointF&offset)     \overload     \since 4.6      Translates all elements in the path by the given \a offset.      \sa translated() */
end_comment
begin_comment
comment|/*!     Returns a copy of the path that is translated by (\a{dx}, \a{dy}).      \since 4.6     \sa translate() */
end_comment
begin_function
DECL|function|translated
name|QPainterPath
name|QPainterPath
operator|::
name|translated
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
specifier|const
block|{
name|QPainterPath
name|copy
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainterPath QPainterPath::translated(const QPointF&offset) const;     \overload     \since 4.6      Returns a copy of the path that is translated by the given \a offset.      \sa translate() */
end_comment
begin_comment
comment|/*!     \fn bool QPainterPath::contains(const QRectF&rectangle) const      Returns \c true if the given \a rectangle is inside the path,     otherwise returns \c false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QPainterPath
operator|::
name|contains
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
comment|// the path is empty or the control point rect doesn't completely
comment|// cover the rectangle we abort stratight away.
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
operator|!
name|controlPointRect
argument_list|()
operator|.
name|contains
argument_list|(
name|rect
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// if there are intersections, chances are that the rect is not
comment|// contained, except if we have winding rule, in which case it
comment|// still might.
if|if
condition|(
name|qt_painterpath_check_crossing
argument_list|(
name|this
argument_list|,
name|rect
argument_list|)
condition|)
block|{
if|if
condition|(
name|fillRule
argument_list|()
operator|==
name|Qt
operator|::
name|OddEvenFill
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// Do some wague sampling in the winding case. This is not
comment|// precise but it should mostly be good enough.
if|if
condition|(
operator|!
name|contains
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|||
operator|!
name|contains
argument_list|(
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
operator|||
operator|!
name|contains
argument_list|(
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
operator|||
operator|!
name|contains
argument_list|(
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// If there exists a point inside that is not part of the path its
comment|// because: rectangle lies completely outside path or a subpath
comment|// excludes parts of the rectangle. Both cases mean that the rect
comment|// is not contained
if|if
condition|(
operator|!
name|contains
argument_list|(
name|rect
operator|.
name|center
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// If there are any subpaths inside this rectangle we need to
comment|// check if they are still contained as a result of the fill
comment|// rule. This can only be the case for WindingFill though. For
comment|// OddEvenFill the rect will never be contained if it surrounds a
comment|// subpath. (the case where two subpaths are completely identical
comment|// can be argued but we choose to neglect it).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|MoveToElement
operator|&&
name|rect
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|fillRule
argument_list|()
operator|==
name|Qt
operator|::
name|OddEvenFill
condition|)
return|return
literal|false
return|;
name|bool
name|stop
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
operator|!
name|stop
operator|&&
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|el
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|el
operator|.
name|type
condition|)
block|{
case|case
name|MoveToElement
case|:
name|stop
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|LineToElement
case|:
if|if
condition|(
operator|!
name|contains
argument_list|(
name|el
argument_list|)
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|CurveToElement
case|:
if|if
condition|(
operator|!
name|contains
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|// compensate for the last ++i in the inner for
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|epsilonCompare
specifier|static
specifier|inline
name|bool
name|epsilonCompare
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|a
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|b
parameter_list|,
specifier|const
name|QSizeF
modifier|&
name|epsilon
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|a
operator|.
name|x
argument_list|()
operator|-
name|b
operator|.
name|x
argument_list|()
argument_list|)
operator|<=
name|epsilon
operator|.
name|width
argument_list|()
operator|&&
name|qAbs
argument_list|(
name|a
operator|.
name|y
argument_list|()
operator|-
name|b
operator|.
name|y
argument_list|()
argument_list|)
operator|<=
name|epsilon
operator|.
name|height
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this painterpath is equal to the given \a path.      Note that comparing paths may involve a per element comparison     which can be slow for complex paths.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QPainterPath
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|QPainterPathData
modifier|*
name|d
init|=
cast|reinterpret_cast
argument_list|<
name|QPainterPathData
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|d_func
argument_list|()
operator|==
name|d
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|path
operator|.
name|d_func
argument_list|()
condition|)
return|return
literal|false
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|fillRule
operator|!=
name|path
operator|.
name|d_func
argument_list|()
operator|->
name|fillRule
condition|)
return|return
literal|false
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|!=
name|path
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|qreal
name|qt_epsilon
init|=
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|?
literal|1e-12
else|:
name|qreal
argument_list|(
literal|1e-5
argument_list|)
decl_stmt|;
name|QSizeF
name|epsilon
init|=
name|boundingRect
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|epsilon
operator|.
name|rwidth
argument_list|()
operator|*=
name|qt_epsilon
expr_stmt|;
name|epsilon
operator|.
name|rheight
argument_list|()
operator|*=
name|qt_epsilon
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|!=
name|path
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
operator|||
operator|!
name|epsilonCompare
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|path
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|epsilon
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this painter path differs from the given \a path.      Note that comparing paths may involve a per element comparison     which can be slow for complex paths.      \sa operator==() */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QPainterPath
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|path
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the intersection of this path and the \a other path.      \sa intersected(), operator&=(), united(), operator|() */
end_comment
begin_function
DECL|function|operator &
name|QPainterPath
name|QPainterPath
operator|::
name|operator
name|&
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|intersected
argument_list|(
name|other
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the union of this path and the \a other path.      \sa united(), operator|=(), intersected(), operator&() */
end_comment
begin_function
DECL|function|operator |
name|QPainterPath
name|QPainterPath
operator|::
name|operator
name||
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|united
argument_list|(
name|other
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the union of this path and the \a other path. This function is equivalent     to operator|().      \sa united(), operator+=(), operator-() */
end_comment
begin_function
DECL|function|operator +
name|QPainterPath
name|QPainterPath
operator|::
name|operator
name|+
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|united
argument_list|(
name|other
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Subtracts the \a other path from a copy of this path, and returns the copy.      \sa subtracted(), operator-=(), operator+() */
end_comment
begin_function
DECL|function|operator -
name|QPainterPath
name|QPainterPath
operator|::
name|operator
name|-
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|subtracted
argument_list|(
name|other
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Intersects this path with \a other and returns a reference to this path.      \sa intersected(), operator&(), operator|=() */
end_comment
begin_function
DECL|function|operator &=
name|QPainterPath
modifier|&
name|QPainterPath
operator|::
name|operator
name|&=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|(
operator|*
name|this
operator|&
name|other
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Unites this path with \a other and returns a reference to this path.      \sa united(), operator|(), operator&=() */
end_comment
begin_function
DECL|function|operator |=
name|QPainterPath
modifier|&
name|QPainterPath
operator|::
name|operator
name||=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|(
operator|*
name|this
operator||
name|other
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Unites this path with \a other, and returns a reference to this path. This     is equivalent to operator|=().      \sa united(), operator+(), operator-=() */
end_comment
begin_function
DECL|function|operator +=
name|QPainterPath
modifier|&
name|QPainterPath
operator|::
name|operator
name|+=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|(
operator|*
name|this
operator|+
name|other
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Subtracts \a other from this path, and returns a reference to this     path.      \sa subtracted(), operator-(), operator+=() */
end_comment
begin_function
DECL|function|operator -=
name|QPainterPath
modifier|&
name|QPainterPath
operator|::
name|operator
name|-=
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|other
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
operator|(
operator|*
name|this
operator|-
name|other
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QPainterPath&path)     \relates QPainterPath      Writes the given painter \a path to the given \a stream, and     returns a reference to the \a stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|<<
name|p
operator|.
name|elementCount
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|s
operator|<<
name|int
argument_list|(
name|e
operator|.
name|type
argument_list|)
expr_stmt|;
name|s
operator|<<
name|double
argument_list|(
name|e
operator|.
name|x
argument_list|)
operator|<<
name|double
argument_list|(
name|e
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|s
operator|<<
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|cStart
expr_stmt|;
name|s
operator|<<
name|int
argument_list|(
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|fillRule
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QPainterPath&path)     \relates QPainterPath      Reads a painter path from the given \a stream into the specified \a path,     and returns a reference to the \a stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QPainterPath
modifier|&
name|p
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|s
operator|>>
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|s
return|;
name|p
operator|.
name|ensureData
argument_list|()
expr_stmt|;
comment|// in case if p.d_func() == 0
if|if
condition|(
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|type
operator|==
name|QPainterPath
operator|::
name|MoveToElement
argument_list|)
expr_stmt|;
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|reserve
argument_list|(
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|int
name|type
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|s
operator|>>
name|type
expr_stmt|;
name|s
operator|>>
name|x
expr_stmt|;
name|s
operator|>>
name|y
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|type
operator|>=
literal|0
operator|&&
name|type
operator|<=
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_is_finite
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|y
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDataStream::operator>>: NaN or Inf element found in path, skipping it"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|QPainterPath
operator|::
name|Element
name|elm
init|=
block|{
name|qreal
argument_list|(
name|x
argument_list|)
block|,
name|qreal
argument_list|(
name|y
argument_list|)
block|,
name|QPainterPath
operator|::
name|ElementType
operator|(
name|type
operator|)
block|}
decl_stmt|;
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|append
argument_list|(
name|elm
argument_list|)
expr_stmt|;
block|}
name|s
operator|>>
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|cStart
expr_stmt|;
name|int
name|fillRule
decl_stmt|;
name|s
operator|>>
name|fillRule
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|fillRule
operator|==
name|Qt
operator|::
name|OddEvenFill
operator|||
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|fillRule
operator|=
name|Qt
operator|::
name|FillRule
argument_list|(
name|fillRule
argument_list|)
expr_stmt|;
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|dirtyBounds
operator|=
literal|true
expr_stmt|;
name|p
operator|.
name|d_func
argument_list|()
operator|->
name|dirtyControlBounds
operator|=
literal|true
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*******************************************************************************  * class QPainterPathStroker  */
end_comment
begin_function
DECL|function|qt_path_stroke_move_to
name|void
name|qt_path_stroke_move_to
parameter_list|(
name|qfixed
name|x
parameter_list|,
name|qfixed
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QPainterPath
operator|*
operator|)
name|data
operator|)
operator|->
name|moveTo
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_path_stroke_line_to
name|void
name|qt_path_stroke_line_to
parameter_list|(
name|qfixed
name|x
parameter_list|,
name|qfixed
name|y
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QPainterPath
operator|*
operator|)
name|data
operator|)
operator|->
name|lineTo
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_path_stroke_cubic_to
name|void
name|qt_path_stroke_cubic_to
parameter_list|(
name|qfixed
name|c1x
parameter_list|,
name|qfixed
name|c1y
parameter_list|,
name|qfixed
name|c2x
parameter_list|,
name|qfixed
name|c2y
parameter_list|,
name|qfixed
name|ex
parameter_list|,
name|qfixed
name|ey
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|(
operator|(
name|QPainterPath
operator|*
operator|)
name|data
operator|)
operator|->
name|cubicTo
argument_list|(
name|qt_fixed_to_real
argument_list|(
name|c1x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|c1y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|c2x
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|c2y
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|ex
argument_list|)
argument_list|,
name|qt_fixed_to_real
argument_list|(
name|ey
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1     \class QPainterPathStroker     \ingroup painting     \inmodule QtGui      \brief The QPainterPathStroker class is used to generate fillable     outlines for a given painter path.      By calling the createStroke() function, passing a given     QPainterPath as argument, a new painter path representing the     outline of the given path is created. The newly created painter     path can then be filled to draw the original painter path's     outline.      You can control the various design aspects (width, cap styles,     join styles and dash pattern) of the outlining using the following     functions:      \list     \li setWidth()     \li setCapStyle()     \li setJoinStyle()     \li setDashPattern()     \endlist      The setDashPattern() function accepts both a Qt::PenStyle object     and a vector representation of the pattern as argument.      In addition you can specify a curve's threshold, controlling the     granularity with which a curve is drawn, using the     setCurveThreshold() function. The default threshold is a well     adjusted value (0.25), and normally you should not need to modify     it. However, you can make the curve's appearance smoother by     decreasing its value.      You can also control the miter limit for the generated outline     using the setMiterLimit() function. The miter limit describes how     far from each join the miter join can extend. The limit is     specified in the units of width so the pixelwise miter limit will     be \c {miterlimit * width}. This value is only used if the join     style is Qt::MiterJoin.      The painter path generated by the createStroke() function should     only be used for outlining the given painter path. Otherwise it     may cause unexpected behavior. Generated outlines also require the     Qt::WindingFill rule which is set by default.      \sa QPen, QBrush */
end_comment
begin_constructor
DECL|function|QPainterPathStrokerPrivate
name|QPainterPathStrokerPrivate
operator|::
name|QPainterPathStrokerPrivate
parameter_list|()
member_init_list|:
name|dashOffset
argument_list|(
literal|0
argument_list|)
block|{
name|stroker
operator|.
name|setMoveToHook
argument_list|(
name|qt_path_stroke_move_to
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setLineToHook
argument_list|(
name|qt_path_stroke_line_to
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setCubicToHook
argument_list|(
name|qt_path_stroke_cubic_to
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!    Creates a new stroker.  */
end_comment
begin_constructor
DECL|function|QPainterPathStroker
name|QPainterPathStroker
operator|::
name|QPainterPathStroker
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QPainterPathStrokerPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!    Creates a new stroker based on \a pen.     \since 5.3  */
end_comment
begin_constructor
DECL|function|QPainterPathStroker
name|QPainterPathStroker
operator|::
name|QPainterPathStroker
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QPainterPathStrokerPrivate
argument_list|)
block|{
name|setWidth
argument_list|(
name|pen
operator|.
name|widthF
argument_list|()
argument_list|)
expr_stmt|;
name|setCapStyle
argument_list|(
name|pen
operator|.
name|capStyle
argument_list|()
argument_list|)
expr_stmt|;
name|setJoinStyle
argument_list|(
name|pen
operator|.
name|joinStyle
argument_list|()
argument_list|)
expr_stmt|;
name|setMiterLimit
argument_list|(
name|pen
operator|.
name|miterLimit
argument_list|()
argument_list|)
expr_stmt|;
name|setDashOffset
argument_list|(
name|pen
operator|.
name|dashOffset
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|CustomDashLine
condition|)
name|setDashPattern
argument_list|(
name|pen
operator|.
name|dashPattern
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|setDashPattern
argument_list|(
name|pen
operator|.
name|style
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the stroker. */
end_comment
begin_destructor
DECL|function|~QPainterPathStroker
name|QPainterPathStroker
operator|::
name|~
name|QPainterPathStroker
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Generates a new path that is a fillable area representing the     outline of the given \a path.      The various design aspects of the outline are based on the     stroker's properties: width(), capStyle(), joinStyle(),     dashPattern(), curveThreshold() and miterLimit().      The generated path should only be used for outlining the given     painter path. Otherwise it may cause unexpected     behavior. Generated outlines also require the Qt::WindingFill rule     which is set by default. */
end_comment
begin_function
DECL|function|createStroke
name|QPainterPath
name|QPainterPathStroker
operator|::
name|createStroke
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|QPainterPathStrokerPrivate
modifier|*
name|d
init|=
cast|const_cast
argument_list|<
name|QPainterPathStrokerPrivate
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
name|QPainterPath
name|stroke
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|path
return|;
if|if
condition|(
name|d
operator|->
name|dashPattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|stroker
operator|.
name|strokePath
argument_list|(
name|path
argument_list|,
operator|&
name|stroke
argument_list|,
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDashStroker
name|dashStroker
argument_list|(
operator|&
name|d
operator|->
name|stroker
argument_list|)
decl_stmt|;
name|dashStroker
operator|.
name|setDashPattern
argument_list|(
name|d
operator|->
name|dashPattern
argument_list|)
expr_stmt|;
name|dashStroker
operator|.
name|setDashOffset
argument_list|(
name|d
operator|->
name|dashOffset
argument_list|)
expr_stmt|;
name|dashStroker
operator|.
name|setClipRect
argument_list|(
name|d
operator|->
name|stroker
operator|.
name|clipRect
argument_list|()
argument_list|)
expr_stmt|;
name|dashStroker
operator|.
name|strokePath
argument_list|(
name|path
argument_list|,
operator|&
name|stroke
argument_list|,
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|stroke
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
return|return
name|stroke
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the width of the generated outline painter path to \a width.      The generated outlines will extend approximately 50% of \a width     to each side of the given input path's original outline. */
end_comment
begin_function
DECL|function|setWidth
name|void
name|QPainterPathStroker
operator|::
name|setWidth
parameter_list|(
name|qreal
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainterPathStroker
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|width
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|stroker
operator|.
name|setStrokeWidth
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the generated outlines. */
end_comment
begin_function
DECL|function|width
name|qreal
name|QPainterPathStroker
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|qt_fixed_to_real
argument_list|(
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|strokeWidth
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the cap style of the generated outlines to \a style.  If a     dash pattern is set, each segment of the pattern is subject to the     cap \a style. */
end_comment
begin_function
DECL|function|setCapStyle
name|void
name|QPainterPathStroker
operator|::
name|setCapStyle
parameter_list|(
name|Qt
operator|::
name|PenCapStyle
name|style
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|setCapStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the cap style of the generated outlines. */
end_comment
begin_function
DECL|function|capStyle
name|Qt
operator|::
name|PenCapStyle
name|QPainterPathStroker
operator|::
name|capStyle
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|capStyle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the join style of the generated outlines to \a style. */
end_comment
begin_function
DECL|function|setJoinStyle
name|void
name|QPainterPathStroker
operator|::
name|setJoinStyle
parameter_list|(
name|Qt
operator|::
name|PenJoinStyle
name|style
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|setJoinStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the join style of the generated outlines. */
end_comment
begin_function
DECL|function|joinStyle
name|Qt
operator|::
name|PenJoinStyle
name|QPainterPathStroker
operator|::
name|joinStyle
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|joinStyle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the miter limit of the generated outlines to \a limit.      The miter limit describes how far from each join the miter join     can extend. The limit is specified in units of the currently set     width. So the pixelwise miter limit will be \c { miterlimit *     width}.      This value is only used if the join style is Qt::MiterJoin. */
end_comment
begin_function
DECL|function|setMiterLimit
name|void
name|QPainterPathStroker
operator|::
name|setMiterLimit
parameter_list|(
name|qreal
name|limit
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|setMiterLimit
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the miter limit for the generated outlines. */
end_comment
begin_function
DECL|function|miterLimit
name|qreal
name|QPainterPathStroker
operator|::
name|miterLimit
parameter_list|()
specifier|const
block|{
return|return
name|qt_fixed_to_real
argument_list|(
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|miterLimit
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Specifies the curve flattening \a threshold, controlling the     granularity with which the generated outlines' curve is drawn.      The default threshold is a well adjusted value (0.25), and     normally you should not need to modify it. However, you can make     the curve's appearance smoother by decreasing its value. */
end_comment
begin_function
DECL|function|setCurveThreshold
name|void
name|QPainterPathStroker
operator|::
name|setCurveThreshold
parameter_list|(
name|qreal
name|threshold
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|setCurveThreshold
argument_list|(
name|qt_real_to_fixed
argument_list|(
name|threshold
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the curve flattening threshold for the generated     outlines. */
end_comment
begin_function
DECL|function|curveThreshold
name|qreal
name|QPainterPathStroker
operator|::
name|curveThreshold
parameter_list|()
specifier|const
block|{
return|return
name|qt_fixed_to_real
argument_list|(
name|d_func
argument_list|()
operator|->
name|stroker
operator|.
name|curveThreshold
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the dash pattern for the generated outlines to \a style. */
end_comment
begin_function
DECL|function|setDashPattern
name|void
name|QPainterPathStroker
operator|::
name|setDashPattern
parameter_list|(
name|Qt
operator|::
name|PenStyle
name|style
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|dashPattern
operator|=
name|QDashStroker
operator|::
name|patternForStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the dash pattern for the generated outlines to \a     dashPattern.  This function makes it possible to specify custom     dash patterns.      Each element in the vector contains the lengths of the dashes and spaces     in the stroke, beginning with the first dash in the first element, the     first space in the second element, and alternating between dashes and     spaces for each following pair of elements.      The vector can contain an odd number of elements, in which case the last     element will be extended by the length of the first element when the     pattern repeats. */
end_comment
begin_function
DECL|function|setDashPattern
name|void
name|QPainterPathStroker
operator|::
name|setDashPattern
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|qreal
argument_list|>
modifier|&
name|dashPattern
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|dashPattern
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dashPattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|d_func
argument_list|()
operator|->
name|dashPattern
operator|<<
name|qt_real_to_fixed
argument_list|(
name|dashPattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the dash pattern for the generated outlines. */
end_comment
begin_function
DECL|function|dashPattern
name|QVector
argument_list|<
name|qreal
argument_list|>
name|QPainterPathStroker
operator|::
name|dashPattern
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|dashPattern
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the dash offset for the generated outlines.  */
end_comment
begin_function
DECL|function|dashOffset
name|qreal
name|QPainterPathStroker
operator|::
name|dashOffset
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|dashOffset
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the dash offset for the generated outlines to \a offset.    See the documentation for QPen::setDashOffset() for a description of the   dash offset.  */
end_comment
begin_function
DECL|function|setDashOffset
name|void
name|QPainterPathStroker
operator|::
name|setDashOffset
parameter_list|(
name|qreal
name|offset
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|dashOffset
operator|=
name|offset
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Converts the path into a polygon using the QTransform   \a matrix, and returns the polygon.    The polygon is created by first converting all subpaths to   polygons, then using a rewinding technique to make sure that   overlapping subpaths can be filled using the correct fill rule.    Note that rewinding inserts addition lines in the polygon so   the outline of the fill polygon does not match the outline of   the path.    \sa toSubpathPolygons(), toFillPolygons(),   {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion} */
end_comment
begin_function
DECL|function|toFillPolygon
name|QPolygonF
name|QPainterPath
operator|::
name|toFillPolygon
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QPolygonF
argument_list|>
name|flats
init|=
name|toSubpathPolygons
argument_list|(
name|matrix
argument_list|)
decl_stmt|;
name|QPolygonF
name|polygon
decl_stmt|;
if|if
condition|(
name|flats
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|polygon
return|;
name|QPointF
name|first
init|=
name|flats
operator|.
name|first
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|flats
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|polygon
operator|+=
name|flats
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flats
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isClosed
argument_list|()
condition|)
name|polygon
operator|+=
name|flats
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|polygon
operator|+=
name|first
expr_stmt|;
block|}
return|return
name|polygon
return|;
block|}
end_function
begin_comment
comment|/*!   \overload */
end_comment
begin_function
DECL|function|toFillPolygon
name|QPolygonF
name|QPainterPath
operator|::
name|toFillPolygon
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|)
specifier|const
block|{
return|return
name|toFillPolygon
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//derivative of the equation
end_comment
begin_function
DECL|function|slopeAt
specifier|static
specifier|inline
name|qreal
name|slopeAt
parameter_list|(
name|qreal
name|t
parameter_list|,
name|qreal
name|a
parameter_list|,
name|qreal
name|b
parameter_list|,
name|qreal
name|c
parameter_list|,
name|qreal
name|d
parameter_list|)
block|{
return|return
literal|3
operator|*
name|t
operator|*
name|t
operator|*
operator|(
name|d
operator|-
literal|3
operator|*
name|c
operator|+
literal|3
operator|*
name|b
operator|-
name|a
operator|)
operator|+
literal|6
operator|*
name|t
operator|*
operator|(
name|c
operator|-
literal|2
operator|*
name|b
operator|+
name|a
operator|)
operator|+
literal|3
operator|*
operator|(
name|b
operator|-
name|a
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the current path. */
end_comment
begin_function
DECL|function|length
name|qreal
name|QPainterPath
operator|::
name|length
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|qreal
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|MoveToElement
case|:
break|break;
case|case
name|LineToElement
case|:
block|{
name|len
operator|+=
name|QLineF
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|CurveToElement
case|:
block|{
name|QBezier
name|b
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|len
operator|+=
name|b
operator|.
name|length
argument_list|()
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Returns percentage of the whole path at the specified length \a len.      Note that similarly to other percent methods, the percentage measurement     is not linear with regards to the length, if curves are present     in the path. When curves are present the percentage argument is mapped     to the t parameter of the Bezier equations. */
end_comment
begin_function
DECL|function|percentAtLength
name|qreal
name|QPainterPath
operator|::
name|percentAtLength
parameter_list|(
name|qreal
name|len
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
name|QPainterPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|qreal
name|totalLength
init|=
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|totalLength
condition|)
return|return
literal|1
return|;
name|qreal
name|curLen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|MoveToElement
case|:
break|break;
case|case
name|LineToElement
case|:
block|{
name|QLineF
name|line
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|qreal
name|llen
init|=
name|line
operator|.
name|length
argument_list|()
decl_stmt|;
name|curLen
operator|+=
name|llen
expr_stmt|;
if|if
condition|(
name|curLen
operator|>=
name|len
condition|)
block|{
return|return
name|len
operator|/
name|totalLength
return|;
block|}
break|break;
block|}
case|case
name|CurveToElement
case|:
block|{
name|QBezier
name|b
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|blen
init|=
name|b
operator|.
name|length
argument_list|()
decl_stmt|;
name|qreal
name|prevLen
init|=
name|curLen
decl_stmt|;
name|curLen
operator|+=
name|blen
expr_stmt|;
if|if
condition|(
name|curLen
operator|>=
name|len
condition|)
block|{
name|qreal
name|res
init|=
name|b
operator|.
name|tAtLength
argument_list|(
name|len
operator|-
name|prevLen
argument_list|)
decl_stmt|;
return|return
operator|(
name|res
operator|*
name|blen
operator|+
name|prevLen
operator|)
operator|/
name|totalLength
return|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|bezierAtT
specifier|static
specifier|inline
name|QBezier
name|bezierAtT
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|qreal
name|t
parameter_list|,
name|qreal
modifier|*
name|startingLength
parameter_list|,
name|qreal
modifier|*
name|bezierLength
parameter_list|)
block|{
operator|*
name|startingLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|1
condition|)
return|return
name|QBezier
argument_list|()
return|;
name|qreal
name|curLen
init|=
literal|0
decl_stmt|;
name|qreal
name|totalLength
init|=
name|path
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|int
name|lastElement
init|=
name|path
operator|.
name|elementCount
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|lastElement
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|&
name|e
init|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|QLineF
name|line
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|qreal
name|llen
init|=
name|line
operator|.
name|length
argument_list|()
decl_stmt|;
name|curLen
operator|+=
name|llen
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|lastElement
operator|||
name|curLen
operator|/
name|totalLength
operator|>=
name|t
condition|)
block|{
operator|*
name|bezierLength
operator|=
name|llen
expr_stmt|;
name|QPointF
name|a
init|=
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QPointF
name|delta
init|=
name|e
operator|-
name|a
decl_stmt|;
return|return
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|a
argument_list|,
name|a
operator|+
name|delta
operator|/
literal|3
argument_list|,
name|a
operator|+
literal|2
operator|*
name|delta
operator|/
literal|3
argument_list|,
name|e
argument_list|)
return|;
block|}
break|break;
block|}
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|QBezier
name|b
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|path
operator|.
name|elementAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|blen
init|=
name|b
operator|.
name|length
argument_list|()
decl_stmt|;
name|curLen
operator|+=
name|blen
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|==
name|lastElement
operator|||
name|curLen
operator|/
name|totalLength
operator|>=
name|t
condition|)
block|{
operator|*
name|bezierLength
operator|=
name|blen
expr_stmt|;
return|return
name|b
return|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
operator|*
name|startingLength
operator|=
name|curLen
expr_stmt|;
block|}
return|return
name|QBezier
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the point at at the percentage \a t of the current path.     The argument \a t has to be between 0 and 1.      Note that similarly to other percent methods, the percentage measurement     is not linear with regards to the length, if curves are present     in the path. When curves are present the percentage argument is mapped     to the t parameter of the Bezier equations. */
end_comment
begin_function
DECL|function|pointAtPercent
name|QPointF
name|QPainterPath
operator|::
name|pointAtPercent
parameter_list|(
name|qreal
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|t
argument_list|<
literal|0
operator|||
name|t
argument_list|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainterPath::pointAtPercent accepts only values between 0 and 1"
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|||
name|d_ptr
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QPointF
argument_list|()
return|;
if|if
condition|(
name|d_ptr
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|d_ptr
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
name|qreal
name|totalLength
init|=
name|length
argument_list|()
decl_stmt|;
name|qreal
name|curLen
init|=
literal|0
decl_stmt|;
name|qreal
name|bezierLen
init|=
literal|0
decl_stmt|;
name|QBezier
name|b
init|=
name|bezierAtT
argument_list|(
operator|*
name|this
argument_list|,
name|t
argument_list|,
operator|&
name|curLen
argument_list|,
operator|&
name|bezierLen
argument_list|)
decl_stmt|;
name|qreal
name|realT
init|=
operator|(
name|totalLength
operator|*
name|t
operator|-
name|curLen
operator|)
operator|/
name|bezierLen
decl_stmt|;
return|return
name|b
operator|.
name|pointAt
argument_list|(
name|qBound
argument_list|(
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|realT
argument_list|,
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the angle of the path tangent at the percentage \a t.     The argument \a t has to be between 0 and 1.      Positive values for the angles mean counter-clockwise while negative values     mean the clockwise direction. Zero degrees is at the 3 o'clock position.      Note that similarly to the other percent methods, the percentage measurement     is not linear with regards to the length if curves are present     in the path. When curves are present the percentage argument is mapped     to the t parameter of the Bezier equations. */
end_comment
begin_function
DECL|function|angleAtPercent
name|qreal
name|QPainterPath
operator|::
name|angleAtPercent
parameter_list|(
name|qreal
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|t
argument_list|<
literal|0
operator|||
name|t
argument_list|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainterPath::angleAtPercent accepts only values between 0 and 1"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|qreal
name|totalLength
init|=
name|length
argument_list|()
decl_stmt|;
name|qreal
name|curLen
init|=
literal|0
decl_stmt|;
name|qreal
name|bezierLen
init|=
literal|0
decl_stmt|;
name|QBezier
name|bez
init|=
name|bezierAtT
argument_list|(
operator|*
name|this
argument_list|,
name|t
argument_list|,
operator|&
name|curLen
argument_list|,
operator|&
name|bezierLen
argument_list|)
decl_stmt|;
name|qreal
name|realT
init|=
operator|(
name|totalLength
operator|*
name|t
operator|-
name|curLen
operator|)
operator|/
name|bezierLen
decl_stmt|;
name|qreal
name|m1
init|=
name|slopeAt
argument_list|(
name|realT
argument_list|,
name|bez
operator|.
name|x1
argument_list|,
name|bez
operator|.
name|x2
argument_list|,
name|bez
operator|.
name|x3
argument_list|,
name|bez
operator|.
name|x4
argument_list|)
decl_stmt|;
name|qreal
name|m2
init|=
name|slopeAt
argument_list|(
name|realT
argument_list|,
name|bez
operator|.
name|y1
argument_list|,
name|bez
operator|.
name|y2
argument_list|,
name|bez
operator|.
name|y3
argument_list|,
name|bez
operator|.
name|y4
argument_list|)
decl_stmt|;
return|return
name|QLineF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|)
operator|.
name|angle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the slope of the path at the percentage \a t. The     argument \a t has to be between 0 and 1.      Note that similarly to other percent methods, the percentage measurement     is not linear with regards to the length, if curves are present     in the path. When curves are present the percentage argument is mapped     to the t parameter of the Bezier equations. */
end_comment
begin_function
DECL|function|slopeAtPercent
name|qreal
name|QPainterPath
operator|::
name|slopeAtPercent
parameter_list|(
name|qreal
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|t
argument_list|<
literal|0
operator|||
name|t
argument_list|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainterPath::slopeAtPercent accepts only values between 0 and 1"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|qreal
name|totalLength
init|=
name|length
argument_list|()
decl_stmt|;
name|qreal
name|curLen
init|=
literal|0
decl_stmt|;
name|qreal
name|bezierLen
init|=
literal|0
decl_stmt|;
name|QBezier
name|bez
init|=
name|bezierAtT
argument_list|(
operator|*
name|this
argument_list|,
name|t
argument_list|,
operator|&
name|curLen
argument_list|,
operator|&
name|bezierLen
argument_list|)
decl_stmt|;
name|qreal
name|realT
init|=
operator|(
name|totalLength
operator|*
name|t
operator|-
name|curLen
operator|)
operator|/
name|bezierLen
decl_stmt|;
name|qreal
name|m1
init|=
name|slopeAt
argument_list|(
name|realT
argument_list|,
name|bez
operator|.
name|x1
argument_list|,
name|bez
operator|.
name|x2
argument_list|,
name|bez
operator|.
name|x3
argument_list|,
name|bez
operator|.
name|x4
argument_list|)
decl_stmt|;
name|qreal
name|m2
init|=
name|slopeAt
argument_list|(
name|realT
argument_list|,
name|bez
operator|.
name|y1
argument_list|,
name|bez
operator|.
name|y2
argument_list|,
name|bez
operator|.
name|y3
argument_list|,
name|bez
operator|.
name|y4
argument_list|)
decl_stmt|;
comment|//tangent line
name|qreal
name|slope
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m1
condition|)
name|slope
operator|=
name|m2
operator|/
name|m1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|qreal
argument_list|>
operator|::
name|has_infinity
condition|)
block|{
name|slope
operator|=
operator|(
name|m2
operator|<
literal|0
operator|)
condition|?
operator|-
name|std
operator|::
name|numeric_limits
argument_list|<
name|qreal
argument_list|>
operator|::
name|infinity
argument_list|()
else|:
name|std
operator|::
name|numeric_limits
argument_list|<
name|qreal
argument_list|>
operator|::
name|infinity
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
return|return
literal|1.79769313486231570e+308
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|qreal
operator|)
literal|3.40282346638528860e+38
operator|)
return|;
block|}
block|}
block|}
return|return
name|slope
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Adds the given rectangle \a rect with rounded corners to the path.    The \a xRadius and \a yRadius arguments specify the radii of   the ellipses defining the corners of the rounded rectangle.   When \a mode is Qt::RelativeSize, \a xRadius and   \a yRadius are specified in percentage of half the rectangle's   width and height respectively, and should be in the range 0.0 to 100.0.    \sa addRect() */
end_comment
begin_function
DECL|function|addRoundedRect
name|void
name|QPainterPath
operator|::
name|addRoundedRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xRadius
parameter_list|,
name|qreal
name|yRadius
parameter_list|,
name|Qt
operator|::
name|SizeMode
name|mode
parameter_list|)
block|{
name|QRectF
name|r
init|=
name|rect
operator|.
name|normalized
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|AbsoluteSize
condition|)
block|{
name|qreal
name|w
init|=
name|r
operator|.
name|width
argument_list|()
operator|/
literal|2
decl_stmt|;
name|qreal
name|h
init|=
name|r
operator|.
name|height
argument_list|()
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
name|xRadius
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xRadius
operator|=
literal|100
operator|*
name|qMin
argument_list|(
name|xRadius
argument_list|,
name|w
argument_list|)
operator|/
name|w
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|yRadius
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|yRadius
operator|=
literal|100
operator|*
name|qMin
argument_list|(
name|yRadius
argument_list|,
name|h
argument_list|)
operator|/
name|h
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xRadius
operator|>
literal|100
condition|)
comment|// fix ranges
name|xRadius
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|yRadius
operator|>
literal|100
condition|)
name|yRadius
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|xRadius
operator|<=
literal|0
operator|||
name|yRadius
operator|<=
literal|0
condition|)
block|{
comment|// add normal rectangle
name|addRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|qreal
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|rxx2
init|=
name|w
operator|*
name|xRadius
operator|/
literal|100
decl_stmt|;
name|qreal
name|ryy2
init|=
name|h
operator|*
name|yRadius
operator|/
literal|100
decl_stmt|;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|bool
name|first
init|=
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|<
literal|2
decl_stmt|;
name|arcMoveTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|180
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|180
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
operator|+
name|w
operator|-
name|rxx2
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|90
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
operator|+
name|w
operator|-
name|rxx2
argument_list|,
name|y
operator|+
name|h
operator|-
name|ryy2
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|0
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
name|ryy2
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|270
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|closeSubpath
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|require_moveTo
operator|=
literal|true
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|convex
operator|=
name|first
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QPainterPath::addRoundedRect(qreal x, qreal y, qreal w, qreal h, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);   \since 4.4   \overload    Adds the given rectangle \a x, \a y, \a w, \a h  with rounded corners to the path.  */
end_comment
begin_comment
comment|/*!   \obsolete    Adds a rectangle \a r with rounded corners to the path.    The \a xRnd and \a yRnd arguments specify how rounded the corners   should be. 0 is angled corners, 99 is maximum roundedness.    \sa addRoundedRect() */
end_comment
begin_function
DECL|function|addRoundRect
name|void
name|QPainterPath
operator|::
name|addRoundRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|xRnd
parameter_list|,
name|int
name|yRnd
parameter_list|)
block|{
if|if
condition|(
name|xRnd
operator|>=
literal|100
condition|)
comment|// fix ranges
name|xRnd
operator|=
literal|99
expr_stmt|;
if|if
condition|(
name|yRnd
operator|>=
literal|100
condition|)
name|yRnd
operator|=
literal|99
expr_stmt|;
if|if
condition|(
name|xRnd
operator|<=
literal|0
operator|||
name|yRnd
operator|<=
literal|0
condition|)
block|{
comment|// add normal rectangle
name|addRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|QRectF
name|rect
init|=
name|r
operator|.
name|normalized
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|qreal
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|rxx2
init|=
name|w
operator|*
name|xRnd
operator|/
literal|100
decl_stmt|;
name|qreal
name|ryy2
init|=
name|h
operator|*
name|yRnd
operator|/
literal|100
decl_stmt|;
name|ensureData
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|bool
name|first
init|=
name|d_func
argument_list|()
operator|->
name|elements
operator|.
name|size
argument_list|()
operator|<
literal|2
decl_stmt|;
name|arcMoveTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|180
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|180
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
operator|+
name|w
operator|-
name|rxx2
argument_list|,
name|y
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|90
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
operator|+
name|w
operator|-
name|rxx2
argument_list|,
name|y
operator|+
name|h
operator|-
name|ryy2
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|0
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|arcTo
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
name|ryy2
argument_list|,
name|rxx2
argument_list|,
name|ryy2
argument_list|,
literal|270
argument_list|,
operator|-
literal|90
argument_list|)
expr_stmt|;
name|closeSubpath
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|require_moveTo
operator|=
literal|true
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|convex
operator|=
name|first
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \obsolete    \fn bool QPainterPath::addRoundRect(const QRectF&rect, int roundness);   \since 4.3   \overload    Adds a rounded rectangle, \a rect, to the path.    The \a roundness argument specifies uniform roundness for the   rectangle.  Vertical and horizontal roundness factors will be   adjusted accordingly to act uniformly around both axes. Use this   method if you want a rectangle equally rounded across both the X and   Y axis.    \sa addRoundedRect() */
end_comment
begin_comment
comment|/*!   \obsolete    \fn void QPainterPath::addRoundRect(qreal x, qreal y, qreal w, qreal h, int xRnd, int yRnd);   \overload    Adds a rectangle with rounded corners to the path. The rectangle   is constructed from \a x, \a y, and the width and height \a w   and \a h.    The \a xRnd and \a yRnd arguments specify how rounded the corners   should be. 0 is angled corners, 99 is maximum roundedness.    \sa addRoundedRect()  */
end_comment
begin_comment
comment|/*!   \obsolete    \fn bool QPainterPath::addRoundRect(qreal x, qreal y, qreal width, qreal height, int roundness);   \since 4.3   \overload    Adds a rounded rectangle to the path, defined by the coordinates \a   x and \a y with the specified \a width and \a height.    The \a roundness argument specifies uniform roundness for the   rectangle. Vertical and horizontal roundness factors will be   adjusted accordingly to act uniformly around both axes. Use this   method if you want a rectangle equally rounded across both the X and   Y axis.    \sa addRoundedRect() */
end_comment
begin_comment
comment|/*!     \since 4.3      Returns a path which is the union of this path's fill area and \a p's fill area.      Set operations on paths will treat the paths as areas. Non-closed     paths will be treated as implicitly closed.     Bezier curves may be flattened to line segments due to numerical instability of     doing bezier curve intersections.      \sa intersected(), subtracted() */
end_comment
begin_function
DECL|function|united
name|QPainterPath
name|QPainterPath
operator|::
name|united
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|isEmpty
argument_list|()
condition|?
name|p
else|:
operator|*
name|this
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|clip
argument_list|(
name|QPathClipper
operator|::
name|BoolOr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a path which is the intersection of this path's fill area and \a p's fill area.     Bezier curves may be flattened to line segments due to numerical instability of     doing bezier curve intersections. */
end_comment
begin_function
DECL|function|intersected
name|QPainterPath
name|QPainterPath
operator|::
name|intersected
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPainterPath
argument_list|()
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|clip
argument_list|(
name|QPathClipper
operator|::
name|BoolAnd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns a path which is \a p's fill area subtracted from this path's fill area.      Set operations on paths will treat the paths as areas. Non-closed     paths will be treated as implicitly closed.     Bezier curves may be flattened to line segments due to numerical instability of     doing bezier curve intersections. */
end_comment
begin_function
DECL|function|subtracted
name|QPainterPath
name|QPainterPath
operator|::
name|subtracted
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|clip
argument_list|(
name|QPathClipper
operator|::
name|BoolSub
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3     \obsolete      Use subtracted() instead.      \sa subtracted() */
end_comment
begin_function
DECL|function|subtractedInverted
name|QPainterPath
name|QPainterPath
operator|::
name|subtractedInverted
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
return|return
name|p
operator|.
name|subtracted
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a simplified version of this path. This implies merging all subpaths that intersect,     and returning a path containing no intersecting edges. Consecutive parallel lines will also     be merged. The simplified path will always use the default fill rule, Qt::OddEvenFill.     Bezier curves may be flattened to line segments due to numerical instability of     doing bezier curve intersections. */
end_comment
begin_function
DECL|function|simplified
name|QPainterPath
name|QPainterPath
operator|::
name|simplified
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|QPainterPath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|clip
argument_list|(
name|QPathClipper
operator|::
name|Simplify
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.3    Returns \c true if the current path intersects at any point the given path \a p.   Also returns \c true if the current path contains or is contained by any part of \a p.    Set operations on paths will treat the paths as areas. Non-closed   paths will be treated as implicitly closed.    \sa contains()  */
end_comment
begin_function
DECL|function|intersects
name|bool
name|QPainterPath
operator|::
name|intersects
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|p
operator|.
name|elementCount
argument_list|()
operator|==
literal|1
condition|)
return|return
name|contains
argument_list|(
name|p
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|intersect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.3    Returns \c true if the given path \a p is contained within   the current path. Returns \c false if any edges of the current path and   \a p intersect.    Set operations on paths will treat the paths as areas. Non-closed   paths will be treated as implicitly closed.    \sa intersects()  */
end_comment
begin_function
DECL|function|contains
name|bool
name|QPainterPath
operator|::
name|contains
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|p
operator|.
name|elementCount
argument_list|()
operator|==
literal|1
condition|)
return|return
name|contains
argument_list|(
name|p
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QPathClipper
name|clipper
argument_list|(
operator|*
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|clipper
operator|.
name|contains
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setDirty
name|void
name|QPainterPath
operator|::
name|setDirty
parameter_list|(
name|bool
name|dirty
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|dirtyBounds
operator|=
name|dirty
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|dirtyControlBounds
operator|=
name|dirty
expr_stmt|;
operator|delete
name|d_func
argument_list|()
operator|->
name|pathConverter
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|pathConverter
operator|=
literal|0
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|convex
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|computeBoundingRect
name|void
name|QPainterPath
operator|::
name|computeBoundingRect
parameter_list|()
specifier|const
block|{
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirtyBounds
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
condition|)
block|{
name|d
operator|->
name|bounds
operator|=
name|QRect
argument_list|()
expr_stmt|;
return|return;
block|}
name|qreal
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|MoveToElement
case|:
case|case
name|LineToElement
case|:
if|if
condition|(
name|e
operator|.
name|x
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|e
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|.
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|e
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|y
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|e
operator|.
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|.
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|e
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|CurveToElement
case|:
block|{
name|QBezier
name|b
init|=
name|QBezier
operator|::
name|fromPoints
argument_list|(
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|e
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|QRectF
name|r
init|=
name|qt_painterpath_bezier_extrema
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|qreal
name|right
init|=
name|r
operator|.
name|right
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|r
operator|.
name|bottom
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|x
argument_list|()
operator|<
name|minx
condition|)
name|minx
operator|=
name|r
operator|.
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|right
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|y
argument_list|()
operator|<
name|miny
condition|)
name|miny
operator|=
name|r
operator|.
name|y
argument_list|()
expr_stmt|;
if|if
condition|(
name|bottom
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|bottom
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|d
operator|->
name|bounds
operator|=
name|QRectF
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|computeControlPointRect
name|void
name|QPainterPath
operator|::
name|computeControlPointRect
parameter_list|()
specifier|const
block|{
name|QPainterPathData
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirtyControlBounds
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
condition|)
block|{
name|d
operator|->
name|controlBounds
operator|=
name|QRect
argument_list|()
expr_stmt|;
return|return;
block|}
name|qreal
name|minx
decl_stmt|,
name|maxx
decl_stmt|,
name|miny
decl_stmt|,
name|maxy
decl_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|elements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Element
modifier|&
name|e
init|=
name|d
operator|->
name|elements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|x
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|e
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|.
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|e
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|y
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|e
operator|.
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|.
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|e
operator|.
name|y
expr_stmt|;
block|}
name|d
operator|->
name|controlBounds
operator|=
name|QRectF
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
operator|-
name|minx
argument_list|,
name|maxy
operator|-
name|miny
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|s
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|p
parameter_list|)
block|{
name|s
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QPainterPath: Element count="
operator|<<
name|p
operator|.
name|elementCount
argument_list|()
operator|<<
name|endl
expr_stmt|;
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"MoveTo"
block|,
literal|"LineTo"
block|,
literal|"CurveTo"
block|,
literal|"CurveToData"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|elementCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|.
name|nospace
argument_list|()
operator|<<
literal|" -> "
operator|<<
name|types
index|[
name|p
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|.
name|type
index|]
operator|<<
literal|"(x="
operator|<<
name|p
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|.
name|x
operator|<<
literal|", y="
operator|<<
name|p
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
operator|.
name|y
operator|<<
literal|')'
operator|<<
name|endl
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
