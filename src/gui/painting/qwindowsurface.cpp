begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<private/qwindowsurface_p.h>
end_include
begin_include
include|#
directive|include
file|<qwindow_qpa.h>
end_include
begin_include
include|#
directive|include
file|<private/qwindow_qpa_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qbackingstore_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QWindowSurfacePrivate
class|class
name|QWindowSurfacePrivate
block|{
public|public:
DECL|function|QWindowSurfacePrivate
name|QWindowSurfacePrivate
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|)
member_init_list|:
name|window
argument_list|(
name|w
argument_list|)
block|{     }
DECL|member|window
name|QWindow
modifier|*
name|window
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
DECL|member|geometry
name|QRect
name|geometry
decl_stmt|;
else|#
directive|else
DECL|member|size
name|QSize
name|size
decl_stmt|;
endif|#
directive|endif
comment|//Q_WS_QPA
DECL|member|staticContents
name|QRegion
name|staticContents
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QWindowSurface     \since 4.3     \internal     \preliminary     \ingroup qws qpa      \brief The QWindowSurface class provides the drawing area for top-level     windows. */
end_comment
begin_comment
comment|/*!     \fn void QWindowSurface::beginPaint(const QRegion&region)      This function is called before painting onto the surface begins,     with the \a region in which the painting will occur.      \sa endPaint(), paintDevice() */
end_comment
begin_comment
comment|/*!     \fn void QWindowSurface::endPaint(const QRegion&region)      This function is called after painting onto the surface has ended,     with the \a region in which the painting was performed.      \sa beginPaint(), paintDevice() */
end_comment
begin_comment
comment|/*!     \fn void QWindowSurface::flush(QWindow *window, const QRegion&region,                                   const QPoint&offset)      Flushes the given \a region from the specified \a window onto the     screen.      Note that the \a offset parameter is currently unused. */
end_comment
begin_comment
comment|/*!     \fn QPaintDevice* QWindowSurface::paintDevice()      Implement this function to return the appropriate paint device. */
end_comment
begin_comment
comment|/*!     Constructs an empty surface for the given top-level \a window. */
end_comment
begin_constructor
DECL|function|QWindowSurface
name|QWindowSurface
operator|::
name|QWindowSurface
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|bool
comment|/*setDefaultSurface*/
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QWindowSurfacePrivate
argument_list|(
name|window
argument_list|)
argument_list|)
block|{
if|#
directive|if
literal|0
block|if (!QApplicationPrivate::runtime_graphics_system) {         if (setDefaultSurface&& window)             window->setWindowSurface(this);     }
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destroys this surface. */
end_comment
begin_destructor
DECL|function|~QWindowSurface
name|QWindowSurface
operator|::
name|~
name|QWindowSurface
parameter_list|()
block|{
comment|//    if (d_ptr->window)
comment|//        d_ptr->window->d_func()->extra->topextra->windowSurface = 0;
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns a pointer to the top-level window associated with this     surface. */
end_comment
begin_function
DECL|function|window
name|QWindow
modifier|*
name|QWindowSurface
operator|::
name|window
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|window
return|;
block|}
end_function
begin_function
DECL|function|beginPaint
name|void
name|QWindowSurface
operator|::
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|endPaint
name|void
name|QWindowSurface
operator|::
name|endPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{
comment|//     QApplication::syncX();
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
end_if
begin_comment
comment|/*!     Sets the currently allocated area to be the given \a rect.      This function is called whenever area covered by the top-level     window changes.      \sa geometry() */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QWindowSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|d_ptr
operator|->
name|geometry
operator|=
name|rect
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently allocated area on the screen. */
end_comment
begin_function
DECL|function|geometry
name|QRect
name|QWindowSurface
operator|::
name|geometry
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|geometry
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!       Sets the size of the windowsurface to be \a size.        \sa size() */
end_comment
begin_function
DECL|function|resize
name|void
name|QWindowSurface
operator|::
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|d_ptr
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current size of the windowsurface. */
end_comment
begin_function
DECL|function|size
name|QSize
name|QWindowSurface
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|size
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_WS_QPA
end_comment
begin_comment
comment|/*!     Scrolls the given \a area \a dx pixels to the right and \a dy     downward; both \a dx and \a dy may be negative.      Returns true if the area was scrolled successfully; false otherwise. */
end_comment
begin_function
DECL|function|scroll
name|bool
name|QWindowSurface
operator|::
name|scroll
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|area
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|area
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|dy
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a QPixmap generated from the part of the backing store   corresponding to \a window. Returns a null QPixmap if an error   occurs. The contents of the pixmap are only defined for the regions   of \a window that have received paint events since the last resize   of the backing store.    If \a rectangle is a null rectangle (the default), the entire window   is grabbed. Otherwise, the grabbed area is limited to \a rectangle.    The default implementation uses QWindowSurface::buffer().    \sa QPixmap::grabWindow() */
end_comment
begin_function
DECL|function|grabWindow
name|QPixmap
name|QWindowSurface
operator|::
name|grabWindow
parameter_list|(
specifier|const
name|QWindow
modifier|*
parameter_list|,
specifier|const
name|QRect
modifier|&
parameter_list|)
specifier|const
block|{
name|QPixmap
name|result
decl_stmt|;
if|#
directive|if
literal|0
block|if (window->window() != window())         return result;      const QImage *img = const_cast<QWindowSurface *>(this)->buffer(window->window());      if (!img || img->isNull())         return result;      QRect rect = rectangle.isEmpty() ? window->rect() : (window->rect()& rectangle);      rect.translate(offset(window) - offset(window->window()));     rect&= QRect(QPoint(), img->size());      if (rect.isEmpty())         return result;      QImage subimg(img->scanLine(rect.y()) + rect.x() * img->depth() / 8,                   rect.width(), rect.height(),                   img->bytesPerLine(), img->format());     subimg.detach();
comment|//### expensive -- maybe we should have a real SubImage that shares reference count
block|result = QPixmap::fromImage(subimg);
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the offset of \a window in the coordinates of this   window surface.  */
end_comment
begin_function
DECL|function|offset
name|QPoint
name|QWindowSurface
operator|::
name|offset
parameter_list|(
specifier|const
name|QWindow
modifier|*
parameter_list|)
specifier|const
block|{
name|QPoint
name|offset
decl_stmt|;
if|#
directive|if
literal|0
block|QWindow *window = d_ptr->window;     QPoint offset = window->mapTo(window, QPoint());
endif|#
directive|endif
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QRect QWindowSurface::rect(const QWindow *window) const    Returns the rectangle for \a window in the coordinates of this   window surface. */
end_comment
begin_function
DECL|function|setStaticContents
name|void
name|QWindowSurface
operator|::
name|setStaticContents
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|d_ptr
operator|->
name|staticContents
operator|=
name|region
expr_stmt|;
block|}
end_function
begin_function
DECL|function|staticContents
name|QRegion
name|QWindowSurface
operator|::
name|staticContents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|staticContents
return|;
block|}
end_function
begin_function
DECL|function|hasStaticContents
name|bool
name|QWindowSurface
operator|::
name|hasStaticContents
parameter_list|()
specifier|const
block|{
return|return
name|hasFeature
argument_list|(
name|QWindowSurface
operator|::
name|StaticContents
argument_list|)
operator|&&
operator|!
name|d_ptr
operator|->
name|staticContents
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|features
name|QWindowSurface
operator|::
name|WindowSurfaceFeatures
name|QWindowSurface
operator|::
name|features
parameter_list|()
specifier|const
block|{
return|return
name|PartialUpdates
operator||
name|PreservedContents
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_QPA
end_ifdef
begin_define
DECL|macro|Q_EXPORT_SCROLLRECT
define|#
directive|define
name|Q_EXPORT_SCROLLRECT
value|Q_GUI_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_EXPORT_SCROLLRECT
define|#
directive|define
name|Q_EXPORT_SCROLLRECT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_scrollRectInImage
name|void
name|Q_EXPORT_SCROLLRECT
name|qt_scrollRectInImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
comment|// make sure we don't detach
name|uchar
modifier|*
name|mem
init|=
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|QImage
operator|&
argument_list|>
argument_list|(
name|img
argument_list|)
operator|.
name|bits
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|lineskip
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|int
name|depth
init|=
name|img
operator|.
name|depth
argument_list|()
operator|>>
literal|3
decl_stmt|;
specifier|const
name|QRect
name|imageRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|r
init|=
name|rect
operator|&
name|imageRect
operator|&
name|imageRect
operator|.
name|translated
argument_list|(
operator|-
name|offset
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|p
init|=
name|rect
operator|.
name|topLeft
argument_list|()
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|uchar
modifier|*
name|src
decl_stmt|;
name|uchar
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|top
argument_list|()
operator|<
name|p
operator|.
name|y
argument_list|()
condition|)
block|{
name|src
operator|=
name|mem
operator|+
name|r
operator|.
name|bottom
argument_list|()
operator|*
name|lineskip
operator|+
name|r
operator|.
name|left
argument_list|()
operator|*
name|depth
expr_stmt|;
name|dest
operator|=
name|mem
operator|+
operator|(
name|p
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
operator|-
literal|1
operator|)
operator|*
name|lineskip
operator|+
name|p
operator|.
name|x
argument_list|()
operator|*
name|depth
expr_stmt|;
name|lineskip
operator|=
operator|-
name|lineskip
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|mem
operator|+
name|r
operator|.
name|top
argument_list|()
operator|*
name|lineskip
operator|+
name|r
operator|.
name|left
argument_list|()
operator|*
name|depth
expr_stmt|;
name|dest
operator|=
name|mem
operator|+
name|p
operator|.
name|y
argument_list|()
operator|*
name|lineskip
operator|+
name|p
operator|.
name|x
argument_list|()
operator|*
name|depth
expr_stmt|;
block|}
specifier|const
name|int
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|bytes
init|=
name|w
operator|*
name|depth
decl_stmt|;
comment|// overlapping segments?
if|if
condition|(
name|offset
operator|.
name|y
argument_list|()
operator|==
literal|0
operator|&&
name|qAbs
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|)
operator|<
name|w
condition|)
block|{
do|do
block|{
operator|::
name|memmove
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|lineskip
expr_stmt|;
name|src
operator|+=
name|lineskip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|lineskip
expr_stmt|;
name|src
operator|+=
name|lineskip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
