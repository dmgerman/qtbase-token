begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<private/qimagescale_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qcolor.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_namespace
DECL|namespace|QImageScale
namespace|namespace
name|QImageScale
block|{
struct_decl|struct
name|QImageScaleInfo
struct_decl|;
block|}
end_namespace
begin_typedef
DECL|typedef|qt_qimageScaleFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|qt_qimageScaleFunc
function_decl|)
parameter_list|(
name|QImageScale
operator|::
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|,
name|unsigned
name|int
modifier|*
name|dest
parameter_list|,
name|int
name|dxx
parameter_list|,
name|int
name|dyy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dow
parameter_list|,
name|int
name|sow
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
specifier|static
name|void
name|qt_qimageScaleAARGB
parameter_list|(
name|QImageScale
operator|::
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|,
name|unsigned
name|int
modifier|*
name|dest
parameter_list|,
name|int
name|dxx
parameter_list|,
name|int
name|dyy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dow
parameter_list|,
name|int
name|sow
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|qt_qimageScaleAARGBA
parameter_list|(
name|QImageScale
operator|::
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|,
name|unsigned
name|int
modifier|*
name|dest
parameter_list|,
name|int
name|dxx
parameter_list|,
name|int
name|dyy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dow
parameter_list|,
name|int
name|sow
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|qt_qimageScaleArgb
name|qt_qimageScaleFunc
name|qt_qimageScaleArgb
init|=
name|qt_qimageScaleAARGBA
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_qimageScaleRgb
name|qt_qimageScaleFunc
name|qt_qimageScaleRgb
init|=
name|qt_qimageScaleAARGB
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Copyright (C) 2004, 2005 Daniel M. Duley  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment
begin_comment
comment|/* OTHER CREDITS:  *  * This is the normal smoothscale method, based on Imlib2's smoothscale.  *  * Originally I took the algorithm used in NetPBM and Qt and added MMX/3dnow  * optimizations. It ran in about 1/2 the time as Qt. Then I ported Imlib's  * C algorithm and it ran at about the same speed as my MMX optimized one...  * Finally I ported Imlib's MMX version and it ran in less than half the  * time as my MMX algorithm, (taking only a quarter of the time Qt does).  * After further optimization it seems to run at around 1/6th.  *  * Changes include formatting, namespaces and other C++'ings, removal of old  * #ifdef'ed code, and removal of unneeded border calculation code.  *  * Imlib2 is (C) Carsten Haitzler and various contributors. The MMX code  * is by Willem Monsuwe<willem@stack.nl>. All other modifications are  * (C) Daniel M. Duley.  */
end_comment
begin_namespace
DECL|namespace|QImageScale
namespace|namespace
name|QImageScale
block|{
DECL|struct|QImageScaleInfo
struct|struct
name|QImageScaleInfo
block|{
DECL|member|xpoints
name|int
modifier|*
name|xpoints
decl_stmt|;
DECL|member|ypoints
name|unsigned
name|int
modifier|*
modifier|*
name|ypoints
decl_stmt|;
DECL|member|xapoints
DECL|member|yapoints
name|int
modifier|*
name|xapoints
decl_stmt|,
modifier|*
name|yapoints
decl_stmt|;
DECL|member|xup_yup
name|int
name|xup_yup
decl_stmt|;
block|}
struct|;
name|unsigned
name|int
modifier|*
modifier|*
name|qimageCalcYPoints
parameter_list|(
name|unsigned
name|int
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|dh
parameter_list|)
function_decl|;
name|int
modifier|*
name|qimageCalcXPoints
parameter_list|(
name|int
name|sw
parameter_list|,
name|int
name|dw
parameter_list|)
function_decl|;
name|int
modifier|*
name|qimageCalcApoints
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|up
parameter_list|)
function_decl|;
name|QImageScaleInfo
modifier|*
name|qimageFreeScaleInfo
parameter_list|(
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|)
function_decl|;
name|QImageScaleInfo
modifier|*
name|qimageCalcScaleInfo
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|char
name|aa
parameter_list|)
function_decl|;
block|}
end_namespace
begin_using
using|using
namespace|namespace
name|QImageScale
namespace|;
end_using
begin_comment
comment|//
end_comment
begin_comment
comment|// Code ported from Imlib...
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// FIXME: replace with qRed, etc... These work on pointers to pixels, not
end_comment
begin_comment
comment|// pixel values
end_comment
begin_define
DECL|macro|A_VAL
define|#
directive|define
name|A_VAL
parameter_list|(
name|p
parameter_list|)
value|(qAlpha(*p))
end_define
begin_define
DECL|macro|R_VAL
define|#
directive|define
name|R_VAL
parameter_list|(
name|p
parameter_list|)
value|(qRed(*p))
end_define
begin_define
DECL|macro|G_VAL
define|#
directive|define
name|G_VAL
parameter_list|(
name|p
parameter_list|)
value|(qGreen(*p))
end_define
begin_define
DECL|macro|B_VAL
define|#
directive|define
name|B_VAL
parameter_list|(
name|p
parameter_list|)
value|(qBlue(*p))
end_define
begin_define
DECL|macro|INV_XAP
define|#
directive|define
name|INV_XAP
value|(256 - xapoints[x])
end_define
begin_define
DECL|macro|XAP
define|#
directive|define
name|XAP
value|(xapoints[x])
end_define
begin_define
DECL|macro|INV_YAP
define|#
directive|define
name|INV_YAP
value|(256 - yapoints[dyy + y])
end_define
begin_define
DECL|macro|YAP
define|#
directive|define
name|YAP
value|(yapoints[dyy + y])
end_define
begin_function
DECL|function|qimageCalcYPoints
name|unsigned
name|int
modifier|*
modifier|*
name|QImageScale
operator|::
name|qimageCalcYPoints
parameter_list|(
name|unsigned
name|int
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|dh
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|,
name|inc
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dh
operator|<
literal|0
condition|)
block|{
name|dh
operator|=
operator|-
name|dh
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
operator|new
name|unsigned
name|int
operator|*
index|[
name|dh
operator|+
literal|1
index|]
expr_stmt|;
name|int
name|up
init|=
name|qAbs
argument_list|(
name|dh
argument_list|)
operator|>=
name|sh
decl_stmt|;
name|val
operator|=
name|up
condition|?
literal|0x8000
operator|*
name|sh
operator|/
name|dh
operator|-
literal|0x8000
else|:
literal|0
expr_stmt|;
name|inc
operator|=
operator|(
name|sh
operator|<<
literal|16
operator|)
operator|/
name|dh
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dh
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|j
operator|++
index|]
operator|=
name|src
operator|+
name|qMax
argument_list|(
literal|0
argument_list|,
name|val
operator|>>
literal|16
argument_list|)
operator|*
name|sw
expr_stmt|;
name|val
operator|+=
name|inc
expr_stmt|;
block|}
if|if
condition|(
name|rv
condition|)
block|{
for|for
control|(
name|i
operator|=
name|dh
operator|/
literal|2
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|unsigned
name|int
modifier|*
name|tmp
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|dh
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|p
index|[
name|dh
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qimageCalcXPoints
name|int
modifier|*
name|QImageScale
operator|::
name|qimageCalcXPoints
parameter_list|(
name|int
name|sw
parameter_list|,
name|int
name|dw
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|,
name|inc
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dw
operator|<
literal|0
condition|)
block|{
name|dw
operator|=
operator|-
name|dw
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
operator|new
name|int
index|[
name|dw
operator|+
literal|1
index|]
expr_stmt|;
name|int
name|up
init|=
name|qAbs
argument_list|(
name|dw
argument_list|)
operator|>=
name|sw
decl_stmt|;
name|val
operator|=
name|up
condition|?
literal|0x8000
operator|*
name|sw
operator|/
name|dw
operator|-
literal|0x8000
else|:
literal|0
expr_stmt|;
name|inc
operator|=
operator|(
name|sw
operator|<<
literal|16
operator|)
operator|/
name|dw
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dw
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|j
operator|++
index|]
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|val
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|val
operator|+=
name|inc
expr_stmt|;
block|}
if|if
condition|(
name|rv
condition|)
block|{
for|for
control|(
name|i
operator|=
name|dw
operator|/
literal|2
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|int
name|tmp
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|dw
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|p
index|[
name|dw
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qimageCalcApoints
name|int
modifier|*
name|QImageScale
operator|::
name|qimageCalcApoints
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|up
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
name|d
operator|=
operator|-
name|d
expr_stmt|;
block|}
name|p
operator|=
operator|new
name|int
index|[
name|d
index|]
expr_stmt|;
comment|/* scaling up */
if|if
condition|(
name|up
condition|)
block|{
name|int
name|val
decl_stmt|,
name|inc
decl_stmt|;
name|val
operator|=
literal|0x8000
operator|*
name|s
operator|/
name|d
operator|-
literal|0x8000
expr_stmt|;
name|inc
operator|=
operator|(
name|s
operator|<<
literal|16
operator|)
operator|/
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
name|val
operator|>>
literal|16
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|p
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|>=
operator|(
name|s
operator|-
literal|1
operator|)
condition|)
name|p
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|p
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|-
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff00
operator|)
expr_stmt|;
name|val
operator|+=
name|inc
expr_stmt|;
block|}
block|}
comment|/* scaling down */
else|else
block|{
name|int
name|val
decl_stmt|,
name|inc
decl_stmt|,
name|ap
decl_stmt|,
name|Cp
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|inc
operator|=
operator|(
name|s
operator|<<
literal|16
operator|)
operator|/
name|d
expr_stmt|;
name|Cp
operator|=
operator|(
operator|(
name|d
operator|<<
literal|14
operator|)
operator|/
name|s
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|=
operator|(
operator|(
literal|0x100
operator|-
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|)
operator|*
name|Cp
operator|)
operator|>>
literal|8
expr_stmt|;
name|p
index|[
name|j
index|]
operator|=
name|ap
operator||
operator|(
name|Cp
operator|<<
literal|16
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|val
operator|+=
name|inc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rv
condition|)
block|{
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|/
literal|2
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|tmp
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|d
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|p
index|[
name|d
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qimageFreeScaleInfo
name|QImageScaleInfo
modifier|*
name|QImageScale
operator|::
name|qimageFreeScaleInfo
parameter_list|(
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|)
block|{
if|if
condition|(
name|isi
condition|)
block|{
operator|delete
index|[]
name|isi
operator|->
name|xpoints
expr_stmt|;
operator|delete
index|[]
name|isi
operator|->
name|ypoints
expr_stmt|;
operator|delete
index|[]
name|isi
operator|->
name|xapoints
expr_stmt|;
operator|delete
index|[]
name|isi
operator|->
name|yapoints
expr_stmt|;
operator|delete
name|isi
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qimageCalcScaleInfo
name|QImageScaleInfo
modifier|*
name|QImageScale
operator|::
name|qimageCalcScaleInfo
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|char
name|aa
parameter_list|)
block|{
name|QImageScaleInfo
modifier|*
name|isi
decl_stmt|;
name|int
name|scw
decl_stmt|,
name|sch
decl_stmt|;
name|scw
operator|=
name|dw
operator|*
name|qlonglong
argument_list|(
name|img
operator|.
name|width
argument_list|()
argument_list|)
operator|/
name|sw
expr_stmt|;
name|sch
operator|=
name|dh
operator|*
name|qlonglong
argument_list|(
name|img
operator|.
name|height
argument_list|()
argument_list|)
operator|/
name|sh
expr_stmt|;
name|isi
operator|=
operator|new
name|QImageScaleInfo
expr_stmt|;
if|if
condition|(
operator|!
name|isi
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|isi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|QImageScaleInfo
argument_list|)
argument_list|)
expr_stmt|;
name|isi
operator|->
name|xup_yup
operator|=
operator|(
name|qAbs
argument_list|(
name|dw
argument_list|)
operator|>=
name|sw
operator|)
operator|+
operator|(
operator|(
name|qAbs
argument_list|(
name|dh
argument_list|)
operator|>=
name|sh
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|isi
operator|->
name|xpoints
operator|=
name|qimageCalcXPoints
argument_list|(
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|scw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isi
operator|->
name|xpoints
condition|)
return|return
operator|(
name|qimageFreeScaleInfo
argument_list|(
name|isi
argument_list|)
operator|)
return|;
name|isi
operator|->
name|ypoints
operator|=
name|qimageCalcYPoints
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
operator|/
literal|4
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|sch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isi
operator|->
name|ypoints
condition|)
return|return
operator|(
name|qimageFreeScaleInfo
argument_list|(
name|isi
argument_list|)
operator|)
return|;
if|if
condition|(
name|aa
condition|)
block|{
name|isi
operator|->
name|xapoints
operator|=
name|qimageCalcApoints
argument_list|(
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|scw
argument_list|,
name|isi
operator|->
name|xup_yup
operator|&
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isi
operator|->
name|xapoints
condition|)
return|return
operator|(
name|qimageFreeScaleInfo
argument_list|(
name|isi
argument_list|)
operator|)
return|;
name|isi
operator|->
name|yapoints
operator|=
name|qimageCalcApoints
argument_list|(
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|sch
argument_list|,
name|isi
operator|->
name|xup_yup
operator|&
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isi
operator|->
name|yapoints
condition|)
return|return
operator|(
name|qimageFreeScaleInfo
argument_list|(
name|isi
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|isi
operator|)
return|;
block|}
end_function
begin_comment
comment|/* FIXME: NEED to optimize ScaleAARGBA - currently its "ok" but needs work*/
end_comment
begin_comment
comment|/* scale by area sampling */
end_comment
begin_function
DECL|function|qt_qimageScaleAARGBA
specifier|static
name|void
name|qt_qimageScaleAARGBA
parameter_list|(
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|,
name|unsigned
name|int
modifier|*
name|dest
parameter_list|,
name|int
name|dxx
parameter_list|,
name|int
name|dyy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dow
parameter_list|,
name|int
name|sow
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|end
decl_stmt|;
name|unsigned
name|int
modifier|*
modifier|*
name|ypoints
init|=
name|isi
operator|->
name|ypoints
decl_stmt|;
name|int
modifier|*
name|xpoints
init|=
name|isi
operator|->
name|xpoints
decl_stmt|;
name|int
modifier|*
name|xapoints
init|=
name|isi
operator|->
name|xapoints
decl_stmt|;
name|int
modifier|*
name|yapoints
init|=
name|isi
operator|->
name|yapoints
decl_stmt|;
name|end
operator|=
name|dxx
operator|+
name|dw
expr_stmt|;
comment|/* scaling up both ways */
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|3
condition|)
block|{
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
comment|/* calculate the source line we'll scan from */
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
name|sptr
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
expr_stmt|;
if|if
condition|(
name|YAP
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
name|int
name|rr
decl_stmt|,
name|gg
decl_stmt|,
name|bb
decl_stmt|,
name|aa
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|a
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|aa
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|pix
operator|--
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|aa
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|r
operator|=
operator|(
operator|(
name|rr
operator|*
name|YAP
operator|)
operator|+
operator|(
name|r
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|g
operator|=
operator|(
operator|(
name|gg
operator|*
name|YAP
operator|)
operator|+
operator|(
name|g
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|b
operator|=
operator|(
operator|(
name|bb
operator|*
name|YAP
operator|)
operator|+
operator|(
name|b
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|aa
operator|*
name|YAP
operator|)
operator|+
operator|(
name|a
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|a
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|r
operator|>>=
literal|8
expr_stmt|;
name|g
operator|>>=
literal|8
expr_stmt|;
name|b
operator|>>=
literal|8
expr_stmt|;
name|a
operator|>>=
literal|8
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|a
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|r
operator|>>=
literal|8
expr_stmt|;
name|g
operator|>>=
literal|8
expr_stmt|;
name|b
operator|>>=
literal|8
expr_stmt|;
name|a
operator|>>=
literal|8
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dptr
operator|++
operator|=
name|sptr
index|[
name|xpoints
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* if we're scaling down vertically */
elseif|else
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|1
condition|)
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification \*/
name|int
name|Cy
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|,
name|rr
decl_stmt|,
name|gg
decl_stmt|,
name|bb
decl_stmt|,
name|aa
decl_stmt|;
name|int
name|yap
decl_stmt|;
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|Cy
operator|=
name|YAP
operator|>>
literal|16
expr_stmt|;
name|yap
operator|=
name|YAP
operator|&
literal|0xffff
expr_stmt|;
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|a
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|pix
operator|+=
name|sow
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|+=
name|sow
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
operator|+
literal|1
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|aa
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|pix
operator|+=
name|sow
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|aa
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|+=
name|sow
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|aa
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
name|r
operator|=
name|r
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|g
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|b
operator|*
name|INV_XAP
expr_stmt|;
name|a
operator|=
name|a
operator|*
name|INV_XAP
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|+
operator|(
operator|(
name|rr
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|g
operator|=
operator|(
name|g
operator|+
operator|(
operator|(
name|gg
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|+
operator|(
operator|(
name|bb
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|+
operator|(
operator|(
name|aa
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
block|}
else|else
block|{
name|r
operator|>>=
literal|4
expr_stmt|;
name|g
operator|>>=
literal|4
expr_stmt|;
name|b
operator|>>=
literal|4
expr_stmt|;
name|a
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgba
argument_list|(
name|r
operator|>>
literal|10
argument_list|,
name|g
operator|>>
literal|10
argument_list|,
name|b
operator|>>
literal|10
argument_list|,
name|a
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* if we're scaling down horizontally */
elseif|else
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|2
condition|)
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification \*/
name|int
name|Cx
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|,
name|rr
decl_stmt|,
name|gg
decl_stmt|,
name|bb
decl_stmt|,
name|aa
decl_stmt|;
name|int
name|xap
decl_stmt|;
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|Cx
operator|=
name|XAP
operator|>>
literal|16
expr_stmt|;
name|xap
operator|=
name|XAP
operator|&
literal|0xffff
expr_stmt|;
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|a
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|j
operator|>
name|Cx
condition|;
name|j
operator|-=
name|Cx
control|)
block|{
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|a
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
if|if
condition|(
name|YAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
operator|+
name|sow
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|aa
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|j
operator|>
name|Cx
condition|;
name|j
operator|-=
name|Cx
control|)
block|{
name|pix
operator|++
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|aa
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|++
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|aa
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
name|r
operator|=
name|r
operator|*
name|INV_YAP
expr_stmt|;
name|g
operator|=
name|g
operator|*
name|INV_YAP
expr_stmt|;
name|b
operator|=
name|b
operator|*
name|INV_YAP
expr_stmt|;
name|a
operator|=
name|a
operator|*
name|INV_YAP
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|+
operator|(
operator|(
name|rr
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|g
operator|=
operator|(
name|g
operator|+
operator|(
operator|(
name|gg
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|+
operator|(
operator|(
name|bb
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|+
operator|(
operator|(
name|aa
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
block|}
else|else
block|{
name|r
operator|>>=
literal|4
expr_stmt|;
name|g
operator|>>=
literal|4
expr_stmt|;
name|b
operator|>>=
literal|4
expr_stmt|;
name|a
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgba
argument_list|(
name|r
operator|>>
literal|10
argument_list|,
name|g
operator|>>
literal|10
argument_list|,
name|b
operator|>>
literal|10
argument_list|,
name|a
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* if we're scaling down horizontally& vertically */
else|else
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification:          |*|  The operation 'b = (b * c)>> 16' translates to pmulhw,          |*|  so the operation 'b = (b * c)>> d' would translate to          |*|  psllw (16 - d), %mmb; pmulh %mmc, %mmb          \*/
name|int
name|Cx
decl_stmt|,
name|Cy
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|a
decl_stmt|,
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|ax
decl_stmt|,
name|rx
decl_stmt|,
name|gx
decl_stmt|,
name|bx
decl_stmt|;
name|int
name|xap
decl_stmt|,
name|yap
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|Cy
operator|=
name|YAP
operator|>>
literal|16
expr_stmt|;
name|yap
operator|=
name|YAP
operator|&
literal|0xffff
expr_stmt|;
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|Cx
operator|=
name|XAP
operator|>>
literal|16
expr_stmt|;
name|xap
operator|=
name|XAP
operator|&
literal|0xffff
expr_stmt|;
name|sptr
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|ax
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
name|g
operator|=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
name|b
operator|=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
name|a
operator|=
operator|(
name|ax
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|ax
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|+=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
name|g
operator|+=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
name|b
operator|+=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
name|a
operator|+=
operator|(
name|ax
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|ax
operator|=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|ax
operator|+=
name|A_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|+=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
name|a
operator|+=
operator|(
name|ax
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgba
argument_list|(
name|r
operator|>>
literal|23
argument_list|,
name|g
operator|>>
literal|23
argument_list|,
name|b
operator|>>
literal|23
argument_list|,
name|a
operator|>>
literal|23
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* scale by area sampling - IGNORE the ALPHA byte*/
end_comment
begin_function
DECL|function|qt_qimageScaleAARGB
specifier|static
name|void
name|qt_qimageScaleAARGB
parameter_list|(
name|QImageScaleInfo
modifier|*
name|isi
parameter_list|,
name|unsigned
name|int
modifier|*
name|dest
parameter_list|,
name|int
name|dxx
parameter_list|,
name|int
name|dyy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dow
parameter_list|,
name|int
name|sow
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|end
decl_stmt|;
name|unsigned
name|int
modifier|*
modifier|*
name|ypoints
init|=
name|isi
operator|->
name|ypoints
decl_stmt|;
name|int
modifier|*
name|xpoints
init|=
name|isi
operator|->
name|xpoints
decl_stmt|;
name|int
modifier|*
name|xapoints
init|=
name|isi
operator|->
name|xapoints
decl_stmt|;
name|int
modifier|*
name|yapoints
init|=
name|isi
operator|->
name|yapoints
decl_stmt|;
name|end
operator|=
name|dxx
operator|+
name|dw
expr_stmt|;
comment|/* scaling up both ways */
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|3
condition|)
block|{
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
comment|/* calculate the source line we'll scan from */
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
name|sptr
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
expr_stmt|;
if|if
condition|(
name|YAP
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|g
init|=
literal|0
decl_stmt|,
name|b
init|=
literal|0
decl_stmt|;
name|int
name|rr
init|=
literal|0
decl_stmt|,
name|gg
init|=
literal|0
decl_stmt|,
name|bb
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|pix
operator|--
expr_stmt|;
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|r
operator|=
operator|(
operator|(
name|rr
operator|*
name|YAP
operator|)
operator|+
operator|(
name|r
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|g
operator|=
operator|(
operator|(
name|gg
operator|*
name|YAP
operator|)
operator|+
operator|(
name|g
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|b
operator|=
operator|(
operator|(
name|bb
operator|*
name|YAP
operator|)
operator|+
operator|(
name|b
operator|*
name|INV_YAP
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_YAP
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|YAP
expr_stmt|;
name|r
operator|>>=
literal|8
expr_stmt|;
name|g
operator|>>=
literal|8
expr_stmt|;
name|b
operator|>>=
literal|8
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|g
init|=
literal|0
decl_stmt|,
name|b
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|INV_XAP
expr_stmt|;
name|pix
operator|++
expr_stmt|;
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|XAP
expr_stmt|;
name|r
operator|>>=
literal|8
expr_stmt|;
name|g
operator|>>=
literal|8
expr_stmt|;
name|b
operator|>>=
literal|8
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dptr
operator|++
operator|=
name|sptr
index|[
name|xpoints
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* if we're scaling down vertically */
elseif|else
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|1
condition|)
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification \*/
name|int
name|Cy
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|rr
decl_stmt|,
name|gg
decl_stmt|,
name|bb
decl_stmt|;
name|int
name|yap
decl_stmt|;
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|Cy
operator|=
name|YAP
operator|>>
literal|16
expr_stmt|;
name|yap
operator|=
name|YAP
operator|&
literal|0xffff
expr_stmt|;
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
if|if
condition|(
name|XAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
operator|+
literal|1
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|yap
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cy
expr_stmt|;
name|pix
operator|+=
name|sow
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
name|r
operator|=
name|r
operator|*
name|INV_XAP
expr_stmt|;
name|g
operator|=
name|g
operator|*
name|INV_XAP
expr_stmt|;
name|b
operator|=
name|b
operator|*
name|INV_XAP
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|+
operator|(
operator|(
name|rr
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|g
operator|=
operator|(
name|g
operator|+
operator|(
operator|(
name|gg
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|+
operator|(
operator|(
name|bb
operator|*
name|XAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
block|}
else|else
block|{
name|r
operator|>>=
literal|4
expr_stmt|;
name|g
operator|>>=
literal|4
expr_stmt|;
name|b
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgba
argument_list|(
name|r
operator|>>
literal|10
argument_list|,
name|g
operator|>>
literal|10
argument_list|,
name|b
operator|>>
literal|10
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* if we're scaling down horizontally */
elseif|else
if|if
condition|(
name|isi
operator|->
name|xup_yup
operator|==
literal|2
condition|)
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification \*/
name|int
name|Cx
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|rr
decl_stmt|,
name|gg
decl_stmt|,
name|bb
decl_stmt|;
name|int
name|xap
decl_stmt|;
comment|/* go through every scanline in the output buffer */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|Cx
operator|=
name|XAP
operator|>>
literal|16
expr_stmt|;
name|xap
operator|=
name|XAP
operator|&
literal|0xffff
expr_stmt|;
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|r
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|g
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|b
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|j
operator|>
name|Cx
condition|;
name|j
operator|-=
name|Cx
control|)
block|{
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|r
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
if|if
condition|(
name|YAP
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
operator|+
name|sow
expr_stmt|;
name|rr
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gg
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bb
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|j
operator|>
name|Cx
condition|;
name|j
operator|-=
name|Cx
control|)
block|{
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|rr
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|gg
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
name|bb
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|j
expr_stmt|;
block|}
name|r
operator|=
name|r
operator|*
name|INV_YAP
expr_stmt|;
name|g
operator|=
name|g
operator|*
name|INV_YAP
expr_stmt|;
name|b
operator|=
name|b
operator|*
name|INV_YAP
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|+
operator|(
operator|(
name|rr
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|g
operator|=
operator|(
name|g
operator|+
operator|(
operator|(
name|gg
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|+
operator|(
operator|(
name|bb
operator|*
name|YAP
operator|)
operator|)
operator|)
operator|>>
literal|12
expr_stmt|;
block|}
else|else
block|{
name|r
operator|>>=
literal|4
expr_stmt|;
name|g
operator|>>=
literal|4
expr_stmt|;
name|b
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgba
argument_list|(
name|r
operator|>>
literal|10
argument_list|,
name|g
operator|>>
literal|10
argument_list|,
name|b
operator|>>
literal|10
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* fully optimized (i think) - onyl change of algorithm can help */
comment|/* if we're scaling down horizontally& vertically */
else|else
block|{
comment|/*\ 'Correct' version, with math units prepared for MMXification \*/
name|int
name|Cx
decl_stmt|,
name|Cy
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pix
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|rx
decl_stmt|,
name|gx
decl_stmt|,
name|bx
decl_stmt|;
name|int
name|xap
decl_stmt|,
name|yap
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
name|y
operator|++
control|)
block|{
name|Cy
operator|=
name|YAP
operator|>>
literal|16
expr_stmt|;
name|yap
operator|=
name|YAP
operator|&
literal|0xffff
expr_stmt|;
name|dptr
operator|=
name|dest
operator|+
name|dx
operator|+
operator|(
operator|(
name|y
operator|+
name|dy
operator|)
operator|*
name|dow
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|dxx
init|;
name|x
operator|<
name|end
condition|;
name|x
operator|++
control|)
block|{
name|Cx
operator|=
name|XAP
operator|>>
literal|16
expr_stmt|;
name|xap
operator|=
name|XAP
operator|&
literal|0xffff
expr_stmt|;
name|sptr
operator|=
name|ypoints
index|[
name|dyy
operator|+
name|y
index|]
operator|+
name|xpoints
index|[
name|x
index|]
expr_stmt|;
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
name|g
operator|=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
name|b
operator|=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|yap
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|yap
init|;
name|j
operator|>
name|Cy
condition|;
name|j
operator|-=
name|Cy
control|)
block|{
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|+=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
name|g
operator|+=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
name|b
operator|+=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|Cy
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|pix
operator|=
name|sptr
expr_stmt|;
name|sptr
operator|+=
name|sow
expr_stmt|;
name|rx
operator|=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|gx
operator|=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|bx
operator|=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|xap
expr_stmt|;
name|pix
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|-
name|xap
init|;
name|i
operator|>
name|Cx
condition|;
name|i
operator|-=
name|Cx
control|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|Cx
expr_stmt|;
name|pix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rx
operator|+=
name|R_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|gx
operator|+=
name|G_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
name|bx
operator|+=
name|B_VAL
argument_list|(
name|pix
argument_list|)
operator|*
name|i
expr_stmt|;
block|}
name|r
operator|+=
operator|(
name|rx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
name|g
operator|+=
operator|(
name|gx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
name|b
operator|+=
operator|(
name|bx
operator|>>
literal|5
operator|)
operator|*
name|j
expr_stmt|;
block|}
operator|*
name|dptr
operator|=
name|qRgb
argument_list|(
name|r
operator|>>
literal|23
argument_list|,
name|g
operator|>>
literal|23
argument_list|,
name|b
operator|>>
literal|23
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void qt_qimageScaleAARGBASetup(QImageScaleInfo *isi, unsigned int *dest,                                       int dxx, int dyy, int dx, int dy, int dw,                                       int dh, int dow, int sow) {     qInitDrawhelperAsm();     qt_qimageScaleAARGBA(isi, dest, dxx, dyy, dx, dy, dw, dh, dow, sow); }  static void qt_qimageScaleAARGBSetup(QImageScaleInfo *isi, unsigned int *dest,                                  int dxx, int dyy, int dx, int dy, int dw,                                  int dh, int dow, int sow) {     qInitDrawhelperAsm();     qt_qimageScaleAARGB(isi, dest, dxx, dyy, dx, dy, dw, dh, dow, sow); }
endif|#
directive|endif
end_endif
begin_function
DECL|function|qSmoothScaleImage
name|QImage
name|qSmoothScaleImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|)
block|{
name|QImage
name|buffer
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|isNull
argument_list|()
operator|||
name|dw
operator|<=
literal|0
operator|||
name|dh
operator|<=
literal|0
condition|)
return|return
name|buffer
return|;
name|int
name|w
init|=
name|src
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|src
operator|.
name|height
argument_list|()
decl_stmt|;
name|QImageScaleInfo
modifier|*
name|scaleinfo
init|=
name|qimageCalcScaleInfo
argument_list|(
name|src
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scaleinfo
condition|)
return|return
name|buffer
return|;
name|buffer
operator|=
name|QImage
argument_list|(
name|dw
argument_list|,
name|dh
argument_list|,
name|src
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage: out of memory, returning null"
argument_list|)
expr_stmt|;
name|qimageFreeScaleInfo
argument_list|(
name|scaleinfo
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|src
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
name|qt_qimageScaleArgb
argument_list|(
name|scaleinfo
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|buffer
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|dw
argument_list|,
name|src
operator|.
name|bytesPerLine
argument_list|()
operator|/
literal|4
argument_list|)
expr_stmt|;
else|else
name|qt_qimageScaleRgb
argument_list|(
name|scaleinfo
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|buffer
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|dw
argument_list|,
name|src
operator|.
name|bytesPerLine
argument_list|()
operator|/
literal|4
argument_list|)
expr_stmt|;
name|qimageFreeScaleInfo
argument_list|(
name|scaleinfo
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
