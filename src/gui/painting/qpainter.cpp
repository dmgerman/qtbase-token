begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// QtCore
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_comment
comment|// QtGui
end_comment
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qpaintdevice.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengine.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qpainter_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpicture.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qpolygon.h"
end_include
begin_include
include|#
directive|include
file|"qtextlayout.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qstatictext.h"
end_include
begin_include
include|#
directive|include
file|"qglyphrun.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformtheme.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qemulationpaintengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpainterpath_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmath_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qstatictext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qglyphrun_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qhexstring_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qrawfont_p.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|QGradient_StretchToDevice
define|#
directive|define
name|QGradient_StretchToDevice
value|0x10000000
DECL|macro|QPaintEngine_OpaqueBackground
define|#
directive|define
name|QPaintEngine_OpaqueBackground
value|0x40000000
comment|// #define QT_DEBUG_DRAW
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
DECL|variable|qt_show_painter_debug_output
name|bool
name|qt_show_painter_debug_output
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|extern
name|QPixmap
name|qt_pixmapForBrush
parameter_list|(
name|int
name|style
parameter_list|,
name|bool
name|invert
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|qt_format_text
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|_r
parameter_list|,
name|int
name|tf
parameter_list|,
specifier|const
name|QTextOption
modifier|*
name|option
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRectF
modifier|*
name|brect
parameter_list|,
name|int
name|tabstops
parameter_list|,
name|int
modifier|*
name|tabarray
parameter_list|,
name|int
name|tabarraylen
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|drawTextItemDecoration
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QFontEngine
modifier|*
name|fe
parameter_list|,
name|QTextEngine
modifier|*
name|textEngine
parameter_list|,
name|QTextCharFormat
operator|::
name|UnderlineStyle
name|underlineStyle
parameter_list|,
name|QTextItem
operator|::
name|RenderFlags
name|flags
parameter_list|,
name|qreal
name|width
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|charFormat
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Helper function to calculate left most position, width and flags for decoration drawing
end_comment
begin_function_decl
name|Q_GUI_EXPORT
name|void
name|qt_draw_decoration_for_glyphs
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|glyph_t
modifier|*
name|glyphArray
parameter_list|,
specifier|const
name|QFixedPoint
modifier|*
name|positions
parameter_list|,
name|int
name|glyphCount
parameter_list|,
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|charFormat
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|coordinateMode
specifier|static
specifier|inline
name|QGradient
operator|::
name|CoordinateMode
name|coordinateMode
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
switch|switch
condition|(
name|brush
operator|.
name|style
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
return|return
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|coordinateMode
argument_list|()
return|;
default|default:
empty_stmt|;
block|}
return|return
name|QGradient
operator|::
name|LogicalMode
return|;
block|}
end_function
begin_comment
comment|/* Returns true if the gradient requires stretch to device...*/
end_comment
begin_function
DECL|function|check_gradient
specifier|static
specifier|inline
name|bool
name|check_gradient
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
return|return
name|coordinateMode
argument_list|(
name|brush
argument_list|)
operator|==
name|QGradient
operator|::
name|StretchToDeviceMode
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|bool
name|qHasPixmapTexture
parameter_list|(
specifier|const
name|QBrush
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|is_brush_transparent
specifier|static
specifier|inline
name|bool
name|is_brush_transparent
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Qt
operator|::
name|BrushStyle
name|s
init|=
name|brush
operator|.
name|style
argument_list|()
decl_stmt|;
name|bool
name|brushBitmap
init|=
name|qHasPixmapTexture
argument_list|(
name|brush
argument_list|)
condition|?
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|isQBitmap
argument_list|()
else|:
operator|(
name|brush
operator|.
name|textureImage
argument_list|()
operator|.
name|depth
argument_list|()
operator|==
literal|1
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|s
operator|>=
name|Qt
operator|::
name|Dense1Pattern
operator|&&
name|s
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
operator|)
operator|||
operator|(
name|s
operator|==
name|Qt
operator|::
name|TexturePattern
operator|&&
name|brushBitmap
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|is_pen_transparent
specifier|static
specifier|inline
name|bool
name|is_pen_transparent
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
return|return
name|pen
operator|.
name|style
argument_list|()
operator|>
name|Qt
operator|::
name|SolidLine
operator|||
name|is_brush_transparent
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Discards the emulation flags that are not relevant for line drawing    and returns the result */
end_comment
begin_function
DECL|function|line_emulation
specifier|static
specifier|inline
name|uint
name|line_emulation
parameter_list|(
name|uint
name|emulation
parameter_list|)
block|{
return|return
name|emulation
operator|&
operator|(
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator||
name|QPaintEngine
operator|::
name|AlphaBlend
operator||
name|QPaintEngine
operator|::
name|Antialiasing
operator||
name|QPaintEngine
operator|::
name|BrushStroke
operator||
name|QPaintEngine
operator|::
name|ConstantOpacity
operator||
name|QGradient_StretchToDevice
operator||
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
operator||
name|QPaintEngine_OpaqueBackground
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_function
DECL|function|qt_painter_thread_test
specifier|static
name|bool
name|qt_painter_thread_test
parameter_list|(
name|int
name|devType
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|bool
name|extraCondition
init|=
literal|false
parameter_list|)
block|{
switch|switch
condition|(
name|devType
condition|)
block|{
case|case
name|QInternal
operator|::
name|Image
case|:
case|case
name|QInternal
operator|::
name|Printer
case|:
case|case
name|QInternal
operator|::
name|Picture
case|:
comment|// can be drawn onto these devices safely from any thread
if|if
condition|(
name|extraCondition
condition|)
break|break;
default|default:
if|if
condition|(
operator|!
name|extraCondition
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|!=
name|qApp
operator|->
name|thread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter: It is not safe to use %s outside the GUI thread"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|checkEmulation
name|void
name|QPainterPrivate
operator|::
name|checkEmulation
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|extended
operator|->
name|flags
argument_list|()
operator|&
name|QPaintEngineEx
operator|::
name|DoNotEmulate
condition|)
return|return;
name|bool
name|doEmulation
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
condition|)
name|doEmulation
operator|=
literal|true
expr_stmt|;
specifier|const
name|QGradient
modifier|*
name|bg
init|=
name|state
operator|->
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
name|bg
operator|&&
name|bg
operator|->
name|coordinateMode
argument_list|()
operator|>
name|QGradient
operator|::
name|LogicalMode
condition|)
name|doEmulation
operator|=
literal|true
expr_stmt|;
specifier|const
name|QGradient
modifier|*
name|pg
init|=
name|qpen_brush
argument_list|(
name|state
operator|->
name|pen
argument_list|)
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
name|pg
operator|&&
name|pg
operator|->
name|coordinateMode
argument_list|()
operator|>
name|QGradient
operator|::
name|LogicalMode
condition|)
name|doEmulation
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|doEmulation
condition|)
block|{
if|if
condition|(
name|extended
operator|!=
name|emulationEngine
condition|)
block|{
if|if
condition|(
operator|!
name|emulationEngine
condition|)
name|emulationEngine
operator|=
operator|new
name|QEmulationPaintEngine
argument_list|(
name|extended
argument_list|)
expr_stmt|;
name|extended
operator|=
name|emulationEngine
expr_stmt|;
name|extended
operator|->
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|emulationEngine
operator|==
name|extended
condition|)
block|{
name|extended
operator|=
name|emulationEngine
operator|->
name|real_engine
expr_stmt|;
block|}
block|}
end_function
begin_destructor
DECL|function|~QPainterPrivate
name|QPainterPrivate
operator|::
name|~
name|QPainterPrivate
parameter_list|()
block|{
operator|delete
name|emulationEngine
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|states
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|states
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummyState
condition|)
operator|delete
name|dummyState
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|viewTransform
name|QTransform
name|QPainterPrivate
operator|::
name|viewTransform
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|state
operator|->
name|VxF
condition|)
block|{
name|qreal
name|scaleW
init|=
name|qreal
argument_list|(
name|state
operator|->
name|vw
argument_list|)
operator|/
name|qreal
argument_list|(
name|state
operator|->
name|ww
argument_list|)
decl_stmt|;
name|qreal
name|scaleH
init|=
name|qreal
argument_list|(
name|state
operator|->
name|vh
argument_list|)
operator|/
name|qreal
argument_list|(
name|state
operator|->
name|wh
argument_list|)
decl_stmt|;
return|return
name|QTransform
argument_list|(
name|scaleW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|scaleH
argument_list|,
name|state
operator|->
name|vx
operator|-
name|state
operator|->
name|wx
operator|*
name|scaleW
argument_list|,
name|state
operator|->
name|vy
operator|-
name|state
operator|->
name|wy
operator|*
name|scaleH
argument_list|)
return|;
block|}
return|return
name|QTransform
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|effectiveDevicePixelRatio
name|int
name|QPainterPrivate
operator|::
name|effectiveDevicePixelRatio
parameter_list|()
specifier|const
block|{
comment|// Limited feature introduction for Qt 5.0.0, remove ifdef in a later release.
ifdef|#
directive|ifdef
name|Q_OS_MAC
comment|// Special cases for devices that does not support PdmDevicePixelRatio go here:
if|if
condition|(
name|device
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Printer
condition|)
return|return
literal|1
return|;
return|return
name|qMax
argument_list|(
literal|1
argument_list|,
name|device
operator|->
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmDevicePixelRatio
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|hidpiScaleTransform
name|QTransform
name|QPainterPrivate
operator|::
name|hidpiScaleTransform
parameter_list|()
specifier|const
block|{
name|int
name|devicePixelRatio
init|=
name|effectiveDevicePixelRatio
argument_list|()
decl_stmt|;
return|return
name|QTransform
operator|::
name|fromScale
argument_list|(
name|devicePixelRatio
argument_list|,
name|devicePixelRatio
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    \internal    Returns true if using a shared painter; otherwise false. */
end_comment
begin_function
DECL|function|attachPainterPrivate
name|bool
name|QPainterPrivate
operator|::
name|attachPainterPrivate
parameter_list|(
name|QPainter
modifier|*
name|q
parameter_list|,
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|QPainter
modifier|*
name|sp
init|=
name|pdev
operator|->
name|sharedPainter
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
return|return
literal|false
return|;
comment|// Save the current state of the shared painter and assign
comment|// the current d_ptr to the shared painter's d_ptr.
name|sp
operator|->
name|save
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
condition|)
block|{
comment|// Allocate space for 4 d-pointers (enough for up to 4 sub-sequent
comment|// redirections within the same paintEvent(), which should be enough
comment|// in 99% of all cases). E.g: A renders B which renders C which renders D.
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs_size
operator|=
literal|4
expr_stmt|;
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
operator|=
operator|(
name|QPainterPrivate
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|QPainterPrivate
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|d_ptr
operator|->
name|refcount
operator|-
literal|1
operator|==
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs_size
condition|)
block|{
comment|// However, to support corner cases we grow the array dynamically if needed.
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs_size
operator|<<=
literal|1
expr_stmt|;
specifier|const
name|int
name|newSize
init|=
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs_size
operator|*
sizeof|sizeof
argument_list|(
name|QPainterPrivate
operator|*
argument_list|)
decl_stmt|;
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|QPainterPrivate
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
argument_list|,
name|newSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|d_ptr
operator|->
name|d_ptrs
index|[
operator|++
name|sp
operator|->
name|d_ptr
operator|->
name|refcount
operator|-
literal|2
index|]
operator|=
name|q
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|.
name|take
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|.
name|reset
argument_list|(
name|sp
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|q
operator|->
name|d_ptr
operator|->
name|state
argument_list|)
expr_stmt|;
comment|// Now initialize the painter with correct widget properties.
name|q
operator|->
name|initFrom
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|QPoint
name|offset
decl_stmt|;
name|pdev
operator|->
name|redirected
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|q
operator|->
name|d_ptr
operator|->
name|engine
operator|->
name|coordinateOffset
argument_list|()
expr_stmt|;
comment|// Update system rect.
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|ww
operator|=
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|vw
operator|=
name|pdev
operator|->
name|width
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|wh
operator|=
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|vh
operator|=
name|pdev
operator|->
name|height
argument_list|()
expr_stmt|;
comment|// Update matrix.
if|if
condition|(
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|WxF
condition|)
block|{
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|redirectionMatrix
operator|=
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|matrix
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|redirectionMatrix
operator|*=
name|q
operator|->
name|d_ptr
operator|->
name|hidpiScaleTransform
argument_list|()
operator|.
name|inverted
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|redirectionMatrix
operator|.
name|translate
argument_list|(
operator|-
name|offset
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|offset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|worldMatrix
operator|=
name|QTransform
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|WxF
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|redirectionMatrix
operator|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|offset
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|offset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|d_ptr
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
name|QPaintEnginePrivate
modifier|*
name|enginePrivate
init|=
name|q
operator|->
name|d_ptr
operator|->
name|engine
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|enginePrivate
operator|->
name|currentClipDevice
operator|==
name|pdev
condition|)
block|{
name|enginePrivate
operator|->
name|systemStateChanged
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Update system transform and clip.
name|enginePrivate
operator|->
name|currentClipDevice
operator|=
name|pdev
expr_stmt|;
name|enginePrivate
operator|->
name|setSystemTransform
argument_list|(
name|q
operator|->
name|d_ptr
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|detachPainterPrivate
name|void
name|QPainterPrivate
operator|::
name|detachPainterPrivate
parameter_list|(
name|QPainter
modifier|*
name|q
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|refcount
operator|>
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QPainterPrivate
modifier|*
name|original
init|=
name|d_ptrs
index|[
operator|--
name|refcount
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|inDestructor
condition|)
block|{
name|inDestructor
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|original
condition|)
name|original
operator|->
name|inDestructor
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|original
condition|)
block|{
name|original
operator|=
operator|new
name|QPainterPrivate
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|d_ptrs
index|[
name|refcount
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|restore
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|.
name|take
argument_list|()
expr_stmt|;
name|q
operator|->
name|d_ptr
operator|.
name|reset
argument_list|(
name|original
argument_list|)
expr_stmt|;
if|if
condition|(
name|emulationEngine
condition|)
block|{
name|extended
operator|=
name|emulationEngine
operator|->
name|real_engine
expr_stmt|;
operator|delete
name|emulationEngine
expr_stmt|;
name|emulationEngine
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|draw_helper
name|void
name|QPainterPrivate
operator|::
name|draw_helper
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|originalPath
parameter_list|,
name|DrawOperation
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
block|{
name|printf
argument_list|(
literal|"QPainter::drawHelper\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|originalPath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QPaintEngine
operator|::
name|PaintEngineFeatures
name|gradientStretch
init|=
name|QPaintEngine
operator|::
name|PaintEngineFeatures
argument_list|(
name|QGradient_StretchToDevice
operator||
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|mustEmulateObjectBoundingModeGradients
init|=
name|extended
operator|||
operator|(
operator|(
name|state
operator|->
name|emulationSpecifier
operator|&
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
operator|)
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PatternTransform
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|emulationSpecifier
operator|&
operator|~
name|gradientStretch
operator|)
operator|&&
operator|!
name|mustEmulateObjectBoundingModeGradients
condition|)
block|{
name|drawStretchedGradient
argument_list|(
name|originalPath
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|emulationSpecifier
operator|&
name|QPaintEngine_OpaqueBackground
condition|)
block|{
name|drawOpaqueBackground
argument_list|(
name|originalPath
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_Q
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|qreal
name|strokeOffsetX
init|=
literal|0
decl_stmt|,
name|strokeOffsetY
init|=
literal|0
decl_stmt|;
name|QPainterPath
name|path
init|=
name|originalPath
operator|*
name|state
operator|->
name|matrix
decl_stmt|;
name|QRectF
name|pathBounds
init|=
name|path
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|QRectF
name|strokeBounds
decl_stmt|;
name|bool
name|doStroke
init|=
operator|(
name|op
operator|&
name|StrokeDraw
operator|)
operator|&&
operator|(
name|state
operator|->
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
operator|)
decl_stmt|;
if|if
condition|(
name|doStroke
condition|)
block|{
name|qreal
name|penWidth
init|=
name|state
operator|->
name|pen
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|penWidth
operator|==
literal|0
condition|)
block|{
name|strokeOffsetX
operator|=
literal|1
expr_stmt|;
name|strokeOffsetY
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// In case of complex xform
if|if
condition|(
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxScale
condition|)
block|{
name|QPainterPathStroker
name|stroker
decl_stmt|;
name|stroker
operator|.
name|setWidth
argument_list|(
name|penWidth
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setJoinStyle
argument_list|(
name|state
operator|->
name|pen
operator|.
name|joinStyle
argument_list|()
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setCapStyle
argument_list|(
name|state
operator|->
name|pen
operator|.
name|capStyle
argument_list|()
argument_list|)
expr_stmt|;
name|QPainterPath
name|stroke
init|=
name|stroker
operator|.
name|createStroke
argument_list|(
name|originalPath
argument_list|)
decl_stmt|;
name|strokeBounds
operator|=
operator|(
name|stroke
operator|*
name|state
operator|->
name|matrix
operator|)
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|strokeOffsetX
operator|=
name|qAbs
argument_list|(
name|penWidth
operator|*
name|state
operator|->
name|matrix
operator|.
name|m11
argument_list|()
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|strokeOffsetY
operator|=
name|qAbs
argument_list|(
name|penWidth
operator|*
name|state
operator|->
name|matrix
operator|.
name|m22
argument_list|()
operator|/
literal|2.0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QRect
name|absPathRect
decl_stmt|;
if|if
condition|(
operator|!
name|strokeBounds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|absPathRect
operator|=
name|strokeBounds
operator|.
name|intersected
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|device
operator|->
name|width
argument_list|()
argument_list|,
name|device
operator|->
name|height
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|absPathRect
operator|=
name|pathBounds
operator|.
name|adjusted
argument_list|(
operator|-
name|strokeOffsetX
argument_list|,
operator|-
name|strokeOffsetY
argument_list|,
name|strokeOffsetX
argument_list|,
name|strokeOffsetY
argument_list|)
operator|.
name|intersected
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|device
operator|->
name|width
argument_list|()
argument_list|,
name|device
operator|->
name|height
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|hasClipping
argument_list|()
condition|)
block|{
name|bool
name|hasPerspectiveTransform
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterClipInfo
modifier|&
name|info
init|=
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxProject
condition|)
block|{
name|hasPerspectiveTransform
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// avoid mapping QRegions with perspective transforms
if|if
condition|(
operator|!
name|hasPerspectiveTransform
condition|)
block|{
comment|// The trick with txinv and invMatrix is done in order to
comment|// avoid transforming the clip to logical coordinates, and
comment|// then back to device coordinates. This is a problem with
comment|// QRegion/QRect based clips, since they use integer
comment|// coordinates and converting to/from logical coordinates will
comment|// lose precision.
name|bool
name|old_txinv
init|=
name|txinv
decl_stmt|;
name|QTransform
name|old_invMatrix
init|=
name|invMatrix
decl_stmt|;
name|txinv
operator|=
literal|true
expr_stmt|;
name|invMatrix
operator|=
name|QTransform
argument_list|()
expr_stmt|;
name|QPainterPath
name|clipPath
init|=
name|q
operator|->
name|clipPath
argument_list|()
decl_stmt|;
name|QRectF
name|r
init|=
name|clipPath
operator|.
name|boundingRect
argument_list|()
operator|.
name|intersected
argument_list|(
name|absPathRect
argument_list|)
decl_stmt|;
name|absPathRect
operator|=
name|r
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
name|txinv
operator|=
name|old_txinv
expr_stmt|;
name|invMatrix
operator|=
name|old_invMatrix
expr_stmt|;
block|}
block|}
comment|//     qDebug("\nQPainterPrivate::draw_helper(), x=%d, y=%d, w=%d, h=%d",
comment|//            devMinX, devMinY, device->width(), device->height());
comment|//     qDebug()<< " - matrix"<< state->matrix;
comment|//     qDebug()<< " - originalPath.bounds"<< originalPath.boundingRect();
comment|//     qDebug()<< " - path.bounds"<< path.boundingRect();
if|if
condition|(
name|absPathRect
operator|.
name|width
argument_list|()
operator|<=
literal|0
operator|||
name|absPathRect
operator|.
name|height
argument_list|()
operator|<=
literal|0
condition|)
return|return;
name|QImage
name|image
argument_list|(
name|absPathRect
operator|.
name|width
argument_list|()
argument_list|,
name|absPathRect
operator|.
name|height
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|image
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|image
argument_list|)
decl_stmt|;
name|p
operator|.
name|d_ptr
operator|->
name|helper_device
operator|=
name|helper_device
expr_stmt|;
name|p
operator|.
name|setOpacity
argument_list|(
name|state
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|p
operator|.
name|translate
argument_list|(
operator|-
name|absPathRect
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|absPathRect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|.
name|setTransform
argument_list|(
name|state
operator|->
name|matrix
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|doStroke
condition|?
name|state
operator|->
name|pen
else|:
name|QPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBrush
argument_list|(
operator|(
name|op
operator|&
name|FillDraw
operator|)
condition|?
name|state
operator|->
name|brush
else|:
name|QBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBackground
argument_list|(
name|state
operator|->
name|bgBrush
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBackgroundMode
argument_list|(
name|state
operator|->
name|bgMode
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBrushOrigin
argument_list|(
name|state
operator|->
name|brushOrigin
argument_list|)
expr_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
name|state
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|state
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawPath
argument_list|(
name|originalPath
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
specifier|static
name|bool
name|do_fallback_overlay
init|=
name|qgetenv
argument_list|(
literal|"QT_PAINT_FALLBACK_OVERLAY"
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|do_fallback_overlay
condition|)
block|{
name|QImage
name|block
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|QPainter
name|pt
argument_list|(
operator|&
name|block
argument_list|)
decl_stmt|;
name|pt
operator|.
name|fillRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|QColor
argument_list|(
literal|196
argument_list|,
literal|0
argument_list|,
literal|196
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|.
name|drawLine
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pt
operator|.
name|end
argument_list|()
expr_stmt|;
name|p
operator|.
name|resetTransform
argument_list|()
expr_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_SourceAtop
argument_list|)
expr_stmt|;
name|p
operator|.
name|setOpacity
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|QBrush
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
name|q
operator|->
name|save
argument_list|()
expr_stmt|;
name|state
operator|->
name|matrix
operator|=
name|QTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|extended
condition|)
block|{
name|extended
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|engine
operator|->
name|drawImage
argument_list|(
name|absPathRect
argument_list|,
name|image
argument_list|,
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|absPathRect
operator|.
name|width
argument_list|()
argument_list|,
name|absPathRect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|OrderedDither
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
name|q
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawOpaqueBackground
name|void
name|QPainterPrivate
operator|::
name|drawOpaqueBackground
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|DrawOperation
name|op
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|q
operator|->
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|FillDraw
operator|&&
name|state
operator|->
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|q
operator|->
name|fillPath
argument_list|(
name|path
argument_list|,
name|state
operator|->
name|bgBrush
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|fillPath
argument_list|(
name|path
argument_list|,
name|state
operator|->
name|brush
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|StrokeDraw
operator|&&
name|state
operator|->
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
condition|)
block|{
name|q
operator|->
name|strokePath
argument_list|(
name|path
argument_list|,
name|QPen
argument_list|(
name|state
operator|->
name|bgBrush
operator|.
name|color
argument_list|()
argument_list|,
name|state
operator|->
name|pen
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|strokePath
argument_list|(
name|path
argument_list|,
name|state
operator|->
name|pen
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|OpaqueMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stretchGradientToUserSpace
specifier|static
specifier|inline
name|QBrush
name|stretchGradientToUserSpace
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|boundingRect
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|brush
operator|.
name|style
argument_list|()
operator|>=
name|Qt
operator|::
name|LinearGradientPattern
operator|&&
name|brush
operator|.
name|style
argument_list|()
operator|<=
name|Qt
operator|::
name|ConicalGradientPattern
argument_list|)
expr_stmt|;
name|QTransform
name|gradientToUser
argument_list|(
name|boundingRect
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|boundingRect
operator|.
name|height
argument_list|()
argument_list|,
name|boundingRect
operator|.
name|x
argument_list|()
argument_list|,
name|boundingRect
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|QGradient
name|g
init|=
operator|*
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
name|g
operator|.
name|setCoordinateMode
argument_list|(
name|QGradient
operator|::
name|LogicalMode
argument_list|)
expr_stmt|;
name|QBrush
name|b
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|b
operator|.
name|setTransform
argument_list|(
name|gradientToUser
operator|*
name|b
operator|.
name|transform
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|drawStretchedGradient
name|void
name|QPainterPrivate
operator|::
name|drawStretchedGradient
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|DrawOperation
name|op
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|sw
init|=
name|helper_device
operator|->
name|width
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|sh
init|=
name|helper_device
operator|->
name|height
argument_list|()
decl_stmt|;
name|bool
name|changedPen
init|=
literal|false
decl_stmt|;
name|bool
name|changedBrush
init|=
literal|false
decl_stmt|;
name|bool
name|needsFill
init|=
literal|false
decl_stmt|;
specifier|const
name|QPen
name|pen
init|=
name|state
operator|->
name|pen
decl_stmt|;
specifier|const
name|QBrush
name|brush
init|=
name|state
operator|->
name|brush
decl_stmt|;
specifier|const
name|QGradient
operator|::
name|CoordinateMode
name|penMode
init|=
name|coordinateMode
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QGradient
operator|::
name|CoordinateMode
name|brushMode
init|=
name|coordinateMode
argument_list|(
name|brush
argument_list|)
decl_stmt|;
name|QRectF
name|boundingRect
decl_stmt|;
comment|// Draw the xformed fill if the brush is a stretch gradient.
if|if
condition|(
operator|(
name|op
operator|&
name|FillDraw
operator|)
operator|&&
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
if|if
condition|(
name|brushMode
operator|==
name|QGradient
operator|::
name|StretchToDeviceMode
condition|)
block|{
name|q
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|changedPen
operator|=
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
expr_stmt|;
name|q
operator|->
name|scale
argument_list|(
name|sw
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|isw
init|=
literal|1.0
operator|/
name|sw
decl_stmt|;
specifier|const
name|qreal
name|ish
init|=
literal|1.0
operator|/
name|sh
decl_stmt|;
name|QTransform
name|inv
argument_list|(
name|isw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ish
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|engine
operator|->
name|drawPath
argument_list|(
name|path
operator|*
name|inv
argument_list|)
expr_stmt|;
name|q
operator|->
name|scale
argument_list|(
name|isw
argument_list|,
name|ish
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needsFill
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|brushMode
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PatternTransform
argument_list|)
argument_list|)
expr_stmt|;
name|boundingRect
operator|=
name|path
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|q
operator|->
name|setBrush
argument_list|(
name|stretchGradientToUserSpace
argument_list|(
name|brush
argument_list|,
name|boundingRect
argument_list|)
argument_list|)
expr_stmt|;
name|changedBrush
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|op
operator|&
name|StrokeDraw
operator|)
operator|&&
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
condition|)
block|{
comment|// Draw the xformed outline if the pen is a stretch gradient.
if|if
condition|(
name|penMode
operator|==
name|QGradient
operator|::
name|StretchToDeviceMode
condition|)
block|{
name|q
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|changedPen
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|needsFill
condition|)
block|{
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|engine
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|scale
argument_list|(
name|sw
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|q
operator|->
name|setBrush
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
name|changedBrush
operator|=
literal|true
expr_stmt|;
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|QPainterPathStroker
name|stroker
decl_stmt|;
name|stroker
operator|.
name|setDashPattern
argument_list|(
name|pen
operator|.
name|style
argument_list|()
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setWidth
argument_list|(
name|pen
operator|.
name|widthF
argument_list|()
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setJoinStyle
argument_list|(
name|pen
operator|.
name|joinStyle
argument_list|()
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setCapStyle
argument_list|(
name|pen
operator|.
name|capStyle
argument_list|()
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setMiterLimit
argument_list|(
name|pen
operator|.
name|miterLimit
argument_list|()
argument_list|)
expr_stmt|;
name|QPainterPath
name|stroke
init|=
name|stroker
operator|.
name|createStroke
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|isw
init|=
literal|1.0
operator|/
name|sw
decl_stmt|;
specifier|const
name|qreal
name|ish
init|=
literal|1.0
operator|/
name|sh
decl_stmt|;
name|QTransform
name|inv
argument_list|(
name|isw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ish
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|engine
operator|->
name|drawPath
argument_list|(
name|stroke
operator|*
name|inv
argument_list|)
expr_stmt|;
name|q
operator|->
name|scale
argument_list|(
name|isw
argument_list|,
name|ish
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|needsFill
operator|&&
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|q
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|changedBrush
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|penMode
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PatternTransform
argument_list|)
argument_list|)
expr_stmt|;
comment|// avoid computing the bounding rect twice
if|if
condition|(
operator|!
name|needsFill
operator|||
name|brushMode
operator|!=
name|QGradient
operator|::
name|ObjectBoundingMode
condition|)
name|boundingRect
operator|=
name|path
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|QPen
name|p
init|=
name|pen
decl_stmt|;
name|p
operator|.
name|setBrush
argument_list|(
name|stretchGradientToUserSpace
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|,
name|boundingRect
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|changedPen
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|changedPen
condition|)
block|{
name|q
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|changedPen
operator|=
literal|false
expr_stmt|;
block|}
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|engine
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|needsFill
condition|)
block|{
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
condition|)
block|{
name|q
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|changedPen
operator|=
literal|true
expr_stmt|;
block|}
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|engine
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changedPen
condition|)
name|q
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
if|if
condition|(
name|changedBrush
condition|)
name|q
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateMatrix
name|void
name|QPainterPrivate
operator|::
name|updateMatrix
parameter_list|()
block|{
name|state
operator|->
name|matrix
operator|=
name|state
operator|->
name|WxF
condition|?
name|state
operator|->
name|worldMatrix
else|:
name|QTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|VxF
condition|)
name|state
operator|->
name|matrix
operator|*=
name|viewTransform
argument_list|()
expr_stmt|;
name|txinv
operator|=
literal|false
expr_stmt|;
comment|// no inverted matrix
name|state
operator|->
name|matrix
operator|*=
name|state
operator|->
name|redirectionMatrix
expr_stmt|;
if|if
condition|(
name|extended
condition|)
name|extended
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
else|else
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|state
operator|->
name|matrix
operator|*=
name|hidpiScaleTransform
argument_list|()
expr_stmt|;
comment|//     printf("VxF=%d, WxF=%d\n", state->VxF, state->WxF);
comment|//     qDebug()<< " --- using matrix"<< state->matrix<< redirection_offset;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|updateInvMatrix
name|void
name|QPainterPrivate
operator|::
name|updateInvMatrix
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|txinv
operator|==
literal|false
argument_list|)
expr_stmt|;
name|txinv
operator|=
literal|true
expr_stmt|;
comment|// creating inverted matrix
name|invMatrix
operator|=
name|state
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|extern
name|bool
name|qt_isExtendedRadialGradient
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|updateEmulationSpecifier
name|void
name|QPainterPrivate
operator|::
name|updateEmulationSpecifier
parameter_list|(
name|QPainterState
modifier|*
name|s
parameter_list|)
block|{
name|bool
name|alpha
init|=
literal|false
decl_stmt|;
name|bool
name|linearGradient
init|=
literal|false
decl_stmt|;
name|bool
name|radialGradient
init|=
literal|false
decl_stmt|;
name|bool
name|extendedRadialGradient
init|=
literal|false
decl_stmt|;
name|bool
name|conicalGradient
init|=
literal|false
decl_stmt|;
name|bool
name|patternBrush
init|=
literal|false
decl_stmt|;
name|bool
name|xform
init|=
literal|false
decl_stmt|;
name|bool
name|complexXform
init|=
literal|false
decl_stmt|;
name|bool
name|skip
init|=
literal|true
decl_stmt|;
comment|// Pen and brush properties (we have to check both if one changes because the
comment|// one that's unchanged can still be in a state which requires emulation)
if|if
condition|(
name|s
operator|->
name|state
argument_list|()
operator|&
operator|(
name|QPaintEngine
operator|::
name|DirtyPen
operator||
name|QPaintEngine
operator|::
name|DirtyBrush
operator||
name|QPaintEngine
operator|::
name|DirtyHints
operator|)
condition|)
block|{
comment|// Check Brush stroke emulation
if|if
condition|(
operator|!
name|s
operator|->
name|pen
operator|.
name|isSolid
argument_list|()
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|BrushStroke
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|BrushStroke
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|BrushStroke
expr_stmt|;
name|skip
operator|=
literal|false
expr_stmt|;
name|QBrush
name|penBrush
init|=
operator|(
name|qpen_style
argument_list|(
name|s
operator|->
name|pen
argument_list|)
operator|==
name|Qt
operator|::
name|NoPen
operator|)
condition|?
name|QBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
else|:
name|qpen_brush
argument_list|(
name|s
operator|->
name|pen
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|BrushStyle
name|brushStyle
init|=
name|qbrush_style
argument_list|(
name|s
operator|->
name|brush
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|BrushStyle
name|penBrushStyle
init|=
name|qbrush_style
argument_list|(
name|penBrush
argument_list|)
decl_stmt|;
name|alpha
operator|=
operator|(
name|penBrushStyle
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
operator|(
name|penBrushStyle
operator|<
name|Qt
operator|::
name|LinearGradientPattern
operator|&&
name|penBrush
operator|.
name|color
argument_list|()
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
operator|)
operator|&&
operator|!
name|penBrush
operator|.
name|isOpaque
argument_list|()
operator|)
operator|||
operator|(
name|brushStyle
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
operator|(
name|brushStyle
operator|<
name|Qt
operator|::
name|LinearGradientPattern
operator|&&
name|s
operator|->
name|brush
operator|.
name|color
argument_list|()
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
operator|)
operator|&&
operator|!
name|s
operator|->
name|brush
operator|.
name|isOpaque
argument_list|()
operator|)
expr_stmt|;
name|linearGradient
operator|=
operator|(
operator|(
name|penBrushStyle
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|)
operator|||
operator|(
name|brushStyle
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|)
operator|)
expr_stmt|;
name|radialGradient
operator|=
operator|(
operator|(
name|penBrushStyle
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|)
operator|||
operator|(
name|brushStyle
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|)
operator|)
expr_stmt|;
name|extendedRadialGradient
operator|=
name|radialGradient
operator|&&
operator|(
name|qt_isExtendedRadialGradient
argument_list|(
name|penBrush
argument_list|)
operator|||
name|qt_isExtendedRadialGradient
argument_list|(
name|s
operator|->
name|brush
argument_list|)
operator|)
expr_stmt|;
name|conicalGradient
operator|=
operator|(
operator|(
name|penBrushStyle
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
operator|)
operator|||
operator|(
name|brushStyle
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
operator|)
operator|)
expr_stmt|;
name|patternBrush
operator|=
operator|(
operator|(
operator|(
name|penBrushStyle
operator|>
name|Qt
operator|::
name|SolidPattern
operator|&&
name|penBrushStyle
operator|<
name|Qt
operator|::
name|LinearGradientPattern
operator|)
operator|||
name|penBrushStyle
operator|==
name|Qt
operator|::
name|TexturePattern
operator|)
operator|||
operator|(
operator|(
name|brushStyle
operator|>
name|Qt
operator|::
name|SolidPattern
operator|&&
name|brushStyle
operator|<
name|Qt
operator|::
name|LinearGradientPattern
operator|)
operator|||
name|brushStyle
operator|==
name|Qt
operator|::
name|TexturePattern
operator|)
operator|)
expr_stmt|;
name|bool
name|penTextureAlpha
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|penBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
name|penTextureAlpha
operator|=
name|qHasPixmapTexture
argument_list|(
name|penBrush
argument_list|)
condition|?
operator|(
name|penBrush
operator|.
name|texture
argument_list|()
operator|.
name|depth
argument_list|()
operator|>
literal|1
operator|)
operator|&&
name|penBrush
operator|.
name|texture
argument_list|()
operator|.
name|hasAlpha
argument_list|()
else|:
name|penBrush
operator|.
name|textureImage
argument_list|()
operator|.
name|hasAlphaChannel
argument_list|()
expr_stmt|;
name|bool
name|brushTextureAlpha
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
name|brushTextureAlpha
operator|=
name|qHasPixmapTexture
argument_list|(
name|s
operator|->
name|brush
argument_list|)
condition|?
operator|(
name|s
operator|->
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|depth
argument_list|()
operator|>
literal|1
operator|)
operator|&&
name|s
operator|->
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|hasAlpha
argument_list|()
else|:
name|s
operator|->
name|brush
operator|.
name|textureImage
argument_list|()
operator|.
name|hasAlphaChannel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|penBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
operator|&&
name|penTextureAlpha
operator|)
operator|||
operator|(
name|s
operator|->
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
operator|&&
name|brushTextureAlpha
operator|)
operator|)
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|MaskedBrush
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|MaskedBrush
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|MaskedBrush
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|state
argument_list|()
operator|&
operator|(
name|QPaintEngine
operator|::
name|DirtyHints
operator||
name|QPaintEngine
operator|::
name|DirtyOpacity
operator||
name|QPaintEngine
operator|::
name|DirtyBackgroundMode
operator|)
condition|)
block|{
name|skip
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
return|return;
if|#
directive|if
literal|0
block|qDebug("QPainterPrivate::updateEmulationSpecifier, state=%p\n"            " - alpha: %d\n"            " - linearGradient: %d\n"            " - radialGradient: %d\n"            " - conicalGradient: %d\n"            " - patternBrush: %d\n"            " - hints: %x\n"            " - xform: %d\n",            s,            alpha,            linearGradient,            radialGradient,            conicalGradient,            patternBrush,            uint(s->renderHints),            xform);
endif|#
directive|endif
comment|// XForm properties
if|if
condition|(
name|s
operator|->
name|state
argument_list|()
operator|&
name|QPaintEngine
operator|::
name|DirtyTransform
condition|)
block|{
name|xform
operator|=
operator|!
name|s
operator|->
name|matrix
operator|.
name|isIdentity
argument_list|()
expr_stmt|;
name|complexXform
operator|=
operator|!
name|s
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>=
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
name|xform
operator|=
literal|true
expr_stmt|;
name|complexXform
operator|=
operator|!
name|s
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
expr_stmt|;
block|}
specifier|const
name|bool
name|brushXform
init|=
operator|(
name|s
operator|->
name|brush
operator|.
name|transform
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|QTransform
operator|::
name|TxNone
operator|)
decl_stmt|;
specifier|const
name|bool
name|penXform
init|=
operator|(
name|s
operator|->
name|pen
operator|.
name|brush
argument_list|()
operator|.
name|transform
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|QTransform
operator|::
name|TxNone
operator|)
decl_stmt|;
specifier|const
name|bool
name|patternXform
init|=
name|patternBrush
operator|&&
operator|(
name|xform
operator|||
name|brushXform
operator|||
name|penXform
operator|)
decl_stmt|;
comment|// Check alphablending
if|if
condition|(
name|alpha
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|AlphaBlend
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|AlphaBlend
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|AlphaBlend
expr_stmt|;
comment|// Linear gradient emulation
if|if
condition|(
name|linearGradient
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|LinearGradientFill
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|LinearGradientFill
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|LinearGradientFill
expr_stmt|;
comment|// Radial gradient emulation
if|if
condition|(
name|extendedRadialGradient
operator|||
operator|(
name|radialGradient
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|RadialGradientFill
argument_list|)
operator|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|RadialGradientFill
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|RadialGradientFill
expr_stmt|;
comment|// Conical gradient emulation
if|if
condition|(
name|conicalGradient
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConicalGradientFill
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|ConicalGradientFill
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|ConicalGradientFill
expr_stmt|;
comment|// Pattern brushes
if|if
condition|(
name|patternBrush
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PatternBrush
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|PatternBrush
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|PatternBrush
expr_stmt|;
comment|// Pattern XForms
if|if
condition|(
name|patternXform
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PatternTransform
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|PatternTransform
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|PatternTransform
expr_stmt|;
comment|// Primitive XForms
if|if
condition|(
name|xform
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PrimitiveTransform
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|PrimitiveTransform
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|PrimitiveTransform
expr_stmt|;
comment|// Perspective XForms
if|if
condition|(
name|complexXform
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PerspectiveTransform
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|PerspectiveTransform
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|PerspectiveTransform
expr_stmt|;
comment|// Constant opacity
if|if
condition|(
name|state
operator|->
name|opacity
operator|!=
literal|1
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|ConstantOpacity
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|ConstantOpacity
expr_stmt|;
name|bool
name|gradientStretch
init|=
literal|false
decl_stmt|;
name|bool
name|objectBoundingMode
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|linearGradient
operator|||
name|conicalGradient
operator|||
name|radialGradient
condition|)
block|{
name|QGradient
operator|::
name|CoordinateMode
name|brushMode
init|=
name|coordinateMode
argument_list|(
name|s
operator|->
name|brush
argument_list|)
decl_stmt|;
name|QGradient
operator|::
name|CoordinateMode
name|penMode
init|=
name|coordinateMode
argument_list|(
name|s
operator|->
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
decl_stmt|;
name|gradientStretch
operator||=
operator|(
name|brushMode
operator|==
name|QGradient
operator|::
name|StretchToDeviceMode
operator|)
expr_stmt|;
name|gradientStretch
operator||=
operator|(
name|penMode
operator|==
name|QGradient
operator|::
name|StretchToDeviceMode
operator|)
expr_stmt|;
name|objectBoundingMode
operator||=
operator|(
name|brushMode
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
operator|)
expr_stmt|;
name|objectBoundingMode
operator||=
operator|(
name|penMode
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|gradientStretch
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QGradient_StretchToDevice
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QGradient_StretchToDevice
expr_stmt|;
if|if
condition|(
name|objectBoundingMode
operator|&&
operator|!
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
argument_list|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine
operator|::
name|ObjectBoundingModeGradients
expr_stmt|;
comment|// Opaque backgrounds...
if|if
condition|(
name|s
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
operator|&&
operator|(
name|is_pen_transparent
argument_list|(
name|s
operator|->
name|pen
argument_list|)
operator|||
name|is_brush_transparent
argument_list|(
name|s
operator|->
name|brush
argument_list|)
operator|)
condition|)
name|s
operator|->
name|emulationSpecifier
operator||=
name|QPaintEngine_OpaqueBackground
expr_stmt|;
else|else
name|s
operator|->
name|emulationSpecifier
operator|&=
operator|~
name|QPaintEngine_OpaqueBackground
expr_stmt|;
if|#
directive|if
literal|0
comment|//won't be correct either way because the device can already have
comment|// something rendered to it in which case subsequent emulation
comment|// on a fully transparent qimage and then blitting the results
comment|// won't produce correct results
comment|// Blend modes
block|if (state->composition_mode> QPainter::CompositionMode_Xor&&         !engine->hasFeature(QPaintEngine::BlendModes))         s->emulationSpecifier |= QPaintEngine::BlendModes;     else         s->emulationSpecifier&= ~QPaintEngine::BlendModes;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|updateStateImpl
name|void
name|QPainterPrivate
operator|::
name|updateStateImpl
parameter_list|(
name|QPainterState
modifier|*
name|newState
parameter_list|)
block|{
comment|// ### we might have to call QPainter::begin() here...
if|if
condition|(
operator|!
name|engine
operator|->
name|state
condition|)
block|{
name|engine
operator|->
name|state
operator|=
name|newState
expr_stmt|;
name|engine
operator|->
name|setDirty
argument_list|(
name|QPaintEngine
operator|::
name|AllDirty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|engine
operator|->
name|state
operator|->
name|painter
argument_list|()
operator|!=
name|newState
operator|->
name|painter
condition|)
comment|// ### this could break with clip regions vs paths.
name|engine
operator|->
name|setDirty
argument_list|(
name|QPaintEngine
operator|::
name|AllDirty
argument_list|)
expr_stmt|;
comment|// Upon restore, revert all changes since last save
elseif|else
if|if
condition|(
name|engine
operator|->
name|state
operator|!=
name|newState
condition|)
name|newState
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyFlags
argument_list|(
cast|static_cast
argument_list|<
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|engine
operator|->
name|state
argument_list|)
operator|->
name|changeFlags
argument_list|)
expr_stmt|;
comment|// We need to store all changes made so that restore can deal with them
else|else
name|newState
operator|->
name|changeFlags
operator||=
name|newState
operator|->
name|dirtyFlags
expr_stmt|;
name|updateEmulationSpecifier
argument_list|(
name|newState
argument_list|)
expr_stmt|;
comment|// Unset potential dirty background mode
name|newState
operator|->
name|dirtyFlags
operator|&=
operator|~
operator|(
name|QPaintEngine
operator|::
name|DirtyBackgroundMode
operator||
name|QPaintEngine
operator|::
name|DirtyBackground
operator|)
expr_stmt|;
name|engine
operator|->
name|state
operator|=
name|newState
expr_stmt|;
name|engine
operator|->
name|updateState
argument_list|(
operator|*
name|newState
argument_list|)
expr_stmt|;
name|engine
operator|->
name|clearDirty
argument_list|(
name|QPaintEngine
operator|::
name|AllDirty
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateState
name|void
name|QPainterPrivate
operator|::
name|updateState
parameter_list|(
name|QPainterState
modifier|*
name|newState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newState
condition|)
block|{
name|engine
operator|->
name|state
operator|=
name|newState
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newState
operator|->
name|state
argument_list|()
operator|||
name|engine
operator|->
name|state
operator|!=
name|newState
condition|)
block|{
name|updateStateImpl
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QPainter     \brief The QPainter class performs low-level painting on widgets and     other paint devices.      \inmodule QtGui     \ingroup painting      \reentrant      QPainter provides highly optimized functions to do most of the     drawing GUI programs require. It can draw everything from simple     lines to complex shapes like pies and chords. It can also draw     aligned text and pixmaps. Normally, it draws in a "natural"     coordinate system, but it can also do view and world     transformation. QPainter can operate on any object that inherits     the QPaintDevice class.      The common use of QPainter is inside a widget's paint event:     Construct and customize (e.g. set the pen or the brush) the     painter. Then draw. Remember to destroy the QPainter object after     drawing. For example:      \snippet code/src_gui_painting_qpainter.cpp 0      The core functionality of QPainter is drawing, but the class also     provide several functions that allows you to customize QPainter's     settings and its rendering quality, and others that enable     clipping. In addition you can control how different shapes are     merged together by specifying the painter's composition mode.      The isActive() function indicates whether the painter is active. A     painter is activated by the begin() function and the constructor     that takes a QPaintDevice argument. The end() function, and the     destructor, deactivates it.      Together with the QPaintDevice and QPaintEngine classes, QPainter     form the basis for Qt's paint system. QPainter is the class used     to perform drawing operations. QPaintDevice represents a device     that can be painted on using a QPainter. QPaintEngine provides the     interface that the painter uses to draw onto different types of     devices. If the painter is active, device() returns the paint     device on which the painter paints, and paintEngine() returns the     paint engine that the painter is currently operating on. For more     information, see the \l {Paint System}.      Sometimes it is desirable to make someone else paint on an unusual     QPaintDevice. QPainter supports a static function to do this,     setRedirected().      \warning When the paintdevice is a widget, QPainter can only be     used inside a paintEvent() function or in a function called by     paintEvent().      \tableofcontents      \section1 Settings      There are several settings that you can customize to make QPainter     draw according to your preferences:      \list      \li font() is the font used for drawing text. If the painter         isActive(), you can retrieve information about the currently set         font, and its metrics, using the fontInfo() and fontMetrics()         functions respectively.      \li brush() defines the color or pattern that is used for filling        shapes.      \li pen() defines the color or stipple that is used for drawing        lines or boundaries.      \li backgroundMode() defines whether there is a background() or        not, i.e it is either Qt::OpaqueMode or Qt::TransparentMode.      \li background() only applies when backgroundMode() is \l        Qt::OpaqueMode and pen() is a stipple. In that case, it        describes the color of the background pixels in the stipple.      \li brushOrigin() defines the origin of the tiled brushes, normally        the origin of widget's background.      \li viewport(), window(), worldTransform() make up the painter's coordinate         transformation system. For more information, see the \l         {Coordinate Transformations} section and the \l {Coordinate         System} documentation.      \li hasClipping() tells whether the painter clips at all. (The paint        device clips, too.) If the painter clips, it clips to clipRegion().      \li layoutDirection() defines the layout direction used by the        painter when drawing text.      \li worldMatrixEnabled() tells whether world transformation is enabled.      \li viewTransformEnabled() tells whether view transformation is         enabled.      \endlist      Note that some of these settings mirror settings in some paint     devices, e.g.  QWidget::font(). The QPainter::begin() function (or     equivalently the QPainter constructor) copies these attributes     from the paint device.      You can at any time save the QPainter's state by calling the     save() function which saves all the available settings on an     internal stack. The restore() function pops them back.      \section1 Drawing      QPainter provides functions to draw most primitives: drawPoint(),     drawPoints(), drawLine(), drawRect(), drawRoundedRect(),     drawEllipse(), drawArc(), drawPie(), drawChord(), drawPolyline(),     drawPolygon(), drawConvexPolygon() and drawCubicBezier().  The two     convenience functions, drawRects() and drawLines(), draw the given     number of rectangles or lines in the given array of \l     {QRect}{QRects} or \l {QLine}{QLines} using the current pen and     brush.      The QPainter class also provides the fillRect() function which     fills the given QRect, with the given QBrush, and the eraseRect()     function that erases the area inside the given rectangle.      All of these functions have both integer and floating point     versions.      \table 100%     \row     \li \inlineimage qpainter-basicdrawing.png     \li     \b {Basic Drawing Example}      The \l {painting/basicdrawing}{Basic Drawing} example shows how to     display basic graphics primitives in a variety of styles using the     QPainter class.      \endtable      If you need to draw a complex shape, especially if you need to do     so repeatedly, consider creating a QPainterPath and drawing it     using drawPath().      \table 100%     \row     \li     \b {Painter Paths example}      The QPainterPath class provides a container for painting     operations, enabling graphical shapes to be constructed and     reused.      The \l {painting/painterpaths}{Painter Paths} example shows how     painter paths can be used to build complex shapes for rendering.      \li \inlineimage qpainter-painterpaths.png     \endtable      QPainter also provides the fillPath() function which fills the     given QPainterPath with the given QBrush, and the strokePath()     function that draws the outline of the given path (i.e. strokes     the path).      See also the \l {painting/deform}{Vector Deformation} example which     shows how to use advanced vector techniques to draw text using a     QPainterPath, the \l {painting/gradients}{Gradients} example which shows     the different types of gradients that are available in Qt, and the \l     {painting/pathstroke}{Path Stroking} example which shows Qt's built-in     dash patterns and shows how custom patterns can be used to extend     the range of available patterns.      \table     \header     \li \l {painting/deform}{Vector Deformation}     \li \l {painting/gradients}{Gradients}     \li \l {painting/pathstroke}{Path Stroking}     \row     \li \inlineimage qpainter-vectordeformation.png     \li \inlineimage qpainter-gradients.png     \li \inlineimage qpainter-pathstroking.png     \endtable       There are functions to draw pixmaps/images, namely drawPixmap(),     drawImage() and drawTiledPixmap(). Both drawPixmap() and drawImage()     produce the same result, except that drawPixmap() is faster     on-screen while drawImage() may be faster on a QPrinter or other     devices.      Text drawing is done using drawText(). When you need     fine-grained positioning, boundingRect() tells you where a given     drawText() command will draw.      There is a drawPicture() function that draws the contents of an     entire QPicture. The drawPicture() function is the only function     that disregards all the painter's settings as QPicture has its own     settings.      \section1 Rendering Quality      To get the optimal rendering result using QPainter, you should use     the platform independent QImage as paint device; i.e. using QImage     will ensure that the result has an identical pixel representation     on any platform.      The QPainter class also provides a means of controlling the     rendering quality through its RenderHint enum and the support for     floating point precision: All the functions for drawing primitives     has a floating point version. These are often used in combination     with the \l {RenderHint}{QPainter::Antialiasing} render hint.      \table 100%     \row     \li \inlineimage qpainter-concentriccircles.png     \li     \b {Concentric Circles Example}      The \l {painting/concentriccircles}{Concentric Circles} example     shows the improved rendering quality that can be obtained using     floating point precision and anti-aliasing when drawing custom     widgets.      The application's main window displays several widgets which are     drawn using the various combinations of precision and     anti-aliasing.      \endtable      The RenderHint enum specifies flags to QPainter that may or may     not be respected by any given engine.  \l     {RenderHint}{QPainter::Antialiasing} indicates that the engine     should antialias edges of primitives if possible, \l     {RenderHint}{QPainter::TextAntialiasing} indicates that the engine     should antialias text if possible, and the \l     {RenderHint}{QPainter::SmoothPixmapTransform} indicates that the     engine should use a smooth pixmap transformation algorithm.      The renderHints() function returns a flag that specifies the     rendering hints that are set for this painter.  Use the     setRenderHint() function to set or clear the currently set     RenderHints.      \section1 Coordinate Transformations      Normally, the QPainter operates on the device's own coordinate     system (usually pixels), but QPainter has good support for     coordinate transformations.      \table     \header     \li  nop \li rotate() \li scale() \li translate()     \row     \li \inlineimage qpainter-clock.png     \li \inlineimage qpainter-rotation.png     \li \inlineimage qpainter-scale.png     \li \inlineimage qpainter-translation.png     \endtable      The most commonly used transformations are scaling, rotation,     translation and shearing. Use the scale() function to scale the     coordinate system by a given offset, the rotate() function to     rotate it clockwise and translate() to translate it (i.e. adding a     given offset to the points). You can also twist the coordinate     system around the origin using the shear() function. See the \l     {painting/affine}{Affine Transformations} example for a visualization of     a sheared coordinate system.      See also the \l {painting/transformations}{Transformations}     example which shows how transformations influence the way that     QPainter renders graphics primitives. In particular it shows how     the order of transformations affects the result.      \table 100%     \row     \li     \b {Affine Transformations Example}      The \l {painting/affine}{Affine Transformations} example shows Qt's     ability to perform affine transformations on painting     operations. The demo also allows the user to experiment with the     transformation operations and see the results immediately.      \li \inlineimage qpainter-affinetransformations.png     \endtable      All the tranformation operations operate on the transformation     worldTransform(). A matrix transforms a point in the plane to another     point. For more information about the transformation matrix, see     the \l {Coordinate System} and QTransform documentation.      The setWorldTransform() function can replace or add to the currently     set worldTransform(). The resetTransform() function resets any     transformations that were made using translate(), scale(),     shear(), rotate(), setWorldTransform(), setViewport() and setWindow()     functions. The deviceTransform() returns the matrix that transforms     from logical coordinates to device coordinates of the platform     dependent paint device. The latter function is only needed when     using platform painting commands on the platform dependent handle,     and the platform does not do transformations nativly.      When drawing with QPainter, we specify points using logical     coordinates which then are converted into the physical coordinates     of the paint device. The mapping of the logical coordinates to the     physical coordinates are handled by QPainter's combinedTransform(), a     combination of viewport() and window() and worldTransform(). The     viewport() represents the physical coordinates specifying an     arbitrary rectangle, the window() describes the same rectangle in     logical coordinates, and the worldTransform() is identical with the     transformation matrix.      See also \l {Coordinate System}      \section1 Clipping      QPainter can clip any drawing operation to a rectangle, a region,     or a vector path. The current clip is available using the     functions clipRegion() and clipPath(). Whether paths or regions are     preferred (faster) depends on the underlying paintEngine(). For     example, the QImage paint engine prefers paths while the X11 paint     engine prefers regions. Setting a clip is done in the painters     logical coordinates.      After QPainter's clipping, the paint device may also clip. For     example, most widgets clip away the pixels used by child widgets,     and most printers clip away an area near the edges of the paper.     This additional clipping is not reflected by the return value of     clipRegion() or hasClipping().      \section1 Composition Modes     \target Composition Modes      QPainter provides the CompositionMode enum which defines the     Porter-Duff rules for digital image compositing; it describes a     model for combining the pixels in one image, the source, with the     pixels in another image, the destination.      The two most common forms of composition are \l     {QPainter::CompositionMode}{Source} and \l     {QPainter::CompositionMode}{SourceOver}.  \l     {QPainter::CompositionMode}{Source} is used to draw opaque objects     onto a paint device. In this mode, each pixel in the source     replaces the corresponding pixel in the destination. In \l     {QPainter::CompositionMode}{SourceOver} composition mode, the     source object is transparent and is drawn on top of the     destination.      Note that composition transformation operates pixelwise. For that     reason, there is a difference between using the graphic primitive     itself and its bounding rectangle: The bounding rect contains     pixels with alpha == 0 (i.e the pixels surrounding the     primitive). These pixels will overwrite the other image's pixels,     affectively clearing those, while the primitive only overwrites     its own area.      \table 100%     \row     \li \inlineimage qpainter-compositiondemo.png      \li     \b {Composition Modes Example}      The \l {painting/composition}{Composition Modes} example, available in     Qt's examples directory, allows you to experiment with the various     composition modes and see the results immediately.      \endtable      \section1 Limitations     \target Limitations      If you are using coordinates with Qt's raster-based paint engine, it is     important to note that, while coordinates greater than +/- 2\sup 15 can     be used, any painting performed with coordinates outside this range is not     guaranteed to be shown; the drawing may be clipped. This is due to the     use of \c{short int} in the implementation.      The outlines generated by Qt's stroker are only an approximation when dealing     with curved shapes. It is in most cases impossible to represent the outline of     a bezier curve segment using another bezier curve segment, and so Qt approximates     the curve outlines by using several smaller curves. For performance reasons there     is a limit to how many curves Qt uses for these outlines, and thus when using     large pen widths or scales the outline error increases. To generate outlines with     smaller errors it is possible to use the QPainterPathStroker class, which has the     setCurveThreshold member function which let's the user specify the error tolerance.     Another workaround is to convert the paths to polygons first and then draw the     polygons instead.      \section1 Performance      QPainter is a rich framework that allows developers to do a great     variety of graphical operations, such as gradients, composition     modes and vector graphics. And QPainter can do this across a     variety of different hardware and software stacks. Naturally the     underlying combination of hardware and software has some     implications for performance, and ensuring that every single     operation is fast in combination with all the various combinations     of composition modes, brushes, clipping, transformation, etc, is     close to an impossible task because of the number of     permutations. As a compromise we have selected a subset of the     QPainter API and backends, where performance is guaranteed to be as     good as we can sensibly get it for the given combination of     hardware and software.      The backends we focus on as high-performance engines are:      \list      \li Raster - This backend implements all rendering in pure software     and is always used to render into QImages. For optimal performance     only use the format types QImage::Format_ARGB32_Premultiplied,     QImage::Format_RGB32 or QImage::Format_RGB16. Any other format,     including QImage::Format_ARGB32, has significantly worse     performance. This engine is used by default for QWidget and QPixmap.      \li OpenGL 2.0 (ES) - This backend is the primary backend for     hardware accelerated graphics. It can be run on desktop machines     and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0     specification. This includes most graphics chips produced in the     last couple of years. The engine can be enabled by using QPainter     onto a QOpenGLWidget or by passing \c {-graphicssystem opengl} on the     command line when the underlying system supports it.      \li OpenVG - This backend implements the Khronos standard for 2D     and Vector Graphics. It is primarily for embedded devices with     hardware support for OpenVG.  The engine can be enabled by     passing \c {-graphicssystem openvg} on the command line when     the underlying system supports it.      \endlist      These operations are:      \list      \li Simple transformations, meaning translation and scaling, pluss     0, 90, 180, 270 degree rotations.      \li \c drawPixmap() in combination with simple transformations and     opacity with non-smooth transformation mode     (\c QPainter::SmoothPixmapTransform not enabled as a render hint).      \li Rectangle fills with solid color, two-color linear gradients     and simple transforms.      \li Rectangular clipping with simple transformations and intersect     clip.      \li Composition Modes \c QPainter::CompositionMode_Source and     QPainter::CompositionMode_SourceOver      \li Rounded rectangle filling using solid color and two-color     linear gradients fills.      \li 3x3 patched pixmaps, via qDrawBorderPixmap.      \endlist      This list gives an indication of which features to safely use in     an application where performance is critical. For certain setups,     other operations may be fast too, but before making extensive use     of them, it is recommended to benchmark and verify them on the     system where the software will run in the end. There are also     cases where expensive operations are ok to use, for instance when     the result is cached in a QPixmap.      \sa QPaintDevice, QPaintEngine, {Qt SVG}, {Basic Drawing Example},         {Drawing Utility Functions} */
end_comment
begin_comment
comment|/*!     \enum QPainter::RenderHint      Renderhints are used to specify flags to QPainter that may or     may not be respected by any given engine.      \value Antialiasing Indicates that the engine should antialias     edges of primitives if possible.      \value TextAntialiasing Indicates that the engine should antialias     text if possible. To forcibly disable antialiasing for text, do not     use this hint. Instead, set QFont::NoAntialias on your font's style     strategy.      \value SmoothPixmapTransform Indicates that the engine should use     a smooth pixmap transformation algorithm (such as bilinear) rather     than nearest neighbor.      \value HighQualityAntialiasing This value is obsolete and will be ignored,     use the Antialiasing render hint instead.      \value NonCosmeticDefaultPen This value is obsolete, the default for QPen     is now non-cosmetic.      \value Qt4CompatiblePainting Compatibility hint telling the engine to use the     same X11 based fill rules as in Qt 4, where aliased rendering is offset     by slightly less than half a pixel. Also will treat default constructed pens     as cosmetic. Potentially useful when porting a Qt 4 application to Qt 5.      \sa renderHints(), setRenderHint(), {QPainter#Rendering     Quality}{Rendering Quality}, {Concentric Circles Example}  */
end_comment
begin_comment
comment|/*!     Constructs a painter.      \sa begin(), end() */
end_comment
begin_constructor
DECL|function|QPainter
name|QPainter
operator|::
name|QPainter
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QPainterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \fn QPainter::QPainter(QPaintDevice *device)      Constructs a painter that begins painting the paint \a device     immediately.      This constructor is convenient for short-lived painters, e.g. in a     QWidget::paintEvent() and should be used only once. The     constructor calls begin() for you and the QPainter destructor     automatically calls end().      Here's an example using begin() and end():     \snippet code/src_gui_painting_qpainter.cpp 1      The same example using this constructor:     \snippet code/src_gui_painting_qpainter.cpp 2      Since the constructor cannot provide feedback when the initialization     of the painter failed you should rather use begin() and end() to paint     on external devices, e.g. printers.      \sa begin(), end() */
end_comment
begin_constructor
DECL|function|QPainter
name|QPainter
operator|::
name|QPainter
parameter_list|(
name|QPaintDevice
modifier|*
name|pd
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pd
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QPainterPrivate
operator|::
name|attachPainterPrivate
argument_list|(
name|this
argument_list|,
name|pd
argument_list|)
condition|)
block|{
name|d_ptr
operator|.
name|reset
argument_list|(
operator|new
name|QPainterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|begin
argument_list|(
name|pd
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|d_ptr
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the painter. */
end_comment
begin_destructor
DECL|function|~QPainter
name|QPainter
operator|::
name|~
name|QPainter
parameter_list|()
block|{
name|d_ptr
operator|->
name|inDestructor
operator|=
literal|true
expr_stmt|;
name|QT_TRY
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
name|end
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|refcount
operator|>
literal|1
condition|)
name|d_ptr
operator|->
name|detachPainterPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// don't throw anything in the destructor.
block|}
if|if
condition|(
name|d_ptr
condition|)
block|{
comment|// Make sure we haven't messed things up.
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|->
name|inDestructor
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|inDestructor
operator|=
literal|false
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|->
name|refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|d_ptrs
condition|)
name|free
argument_list|(
name|d_ptr
operator|->
name|d_ptrs
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     Returns the paint device on which this painter is currently     painting, or 0 if the painter is not active.      \sa isActive() */
end_comment
begin_function
DECL|function|device
name|QPaintDevice
modifier|*
name|QPainter
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
name|isActive
argument_list|()
operator|&&
name|d
operator|->
name|engine
operator|->
name|d_func
argument_list|()
operator|->
name|currentClipDevice
condition|)
return|return
name|d
operator|->
name|engine
operator|->
name|d_func
argument_list|()
operator|->
name|currentClipDevice
return|;
return|return
name|d
operator|->
name|original_device
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if begin() has been called and end() has not yet been     called; otherwise returns false.      \sa begin(), QPaintDevice::paintingActive() */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QPainter
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     Initializes the painters pen, background and font to the same as     the given \a device.      \obsolete      \sa begin(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|initFrom
name|void
name|QPainter
operator|::
name|initFrom
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|device
argument_list|,
literal|"QPainter::initFrom(const QPaintDevice *device)"
argument_list|,
literal|"QPaintDevice cannot be 0"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::initFrom: Painter not active, aborted"
argument_list|)
expr_stmt|;
return|return;
block|}
name|device
operator|->
name|initPainter
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|penChanged
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|engine
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|setDirty
argument_list|(
name|QPaintEngine
operator|::
name|DirtyPen
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|setDirty
argument_list|(
name|QPaintEngine
operator|::
name|DirtyBrush
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|setDirty
argument_list|(
name|QPaintEngine
operator|::
name|DirtyFont
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Saves the current painter state (pushes the state onto a stack). A     save() must be followed by a corresponding restore(); the end()     function unwinds the stack.      \sa restore() */
end_comment
begin_function
DECL|function|save
name|void
name|QPainter
operator|::
name|save
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::save()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::save: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|extended
operator|->
name|createState
argument_list|(
name|d
operator|->
name|states
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|setState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
operator|new
name|QPainterState
argument_list|(
name|d
operator|->
name|states
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|state
operator|=
name|d
operator|->
name|state
expr_stmt|;
block|}
name|d
operator|->
name|states
operator|.
name|push_back
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Restores the current painter state (pops a saved state off the     stack).      \sa save() */
end_comment
begin_function
DECL|function|restore
name|void
name|QPainter
operator|::
name|restore
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::restore()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|states
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::restore: Unbalanced save/restore"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::restore: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPainterState
modifier|*
name|tmp
init|=
name|d
operator|->
name|state
decl_stmt|;
name|d
operator|->
name|states
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|states
operator|.
name|back
argument_list|()
expr_stmt|;
name|d
operator|->
name|txinv
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|checkEmulation
argument_list|()
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|setState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
operator|delete
name|tmp
expr_stmt|;
return|return;
block|}
comment|// trigger clip update if the clip path/region has changed since
comment|// last save
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|tmp
operator|->
name|changeFlags
operator|&
operator|(
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyClipPath
operator|)
operator|)
condition|)
block|{
comment|// reuse the tmp state to avoid any extra allocs...
name|tmp
operator|->
name|dirtyFlags
operator|=
name|QPaintEngine
operator|::
name|DirtyClipPath
expr_stmt|;
name|tmp
operator|->
name|clipOperation
operator|=
name|Qt
operator|::
name|NoClip
expr_stmt|;
name|tmp
operator|->
name|clipPath
operator|=
name|QPainterPath
argument_list|()
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|updateState
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
comment|// replay the list of clip states,
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterClipInfo
modifier|&
name|info
init|=
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|matrix
operator|=
name|info
operator|.
name|matrix
expr_stmt|;
name|tmp
operator|->
name|matrix
operator|*=
name|d
operator|->
name|state
operator|->
name|redirectionMatrix
expr_stmt|;
name|tmp
operator|->
name|clipOperation
operator|=
name|info
operator|.
name|operation
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RectClip
condition|)
block|{
name|tmp
operator|->
name|dirtyFlags
operator|=
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|tmp
operator|->
name|clipRegion
operator|=
name|info
operator|.
name|rect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RegionClip
condition|)
block|{
name|tmp
operator|->
name|dirtyFlags
operator|=
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|tmp
operator|->
name|clipRegion
operator|=
name|info
operator|.
name|region
expr_stmt|;
block|}
else|else
block|{
comment|// clipType == QPainterClipInfo::PathClip
name|tmp
operator|->
name|dirtyFlags
operator|=
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|tmp
operator|->
name|clipPath
operator|=
name|info
operator|.
name|path
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|updateState
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|//Since we've updated the clip region anyway, pretend that the clip path hasn't changed:
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator|&=
operator|~
operator|(
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator|)
expr_stmt|;
name|tmp
operator|->
name|changeFlags
operator|&=
operator|~
name|uint
argument_list|(
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyClipRegion
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|changeFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
operator|delete
name|tmp
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      \fn bool QPainter::begin(QPaintDevice *device)      Begins painting the paint \a device and returns true if     successful; otherwise returns false.      Notice that all painter settings (setPen(), setBrush() etc.) are reset     to default values when begin() is called.      The errors that can occur are serious problems, such as these:      \snippet code/src_gui_painting_qpainter.cpp 3      Note that most of the time, you can use one of the constructors     instead of begin(), and that end() is automatically done at     destruction.      \warning A paint device can only be painted by one painter at a     time.      \warning Painting on a QImage with the format     QImage::Format_Indexed8 is not supported.      \sa end(), QPainter() */
end_comment
begin_function
DECL|function|qt_cleanup_painter_state
specifier|static
specifier|inline
name|void
name|qt_cleanup_painter_state
parameter_list|(
name|QPainterPrivate
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|states
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|d
operator|->
name|state
expr_stmt|;
name|d
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|engine
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|device
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|begin
name|bool
name|QPainter
operator|::
name|begin
parameter_list|(
name|QPaintDevice
modifier|*
name|pd
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|painters
operator|>
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin: A paint device can only be painted by one painter at a time."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin: Painter already active"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|QPainterPrivate
operator|::
name|attachPainterPrivate
argument_list|(
name|this
argument_list|,
name|pd
argument_list|)
condition|)
return|return
literal|true
return|;
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|d
operator|->
name|helper_device
operator|=
name|pd
expr_stmt|;
name|d
operator|->
name|original_device
operator|=
name|pd
expr_stmt|;
name|QPoint
name|redirectionOffset
decl_stmt|;
name|QPaintDevice
modifier|*
name|rpd
init|=
name|pd
operator|->
name|redirected
argument_list|(
operator|&
name|redirectionOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpd
condition|)
name|pd
operator|=
name|rpd
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::begin(), device=%p, type=%d\n"
argument_list|,
name|pd
argument_list|,
name|pd
operator|->
name|devType
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pd
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Pixmap
condition|)
cast|static_cast
argument_list|<
name|QPixmap
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
operator|->
name|detach
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Image
condition|)
cast|static_cast
argument_list|<
name|QImage
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
operator|->
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|engine
operator|=
name|pd
operator|->
name|paintEngine
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin: Paint device returned engine == 0, type: %d"
argument_list|,
name|pd
operator|->
name|devType
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|device
operator|=
name|pd
expr_stmt|;
name|d
operator|->
name|extended
operator|=
name|d
operator|->
name|engine
operator|->
name|isExtended
argument_list|()
condition|?
cast|static_cast
argument_list|<
name|QPaintEngineEx
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|engine
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|emulationEngine
condition|)
name|d
operator|->
name|emulationEngine
operator|->
name|real_engine
operator|=
name|d
operator|->
name|extended
expr_stmt|;
comment|// Setup new state...
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|extended
condition|?
name|d
operator|->
name|extended
operator|->
name|createState
argument_list|(
literal|0
argument_list|)
else|:
operator|new
name|QPainterState
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|painter
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|states
operator|.
name|push_back
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|redirectionMatrix
operator|.
name|translate
argument_list|(
operator|-
name|redirectionOffset
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|redirectionOffset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|brushOrigin
operator|=
name|QPointF
argument_list|()
expr_stmt|;
comment|// Slip a painter state into the engine before we do any other operations
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|setState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|engine
operator|->
name|state
operator|=
name|d
operator|->
name|state
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|devType
argument_list|()
condition|)
block|{
case|case
name|QInternal
operator|::
name|Pixmap
case|:
block|{
name|QPixmap
modifier|*
name|pm
init|=
cast|static_cast
argument_list|<
name|QPixmap
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin: Cannot paint on a null pixmap"
argument_list|)
expr_stmt|;
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|pm
operator|->
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|pen
operator|=
name|QPen
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|brush
operator|=
name|QBrush
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QInternal
operator|::
name|Image
case|:
block|{
name|QImage
modifier|*
name|img
init|=
cast|static_cast
argument_list|<
name|QImage
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|img
operator|->
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin: Cannot paint on a null image"
argument_list|)
expr_stmt|;
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|img
operator|->
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
comment|// Painting on indexed8 images is not supported.
name|qWarning
argument_list|(
literal|"QPainter::begin: Cannot paint on an image with the QImage::Format_Indexed8 format"
argument_list|)
expr_stmt|;
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|img
operator|->
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|pen
operator|=
name|QPen
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|brush
operator|=
name|QBrush
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|ww
operator|==
literal|0
condition|)
comment|// For compat with 3.x painter defaults
name|d
operator|->
name|state
operator|->
name|ww
operator|=
name|d
operator|->
name|state
operator|->
name|wh
operator|=
name|d
operator|->
name|state
operator|->
name|vw
operator|=
name|d
operator|->
name|state
operator|->
name|vh
operator|=
literal|1024
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|setPaintDevice
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|bool
name|begun
init|=
name|d
operator|->
name|engine
operator|->
name|begin
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|begun
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::begin(): Returned false"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
name|d
operator|->
name|engine
operator|->
name|setActive
argument_list|(
name|begun
argument_list|)
expr_stmt|;
block|}
comment|// Copy painter properties from original paint device,
comment|// required for QPixmap::grabWidget()
if|if
condition|(
name|d
operator|->
name|original_device
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|initFrom
argument_list|(
name|d
operator|->
name|original_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|state
operator|->
name|layoutDirection
operator|=
name|Qt
operator|::
name|LayoutDirectionAuto
expr_stmt|;
comment|// make sure we have a font compatible with the paintdevice
name|d
operator|->
name|state
operator|->
name|deviceFont
operator|=
name|d
operator|->
name|state
operator|->
name|font
operator|=
name|QFont
argument_list|(
name|d
operator|->
name|state
operator|->
name|deviceFont
argument_list|,
name|device
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QRect
name|systemRect
init|=
name|d
operator|->
name|engine
operator|->
name|systemRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|systemRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|ww
operator|=
name|d
operator|->
name|state
operator|->
name|vw
operator|=
name|systemRect
operator|.
name|width
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|wh
operator|=
name|d
operator|->
name|state
operator|->
name|vh
operator|=
name|systemRect
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|state
operator|->
name|ww
operator|=
name|d
operator|->
name|state
operator|->
name|vw
operator|=
name|pd
operator|->
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmWidth
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|wh
operator|=
name|d
operator|->
name|state
operator|->
name|vh
operator|=
name|pd
operator|->
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmHeight
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QPoint
name|coordinateOffset
init|=
name|d
operator|->
name|engine
operator|->
name|coordinateOffset
argument_list|()
decl_stmt|;
name|d
operator|->
name|state
operator|->
name|redirectionMatrix
operator|.
name|translate
argument_list|(
operator|-
name|coordinateOffset
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|coordinateOffset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|engine
operator|->
name|isActive
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|redirectionMatrix
operator|.
name|isIdentity
argument_list|()
operator|||
name|d
operator|->
name|effectiveDevicePixelRatio
argument_list|()
operator|>
literal|1
condition|)
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|engine
operator|->
name|isActive
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|renderHints
operator|=
name|QPainter
operator|::
name|TextAntialiasing
expr_stmt|;
operator|++
name|d
operator|->
name|device
operator|->
name|painters
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Ends painting. Any resources used while painting are released. You     don't normally need to call this since it is called by the     destructor.      Returns true if the painter is no longer active; otherwise returns false.      \sa begin(), isActive() */
end_comment
begin_function
DECL|function|end
name|bool
name|QPainter
operator|::
name|end
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::end()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::end: Painter not active, aborted"
argument_list|)
expr_stmt|;
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|refcount
operator|>
literal|1
condition|)
block|{
name|d
operator|->
name|detachPainterPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|bool
name|ended
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|ended
operator|=
name|d
operator|->
name|engine
operator|->
name|end
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|d
operator|->
name|device
operator|->
name|painters
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
operator|->
name|painters
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|setPaintDevice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|states
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::end: Painter ended with %d saved states"
argument_list|,
name|d
operator|->
name|states
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|engine
operator|->
name|autoDestruct
argument_list|()
condition|)
block|{
operator|delete
name|d
operator|->
name|engine
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|emulationEngine
condition|)
block|{
operator|delete
name|d
operator|->
name|emulationEngine
expr_stmt|;
name|d
operator|->
name|emulationEngine
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|=
literal|0
expr_stmt|;
block|}
name|qt_cleanup_painter_state
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|ended
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the paint engine that the painter is currently operating     on if the painter is active; otherwise 0.      \sa isActive() */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QPainter
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Flushes the painting pipeline and prepares for the user issuing commands     directly to the underlying graphics context. Must be followed by a call to     endNativePainting().      Note that only the states the underlying paint engine changes will be reset     to their respective default states. The states we reset may change from     release to release. The following states are currently reset in the OpenGL     2 engine:      \list     \li blending is disabled     \li the depth, stencil and scissor tests are disabled     \li the active texture unit is reset to 0     \li the depth mask, depth function and the clear depth are reset to their     default values     \li the stencil mask, stencil operation and stencil function are reset to     their default values      \li the current color is reset to solid white     \endlist      If, for example, the OpenGL polygon mode is changed by the user inside a     beginNativePaint()/endNativePainting() block, it will not be reset to the     default state by endNativePainting(). Here is an example that shows     intermixing of painter commands and raw OpenGL commands:      \snippet code/src_gui_painting_qpainter.cpp 21      \sa endNativePainting() */
end_comment
begin_function
DECL|function|beginNativePainting
name|void
name|QPainter
operator|::
name|beginNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::beginNativePainting: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|beginNativePainting
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Restores the painter after manually issuing native painting commands. Lets     the painter restore any native state that it relies on before calling any     other painter commands.      \sa beginNativePainting() */
end_comment
begin_function
DECL|function|endNativePainting
name|void
name|QPainter
operator|::
name|endNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::beginNativePainting: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|endNativePainting
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|engine
operator|->
name|syncState
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the font metrics for the painter if the painter is     active. Otherwise, the return value is undefined.      \sa font(), isActive(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|fontMetrics
name|QFontMetrics
name|QPainter
operator|::
name|fontMetrics
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::fontMetrics: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QFontMetrics
argument_list|(
name|QFont
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QFontMetrics
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the font info for the painter if the painter is     active. Otherwise, the return value is undefined.      \sa font(), isActive(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|fontInfo
name|QFontInfo
name|QPainter
operator|::
name|fontInfo
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::fontInfo: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QFontInfo
argument_list|(
name|QFont
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QFontInfo
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the opacity of the painter. The default value is     1. */
end_comment
begin_function
DECL|function|opacity
name|qreal
name|QPainter
operator|::
name|opacity
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::opacity: Painter not active"
argument_list|)
expr_stmt|;
return|return
literal|1.0
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|opacity
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the opacity of the painter to \a opacity. The value should     be in the range 0.0 to 1.0, where 0.0 is fully transparent and     1.0 is fully opaque.      Opacity set on the painter will apply to all drawing operations     individually. */
end_comment
begin_function
DECL|function|setOpacity
name|void
name|QPainter
operator|::
name|setOpacity
parameter_list|(
name|qreal
name|opacity
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setOpacity: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|opacity
operator|=
name|qMin
argument_list|(
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|opacity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opacity
operator|==
name|d
operator|->
name|state
operator|->
name|opacity
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|opacity
operator|=
name|opacity
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|opacityChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyOpacity
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently set brush origin.      \sa setBrushOrigin(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|brushOrigin
name|QPoint
name|QPainter
operator|::
name|brushOrigin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::brushOrigin: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QPoint
argument_list|()
return|;
block|}
return|return
name|QPointF
argument_list|(
name|d
operator|->
name|state
operator|->
name|brushOrigin
argument_list|)
operator|.
name|toPoint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setBrushOrigin(const QPointF&position)      Sets the brush origin to \a position.      The brush origin specifies the (0, 0) coordinate of the painter's     brush.      Note that while the brushOrigin() was necessary to adopt the     parent's background for a widget in Qt 3, this is no longer the     case since the Qt 4 painter doesn't paint the background unless     you explicitly tell it to do so by setting the widget's \l     {QWidget::autoFillBackground}{autoFillBackground} property to     true.      \sa brushOrigin(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setBrushOrigin
name|void
name|QPainter
operator|::
name|setBrushOrigin
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setBrushOrigin(), (%.2f,%.2f)\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setBrushOrigin: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|brushOrigin
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|brushOriginChanged
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyBrushOrigin
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setBrushOrigin(const QPoint&position)     \overload      Sets the brush's origin to the given \a position. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::setBrushOrigin(int x, int y)      \overload      Sets the brush's origin to point (\a x, \a y). */
end_comment
begin_comment
comment|/*!     \enum QPainter::CompositionMode      Defines the modes supported for digital image compositing.     Composition modes are used to specify how the pixels in one image,     the source, are merged with the pixel in another image, the     destination.      Please note that the bitwise raster operation modes, denoted with     a RasterOp prefix, are only natively supported in the X11 and     raster paint engines. This means that the only way to utilize     these modes on the Mac is via a QImage. The RasterOp denoted blend     modes are \e not supported for pens and brushes with alpha     components. Also, turning on the QPainter::Antialiasing render     hint will effectively disable the RasterOp modes.        \image qpainter-compositionmode1.png      \image qpainter-compositionmode2.png      The most common type is SourceOver (often referred to as just     alpha blending) where the source pixel is blended on top of the     destination pixel in such a way that the alpha component of the     source defines the translucency of the pixel.      When the paint device is a QImage, the image format must be set to     \l {QImage::Format}{Format_ARGB32_Premultiplied} or     \l {QImage::Format}{Format_ARGB32} for the composition modes to have     any effect. For performance the premultiplied version is the preferred     format.      When a composition mode is set it applies to all painting     operator, pens, brushes, gradients and pixmap/image drawing.      \value CompositionMode_SourceOver This is the default mode. The     alpha of the source is used to blend the pixel on top of the     destination.      \value CompositionMode_DestinationOver The alpha of the     destination is used to blend it on top of the source pixels. This     mode is the inverse of CompositionMode_SourceOver.      \value CompositionMode_Clear The pixels in the destination are     cleared (set to fully transparent) independent of the source.      \value CompositionMode_Source The output is the source     pixel. (This means a basic copy operation and is identical to     SourceOver when the source pixel is opaque).      \value CompositionMode_Destination The output is the destination     pixel. This means that the blending has no effect. This mode is     the inverse of CompositionMode_Source.      \value CompositionMode_SourceIn The output is the source, where     the alpha is reduced by that of the destination.      \value CompositionMode_DestinationIn The output is the     destination, where the alpha is reduced by that of the     source. This mode is the inverse of CompositionMode_SourceIn.      \value CompositionMode_SourceOut The output is the source, where     the alpha is reduced by the inverse of destination.      \value CompositionMode_DestinationOut The output is the     destination, where the alpha is reduced by the inverse of the     source. This mode is the inverse of CompositionMode_SourceOut.      \value CompositionMode_SourceAtop The source pixel is blended on     top of the destination, with the alpha of the source pixel reduced     by the alpha of the destination pixel.      \value CompositionMode_DestinationAtop The destination pixel is     blended on top of the source, with the alpha of the destination     pixel is reduced by the alpha of the destination pixel. This mode     is the inverse of CompositionMode_SourceAtop.      \value CompositionMode_Xor The source, whose alpha is reduced with     the inverse of the destination alpha, is merged with the     destination, whose alpha is reduced by the inverse of the source     alpha. CompositionMode_Xor is not the same as the bitwise Xor.      \value CompositionMode_Plus Both the alpha and color of the source     and destination pixels are added together.      \value CompositionMode_Multiply The output is the source color     multiplied by the destination. Multiplying a color with white     leaves the color unchanged, while multiplying a color     with black produces black.      \value CompositionMode_Screen The source and destination colors     are inverted and then multiplied. Screening a color with white     produces white, whereas screening a color with black leaves the     color unchanged.      \value CompositionMode_Overlay Multiplies or screens the colors     depending on the destination color. The destination color is mixed     with the source color to reflect the lightness or darkness of the     destination.      \value CompositionMode_Darken The darker of the source and     destination colors is selected.      \value CompositionMode_Lighten The lighter of the source and     destination colors is selected.      \value CompositionMode_ColorDodge The destination color is     brightened to reflect the source color. A black source color     leaves the destination color unchanged.      \value CompositionMode_ColorBurn The destination color is darkened     to reflect the source color. A white source color leaves the     destination color unchanged.      \value CompositionMode_HardLight Multiplies or screens the colors     depending on the source color. A light source color will lighten     the destination color, whereas a dark source color will darken the     destination color.      \value CompositionMode_SoftLight Darkens or lightens the colors     depending on the source color. Similar to     CompositionMode_HardLight.      \value CompositionMode_Difference Subtracts the darker of the     colors from the lighter.  Painting with white inverts the     destination color, whereas painting with black leaves the     destination color unchanged.      \value CompositionMode_Exclusion Similar to     CompositionMode_Difference, but with a lower contrast. Painting     with white inverts the destination color, whereas painting with     black leaves the destination color unchanged.      \value RasterOp_SourceOrDestination Does a bitwise OR operation on     the source and destination pixels (src OR dst).      \value RasterOp_SourceAndDestination Does a bitwise AND operation     on the source and destination pixels (src AND dst).      \value RasterOp_SourceXorDestination Does a bitwise XOR operation     on the source and destination pixels (src XOR dst).      \value RasterOp_NotSourceAndNotDestination Does a bitwise NOR     operation on the source and destination pixels ((NOT src) AND (NOT     dst)).      \value RasterOp_NotSourceOrNotDestination Does a bitwise NAND     operation on the source and destination pixels ((NOT src) OR (NOT     dst)).      \value RasterOp_NotSourceXorDestination Does a bitwise operation     where the source pixels are inverted and then XOR'ed with the     destination ((NOT src) XOR dst).      \value RasterOp_NotSource Does a bitwise operation where the     source pixels are inverted (NOT src).      \value RasterOp_NotSourceAndDestination Does a bitwise operation     where the source is inverted and then AND'ed with the destination     ((NOT src) AND dst).      \value RasterOp_SourceAndNotDestination Does a bitwise operation     where the source is AND'ed with the inverted destination pixels     (src AND (NOT dst)).      \value RasterOp_NotSourceOrDestination Does a bitwise operation     where the source is inverted and then OR'ed with the destination     ((NOT src) OR dst).      \value RasterOp_ClearDestination The pixels in the destination are     cleared (set to 0) independent of the source.      \value RasterOp_SetDestination The pixels in the destination are     set (set to 1) independent of the source.      \value RasterOp_NotDestination Does a bitwise operation     where the destination pixels are inverted (NOT dst).      \value RasterOp_SourceOrNotDestination Does a bitwise operation     where the source is OR'ed with the inverted destination pixels     (src OR (NOT dst)).      \sa compositionMode(), setCompositionMode(), {QPainter#Composition     Modes}{Composition Modes}, {Image Composition Example} */
end_comment
begin_comment
comment|/*!     Sets the composition mode to the given \a mode.      \warning Only a QPainter operating on a QImage fully supports all     composition modes. The RasterOp modes are supported for X11 as     described in compositionMode().      \sa compositionMode() */
end_comment
begin_function
DECL|function|setCompositionMode
name|void
name|QPainter
operator|::
name|setCompositionMode
parameter_list|(
name|CompositionMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setCompositionMode: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|composition_mode
operator|==
name|mode
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|composition_mode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|compositionModeChanged
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mode
operator|>=
name|QPainter
operator|::
name|RasterOp_SourceOrDestination
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|RasterOpModes
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setCompositionMode: "
literal|"Raster operation modes not supported on device"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|>=
name|QPainter
operator|::
name|CompositionMode_Plus
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|BlendModes
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setCompositionMode: "
literal|"Blend modes not supported on device"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PorterDuff
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|CompositionMode_Source
operator|&&
name|mode
operator|!=
name|CompositionMode_SourceOver
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setCompositionMode: "
literal|"PorterDuff modes not supported on device"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|state
operator|->
name|composition_mode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyCompositionMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the current composition mode.    \sa CompositionMode, setCompositionMode() */
end_comment
begin_function
DECL|function|compositionMode
name|QPainter
operator|::
name|CompositionMode
name|QPainter
operator|::
name|compositionMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::compositionMode: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QPainter
operator|::
name|CompositionMode_SourceOver
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|composition_mode
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current background brush.      \sa setBackground(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|background
specifier|const
name|QBrush
modifier|&
name|QPainter
operator|::
name|background
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::background: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|brush
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|bgBrush
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if clipping has been set; otherwise returns false.      \sa setClipping(), {QPainter#Clipping}{Clipping} */
end_comment
begin_function
DECL|function|hasClipping
name|bool
name|QPainter
operator|::
name|hasClipping
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::hasClipping: Painter not active"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|&&
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|!=
name|Qt
operator|::
name|NoClip
return|;
block|}
end_function
begin_comment
comment|/*!     Enables clipping if  \a enable is true, or disables clipping if  \a     enable is false.      \sa hasClipping(), {QPainter#Clipping}{Clipping} */
end_comment
begin_function
DECL|function|setClipping
name|void
name|QPainter
operator|::
name|setClipping
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setClipping(), enable=%s, was=%s\n"
argument_list|,
name|enable
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|hasClipping
argument_list|()
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setClipping: Painter not active, state will be reset by begin"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hasClipping
argument_list|()
operator|==
name|enable
condition|)
return|return;
comment|// we can't enable clipping if we don't have a clip
if|if
condition|(
name|enable
operator|&&
operator|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|last
argument_list|()
operator|.
name|operation
operator|==
name|Qt
operator|::
name|NoClip
operator|)
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
name|enable
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|clipEnabledChanged
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyClipEnabled
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently set clip region. Note that the clip region     is given in logical coordinates.      \warning QPainter does not store the combined clip explicitly as     this is handled by the underlying QPaintEngine, so the path is     recreated on demand and transformed to the current logical     coordinate system. This is potentially an expensive operation.      \sa setClipRegion(), clipPath(), setClipping() */
end_comment
begin_function
DECL|function|clipRegion
name|QRegion
name|QPainter
operator|::
name|clipRegion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::clipRegion: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QRegion
argument_list|()
return|;
block|}
name|QRegion
name|region
decl_stmt|;
name|bool
name|lastWasNothing
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|txinv
condition|)
cast|const_cast
argument_list|<
name|QPainter
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_ptr
operator|->
name|updateInvMatrix
argument_list|()
expr_stmt|;
comment|// ### Falcon: Use QPainterPath
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPainterClipInfo
modifier|&
name|info
init|=
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|info
operator|.
name|clipType
condition|)
block|{
case|case
name|QPainterClipInfo
operator|::
name|RegionClip
case|:
block|{
name|QTransform
name|matrix
init|=
operator|(
name|info
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
if|if
condition|(
name|lastWasNothing
condition|)
block|{
name|region
operator|=
name|info
operator|.
name|region
operator|*
name|matrix
expr_stmt|;
name|lastWasNothing
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
name|region
operator|&=
name|info
operator|.
name|region
operator|*
name|matrix
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|lastWasNothing
operator|=
literal|true
expr_stmt|;
name|region
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
else|else
name|region
operator|=
name|info
operator|.
name|region
operator|*
name|matrix
expr_stmt|;
break|break;
block|}
case|case
name|QPainterClipInfo
operator|::
name|PathClip
case|:
block|{
name|QTransform
name|matrix
init|=
operator|(
name|info
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
if|if
condition|(
name|lastWasNothing
condition|)
block|{
name|region
operator|=
name|QRegion
argument_list|(
operator|(
name|info
operator|.
name|path
operator|*
name|matrix
operator|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
argument_list|,
name|info
operator|.
name|path
operator|.
name|fillRule
argument_list|()
argument_list|)
expr_stmt|;
name|lastWasNothing
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
block|{
name|region
operator|&=
name|QRegion
argument_list|(
operator|(
name|info
operator|.
name|path
operator|*
name|matrix
operator|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
argument_list|,
name|info
operator|.
name|path
operator|.
name|fillRule
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|lastWasNothing
operator|=
literal|true
expr_stmt|;
name|region
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|region
operator|=
name|QRegion
argument_list|(
operator|(
name|info
operator|.
name|path
operator|*
name|matrix
operator|)
operator|.
name|toFillPolygon
argument_list|()
operator|.
name|toPolygon
argument_list|()
argument_list|,
name|info
operator|.
name|path
operator|.
name|fillRule
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QPainterClipInfo
operator|::
name|RectClip
case|:
block|{
name|QTransform
name|matrix
init|=
operator|(
name|info
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
if|if
condition|(
name|lastWasNothing
condition|)
block|{
name|region
operator|=
name|QRegion
argument_list|(
name|info
operator|.
name|rect
argument_list|)
operator|*
name|matrix
expr_stmt|;
name|lastWasNothing
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
block|{
comment|// Use rect intersection if possible.
if|if
condition|(
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
name|region
operator|&=
name|matrix
operator|.
name|mapRect
argument_list|(
name|info
operator|.
name|rect
argument_list|)
expr_stmt|;
else|else
name|region
operator|&=
name|matrix
operator|.
name|map
argument_list|(
name|QRegion
argument_list|(
name|info
operator|.
name|rect
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|lastWasNothing
operator|=
literal|true
expr_stmt|;
name|region
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|region
operator|=
name|QRegion
argument_list|(
name|info
operator|.
name|rect
argument_list|)
operator|*
name|matrix
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QPainterClipInfo
operator|::
name|RectFClip
case|:
block|{
name|QTransform
name|matrix
init|=
operator|(
name|info
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
if|if
condition|(
name|lastWasNothing
condition|)
block|{
name|region
operator|=
name|QRegion
argument_list|(
name|info
operator|.
name|rectf
operator|.
name|toRect
argument_list|()
argument_list|)
operator|*
name|matrix
expr_stmt|;
name|lastWasNothing
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
block|{
comment|// Use rect intersection if possible.
if|if
condition|(
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
name|region
operator|&=
name|matrix
operator|.
name|mapRect
argument_list|(
name|info
operator|.
name|rectf
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|region
operator|&=
name|matrix
operator|.
name|map
argument_list|(
name|QRegion
argument_list|(
name|info
operator|.
name|rectf
operator|.
name|toRect
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|lastWasNothing
operator|=
literal|true
expr_stmt|;
name|region
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|region
operator|=
name|QRegion
argument_list|(
name|info
operator|.
name|rectf
operator|.
name|toRect
argument_list|()
argument_list|)
operator|*
name|matrix
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|region
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     Returns the currently clip as a path. Note that the clip path is     given in logical coordinates.      \warning QPainter does not store the combined clip explicitly as     this is handled by the underlying QPaintEngine, so the path is     recreated on demand and transformed to the current logical     coordinate system. This is potentially an expensive operation.      \sa setClipPath(), clipRegion(), setClipping() */
end_comment
begin_function
DECL|function|clipPath
name|QPainterPath
name|QPainter
operator|::
name|clipPath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
comment|// ### Since we do not support path intersections and path unions yet,
comment|// we just use clipRegion() here...
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::clipPath: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QPainterPath
argument_list|()
return|;
block|}
comment|// No clip, return empty
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|QPainterPath
argument_list|()
return|;
block|}
else|else
block|{
comment|// Update inverse matrix, used below.
if|if
condition|(
operator|!
name|d
operator|->
name|txinv
condition|)
cast|const_cast
argument_list|<
name|QPainter
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_ptr
operator|->
name|updateInvMatrix
argument_list|()
expr_stmt|;
comment|// For the simple case avoid conversion.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|PathClip
condition|)
block|{
name|QTransform
name|matrix
init|=
operator|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
return|return
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|path
operator|*
name|matrix
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RectClip
condition|)
block|{
name|QTransform
name|matrix
init|=
operator|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|matrix
operator|*
name|d
operator|->
name|invMatrix
operator|)
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|rect
argument_list|)
expr_stmt|;
return|return
name|path
operator|*
name|matrix
return|;
block|}
else|else
block|{
comment|// Fallback to clipRegion() for now, since we don't have isect/unite for paths
return|return
name|qt_regionToPath
argument_list|(
name|clipRegion
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of the current clip if there is a clip;     otherwise returns an empty rectangle. Note that the clip region is     given in logical coordinates.      The bounding rectangle is not guaranteed to be tight.      \sa setClipRect(), setClipPath(), setClipRegion()      \since 4.8  */
end_comment
begin_function
DECL|function|clipBoundingRect
name|QRectF
name|QPainter
operator|::
name|clipBoundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::clipBoundingRect: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|()
return|;
block|}
comment|// Accumulate the bounding box in device space. This is not 100%
comment|// precise, but it fits within the guarantee and it is reasonably
comment|// fast.
name|QRectF
name|bounds
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|r
decl_stmt|;
specifier|const
name|QPainterClipInfo
modifier|&
name|info
init|=
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RectClip
condition|)
name|r
operator|=
name|info
operator|.
name|rect
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RectFClip
condition|)
name|r
operator|=
name|info
operator|.
name|rectf
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|clipType
operator|==
name|QPainterClipInfo
operator|::
name|RegionClip
condition|)
name|r
operator|=
name|info
operator|.
name|region
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
else|else
name|r
operator|=
name|info
operator|.
name|path
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|r
operator|=
name|info
operator|.
name|matrix
operator|.
name|mapRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|bounds
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|operation
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
name|bounds
operator|&=
name|r
expr_stmt|;
block|}
comment|// Map the rectangle back into logical space using the inverse
comment|// matrix.
if|if
condition|(
operator|!
name|d
operator|->
name|txinv
condition|)
cast|const_cast
argument_list|<
name|QPainter
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_ptr
operator|->
name|updateInvMatrix
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|invMatrix
operator|.
name|mapRect
argument_list|(
name|bounds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setClipRect(const QRectF&rectangle, Qt::ClipOperation operation)      Enables clipping, and sets the clip region to the given \a     rectangle using the given clip \a operation. The default operation     is to replace the current clip rectangle.      Note that the clip rectangle is specified in logical (painter)     coordinates.      \sa clipRegion(), setClipping(), {QPainter#Clipping}{Clipping} */
end_comment
begin_function
DECL|function|setClipRect
name|void
name|QPainter
operator|::
name|setClipRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|&&
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|)
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setClipRect: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|qreal
name|right
init|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|pts
index|[]
init|=
block|{
name|rect
operator|.
name|x
argument_list|()
block|,
name|rect
operator|.
name|y
argument_list|()
block|,
name|right
block|,
name|rect
operator|.
name|y
argument_list|()
block|,
name|right
block|,
name|bottom
block|,
name|rect
operator|.
name|x
argument_list|()
block|,
name|bottom
block|}
decl_stmt|;
name|QVectorPath
name|vp
argument_list|(
name|pts
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|QVectorPath
operator|::
name|RectangleHint
argument_list|)
decl_stmt|;
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|clip
argument_list|(
name|vp
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|NoClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|rect
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qreal
argument_list|(
name|int
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
operator|==
name|rect
operator|.
name|top
argument_list|()
operator|&&
name|qreal
argument_list|(
name|int
argument_list|(
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
operator|==
name|rect
operator|.
name|bottom
argument_list|()
operator|&&
name|qreal
argument_list|(
name|int
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
operator|==
name|rect
operator|.
name|left
argument_list|()
operator|&&
name|qreal
argument_list|(
name|int
argument_list|(
name|rect
operator|.
name|right
argument_list|()
argument_list|)
argument_list|)
operator|==
name|rect
operator|.
name|right
argument_list|()
condition|)
block|{
name|setClipRect
argument_list|(
name|rect
operator|.
name|toRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setClipRegion
argument_list|(
name|QRegion
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|setClipPath
argument_list|(
name|path
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setClipRect(const QRect&rectangle, Qt::ClipOperation operation)     \overload      Enables clipping, and sets the clip region to the given \a rectangle using the given     clip \a operation. */
end_comment
begin_function
DECL|function|setClipRect
name|void
name|QPainter
operator|::
name|setClipRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setClipRect: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|&&
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|)
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|clip
argument_list|(
name|rect
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|NoClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|rect
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|==
name|Qt
operator|::
name|NoClip
operator|&&
name|op
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipRegion
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|rect
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyClipEnabled
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setClipRect(int x, int y, int width, int height, Qt::ClipOperation operation)      Enables clipping, and sets the clip region to the rectangle beginning at (\a x, \a y)     with the given \a width and \a height. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::setClipRegion(const QRegion&region, Qt::ClipOperation operation)      Sets the clip region to the given \a region using the specified clip     \a operation. The default clip operation is to replace the current     clip region.      Note that the clip region is given in logical coordinates.      \sa clipRegion(), setClipRect(), {QPainter#Clipping}{Clipping} */
end_comment
begin_function
DECL|function|setClipRegion
name|void
name|QPainter
operator|::
name|setClipRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|r
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
name|QRect
name|rect
init|=
name|r
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setClipRegion(), size=%d, [%d,%d,%d,%d]\n"
argument_list|,
name|r
operator|.
name|rects
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setClipRegion: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|&&
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|)
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|clip
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|r
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|==
name|Qt
operator|::
name|NoClip
operator|&&
name|op
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipRegion
operator|=
name|r
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|r
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyClipEnabled
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \obsolete      Sets the transformation matrix to \a matrix and enables transformations.      \note It is advisable to use setWorldTransform() instead of this function to     preserve the properties of perspective transformations.      If \a combine is true, then \a matrix is combined with the current     transformation matrix; otherwise \a matrix replaces the current     transformation matrix.      If \a matrix is the identity matrix and \a combine is false, this     function calls setWorldMatrixEnabled(false). (The identity matrix is the     matrix where QMatrix::m11() and QMatrix::m22() are 1.0 and the     rest are 0.0.)      The following functions can transform the coordinate system without using     a QMatrix:     \list     \li translate()     \li scale()     \li shear()     \li rotate()     \endlist      They operate on the painter's worldMatrix() and are implemented like this:      \snippet code/src_gui_painting_qpainter.cpp 4      Note that when using setWorldMatrix() function you should always have     \a combine be true when you are drawing into a QPicture. Otherwise     it may not be possible to replay the picture with additional     transformations; using the translate(), scale(), etc. convenience     functions is safe.      For more information about the coordinate system, transformations     and window-viewport conversion, see \l {Coordinate System}.      \sa setWorldTransform(), QTransform */
end_comment
begin_function
DECL|function|setWorldMatrix
name|void
name|QPainter
operator|::
name|setWorldMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|setWorldTransform
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|combine
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \obsolete      Returns the world transformation matrix.      It is advisable to use worldTransform() because worldMatrix() does not     preserve the properties of perspective transformations.      \sa {QPainter#Coordinate Transformations}{Coordinate Transformations},     {Coordinate System} */
end_comment
begin_function
DECL|function|worldMatrix
specifier|const
name|QMatrix
modifier|&
name|QPainter
operator|::
name|worldMatrix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::worldMatrix: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|transform
operator|.
name|toAffine
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setWorldTransform() instead.      \sa setWorldTransform() */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QPainter
operator|::
name|setMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|setWorldTransform
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|combine
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use worldTransform() instead.      \sa worldTransform() */
end_comment
begin_function
DECL|function|matrix
specifier|const
name|QMatrix
modifier|&
name|QPainter
operator|::
name|matrix
parameter_list|()
specifier|const
block|{
return|return
name|worldMatrix
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \obsolete      Returns the transformation matrix combining the current     window/viewport and world transformation.      It is advisable to use combinedTransform() instead of this     function to preserve the properties of perspective transformations.      \sa setWorldTransform(), setWindow(), setViewport() */
end_comment
begin_function
DECL|function|combinedMatrix
name|QMatrix
name|QPainter
operator|::
name|combinedMatrix
parameter_list|()
specifier|const
block|{
return|return
name|combinedTransform
argument_list|()
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns the matrix that transforms from logical coordinates to     device coordinates of the platform dependent paint device.      \note It is advisable to use deviceTransform() instead of this     function to preserve the properties of perspective transformations.      This function is \e only needed when using platform painting     commands on the platform dependent handle (Qt::HANDLE), and the     platform does not do transformations nativly.      The QPaintEngine::PaintEngineFeature enum can be queried to     determine whether the platform performs the transformations or     not.      \sa worldMatrix(), QPaintEngine::hasFeature(), */
end_comment
begin_function
DECL|function|deviceMatrix
specifier|const
name|QMatrix
modifier|&
name|QPainter
operator|::
name|deviceMatrix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::deviceMatrix: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|transform
operator|.
name|toAffine
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Resets any transformations that were made using translate(), scale(),     shear(), rotate(), setWorldMatrix(), setViewport() and     setWindow().      It is advisable to use resetTransform() instead of this function     to preserve the properties of perspective transformations.      \sa {QPainter#Coordinate Transformations}{Coordinate     Transformations} */
end_comment
begin_function
DECL|function|resetMatrix
name|void
name|QPainter
operator|::
name|resetMatrix
parameter_list|()
block|{
name|resetTransform
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Enables transformations if \a enable is true, or disables     transformations if \a enable is false. The world transformation     matrix is not changed.      \sa worldMatrixEnabled(), worldTransform(), {QPainter#Coordinate     Transformations}{Coordinate Transformations} */
end_comment
begin_function
DECL|function|setWorldMatrixEnabled
name|void
name|QPainter
operator|::
name|setWorldMatrixEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setMatrixEnabled(), enable=%d\n"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setMatrixEnabled: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|enable
operator|==
name|d
operator|->
name|state
operator|->
name|WxF
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
name|enable
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if world transformation is enabled; otherwise returns     false.      \sa setWorldMatrixEnabled(), worldTransform(), {Coordinate System} */
end_comment
begin_function
DECL|function|worldMatrixEnabled
name|bool
name|QPainter
operator|::
name|worldMatrixEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::worldMatrixEnabled: Painter not active"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|WxF
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setWorldMatrixEnabled() instead.      \sa setWorldMatrixEnabled() */
end_comment
begin_function
DECL|function|setMatrixEnabled
name|void
name|QPainter
operator|::
name|setMatrixEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setWorldMatrixEnabled
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use worldMatrixEnabled() instead      \sa worldMatrixEnabled() */
end_comment
begin_function
DECL|function|matrixEnabled
name|bool
name|QPainter
operator|::
name|matrixEnabled
parameter_list|()
specifier|const
block|{
return|return
name|worldMatrixEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Scales the coordinate system by (\a{sx}, \a{sy}).      \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations} */
end_comment
begin_function
DECL|function|scale
name|void
name|QPainter
operator|::
name|scale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::scale(), sx=%f, sy=%f\n"
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::scale: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|.
name|scale
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shears the coordinate system by (\a{sh}, \a{sv}).      \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations} */
end_comment
begin_function
DECL|function|shear
name|void
name|QPainter
operator|::
name|shear
parameter_list|(
name|qreal
name|sh
parameter_list|,
name|qreal
name|sv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::shear(), sh=%f, sv=%f\n"
argument_list|,
name|sh
argument_list|,
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::shear: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|.
name|shear
argument_list|(
name|sh
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::rotate(qreal angle)      Rotates the coordinate system clockwise. The given \a angle parameter uses degree unit.      \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations} */
end_comment
begin_function
DECL|function|rotate
name|void
name|QPainter
operator|::
name|rotate
parameter_list|(
name|qreal
name|a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::rotate(), angle=%f\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::rotate: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|.
name|rotate
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Translates the coordinate system by the given \a offset; i.e. the     given \a offset is added to points.      \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations} */
end_comment
begin_function
DECL|function|translate
name|void
name|QPainter
operator|::
name|translate
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|offset
parameter_list|)
block|{
name|qreal
name|dx
init|=
name|offset
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
name|offset
operator|.
name|y
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::translate(), dx=%f, dy=%f\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::translate: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::translate(const QPoint&offset)     \overload      Translates the coordinate system by the given \a offset. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::translate(qreal dx, qreal dy)     \overload      Translates the coordinate system by the vector (\a dx, \a dy). */
end_comment
begin_comment
comment|/*!     \fn void QPainter::setClipPath(const QPainterPath&path, Qt::ClipOperation operation)      Enables clipping, and sets the clip path for the painter to the     given \a path, with the clip \a operation.      Note that the clip path is specified in logical (painter)     coordinates.      \sa clipPath(), clipRegion(), {QPainter#Clipping}{Clipping}  */
end_comment
begin_function
DECL|function|setClipPath
name|void
name|QPainter
operator|::
name|setClipPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
block|{
name|QRectF
name|b
init|=
name|path
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"QPainter::setClipPath(), size=%d, op=%d, bounds=[%.2f,%.2f,%.2f,%.2f]\n"
argument_list|,
name|path
operator|.
name|elementCount
argument_list|()
argument_list|,
name|op
argument_list|,
name|b
operator|.
name|x
argument_list|()
argument_list|,
name|b
operator|.
name|y
argument_list|()
argument_list|,
name|b
operator|.
name|width
argument_list|()
argument_list|,
name|b
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setClipPath: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|&&
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|)
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|clip
argument_list|(
name|path
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|path
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|==
name|Qt
operator|::
name|NoClip
operator|&&
name|op
operator|==
name|Qt
operator|::
name|IntersectClip
condition|)
name|op
operator|=
name|Qt
operator|::
name|ReplaceClip
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipPath
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipOperation
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
operator|||
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipInfo
operator|<<
name|QPainterClipInfo
argument_list|(
name|path
argument_list|,
name|op
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyClipEnabled
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the outline (strokes) the path \a path with the pen specified     by \a pen      \sa fillPath(), {QPainter#Drawing}{Drawing} */
end_comment
begin_function
DECL|function|strokePath
name|void
name|QPainter
operator|::
name|strokePath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::strokePath: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|qpen_brush
argument_list|(
name|pen
argument_list|)
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
name|g
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|LogicalMode
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|stroke
argument_list|(
name|qtVectorPathForPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|pen
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QBrush
name|oldBrush
init|=
name|d
operator|->
name|state
operator|->
name|brush
decl_stmt|;
name|QPen
name|oldPen
init|=
name|d
operator|->
name|state
operator|->
name|pen
decl_stmt|;
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// Reset old state
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Fills the given \a path using the given \a brush. The outline is     not drawn.      Alternatively, you can specify a QColor instead of a QBrush; the     QBrush constructor (taking a QColor argument) will automatically     create a solid pattern brush.      \sa drawPath() */
end_comment
begin_function
DECL|function|fillPath
name|void
name|QPainter
operator|::
name|fillPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::fillPath: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
name|g
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|LogicalMode
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|fill
argument_list|(
name|qtVectorPathForPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|brush
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QBrush
name|oldBrush
init|=
name|d
operator|->
name|state
operator|->
name|brush
decl_stmt|;
name|QPen
name|oldPen
init|=
name|d
operator|->
name|state
operator|->
name|pen
decl_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// Reset old state
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the given painter \a path using the current pen for outline     and the current brush for filling.      \table 100%     \row     \li \inlineimage qpainter-path.png     \li     \snippet code/src_gui_painting_qpainter.cpp 5     \endtable      \sa {painting/painterpaths}{the Painter Paths     example},{painting/deform}{the Vector Deformation example} */
end_comment
begin_function
DECL|function|drawPath
name|void
name|QPainter
operator|::
name|drawPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
name|QRectF
name|pathBounds
init|=
name|path
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPath(), size=%d, [%.2f,%.2f,%.2f,%.2f]\n"
argument_list|,
name|path
operator|.
name|elementCount
argument_list|()
argument_list|,
name|pathBounds
operator|.
name|x
argument_list|()
argument_list|,
name|pathBounds
operator|.
name|y
argument_list|()
argument_list|,
name|pathBounds
operator|.
name|width
argument_list|()
argument_list|,
name|pathBounds
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::drawPath: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PainterPaths
argument_list|)
operator|&&
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawLine(const QLineF&line)      Draws a line defined by \a line.      \table 100%     \row     \li \inlineimage qpainter-line.png     \li     \snippet code/src_gui_painting_qpainter.cpp 6     \endtable      \sa drawLines(), drawPolyline(), {Coordinate System} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLine(const QLine&line)     \overload      Draws a line defined by \a line. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLine(const QPoint&p1, const QPoint&p2)     \overload      Draws a line from \a p1 to \a p2. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLine(const QPointF&p1, const QPointF&p2)     \overload      Draws a line from \a p1 to \a p2. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLine(int x1, int y1, int x2, int y2)     \overload      Draws a line from (\a x1, \a y1) to (\a x2, \a y2) and sets the     current pen position to (\a x2, \a y2). */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRect(const QRectF&rectangle)      Draws the current \a rectangle with the current pen and brush.      A filled rectangle has a size of \a{rectangle}.size(). A stroked     rectangle has a size of \a{rectangle}.size() plus the pen width.      \table 100%     \row     \li \inlineimage qpainter-rectangle.png     \li     \snippet code/src_gui_painting_qpainter.cpp 7     \endtable      \sa drawRects(), drawPolygon(), {Coordinate System} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRect(const QRect&rectangle)      \overload      Draws the current \a rectangle with the current pen and brush. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRect(int x, int y, int width, int height)      \overload      Draws a rectangle with upper left corner at (\a{x}, \a{y}) and     with the given \a width and \a height. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRects(const QRectF *rectangles, int rectCount)      Draws the first \a rectCount of the given \a rectangles using the     current pen and brush.      \sa drawRect() */
end_comment
begin_function
DECL|function|drawRects
name|void
name|QPainter
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRectF
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawRects(), count=%d\n"
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::drawRects: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rectCount
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|r
argument_list|(
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawRects
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|brushNeedsResolving
argument_list|()
operator|||
name|d
operator|->
name|state
operator|->
name|penNeedsResolving
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
name|rectPath
decl_stmt|;
name|rectPath
operator|.
name|addRect
argument_list|(
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|rectPath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPainterPath
name|rectPath
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
name|rectPath
operator|.
name|addRect
argument_list|(
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|rectPath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawRects(const QRect *rectangles, int rectCount)     \overload      Draws the first \a rectCount of the given \a rectangles using the     current pen and brush. */
end_comment
begin_function
DECL|function|drawRects
name|void
name|QPainter
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawRects(), count=%d\n"
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::drawRects: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rectCount
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|r
argument_list|(
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawRects
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|brushNeedsResolving
argument_list|()
operator|||
name|d
operator|->
name|state
operator|->
name|penNeedsResolving
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
block|{
name|QPainterPath
name|rectPath
decl_stmt|;
name|rectPath
operator|.
name|addRect
argument_list|(
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|rectPath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPainterPath
name|rectPath
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
control|)
name|rectPath
operator|.
name|addRect
argument_list|(
name|rects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|rectPath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawRects(const QVector<QRectF>&rectangles)     \overload      Draws the given \a rectangles using the current pen and brush. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRects(const QVector<QRect>&rectangles)      \overload      Draws the given \a rectangles using the current pen and brush. */
end_comment
begin_comment
comment|/*!   \fn void QPainter::drawPoint(const QPointF&position)      Draws a single point at the given \a position using the current     pen's color.      \sa {Coordinate System} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPoint(const QPoint&position)     \overload      Draws a single point at the given \a position using the current     pen's color. */
end_comment
begin_comment
comment|/*! \fn void QPainter::drawPoint(int x, int y)      \overload      Draws a single point at position (\a x, \a y). */
end_comment
begin_comment
comment|/*!     Draws the first \a pointCount points in the array \a points using     the current pen's color.      \sa {Coordinate System} */
end_comment
begin_function
DECL|function|drawPoints
name|void
name|QPainter
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPoints(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::drawPoints: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pointCount
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
comment|// ### use drawPoints function
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pt
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawPoints
argument_list|(
operator|&
name|pt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPen
name|pen
init|=
name|d
operator|->
name|state
operator|->
name|pen
decl_stmt|;
name|bool
name|flat_pen
init|=
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|FlatCap
decl_stmt|;
if|if
condition|(
name|flat_pen
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
name|pen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|SquareCap
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
name|QPainterPath
name|path
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|path
operator|.
name|moveTo
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
literal|0.0001
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
if|if
condition|(
name|flat_pen
condition|)
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Draws the first \a pointCount points in the array \a points using     the current pen's color. */
end_comment
begin_function
DECL|function|drawPoints
name|void
name|QPainter
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPoints(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::drawPoints: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pointCount
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
name|d
operator|->
name|engine
operator|->
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
comment|// ### use drawPoints function
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|pt
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawPoints
argument_list|(
operator|&
name|pt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPen
name|pen
init|=
name|d
operator|->
name|state
operator|->
name|pen
decl_stmt|;
name|bool
name|flat_pen
init|=
operator|(
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|FlatCap
operator|)
decl_stmt|;
if|if
condition|(
name|flat_pen
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
name|pen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|SquareCap
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
name|QPainterPath
name|path
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
block|{
name|path
operator|.
name|moveTo
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|()
operator|+
literal|0.0001
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
if|if
condition|(
name|flat_pen
condition|)
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPoints(const QPolygonF&points)      \overload      Draws the points in the vector  \a points. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPoints(const QPolygon&points)      \overload      Draws the points in the vector  \a points. */
end_comment
begin_comment
comment|/*!     Sets the background mode of the painter to the given \a mode      Qt::TransparentMode (the default) draws stippled lines and text     without setting the background pixels.  Qt::OpaqueMode fills these     space with the current background color.      Note that in order to draw a bitmap or pixmap transparently, you     must use QPixmap::setMask().      \sa backgroundMode(), setBackground(),     {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setBackgroundMode
name|void
name|QPainter
operator|::
name|setBackgroundMode
parameter_list|(
name|Qt
operator|::
name|BGMode
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setBackgroundMode(), mode=%d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setBackgroundMode: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|bgMode
operator|==
name|mode
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|bgMode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|checkEmulation
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyBackgroundMode
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the current background mode.      \sa setBackgroundMode(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|backgroundMode
name|Qt
operator|::
name|BGMode
name|QPainter
operator|::
name|backgroundMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::backgroundMode: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|Qt
operator|::
name|TransparentMode
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|bgMode
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the painter's pen to have style Qt::SolidLine, width 0 and the     specified \a color. */
end_comment
begin_function
DECL|function|setPen
name|void
name|QPainter
operator|::
name|setPen
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setPen(), color=%04x\n"
argument_list|,
name|color
operator|.
name|rgb
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setPen: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPen
name|pen
argument_list|(
name|color
operator|.
name|isValid
argument_list|()
condition|?
name|color
else|:
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|pen
operator|==
name|pen
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|penChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyPen
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the painter's pen to be the given \a pen.      The \a pen defines how to draw lines and outlines, and it also     defines the text color.      \sa pen(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setPen
name|void
name|QPainter
operator|::
name|setPen
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setPen(), color=%04x, (brushStyle=%d) style=%d, cap=%d, join=%d\n"
argument_list|,
name|pen
operator|.
name|color
argument_list|()
operator|.
name|rgb
argument_list|()
argument_list|,
name|pen
operator|.
name|brush
argument_list|()
operator|.
name|style
argument_list|()
argument_list|,
name|pen
operator|.
name|style
argument_list|()
argument_list|,
name|pen
operator|.
name|capStyle
argument_list|()
argument_list|,
name|pen
operator|.
name|joinStyle
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setPen: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|pen
operator|==
name|pen
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|checkEmulation
argument_list|()
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|penChanged
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyPen
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the painter's pen to have the given \a style, width 1 and     black color. */
end_comment
begin_function
DECL|function|setPen
name|void
name|QPainter
operator|::
name|setPen
parameter_list|(
name|Qt
operator|::
name|PenStyle
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setPen: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPen
name|pen
init|=
name|QPen
argument_list|(
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|pen
operator|==
name|pen
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|penChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyPen
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the painter's current pen.      \sa setPen(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|pen
specifier|const
name|QPen
modifier|&
name|QPainter
operator|::
name|pen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::pen: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|pen
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|pen
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the painter's brush to the given \a brush.      The painter's brush defines how shapes are filled.      \sa brush(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setBrush
name|void
name|QPainter
operator|::
name|setBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setBrush(), color=%04x, style=%d\n"
argument_list|,
name|brush
operator|.
name|color
argument_list|()
operator|.
name|rgb
argument_list|()
argument_list|,
name|brush
operator|.
name|style
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setBrush: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|brush
operator|.
name|d
operator|==
name|brush
operator|.
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|state
operator|->
name|brush
operator|=
name|brush
expr_stmt|;
name|d
operator|->
name|checkEmulation
argument_list|()
expr_stmt|;
name|d
operator|->
name|extended
operator|->
name|brushChanged
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|brush
operator|=
name|brush
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyBrush
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the painter's brush to black color and the specified \a     style. */
end_comment
begin_function
DECL|function|setBrush
name|void
name|QPainter
operator|::
name|setBrush
parameter_list|(
name|Qt
operator|::
name|BrushStyle
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setBrush: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|brush
operator|.
name|style
argument_list|()
operator|==
name|style
operator|&&
operator|(
name|style
operator|==
name|Qt
operator|::
name|NoBrush
operator|||
operator|(
name|style
operator|==
name|Qt
operator|::
name|SolidPattern
operator|&&
name|d
operator|->
name|state
operator|->
name|brush
operator|.
name|color
argument_list|()
operator|==
name|QColor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|brush
operator|=
name|QBrush
argument_list|(
name|Qt
operator|::
name|black
argument_list|,
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|brushChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyBrush
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the painter's current brush.      \sa QPainter::setBrush(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|brush
specifier|const
name|QBrush
modifier|&
name|QPainter
operator|::
name|brush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::brush: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|brush
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|brush
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setBackground(const QBrush&brush)      Sets the background brush of the painter to the given \a brush.      The background brush is the brush that is filled in when drawing     opaque text, stippled lines and bitmaps. The background brush has     no effect in transparent background mode (which is the default).      \sa background(), setBackgroundMode(),     {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setBackground
name|void
name|QPainter
operator|::
name|setBackground
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|bg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setBackground(), color=%04x, style=%d\n"
argument_list|,
name|bg
operator|.
name|color
argument_list|()
operator|.
name|rgb
argument_list|()
argument_list|,
name|bg
operator|.
name|style
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setBackground: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|bgBrush
operator|=
name|bg
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyBackground
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the painter's font to the given \a font.      This font is used by subsequent drawText() functions. The text     color is the same as the pen color.      If you set a font that isn't available, Qt finds a close match.     font() will return what you set using setFont() and fontInfo() returns the     font actually being used (which may be the same).      \sa font(), drawText(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setFont
name|void
name|QPainter
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setFont(), family=%s, pointSize=%d\n"
argument_list|,
name|font
operator|.
name|family
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|font
operator|.
name|pointSize
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setFont: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|font
operator|=
name|QFont
argument_list|(
name|font
operator|.
name|resolve
argument_list|(
name|d
operator|->
name|state
operator|->
name|deviceFont
argument_list|)
argument_list|,
name|device
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyFont
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently set font used for drawing text.      \sa setFont(), drawText(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|font
specifier|const
name|QFont
modifier|&
name|QPainter
operator|::
name|font
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::font: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|font
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|font
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Draws the given rectangle \a rect with rounded corners.      The \a xRadius and \a yRadius arguments specify the radii     of the ellipses defining the corners of the rounded rectangle.     When \a mode is Qt::RelativeSize, \a xRadius and     \a yRadius are specified in percentage of half the rectangle's     width and height respectively, and should be in the range     0.0 to 100.0.      A filled rectangle has a size of rect.size(). A stroked rectangle     has a size of rect.size() plus the pen width.      \table 100%     \row     \li \inlineimage qpainter-roundrect.png     \li     \snippet code/src_gui_painting_qpainter.cpp 8     \endtable      \sa drawRect(), QPen */
end_comment
begin_function
DECL|function|drawRoundedRect
name|void
name|QPainter
operator|::
name|drawRoundedRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xRadius
parameter_list|,
name|qreal
name|yRadius
parameter_list|,
name|Qt
operator|::
name|SizeMode
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawRoundedRect(), [%.2f,%.2f,%.2f,%.2f]\n"
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|xRadius
operator|<=
literal|0
operator|||
name|yRadius
operator|<=
literal|0
condition|)
block|{
comment|// draw normal rectangle
name|drawRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawRoundedRect
argument_list|(
name|rect
argument_list|,
name|xRadius
argument_list|,
name|yRadius
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRoundedRect
argument_list|(
name|rect
argument_list|,
name|xRadius
argument_list|,
name|yRadius
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawRoundedRect(const QRect&rect, qreal xRadius, qreal yRadius,                                        Qt::SizeMode mode = Qt::AbsoluteSize);     \since 4.4     \overload      Draws the given rectangle \a rect with rounded corners. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius,                                        Qt::SizeMode mode = Qt::AbsoluteSize);     \since 4.4     \overload      Draws the given rectangle \a x, \a y, \a w, \a h with rounded corners. */
end_comment
begin_comment
comment|/*!     \obsolete      Draws a rectangle \a r with rounded corners.      The \a xRnd and \a yRnd arguments specify how rounded the corners     should be. 0 is angled corners, 99 is maximum roundedness.      A filled rectangle has a size of r.size(). A stroked rectangle     has a size of r.size() plus the pen width.      \sa drawRoundedRect() */
end_comment
begin_function
DECL|function|drawRoundRect
name|void
name|QPainter
operator|::
name|drawRoundRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|xRnd
parameter_list|,
name|int
name|yRnd
parameter_list|)
block|{
name|drawRoundedRect
argument_list|(
name|r
argument_list|,
name|xRnd
argument_list|,
name|yRnd
argument_list|,
name|Qt
operator|::
name|RelativeSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawRoundRect(const QRect&r, int xRnd = 25, int yRnd = 25)      \overload     \obsolete      Draws the rectangle \a r with rounded corners. */
end_comment
begin_comment
comment|/*!     \obsolete      \fn QPainter::drawRoundRect(int x, int y, int w, int h, int xRnd, int yRnd)      \overload      Draws the rectangle \a x, \a y, \a w, \a h with rounded corners. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawEllipse(const QRectF&rectangle)      Draws the ellipse defined by the given \a rectangle.      A filled ellipse has a size of \a{rectangle}.\l     {QRect::size()}{size()}. A stroked ellipse has a size of     \a{rectangle}.\l {QRect::size()}{size()} plus the pen width.      \table 100%     \row     \li \inlineimage qpainter-ellipse.png     \li     \snippet code/src_gui_painting_qpainter.cpp 9     \endtable      \sa drawPie(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawEllipse
name|void
name|QPainter
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawEllipse(), [%.2f,%.2f,%.2f,%.2f]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
name|QRectF
name|rect
argument_list|(
name|r
operator|.
name|normalized
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
name|rect
operator|.
name|translate
argument_list|(
name|QPointF
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|engine
operator|->
name|drawEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainter::drawEllipse(const QRect&rectangle)      \overload      Draws the ellipse defined by the given \a rectangle. */
end_comment
begin_function
DECL|function|drawEllipse
name|void
name|QPainter
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawEllipse(), [%d,%d,%d,%d]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
name|QRect
name|rect
argument_list|(
name|r
operator|.
name|normalized
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
name|rect
operator|.
name|translate
argument_list|(
name|QPoint
argument_list|(
name|qRound
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeAndFillDraw
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|engine
operator|->
name|drawEllipse
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainter::drawEllipse(int x, int y, int width, int height)      \overload      Draws the ellipse defined by the rectangle beginning at (\a{x},     \a{y}) with the given \a width and \a height. */
end_comment
begin_comment
comment|/*!     \since 4.4      \fn QPainter::drawEllipse(const QPointF&center, qreal rx, qreal ry)      \overload      Draws the ellipse positioned at \a{center} with radii \a{rx} and \a{ry}. */
end_comment
begin_comment
comment|/*!     \since 4.4      \fn QPainter::drawEllipse(const QPoint&center, int rx, int ry)      \overload      Draws the ellipse positioned at \a{center} with radii \a{rx} and \a{ry}. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawArc(const QRectF&rectangle, int startAngle, int spanAngle)      Draws the arc defined by the given \a rectangle, \a startAngle and     \a spanAngle.      The \a startAngle and \a spanAngle must be specified in 1/16th of     a degree, i.e. a full circle equals 5760 (16 * 360). Positive     values for the angles mean counter-clockwise while negative values     mean the clockwise direction. Zero degrees is at the 3 o'clock     position.      \table 100%     \row     \li \inlineimage qpainter-arc.png     \li     \snippet code/src_gui_painting_qpainter.cpp 10     \endtable      \sa drawPie(), drawChord(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawArc
name|void
name|QPainter
operator|::
name|drawArc
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|alen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawArc(), [%.2f,%.2f,%.2f,%.2f], angle=%d, sweep=%d\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|a
operator|/
literal|16
argument_list|,
name|alen
operator|/
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
name|QRectF
name|rect
init|=
name|r
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|arcMoveTo
argument_list|(
name|rect
argument_list|,
name|a
operator|/
literal|16.0
argument_list|)
expr_stmt|;
name|path
operator|.
name|arcTo
argument_list|(
name|rect
argument_list|,
name|a
operator|/
literal|16.0
argument_list|,
name|alen
operator|/
literal|16.0
argument_list|)
expr_stmt|;
name|strokePath
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|state
operator|->
name|pen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn void QPainter::drawArc(const QRect&rectangle, int startAngle,                                int spanAngle)      \overload      Draws the arc defined by the given \a rectangle, \a startAngle and     \a spanAngle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawArc(int x, int y, int width, int height,                                int startAngle, int spanAngle)      \overload      Draws the arc defined by the rectangle beginning at (\a x, \a y)     with the specified \a width and \a height, and the given \a     startAngle and \a spanAngle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPie(const QRectF&rectangle, int startAngle, int spanAngle)      Draws a pie defined by the given \a rectangle, \a startAngle and \a spanAngle.      The pie is filled with the current brush().      The startAngle and spanAngle must be specified in 1/16th of a     degree, i.e. a full circle equals 5760 (16 * 360). Positive values     for the angles mean counter-clockwise while negative values mean     the clockwise direction. Zero degrees is at the 3 o'clock     position.      \table 100%     \row     \li \inlineimage qpainter-pie.png     \li     \snippet code/src_gui_painting_qpainter.cpp 11     \endtable      \sa drawEllipse(), drawChord(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawPie
name|void
name|QPainter
operator|::
name|drawPie
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|alen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPie(), [%.2f,%.2f,%.2f,%.2f], angle=%d, sweep=%d\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|a
operator|/
literal|16
argument_list|,
name|alen
operator|/
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|a
operator|>
operator|(
literal|360
operator|*
literal|16
operator|)
condition|)
block|{
name|a
operator|=
name|a
operator|%
operator|(
literal|360
operator|*
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|a
operator|=
name|a
operator|%
operator|(
literal|360
operator|*
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|a
operator|+=
operator|(
literal|360
operator|*
literal|16
operator|)
expr_stmt|;
block|}
name|QRectF
name|rect
init|=
name|r
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|moveTo
argument_list|(
name|rect
operator|.
name|center
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|arcTo
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|a
operator|/
literal|16.0
argument_list|,
name|alen
operator|/
literal|16.0
argument_list|)
expr_stmt|;
name|path
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPie(const QRect&rectangle, int startAngle, int spanAngle)     \overload      Draws a pie defined by the given \a rectangle, \a startAngle and     and \a spanAngle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPie(int x, int y, int width, int height, int     startAngle, int spanAngle)      \overload      Draws the pie defined by the rectangle beginning at (\a x, \a y) with     the specified \a width and \a height, and the given \a startAngle and     \a spanAngle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawChord(const QRectF&rectangle, int startAngle, int spanAngle)      Draws the chord defined by the given \a rectangle, \a startAngle and     \a spanAngle.  The chord is filled with the current brush().      The startAngle and spanAngle must be specified in 1/16th of a     degree, i.e. a full circle equals 5760 (16 * 360). Positive values     for the angles mean counter-clockwise while negative values mean     the clockwise direction. Zero degrees is at the 3 o'clock     position.      \table 100%     \row     \li \inlineimage qpainter-chord.png     \li     \snippet code/src_gui_painting_qpainter.cpp 12     \endtable      \sa drawArc(), drawPie(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawChord
name|void
name|QPainter
operator|::
name|drawChord
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|alen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawChord(), [%.2f,%.2f,%.2f,%.2f], angle=%d, sweep=%d\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|a
operator|/
literal|16
argument_list|,
name|alen
operator|/
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
name|QRectF
name|rect
init|=
name|r
operator|.
name|normalized
argument_list|()
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|arcMoveTo
argument_list|(
name|rect
argument_list|,
name|a
operator|/
literal|16.0
argument_list|)
expr_stmt|;
name|path
operator|.
name|arcTo
argument_list|(
name|rect
argument_list|,
name|a
operator|/
literal|16.0
argument_list|,
name|alen
operator|/
literal|16.0
argument_list|)
expr_stmt|;
name|path
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawChord(const QRect&rectangle, int startAngle, int spanAngle)      \overload      Draws the chord defined by the given \a rectangle, \a startAngle and     \a spanAngle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawChord(int x, int y, int width, int height, int     startAngle, int spanAngle)      \overload     Draws the chord defined by the rectangle beginning at (\a x, \a y)    with the specified \a width and \a height, and the given \a    startAngle and \a spanAngle. */
end_comment
begin_comment
comment|/*!     Draws the first \a lineCount lines in the array \a lines     using the current pen.      \sa drawLine(), drawPolyline() */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPainter
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLineF
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawLines(), line count=%d\n"
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|lineCount
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|lineEmulation
init|=
name|line_emulation
argument_list|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|lineEmulation
condition|)
block|{
if|if
condition|(
name|lineEmulation
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
control|)
block|{
name|QLineF
name|line
init|=
name|lines
index|[
name|i
index|]
decl_stmt|;
name|line
operator|.
name|translate
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawLines
argument_list|(
operator|&
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPainterPath
name|linePath
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
control|)
block|{
name|linePath
operator|.
name|moveTo
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|p1
argument_list|()
argument_list|)
expr_stmt|;
name|linePath
operator|.
name|lineTo
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|p2
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|draw_helper
argument_list|(
name|linePath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawLines(const QLine *lines, int lineCount)     \overload      Draws the first \a lineCount lines in the array \a lines     using the current pen. */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPainter
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLine
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawLine(), line count=%d\n"
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|lineCount
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|lineEmulation
init|=
name|line_emulation
argument_list|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|lineEmulation
condition|)
block|{
if|if
condition|(
name|lineEmulation
operator|==
name|QPaintEngine
operator|::
name|PrimitiveTransform
operator|&&
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
control|)
block|{
name|QLineF
name|line
init|=
name|lines
index|[
name|i
index|]
decl_stmt|;
name|line
operator|.
name|translate
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawLines
argument_list|(
operator|&
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPainterPath
name|linePath
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
control|)
block|{
name|linePath
operator|.
name|moveTo
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|p1
argument_list|()
argument_list|)
expr_stmt|;
name|linePath
operator|.
name|lineTo
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|p2
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|draw_helper
argument_list|(
name|linePath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Draws the first \a lineCount lines in the array \a pointPairs     using the current pen.  The lines are specified as pairs of points     so the number of entries in \a pointPairs must be at least \a     lineCount * 2. */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPainter
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|pointPairs
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QLineF
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|QPointF
argument_list|)
argument_list|)
expr_stmt|;
name|drawLines
argument_list|(
operator|(
name|QLineF
operator|*
operator|)
name|pointPairs
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Draws the first \a lineCount lines in the array \a pointPairs     using the current pen. */
end_comment
begin_function
DECL|function|drawLines
name|void
name|QPainter
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|pointPairs
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QLine
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|QPoint
argument_list|)
argument_list|)
expr_stmt|;
name|drawLines
argument_list|(
operator|(
name|QLine
operator|*
operator|)
name|pointPairs
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawLines(const QVector<QPointF>&pointPairs)     \overload      Draws a line for each pair of points in the vector \a pointPairs     using the current pen. If there is an odd number of points in the     array, the last point will be ignored. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLines(const QVector<QPoint>&pointPairs)     \overload      Draws a line for each pair of points in the vector \a pointPairs     using the current pen. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLines(const QVector<QLineF>&lines)     \overload      Draws the set of lines defined by the list \a lines using the     current pen and brush. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawLines(const QVector<QLine>&lines)     \overload      Draws the set of lines defined by the list \a lines using the     current pen and brush. */
end_comment
begin_comment
comment|/*!     Draws the polyline defined by the first \a pointCount points in \a     points using the current pen.      Note that unlike the drawPolygon() function the last point is \e     not connected to the first, neither is the polyline filled.      \table 100%     \row     \li     \snippet code/src_gui_painting_qpainter.cpp 13     \endtable      \sa drawLines(), drawPolygon(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawPolyline
name|void
name|QPainter
operator|::
name|drawPolyline
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPolyline(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolylineMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|lineEmulation
init|=
name|line_emulation
argument_list|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|lineEmulation
condition|)
block|{
comment|// ###
comment|//         if (lineEmulation == QPaintEngine::PrimitiveTransform
comment|//&& d->state->matrix.type() == QTransform::TxTranslate) {
comment|//         } else {
name|QPainterPath
name|polylinePath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polylinePath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polylinePath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
comment|//         }
block|}
else|else
block|{
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolylineMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Draws the polyline defined by the first \a pointCount points in \a     points using the current pen.  */
end_comment
begin_function
DECL|function|drawPolyline
name|void
name|QPainter
operator|::
name|drawPolyline
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPolyline(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolylineMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|lineEmulation
init|=
name|line_emulation
argument_list|(
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|lineEmulation
condition|)
block|{
comment|// ###
comment|//         if (lineEmulation == QPaintEngine::PrimitiveTransform
comment|//&& d->state->matrix.type() == QTransform::TxTranslate) {
comment|//         } else {
name|QPainterPath
name|polylinePath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polylinePath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polylinePath
argument_list|,
name|QPainterPrivate
operator|::
name|StrokeDraw
argument_list|)
expr_stmt|;
comment|//         }
block|}
else|else
block|{
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolylineMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPolyline(const QPolygonF&points)      \overload      Draws the polyline defined by the given \a points using the     current pen. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPolyline(const QPolygon&points)      \overload      Draws the polyline defined by the given \a points using the     current pen. */
end_comment
begin_comment
comment|/*!     Draws the polygon defined by the first \a pointCount points in the     array \a points using the current pen and brush.      \table 100%     \row     \li \inlineimage qpainter-polygon.png     \li     \snippet code/src_gui_painting_qpainter.cpp 14     \endtable      The first point is implicitly connected to the last point, and the     polygon is filled with the current brush().      If \a fillRule is Qt::WindingFill, the polygon is filled using the     winding fill algorithm.  If \a fillRule is Qt::OddEvenFill, the     polygon is filled using the odd-even fill algorithm. See     \l{Qt::FillRule} for a more detailed description of these fill     rules.      \sa drawConvexPolygon(), drawPolyline(), {Coordinate System} */
end_comment
begin_function
DECL|function|drawPolygon
name|void
name|QPainter
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPolygon(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolygonDrawMode
argument_list|(
name|fillRule
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|emulationSpecifier
init|=
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
decl_stmt|;
if|if
condition|(
name|emulationSpecifier
condition|)
block|{
name|QPainterPath
name|polygonPath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polygonPath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|polygonPath
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|polygonPath
operator|.
name|setFillRule
argument_list|(
name|fillRule
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polygonPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolygonDrawMode
argument_list|(
name|fillRule
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \overload      Draws the polygon defined by the first \a pointCount points in the     array \a points. */
end_comment
begin_function
DECL|function|drawPolygon
name|void
name|QPainter
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|Qt
operator|::
name|FillRule
name|fillRule
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPolygon(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolygonDrawMode
argument_list|(
name|fillRule
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|emulationSpecifier
init|=
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
decl_stmt|;
if|if
condition|(
name|emulationSpecifier
condition|)
block|{
name|QPainterPath
name|polygonPath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polygonPath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|polygonPath
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|polygonPath
operator|.
name|setFillRule
argument_list|(
name|fillRule
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polygonPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|PolygonDrawMode
argument_list|(
name|fillRule
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn void QPainter::drawPolygon(const QPolygonF&points, Qt::FillRule fillRule)      \overload      Draws the polygon defined by the given \a points using the fill     rule \a fillRule. */
end_comment
begin_comment
comment|/*! \fn void QPainter::drawPolygon(const QPolygon&points, Qt::FillRule fillRule)      \overload      Draws the polygon defined by the given \a points using the fill     rule \a fillRule. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawConvexPolygon(const QPointF *points, int pointCount)      Draws the convex polygon defined by the first \a pointCount points     in the array \a points using the current pen.      \table 100%     \row     \li \inlineimage qpainter-polygon.png     \li     \snippet code/src_gui_painting_qpainter.cpp 15     \endtable      The first point is implicitly connected to the last point, and the     polygon is filled with the current brush().  If the supplied     polygon is not convex, i.e. it contains at least one angle larger     than 180 degrees, the results are undefined.      On some platforms (e.g. X11), the drawConvexPolygon() function can     be faster than the drawPolygon() function.      \sa drawPolygon(), drawPolyline(), {Coordinate System} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawConvexPolygon(const QPoint *points, int pointCount)     \overload      Draws the convex polygon defined by the first \a pointCount points     in the array \a points using the current pen. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawConvexPolygon(const QPolygonF&polygon)      \overload      Draws the convex polygon defined by \a polygon using the current     pen and brush. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawConvexPolygon(const QPolygon&polygon)     \overload      Draws the convex polygon defined by \a polygon using the current     pen and brush. */
end_comment
begin_function
DECL|function|drawConvexPolygon
name|void
name|QPainter
operator|::
name|drawConvexPolygon
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawConvexPolygon(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|ConvexMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|emulationSpecifier
init|=
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
decl_stmt|;
if|if
condition|(
name|emulationSpecifier
condition|)
block|{
name|QPainterPath
name|polygonPath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polygonPath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|polygonPath
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|polygonPath
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polygonPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|ConvexMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawConvexPolygon
name|void
name|QPainter
operator|::
name|drawConvexPolygon
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawConvexPolygon(), count=%d\n"
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pointCount
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|ConvexMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|uint
name|emulationSpecifier
init|=
name|d
operator|->
name|state
operator|->
name|emulationSpecifier
decl_stmt|;
if|if
condition|(
name|emulationSpecifier
condition|)
block|{
name|QPainterPath
name|polygonPath
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
control|)
name|polygonPath
operator|.
name|lineTo
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|polygonPath
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|polygonPath
operator|.
name|setFillRule
argument_list|(
name|Qt
operator|::
name|WindingFill
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw_helper
argument_list|(
name|polygonPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|engine
operator|->
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|QPaintEngine
operator|::
name|ConvexMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|roundInDeviceCoordinates
specifier|static
specifier|inline
name|QPointF
name|roundInDeviceCoordinates
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|)
block|{
return|return
name|m
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|m
operator|.
name|map
argument_list|(
name|p
argument_list|)
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QRectF&target, const QPixmap&pixmap, const QRectF&source)      Draws the rectangular portion \a source of the given \a pixmap     into the given \a target in the paint device.      \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.      \table 100%     \row     \li     \snippet code/src_gui_painting_qpainter.cpp 16     \endtable      If \a pixmap is a QBitmap it is drawn with the bits that are "set"     using the pens color. If backgroundMode is Qt::OpaqueMode, the     "unset" bits are drawn using the color of the background brush; if     backgroundMode is Qt::TransparentMode, the "unset" bits are     transparent. Drawing bitmaps with gradient or texture colors is     not supported.      \sa drawImage() */
end_comment
begin_function
DECL|function|drawPixmap
name|void
name|QPainter
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pm
parameter_list|)
block|{
if|#
directive|if
name|defined
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPixmap(), p=[%.2f,%.2f], pix=[%d,%d]\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|,
name|pm
operator|.
name|width
argument_list|()
argument_list|,
name|pm
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pm
operator|.
name|isNull
argument_list|()
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qt_painter_thread_test
argument_list|(
name|d
operator|->
name|device
operator|->
name|devType
argument_list|()
argument_list|,
literal|"drawPixmap()"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPixmap
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
expr_stmt|;
return|return;
block|}
name|qreal
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|pm
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|pm
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return;
comment|// Emulate opaque background for bitmaps
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
operator|&&
name|pm
operator|.
name|isQBitmap
argument_list|()
condition|)
block|{
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|bgBrush
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PerspectiveTransform
argument_list|)
operator|)
operator|||
operator|(
name|d
operator|->
name|state
operator|->
name|opacity
operator|!=
literal|1.0
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
operator|)
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
comment|// If there is no rotation involved we have to make sure we use the
comment|// antialiased and not the aliased coordinate system by rounding the coordinates.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|QPointF
name|p
init|=
name|roundInDeviceCoordinates
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
name|setRenderHint
argument_list|(
name|Antialiasing
argument_list|,
name|renderHints
argument_list|()
operator|&
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|QBrush
name|brush
argument_list|(
name|d
operator|->
name|state
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
name|pm
argument_list|)
decl_stmt|;
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|setBrushOrigin
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|pm
operator|.
name|rect
argument_list|()
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
condition|)
block|{
name|x
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|y
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
name|int
name|scale
init|=
name|pm
operator|.
name|devicePixelRatio
argument_list|()
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|drawPixmap
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
operator|/
name|scale
argument_list|,
name|h
operator|/
name|scale
argument_list|)
argument_list|,
name|pm
argument_list|,
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawPixmap
name|void
name|QPainter
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pm
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|)
block|{
if|#
directive|if
name|defined
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawPixmap(), target=[%.2f,%.2f,%.2f,%.2f], pix=[%d,%d], source=[%.2f,%.2f,%.2f,%.2f]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pm
operator|.
name|width
argument_list|()
argument_list|,
name|pm
operator|.
name|height
argument_list|()
argument_list|,
name|sr
operator|.
name|x
argument_list|()
argument_list|,
name|sr
operator|.
name|y
argument_list|()
argument_list|,
name|sr
operator|.
name|width
argument_list|()
argument_list|,
name|sr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pm
operator|.
name|isNull
argument_list|()
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qt_painter_thread_test
argument_list|(
name|d
operator|->
name|device
operator|->
name|devType
argument_list|()
argument_list|,
literal|"drawPixmap()"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qreal
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|sx
init|=
name|sr
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|sy
init|=
name|sr
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|sw
init|=
name|sr
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|sh
init|=
name|sr
operator|.
name|height
argument_list|()
decl_stmt|;
comment|// Get pixmap scale. Use it when calculating the target
comment|// rect size from pixmap size. For example, a 2X 64x64 pixel
comment|// pixmap should result in a 32x32 point target rect.
specifier|const
name|qreal
name|pmscale
init|=
name|pm
operator|.
name|devicePixelRatio
argument_list|()
decl_stmt|;
comment|// Sanity-check clipping
if|if
condition|(
name|sw
operator|<=
literal|0
condition|)
name|sw
operator|=
name|pm
operator|.
name|width
argument_list|()
operator|-
name|sx
expr_stmt|;
if|if
condition|(
name|sh
operator|<=
literal|0
condition|)
name|sh
operator|=
name|pm
operator|.
name|height
argument_list|()
operator|-
name|sy
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
name|sw
operator|/
name|pmscale
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
name|sh
operator|/
name|pmscale
expr_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|qreal
name|w_ratio
init|=
name|sx
operator|*
name|w
operator|/
name|sw
decl_stmt|;
name|x
operator|-=
name|w_ratio
expr_stmt|;
name|w
operator|+=
name|w_ratio
expr_stmt|;
name|sw
operator|+=
name|sx
expr_stmt|;
name|sx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sy
operator|<
literal|0
condition|)
block|{
name|qreal
name|h_ratio
init|=
name|sy
operator|*
name|h
operator|/
name|sh
decl_stmt|;
name|y
operator|-=
name|h_ratio
expr_stmt|;
name|h
operator|+=
name|h_ratio
expr_stmt|;
name|sh
operator|+=
name|sy
expr_stmt|;
name|sy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sw
operator|+
name|sx
operator|>
name|pm
operator|.
name|width
argument_list|()
condition|)
block|{
name|qreal
name|delta
init|=
name|sw
operator|-
operator|(
name|pm
operator|.
name|width
argument_list|()
operator|-
name|sx
operator|)
decl_stmt|;
name|qreal
name|w_ratio
init|=
name|delta
operator|*
name|w
operator|/
name|sw
decl_stmt|;
name|sw
operator|-=
name|delta
expr_stmt|;
name|w
operator|-=
name|w_ratio
expr_stmt|;
block|}
if|if
condition|(
name|sh
operator|+
name|sy
operator|>
name|pm
operator|.
name|height
argument_list|()
condition|)
block|{
name|qreal
name|delta
init|=
name|sh
operator|-
operator|(
name|pm
operator|.
name|height
argument_list|()
operator|-
name|sy
operator|)
decl_stmt|;
name|qreal
name|h_ratio
init|=
name|delta
operator|*
name|h
operator|/
name|sh
decl_stmt|;
name|sh
operator|-=
name|delta
expr_stmt|;
name|h
operator|-=
name|h_ratio
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
operator|||
name|sw
operator|<=
literal|0
operator|||
name|sh
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPixmap
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|pm
argument_list|,
name|QRectF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Emulate opaque background for bitmaps
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
operator|&&
name|pm
operator|.
name|isQBitmap
argument_list|()
condition|)
name|fillRect
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|bgBrush
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PerspectiveTransform
argument_list|)
operator|)
operator|||
operator|(
name|d
operator|->
name|state
operator|->
name|opacity
operator|!=
literal|1.0
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|sw
operator|!=
name|w
operator|||
name|sh
operator|!=
name|h
operator|)
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
comment|// If there is no rotation involved we have to make sure we use the
comment|// antialiased and not the aliased coordinate system by rounding the coordinates.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|QPointF
name|p
init|=
name|roundInDeviceCoordinates
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|&&
name|sw
operator|==
name|w
operator|&&
name|sh
operator|==
name|h
condition|)
block|{
name|sx
operator|=
name|qRound
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|sy
operator|=
name|qRound
argument_list|(
name|sy
argument_list|)
expr_stmt|;
name|sw
operator|=
name|qRound
argument_list|(
name|sw
argument_list|)
expr_stmt|;
name|sh
operator|=
name|qRound
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|scale
argument_list|(
name|w
operator|/
name|sw
argument_list|,
name|h
operator|/
name|sh
argument_list|)
expr_stmt|;
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
name|setRenderHint
argument_list|(
name|Antialiasing
argument_list|,
name|renderHints
argument_list|()
operator|&
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|QBrush
name|brush
decl_stmt|;
if|if
condition|(
name|sw
operator|==
name|pm
operator|.
name|width
argument_list|()
operator|&&
name|sh
operator|==
name|pm
operator|.
name|height
argument_list|()
condition|)
name|brush
operator|=
name|QBrush
argument_list|(
name|d
operator|->
name|state
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
name|pm
argument_list|)
expr_stmt|;
else|else
name|brush
operator|=
name|QBrush
argument_list|(
name|d
operator|->
name|state
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
name|pm
operator|.
name|copy
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
condition|)
block|{
name|x
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|y
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|drawPixmap
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|pm
argument_list|,
name|QRectF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QRect&target, const QPixmap&pixmap,                                   const QRect&source)     \overload      Draws the rectangular portion \a source of the given \a pixmap     into the given \a target in the paint device.      \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QPointF&point, const QPixmap&pixmap,                                   const QRectF&source)     \overload      Draws the rectangular portion \a source of the given \a pixmap     with its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QPoint&point, const QPixmap&pixmap,                                   const QRect&source)      \overload      Draws the rectangular portion \a source of the given \a pixmap     with its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QPointF&point, const QPixmap&pixmap)     \overload      Draws the given \a pixmap with its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QPoint&point, const QPixmap&pixmap)     \overload      Draws the given \a pixmap with its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(int x, int y, const QPixmap&pixmap)      \overload      Draws the given \a pixmap at position (\a{x}, \a{y}). */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(const QRect&rectangle, const QPixmap&pixmap)     \overload      Draws the given \a  pixmap into the given \a rectangle.      \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(int x, int y, int width, int height,     const QPixmap&pixmap)      \overload      Draws the \a pixmap into the rectangle at position (\a{x}, \a{y})     with  the given \a width and \a height. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap&pixmap,                                   int sx, int sy, int sw, int sh)      \overload      Draws the rectangular portion with the origin (\a{sx}, \a{sy}),     width \a sw and height \a sh, of the given \a pixmap , at the     point (\a{x}, \a{y}), with a width of \a w and a height of \a h.     If sw or sh are equal to zero the width/height of the pixmap     is used and adjusted by the offset sx/sy; */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPixmap(int x, int y, const QPixmap&pixmap,                                   int sx, int sy, int sw, int sh)      \overload      Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a     pixmap into the paint device.      (\a{x}, \a{y}) specifies the top-left point in the paint device that is     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a     pixmap that is to be drawn. The default is (0, 0).      (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.     The default, (0, 0) (and negative) means all the way to the     bottom-right of the pixmap. */
end_comment
begin_function
DECL|function|drawImage
name|void
name|QPainter
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawImage
argument_list|(
name|p
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return;
block|}
name|qreal
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|scale
init|=
name|image
operator|.
name|devicePixelRatio
argument_list|()
decl_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|)
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PerspectiveTransform
argument_list|)
operator|)
operator|||
operator|(
name|d
operator|->
name|state
operator|->
name|opacity
operator|!=
literal|1.0
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
operator|)
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
comment|// If there is no rotation involved we have to make sure we use the
comment|// antialiased and not the aliased coordinate system by rounding the coordinates.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|QPointF
name|p
init|=
name|roundInDeviceCoordinates
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
name|setRenderHint
argument_list|(
name|Antialiasing
argument_list|,
name|renderHints
argument_list|()
operator|&
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|QBrush
name|brush
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|setBrushOrigin
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|image
operator|.
name|size
argument_list|()
operator|/
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
condition|)
block|{
name|x
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|y
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|drawImage
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
operator|/
name|scale
argument_list|,
name|h
operator|/
name|scale
argument_list|)
argument_list|,
name|image
argument_list|,
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawImage
name|void
name|QPainter
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|targetRect
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sourceRect
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|qreal
name|x
init|=
name|targetRect
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|targetRect
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|w
init|=
name|targetRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|targetRect
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|sx
init|=
name|sourceRect
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|sy
init|=
name|sourceRect
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|sw
init|=
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|sh
init|=
name|sourceRect
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|imageScale
init|=
name|image
operator|.
name|devicePixelRatio
argument_list|()
decl_stmt|;
comment|// Sanity-check clipping
if|if
condition|(
name|sw
operator|<=
literal|0
condition|)
name|sw
operator|=
name|image
operator|.
name|width
argument_list|()
operator|-
name|sx
expr_stmt|;
if|if
condition|(
name|sh
operator|<=
literal|0
condition|)
name|sh
operator|=
name|image
operator|.
name|height
argument_list|()
operator|-
name|sy
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
name|sw
operator|/
name|imageScale
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
name|sh
operator|/
name|imageScale
expr_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|qreal
name|w_ratio
init|=
name|sx
operator|*
name|w
operator|/
name|sw
decl_stmt|;
name|x
operator|-=
name|w_ratio
expr_stmt|;
name|w
operator|+=
name|w_ratio
expr_stmt|;
name|sw
operator|+=
name|sx
expr_stmt|;
name|sx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sy
operator|<
literal|0
condition|)
block|{
name|qreal
name|h_ratio
init|=
name|sy
operator|*
name|h
operator|/
name|sh
decl_stmt|;
name|y
operator|-=
name|h_ratio
expr_stmt|;
name|h
operator|+=
name|h_ratio
expr_stmt|;
name|sh
operator|+=
name|sy
expr_stmt|;
name|sy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sw
operator|+
name|sx
operator|>
name|image
operator|.
name|width
argument_list|()
condition|)
block|{
name|qreal
name|delta
init|=
name|sw
operator|-
operator|(
name|image
operator|.
name|width
argument_list|()
operator|-
name|sx
operator|)
decl_stmt|;
name|qreal
name|w_ratio
init|=
name|delta
operator|*
name|w
operator|/
name|sw
decl_stmt|;
name|sw
operator|-=
name|delta
expr_stmt|;
name|w
operator|-=
name|w_ratio
expr_stmt|;
block|}
if|if
condition|(
name|sh
operator|+
name|sy
operator|>
name|image
operator|.
name|height
argument_list|()
condition|)
block|{
name|qreal
name|delta
init|=
name|sh
operator|-
operator|(
name|image
operator|.
name|height
argument_list|()
operator|-
name|sy
operator|)
decl_stmt|;
name|qreal
name|h_ratio
init|=
name|delta
operator|*
name|h
operator|/
name|sh
decl_stmt|;
name|sh
operator|-=
name|delta
expr_stmt|;
name|h
operator|-=
name|h_ratio
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
operator|||
name|sw
operator|<=
literal|0
operator|||
name|sh
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawImage
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|image
argument_list|,
name|QRectF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|||
operator|(
name|sw
operator|!=
name|w
operator|||
name|sh
operator|!=
name|h
operator|)
operator|)
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PerspectiveTransform
argument_list|)
operator|)
operator|||
operator|(
name|d
operator|->
name|state
operator|->
name|opacity
operator|!=
literal|1.0
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
operator|)
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
comment|// If there is no rotation involved we have to make sure we use the
comment|// antialiased and not the aliased coordinate system by rounding the coordinates.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|QPointF
name|p
init|=
name|roundInDeviceCoordinates
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
name|x
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|y
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|&&
name|sw
operator|==
name|w
operator|&&
name|sh
operator|==
name|h
condition|)
block|{
name|sx
operator|=
name|qRound
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|sy
operator|=
name|qRound
argument_list|(
name|sy
argument_list|)
expr_stmt|;
name|sw
operator|=
name|qRound
argument_list|(
name|sw
argument_list|)
expr_stmt|;
name|sh
operator|=
name|qRound
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|translate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|scale
argument_list|(
name|w
operator|/
name|sw
argument_list|,
name|h
operator|/
name|sh
argument_list|)
expr_stmt|;
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
name|setRenderHint
argument_list|(
name|Antialiasing
argument_list|,
name|renderHints
argument_list|()
operator|&
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|QBrush
name|brush
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|setBrushOrigin
argument_list|(
name|QPointF
argument_list|(
operator|-
name|sx
argument_list|,
operator|-
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
condition|)
block|{
name|x
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|y
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|drawImage
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|image
argument_list|,
name|QRectF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawGlyphRun(const QPointF&position, const QGlyphRun&glyphs)      Draws the glyphs represented by \a glyphs at \a position. The \a position gives the     edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font     selected on \a glyphs and at offsets given by the positions in \a glyphs.      \since 4.8      \sa QGlyphRun::setRawFont(), QGlyphRun::setPositions(), QGlyphRun::setGlyphIndexes() */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_RAWFONT
argument_list|)
end_if
begin_function
DECL|function|drawGlyphRun
name|void
name|QPainter
operator|::
name|drawGlyphRun
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
specifier|const
name|QGlyphRun
modifier|&
name|glyphRun
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|QRawFont
name|font
init|=
name|glyphRun
operator|.
name|rawFont
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|font
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|QGlyphRunPrivate
modifier|*
name|glyphRun_d
init|=
name|QGlyphRunPrivate
operator|::
name|get
argument_list|(
name|glyphRun
argument_list|)
decl_stmt|;
specifier|const
name|quint32
modifier|*
name|glyphIndexes
init|=
name|glyphRun_d
operator|->
name|glyphIndexData
decl_stmt|;
specifier|const
name|QPointF
modifier|*
name|glyphPositions
init|=
name|glyphRun_d
operator|->
name|glyphPositionData
decl_stmt|;
name|int
name|count
init|=
name|qMin
argument_list|(
name|glyphRun_d
operator|->
name|glyphIndexDataSize
argument_list|,
name|glyphRun_d
operator|->
name|glyphPositionDataSize
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QFixedPoint
argument_list|,
literal|128
argument_list|>
name|fixedPointPositions
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|QRawFontPrivate
modifier|*
name|fontD
init|=
name|QRawFontPrivate
operator|::
name|get
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|bool
name|engineRequiresPretransformedGlyphPositions
init|=
name|d
operator|->
name|extended
condition|?
name|d
operator|->
name|extended
operator|->
name|requiresPretransformedGlyphPositions
argument_list|(
name|fontD
operator|->
name|fontEngine
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
else|:
name|d
operator|->
name|engine
operator|->
name|type
argument_list|()
operator|!=
name|QPaintEngine
operator|::
name|CoreGraphics
operator|&&
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|QPointF
name|processedPosition
init|=
name|position
operator|+
name|glyphPositions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|engineRequiresPretransformedGlyphPositions
condition|)
name|processedPosition
operator|=
name|d
operator|->
name|state
operator|->
name|transform
argument_list|()
operator|.
name|map
argument_list|(
name|processedPosition
argument_list|)
expr_stmt|;
name|fixedPointPositions
index|[
name|i
index|]
operator|=
name|QFixedPoint
operator|::
name|fromPointF
argument_list|(
name|processedPosition
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|drawGlyphs
argument_list|(
name|glyphIndexes
argument_list|,
name|fixedPointPositions
operator|.
name|data
argument_list|()
argument_list|,
name|count
argument_list|,
name|font
argument_list|,
name|glyphRun
operator|.
name|overline
argument_list|()
argument_list|,
name|glyphRun
operator|.
name|underline
argument_list|()
argument_list|,
name|glyphRun
operator|.
name|strikeOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawGlyphs
name|void
name|QPainterPrivate
operator|::
name|drawGlyphs
parameter_list|(
specifier|const
name|quint32
modifier|*
name|glyphArray
parameter_list|,
name|QFixedPoint
modifier|*
name|positions
parameter_list|,
name|int
name|glyphCount
parameter_list|,
specifier|const
name|QRawFont
modifier|&
name|font
parameter_list|,
name|bool
name|overline
parameter_list|,
name|bool
name|underline
parameter_list|,
name|bool
name|strikeOut
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|QRawFontPrivate
modifier|*
name|fontD
init|=
name|QRawFontPrivate
operator|::
name|get
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|fontEngine
init|=
name|fontD
operator|->
name|fontEngine
decl_stmt|;
name|QFixed
name|leftMost
decl_stmt|;
name|QFixed
name|rightMost
decl_stmt|;
name|QFixed
name|baseLine
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
operator|++
name|i
control|)
block|{
name|glyph_metrics_t
name|gm
init|=
name|fontEngine
operator|->
name|boundingBox
argument_list|(
name|glyphArray
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|leftMost
operator|>
name|positions
index|[
name|i
index|]
operator|.
name|x
condition|)
name|leftMost
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
comment|// We don't support glyphs that do not share a common baseline. If this turns out to
comment|// be a relevant use case, then we need to find clusters of glyphs that share a baseline
comment|// and do a drawTextItemDecorations call per cluster.
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|baseLine
operator|<
name|positions
index|[
name|i
index|]
operator|.
name|y
condition|)
name|baseLine
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
comment|// We use the advance rather than the actual bounds to match the algorithm in drawText()
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|rightMost
operator|<
name|positions
index|[
name|i
index|]
operator|.
name|x
operator|+
name|gm
operator|.
name|xoff
condition|)
name|rightMost
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|x
operator|+
name|gm
operator|.
name|xoff
expr_stmt|;
block|}
name|QFixed
name|width
init|=
name|rightMost
operator|-
name|leftMost
decl_stmt|;
if|if
condition|(
name|extended
operator|!=
literal|0
operator|&&
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
condition|)
block|{
name|QStaticTextItem
name|staticTextItem
decl_stmt|;
name|staticTextItem
operator|.
name|color
operator|=
name|state
operator|->
name|pen
operator|.
name|color
argument_list|()
expr_stmt|;
name|staticTextItem
operator|.
name|font
operator|=
name|state
operator|->
name|font
expr_stmt|;
name|staticTextItem
operator|.
name|setFontEngine
argument_list|(
name|fontEngine
argument_list|)
expr_stmt|;
name|staticTextItem
operator|.
name|numGlyphs
operator|=
name|glyphCount
expr_stmt|;
name|staticTextItem
operator|.
name|glyphs
operator|=
cast|reinterpret_cast
argument_list|<
name|glyph_t
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|glyph_t
operator|*
argument_list|>
argument_list|(
name|glyphArray
argument_list|)
argument_list|)
expr_stmt|;
name|staticTextItem
operator|.
name|glyphPositions
operator|=
name|positions
expr_stmt|;
name|extended
operator|->
name|drawStaticTextItem
argument_list|(
operator|&
name|staticTextItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTextItemInt
name|textItem
decl_stmt|;
name|textItem
operator|.
name|fontEngine
operator|=
name|fontEngine
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|QFixed
argument_list|,
literal|128
argument_list|>
name|advances
argument_list|(
name|glyphCount
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QGlyphJustification
argument_list|,
literal|128
argument_list|>
name|glyphJustifications
argument_list|(
name|glyphCount
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QGlyphAttributes
argument_list|,
literal|128
argument_list|>
name|glyphAttributes
argument_list|(
name|glyphCount
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|glyphAttributes
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|glyphAttributes
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QGlyphAttributes
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|advances
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|advances
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QFixed
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|glyphJustifications
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|glyphJustifications
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QGlyphJustification
argument_list|)
argument_list|)
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|numGlyphs
operator|=
name|glyphCount
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|glyphs
operator|=
cast|const_cast
argument_list|<
name|glyph_t
operator|*
argument_list|>
argument_list|(
name|glyphArray
argument_list|)
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|offsets
operator|=
name|positions
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|advances_x
operator|=
name|advances
operator|.
name|data
argument_list|()
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|advances_y
operator|=
name|advances
operator|.
name|data
argument_list|()
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|justifications
operator|=
name|glyphJustifications
operator|.
name|data
argument_list|()
expr_stmt|;
name|textItem
operator|.
name|glyphs
operator|.
name|attributes
operator|=
name|glyphAttributes
operator|.
name|data
argument_list|()
expr_stmt|;
name|engine
operator|->
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
block|}
name|QTextItemInt
operator|::
name|RenderFlags
name|flags
decl_stmt|;
if|if
condition|(
name|underline
condition|)
name|flags
operator||=
name|QTextItemInt
operator|::
name|Underline
expr_stmt|;
if|if
condition|(
name|overline
condition|)
name|flags
operator||=
name|QTextItemInt
operator|::
name|Overline
expr_stmt|;
if|if
condition|(
name|strikeOut
condition|)
name|flags
operator||=
name|QTextItemInt
operator|::
name|StrikeOut
expr_stmt|;
name|drawTextItemDecoration
argument_list|(
name|q
argument_list|,
name|QPointF
argument_list|(
name|leftMost
operator|.
name|toReal
argument_list|()
argument_list|,
name|baseLine
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|fontEngine
argument_list|,
literal|0
argument_list|,
comment|// textEngine
operator|(
name|underline
condition|?
name|QTextCharFormat
operator|::
name|SingleUnderline
else|:
name|QTextCharFormat
operator|::
name|NoUnderline
operator|)
argument_list|,
name|flags
argument_list|,
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|QTextCharFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_RAWFONT
end_comment
begin_comment
comment|/*!      \fn void QPainter::drawStaticText(const QPoint&topLeftPosition, const QStaticText&staticText)     \since 4.7     \overload      Draws the \a staticText at the \a topLeftPosition.      \note The y-position is used as the top of the font.  */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawStaticText(int left, int top, const QStaticText&staticText)     \since 4.7     \overload      Draws the \a staticText at coordinates \a left and \a top.      \note The y-position is used as the top of the font. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawText(const QPointF&position, const QString&text)      Draws the given \a text with the currently defined text direction,     beginning at the given \a position.      This function does not handle the newline character (\\n), as it cannot     break text into multiple lines, and it cannot display the newline character.     Use the QPainter::drawText() overload that takes a rectangle instead     if you want to draw multiple lines of text with the newline character, or     if you want the text to be wrapped.      By default, QPainter draws text anti-aliased.      \note The y-position is used as the baseline of the font.      \sa setFont(), setPen() */
end_comment
begin_function
DECL|function|drawText
name|void
name|QPainter
operator|::
name|drawText
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|drawText
argument_list|(
name|p
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Draws the given \a staticText at the given \a topLeftPosition.      The text will be drawn using the font and the transformation set on the painter. If the     font and/or transformation set on the painter are different from the ones used to initialize     the layout of the QStaticText, then the layout will have to be recalculated. Use     QStaticText::prepare() to initialize \a staticText with the font and transformation with which     it will later be drawn.      If \a topLeftPosition is not the same as when \a staticText was initialized, or when it was     last drawn, then there will be a slight overhead when translating the text to its new position.      \note If the painter's transformation is not affine, then \a staticText will be drawn using     regular calls to drawText(), losing any potential for performance improvement.      \note The y-position is used as the top of the font.      \sa QStaticText */
end_comment
begin_function
DECL|function|drawStaticText
name|void
name|QPainter
operator|::
name|drawStaticText
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|topLeftPosition
parameter_list|,
specifier|const
name|QStaticText
modifier|&
name|staticText
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|staticText
operator|.
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
name|QStaticTextPrivate
modifier|*
name|staticText_d
init|=
cast|const_cast
argument_list|<
name|QStaticTextPrivate
operator|*
argument_list|>
argument_list|(
name|QStaticTextPrivate
operator|::
name|get
argument_list|(
operator|&
name|staticText
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|font
argument_list|()
operator|!=
name|staticText_d
operator|->
name|font
condition|)
block|{
name|staticText_d
operator|->
name|font
operator|=
name|font
argument_list|()
expr_stmt|;
name|staticText_d
operator|->
name|needsRelayout
operator|=
literal|true
expr_stmt|;
block|}
name|QFontEngine
modifier|*
name|fe
init|=
name|staticText_d
operator|->
name|font
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
if|if
condition|(
name|fe
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Multi
condition|)
name|fe
operator|=
cast|static_cast
argument_list|<
name|QFontEngineMulti
operator|*
argument_list|>
argument_list|(
name|fe
argument_list|)
operator|->
name|engine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// If we don't have an extended paint engine, if the painter is projected,
comment|// or if the font engine does not support the matrix, we go through standard
comment|// code path
if|if
condition|(
name|d
operator|->
name|extended
operator|==
literal|0
operator|||
operator|!
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isAffine
argument_list|()
operator|||
operator|!
name|fe
operator|->
name|supportsTransformation
argument_list|(
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
condition|)
block|{
name|staticText_d
operator|->
name|paintText
argument_list|(
name|topLeftPosition
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|engineRequiresPretransform
init|=
name|d
operator|->
name|extended
operator|->
name|requiresPretransformedGlyphPositions
argument_list|(
name|fe
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
if|if
condition|(
name|staticText_d
operator|->
name|untransformedCoordinates
operator|&&
name|engineRequiresPretransform
condition|)
block|{
comment|// The coordinates are untransformed, and the engine can't deal with that
comment|// nativly, so we have to pre-transform the static text.
name|staticText_d
operator|->
name|untransformedCoordinates
operator|=
literal|false
expr_stmt|;
name|staticText_d
operator|->
name|needsRelayout
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|staticText_d
operator|->
name|untransformedCoordinates
operator|&&
operator|!
name|engineRequiresPretransform
condition|)
block|{
comment|// The coordinates are already transformed, but the engine can handle that
comment|// nativly, so undo the transform of the static text.
name|staticText_d
operator|->
name|untransformedCoordinates
operator|=
literal|true
expr_stmt|;
name|staticText_d
operator|->
name|needsRelayout
operator|=
literal|true
expr_stmt|;
block|}
comment|// Don't recalculate entire layout because of translation, rather add the dx and dy
comment|// into the position to move each text item the correct distance.
name|QPointF
name|transformedPosition
init|=
name|topLeftPosition
decl_stmt|;
if|if
condition|(
operator|!
name|staticText_d
operator|->
name|untransformedCoordinates
condition|)
name|transformedPosition
operator|=
name|transformedPosition
operator|*
name|d
operator|->
name|state
operator|->
name|matrix
expr_stmt|;
name|QTransform
name|oldMatrix
decl_stmt|;
comment|// The translation has been applied to transformedPosition. Remove translation
comment|// component from matrix.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|isTranslating
argument_list|()
operator|&&
operator|!
name|staticText_d
operator|->
name|untransformedCoordinates
condition|)
block|{
name|qreal
name|m11
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m11
argument_list|()
decl_stmt|;
name|qreal
name|m12
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m12
argument_list|()
decl_stmt|;
name|qreal
name|m13
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m13
argument_list|()
decl_stmt|;
name|qreal
name|m21
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m21
argument_list|()
decl_stmt|;
name|qreal
name|m22
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m22
argument_list|()
decl_stmt|;
name|qreal
name|m23
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m23
argument_list|()
decl_stmt|;
name|qreal
name|m33
init|=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|m33
argument_list|()
decl_stmt|;
name|oldMatrix
operator|=
name|d
operator|->
name|state
operator|->
name|matrix
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|setMatrix
argument_list|(
name|m11
argument_list|,
name|m12
argument_list|,
name|m13
argument_list|,
name|m21
argument_list|,
name|m22
argument_list|,
name|m23
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|m33
argument_list|)
expr_stmt|;
block|}
comment|// If the transform is not identical to the text transform,
comment|// we have to relayout the text (for other transformations than plain translation)
name|bool
name|staticTextNeedsReinit
init|=
name|staticText_d
operator|->
name|needsRelayout
decl_stmt|;
if|if
condition|(
operator|!
name|staticText_d
operator|->
name|untransformedCoordinates
operator|&&
name|staticText_d
operator|->
name|matrix
operator|!=
name|d
operator|->
name|state
operator|->
name|matrix
condition|)
block|{
name|staticText_d
operator|->
name|matrix
operator|=
name|d
operator|->
name|state
operator|->
name|matrix
expr_stmt|;
name|staticTextNeedsReinit
operator|=
literal|true
expr_stmt|;
block|}
comment|// Recreate the layout of the static text because the matrix or font has changed
if|if
condition|(
name|staticTextNeedsReinit
condition|)
name|staticText_d
operator|->
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|transformedPosition
operator|!=
name|staticText_d
operator|->
name|position
condition|)
block|{
comment|// Translate to actual position
name|QFixed
name|fx
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|transformedPosition
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|QFixed
name|fy
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|transformedPosition
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|QFixed
name|oldX
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|staticText_d
operator|->
name|position
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|QFixed
name|oldY
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|staticText_d
operator|->
name|position
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|item
init|=
literal|0
init|;
name|item
operator|<
name|staticText_d
operator|->
name|itemCount
condition|;
operator|++
name|item
control|)
block|{
name|QStaticTextItem
modifier|*
name|textItem
init|=
name|staticText_d
operator|->
name|items
operator|+
name|item
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|textItem
operator|->
name|numGlyphs
condition|;
operator|++
name|i
control|)
block|{
name|textItem
operator|->
name|glyphPositions
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|fx
operator|-
name|oldX
expr_stmt|;
name|textItem
operator|->
name|glyphPositions
index|[
name|i
index|]
operator|.
name|y
operator|+=
name|fy
operator|-
name|oldY
expr_stmt|;
block|}
name|textItem
operator|->
name|userDataNeedsUpdate
operator|=
literal|true
expr_stmt|;
block|}
name|staticText_d
operator|->
name|position
operator|=
name|transformedPosition
expr_stmt|;
block|}
name|QPen
name|oldPen
init|=
name|d
operator|->
name|state
operator|->
name|pen
decl_stmt|;
name|QColor
name|currentColor
init|=
name|oldPen
operator|.
name|color
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|staticText_d
operator|->
name|itemCount
condition|;
operator|++
name|i
control|)
block|{
name|QStaticTextItem
modifier|*
name|item
init|=
name|staticText_d
operator|->
name|items
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|color
operator|.
name|isValid
argument_list|()
operator|&&
name|currentColor
operator|!=
name|item
operator|->
name|color
condition|)
block|{
name|setPen
argument_list|(
name|item
operator|->
name|color
argument_list|)
expr_stmt|;
name|currentColor
operator|=
name|item
operator|->
name|color
expr_stmt|;
block|}
name|d
operator|->
name|extended
operator|->
name|drawStaticTextItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|qt_draw_decoration_for_glyphs
argument_list|(
name|this
argument_list|,
name|item
operator|->
name|glyphs
argument_list|,
name|item
operator|->
name|glyphPositions
argument_list|,
name|item
operator|->
name|numGlyphs
argument_list|,
name|item
operator|->
name|fontEngine
argument_list|()
argument_list|,
name|staticText_d
operator|->
name|font
argument_list|,
name|QTextCharFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentColor
operator|!=
name|oldPen
operator|.
name|color
argument_list|()
condition|)
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|staticText_d
operator|->
name|untransformedCoordinates
operator|&&
name|oldMatrix
operator|.
name|isTranslating
argument_list|()
condition|)
name|d
operator|->
name|state
operator|->
name|matrix
operator|=
name|oldMatrix
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal */
end_comment
begin_function
DECL|function|drawText
name|void
name|QPainter
operator|::
name|drawText
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|tf
parameter_list|,
name|int
name|justificationPadding
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawText(), pos=[%.2f,%.2f], str='%s'\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|,
name|str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
operator|||
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|TextBypassShaping
condition|)
block|{
comment|// Skip complex shaping, shape using glyph advances only
name|int
name|len
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|numGlyphs
init|=
name|len
decl_stmt|;
name|QVarLengthGlyphLayoutArray
name|glyphs
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|fontEngine
init|=
name|d
operator|->
name|state
operator|->
name|font
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fontEngine
operator|->
name|stringToCMap
argument_list|(
name|str
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|numGlyphs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|glyphs
operator|.
name|resize
argument_list|(
name|numGlyphs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fontEngine
operator|->
name|stringToCMap
argument_list|(
name|str
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|numGlyphs
argument_list|,
literal|0
argument_list|)
condition|)
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
name|Q_FUNC_INFO
argument_list|,
literal|"stringToCMap shouldn't fail twice"
argument_list|)
expr_stmt|;
block|}
name|QTextItemInt
name|gf
argument_list|(
name|glyphs
argument_list|,
operator|&
name|d
operator|->
name|state
operator|->
name|font
argument_list|,
name|str
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
name|fontEngine
argument_list|)
decl_stmt|;
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|gf
argument_list|)
expr_stmt|;
return|return;
block|}
name|QStackTextEngine
name|engine
argument_list|(
name|str
argument_list|,
name|d
operator|->
name|state
operator|->
name|font
argument_list|)
decl_stmt|;
name|engine
operator|.
name|option
operator|.
name|setTextDirection
argument_list|(
name|d
operator|->
name|state
operator|->
name|layoutDirection
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|&
operator|(
name|Qt
operator|::
name|TextForceLeftToRight
operator||
name|Qt
operator|::
name|TextForceRightToLeft
operator|)
condition|)
block|{
name|engine
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|engine
operator|.
name|option
operator|.
name|setTextDirection
argument_list|(
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextForceLeftToRight
operator|)
condition|?
name|Qt
operator|::
name|LeftToRight
else|:
name|Qt
operator|::
name|RightToLeft
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|QScriptLine
name|line
decl_stmt|;
name|line
operator|.
name|length
operator|=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
name|engine
operator|.
name|shapeLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|int
name|nItems
init|=
name|engine
operator|.
name|layoutData
operator|->
name|items
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|visualOrder
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|uchar
argument_list|>
name|levels
argument_list|(
name|nItems
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
name|levels
index|[
name|i
index|]
operator|=
name|engine
operator|.
name|layoutData
operator|->
name|items
index|[
name|i
index|]
operator|.
name|analysis
operator|.
name|bidiLevel
expr_stmt|;
name|QTextEngine
operator|::
name|bidiReorder
argument_list|(
name|nItems
argument_list|,
name|levels
operator|.
name|data
argument_list|()
argument_list|,
name|visualOrder
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|justificationPadding
operator|>
literal|0
condition|)
block|{
name|engine
operator|.
name|option
operator|.
name|setAlignment
argument_list|(
name|Qt
operator|::
name|AlignJustify
argument_list|)
expr_stmt|;
name|engine
operator|.
name|forceJustification
operator|=
literal|true
expr_stmt|;
comment|// this works because justify() is only interested in the difference between width and textWidth
name|line
operator|.
name|width
operator|=
name|justificationPadding
expr_stmt|;
name|engine
operator|.
name|justify
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|QFixed
name|x
init|=
name|QFixed
operator|::
name|fromReal
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
block|{
name|int
name|item
init|=
name|visualOrder
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|QScriptItem
modifier|&
name|si
init|=
name|engine
operator|.
name|layoutData
operator|->
name|items
operator|.
name|at
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|>=
name|QScriptAnalysis
operator|::
name|TabOrObject
condition|)
block|{
name|x
operator|+=
name|si
operator|.
name|width
expr_stmt|;
continue|continue;
block|}
name|QFont
name|f
init|=
name|engine
operator|.
name|font
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|QTextItemInt
name|gf
argument_list|(
name|si
argument_list|,
operator|&
name|f
argument_list|)
decl_stmt|;
name|gf
operator|.
name|glyphs
operator|=
name|engine
operator|.
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|gf
operator|.
name|chars
operator|=
name|engine
operator|.
name|layoutData
operator|->
name|string
operator|.
name|unicode
argument_list|()
operator|+
name|si
operator|.
name|position
expr_stmt|;
name|gf
operator|.
name|num_chars
operator|=
name|engine
operator|.
name|length
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|.
name|forceJustification
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gf
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|;
operator|++
name|j
control|)
name|gf
operator|.
name|width
operator|+=
name|gf
operator|.
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gf
operator|.
name|width
operator|=
name|si
operator|.
name|width
expr_stmt|;
block|}
name|gf
operator|.
name|logClusters
operator|=
name|engine
operator|.
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|gf
argument_list|)
expr_stmt|;
name|x
operator|+=
name|gf
operator|.
name|width
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawText
name|void
name|QPainter
operator|::
name|drawText
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRect
modifier|*
name|br
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawText(), r=[%d,%d,%d,%d], flags=%d, str='%s'\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|flags
argument_list|,
name|str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|QRectF
name|bounds
decl_stmt|;
name|qt_format_text
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|,
name|r
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|br
condition|?
operator|&
name|bounds
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
condition|)
operator|*
name|br
operator|=
name|bounds
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawText(const QPoint&position, const QString&text)      \overload      Draws the given \a text with the currently defined text direction,     beginning at the given \a position.      By default, QPainter draws text anti-aliased.      \note The y-position is used as the baseline of the font.      \sa setFont(), setPen() */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawText(const QRectF&rectangle, int flags, const QString&text, QRectF *boundingRect)     \overload      Draws the given \a text within the provided \a rectangle.     The \a rectangle along with alignment \a flags defines the anchors for the \a text.      \table 100%     \row     \li \inlineimage qpainter-text.png     \li     \snippet code/src_gui_painting_qpainter.cpp 17     \endtable      The \a boundingRect (if not null) is set to the what the bounding rectangle     should be in order to enclose the whole text. The \a flags argument is a bitwise     OR of the following flags:      \list     \li Qt::AlignLeft     \li Qt::AlignRight     \li Qt::AlignHCenter     \li Qt::AlignJustify     \li Qt::AlignTop     \li Qt::AlignBottom     \li Qt::AlignVCenter     \li Qt::AlignCenter     \li Qt::TextDontClip     \li Qt::TextSingleLine     \li Qt::TextExpandTabs     \li Qt::TextShowMnemonic     \li Qt::TextWordWrap     \li Qt::TextIncludeTrailingSpaces     \endlist      \sa Qt::AlignmentFlag, Qt::TextFlag, boundingRect(), layoutDirection()      By default, QPainter draws text anti-aliased.      \note The y-coordinate of \a rectangle is used as the top of the font. */
end_comment
begin_function
DECL|function|drawText
name|void
name|QPainter
operator|::
name|drawText
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRectF
modifier|*
name|br
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawText(), r=[%.2f,%.2f,%.2f,%.2f], flags=%d, str='%s'\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|flags
argument_list|,
name|str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|qt_format_text
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|,
name|r
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|br
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawText(const QRect&rectangle, int flags, const QString&text, QRect *boundingRect)     \overload      Draws the given \a text within the provided \a rectangle according     to the specified \a flags. The \a boundingRect (if not null) is set to     the what the bounding rectangle should be in order to enclose the whole text.      By default, QPainter draws text anti-aliased.      \note The y-coordinate of \a rectangle is used as the top of the font.      \sa setFont(), setPen() */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawText(int x, int y, const QString&text)      \overload      Draws the given \a text at position (\a{x}, \a{y}), using the painter's     currently defined text direction.      By default, QPainter draws text anti-aliased.      \note The y-position is used as the baseline of the font.      \sa setFont(), setPen() */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawText(int x, int y, int width, int height, int flags,                                 const QString&text, QRect *boundingRect)      \overload      Draws the given \a text within the rectangle with origin (\a{x},     \a{y}), \a width and \a height.      The \a boundingRect (if not null) is set to the actual bounding     rectangle of the output.  The \a flags argument is a bitwise OR of     the following flags:      \list     \li Qt::AlignLeft     \li Qt::AlignRight     \li Qt::AlignHCenter     \li Qt::AlignJustify     \li Qt::AlignTop     \li Qt::AlignBottom     \li Qt::AlignVCenter     \li Qt::AlignCenter     \li Qt::TextSingleLine     \li Qt::TextExpandTabs     \li Qt::TextShowMnemonic     \li Qt::TextWordWrap     \endlist      By default, QPainter draws text anti-aliased.      \note The y-position is used as the top of the font.      \sa Qt::AlignmentFlag, Qt::TextFlag, setFont(), setPen() */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawText(const QRectF&rectangle, const QString&text,         const QTextOption&option)     \overload      Draws the given \a text in the \a rectangle specified using the \a option     to control its positioning and orientation.      By default, QPainter draws text anti-aliased.      \note The y-coordinate of \a rectangle is used as the top of the font.      \sa setFont(), setPen() */
end_comment
begin_function
DECL|function|drawText
name|void
name|QPainter
operator|::
name|drawText
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QTextOption
modifier|&
name|o
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawText(), r=[%.2f,%.2f,%.2f,%.2f], str='%s'\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|text
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|qt_format_text
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|,
name|r
argument_list|,
literal|0
argument_list|,
operator|&
name|o
argument_list|,
name|text
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawTextItem(int x, int y, const QTextItem&ti)      \internal     \overload */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawTextItem(const QPoint&p, const QTextItem&ti)      \internal     \overload      Draws the text item \a ti at position \a p. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawTextItem(const QPointF&p, const QTextItem&ti)      \internal     \since 4.1      Draws the text item \a ti at position \a p.      This method ignores the painters background mode and     color. drawText and qt_format_text have to do it themselves, as     only they know the extents of the complete string.      It ignores the font set on the painter as the text item has one of its own.      The underline and strikeout parameters of the text items font are     ignored aswell. You'll need to pass in the correct flags to get     underlining and strikeout. */
end_comment
begin_function
DECL|function|generateWavyPixmap
specifier|static
name|QPixmap
name|generateWavyPixmap
parameter_list|(
name|qreal
name|maxRadius
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
specifier|const
name|qreal
name|radiusBase
init|=
name|qMax
argument_list|(
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|maxRadius
argument_list|)
decl_stmt|;
name|QString
name|key
init|=
name|QLatin1String
argument_list|(
literal|"WaveUnderline-"
argument_list|)
operator|%
name|pen
operator|.
name|color
argument_list|()
operator|.
name|name
argument_list|()
operator|%
name|HexString
argument_list|<
name|qreal
argument_list|>
argument_list|(
name|radiusBase
argument_list|)
decl_stmt|;
name|QPixmap
name|pixmap
decl_stmt|;
if|if
condition|(
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
argument_list|,
name|pixmap
argument_list|)
condition|)
return|return
name|pixmap
return|;
specifier|const
name|qreal
name|halfPeriod
init|=
name|qMax
argument_list|(
name|qreal
argument_list|(
literal|2
argument_list|)
argument_list|,
name|qreal
argument_list|(
name|radiusBase
operator|*
literal|1.61803399
argument_list|)
argument_list|)
decl_stmt|;
comment|// the golden ratio
specifier|const
name|int
name|width
init|=
name|qCeil
argument_list|(
literal|100
operator|/
operator|(
literal|2
operator|*
name|halfPeriod
operator|)
argument_list|)
operator|*
operator|(
literal|2
operator|*
name|halfPeriod
operator|)
decl_stmt|;
specifier|const
name|int
name|radius
init|=
name|qFloor
argument_list|(
name|radiusBase
argument_list|)
decl_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|qreal
name|xs
init|=
literal|0
decl_stmt|;
name|qreal
name|ys
init|=
name|radius
decl_stmt|;
while|while
condition|(
name|xs
operator|<
name|width
condition|)
block|{
name|xs
operator|+=
name|halfPeriod
expr_stmt|;
name|ys
operator|=
operator|-
name|ys
expr_stmt|;
name|path
operator|.
name|quadTo
argument_list|(
name|xs
operator|-
name|halfPeriod
operator|/
literal|2
argument_list|,
name|ys
argument_list|,
name|xs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pixmap
operator|=
name|QPixmap
argument_list|(
name|width
argument_list|,
name|radius
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
block|{
name|QPen
name|wavePen
init|=
name|pen
decl_stmt|;
name|wavePen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|SquareCap
argument_list|)
expr_stmt|;
comment|// This is to protect against making the line too fat, as happens on Mac OS X
comment|// due to it having a rather thick width for the regular underline.
specifier|const
name|qreal
name|maxPenWidth
init|=
literal|.8
operator|*
name|radius
decl_stmt|;
if|if
condition|(
name|wavePen
operator|.
name|widthF
argument_list|()
operator|>
name|maxPenWidth
condition|)
name|wavePen
operator|.
name|setWidth
argument_list|(
name|maxPenWidth
argument_list|)
expr_stmt|;
name|QPainter
name|imgPainter
argument_list|(
operator|&
name|pixmap
argument_list|)
decl_stmt|;
name|imgPainter
operator|.
name|setPen
argument_list|(
name|wavePen
argument_list|)
expr_stmt|;
name|imgPainter
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
name|imgPainter
operator|.
name|translate
argument_list|(
literal|0
argument_list|,
name|radius
argument_list|)
expr_stmt|;
name|imgPainter
operator|.
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|key
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_function
DECL|function|drawTextItemDecoration
specifier|static
name|void
name|drawTextItemDecoration
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QFontEngine
modifier|*
name|fe
parameter_list|,
name|QTextEngine
modifier|*
name|textEngine
parameter_list|,
name|QTextCharFormat
operator|::
name|UnderlineStyle
name|underlineStyle
parameter_list|,
name|QTextItem
operator|::
name|RenderFlags
name|flags
parameter_list|,
name|qreal
name|width
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|charFormat
parameter_list|)
block|{
if|if
condition|(
name|underlineStyle
operator|==
name|QTextCharFormat
operator|::
name|NoUnderline
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|(
name|QTextItem
operator|::
name|StrikeOut
operator||
name|QTextItem
operator|::
name|Overline
operator|)
operator|)
condition|)
return|return;
specifier|const
name|QPen
name|oldPen
init|=
name|painter
operator|->
name|pen
argument_list|()
decl_stmt|;
specifier|const
name|QBrush
name|oldBrush
init|=
name|painter
operator|->
name|brush
argument_list|()
decl_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|QPen
name|pen
init|=
name|oldPen
decl_stmt|;
name|pen
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|SolidLine
argument_list|)
expr_stmt|;
name|pen
operator|.
name|setWidthF
argument_list|(
name|fe
operator|->
name|lineThickness
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|pen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|FlatCap
argument_list|)
expr_stmt|;
name|QLineF
name|line
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
name|pos
operator|.
name|x
argument_list|()
operator|+
name|qFloor
argument_list|(
name|width
argument_list|)
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|wasCompatiblePainting
init|=
name|painter
operator|->
name|renderHints
argument_list|()
operator|&
name|QPainter
operator|::
name|Qt4CompatiblePainting
decl_stmt|;
if|if
condition|(
name|wasCompatiblePainting
condition|)
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Qt4CompatiblePainting
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|underlineOffset
init|=
name|fe
operator|->
name|underlinePosition
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
comment|// deliberately ceil the offset to avoid the underline coming too close to
comment|// the text above it.
specifier|const
name|qreal
name|underlinePos
init|=
name|pos
operator|.
name|y
argument_list|()
operator|+
name|qCeil
argument_list|(
name|underlineOffset
argument_list|)
operator|+
literal|0.5
decl_stmt|;
if|if
condition|(
name|underlineStyle
operator|==
name|QTextCharFormat
operator|::
name|SpellCheckUnderline
condition|)
block|{
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|theme
condition|)
name|underlineStyle
operator|=
name|QTextCharFormat
operator|::
name|UnderlineStyle
argument_list|(
name|theme
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|SpellCheckUnderlineStyle
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|underlineStyle
operator|==
name|QTextCharFormat
operator|::
name|WaveUnderline
condition|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|translate
argument_list|(
literal|0
argument_list|,
name|pos
operator|.
name|y
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QColor
name|uc
init|=
name|charFormat
operator|.
name|underlineColor
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|.
name|isValid
argument_list|()
condition|)
name|pen
operator|.
name|setColor
argument_list|(
name|uc
argument_list|)
expr_stmt|;
comment|// Adapt wave to underlineOffset or pen width, whatever is larger, to make it work on all platforms
specifier|const
name|QPixmap
name|wave
init|=
name|generateWavyPixmap
argument_list|(
name|qMax
argument_list|(
name|underlineOffset
argument_list|,
name|pen
operator|.
name|widthF
argument_list|()
argument_list|)
argument_list|,
name|pen
argument_list|)
decl_stmt|;
specifier|const
name|int
name|descent
init|=
operator|(
name|int
operator|)
name|fe
operator|->
name|descent
argument_list|()
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
name|painter
operator|->
name|brushOrigin
argument_list|()
operator|.
name|x
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|painter
operator|->
name|fillRect
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
literal|0
argument_list|,
name|qCeil
argument_list|(
name|width
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|wave
operator|.
name|height
argument_list|()
argument_list|,
name|descent
argument_list|)
argument_list|,
name|wave
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|underlineStyle
operator|!=
name|QTextCharFormat
operator|::
name|NoUnderline
condition|)
block|{
name|QColor
name|uc
init|=
name|charFormat
operator|.
name|underlineColor
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|.
name|isValid
argument_list|()
condition|)
name|pen
operator|.
name|setColor
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|pen
operator|.
name|setStyle
argument_list|(
call|(
name|Qt
operator|::
name|PenStyle
call|)
argument_list|(
name|underlineStyle
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|QLineF
name|underline
argument_list|(
name|line
operator|.
name|x1
argument_list|()
argument_list|,
name|underlinePos
argument_list|,
name|line
operator|.
name|x2
argument_list|()
argument_list|,
name|underlinePos
argument_list|)
decl_stmt|;
if|if
condition|(
name|textEngine
condition|)
name|textEngine
operator|->
name|addUnderline
argument_list|(
name|painter
argument_list|,
name|underline
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|drawLine
argument_list|(
name|underline
argument_list|)
expr_stmt|;
block|}
name|pen
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|SolidLine
argument_list|)
expr_stmt|;
name|pen
operator|.
name|setColor
argument_list|(
name|oldPen
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QTextItem
operator|::
name|StrikeOut
condition|)
block|{
name|QLineF
name|strikeOutLine
init|=
name|line
decl_stmt|;
name|strikeOutLine
operator|.
name|translate
argument_list|(
literal|0.
argument_list|,
operator|-
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
operator|/
literal|3.
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
if|if
condition|(
name|textEngine
condition|)
name|textEngine
operator|->
name|addStrikeOut
argument_list|(
name|painter
argument_list|,
name|strikeOutLine
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|drawLine
argument_list|(
name|strikeOutLine
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|QTextItem
operator|::
name|Overline
condition|)
block|{
name|QLineF
name|overline
init|=
name|line
decl_stmt|;
name|overline
operator|.
name|translate
argument_list|(
literal|0.
argument_list|,
operator|-
name|fe
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
if|if
condition|(
name|textEngine
condition|)
name|textEngine
operator|->
name|addOverline
argument_list|(
name|painter
argument_list|,
name|overline
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|drawLine
argument_list|(
name|overline
argument_list|)
expr_stmt|;
block|}
name|painter
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasCompatiblePainting
condition|)
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Qt4CompatiblePainting
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_draw_decoration_for_glyphs
name|Q_GUI_EXPORT
name|void
name|qt_draw_decoration_for_glyphs
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|glyph_t
modifier|*
name|glyphArray
parameter_list|,
specifier|const
name|QFixedPoint
modifier|*
name|positions
parameter_list|,
name|int
name|glyphCount
parameter_list|,
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|charFormat
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|font
operator|.
name|underline
argument_list|()
operator|||
name|font
operator|.
name|strikeOut
argument_list|()
operator|||
name|font
operator|.
name|overline
argument_list|()
operator|)
condition|)
return|return;
name|QFixed
name|leftMost
decl_stmt|;
name|QFixed
name|rightMost
decl_stmt|;
name|QFixed
name|baseLine
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
operator|++
name|i
control|)
block|{
name|glyph_metrics_t
name|gm
init|=
name|fontEngine
operator|->
name|boundingBox
argument_list|(
name|glyphArray
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|leftMost
operator|>
name|positions
index|[
name|i
index|]
operator|.
name|x
condition|)
name|leftMost
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
comment|// We don't support glyphs that do not share a common baseline. If this turns out to
comment|// be a relevant use case, then we need to find clusters of glyphs that share a baseline
comment|// and do a drawTextItemDecoration call per cluster.
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|baseLine
operator|<
name|positions
index|[
name|i
index|]
operator|.
name|y
condition|)
name|baseLine
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
comment|// We use the advance rather than the actual bounds to match the algorithm in drawText()
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|rightMost
operator|<
name|positions
index|[
name|i
index|]
operator|.
name|x
operator|+
name|gm
operator|.
name|xoff
condition|)
name|rightMost
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|x
operator|+
name|gm
operator|.
name|xoff
expr_stmt|;
block|}
name|QFixed
name|width
init|=
name|rightMost
operator|-
name|leftMost
decl_stmt|;
name|QTextItem
operator|::
name|RenderFlags
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|font
operator|.
name|underline
argument_list|()
condition|)
name|flags
operator||=
name|QTextItem
operator|::
name|Underline
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|overline
argument_list|()
condition|)
name|flags
operator||=
name|QTextItem
operator|::
name|Overline
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|strikeOut
argument_list|()
condition|)
name|flags
operator||=
name|QTextItem
operator|::
name|StrikeOut
expr_stmt|;
name|drawTextItemDecoration
argument_list|(
name|painter
argument_list|,
name|QPointF
argument_list|(
name|leftMost
operator|.
name|toReal
argument_list|()
argument_list|,
name|baseLine
operator|.
name|toReal
argument_list|()
argument_list|)
argument_list|,
name|fontEngine
argument_list|,
literal|0
argument_list|,
comment|// textEngine
name|font
operator|.
name|underline
argument_list|()
condition|?
name|QTextCharFormat
operator|::
name|SingleUnderline
else|:
name|QTextCharFormat
operator|::
name|NoUnderline
argument_list|,
name|flags
argument_list|,
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|charFormat
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawTextItem
name|void
name|QPainter
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItem
modifier|&
name|ti
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|d
operator|->
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|ti
argument_list|,
cast|static_cast
argument_list|<
name|QTextEngine
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawTextItem
name|void
name|QPainterPrivate
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItem
modifier|&
name|_ti
parameter_list|,
name|QTextEngine
modifier|*
name|textEngine
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawTextItem(), pos=[%.f,%.f], str='%s'\n"
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|_ti
operator|.
name|text
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_Q
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qt_painter_thread_test
argument_list|(
name|device
operator|->
name|devType
argument_list|()
argument_list|,
literal|"text and fonts"
argument_list|,
name|QFontDatabase
operator|::
name|supportsThreadedFontRendering
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QTextItemInt
modifier|&
name|ti
init|=
cast|const_cast
argument_list|<
name|QTextItemInt
operator|&
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|&
argument_list|>
argument_list|(
name|_ti
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extended
operator|&&
name|state
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
condition|)
block|{
name|QRectF
name|rect
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
operator|-
name|ti
operator|.
name|ascent
operator|.
name|toReal
argument_list|()
argument_list|,
name|ti
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
operator|(
name|ti
operator|.
name|ascent
operator|+
name|ti
operator|.
name|descent
operator|+
literal|1
operator|)
operator|.
name|toReal
argument_list|()
argument_list|)
decl_stmt|;
name|q
operator|->
name|fillRect
argument_list|(
name|rect
argument_list|,
name|state
operator|->
name|bgBrush
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|pen
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
specifier|const
name|QPainter
operator|::
name|RenderHints
name|oldRenderHints
init|=
name|state
operator|->
name|renderHints
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|Antialiasing
operator|&&
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
comment|// draw antialias decoration (underline/overline/strikeout) with
comment|// transformed text
name|bool
name|aa
init|=
literal|true
decl_stmt|;
specifier|const
name|QTransform
modifier|&
name|m
init|=
name|state
operator|->
name|matrix
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<
name|QTransform
operator|::
name|TxShear
condition|)
block|{
name|bool
name|isPlain90DegreeRotation
init|=
operator|(
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m11
argument_list|()
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m12
argument_list|()
operator|-
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m21
argument_list|()
operator|+
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m22
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m11
argument_list|()
operator|+
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m12
argument_list|()
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m21
argument_list|()
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m22
argument_list|()
operator|+
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m11
argument_list|()
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m12
argument_list|()
operator|+
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m21
argument_list|()
operator|-
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|m
operator|.
name|m22
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|aa
operator|=
operator|!
name|isPlain90DegreeRotation
expr_stmt|;
block|}
if|if
condition|(
name|aa
condition|)
name|q
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extended
condition|)
name|updateState
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ti
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|)
block|{
comment|// nothing to do
block|}
elseif|else
if|if
condition|(
name|ti
operator|.
name|fontEngine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Multi
condition|)
block|{
name|QFontEngineMulti
modifier|*
name|multi
init|=
cast|static_cast
argument_list|<
name|QFontEngineMulti
operator|*
argument_list|>
argument_list|(
name|ti
operator|.
name|fontEngine
argument_list|)
decl_stmt|;
specifier|const
name|QGlyphLayout
modifier|&
name|glyphs
init|=
name|ti
operator|.
name|glyphs
decl_stmt|;
name|int
name|which
init|=
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
operator|>>
literal|24
decl_stmt|;
name|qreal
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|bool
name|rtl
init|=
name|ti
operator|.
name|flags
operator|&
name|QTextItem
operator|::
name|RightToLeft
decl_stmt|;
if|if
condition|(
name|rtl
condition|)
name|x
operator|+=
name|ti
operator|.
name|width
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|end
operator|=
literal|0
init|;
name|end
operator|<
name|ti
operator|.
name|glyphs
operator|.
name|numGlyphs
condition|;
operator|++
name|end
control|)
block|{
specifier|const
name|int
name|e
init|=
name|glyphs
operator|.
name|glyphs
index|[
name|end
index|]
operator|>>
literal|24
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|which
condition|)
continue|continue;
name|QTextItemInt
name|ti2
init|=
name|ti
operator|.
name|midItem
argument_list|(
name|multi
operator|->
name|engine
argument_list|(
name|which
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|ti2
operator|.
name|width
operator|=
literal|0
expr_stmt|;
comment|// set the high byte to zero and calc the width
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|=
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|&
literal|0xffffff
expr_stmt|;
name|ti2
operator|.
name|width
operator|+=
name|ti
operator|.
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl
condition|)
name|x
operator|-=
name|ti2
operator|.
name|width
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|engine
operator|->
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|ti2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtl
condition|)
name|x
operator|+=
name|ti2
operator|.
name|width
operator|.
name|toReal
argument_list|()
expr_stmt|;
comment|// reset the high byte for all glyphs and advance to the next sub-string
specifier|const
name|int
name|hi
init|=
name|which
operator|<<
literal|24
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|=
name|hi
operator||
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
expr_stmt|;
block|}
comment|// change engine
name|start
operator|=
name|end
expr_stmt|;
name|which
operator|=
name|e
expr_stmt|;
block|}
name|QTextItemInt
name|ti2
init|=
name|ti
operator|.
name|midItem
argument_list|(
name|multi
operator|->
name|engine
argument_list|(
name|which
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|ti2
operator|.
name|width
operator|=
literal|0
expr_stmt|;
comment|// set the high byte to zero and calc the width
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|=
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|&
literal|0xffffff
expr_stmt|;
name|ti2
operator|.
name|width
operator|+=
name|ti
operator|.
name|glyphs
operator|.
name|effectiveAdvance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl
condition|)
name|x
operator|-=
name|ti2
operator|.
name|width
operator|.
name|toReal
argument_list|()
expr_stmt|;
if|if
condition|(
name|extended
condition|)
name|extended
operator|->
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|ti2
argument_list|)
expr_stmt|;
else|else
name|engine
operator|->
name|drawTextItem
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|ti2
argument_list|)
expr_stmt|;
comment|// reset the high byte for all glyphs
specifier|const
name|int
name|hi
init|=
name|which
operator|<<
literal|24
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
operator|=
name|hi
operator||
name|glyphs
operator|.
name|glyphs
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|extended
condition|)
name|extended
operator|->
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|ti
argument_list|)
expr_stmt|;
else|else
name|engine
operator|->
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
name|drawTextItemDecoration
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|ti
operator|.
name|fontEngine
argument_list|,
name|textEngine
argument_list|,
name|ti
operator|.
name|underlineStyle
argument_list|,
name|ti
operator|.
name|flags
argument_list|,
name|ti
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|ti
operator|.
name|charFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|renderHints
operator|!=
name|oldRenderHints
condition|)
block|{
name|state
operator|->
name|renderHints
operator|=
name|oldRenderHints
expr_stmt|;
if|if
condition|(
name|extended
condition|)
name|extended
operator|->
name|renderHintsChanged
argument_list|()
expr_stmt|;
else|else
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyHints
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QPainter::boundingRect(const QRectF&rectangle, int flags, const QString&text)      Returns the bounding rectangle of the \a text as it will appear     when drawn inside the given \a rectangle with the specified \a     flags using the currently set font(); i.e the function tells you     where the drawText() function will draw when given the same     arguments.      If the \a text does not fit within the given \a rectangle using     the specified \a flags, the function returns the required     rectangle.      The \a flags argument is a bitwise OR of the following flags:     \list          \li Qt::AlignLeft          \li Qt::AlignRight          \li Qt::AlignHCenter          \li Qt::AlignTop          \li Qt::AlignBottom          \li Qt::AlignVCenter          \li Qt::AlignCenter          \li Qt::TextSingleLine          \li Qt::TextExpandTabs          \li Qt::TextShowMnemonic          \li Qt::TextWordWrap          \li Qt::TextIncludeTrailingSpaces     \endlist     If several of the horizontal or several of the vertical alignment     flags are set, the resulting alignment is undefined.      \sa drawText(), Qt::Alignment, Qt::TextFlag */
end_comment
begin_comment
comment|/*!     \fn QRect QPainter::boundingRect(const QRect&rectangle, int flags,                                      const QString&text)      \overload      Returns the bounding rectangle of the \a text as it will appear     when drawn inside the given \a rectangle with the specified \a     flags using the currently set font(). */
end_comment
begin_comment
comment|/*!     \fn QRect QPainter::boundingRect(int x, int y, int w, int h, int flags,                                      const QString&text);      \overload      Returns the bounding rectangle of the given \a text as it will     appear when drawn inside the rectangle beginning at the point     (\a{x}, \a{y}) with width \a w and height \a h. */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QPainter
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QRect
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|QRect
name|brect
decl_stmt|;
name|drawText
argument_list|(
name|rect
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextDontPrint
argument_list|,
name|str
argument_list|,
operator|&
name|brect
argument_list|)
expr_stmt|;
return|return
name|brect
return|;
block|}
end_function
begin_function
DECL|function|boundingRect
name|QRectF
name|QPainter
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QRectF
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|QRectF
name|brect
decl_stmt|;
name|drawText
argument_list|(
name|rect
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextDontPrint
argument_list|,
name|str
argument_list|,
operator|&
name|brect
argument_list|)
expr_stmt|;
return|return
name|brect
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QPainter::boundingRect(const QRectF&rectangle,         const QString&text, const QTextOption&option)      \overload      Instead of specifying flags as a bitwise OR of the     Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes     an \a option argument. The QTextOption class provides a     description of general rich text properties.      \sa QTextOption */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QPainter
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QTextOption
modifier|&
name|o
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QRectF
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|QRectF
name|br
decl_stmt|;
name|qt_format_text
argument_list|(
name|d
operator|->
name|state
operator|->
name|font
argument_list|,
name|r
argument_list|,
name|Qt
operator|::
name|TextDontPrint
argument_list|,
operator|&
name|o
argument_list|,
name|text
argument_list|,
operator|&
name|br
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|br
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawTiledPixmap(const QRectF&rectangle, const QPixmap&pixmap, const QPointF&position)      Draws a tiled \a pixmap, inside the given \a rectangle with its     origin at the given \a position.      Calling drawTiledPixmap() is similar to calling drawPixmap()     several times to fill (tile) an area with a pixmap, but is     potentially much more efficient depending on the underlying window     system.      \sa drawPixmap() */
end_comment
begin_function
DECL|function|drawTiledPixmap
name|void
name|QPainter
operator|::
name|drawTiledPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::drawTiledPixmap(), target=[%.2f,%.2f,%.2f,%.2f], pix=[%d,%d], offset=[%.2f,%.2f]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pixmap
operator|.
name|width
argument_list|()
argument_list|,
name|pixmap
operator|.
name|height
argument_list|()
argument_list|,
name|sp
operator|.
name|x
argument_list|()
argument_list|,
name|sp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pixmap
operator|.
name|isNull
argument_list|()
operator|||
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qt_painter_thread_test
argument_list|(
name|d
operator|->
name|device
operator|->
name|devType
argument_list|()
argument_list|,
literal|"drawTiledPixmap()"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qreal
name|sw
init|=
name|pixmap
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|sh
init|=
name|pixmap
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|sx
init|=
name|sp
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|sy
init|=
name|sp
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
name|sx
operator|=
name|qRound
argument_list|(
name|sw
argument_list|)
operator|-
name|qRound
argument_list|(
operator|-
name|sx
argument_list|)
operator|%
name|qRound
argument_list|(
name|sw
argument_list|)
expr_stmt|;
else|else
name|sx
operator|=
name|qRound
argument_list|(
name|sx
argument_list|)
operator|%
name|qRound
argument_list|(
name|sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|sy
operator|<
literal|0
condition|)
name|sy
operator|=
name|qRound
argument_list|(
name|sh
argument_list|)
operator|-
operator|-
name|qRound
argument_list|(
name|sy
argument_list|)
operator|%
name|qRound
argument_list|(
name|sh
argument_list|)
expr_stmt|;
else|else
name|sy
operator|=
name|qRound
argument_list|(
name|sy
argument_list|)
operator|%
name|qRound
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawTiledPixmap
argument_list|(
name|r
argument_list|,
name|pixmap
argument_list|,
name|QPointF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|bgMode
operator|==
name|Qt
operator|::
name|OpaqueMode
operator|&&
name|pixmap
operator|.
name|isQBitmap
argument_list|()
condition|)
name|fillRect
argument_list|(
name|r
argument_list|,
name|d
operator|->
name|state
operator|->
name|bgBrush
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
operator|)
operator|||
operator|(
name|d
operator|->
name|state
operator|->
name|opacity
operator|!=
literal|1.0
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|ConstantOpacity
argument_list|)
operator|)
condition|)
block|{
name|save
argument_list|()
expr_stmt|;
name|setBackgroundMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
expr_stmt|;
name|setRenderHint
argument_list|(
name|Antialiasing
argument_list|,
name|renderHints
argument_list|()
operator|&
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|QBrush
argument_list|(
name|d
operator|->
name|state
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
name|pixmap
argument_list|)
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
comment|// If there is no rotation involved we have to make sure we use the
comment|// antialiased and not the aliased coordinate system by rounding the coordinates.
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
specifier|const
name|QPointF
name|p
init|=
name|roundInDeviceCoordinates
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|,
name|d
operator|->
name|state
operator|->
name|matrix
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
name|sx
operator|=
name|qRound
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|sy
operator|=
name|qRound
argument_list|(
name|sy
argument_list|)
expr_stmt|;
block|}
name|setBrushOrigin
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|-
name|sx
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|-
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|QRectF
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setBrushOrigin
argument_list|(
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|-
name|sx
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|-
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|drawRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|restore
argument_list|()
expr_stmt|;
return|return;
block|}
name|qreal
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
operator|&&
operator|!
name|d
operator|->
name|engine
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PixmapTransform
argument_list|)
condition|)
block|{
name|x
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dx
argument_list|()
expr_stmt|;
name|y
operator|+=
name|d
operator|->
name|state
operator|->
name|matrix
operator|.
name|dy
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|drawTiledPixmap
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|pixmap
argument_list|,
name|QPointF
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPainter::drawTiledPixmap(const QRect&rectangle, const QPixmap&pixmap,                                   const QPoint&position = QPoint())     \overload      Draws a tiled \a pixmap, inside the given \a rectangle with its     origin at the given \a position. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawTiledPixmap(int x, int y, int width, int height, const          QPixmap&pixmap, int sx, int sy);     \overload      Draws a tiled \a pixmap in the specified rectangle.      (\a{x}, \a{y}) specifies the top-left point in the paint device     that is to be drawn onto; with the given \a width and \a     height. (\a{sx}, \a{sy}) specifies the top-left point in the \a     pixmap that is to be drawn; this defaults to (0, 0). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
end_ifndef
begin_comment
comment|/*!     \fn void QPainter::drawPicture(const QPointF&point, const QPicture&picture)      Replays the given \a picture at the given \a point.      The QPicture class is a paint device that records and replays     QPainter commands. A picture serializes the painter commands to an     IO device in a platform-independent format. Everything that can be     painted on a widget or pixmap can also be stored in a picture.      This function does exactly the same as QPicture::play() when     called with \a point = QPoint(0, 0).      \table 100%     \row     \li     \snippet code/src_gui_painting_qpainter.cpp 18     \endtable      \sa QPicture::play() */
end_comment
begin_function
DECL|function|drawPicture
name|void
name|QPainter
operator|::
name|drawPicture
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QPicture
modifier|&
name|picture
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|updateState
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|save
argument_list|()
expr_stmt|;
name|translate
argument_list|(
name|p
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPicture
operator|*
argument_list|>
argument_list|(
operator|&
name|picture
argument_list|)
operator|->
name|play
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawPicture(const QPoint&point, const QPicture&picture)     \overload      Replays the given \a picture at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawPicture(int x, int y, const QPicture&picture)     \overload      Draws the given \a picture at point (\a x, \a y). */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PICTURE
end_comment
begin_comment
comment|/*!     \fn void QPainter::eraseRect(const QRectF&rectangle)      Erases the area inside the given \a rectangle. Equivalent to     calling     \snippet code/src_gui_painting_qpainter.cpp 19      \sa fillRect() */
end_comment
begin_function
DECL|function|eraseRect
name|void
name|QPainter
operator|::
name|eraseRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
name|fillRect
argument_list|(
name|r
argument_list|,
name|d
operator|->
name|state
operator|->
name|bgBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|needsResolving
specifier|static
specifier|inline
name|bool
name|needsResolving
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Qt
operator|::
name|BrushStyle
name|s
init|=
name|brush
operator|.
name|style
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|s
operator|==
name|Qt
operator|::
name|LinearGradientPattern
operator|||
name|s
operator|==
name|Qt
operator|::
name|RadialGradientPattern
operator|||
name|s
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
operator|)
operator|&&
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::eraseRect(const QRect&rectangle)     \overload      Erases the area inside the given  \a rectangle. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::eraseRect(int x, int y, int width, int height)     \overload      Erases the area inside the rectangle beginning at (\a x, \a y)     with the given \a width and \a height. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(int x, int y, int width, int height, Qt::BrushStyle style)     \overload      Fills the rectangle beginning at (\a{x}, \a{y}) with the given \a     width and \a height, using the brush \a style specified.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRect&rectangle, Qt::BrushStyle style)     \overload      Fills the given \a rectangle  with the brush \a style specified.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRectF&rectangle, Qt::BrushStyle style)     \overload      Fills the given \a rectangle  with the brush \a style specified.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRectF&rectangle, const QBrush&brush)      Fills the given \a rectangle  with the \a brush specified.      Alternatively, you can specify a QColor instead of a QBrush; the     QBrush constructor (taking a QColor argument) will automatically     create a solid pattern brush.      \sa drawRect() */
end_comment
begin_function
DECL|function|fillRect
name|void
name|QPainter
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
name|g
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|LogicalMode
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|fillRect
argument_list|(
name|r
argument_list|,
name|brush
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QPen
name|oldPen
init|=
name|pen
argument_list|()
decl_stmt|;
name|QBrush
name|oldBrush
init|=
name|this
operator|->
name|brush
argument_list|()
decl_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|d
operator|->
name|colorBrush
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|SolidPattern
argument_list|)
expr_stmt|;
name|d
operator|->
name|colorBrush
operator|.
name|setColor
argument_list|(
name|brush
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|d
operator|->
name|colorBrush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
block|}
name|drawRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRect&rectangle, const QBrush&brush)     \overload      Fills the given \a rectangle with the specified \a brush. */
end_comment
begin_function
DECL|function|fillRect
name|void
name|QPainter
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|brush
operator|.
name|gradient
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
name|g
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|LogicalMode
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|fillRect
argument_list|(
name|r
argument_list|,
name|brush
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QPen
name|oldPen
init|=
name|pen
argument_list|()
decl_stmt|;
name|QBrush
name|oldBrush
init|=
name|this
operator|->
name|brush
argument_list|()
decl_stmt|;
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|d
operator|->
name|colorBrush
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|SolidPattern
argument_list|)
expr_stmt|;
name|d
operator|->
name|colorBrush
operator|.
name|setColor
argument_list|(
name|brush
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|d
operator|->
name|colorBrush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
block|}
name|drawRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRect&rectangle, const QColor&color)     \overload      Fills the given \a rectangle with the \a color specified.      \since 4.5 */
end_comment
begin_function
DECL|function|fillRect
name|void
name|QPainter
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|fillRect
argument_list|(
name|r
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return;
block|}
name|fillRect
argument_list|(
name|r
argument_list|,
name|QBrush
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRectF&rectangle, const QColor&color)     \overload      Fills the given \a rectangle with the \a color specified.      \since 4.5 */
end_comment
begin_function
DECL|function|fillRect
name|void
name|QPainter
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|fillRect
argument_list|(
name|r
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return;
block|}
name|fillRect
argument_list|(
name|r
argument_list|,
name|QBrush
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::fillRect(int x, int y, int width, int height, const QBrush&brush)      \overload      Fills the rectangle beginning at (\a{x}, \a{y}) with the given \a     width and \a height, using the given \a brush. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(int x, int y, int width, int height, const QColor&color)      \overload      Fills the rectangle beginning at (\a{x}, \a{y}) with the given \a     width and \a height, using the given \a color.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(int x, int y, int width, int height, Qt::GlobalColor color)      \overload      Fills the rectangle beginning at (\a{x}, \a{y}) with the given \a     width and \a height, using the given \a color.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRect&rectangle, Qt::GlobalColor color);      \overload      Fills the given \a rectangle with the specified \a color.      \since 4.5 */
end_comment
begin_comment
comment|/*!     \fn void QPainter::fillRect(const QRectF&rectangle, Qt::GlobalColor color);      \overload      Fills the given \a rectangle with the specified \a color.      \since 4.5 */
end_comment
begin_comment
comment|/*!     Sets the given render \a hint on the painter if \a on is true;     otherwise clears the render hint.      \sa setRenderHints(), renderHints(), {QPainter#Rendering     Quality}{Rendering Quality} */
end_comment
begin_function
DECL|function|setRenderHint
name|void
name|QPainter
operator|::
name|setRenderHint
parameter_list|(
name|RenderHint
name|hint
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setRenderHint: hint=%x, %s\n"
argument_list|,
name|hint
argument_list|,
name|on
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
specifier|static
specifier|const
name|bool
name|antialiasingDisabled
init|=
name|qgetenv
argument_list|(
literal|"QT_NO_ANTIALIASING"
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|hint
operator|==
name|QPainter
operator|::
name|Antialiasing
operator|&&
name|antialiasingDisabled
condition|)
return|return;
endif|#
directive|endif
name|setRenderHints
argument_list|(
name|hint
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the given render \a hints on the painter if \a on is true;     otherwise clears the render hints.      \sa setRenderHint(), renderHints(), {QPainter#Rendering     Quality}{Rendering Quality} */
end_comment
begin_function
DECL|function|setRenderHints
name|void
name|QPainter
operator|::
name|setRenderHints
parameter_list|(
name|RenderHints
name|hints
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setRenderHint: Painter must be active to set rendering hints"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|on
condition|)
name|d
operator|->
name|state
operator|->
name|renderHints
operator||=
name|hints
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|renderHints
operator|&=
operator|~
name|hints
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|renderHintsChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyHints
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a flag that specifies the rendering hints that are set for     this painter.      \sa testRenderHint(), {QPainter#Rendering Quality}{Rendering Quality} */
end_comment
begin_function
DECL|function|renderHints
name|QPainter
operator|::
name|RenderHints
name|QPainter
operator|::
name|renderHints
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|state
operator|->
name|renderHints
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPainter::testRenderHint(RenderHint hint) const     \since 4.3      Returns true if \a hint is set; otherwise returns false.      \sa renderHints(), setRenderHint() */
end_comment
begin_comment
comment|/*!     Returns true if view transformation is enabled; otherwise returns     false.      \sa setViewTransformEnabled(), worldTransform() */
end_comment
begin_function
DECL|function|viewTransformEnabled
name|bool
name|QPainter
operator|::
name|viewTransformEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::viewTransformEnabled: Painter not active"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|VxF
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setWindow(const QRect&rectangle)      Sets the painter's window to the given \a rectangle, and enables     view transformations.      The window rectangle is part of the view transformation. The     window specifies the logical coordinate system. Its sister, the     viewport(), specifies the device coordinate system.      The default window rectangle is the same as the device's     rectangle.      \sa window(), viewTransformEnabled(), {Coordinate     System#Window-Viewport Conversion}{Window-Viewport Conversion} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::setWindow(int x, int y, int width, int height)     \overload      Sets the painter's window to the rectangle beginning at (\a x, \a     y) and the given \a width and \a height. */
end_comment
begin_function
DECL|function|setWindow
name|void
name|QPainter
operator|::
name|setWindow
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setWindow(), [%d,%d,%d,%d]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setWindow: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|wx
operator|=
name|r
operator|.
name|x
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|wy
operator|=
name|r
operator|.
name|y
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|ww
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|wh
operator|=
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|VxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the window rectangle.      \sa setWindow(), setViewTransformEnabled() */
end_comment
begin_function
DECL|function|window
name|QRect
name|QPainter
operator|::
name|window
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::window: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QRect
argument_list|()
return|;
block|}
return|return
name|QRect
argument_list|(
name|d
operator|->
name|state
operator|->
name|wx
argument_list|,
name|d
operator|->
name|state
operator|->
name|wy
argument_list|,
name|d
operator|->
name|state
operator|->
name|ww
argument_list|,
name|d
operator|->
name|state
operator|->
name|wh
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::setViewport(const QRect&rectangle)      Sets the painter's viewport rectangle to the given \a rectangle,     and enables view transformations.      The viewport rectangle is part of the view transformation. The     viewport specifies the device coordinate system. Its sister, the     window(), specifies the logical coordinate system.      The default viewport rectangle is the same as the device's     rectangle.      \sa viewport(), viewTransformEnabled(), {Coordinate     System#Window-Viewport Conversion}{Window-Viewport Conversion} */
end_comment
begin_comment
comment|/*!     \fn void QPainter::setViewport(int x, int y, int width, int height)     \overload      Sets the painter's viewport rectangle to be the rectangle     beginning at (\a x, \a y) with the given \a width and \a height. */
end_comment
begin_function
DECL|function|setViewport
name|void
name|QPainter
operator|::
name|setViewport
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setViewport(), [%d,%d,%d,%d]\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setViewport: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|vx
operator|=
name|r
operator|.
name|x
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|vy
operator|=
name|r
operator|.
name|y
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|vw
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|vh
operator|=
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|VxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the viewport rectangle.      \sa setViewport(), setViewTransformEnabled() */
end_comment
begin_function
DECL|function|viewport
name|QRect
name|QPainter
operator|::
name|viewport
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::viewport: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QRect
argument_list|()
return|;
block|}
return|return
name|QRect
argument_list|(
name|d
operator|->
name|state
operator|->
name|vx
argument_list|,
name|d
operator|->
name|state
operator|->
name|vy
argument_list|,
name|d
operator|->
name|state
operator|->
name|vw
argument_list|,
name|d
operator|->
name|state
operator|->
name|vh
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Enables view transformations if \a enable is true, or disables     view transformations if \a enable is false.      \sa viewTransformEnabled(), {Coordinate System#Window-Viewport     Conversion}{Window-Viewport Conversion} */
end_comment
begin_function
DECL|function|setViewTransformEnabled
name|void
name|QPainter
operator|::
name|setViewTransformEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::setViewTransformEnabled(), enable=%d\n"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setViewTransformEnabled: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|enable
operator|==
name|d
operator|->
name|state
operator|->
name|VxF
condition|)
return|return;
name|d
operator|->
name|state
operator|->
name|VxF
operator|=
name|enable
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      \obsolete      Please use QWidget::render() instead.      Redirects all paint commands for the given paint \a device, to the     \a replacement device. The optional point \a offset defines an     offset within the source device.      The redirection will not be effective until the begin() function     has been called; make sure to call end() for the given \a     device's painter (if any) before redirecting. Call     restoreRedirected() to restore the previous redirection.      \warning Making use of redirections in the QPainter API implies     that QPainter::begin() and QPaintDevice destructors need to hold     a mutex for a short period. This can impact performance. Use of     QWidget::render is strongly encouraged.      \sa redirected(), restoreRedirected() */
end_comment
begin_function
DECL|function|setRedirected
name|void
name|QPainter
operator|::
name|setRedirected
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|device
parameter_list|,
name|QPaintDevice
modifier|*
name|replacement
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|device
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
argument|device
argument_list|)
name|Q_UNUSED
argument_list|(
argument|replacement
argument_list|)
name|Q_UNUSED
argument_list|(
argument|offset
argument_list|)
name|qWarning
argument_list|(
literal|"QPainter::setRedirected(): ignoring call to deprecated function, use QWidget::render() instead"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      \obsolete      Using QWidget::render() obsoletes the use of this function.      Restores the previous redirection for the given \a device after a     call to setRedirected().      \warning Making use of redirections in the QPainter API implies     that QPainter::begin() and QPaintDevice destructors need to hold     a mutex for a short period. This can impact performance. Use of     QWidget::render is strongly encouraged.      \sa redirected()  */
end_comment
begin_function
DECL|function|restoreRedirected
name|void
name|QPainter
operator|::
name|restoreRedirected
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|device
argument_list|)
name|qWarning
argument_list|(
literal|"QPainter::restoreRedirected(): ignoring call to deprecated function, use QWidget::render() instead"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      \obsolete      Using QWidget::render() obsoletes the use of this function.      Returns the replacement for given \a device. The optional out     parameter \a offset returns the offset within the replaced device.      \warning Making use of redirections in the QPainter API implies     that QPainter::begin() and QPaintDevice destructors need to hold     a mutex for a short period. This can impact performance. Use of     QWidget::render is strongly encouraged.      \sa setRedirected(), restoreRedirected() */
end_comment
begin_function
DECL|function|redirected
name|QPaintDevice
modifier|*
name|QPainter
operator|::
name|redirected
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|device
parameter_list|,
name|QPoint
modifier|*
name|offset
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|device
argument_list|)
name|Q_UNUSED
argument_list|(
argument|offset
argument_list|)
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qt_format_text
name|void
name|qt_format_text
parameter_list|(
specifier|const
name|QFont
modifier|&
name|fnt
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|_r
parameter_list|,
name|int
name|tf
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRectF
modifier|*
name|brect
parameter_list|,
name|int
name|tabstops
parameter_list|,
name|int
modifier|*
name|ta
parameter_list|,
name|int
name|tabarraylen
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|)
block|{
name|qt_format_text
argument_list|(
name|fnt
argument_list|,
name|_r
argument_list|,
name|tf
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|brect
argument_list|,
name|tabstops
argument_list|,
name|ta
argument_list|,
name|tabarraylen
argument_list|,
name|painter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_format_text
name|void
name|qt_format_text
parameter_list|(
specifier|const
name|QFont
modifier|&
name|fnt
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|_r
parameter_list|,
name|int
name|tf
parameter_list|,
specifier|const
name|QTextOption
modifier|*
name|option
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRectF
modifier|*
name|brect
parameter_list|,
name|int
name|tabstops
parameter_list|,
name|int
modifier|*
name|ta
parameter_list|,
name|int
name|tabarraylen
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|tf
operator|&
operator|~
name|Qt
operator|::
name|TextDontPrint
operator|)
operator|!=
literal|0
operator|&&
name|option
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|// we either have an option or flags
if|if
condition|(
name|option
condition|)
block|{
name|tf
operator||=
name|option
operator|->
name|alignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|wrapMode
argument_list|()
operator|!=
name|QTextOption
operator|::
name|NoWrap
condition|)
name|tf
operator||=
name|Qt
operator|::
name|TextWordWrap
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|flags
argument_list|()
operator|&
name|QTextOption
operator|::
name|IncludeTrailingSpaces
condition|)
name|tf
operator||=
name|Qt
operator|::
name|TextIncludeTrailingSpaces
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|tabStop
argument_list|()
operator|>=
literal|0
operator|||
operator|!
name|option
operator|->
name|tabArray
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|tf
operator||=
name|Qt
operator|::
name|TextExpandTabs
expr_stmt|;
block|}
comment|// we need to copy r here to protect against the case (&r == brect).
name|QRectF
name|r
argument_list|(
name|_r
argument_list|)
decl_stmt|;
name|bool
name|dontclip
init|=
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextDontClip
operator|)
decl_stmt|;
name|bool
name|wordwrap
init|=
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextWordWrap
operator|)
operator|||
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextWrapAnywhere
operator|)
decl_stmt|;
name|bool
name|singleline
init|=
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextSingleLine
operator|)
decl_stmt|;
name|bool
name|showmnemonic
init|=
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextShowMnemonic
operator|)
decl_stmt|;
name|bool
name|hidemnmemonic
init|=
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextHideMnemonic
operator|)
decl_stmt|;
name|Qt
operator|::
name|LayoutDirection
name|layout_direction
decl_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|TextForceLeftToRight
condition|)
name|layout_direction
operator|=
name|Qt
operator|::
name|LeftToRight
expr_stmt|;
elseif|else
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|TextForceRightToLeft
condition|)
name|layout_direction
operator|=
name|Qt
operator|::
name|RightToLeft
expr_stmt|;
elseif|else
if|if
condition|(
name|option
condition|)
name|layout_direction
operator|=
name|option
operator|->
name|textDirection
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|painter
condition|)
name|layout_direction
operator|=
name|painter
operator|->
name|layoutDirection
argument_list|()
expr_stmt|;
else|else
name|layout_direction
operator|=
name|Qt
operator|::
name|LeftToRight
expr_stmt|;
name|tf
operator|=
name|QGuiApplicationPrivate
operator|::
name|visualAlignment
argument_list|(
name|layout_direction
argument_list|,
name|QFlag
argument_list|(
name|tf
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|isRightToLeft
init|=
name|layout_direction
operator|==
name|Qt
operator|::
name|RightToLeft
decl_stmt|;
name|bool
name|expandtabs
init|=
operator|(
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextExpandTabs
operator|)
operator|&&
operator|(
operator|(
operator|(
name|tf
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
operator|&&
operator|!
name|isRightToLeft
operator|)
operator|||
operator|(
operator|(
name|tf
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
operator|&&
name|isRightToLeft
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|painter
condition|)
name|tf
operator||=
name|Qt
operator|::
name|TextDontPrint
expr_stmt|;
name|uint
name|maxUnderlines
init|=
literal|0
decl_stmt|;
name|int
name|numUnderlines
init|=
literal|0
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|32
argument_list|>
name|underlinePositions
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QFontMetricsF
name|fm
argument_list|(
name|fnt
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|str
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|start_lengthVariant
label|:
name|bool
name|hasMoreLengthVariants
init|=
literal|false
decl_stmt|;
comment|// compatible behaviour to the old implementation. Replace
comment|// tabs by spaces
name|int
name|old_offset
init|=
name|offset
decl_stmt|;
for|for
control|(
init|;
name|offset
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
name|offset
operator|++
control|)
block|{
name|QChar
name|chr
init|=
name|text
operator|.
name|at
argument_list|(
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|chr
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
operator|||
operator|(
name|singleline
operator|&&
name|chr
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|text
index|[
name|offset
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chr
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|text
index|[
name|offset
index|]
operator|=
name|QChar
operator|::
name|LineSeparator
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chr
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
operator|++
name|maxUnderlines
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chr
operator|==
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|expandtabs
condition|)
block|{
name|text
index|[
name|offset
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tabarraylen
operator|&&
operator|!
name|tabstops
condition|)
block|{
name|tabstops
operator|=
name|qRound
argument_list|(
name|fm
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
argument_list|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chr
operator|==
name|QChar
argument_list|(
name|ushort
argument_list|(
literal|0x9c
argument_list|)
argument_list|)
condition|)
block|{
comment|// string with multiple length variants
name|hasMoreLengthVariants
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|int
name|length
init|=
name|offset
operator|-
name|old_offset
decl_stmt|;
if|if
condition|(
operator|(
name|hidemnmemonic
operator|||
name|showmnemonic
operator|)
operator|&&
name|maxUnderlines
operator|>
literal|0
condition|)
block|{
name|underlinePositions
operator|.
name|resize
argument_list|(
name|maxUnderlines
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QChar
modifier|*
name|cout
init|=
name|text
operator|.
name|data
argument_list|()
operator|+
name|old_offset
decl_stmt|;
name|QChar
modifier|*
name|cin
init|=
name|cout
decl_stmt|;
name|int
name|l
init|=
name|length
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
operator|*
name|cin
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
operator|++
name|cin
expr_stmt|;
operator|--
name|length
expr_stmt|;
operator|--
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
break|break;
if|if
condition|(
operator|*
name|cin
operator|!=
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
operator|&&
operator|!
name|hidemnmemonic
condition|)
name|underlinePositions
index|[
name|numUnderlines
operator|++
index|]
operator|=
name|cout
operator|-
name|text
operator|.
name|data
argument_list|()
operator|-
name|old_offset
expr_stmt|;
block|}
operator|*
name|cout
operator|=
operator|*
name|cin
expr_stmt|;
operator|++
name|cout
expr_stmt|;
operator|++
name|cin
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
block|}
comment|// no need to do extra work for underlines if we don't paint
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|TextDontPrint
condition|)
name|numUnderlines
operator|=
literal|0
expr_stmt|;
name|underlinePositions
index|[
name|numUnderlines
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qreal
name|height
init|=
literal|0
decl_stmt|;
name|qreal
name|width
init|=
literal|0
decl_stmt|;
name|QString
name|finalText
init|=
name|text
operator|.
name|mid
argument_list|(
name|old_offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|QStackTextEngine
name|engine
argument_list|(
name|finalText
argument_list|,
name|fnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|option
condition|)
block|{
name|engine
operator|.
name|option
operator|=
operator|*
name|option
expr_stmt|;
block|}
if|if
condition|(
name|engine
operator|.
name|option
operator|.
name|tabStop
argument_list|()
operator|<
literal|0
operator|&&
name|tabstops
operator|>
literal|0
condition|)
name|engine
operator|.
name|option
operator|.
name|setTabStop
argument_list|(
name|tabstops
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|.
name|option
operator|.
name|tabs
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ta
condition|)
block|{
name|QList
argument_list|<
name|qreal
argument_list|>
name|tabs
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tabarraylen
condition|;
name|i
operator|++
control|)
name|tabs
operator|.
name|append
argument_list|(
name|qreal
argument_list|(
name|ta
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|engine
operator|.
name|option
operator|.
name|setTabArray
argument_list|(
name|tabs
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|option
operator|.
name|setTextDirection
argument_list|(
name|layout_direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignJustify
condition|)
name|engine
operator|.
name|option
operator|.
name|setAlignment
argument_list|(
name|Qt
operator|::
name|AlignJustify
argument_list|)
expr_stmt|;
else|else
name|engine
operator|.
name|option
operator|.
name|setAlignment
argument_list|(
name|Qt
operator|::
name|AlignLeft
argument_list|)
expr_stmt|;
comment|// do not do alignment twice
if|if
condition|(
operator|!
name|option
operator|&&
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextWrapAnywhere
operator|)
condition|)
name|engine
operator|.
name|option
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|WrapAnywhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|TextJustificationForced
condition|)
name|engine
operator|.
name|forceJustification
operator|=
literal|true
expr_stmt|;
name|QTextLayout
name|textLayout
argument_list|(
operator|&
name|engine
argument_list|)
decl_stmt|;
name|textLayout
operator|.
name|setCacheEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|textLayout
operator|.
name|engine
argument_list|()
operator|->
name|underlinePositions
operator|=
name|underlinePositions
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|finalText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|height
operator|=
name|fm
operator|.
name|height
argument_list|()
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|tf
operator||=
name|Qt
operator|::
name|TextDontPrint
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|lineWidth
init|=
literal|0x01000000
decl_stmt|;
if|if
condition|(
name|wordwrap
operator|||
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextJustificationForced
operator|)
condition|)
name|lineWidth
operator|=
name|qMax
argument_list|<
name|qreal
argument_list|>
argument_list|(
literal|0
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wordwrap
condition|)
name|tf
operator||=
name|Qt
operator|::
name|TextIncludeTrailingSpaces
expr_stmt|;
name|textLayout
operator|.
name|engine
argument_list|()
operator|->
name|ignoreBidi
operator|=
name|bool
argument_list|(
name|tf
operator|&
name|Qt
operator|::
name|TextDontPrint
argument_list|)
expr_stmt|;
name|textLayout
operator|.
name|beginLayout
argument_list|()
expr_stmt|;
name|qreal
name|leading
init|=
name|fm
operator|.
name|leading
argument_list|()
decl_stmt|;
name|height
operator|=
operator|-
name|leading
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|QTextLine
name|l
init|=
name|textLayout
operator|.
name|createLine
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isValid
argument_list|()
condition|)
break|break;
name|l
operator|.
name|setLineWidth
argument_list|(
name|lineWidth
argument_list|)
expr_stmt|;
name|height
operator|+=
name|leading
expr_stmt|;
comment|// Make sure lines are positioned on whole pixels
name|height
operator|=
name|qCeil
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|l
operator|.
name|setPosition
argument_list|(
name|QPointF
argument_list|(
literal|0.
argument_list|,
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|height
operator|+=
name|textLayout
operator|.
name|engine
argument_list|()
operator|->
name|lines
index|[
name|l
operator|.
name|lineNumber
argument_list|()
index|]
operator|.
name|height
argument_list|()
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|width
operator|=
name|qMax
argument_list|(
name|width
argument_list|,
name|l
operator|.
name|naturalTextWidth
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dontclip
operator|&&
operator|!
name|brect
operator|&&
name|height
operator|>=
name|r
operator|.
name|height
argument_list|()
condition|)
break|break;
block|}
name|textLayout
operator|.
name|endLayout
argument_list|()
expr_stmt|;
block|}
name|qreal
name|yoff
init|=
literal|0
decl_stmt|;
name|qreal
name|xoff
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|yoff
operator|=
name|r
operator|.
name|height
argument_list|()
operator|-
name|height
expr_stmt|;
elseif|else
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignVCenter
condition|)
name|yoff
operator|=
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|xoff
operator|=
name|r
operator|.
name|width
argument_list|()
operator|-
name|width
expr_stmt|;
elseif|else
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignHCenter
condition|)
name|xoff
operator|=
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|width
operator|)
operator|/
literal|2
expr_stmt|;
name|QRectF
name|bounds
init|=
name|QRectF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|xoff
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|yoff
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasMoreLengthVariants
operator|&&
operator|!
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextLongestVariant
operator|)
operator|&&
operator|!
name|r
operator|.
name|contains
argument_list|(
name|bounds
argument_list|)
condition|)
block|{
name|offset
operator|++
expr_stmt|;
goto|goto
name|start_lengthVariant
goto|;
block|}
if|if
condition|(
name|brect
condition|)
operator|*
name|brect
operator|=
name|bounds
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tf
operator|&
name|Qt
operator|::
name|TextDontPrint
operator|)
condition|)
block|{
name|bool
name|restore
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|dontclip
operator|&&
operator|!
name|r
operator|.
name|contains
argument_list|(
name|bounds
argument_list|)
condition|)
block|{
name|restore
operator|=
literal|true
expr_stmt|;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setClipRect
argument_list|(
name|r
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|textLayout
operator|.
name|lineCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QTextLine
name|line
init|=
name|textLayout
operator|.
name|lineAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QTextEngine
modifier|*
name|eng
init|=
name|textLayout
operator|.
name|engine
argument_list|()
decl_stmt|;
name|eng
operator|->
name|enableDelayDecorations
argument_list|()
expr_stmt|;
name|qreal
name|advance
init|=
name|line
operator|.
name|horizontalAdvance
argument_list|()
decl_stmt|;
name|xoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
block|{
name|xoff
operator|=
name|r
operator|.
name|width
argument_list|()
operator|-
name|advance
operator|-
name|eng
operator|->
name|leadingSpaceWidth
argument_list|(
name|eng
operator|->
name|lines
index|[
name|line
operator|.
name|lineNumber
argument_list|()
index|]
argument_list|)
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tf
operator|&
name|Qt
operator|::
name|AlignHCenter
condition|)
name|xoff
operator|=
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|advance
operator|)
operator|/
literal|2
expr_stmt|;
name|line
operator|.
name|draw
argument_list|(
name|painter
argument_list|,
name|QPointF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|xoff
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|yoff
argument_list|)
argument_list|)
expr_stmt|;
name|eng
operator|->
name|drawDecorations
argument_list|(
name|painter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|restore
condition|)
block|{
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the layout direction used by the painter when drawing text,     to the specified \a direction.      The default is Qt::LayoutDirectionAuto, which will implicitly determine the     direction from the text drawn.      \sa QTextOption::setTextDirection(), layoutDirection(), drawText(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|setLayoutDirection
name|void
name|QPainter
operator|::
name|setLayoutDirection
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
condition|)
name|d
operator|->
name|state
operator|->
name|layoutDirection
operator|=
name|direction
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the layout direction used by the painter when drawing text.      \sa QTextOption::textDirection(), setLayoutDirection(), drawText(), {QPainter#Settings}{Settings} */
end_comment
begin_function
DECL|function|layoutDirection
name|Qt
operator|::
name|LayoutDirection
name|QPainter
operator|::
name|layoutDirection
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
condition|?
name|d
operator|->
name|state
operator|->
name|layoutDirection
else|:
name|Qt
operator|::
name|LayoutDirectionAuto
return|;
block|}
end_function
begin_constructor
DECL|function|QPainterState
name|QPainterState
operator|::
name|QPainterState
parameter_list|(
specifier|const
name|QPainterState
modifier|*
name|s
parameter_list|)
member_init_list|:
name|brushOrigin
argument_list|(
name|s
operator|->
name|brushOrigin
argument_list|)
member_init_list|,
name|font
argument_list|(
name|s
operator|->
name|font
argument_list|)
member_init_list|,
name|deviceFont
argument_list|(
name|s
operator|->
name|deviceFont
argument_list|)
member_init_list|,
name|pen
argument_list|(
name|s
operator|->
name|pen
argument_list|)
member_init_list|,
name|brush
argument_list|(
name|s
operator|->
name|brush
argument_list|)
member_init_list|,
name|bgBrush
argument_list|(
name|s
operator|->
name|bgBrush
argument_list|)
member_init_list|,
name|clipRegion
argument_list|(
name|s
operator|->
name|clipRegion
argument_list|)
member_init_list|,
name|clipPath
argument_list|(
name|s
operator|->
name|clipPath
argument_list|)
member_init_list|,
name|clipOperation
argument_list|(
name|s
operator|->
name|clipOperation
argument_list|)
member_init_list|,
name|renderHints
argument_list|(
name|s
operator|->
name|renderHints
argument_list|)
member_init_list|,
name|clipInfo
argument_list|(
name|s
operator|->
name|clipInfo
argument_list|)
member_init_list|,
name|worldMatrix
argument_list|(
name|s
operator|->
name|worldMatrix
argument_list|)
member_init_list|,
name|matrix
argument_list|(
name|s
operator|->
name|matrix
argument_list|)
member_init_list|,
name|redirectionMatrix
argument_list|(
name|s
operator|->
name|redirectionMatrix
argument_list|)
member_init_list|,
name|wx
argument_list|(
name|s
operator|->
name|wx
argument_list|)
member_init_list|,
name|wy
argument_list|(
name|s
operator|->
name|wy
argument_list|)
member_init_list|,
name|ww
argument_list|(
name|s
operator|->
name|ww
argument_list|)
member_init_list|,
name|wh
argument_list|(
name|s
operator|->
name|wh
argument_list|)
member_init_list|,
name|vx
argument_list|(
name|s
operator|->
name|vx
argument_list|)
member_init_list|,
name|vy
argument_list|(
name|s
operator|->
name|vy
argument_list|)
member_init_list|,
name|vw
argument_list|(
name|s
operator|->
name|vw
argument_list|)
member_init_list|,
name|vh
argument_list|(
name|s
operator|->
name|vh
argument_list|)
member_init_list|,
name|opacity
argument_list|(
name|s
operator|->
name|opacity
argument_list|)
member_init_list|,
name|WxF
argument_list|(
name|s
operator|->
name|WxF
argument_list|)
member_init_list|,
name|VxF
argument_list|(
name|s
operator|->
name|VxF
argument_list|)
member_init_list|,
name|clipEnabled
argument_list|(
name|s
operator|->
name|clipEnabled
argument_list|)
member_init_list|,
name|bgMode
argument_list|(
name|s
operator|->
name|bgMode
argument_list|)
member_init_list|,
name|painter
argument_list|(
name|s
operator|->
name|painter
argument_list|)
member_init_list|,
name|layoutDirection
argument_list|(
name|s
operator|->
name|layoutDirection
argument_list|)
member_init_list|,
name|composition_mode
argument_list|(
name|s
operator|->
name|composition_mode
argument_list|)
member_init_list|,
name|emulationSpecifier
argument_list|(
name|s
operator|->
name|emulationSpecifier
argument_list|)
member_init_list|,
name|changeFlags
argument_list|(
literal|0
argument_list|)
block|{
name|dirtyFlags
operator|=
name|s
operator|->
name|dirtyFlags
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QPainterState
name|QPainterState
operator|::
name|QPainterState
parameter_list|()
member_init_list|:
name|brushOrigin
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|bgBrush
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
member_init_list|,
name|clipOperation
argument_list|(
name|Qt
operator|::
name|NoClip
argument_list|)
member_init_list|,
name|renderHints
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|wx
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|wy
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ww
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|wh
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vx
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vy
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vw
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vh
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|opacity
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|WxF
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|VxF
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|clipEnabled
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|bgMode
argument_list|(
name|Qt
operator|::
name|TransparentMode
argument_list|)
member_init_list|,
name|painter
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|layoutDirection
argument_list|(
name|QGuiApplication
operator|::
name|layoutDirection
argument_list|()
argument_list|)
member_init_list|,
name|composition_mode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_SourceOver
argument_list|)
member_init_list|,
name|emulationSpecifier
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|changeFlags
argument_list|(
literal|0
argument_list|)
block|{
name|dirtyFlags
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QPainterState
name|QPainterState
operator|::
name|~
name|QPainterState
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|init
name|void
name|QPainterState
operator|::
name|init
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|)
block|{
name|bgBrush
operator|=
name|Qt
operator|::
name|white
expr_stmt|;
name|bgMode
operator|=
name|Qt
operator|::
name|TransparentMode
expr_stmt|;
name|WxF
operator|=
literal|false
expr_stmt|;
name|VxF
operator|=
literal|false
expr_stmt|;
name|clipEnabled
operator|=
literal|true
expr_stmt|;
name|wx
operator|=
name|wy
operator|=
name|ww
operator|=
name|wh
operator|=
literal|0
expr_stmt|;
name|vx
operator|=
name|vy
operator|=
name|vw
operator|=
name|vh
operator|=
literal|0
expr_stmt|;
name|painter
operator|=
name|p
expr_stmt|;
name|pen
operator|=
name|QPen
argument_list|()
expr_stmt|;
name|brushOrigin
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|brush
operator|=
name|QBrush
argument_list|()
expr_stmt|;
name|font
operator|=
name|deviceFont
operator|=
name|QFont
argument_list|()
expr_stmt|;
name|clipRegion
operator|=
name|QRegion
argument_list|()
expr_stmt|;
name|clipPath
operator|=
name|QPainterPath
argument_list|()
expr_stmt|;
name|clipOperation
operator|=
name|Qt
operator|::
name|NoClip
expr_stmt|;
name|clipInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|worldMatrix
operator|.
name|reset
argument_list|()
expr_stmt|;
name|matrix
operator|.
name|reset
argument_list|()
expr_stmt|;
name|layoutDirection
operator|=
name|QGuiApplication
operator|::
name|layoutDirection
argument_list|()
expr_stmt|;
name|composition_mode
operator|=
name|QPainter
operator|::
name|CompositionMode_SourceOver
expr_stmt|;
name|emulationSpecifier
operator|=
literal|0
expr_stmt|;
name|dirtyFlags
operator|=
literal|0
expr_stmt|;
name|changeFlags
operator|=
literal|0
expr_stmt|;
name|renderHints
operator|=
literal|0
expr_stmt|;
name|opacity
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QRectF&target, const QImage&image, const QRectF&source,                          Qt::ImageConversionFlags flags)      Draws the rectangular portion \a source of the given \a image     into the \a target rectangle in the paint device.      \note The image is scaled to fit the rectangle, if both the image and rectangle size disagree.      If the image needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a flags to     specify how you would prefer this to happen.      \table 100%     \row     \li     \snippet code/src_gui_painting_qpainter.cpp 20     \endtable      \sa drawPixmap() */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QRect&target, const QImage&image, const QRect&source,                                  Qt::ImageConversionFlags flags)     \overload      Draws the rectangular portion \a source of the given \a image     into the \a target rectangle in the paint device.      \note The image is scaled to fit the rectangle, if both the image and rectangle size disagree. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QPointF&point, const QImage&image)      \overload      Draws the given \a image at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QPoint&point, const QImage&image)      \overload      Draws the given \a image at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QPointF&point, const QImage&image, const QRectF&source,                                  Qt::ImageConversionFlags flags = 0)      \overload      Draws the rectangular portion \a source of the given \a image with     its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QPoint&point, const QImage&image, const QRect&source,                                  Qt::ImageConversionFlags flags = 0)     \overload      Draws the rectangular portion \a source of the given \a image with     its origin at the given \a point. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QRectF&rectangle, const QImage&image)      \overload      Draws the given \a image into the given \a rectangle.      \note The image is scaled to fit the rectangle, if both the image and rectangle size disagree. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(const QRect&rectangle, const QImage&image)      \overload      Draws the given \a image into the given \a rectangle.     \note The image is scaled to fit the rectangle, if both the image and rectangle size disagree. */
end_comment
begin_comment
comment|/*!     \fn void QPainter::drawImage(int x, int y, const QImage&image,                                  int sx, int sy, int sw, int sh,                                  Qt::ImageConversionFlags flags)     \overload      Draws an image at (\a{x}, \a{y}) by copying a part of \a image into     the paint device.      (\a{x}, \a{y}) specifies the top-left point in the paint device that is     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a     image that is to be drawn. The default is (0, 0).      (\a{sw}, \a{sh}) specifies the size of the image that is to be drawn.     The default, (0, 0) (and negative) means all the way to the     bottom-right of the image. */
end_comment
begin_comment
comment|/*!     \class QPaintEngineState     \since 4.1     \inmodule QtGui      \brief The QPaintEngineState class provides information about the     active paint engine's current state.     \reentrant      QPaintEngineState records which properties that have changed since     the last time the paint engine was updated, as well as their     current value.      Which properties that have changed can at any time be retrieved     using the state() function. This function returns an instance of     the QPaintEngine::DirtyFlags type which stores an OR combination     of QPaintEngine::DirtyFlag values. The QPaintEngine::DirtyFlag     enum defines whether a property has changed since the last update     or not.      If a property is marked with a dirty flag, its current value can     be retrieved using the corresponding get function:      \target GetFunction      \table     \header \li Property Flag \li Current Property Value     \row \li QPaintEngine::DirtyBackground \li backgroundBrush()     \row \li QPaintEngine::DirtyBackgroundMode \li backgroundMode()     \row \li QPaintEngine::DirtyBrush \li brush()     \row \li QPaintEngine::DirtyBrushOrigin \li brushOrigin()     \row \li QPaintEngine::DirtyClipRegion \e or QPaintEngine::DirtyClipPath          \li clipOperation()     \row \li QPaintEngine::DirtyClipPath \li clipPath()     \row \li QPaintEngine::DirtyClipRegion \li clipRegion()     \row \li QPaintEngine::DirtyCompositionMode \li compositionMode()     \row \li QPaintEngine::DirtyFont \li font()     \row \li QPaintEngine::DirtyTransform \li transform()     \row \li QPaintEngine::DirtyClipEnabled \li isClipEnabled()     \row \li QPaintEngine::DirtyPen \li pen()     \row \li QPaintEngine::DirtyHints \li renderHints()     \endtable      The QPaintEngineState class also provide the painter() function     which returns a pointer to the painter that is currently updating     the paint engine.      An instance of this class, representing the current state of the     active paint engine, is passed as argument to the     QPaintEngine::updateState() function. The only situation in which     you will have to use this class directly is when implementing your     own paint engine.      \sa QPaintEngine */
end_comment
begin_comment
comment|/*!     \fn QPaintEngine::DirtyFlags QPaintEngineState::state() const      Returns a combination of flags identifying the set of properties     that need to be updated when updating the paint engine's state     (i.e. during a call to the QPaintEngine::updateState() function).      \sa QPaintEngine::updateState() */
end_comment
begin_comment
comment|/*!     Returns the pen in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyPen flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|pen
name|QPen
name|QPaintEngineState
operator|::
name|pen
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|pen
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the brush in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyBrush flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|brush
name|QBrush
name|QPaintEngineState
operator|::
name|brush
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|brush
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the brush origin in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyBrushOrigin flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|brushOrigin
name|QPointF
name|QPaintEngineState
operator|::
name|brushOrigin
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|brushOrigin
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the background brush in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyBackground flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|backgroundBrush
name|QBrush
name|QPaintEngineState
operator|::
name|backgroundBrush
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|bgBrush
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the background mode in the current paint engine     state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyBackgroundMode flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|backgroundMode
name|Qt
operator|::
name|BGMode
name|QPaintEngineState
operator|::
name|backgroundMode
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|bgMode
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the font in the current paint engine     state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyFont flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QPaintEngineState
operator|::
name|font
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|font
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \obsolete      Returns the matrix in the current paint engine     state.      \note It is advisable to use transform() instead of this function to     preserve the properties of perspective transformations.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyTransform flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|matrix
name|QMatrix
name|QPaintEngineState
operator|::
name|matrix
parameter_list|()
specifier|const
block|{
specifier|const
name|QPainterState
modifier|*
name|st
init|=
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|st
operator|->
name|matrix
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns the matrix in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyTransform flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|transform
name|QTransform
name|QPaintEngineState
operator|::
name|transform
parameter_list|()
specifier|const
block|{
specifier|const
name|QPainterState
modifier|*
name|st
init|=
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
name|st
operator|->
name|matrix
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the clip operation in the current paint engine     state.      This variable should only be used when the state() returns a     combination which includes either the QPaintEngine::DirtyClipPath     or the QPaintEngine::DirtyClipRegion flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|clipOperation
name|Qt
operator|::
name|ClipOperation
name|QPaintEngineState
operator|::
name|clipOperation
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|clipOperation
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns whether the coordinate of the fill have been specified     as bounded by the current rendering operation and have to be     resolved (about the currently rendered primitive). */
end_comment
begin_function
DECL|function|brushNeedsResolving
name|bool
name|QPaintEngineState
operator|::
name|brushNeedsResolving
parameter_list|()
specifier|const
block|{
specifier|const
name|QBrush
modifier|&
name|brush
init|=
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|brush
decl_stmt|;
return|return
name|needsResolving
argument_list|(
name|brush
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns whether the coordinate of the stroke have been specified     as bounded by the current rendering operation and have to be     resolved (about the currently rendered primitive). */
end_comment
begin_function
DECL|function|penNeedsResolving
name|bool
name|QPaintEngineState
operator|::
name|penNeedsResolving
parameter_list|()
specifier|const
block|{
specifier|const
name|QPen
modifier|&
name|pen
init|=
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|pen
decl_stmt|;
return|return
name|needsResolving
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the clip region in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyClipRegion flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|clipRegion
name|QRegion
name|QPaintEngineState
operator|::
name|clipRegion
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|clipRegion
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the clip path in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyClipPath flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|clipPath
name|QPainterPath
name|QPaintEngineState
operator|::
name|clipPath
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|clipPath
return|;
block|}
end_function
begin_comment
comment|/*!     Returns whether clipping is enabled or not in the current paint     engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyClipEnabled     flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|isClipEnabled
name|bool
name|QPaintEngineState
operator|::
name|isClipEnabled
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|clipEnabled
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the render hints in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyHints     flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|renderHints
name|QPainter
operator|::
name|RenderHints
name|QPaintEngineState
operator|::
name|renderHints
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|renderHints
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the composition mode in the current paint engine state.      This variable should only be used when the state() returns a     combination which includes the QPaintEngine::DirtyCompositionMode     flag.      \sa state(), QPaintEngine::updateState() */
end_comment
begin_function
DECL|function|compositionMode
name|QPainter
operator|::
name|CompositionMode
name|QPaintEngineState
operator|::
name|compositionMode
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|composition_mode
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the painter currently updating the paint     engine. */
end_comment
begin_function
DECL|function|painter
name|QPainter
modifier|*
name|QPaintEngineState
operator|::
name|painter
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|painter
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the opacity in the current paint engine state. */
end_comment
begin_function
DECL|function|opacity
name|qreal
name|QPaintEngineState
operator|::
name|opacity
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QPainterState
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|opacity
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Sets the world transformation matrix.     If \a combine is true, the specified \a transform is combined with     the current matrix; otherwise it replaces the current matrix.      \sa transform(), setWorldTransform() */
end_comment
begin_function
DECL|function|setTransform
name|void
name|QPainter
operator|::
name|setTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|setWorldTransform
argument_list|(
name|transform
argument_list|,
name|combine
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the world transformation matrix.      \sa worldTransform() */
end_comment
begin_function
DECL|function|transform
specifier|const
name|QTransform
modifier|&
name|QPainter
operator|::
name|transform
parameter_list|()
specifier|const
block|{
return|return
name|worldTransform
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the matrix that transforms from logical coordinates to     device coordinates of the platform dependent paint device.      This function is \e only needed when using platform painting     commands on the platform dependent handle (Qt::HANDLE), and the     platform does not do transformations nativly.      The QPaintEngine::PaintEngineFeature enum can be queried to     determine whether the platform performs the transformations or     not.      \sa worldTransform(), QPaintEngine::hasFeature(), */
end_comment
begin_function
DECL|function|deviceTransform
specifier|const
name|QTransform
modifier|&
name|QPainter
operator|::
name|deviceTransform
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::deviceTransform: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|transform
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|matrix
return|;
block|}
end_function
begin_comment
comment|/*!     Resets any transformations that were made using translate(),     scale(), shear(), rotate(), setWorldTransform(), setViewport()     and setWindow().      \sa {Coordinate Transformations} */
end_comment
begin_function
DECL|function|resetTransform
name|void
name|QPainter
operator|::
name|resetTransform
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG_DRAW
if|if
condition|(
name|qt_show_painter_debug_output
condition|)
name|printf
argument_list|(
literal|"QPainter::resetMatrix()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::resetMatrix: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|->
name|wx
operator|=
name|d
operator|->
name|state
operator|->
name|wy
operator|=
name|d
operator|->
name|state
operator|->
name|vx
operator|=
name|d
operator|->
name|state
operator|->
name|vy
operator|=
literal|0
expr_stmt|;
comment|// default view origins
name|d
operator|->
name|state
operator|->
name|ww
operator|=
name|d
operator|->
name|state
operator|->
name|vw
operator|=
name|d
operator|->
name|device
operator|->
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmWidth
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|wh
operator|=
name|d
operator|->
name|state
operator|->
name|vh
operator|=
name|d
operator|->
name|device
operator|->
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmHeight
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|=
name|QTransform
argument_list|()
expr_stmt|;
name|setMatrixEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setViewTransformEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extended
condition|)
name|d
operator|->
name|extended
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|state
operator|->
name|dirtyFlags
operator||=
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the world transformation matrix.     If \a combine is true, the specified \a matrix is combined with the current matrix;     otherwise it replaces the current matrix.      \sa transform(), setTransform() */
end_comment
begin_function
DECL|function|setWorldTransform
name|void
name|QPainter
operator|::
name|setWorldTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::setWorldTransform: Painter not active"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|combine
condition|)
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|=
name|matrix
operator|*
name|d
operator|->
name|state
operator|->
name|worldMatrix
expr_stmt|;
comment|// combines
else|else
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|=
name|matrix
expr_stmt|;
comment|// set new matrix
name|d
operator|->
name|state
operator|->
name|WxF
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the world transformation matrix. */
end_comment
begin_function
DECL|function|worldTransform
specifier|const
name|QTransform
modifier|&
name|QPainter
operator|::
name|worldTransform
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::worldTransform: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fakeState
argument_list|()
operator|->
name|transform
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|worldMatrix
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the transformation matrix combining the current     window/viewport and world transformation.      \sa setWorldTransform(), setWindow(), setViewport() */
end_comment
begin_function
DECL|function|combinedTransform
name|QTransform
name|QPainter
operator|::
name|combinedTransform
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPainter::combinedTransform: Painter not active"
argument_list|)
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|state
operator|->
name|worldMatrix
operator|*
name|d
operator|->
name|viewTransform
argument_list|()
operator|*
name|d
operator|->
name|hidpiScaleTransform
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      This function is used to draw \a pixmap, or a sub-rectangle of \a pixmap,     at multiple positions with different scale, rotation and opacity. \a     fragments is an array of \a fragmentCount elements specifying the     parameters used to draw each pixmap fragment. The \a hints     parameter can be used to pass in drawing hints.      This function is potentially faster than multiple calls to drawPixmap(),     since the backend can optimize state changes.      \sa QPainter::PixmapFragment, QPainter::PixmapFragmentHint */
end_comment
begin_function
DECL|function|drawPixmapFragments
name|void
name|QPainter
operator|::
name|drawPixmapFragments
parameter_list|(
specifier|const
name|PixmapFragment
modifier|*
name|fragments
parameter_list|,
name|int
name|fragmentCount
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|PixmapFragmentHints
name|hints
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPainter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
operator|||
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fragmentCount
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|sourceRect
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|sourceLeft
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|sourceTop
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|QRectF
argument_list|(
name|pixmap
operator|.
name|rect
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|sourceRect
argument_list|)
operator|)
condition|)
name|qWarning
argument_list|(
literal|"QPainter::drawPixmapFragments - the source rect is not contained by the pixmap's rectangle"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|engine
operator|->
name|isExtended
argument_list|()
condition|)
block|{
name|d
operator|->
name|extended
operator|->
name|drawPixmapFragments
argument_list|(
name|fragments
argument_list|,
name|fragmentCount
argument_list|,
name|pixmap
argument_list|,
name|hints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|oldOpacity
init|=
name|opacity
argument_list|()
decl_stmt|;
name|QTransform
name|oldTransform
init|=
name|transform
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fragmentCount
condition|;
operator|++
name|i
control|)
block|{
name|QTransform
name|transform
init|=
name|oldTransform
decl_stmt|;
name|qreal
name|xOffset
init|=
literal|0
decl_stmt|;
name|qreal
name|yOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fragments
index|[
name|i
index|]
operator|.
name|rotation
operator|==
literal|0
condition|)
block|{
name|xOffset
operator|=
name|fragments
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|yOffset
operator|=
name|fragments
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|transform
operator|.
name|translate
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|transform
operator|.
name|rotate
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
block|}
name|setOpacity
argument_list|(
name|oldOpacity
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|transform
argument_list|)
expr_stmt|;
name|qreal
name|w
init|=
name|fragments
index|[
name|i
index|]
operator|.
name|scaleX
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|width
decl_stmt|;
name|qreal
name|h
init|=
name|fragments
index|[
name|i
index|]
operator|.
name|scaleY
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|height
decl_stmt|;
name|QRectF
name|sourceRect
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|sourceLeft
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|sourceTop
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
name|drawPixmap
argument_list|(
name|QRectF
argument_list|(
operator|-
literal|0.5
operator|*
name|w
operator|+
name|xOffset
argument_list|,
operator|-
literal|0.5
operator|*
name|h
operator|+
name|yOffset
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|pixmap
argument_list|,
name|sourceRect
argument_list|)
expr_stmt|;
block|}
name|setOpacity
argument_list|(
name|oldOpacity
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|oldTransform
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7     \class QPainter::PixmapFragment     \inmodule QtGui      \brief This class is used in conjunction with the     QPainter::drawPixmapFragments() function to specify how a pixmap, or     sub-rect of a pixmap, is drawn.      The \a sourceLeft, \a sourceTop, \a width and \a height variables are used     as a source rectangle within the pixmap passed into the     QPainter::drawPixmapFragments() function. The variables \a x, \a y, \a     width and \a height are used to calculate the target rectangle that is     drawn. \a x and \a y denotes the center of the target rectangle. The \a     width and \a height in the target rectangle is scaled by the \a scaleX and     \a scaleY values. The resulting target rectangle is then rotated \a     rotation degrees around the \a x, \a y center point.      \sa QPainter::drawPixmapFragments() */
end_comment
begin_comment
comment|/*!     \since 4.7      This is a convenience function that returns a QPainter::PixmapFragment that is     initialized with the \a pos, \a sourceRect, \a scaleX, \a scaleY, \a     rotation, \a opacity parameters. */
end_comment
begin_function
DECL|function|create
name|QPainter
operator|::
name|PixmapFragment
name|QPainter
operator|::
name|PixmapFragment
operator|::
name|create
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sourceRect
parameter_list|,
name|qreal
name|scaleX
parameter_list|,
name|qreal
name|scaleY
parameter_list|,
name|qreal
name|rotation
parameter_list|,
name|qreal
name|opacity
parameter_list|)
block|{
name|PixmapFragment
name|fragment
init|=
block|{
name|pos
operator|.
name|x
argument_list|()
block|,
name|pos
operator|.
name|y
argument_list|()
block|,
name|sourceRect
operator|.
name|x
argument_list|()
block|,
name|sourceRect
operator|.
name|y
argument_list|()
block|,
name|sourceRect
operator|.
name|width
argument_list|()
block|,
name|sourceRect
operator|.
name|height
argument_list|()
block|,
name|scaleX
block|,
name|scaleY
block|,
name|rotation
block|,
name|opacity
block|}
decl_stmt|;
return|return
name|fragment
return|;
block|}
end_function
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::x     \brief the x coordinate of center point in the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::y     \brief the y coordinate of the center point in the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::sourceLeft     \brief the left coordinate of the source rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::sourceTop     \brief the top coordinate of the source rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::width      \brief the width of the source rectangle and is used to calculate the width     of the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::height      \brief the height of the source rectangle and is used to calculate the     height of the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::scaleX     \brief the horizontal scale of the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::scaleY     \brief the vertical scale of the target rectangle. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::rotation      \brief the rotation of the target rectangle in degrees. The target     rectangle is rotated after it has been scaled. */
end_comment
begin_comment
comment|/*!     \variable QPainter::PixmapFragment::opacity      \brief the opacity of the target rectangle, where 0.0 is fully transparent     and 1.0 is fully opaque. */
end_comment
begin_comment
comment|/*!     \since 4.7      \enum QPainter::PixmapFragmentHint      \value OpaqueHint Indicates that the pixmap fragments to be drawn are     opaque. Opaque fragments are potentially faster to draw.      \sa QPainter::drawPixmapFragments(), QPainter::PixmapFragment */
end_comment
begin_function
DECL|function|qt_draw_helper
name|void
name|qt_draw_helper
parameter_list|(
name|QPainterPrivate
modifier|*
name|p
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|QPainterPrivate
operator|::
name|DrawOperation
name|operation
parameter_list|)
block|{
name|p
operator|->
name|draw_helper
argument_list|(
name|path
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
