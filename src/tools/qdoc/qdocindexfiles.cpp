begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdom.h"
end_include
begin_include
include|#
directive|include
file|"qxmlstream.h"
end_include
begin_include
include|#
directive|include
file|"qdocindexfiles.h"
end_include
begin_include
include|#
directive|include
file|"qdoctagfiles.h"
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"location.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!   \class QDocIndexFiles    This class handles qdoc index files.  */
DECL|member|qdocIndexFiles_
name|QDocIndexFiles
modifier|*
name|QDocIndexFiles
operator|::
name|qdocIndexFiles_
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs the singleton QDocIndexFiles.  */
end_comment
begin_constructor
DECL|function|QDocIndexFiles
name|QDocIndexFiles
operator|::
name|QDocIndexFiles
parameter_list|()
member_init_list|:
name|gen_
argument_list|(
literal|0
argument_list|)
block|{
name|qdb_
operator|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the singleton QDocIndexFiles.  */
end_comment
begin_destructor
DECL|function|~QDocIndexFiles
name|QDocIndexFiles
operator|::
name|~
name|QDocIndexFiles
parameter_list|()
block|{
name|qdb_
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Creates the singleton. Allows only one instance of the class   to be created. Returns a pointer to the singleton.  */
end_comment
begin_function
DECL|function|qdocIndexFiles
name|QDocIndexFiles
modifier|*
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdocIndexFiles_
condition|)
name|qdocIndexFiles_
operator|=
operator|new
name|QDocIndexFiles
expr_stmt|;
return|return
name|qdocIndexFiles_
return|;
block|}
end_function
begin_comment
comment|/*!   Destroys the singleton.  */
end_comment
begin_function
DECL|function|destroyQDocIndexFiles
name|void
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
parameter_list|()
block|{
if|if
condition|(
name|qdocIndexFiles_
condition|)
block|{
operator|delete
name|qdocIndexFiles_
expr_stmt|;
name|qdocIndexFiles_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the list of index files in \a indexFiles.  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|QDocIndexFiles
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|indexFiles
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|indexFile
decl|,
name|indexFiles
control|)
block|{
name|QString
name|msg
init|=
literal|"Loading index file: "
operator|+
name|indexFile
decl_stmt|;
name|Location
operator|::
name|logToStdErr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|readIndexFile
argument_list|(
name|indexFile
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the index file at \a path.  */
end_comment
begin_function
DECL|function|readIndexFile
name|void
name|QDocIndexFiles
operator|::
name|readIndexFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QDomDocument
name|document
decl_stmt|;
name|document
operator|.
name|setContent
argument_list|(
operator|&
name|file
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|QDomElement
name|indexElement
init|=
name|document
operator|.
name|documentElement
argument_list|()
decl_stmt|;
comment|// Generate a relative URL between the install dir and the index file
comment|// when the -installdir command line option is set.
name|QString
name|indexUrl
decl_stmt|;
if|if
condition|(
name|Config
operator|::
name|installDir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|indexUrl
operator|=
name|indexElement
operator|.
name|attribute
argument_list|(
literal|"url"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use a fake directory, since we will copy the output to a sub directory of
comment|// installDir when using "make install". This is just for a proper relative path.
comment|//QDir installDir(path.section('/', 0, -3) + "/outputdir");
name|QDir
name|installDir
argument_list|(
name|path
operator|.
name|section
argument_list|(
literal|'/'
argument_list|,
literal|0
argument_list|,
operator|-
literal|3
argument_list|)
operator|+
literal|'/'
operator|+
name|Generator
operator|::
name|outputSubdir
argument_list|()
argument_list|)
decl_stmt|;
name|indexUrl
operator|=
name|installDir
operator|.
name|relativeFilePath
argument_list|(
name|path
argument_list|)
operator|.
name|section
argument_list|(
literal|'/'
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|project_
operator|=
name|indexElement
operator|.
name|attribute
argument_list|(
literal|"project"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|basesList_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|relatedList_
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Scan all elements in the XML file, constructing a map that contains
comment|// base classes for each class found.
name|QDomElement
name|child
init|=
name|indexElement
operator|.
name|firstChildElement
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|()
expr_stmt|;
block|}
comment|// Now that all the base classes have been found for this index,
comment|// arrange them into an inheritance hierarchy.
name|resolveIndex
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Read a<section> element from the index file and create the   appropriate node(s).  */
end_comment
begin_function
DECL|function|readIndexSection
name|void
name|QDocIndexFiles
operator|::
name|readIndexSection
parameter_list|(
specifier|const
name|QDomElement
modifier|&
name|element
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|indexUrl
parameter_list|)
block|{
name|QString
name|name
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|QString
name|href
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"href"
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|Location
name|location
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"namespace"
condition|)
block|{
name|node
operator|=
operator|new
name|NamespaceNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"class"
condition|)
block|{
name|node
operator|=
operator|new
name|ClassNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|basesList_
operator|.
name|append
argument_list|(
name|QPair
argument_list|<
name|ClassNode
operator|*
argument_list|,
name|QString
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|,
name|element
operator|.
name|attribute
argument_list|(
literal|"bases"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlclass"
operator|)
operator|||
operator|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
operator|)
operator|&&
operator|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlclass"
operator|)
operator|)
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
operator|new
name|QmlClassNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|qcn
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|qmlModuleName
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"qml-module-name"
argument_list|)
decl_stmt|;
name|QString
name|qmlModuleVersion
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"qml-module-version"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qmlModuleName
operator|.
name|isEmpty
argument_list|()
condition|)
name|qdb_
operator|->
name|addToQmlModule
argument_list|(
name|qmlModuleName
operator|+
literal|" "
operator|+
name|qmlModuleVersion
argument_list|,
name|qcn
argument_list|)
expr_stmt|;
name|QString
name|qmlFullBaseName
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"qml-base-type"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qmlFullBaseName
operator|.
name|isEmpty
argument_list|()
condition|)
name|qcn
operator|->
name|setQmlBaseName
argument_list|(
name|qmlFullBaseName
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node
operator|=
name|qcn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlbasictype"
condition|)
block|{
name|QmlBasicTypeNode
modifier|*
name|qbtn
init|=
operator|new
name|QmlBasicTypeNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|qbtn
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node
operator|=
name|qbtn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlpropertygroup"
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|QmlPropertyGroupNode
modifier|*
name|qpgn
init|=
operator|new
name|QmlPropertyGroupNode
argument_list|(
name|qcn
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node
operator|=
name|qpgn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlproperty"
condition|)
block|{
name|QString
name|type
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
name|bool
name|attached
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"attached"
argument_list|)
operator|==
literal|"true"
condition|)
name|attached
operator|=
literal|true
expr_stmt|;
name|bool
name|readonly
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"writable"
argument_list|)
operator|==
literal|"false"
condition|)
name|readonly
operator|=
literal|true
expr_stmt|;
name|QmlPropertyNode
modifier|*
name|qpn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|qpn
operator|=
operator|new
name|QmlPropertyNode
argument_list|(
name|qcn
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QmlPropertyGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyGroupNode
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|qpn
operator|=
operator|new
name|QmlPropertyNode
argument_list|(
name|qpgn
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
expr_stmt|;
block|}
name|qpn
operator|->
name|setReadOnly
argument_list|(
name|readonly
argument_list|)
expr_stmt|;
name|node
operator|=
name|qpn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlmethod"
operator|)
operator|||
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlsignal"
operator|)
operator|||
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlsignalhandler"
operator|)
condition|)
block|{
name|Node
operator|::
name|Type
name|t
init|=
name|Node
operator|::
name|QmlMethod
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlsignal"
condition|)
name|t
operator|=
name|Node
operator|::
name|QmlSignal
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlsignalhandler"
condition|)
name|t
operator|=
name|Node
operator|::
name|QmlSignalHandler
expr_stmt|;
name|bool
name|attached
init|=
literal|false
decl_stmt|;
name|FunctionNode
modifier|*
name|fn
init|=
operator|new
name|FunctionNode
argument_list|(
name|t
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|attached
argument_list|)
decl_stmt|;
name|node
operator|=
name|fn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
condition|)
block|{
name|Node
operator|::
name|SubType
name|subtype
decl_stmt|;
name|Node
operator|::
name|PageType
name|ptype
init|=
name|Node
operator|::
name|NoPageType
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"example"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Example
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ExamplePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"header"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|HeaderFile
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"file"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|File
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|NoPageType
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"group"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Group
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"module"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Module
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlmodule"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlModule
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"page"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Page
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ArticlePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"externalpage"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|ExternalPage
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ArticlePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlclass"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlClass
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlbasictype"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlBasicType
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
else|else
return|return;
name|DocNode
modifier|*
name|docNode
init|=
operator|new
name|DocNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|subtype
argument_list|,
name|ptype
argument_list|)
decl_stmt|;
name|docNode
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node
operator|=
name|docNode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"enum"
condition|)
block|{
name|EnumNode
modifier|*
name|enumNode
init|=
operator|new
name|EnumNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|EnumItem
name|item
argument_list|(
name|child
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"value"
argument_list|)
argument_list|)
decl_stmt|;
name|enumNode
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|enumNode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"typedef"
condition|)
block|{
name|node
operator|=
operator|new
name|TypedefNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"property"
condition|)
block|{
name|node
operator|=
operator|new
name|PropertyNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"function"
condition|)
block|{
name|FunctionNode
operator|::
name|Virtualness
name|virt
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"non"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|NonVirtual
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"impure"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|ImpureVirtual
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"pure"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|PureVirtual
expr_stmt|;
else|else
return|return;
name|FunctionNode
operator|::
name|Metaness
name|meta
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"plain"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"signal"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Signal
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"slot"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Slot
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"constructor"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Ctor
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"destructor"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Dtor
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macro"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithParams
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macrowithparams"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithParams
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macrowithoutparams"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithoutParams
expr_stmt|;
else|else
return|return;
name|FunctionNode
modifier|*
name|functionNode
init|=
operator|new
name|FunctionNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|functionNode
operator|->
name|setReturnType
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"return"
argument_list|)
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setVirtualness
argument_list|(
name|virt
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setMetaness
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setConst
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"const"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setStatic
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"static"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setOverload
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"overload"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"relates"
argument_list|)
operator|&&
name|element
operator|.
name|attribute
argument_list|(
literal|"relates"
argument_list|)
operator|!=
name|parent
operator|->
name|name
argument_list|()
condition|)
block|{
name|relatedList_
operator|.
name|append
argument_list|(
name|QPair
argument_list|<
name|FunctionNode
operator|*
argument_list|,
name|QString
argument_list|>
argument_list|(
name|functionNode
argument_list|,
name|element
operator|.
name|attribute
argument_list|(
literal|"relates"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|(
literal|"parameter"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Do not use the default value for the parameter; it is not
comment|// required, and has been known to cause problems.
name|Parameter
name|parameter
argument_list|(
name|child
operator|.
name|attribute
argument_list|(
literal|"left"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"right"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
decl_stmt|;
comment|// child.attribute("default")
name|functionNode
operator|->
name|addParameter
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|(
literal|"parameter"
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|functionNode
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"variable"
condition|)
block|{
name|node
operator|=
operator|new
name|VariableNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"keyword"
condition|)
block|{
name|qdb_
operator|->
name|insertTarget
argument_list|(
name|name
argument_list|,
name|TargetRec
operator|::
name|Keyword
argument_list|,
name|parent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"target"
condition|)
block|{
name|qdb_
operator|->
name|insertTarget
argument_list|(
name|name
argument_list|,
name|TargetRec
operator|::
name|Target
argument_list|,
name|parent
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"contents"
condition|)
block|{
name|qdb_
operator|->
name|insertTarget
argument_list|(
name|name
argument_list|,
name|TargetRec
operator|::
name|Contents
argument_list|,
name|parent
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
return|return;
name|QString
name|access
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"access"
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
operator|==
literal|"public"
condition|)
name|node
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|"protected"
condition|)
name|node
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|"private"
condition|)
name|node
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Private
argument_list|)
expr_stmt|;
else|else
name|node
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"page"
operator|)
operator|&&
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"qmlclass"
operator|)
operator|&&
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"qmlbasictype"
operator|)
condition|)
block|{
name|QString
name|threadSafety
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"threadsafety"
argument_list|)
decl_stmt|;
if|if
condition|(
name|threadSafety
operator|==
literal|"non-reentrant"
condition|)
name|node
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|NonReentrant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|threadSafety
operator|==
literal|"reentrant"
condition|)
name|node
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|Reentrant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|threadSafety
operator|==
literal|"thread safe"
condition|)
name|node
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|ThreadSafe
argument_list|)
expr_stmt|;
else|else
name|node
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|UnspecifiedSafeness
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|UnspecifiedSafeness
argument_list|)
expr_stmt|;
name|QString
name|status
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"status"
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|"compat"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Compat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"obsolete"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"deprecated"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"preliminary"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Preliminary
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"commendable"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Commendable
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"internal"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Internal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"main"
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Main
argument_list|)
expr_stmt|;
else|else
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Commendable
argument_list|)
expr_stmt|;
name|QString
name|moduleName
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"module"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|moduleName
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|->
name|setModuleName
argument_list|(
name|moduleName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|node
operator|->
name|setUrl
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|href
argument_list|)
expr_stmt|;
block|}
name|QString
name|since
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"since"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|since
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|node
operator|->
name|setSince
argument_list|(
name|since
argument_list|)
expr_stmt|;
block|}
name|QString
name|groupsAttr
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"groups"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|groupsAttr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|groupNames
init|=
name|groupsAttr
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupNames
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|qdb_
operator|->
name|findGroup
argument_list|(
name|groupNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
condition|)
block|{
name|dn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qDebug
argument_list|()
operator|<<
literal|"NODE:"
operator|<<
name|node
operator|->
name|name
argument_list|()
operator|<<
literal|"GROUPS:"
operator|<<
name|groupNames
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"DID NOT FIND GROUP:"
operator|<<
name|dn
operator|->
name|name
argument_list|()
operator|<<
literal|"for:"
operator|<<
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Create some content for the node.
name|QSet
argument_list|<
name|QString
argument_list|>
name|emptySet
decl_stmt|;
name|Doc
name|doc
argument_list|(
name|location
argument_list|,
name|location
argument_list|,
literal|" "
argument_list|,
name|emptySet
argument_list|,
name|emptySet
argument_list|)
decl_stmt|;
comment|// placeholder
name|node
operator|->
name|setDoc
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|node
operator|->
name|setIndexNodeFlag
argument_list|()
expr_stmt|;
name|node
operator|->
name|setOutputSubdirectory
argument_list|(
name|project_
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|briefAttr
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"brief"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|briefAttr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|node
operator|->
name|setReconstitutedBrief
argument_list|(
name|briefAttr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"class"
condition|)
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlclass"
condition|)
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
condition|)
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"namespace"
operator|&&
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The root node in the index is a namespace with an empty name.
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|parent
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
block|}
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveIndex
name|void
name|QDocIndexFiles
operator|::
name|resolveIndex
parameter_list|()
block|{
name|QPair
argument_list|<
name|ClassNode
modifier|*
argument_list|,
name|QString
argument_list|>
name|pair
decl_stmt|;
foreach|foreach
control|(
name|pair
init|,
name|basesList_
control|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|base
decl|,
name|pair
operator|.
name|second
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|base
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|pair
operator|.
name|first
operator|->
name|addBaseClass
argument_list|(
name|Node
operator|::
name|Public
argument_list|,
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QPair
argument_list|<
name|FunctionNode
modifier|*
argument_list|,
name|QString
argument_list|>
name|relatedPair
decl_stmt|;
foreach|foreach
control|(
name|relatedPair
init|,
name|relatedList_
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|relatedPair
operator|.
name|second
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|relatedPair
operator|.
name|first
operator|->
name|setRelates
argument_list|(
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Normally this is used for writing the \e groups attribute,   but it can be used for writing any attribute with a list   value that comes from some subset of the members of \a n.    \note The members of \a n are \e not the children of \a n.    The names we want to include are the names of the members   of \a n that have node type \a t and node subtype \a st.   The attribute name is \a attr. The names are joined with   the space character and written with \a writer.  */
end_comment
begin_function
DECL|function|writeMembersAttribute
name|void
name|QDocIndexFiles
operator|::
name|writeMembersAttribute
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|n
parameter_list|,
name|Node
operator|::
name|Type
name|t
parameter_list|,
name|Node
operator|::
name|SubType
name|st
parameter_list|,
specifier|const
name|QString
modifier|&
name|attr
parameter_list|)
block|{
specifier|const
name|NodeList
modifier|&
name|members
init|=
name|n
operator|->
name|members
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|names
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|i
init|=
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|type
argument_list|()
operator|==
name|t
operator|&&
operator|(
operator|*
name|i
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|st
condition|)
name|names
operator|.
name|append
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|names
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
name|attr
argument_list|,
name|names
operator|.
name|join
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate the index section with the given \a writer for the \a node   specified, returning true if an element was written; otherwise returns   false.  */
end_comment
begin_function
DECL|function|generateIndexSection
name|bool
name|QDocIndexFiles
operator|::
name|generateIndexSection
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
comment|/*       Don't include index nodes in a new index file. Or DITA map nodes.      */
if|if
condition|(
name|node
operator|->
name|isIndexNode
argument_list|()
operator|||
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|DitaMap
condition|)
return|return
literal|false
return|;
name|QString
name|nodeName
decl_stmt|;
name|QString
name|qmlModuleName
decl_stmt|;
name|QString
name|qmlModuleVersion
decl_stmt|;
name|QString
name|qmlFullBaseName
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|nodeName
operator|=
literal|"namespace"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|nodeName
operator|=
literal|"class"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Document
case|:
name|nodeName
operator|=
literal|"page"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|nodeName
operator|=
literal|"qmlclass"
expr_stmt|;
name|qmlModuleName
operator|=
name|node
operator|->
name|qmlModuleName
argument_list|()
expr_stmt|;
name|qmlModuleVersion
operator|=
name|node
operator|->
name|qmlModuleVersion
argument_list|()
expr_stmt|;
name|qmlFullBaseName
operator|=
name|node
operator|->
name|qmlFullBaseName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
name|nodeName
operator|=
literal|"qmlbasictype"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|nodeName
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|nodeName
operator|=
literal|"typedef"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|nodeName
operator|=
literal|"property"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|nodeName
operator|=
literal|"function"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|nodeName
operator|=
literal|"variable"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|nodeName
operator|=
literal|"qmlproperty"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
name|nodeName
operator|=
literal|"qmlpropertygroup"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|nodeName
operator|=
literal|"qmlsignal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|nodeName
operator|=
literal|"qmlsignalhandler"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|nodeName
operator|=
literal|"qmlmethod"
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
name|QString
name|access
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|access
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Public
case|:
name|access
operator|=
literal|"public"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Protected
case|:
name|access
operator|=
literal|"protected"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Private
case|:
comment|// Do not include private non-internal nodes in the index.
comment|// (Internal public and protected nodes are marked as private
comment|// by qdoc. We can check their internal status to determine
comment|// whether they were really private to begin with.)
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Internal
operator|&&
name|generateInternalNodes
condition|)
name|access
operator|=
literal|"internal"
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
name|QString
name|objName
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
comment|// Special case: only the root node should have an empty name.
if|if
condition|(
name|objName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|node
operator|!=
name|qdb_
operator|->
name|treeRoot
argument_list|()
condition|)
return|return
literal|false
return|;
name|writer
operator|.
name|writeStartElement
argument_list|(
name|nodeName
argument_list|)
expr_stmt|;
name|QXmlStreamAttributes
name|attributes
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"access"
argument_list|,
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Document
condition|)
block|{
name|QString
name|threadSafety
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|threadSafeness
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|NonReentrant
case|:
name|threadSafety
operator|=
literal|"non-reentrant"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Reentrant
case|:
name|threadSafety
operator|=
literal|"reentrant"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ThreadSafe
case|:
name|threadSafety
operator|=
literal|"thread safe"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|UnspecifiedSafeness
case|:
default|default:
name|threadSafety
operator|=
literal|"unspecified"
expr_stmt|;
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"threadsafety"
argument_list|,
name|threadSafety
argument_list|)
expr_stmt|;
block|}
name|QString
name|status
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Compat
case|:
name|status
operator|=
literal|"compat"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|status
operator|=
literal|"obsolete"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Deprecated
case|:
name|status
operator|=
literal|"obsolete"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Preliminary
case|:
name|status
operator|=
literal|"preliminary"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Commendable
case|:
name|status
operator|=
literal|"commendable"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Internal
case|:
name|status
operator|=
literal|"internal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Main
case|:
default|default:
name|status
operator|=
literal|"main"
expr_stmt|;
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qmlModuleName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"qml-module-name"
argument_list|,
name|qmlModuleName
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"qml-module-version"
argument_list|,
name|qmlModuleVersion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qmlFullBaseName
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"qml-base-type"
argument_list|,
name|qmlFullBaseName
argument_list|)
expr_stmt|;
block|}
name|QString
name|fullName
init|=
name|node
operator|->
name|fullDocumentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullName
operator|!=
name|objName
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"fullname"
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
name|QString
name|href
decl_stmt|;
if|if
condition|(
name|Generator
operator|::
name|useOutputSubdirs
argument_list|()
condition|)
name|href
operator|=
name|node
operator|->
name|outputSubdirectory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|href
operator|.
name|isEmpty
argument_list|()
condition|)
name|href
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|href
operator|.
name|append
argument_list|(
name|gen_
operator|->
name|fullDocumentLocation
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|href
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|isQmlNode
argument_list|()
operator|)
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"location"
argument_list|,
name|node
operator|->
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|since
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"since"
argument_list|,
name|node
operator|->
name|since
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Class
case|:
block|{
comment|// Classes contain information about their base classes.
specifier|const
name|ClassNode
modifier|*
name|classNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
name|bases
init|=
name|classNode
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|baseStrings
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|related
decl|,
name|bases
control|)
block|{
name|ClassNode
modifier|*
name|baseClassNode
init|=
name|related
operator|.
name|node
decl_stmt|;
name|baseStrings
operator|.
name|insert
argument_list|(
name|baseClassNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"bases"
argument_list|,
name|QStringList
argument_list|(
name|baseStrings
operator|.
name|toList
argument_list|()
argument_list|)
operator|.
name|join
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|moduleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|node
operator|->
name|moduleName
argument_list|()
argument_list|)
expr_stmt|;
name|writeMembersAttribute
argument_list|(
name|writer
argument_list|,
name|classNode
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|Group
argument_list|,
literal|"groups"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
block|{
specifier|const
name|NamespaceNode
modifier|*
name|namespaceNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceNode
operator|->
name|moduleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|namespaceNode
operator|->
name|moduleName
argument_list|()
argument_list|)
expr_stmt|;
name|writeMembersAttribute
argument_list|(
name|writer
argument_list|,
name|namespaceNode
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|Group
argument_list|,
literal|"groups"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Document
case|:
block|{
comment|/*               Document nodes (such as manual pages) contain subtypes,               titles and other attributes.             */
name|bool
name|writeModuleName
init|=
literal|false
decl_stmt|;
specifier|const
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|docNode
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Example
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"example"
argument_list|)
expr_stmt|;
name|writeModuleName
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|HeaderFile
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"header"
argument_list|)
expr_stmt|;
name|writeModuleName
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|File
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Group
case|:
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"seen"
argument_list|,
name|docNode
operator|->
name|wasSeen
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
comment|// Groups contain information about their group members.
specifier|const
name|NodeList
modifier|&
name|members
init|=
name|docNode
operator|->
name|members
argument_list|()
decl_stmt|;
name|QStringList
name|names
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|member
decl|,
name|members
control|)
block|{
name|names
operator|.
name|append
argument_list|(
name|member
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"members"
argument_list|,
name|names
operator|.
name|join
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
name|writeModuleName
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Module
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"module"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlModule
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"qmlmodule"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Page
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"page"
argument_list|)
expr_stmt|;
name|writeModuleName
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"externalpage"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlClass
case|:
comment|//writer.writeAttribute("subtype", "qmlclass");
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
comment|//writer.writeAttribute("subtype", "qmlbasictype");
break|break;
default|default:
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|docNode
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"fulltitle"
argument_list|,
name|docNode
operator|->
name|fullTitle
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtitle"
argument_list|,
name|docNode
operator|->
name|subTitle
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"location"
argument_list|,
name|docNode
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|moduleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|writeModuleName
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|node
operator|->
name|moduleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeMembersAttribute
argument_list|(
name|writer
argument_list|,
name|docNode
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|Group
argument_list|,
literal|"groups"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
comment|/*               Function nodes contain information about the type of               function being described.             */
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|functionNode
operator|->
name|virtualness
argument_list|()
condition|)
block|{
case|case
name|FunctionNode
operator|::
name|NonVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"non"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|ImpureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"impure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|PureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"pure"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|functionNode
operator|->
name|metaness
argument_list|()
condition|)
block|{
case|case
name|FunctionNode
operator|::
name|Plain
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"plain"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Signal
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Slot
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Ctor
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Dtor
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"destructor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|MacroWithParams
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"macrowithparams"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|MacroWithoutParams
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"macrowithoutparams"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"const"
argument_list|,
name|functionNode
operator|->
name|isConst
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"static"
argument_list|,
name|functionNode
operator|->
name|isStatic
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"overload"
argument_list|,
name|functionNode
operator|->
name|isOverload
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|isOverload
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"overload-number"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|functionNode
operator|->
name|overloadNumber
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|relates
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"relates"
argument_list|,
name|functionNode
operator|->
name|relates
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|PropertyNode
modifier|*
name|propertyNode
init|=
name|functionNode
operator|->
name|associatedProperty
argument_list|()
decl_stmt|;
if|if
condition|(
name|propertyNode
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"associated-property"
argument_list|,
name|propertyNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|functionNode
operator|->
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|qpn
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"attached"
argument_list|,
name|qpn
operator|->
name|isAttached
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"writable"
argument_list|,
name|qpn
operator|->
name|isWritable
argument_list|(
name|qdb_
argument_list|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
block|{
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Property
case|:
block|{
specifier|const
name|PropertyNode
modifier|*
name|propertyNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|propertyNode
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|getters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"getter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// getter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|setters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"setter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// setter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|resetters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"resetter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// resetter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|notifiers
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"notifier"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// notifier
block|}
block|}
block|}
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
block|{
specifier|const
name|VariableNode
modifier|*
name|variableNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|VariableNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|variableNode
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"static"
argument_list|,
name|variableNode
operator|->
name|isStatic
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"brief"
argument_list|,
name|brief
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// Inner nodes and function nodes contain child nodes of some sort, either
comment|// actual child nodes or function parameters. For these, we close the
comment|// opening tag, create child elements, then add a closing tag for the
comment|// element. Elements for all other nodes are closed in the opening tag.
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// For internal pages, we canonicalize the target, keyword and content
comment|// item names so that they can be used by qdoc for other sets of
comment|// documentation.
comment|// The reason we do this here is that we don't want to ruin
comment|// externally composed indexes, containing non-qdoc-style target names
comment|// when reading in indexes.
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
name|bool
name|external
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
name|external
operator|=
literal|true
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|Atom
modifier|*
name|target
decl|,
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
control|)
block|{
name|QString
name|targetName
init|=
name|target
operator|->
name|string
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
name|targetName
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|targetName
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"target"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|targetName
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// target
block|}
block|}
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|Atom
modifier|*
name|keyword
decl|,
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"keyword"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|keyword
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// keyword
block|}
block|}
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|item
init|=
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|int
name|level
init|=
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContentsLevels
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|item
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"contents"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"level"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// contents
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// Write a signature attribute for convenience.
name|QStringList
name|signatureList
decl_stmt|;
name|QStringList
name|resolvedParameters
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|parameter
decl|,
name|functionNode
operator|->
name|parameters
argument_list|()
control|)
block|{
name|QString
name|leftType
init|=
name|parameter
operator|.
name|leftType
argument_list|()
decl_stmt|;
specifier|const
name|Node
modifier|*
name|leftNode
init|=
name|qdb_
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|leftNode
operator|||
name|leftNode
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Typedef
condition|)
block|{
name|leftNode
operator|=
name|qdb_
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
name|node
operator|->
name|parent
argument_list|()
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftNode
operator|&&
name|leftNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
if|if
condition|(
name|leftNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|leftNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|leftType
operator|=
literal|"QFlags<"
operator|+
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|leftType
operator|=
name|leftNode
operator|->
name|fullDocumentName
argument_list|()
expr_stmt|;
block|}
name|resolvedParameters
operator|.
name|append
argument_list|(
name|leftType
argument_list|)
expr_stmt|;
name|signatureList
operator|.
name|append
argument_list|(
name|leftType
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|parameter
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|signature
init|=
name|functionNode
operator|->
name|name
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
operator|+
name|signatureList
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|isConst
argument_list|()
condition|)
name|signature
operator|+=
literal|" const"
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"signature"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|functionNode
operator|->
name|parameters
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Parameter
name|parameter
init|=
name|functionNode
operator|->
name|parameters
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"parameter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"left"
argument_list|,
name|resolvedParameters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"right"
argument_list|,
name|parameter
operator|.
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|parameter
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"default"
argument_list|,
name|parameter
operator|.
name|defaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// parameter
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enumNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|enumNode
operator|->
name|flagsType
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"typedef"
argument_list|,
name|enumNode
operator|->
name|flagsType
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|enumNode
operator|->
name|items
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|item
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|item
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// value
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"enum"
argument_list|,
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the node \a n1 is less than node \a n2. The   comparison is performed by comparing properties of the nodes   in order of increasing complexity. */
end_comment
begin_function
DECL|function|compareNodes
name|bool
name|compareNodes
parameter_list|(
specifier|const
name|Node
modifier|*
name|n1
parameter_list|,
specifier|const
name|Node
modifier|*
name|n2
parameter_list|)
block|{
comment|// Private nodes can occur in any order since they won't normally be
comment|// written to the index.
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|&&
name|n2
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
operator|<
name|n2
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
operator|>
name|n2
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|<
name|n2
operator|->
name|type
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|>
name|n2
operator|->
name|type
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|name
argument_list|()
operator|<
name|n2
operator|->
name|name
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|name
argument_list|()
operator|>
name|n2
operator|->
name|name
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|<
name|n2
operator|->
name|access
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|>
name|n2
operator|->
name|access
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
operator|&&
name|n2
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|f1
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|n1
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|f2
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|n2
argument_list|)
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|<
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|>
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|f1
operator|->
name|signature
argument_list|()
operator|<
name|f2
operator|->
name|signature
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|signature
argument_list|()
operator|>
name|f2
operator|->
name|signature
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|n2
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|f1
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|n1
argument_list|)
decl_stmt|;
specifier|const
name|DocNode
modifier|*
name|f2
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|n2
argument_list|)
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|fullTitle
argument_list|()
operator|<
name|f2
operator|->
name|fullTitle
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|fullTitle
argument_list|()
operator|>
name|f2
operator|->
name|fullTitle
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Generate index sections for the child nodes of the given \a node   using the \a writer specified. If \a generateInternalNodes is true,   nodes marked as internal will be included in the index; otherwise,   they will be omitted. */
end_comment
begin_function
DECL|function|generateIndexSections
name|void
name|QDocIndexFiles
operator|::
name|generateIndexSections
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
comment|/*       Note that the groups are written after all the other nodes.      */
if|if
condition|(
operator|!
name|node
operator|->
name|isGroup
argument_list|()
operator|&&
name|generateIndexSection
argument_list|(
name|writer
argument_list|,
name|node
argument_list|,
name|generateInternalNodes
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
name|cnodes
init|=
name|inner
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|cnodes
operator|.
name|begin
argument_list|()
argument_list|,
name|cnodes
operator|.
name|end
argument_list|()
argument_list|,
name|compareNodes
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|cnodes
control|)
block|{
comment|/*                   Don't generate anything for a collision node. We want                   children of collision nodes in the index, but leaving                   out the parent collision page will make searching for                   nodes easier.                  */
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|pgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|c
decl|,
name|pgn
operator|->
name|childNodes
argument_list|()
control|)
block|{
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|c
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|child
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Outputs an index file.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|QDocIndexFiles
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
return|return;
name|QString
name|msg
init|=
literal|"Writing index file: "
operator|+
name|fileName
decl_stmt|;
name|Location
operator|::
name|logToStdErr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|gen_
operator|=
name|g
expr_stmt|;
name|QXmlStreamWriter
name|writer
argument_list|(
operator|&
name|file
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartDocument
argument_list|()
expr_stmt|;
name|writer
operator|.
name|writeDTD
argument_list|(
literal|"<!DOCTYPE QDOCINDEX>"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"INDEX"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"url"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"version"
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"project"
argument_list|,
name|g
operator|->
name|config
argument_list|()
operator|->
name|getString
argument_list|(
name|CONFIG_PROJECT
argument_list|)
argument_list|)
expr_stmt|;
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
comment|/*       We wait until the end of the index file to output the group elements.       By waiting until the end, when we read each group element, its members       will have already been created. It is then only necessary to create       the group page and add each member to its member list.      */
specifier|const
name|DocNodeMap
modifier|&
name|groups
init|=
name|qdb_
operator|->
name|groups
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|groups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DocNodeMap
operator|::
name|ConstIterator
name|g
init|=
name|groups
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|g
operator|!=
name|groups
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|generateIndexSection
argument_list|(
name|writer
argument_list|,
name|g
operator|.
name|value
argument_list|()
argument_list|,
name|generateInternalNodes
argument_list|)
condition|)
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
operator|++
name|g
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// INDEX
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// QDOCINDEX
name|writer
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
