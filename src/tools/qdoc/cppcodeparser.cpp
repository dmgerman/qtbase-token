begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   cppcodeparser.cpp */
end_comment
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|"codechunk.h"
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"cppcodeparser.h"
end_include
begin_include
include|#
directive|include
file|"tokenizer.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/* qmake ignore Q_OBJECT */
DECL|member|exampleFiles
name|QStringList
name|CppCodeParser
operator|::
name|exampleFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleDirs
name|QStringList
name|CppCodeParser
operator|::
name|exampleDirs
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   The constructor initializes some regular expressions   and calls reset().  */
end_comment
begin_constructor
DECL|function|CppCodeParser
name|CppCodeParser
operator|::
name|CppCodeParser
parameter_list|()
member_init_list|:
name|varComment
argument_list|(
literal|"/\\*\\s*([a-zA-Z_0-9]+)\\s*\\*/"
argument_list|)
member_init_list|,
name|sep
argument_list|(
literal|"(?:<[^>]+>)?::"
argument_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   The destructor is trivial.  */
end_comment
begin_destructor
DECL|function|~CppCodeParser
name|CppCodeParser
operator|::
name|~
name|CppCodeParser
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   The constructor initializes a map of special node types   for identifying important nodes. And it initializes   some filters for identifying certain kinds of files.  */
end_comment
begin_function
DECL|function|initializeParser
name|void
name|CppCodeParser
operator|::
name|initializeParser
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|CodeParser
operator|::
name|initializeParser
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|/*       All these can appear in a C++ namespace. Don't add       anything that can't be in a C++ namespace.      */
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_NAMESPACE
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|)
expr_stmt|;
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_CLASS
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
expr_stmt|;
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_ENUM
argument_list|,
name|Node
operator|::
name|Enum
argument_list|)
expr_stmt|;
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_TYPEDEF
argument_list|,
name|Node
operator|::
name|Typedef
argument_list|)
expr_stmt|;
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_PROPERTY
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
expr_stmt|;
name|nodeTypeMap
operator|.
name|insert
argument_list|(
name|COMMAND_VARIABLE
argument_list|,
name|Node
operator|::
name|Variable
argument_list|)
expr_stmt|;
name|exampleFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_EXAMPLES
argument_list|)
expr_stmt|;
name|exampleDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_EXAMPLEDIRS
argument_list|)
expr_stmt|;
name|QStringList
name|exampleFilePatterns
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EXAMPLES
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_FILEEXTENSIONS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exampleFilePatterns
operator|.
name|isEmpty
argument_list|()
condition|)
name|exampleNameFilter
operator|=
name|exampleFilePatterns
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|exampleNameFilter
operator|=
literal|"*.cpp *.h *.js *.xq *.svg *.xml *.dita *.ui"
expr_stmt|;
name|QStringList
name|exampleImagePatterns
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EXAMPLES
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_IMAGEEXTENSIONS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exampleImagePatterns
operator|.
name|isEmpty
argument_list|()
condition|)
name|exampleImageFilter
operator|=
name|exampleImagePatterns
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|exampleImageFilter
operator|=
literal|"*.png"
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Clear the map of common node types and call   the same function in the base class.  */
end_comment
begin_function
DECL|function|terminateParser
name|void
name|CppCodeParser
operator|::
name|terminateParser
parameter_list|()
block|{
name|nodeTypeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|CodeParser
operator|::
name|terminateParser
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns "Cpp".  */
end_comment
begin_function
DECL|function|language
name|QString
name|CppCodeParser
operator|::
name|language
parameter_list|()
block|{
return|return
literal|"Cpp"
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a list of extensions for header files.  */
end_comment
begin_function
DECL|function|headerFileNameFilter
name|QStringList
name|CppCodeParser
operator|::
name|headerFileNameFilter
parameter_list|()
block|{
return|return
name|QStringList
argument_list|()
operator|<<
literal|"*.ch"
operator|<<
literal|"*.h"
operator|<<
literal|"*.h++"
operator|<<
literal|"*.hh"
operator|<<
literal|"*.hpp"
operator|<<
literal|"*.hxx"
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a list of extensions for source files, i.e. not   header files.  */
end_comment
begin_function
DECL|function|sourceFileNameFilter
name|QStringList
name|CppCodeParser
operator|::
name|sourceFileNameFilter
parameter_list|()
block|{
return|return
name|QStringList
argument_list|()
operator|<<
literal|"*.c++"
operator|<<
literal|"*.cc"
operator|<<
literal|"*.cpp"
operator|<<
literal|"*.cxx"
operator|<<
literal|"*.mm"
return|;
block|}
end_function
begin_comment
comment|/*!   Parse the C++ header file identified by \a filePath and add   the parsed contents to the database. The \a location is used   for reporting errors.  */
end_comment
begin_function
DECL|function|parseHeaderFile
name|void
name|CppCodeParser
operator|::
name|parseHeaderFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
name|QFile
name|in
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|currentFile_
operator|=
name|filePath
expr_stmt|;
if|if
condition|(
operator|!
name|in
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|error
argument_list|(
name|tr
argument_list|(
literal|"Cannot open C++ header file '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
name|currentFile_
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|reset
argument_list|()
expr_stmt|;
name|Location
name|fileLocation
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|Tokenizer
name|fileTokenizer
argument_list|(
name|fileLocation
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|tokenizer
operator|=
operator|&
name|fileTokenizer
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|matchDeclList
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileTokenizer
operator|.
name|version
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|qdb_
operator|->
name|setVersion
argument_list|(
name|fileTokenizer
operator|.
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileLocation
operator|.
name|fileName
argument_list|()
operator|==
literal|"qiterator.h"
condition|)
name|parseQiteratorDotH
argument_list|(
name|location
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
name|currentFile_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Get ready to parse the C++ cpp file identified by \a filePath   and add its parsed contents to the database. \a location is   used for reporting errors.    Call matchDocsAndStuff() to do all the parsing and tree building.  */
end_comment
begin_function
DECL|function|parseSourceFile
name|void
name|CppCodeParser
operator|::
name|parseSourceFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
name|QFile
name|in
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|currentFile_
operator|=
name|filePath
expr_stmt|;
if|if
condition|(
operator|!
name|in
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|error
argument_list|(
name|tr
argument_list|(
literal|"Cannot open C++ source file '%1' (%2)"
argument_list|)
operator|.
name|arg
argument_list|(
name|filePath
argument_list|)
operator|.
name|arg
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|currentFile_
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|reset
argument_list|()
expr_stmt|;
name|Location
name|fileLocation
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|Tokenizer
name|fileTokenizer
argument_list|(
name|fileLocation
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|tokenizer
operator|=
operator|&
name|fileTokenizer
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
comment|/*       The set of active namespaces is cleared before parsing       each source file. The word "source" here means cpp file.      */
name|activeNamespaces_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|matchDocsAndStuff
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentFile_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This is called after all the header files have been parsed.   I think the most important thing it does is resolve class   inheritance links in the tree. But it also initializes a   bunch of stuff.  */
end_comment
begin_function
DECL|function|doneParsingHeaderFiles
name|void
name|CppCodeParser
operator|::
name|doneParsingHeaderFiles
parameter_list|()
block|{
name|qdb_
operator|->
name|resolveInheritance
argument_list|()
expr_stmt|;
name|QMapIterator
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|i
argument_list|(
name|sequentialIteratorClasses
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|instantiateIteratorMacro
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
name|sequentialIteratorDefinition
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|mutableSequentialIteratorClasses
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|instantiateIteratorMacro
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
name|mutableSequentialIteratorDefinition
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|associativeIteratorClasses
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|instantiateIteratorMacro
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
name|associativeIteratorDefinition
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|mutableAssociativeIteratorClasses
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|instantiateIteratorMacro
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
name|mutableAssociativeIteratorDefinition
argument_list|)
expr_stmt|;
block|}
name|sequentialIteratorDefinition
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mutableSequentialIteratorDefinition
operator|.
name|clear
argument_list|()
expr_stmt|;
name|associativeIteratorDefinition
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mutableAssociativeIteratorDefinition
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sequentialIteratorClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mutableSequentialIteratorClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|associativeIteratorClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mutableAssociativeIteratorClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This is called after all the source files (i.e., not the   header files) have been parsed. It traverses the tree to   resolve property links, normalize overload signatures, and   do other housekeeping of the database.  */
end_comment
begin_function
DECL|function|doneParsingSourceFiles
name|void
name|CppCodeParser
operator|::
name|doneParsingSourceFiles
parameter_list|()
block|{
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|clearCurrentChildPointers
argument_list|()
expr_stmt|;
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|normalizeOverloads
argument_list|()
expr_stmt|;
name|qdb_
operator|->
name|fixInheritance
argument_list|()
expr_stmt|;
name|qdb_
operator|->
name|resolveProperties
argument_list|()
expr_stmt|;
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|makeUndocumentedChildrenInternal
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the set of strings reopresenting the topic commands.  */
end_comment
begin_function
DECL|function|topicCommands
name|QSet
argument_list|<
name|QString
argument_list|>
name|CppCodeParser
operator|::
name|topicCommands
parameter_list|()
block|{
return|return
name|QSet
argument_list|<
name|QString
argument_list|>
argument_list|()
operator|<<
name|COMMAND_CLASS
operator|<<
name|COMMAND_DITAMAP
operator|<<
name|COMMAND_ENUM
operator|<<
name|COMMAND_EXAMPLE
operator|<<
name|COMMAND_EXTERNALPAGE
operator|<<
name|COMMAND_FILE
operator|<<
name|COMMAND_FN
operator|<<
name|COMMAND_GROUP
operator|<<
name|COMMAND_HEADERFILE
operator|<<
name|COMMAND_MACRO
operator|<<
name|COMMAND_MODULE
operator|<<
name|COMMAND_NAMESPACE
operator|<<
name|COMMAND_PAGE
operator|<<
name|COMMAND_PROPERTY
operator|<<
name|COMMAND_TYPEDEF
operator|<<
name|COMMAND_VARIABLE
operator|<<
name|COMMAND_QMLCLASS
operator|<<
name|COMMAND_QMLTYPE
operator|<<
name|COMMAND_QMLPROPERTY
operator|<<
name|COMMAND_QMLATTACHEDPROPERTY
operator|<<
name|COMMAND_QMLSIGNAL
operator|<<
name|COMMAND_QMLATTACHEDSIGNAL
operator|<<
name|COMMAND_QMLMETHOD
operator|<<
name|COMMAND_QMLATTACHEDMETHOD
operator|<<
name|COMMAND_QMLBASICTYPE
operator|<<
name|COMMAND_QMLMODULE
return|;
block|}
end_function
begin_comment
comment|/*!   Process the topic \a command found in the \a doc with argument \a arg.  */
end_comment
begin_function
DECL|function|processTopicCommand
name|Node
modifier|*
name|CppCodeParser
operator|::
name|processTopicCommand
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|command
parameter_list|,
specifier|const
name|ArgLocPair
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|command
operator|==
name|COMMAND_FN
condition|)
block|{
name|QStringList
name|parentPath
decl_stmt|;
name|FunctionNode
modifier|*
name|func
init|=
literal|0
decl_stmt|;
name|FunctionNode
modifier|*
name|clone
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|makeFunctionNode
argument_list|(
name|arg
operator|.
name|first
argument_list|,
operator|&
name|parentPath
argument_list|,
operator|&
name|clone
argument_list|)
operator|&&
operator|!
name|makeFunctionNode
argument_list|(
literal|"void "
operator|+
name|arg
operator|.
name|first
argument_list|,
operator|&
name|parentPath
argument_list|,
operator|&
name|clone
argument_list|)
condition|)
block|{
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid syntax in '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_FN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|activeNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|usedNamespace_
decl|,
name|activeNamespaces_
control|)
block|{
name|QStringList
name|newPath
init|=
name|usedNamespace_
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|parentPath
decl_stmt|;
name|func
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|newPath
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
break|break;
block|}
block|}
comment|// Search the root namespace if no match was found.
if|if
condition|(
name|func
operator|==
literal|0
condition|)
name|func
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|parentPath
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parentPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|lastPath_
operator|.
name|isEmpty
argument_list|()
condition|)
name|func
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|lastPath_
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find '%1' in '\\%2' %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|clone
operator|->
name|name
argument_list|()
operator|+
literal|"(...)"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_FN
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
operator|.
name|first
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"I cannot find any function of that name with the "
literal|"specified signature. Make sure that the signature "
literal|"is identical to the declaration, including 'const' "
literal|"qualifiers."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '%1::' for '%2' in '\\%3'"
argument_list|)
operator|.
name|arg
argument_list|(
name|lastPath_
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|clone
operator|->
name|name
argument_list|()
operator|+
literal|"()"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_FN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastPath_
operator|=
name|parentPath
expr_stmt|;
block|}
if|if
condition|(
name|func
condition|)
block|{
name|func
operator|->
name|borrowParameterNames
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|func
operator|->
name|setParentPath
argument_list|(
name|clone
operator|->
name|parentPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|delete
name|clone
expr_stmt|;
block|}
return|return
name|func
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_MACRO
condition|)
block|{
name|QStringList
name|parentPath
decl_stmt|;
name|FunctionNode
modifier|*
name|func
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|makeFunctionNode
argument_list|(
name|arg
operator|.
name|first
argument_list|,
operator|&
name|parentPath
argument_list|,
operator|&
name|func
argument_list|,
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parentPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid syntax in '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_MACRO
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
name|func
expr_stmt|;
name|func
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|setMetaness
argument_list|(
name|FunctionNode
operator|::
name|MacroWithParams
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
name|params
init|=
name|func
operator|->
name|parameters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Parameter
modifier|&
name|param
init|=
name|params
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|param
operator|.
name|leftType
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|param
operator|.
name|leftType
argument_list|()
operator|!=
literal|"..."
condition|)
name|param
operator|=
name|Parameter
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|param
operator|.
name|leftType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|func
operator|->
name|setParameters
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|func
return|;
block|}
elseif|else
if|if
condition|(
name|QRegExp
argument_list|(
literal|"[A-Za-z_][A-Za-z0-9_]+"
argument_list|)
operator|.
name|exactMatch
argument_list|(
name|arg
operator|.
name|first
argument_list|)
condition|)
block|{
name|func
operator|=
operator|new
name|FunctionNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|)
expr_stmt|;
name|func
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
name|func
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
name|func
operator|->
name|setMetaness
argument_list|(
name|FunctionNode
operator|::
name|MacroWithoutParams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid syntax in '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_MACRO
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|func
return|;
block|}
elseif|else
if|if
condition|(
name|nodeTypeMap
operator|.
name|contains
argument_list|(
name|command
argument_list|)
condition|)
block|{
comment|/*           We should only get in here if the command refers to           something that can appear in a C++ namespace,           i.e. a class, another namespace, an enum, a typedef,           a property or a variable. I think these are handled           this way to allow the writer to refer to the entity           without including the namespace qualifier.          */
name|Node
operator|::
name|Type
name|type
init|=
name|nodeTypeMap
index|[
name|command
index|]
decl_stmt|;
name|Node
operator|::
name|SubType
name|subtype
init|=
name|Node
operator|::
name|NoSubType
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|Document
condition|)
name|subtype
operator|=
name|Node
operator|::
name|QmlClass
expr_stmt|;
name|QStringList
name|paths
init|=
name|arg
operator|.
name|first
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
name|path
init|=
name|paths
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
comment|/*           If the command refers to something that can be in a           C++ namespace, search for it first in all the known           C++ namespaces.          */
if|if
condition|(
operator|!
name|activeNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|usedNamespace_
decl|,
name|activeNamespaces_
control|)
block|{
name|QStringList
name|newPath
init|=
name|usedNamespace_
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|path
decl_stmt|;
name|node
operator|=
name|qdb_
operator|->
name|findNodeByNameAndType
argument_list|(
name|newPath
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|path
operator|=
name|newPath
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*           If the node was not found in a C++ namespace, search           for it in the root namespace.          */
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|node
operator|=
name|qdb_
operator|->
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find '%1' specified with '\\%2' in any header file"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
operator|.
name|first
argument_list|)
operator|.
name|arg
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|lastPath_
operator|=
name|path
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
comment|/*               This treets a class as a namespace.              */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|path
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|QString
name|ns
init|=
name|path
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|activeNamespaces_
operator|.
name|insert
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_EXAMPLE
condition|)
block|{
if|if
condition|(
name|Config
operator|::
name|generateExamples
condition|)
block|{
name|ExampleNode
modifier|*
name|en
init|=
operator|new
name|ExampleNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|en
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
name|createExampleFileNodes
argument_list|(
name|en
argument_list|)
expr_stmt|;
return|return
name|en
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_EXTERNALPAGE
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|,
name|Node
operator|::
name|ExternalPage
argument_list|,
name|Node
operator|::
name|ArticlePage
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_FILE
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|,
name|Node
operator|::
name|File
argument_list|,
name|Node
operator|::
name|NoPageType
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_GROUP
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|qdb_
operator|->
name|addGroup
argument_list|(
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_HEADERFILE
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|,
name|Node
operator|::
name|HeaderFile
argument_list|,
name|Node
operator|::
name|ApiPage
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_MODULE
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|qdb_
operator|->
name|addModule
argument_list|(
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLMODULE
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|qdb_
operator|->
name|addQmlModule
argument_list|(
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_PAGE
condition|)
block|{
name|Node
operator|::
name|PageType
name|ptype
init|=
name|Node
operator|::
name|ArticlePage
decl_stmt|;
name|QStringList
name|args
init|=
name|arg
operator|.
name|first
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QString
name|t
init|=
name|args
index|[
literal|1
index|]
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|"howto"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|HowToPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"api"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"example"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|ExamplePage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"overview"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"tutorial"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|TutorialPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"faq"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|FAQPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"ditamap"
condition|)
name|ptype
operator|=
name|Node
operator|::
name|DitaMapPage
expr_stmt|;
block|}
comment|/*           Search for a node with the same name. If there is one,           then there is a collision, so create a collision node           and make the existing node a child of the collision           node, and then create the new Page node and make           it a child of the collision node as well. Return the           collision node.            If there is no collision, just create a new Page           node and return that one.         */
name|NameCollisionNode
modifier|*
name|ncn
init|=
name|qdb_
operator|->
name|checkForCollision
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|DocNode
modifier|*
name|dn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ptype
operator|==
name|Node
operator|::
name|DitaMapPage
condition|)
name|dn
operator|=
operator|new
name|DitaMapNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|dn
operator|=
operator|new
name|DocNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|Node
operator|::
name|Page
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncn
condition|)
block|{
name|ncn
operator|->
name|addCollision
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_DITAMAP
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DitaMapNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|dn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|command
operator|==
name|COMMAND_QMLCLASS
operator|)
operator|||
operator|(
name|command
operator|==
name|COMMAND_QMLTYPE
operator|)
condition|)
block|{
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLCLASS
condition|)
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\\qmlclass is deprecated; use \\qmltype instead"
argument_list|)
argument_list|)
expr_stmt|;
name|ClassNode
modifier|*
name|classNode
init|=
literal|0
decl_stmt|;
name|QStringList
name|names
init|=
name|arg
operator|.
name|first
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|names
index|[
literal|1
index|]
operator|!=
literal|"0"
condition|)
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\\qmltype no longer has a 2nd argument; "
literal|"use '\\instantiates<class>' in \\qmltype "
literal|"comments instead"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"The 0 arg is no longer used for indicating "
literal|"that the QML type does not instantiate a "
literal|"C++ class"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*               If the second argument of the \\qmlclass command               is 0 we should ignore the C++ class. The second               argument should only be 0 when you are documenting               QML in a .qdoc file.              */
if|if
condition|(
name|names
index|[
literal|1
index|]
operator|!=
literal|"0"
condition|)
name|classNode
operator|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
name|names
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*           Search for a node with the same name. If there is one,           then there is a collision, so create a collision node           and make the existing node a child of the collision           node, and then create the new QML class node and make           it a child of the collision node as well. Return the           collision node.            If there is no collision, just create a new QML class           node and return that one.          */
name|NameCollisionNode
modifier|*
name|ncn
init|=
name|qdb_
operator|->
name|checkForCollision
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|QmlClassNode
modifier|*
name|qcn
init|=
operator|new
name|QmlClassNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|qcn
operator|->
name|setClassNode
argument_list|(
name|classNode
argument_list|)
expr_stmt|;
name|qcn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// to be removed if \qmltype and \instantiates work ok
block|if (isParsingCpp() || isParsingQdoc()) {             qcn->requireCppClass();             if (names.size()< 2) {                 QString msg = "C++ class name not specified for class documented as "                     "QML type: '\\qmlclass " + arg.first + "<class name>'";                 doc.startLocation().warning(tr(msg.toLatin1().data()));             }             else if (!classNode) {                 QString msg = "C++ class not found in any .h file for class documented "                     "as QML type: '\\qmlclass " + arg.first + "'";                 doc.startLocation().warning(tr(msg.toLatin1().data()));             }         }
endif|#
directive|endif
if|if
condition|(
name|ncn
condition|)
name|ncn
operator|->
name|addCollision
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
return|return
name|qcn
return|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLBASICTYPE
condition|)
block|{
name|QmlBasicTypeNode
modifier|*
name|n
init|=
operator|new
name|QmlBasicTypeNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|,
name|arg
operator|.
name|first
argument_list|)
decl_stmt|;
name|n
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|command
operator|==
name|COMMAND_QMLSIGNAL
operator|)
operator|||
operator|(
name|command
operator|==
name|COMMAND_QMLMETHOD
operator|)
operator|||
operator|(
name|command
operator|==
name|COMMAND_QMLATTACHEDSIGNAL
operator|)
operator|||
operator|(
name|command
operator|==
name|COMMAND_QMLATTACHEDMETHOD
operator|)
condition|)
block|{
name|QString
name|module
decl_stmt|;
name|QString
name|element
decl_stmt|;
name|QString
name|type
decl_stmt|;
if|if
condition|(
name|splitQmlMethodArg
argument_list|(
name|arg
operator|.
name|first
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|element
argument_list|)
condition|)
block|{
name|QmlClassNode
modifier|*
name|qmlClass
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|module
argument_list|,
name|element
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmlClass
condition|)
block|{
name|bool
name|attached
init|=
literal|false
decl_stmt|;
name|Node
operator|::
name|Type
name|nodeType
init|=
name|Node
operator|::
name|QmlMethod
decl_stmt|;
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLSIGNAL
condition|)
name|nodeType
operator|=
name|Node
operator|::
name|QmlSignal
expr_stmt|;
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLATTACHEDSIGNAL
condition|)
block|{
name|nodeType
operator|=
name|Node
operator|::
name|QmlSignal
expr_stmt|;
name|attached
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLMETHOD
condition|)
block|{
comment|// do nothing
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLATTACHEDMETHOD
condition|)
name|attached
operator|=
literal|true
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|// never get here.
name|FunctionNode
modifier|*
name|fn
init|=
name|makeFunctionNode
argument_list|(
name|doc
argument_list|,
name|arg
operator|.
name|first
argument_list|,
name|qmlClass
argument_list|,
name|nodeType
argument_list|,
name|attached
argument_list|,
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|fn
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   A QML property argument has the form...<type><element>::<name><type><QML-module>::<element>::<name>    This function splits the argument into one of those   two forms. The three part form is the old form, which   was used before the creation of QtQuick 2 and Qt   Components. A<QML-module> is the QML equivalent of a   C++ namespace. So this function splits \a arg on "::"   and stores the parts in \a type, \a module, \a element,   and \a name, and returns true. If any part other than   \a module is not found, a qdoc warning is emitted and   false is returned.    \note The two elements \e{Component} and \e{QtObject} never   have a module qualifier.  */
end_comment
begin_function
DECL|function|splitQmlPropertyArg
name|bool
name|CppCodeParser
operator|::
name|splitQmlPropertyArg
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|,
name|QString
modifier|&
name|type
parameter_list|,
name|QString
modifier|&
name|module
parameter_list|,
name|QString
modifier|&
name|element
parameter_list|,
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QStringList
name|blankSplit
init|=
name|arg
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|type
operator|=
name|blankSplit
index|[
literal|0
index|]
expr_stmt|;
name|QStringList
name|colonSplit
argument_list|(
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|module
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
name|element
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
name|name
operator|=
name|colonSplit
index|[
literal|2
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|module
operator|.
name|clear
argument_list|()
expr_stmt|;
name|element
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
name|name
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QString
name|msg
init|=
literal|"Unrecognizable QML module/component qualifier for "
operator|+
name|arg
decl_stmt|;
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|msg
init|=
literal|"Missing property type for "
operator|+
name|arg
decl_stmt|;
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   A QML signal or method argument has the form...<type><element>::<name>(<param>,<param>, ...)<type><QML-module>::<element>::<name>(<param>,<param>, ...)    This function splits the argument into one of those two   forms, sets \a module, \a element, and \a name, and returns   true. If the argument doesn't match either form, an error   message is emitted and false is returned.    \note The two elements \e{Component} and \e{QtObject} never   have a module qualifier.  */
end_comment
begin_function
DECL|function|splitQmlMethodArg
name|bool
name|CppCodeParser
operator|::
name|splitQmlMethodArg
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|,
name|QString
modifier|&
name|type
parameter_list|,
name|QString
modifier|&
name|module
parameter_list|,
name|QString
modifier|&
name|element
parameter_list|)
block|{
name|QStringList
name|colonSplit
argument_list|(
name|arg
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QStringList
name|blankSplit
init|=
name|colonSplit
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|type
operator|=
name|blankSplit
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|module
operator|=
name|blankSplit
index|[
literal|1
index|]
expr_stmt|;
name|element
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|module
operator|.
name|clear
argument_list|()
expr_stmt|;
name|element
operator|=
name|blankSplit
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|module
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
name|element
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|module
operator|.
name|clear
argument_list|()
expr_stmt|;
name|element
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|QString
name|msg
init|=
literal|"Unrecognizable QML module/component qualifier for "
operator|+
name|arg
decl_stmt|;
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Process the topic \a command group found in the \a doc with arguments \a args.    Currently, this function is called only for \e{qmlproperty}   and \e{qmlattachedproperty}.  */
end_comment
begin_function
DECL|function|processTopicCommandGroup
name|Node
modifier|*
name|CppCodeParser
operator|::
name|processTopicCommandGroup
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|command
parameter_list|,
specifier|const
name|ArgList
modifier|&
name|args
parameter_list|)
block|{
name|QmlPropGroupNode
modifier|*
name|qmlPropGroup
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|command
operator|==
name|COMMAND_QMLPROPERTY
operator|)
operator|||
operator|(
name|command
operator|==
name|COMMAND_QMLATTACHEDPROPERTY
operator|)
condition|)
block|{
name|QString
name|arg
decl_stmt|;
name|QString
name|type
decl_stmt|;
name|QString
name|module
decl_stmt|;
name|QString
name|element
decl_stmt|;
name|QString
name|property
decl_stmt|;
name|QmlClassNode
modifier|*
name|qmlClass
init|=
literal|0
decl_stmt|;
name|bool
name|attached
init|=
operator|(
name|command
operator|==
name|COMMAND_QMLATTACHEDPROPERTY
operator|)
decl_stmt|;
name|ArgList
operator|::
name|ConstIterator
name|argsIter
init|=
name|args
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|arg
operator|=
name|argsIter
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|splitQmlPropertyArg
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|element
argument_list|,
name|property
argument_list|)
condition|)
block|{
name|qmlClass
operator|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|module
argument_list|,
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmlClass
condition|)
block|{
name|qmlPropGroup
operator|=
operator|new
name|QmlPropGroupNode
argument_list|(
name|qmlClass
argument_list|,
name|property
argument_list|)
expr_stmt|;
comment|//,attached);
name|qmlPropGroup
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qmlPropGroup
condition|)
block|{
if|if
condition|(
name|qmlClass
operator|->
name|hasProperty
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"QML property documented multiple times: '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QmlPropertyNode
modifier|*
name|qmlPropNode
init|=
operator|new
name|QmlPropertyNode
argument_list|(
name|qmlPropGroup
argument_list|,
name|property
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
decl_stmt|;
name|qmlPropNode
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|argsIter
expr_stmt|;
while|while
condition|(
name|argsIter
operator|!=
name|args
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|arg
operator|=
name|argsIter
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|splitQmlPropertyArg
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|element
argument_list|,
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|qmlClass
operator|->
name|hasProperty
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|doc
operator|.
name|startLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"QML property documented multiple times: '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QmlPropertyNode
modifier|*
name|qmlPropNode
init|=
operator|new
name|QmlPropertyNode
argument_list|(
name|qmlPropGroup
argument_list|,
name|property
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
decl_stmt|;
name|qmlPropNode
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|startLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|argsIter
expr_stmt|;
block|}
block|}
block|}
return|return
name|qmlPropGroup
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the set of strings representing the common metacommands   plus some other metacommands.  */
end_comment
begin_function
DECL|function|otherMetaCommands
name|QSet
argument_list|<
name|QString
argument_list|>
name|CppCodeParser
operator|::
name|otherMetaCommands
parameter_list|()
block|{
return|return
name|commonMetaCommands
argument_list|()
operator|<<
name|COMMAND_INHEADERFILE
operator|<<
name|COMMAND_OVERLOAD
operator|<<
name|COMMAND_REIMP
operator|<<
name|COMMAND_RELATES
operator|<<
name|COMMAND_CONTENTSPAGE
operator|<<
name|COMMAND_NEXTPAGE
operator|<<
name|COMMAND_PREVIOUSPAGE
operator|<<
name|COMMAND_INDEXPAGE
operator|<<
name|COMMAND_STARTPAGE
operator|<<
name|COMMAND_QMLINHERITS
operator|<<
name|COMMAND_QMLINSTANTIATES
operator|<<
name|COMMAND_QMLDEFAULT
operator|<<
name|COMMAND_QMLREADONLY
operator|<<
name|COMMAND_QMLABSTRACT
return|;
block|}
end_function
begin_comment
comment|/*!   Process the metacommand \a command in the context of the   \a node associated with the topic command and the \a doc.   \a arg is the argument to the metacommand.  */
end_comment
begin_function
DECL|function|processOtherMetaCommand
name|void
name|CppCodeParser
operator|::
name|processOtherMetaCommand
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|command
parameter_list|,
specifier|const
name|ArgLocPair
modifier|&
name|argLocPair
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|arg
init|=
name|argLocPair
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|command
operator|==
name|COMMAND_INHEADERFILE
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|addInclude
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Ignored '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_INHEADERFILE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_OVERLOAD
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
operator|(
operator|(
name|FunctionNode
operator|*
operator|)
name|node
operator|)
operator|->
name|setOverload
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Ignored '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_OVERLOAD
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_REIMP
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|&&
operator|!
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isInternal
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
name|node
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|0
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find base function for '\\%1' in %2()"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_REIMP
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"The function either doesn't exist in any "
literal|"base class with the same signature or it "
literal|"exists but isn't virtual."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*                   Ideally, we would enable this check to warn whenever                   \reimp is used incorrectly, and only make the node                   internal if the function is a reimplementation of                   another function in a base class.                 */
elseif|else
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|from
operator|->
name|parent
argument_list|()
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"'\\%1' in %2() should be '\\internal' "
literal|"because its base function is private "
literal|"or internal"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_REIMP
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|func
operator|->
name|setReimp
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Ignored '\\%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_REIMP
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_RELATES
condition|)
block|{
comment|/*           Find the node that this node relates to.          */
name|Node
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
argument_list|)
operator|||
name|arg
operator|.
name|startsWith
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
comment|/*               It should be a header file, I think.             */
name|n
operator|=
name|qdb_
operator|->
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|arg
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*               If it wasn't a file, it should be either a class or a namespace.              */
name|QStringList
name|newPath
init|=
name|arg
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|n
operator|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|qdb_
operator|->
name|findNamespaceNode
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/*               Didn't ind it. Error...              */
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find '%1' in '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_RELATES
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*               Found it. This node relates to it.              */
name|node
operator|->
name|setRelates
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_CONTENTSPAGE
condition|)
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|ContentsLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_NEXTPAGE
condition|)
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|NextLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_PREVIOUSPAGE
condition|)
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|PreviousLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_INDEXPAGE
condition|)
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|IndexLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_STARTPAGE
condition|)
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|StartLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLINHERITS
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|==
name|arg
condition|)
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"%1 tries to inherit itself"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|setLink
argument_list|(
name|node
argument_list|,
name|Node
operator|::
name|InheritsLink
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
operator|::
name|addInheritedBy
argument_list|(
name|arg
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLINSTANTIATES
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
condition|)
block|{
name|ClassNode
modifier|*
name|classNode
init|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
name|arg
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|classNode
condition|)
name|node
operator|->
name|setClassNode
argument_list|(
name|classNode
argument_list|)
expr_stmt|;
else|else
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"C++ class %1 not found: \\instantiates %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\\instantiates is only allowed in \\qmltype"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLDEFAULT
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setDefault
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QmlPropGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
name|QmlPropGroupNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setDefault
argument_list|()
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLREADONLY
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setReadOnly
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QmlPropGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
name|QmlPropGroupNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setReadOnly
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLABSTRACT
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
condition|)
block|{
name|node
operator|->
name|setAbstract
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|processCommonMetaCommand
argument_list|(
name|doc
operator|.
name|location
argument_list|()
argument_list|,
name|command
argument_list|,
name|argLocPair
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   The topic command has been processed resulting in the \a doc   and \a node passed in here. Process the other meta commands,   which are found in \a doc, in the context of the topic \a node.  */
end_comment
begin_function
DECL|function|processOtherMetaCommands
name|void
name|CppCodeParser
operator|::
name|processOtherMetaCommands
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
name|metaCommands
init|=
name|doc
operator|.
name|metaCommandsUsed
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|cmd
init|=
name|metaCommands
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|cmd
operator|!=
name|metaCommands
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|ArgList
name|args
init|=
name|doc
operator|.
name|metaCommandArgs
argument_list|(
operator|*
name|cmd
argument_list|)
decl_stmt|;
name|ArgList
operator|::
name|ConstIterator
name|arg
init|=
name|args
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|arg
operator|!=
name|args
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|processOtherMetaCommand
argument_list|(
name|doc
argument_list|,
operator|*
name|cmd
argument_list|,
operator|*
name|arg
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|++
name|arg
expr_stmt|;
block|}
operator|++
name|cmd
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Resets the C++ code parser to its default initialized state.  */
end_comment
begin_function
DECL|function|reset
name|void
name|CppCodeParser
operator|::
name|reset
parameter_list|()
block|{
name|tokenizer
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
literal|0
expr_stmt|;
name|access
operator|=
name|Node
operator|::
name|Public
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
name|lastPath_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Get the next token from the file being parsed and store it   in the token variable.  */
end_comment
begin_function
DECL|function|readToken
name|void
name|CppCodeParser
operator|::
name|readToken
parameter_list|()
block|{
name|tok
operator|=
name|tokenizer
operator|->
name|getToken
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Return the current location in the file being parsed,   i.e. the file name, line number, and column number.  */
end_comment
begin_function
DECL|function|location
specifier|const
name|Location
modifier|&
name|CppCodeParser
operator|::
name|location
parameter_list|()
block|{
return|return
name|tokenizer
operator|->
name|location
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Return the previous string read from the file being parsed.  */
end_comment
begin_function
DECL|function|previousLexeme
name|QString
name|CppCodeParser
operator|::
name|previousLexeme
parameter_list|()
block|{
return|return
name|tokenizer
operator|->
name|previousLexeme
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Return the current string string from the file being parsed.  */
end_comment
begin_function
DECL|function|lexeme
name|QString
name|CppCodeParser
operator|::
name|lexeme
parameter_list|()
block|{
return|return
name|tokenizer
operator|->
name|lexeme
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|match
name|bool
name|CppCodeParser
operator|::
name|match
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|tok
operator|==
name|target
condition|)
block|{
name|readToken
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Skip to \a target. If \a target is found before the end   of input, return true. Otherwise return false.  */
end_comment
begin_function
DECL|function|skipTo
name|bool
name|CppCodeParser
operator|::
name|skipTo
parameter_list|(
name|int
name|target
parameter_list|)
block|{
while|while
condition|(
operator|(
name|tok
operator|!=
name|Tok_Eoi
operator|)
operator|&&
operator|(
name|tok
operator|!=
name|target
operator|)
condition|)
name|readToken
argument_list|()
expr_stmt|;
return|return
operator|(
name|tok
operator|==
name|target
condition|?
literal|true
else|:
literal|false
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   If the current token is one of the keyword thingees that   are used in Qt, skip over it to the next token and return   true. Otherwise just return false without reading the   next token.  */
end_comment
begin_function
DECL|function|matchCompat
name|bool
name|CppCodeParser
operator|::
name|matchCompat
parameter_list|()
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|Tok_QT_COMPAT
case|:
case|case
name|Tok_QT_COMPAT_CONSTRUCTOR
case|:
case|case
name|Tok_QT_DEPRECATED
case|:
case|case
name|Tok_QT_MOC_COMPAT
case|:
case|case
name|Tok_QT3_SUPPORT
case|:
case|case
name|Tok_QT3_SUPPORT_CONSTRUCTOR
case|:
case|case
name|Tok_QT3_MOC_SUPPORT
case|:
name|readToken
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|matchModuleQualifier
name|bool
name|CppCodeParser
operator|::
name|matchModuleQualifier
parameter_list|(
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|bool
name|matches
init|=
operator|(
name|lexeme
argument_list|()
operator|==
name|QString
argument_list|(
literal|'.'
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|matches
condition|)
block|{
do|do
block|{
name|name
operator|+=
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tok
operator|==
name|Tok_Ident
operator|)
operator|||
operator|(
name|lexeme
argument_list|()
operator|==
name|QString
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
do|;
block|}
return|return
name|matches
return|;
block|}
end_function
begin_function
DECL|function|matchTemplateAngles
name|bool
name|CppCodeParser
operator|::
name|matchTemplateAngles
parameter_list|(
name|CodeChunk
modifier|*
name|dataType
parameter_list|)
block|{
name|bool
name|matches
init|=
operator|(
name|tok
operator|==
name|Tok_LeftAngle
operator|)
decl_stmt|;
if|if
condition|(
name|matches
condition|)
block|{
name|int
name|leftAngleDepth
init|=
literal|0
decl_stmt|;
name|int
name|parenAndBraceDepth
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|tok
operator|==
name|Tok_LeftAngle
condition|)
block|{
name|leftAngleDepth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_RightAngle
condition|)
block|{
name|leftAngleDepth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_LeftParen
operator|||
name|tok
operator|==
name|Tok_LeftBrace
condition|)
block|{
operator|++
name|parenAndBraceDepth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_RightParen
operator|||
name|tok
operator|==
name|Tok_RightBrace
condition|)
block|{
if|if
condition|(
operator|--
name|parenAndBraceDepth
operator|<
literal|0
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dataType
operator|!=
literal|0
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|leftAngleDepth
operator|>
literal|0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
do|;
block|}
return|return
name|matches
return|;
block|}
end_function
begin_function
DECL|function|matchTemplateHeader
name|bool
name|CppCodeParser
operator|::
name|matchTemplateHeader
parameter_list|()
block|{
name|readToken
argument_list|()
expr_stmt|;
return|return
name|matchTemplateAngles
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|matchDataType
name|bool
name|CppCodeParser
operator|::
name|matchDataType
parameter_list|(
name|CodeChunk
modifier|*
name|dataType
parameter_list|,
name|QString
modifier|*
name|var
parameter_list|)
block|{
comment|/*       This code is really hard to follow... sorry. The loop is there to match       Alpha::Beta::Gamma::...::Omega.     */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|virgin
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_Ident
condition|)
block|{
comment|/*               There is special processing for 'Foo::operator int()'               and such elsewhere. This is the only case where we               return something with a trailing gulbrandsen ('Foo::').             */
if|if
condition|(
name|tok
operator|==
name|Tok_operator
condition|)
return|return
literal|true
return|;
comment|/*               People may write 'const unsigned short' or               'short unsigned const' or any other permutation.             */
while|while
condition|(
name|match
argument_list|(
name|Tok_const
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_volatile
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|match
argument_list|(
name|Tok_signed
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_unsigned
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_short
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_long
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_int64
argument_list|)
condition|)
block|{
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
name|virgin
operator|=
literal|false
expr_stmt|;
block|}
while|while
condition|(
name|match
argument_list|(
name|Tok_const
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_volatile
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Tilde
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|virgin
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|match
argument_list|(
name|Tok_void
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_int
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_char
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_double
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Ellipsis
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
else|else
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|Tok_int
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_char
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_double
argument_list|)
condition|)
block|{
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|matchTemplateAngles
argument_list|(
name|dataType
argument_list|)
expr_stmt|;
while|while
condition|(
name|match
argument_list|(
name|Tok_const
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_volatile
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Gulbrandsen
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
while|while
condition|(
name|match
argument_list|(
name|Tok_Ampersand
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Aster
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_const
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Caret
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParenAster
argument_list|)
condition|)
block|{
comment|/*           A function pointer. This would be rather hard to handle without a           tokenizer hack, because a type can be followed with a left parenthesis           in some cases (e.g., 'operator int()'). The tokenizer recognizes '(*'           as a single token.         */
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
name|dataType
operator|->
name|appendHotspot
argument_list|()
expr_stmt|;
if|if
condition|(
name|var
operator|!=
literal|0
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
operator|*
name|var
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
operator|||
name|tok
operator|!=
name|Tok_LeftParen
condition|)
return|return
literal|false
return|;
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|parenDepth0
init|=
name|tokenizer
operator|->
name|parenDepth
argument_list|()
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|->
name|parenDepth
argument_list|()
operator|>=
name|parenDepth0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|dataType
operator|->
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
condition|)
name|dataType
operator|->
name|append
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*           The common case: Look for an optional identifier, then for           some array brackets.         */
name|dataType
operator|->
name|appendHotspot
argument_list|()
expr_stmt|;
if|if
condition|(
name|var
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
block|{
operator|*
name|var
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|Tok_Comment
argument_list|)
condition|)
block|{
comment|/*                   A neat hack: Commented-out parameter names are                   recognized by qdoc. It's impossible to illustrate                   here inside a C-style comment, because it requires                   an asterslash. It's also impossible to illustrate                   inside a C++-style comment, because the explanation                   does not fit on one line.                 */
if|if
condition|(
name|varComment
operator|.
name|exactMatch
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
condition|)
operator|*
name|var
operator|=
name|varComment
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tok
operator|==
name|Tok_LeftBracket
condition|)
block|{
name|int
name|bracketDepth0
init|=
name|tokenizer
operator|->
name|bracketDepth
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|tokenizer
operator|->
name|bracketDepth
argument_list|()
operator|>=
name|bracketDepth0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
operator|)
operator|||
name|tok
operator|==
name|Tok_RightBracket
condition|)
block|{
name|dataType
operator|->
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchParameter
name|bool
name|CppCodeParser
operator|::
name|matchParameter
parameter_list|(
name|FunctionNode
modifier|*
name|func
parameter_list|)
block|{
name|CodeChunk
name|dataType
decl_stmt|;
name|QString
name|name
decl_stmt|;
name|CodeChunk
name|defaultValue
decl_stmt|;
if|if
condition|(
operator|!
name|matchDataType
argument_list|(
operator|&
name|dataType
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
name|match
argument_list|(
name|Tok_Comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Equal
argument_list|)
condition|)
block|{
name|int
name|parenDepth0
init|=
name|tokenizer
operator|->
name|parenDepth
argument_list|()
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|->
name|parenDepth
argument_list|()
operator|>=
name|parenDepth0
operator|&&
operator|(
name|tok
operator|!=
name|Tok_Comma
operator|||
name|tokenizer
operator|->
name|parenDepth
argument_list|()
operator|>
name|parenDepth0
operator|)
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|defaultValue
operator|.
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
name|func
operator|->
name|addParameter
argument_list|(
name|Parameter
argument_list|(
name|dataType
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|defaultValue
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ###
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchFunctionDecl
name|bool
name|CppCodeParser
operator|::
name|matchFunctionDecl
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|QStringList
modifier|*
name|parentPathPtr
parameter_list|,
name|FunctionNode
modifier|*
modifier|*
name|funcPtr
parameter_list|,
specifier|const
name|QString
modifier|&
name|templateStuff
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
block|{
name|CodeChunk
name|returnType
decl_stmt|;
name|QStringList
name|parentPath
decl_stmt|;
name|QString
name|name
decl_stmt|;
name|bool
name|compat
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_friend
argument_list|)
condition|)
return|return
literal|false
return|;
name|match
argument_list|(
name|Tok_explicit
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchCompat
argument_list|()
condition|)
name|compat
operator|=
literal|true
expr_stmt|;
name|bool
name|sta
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_static
argument_list|)
condition|)
block|{
name|sta
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|matchCompat
argument_list|()
condition|)
name|compat
operator|=
literal|true
expr_stmt|;
block|}
name|FunctionNode
operator|::
name|Virtualness
name|vir
init|=
name|FunctionNode
operator|::
name|NonVirtual
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_virtual
argument_list|)
condition|)
block|{
name|vir
operator|=
name|FunctionNode
operator|::
name|ImpureVirtual
expr_stmt|;
if|if
condition|(
name|matchCompat
argument_list|()
condition|)
name|compat
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchDataType
argument_list|(
operator|&
name|returnType
argument_list|)
condition|)
block|{
if|if
condition|(
name|tokenizer
operator|->
name|parsingFnOrMacro
argument_list|()
operator|&&
operator|(
name|match
argument_list|(
name|Tok_Q_DECLARE_FLAGS
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Q_PROPERTY
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Q_PRIVATE_PROPERTY
argument_list|)
operator|)
condition|)
name|returnType
operator|=
name|CodeChunk
argument_list|(
name|previousLexeme
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|returnType
operator|.
name|toString
argument_list|()
operator|==
literal|"QBool"
condition|)
name|returnType
operator|=
name|CodeChunk
argument_list|(
literal|"bool"
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchCompat
argument_list|()
condition|)
name|compat
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|Tok_operator
operator|&&
operator|(
name|returnType
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|returnType
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"::"
argument_list|)
operator|)
condition|)
block|{
comment|// 'QString::operator const char *()'
name|parentPath
operator|=
name|returnType
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|parentPath
operator|.
name|removeAll
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|returnType
operator|=
name|CodeChunk
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|CodeChunk
name|restOfName
decl_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_Tilde
operator|&&
name|matchDataType
argument_list|(
operator|&
name|restOfName
argument_list|)
condition|)
block|{
name|name
operator|=
literal|"operator "
operator|+
name|restOfName
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|previousLexeme
argument_list|()
operator|+
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_LeftParen
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|name
operator|+=
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tok
operator|!=
name|Tok_LeftParen
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_LeftParen
condition|)
block|{
comment|// constructor or destructor
name|parentPath
operator|=
name|returnType
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parentPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
name|parentPath
operator|.
name|last
argument_list|()
expr_stmt|;
name|parentPath
operator|.
name|erase
argument_list|(
name|parentPath
operator|.
name|end
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|returnType
operator|=
name|CodeChunk
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
block|{
name|name
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
comment|/*               This is a hack to let QML module identifiers through.              */
name|matchModuleQualifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|matchTemplateAngles
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Gulbrandsen
argument_list|)
condition|)
name|parentPath
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|tok
operator|==
name|Tok_operator
condition|)
block|{
name|name
operator|=
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|name
operator|+=
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|Tok_LeftParen
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|parent
operator|&&
operator|(
name|tok
operator|==
name|Tok_Semicolon
operator|||
name|tok
operator|==
name|Tok_LeftBracket
operator|||
name|tok
operator|==
name|Tok_Colon
operator|)
operator|&&
name|access
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
name|tok
operator|==
name|Tok_LeftBracket
condition|)
block|{
name|returnType
operator|.
name|appendHotspot
argument_list|()
expr_stmt|;
name|int
name|bracketDepth0
init|=
name|tokenizer
operator|->
name|bracketDepth
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|tokenizer
operator|->
name|bracketDepth
argument_list|()
operator|>=
name|bracketDepth0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
operator|)
operator|||
name|tok
operator|==
name|Tok_RightBracket
condition|)
block|{
name|returnType
operator|.
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|!=
name|Tok_Semicolon
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_Colon
condition|)
block|{
name|returnType
operator|.
name|appendHotspot
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_Semicolon
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|returnType
operator|.
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|!=
name|Tok_Semicolon
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|VariableNode
modifier|*
name|var
init|=
operator|new
name|VariableNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|var
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|var
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|var
operator|->
name|setLeftType
argument_list|(
name|returnType
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|var
operator|->
name|setRightType
argument_list|(
name|returnType
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
name|var
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Compat
argument_list|)
expr_stmt|;
name|var
operator|->
name|setStatic
argument_list|(
name|sta
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tok
operator|!=
name|Tok_LeftParen
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|readToken
argument_list|()
expr_stmt|;
name|FunctionNode
modifier|*
name|func
init|=
operator|new
name|FunctionNode
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|attached
argument_list|)
decl_stmt|;
name|func
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|func
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|func
operator|->
name|setReturnType
argument_list|(
name|returnType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|func
operator|->
name|setParentPath
argument_list|(
name|parentPath
argument_list|)
expr_stmt|;
name|func
operator|->
name|setTemplateStuff
argument_list|(
name|templateStuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
name|func
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Compat
argument_list|)
expr_stmt|;
name|func
operator|->
name|setMetaness
argument_list|(
name|metaness
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|parent
operator|->
name|name
argument_list|()
condition|)
block|{
name|func
operator|->
name|setMetaness
argument_list|(
name|FunctionNode
operator|::
name|Ctor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'~'
argument_list|)
argument_list|)
condition|)
block|{
name|func
operator|->
name|setMetaness
argument_list|(
name|FunctionNode
operator|::
name|Dtor
argument_list|)
expr_stmt|;
block|}
block|}
name|func
operator|->
name|setStatic
argument_list|(
name|sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_RightParen
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|matchParameter
argument_list|(
name|func
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
do|while
condition|(
name|match
argument_list|(
name|Tok_Comma
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|func
operator|->
name|setConst
argument_list|(
name|match
argument_list|(
name|Tok_const
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Equal
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Number
argument_list|)
condition|)
name|vir
operator|=
name|FunctionNode
operator|::
name|PureVirtual
expr_stmt|;
name|func
operator|->
name|setVirtualness
argument_list|(
name|vir
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Colon
argument_list|)
condition|)
block|{
while|while
condition|(
name|tok
operator|!=
name|Tok_LeftBrace
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
name|readToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Semicolon
argument_list|)
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|int
name|braceDepth0
init|=
name|tokenizer
operator|->
name|braceDepth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_LeftBrace
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
while|while
condition|(
name|tokenizer
operator|->
name|braceDepth
argument_list|()
operator|>=
name|braceDepth0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
name|readToken
argument_list|()
expr_stmt|;
name|match
argument_list|(
name|Tok_RightBrace
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentPathPtr
operator|!=
literal|0
condition|)
operator|*
name|parentPathPtr
operator|=
name|parentPath
expr_stmt|;
if|if
condition|(
name|funcPtr
operator|!=
literal|0
condition|)
operator|*
name|funcPtr
operator|=
name|func
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchBaseSpecifier
name|bool
name|CppCodeParser
operator|::
name|matchBaseSpecifier
parameter_list|(
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|bool
name|isClass
parameter_list|)
block|{
name|Node
operator|::
name|Access
name|access
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|Tok_public
case|:
name|access
operator|=
name|Node
operator|::
name|Public
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
break|break;
case|case
name|Tok_protected
case|:
name|access
operator|=
name|Node
operator|::
name|Protected
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
break|break;
case|case
name|Tok_private
case|:
name|access
operator|=
name|Node
operator|::
name|Private
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
break|break;
default|default:
name|access
operator|=
name|isClass
condition|?
name|Node
operator|::
name|Private
else|:
name|Node
operator|::
name|Public
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|Tok_virtual
condition|)
name|readToken
argument_list|()
expr_stmt|;
name|CodeChunk
name|baseClass
decl_stmt|;
if|if
condition|(
operator|!
name|matchDataType
argument_list|(
operator|&
name|baseClass
argument_list|)
condition|)
return|return
literal|false
return|;
name|qdb_
operator|->
name|addBaseClass
argument_list|(
name|classe
argument_list|,
name|access
argument_list|,
name|baseClass
operator|.
name|toPath
argument_list|()
argument_list|,
name|baseClass
operator|.
name|toString
argument_list|()
argument_list|,
name|classe
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchBaseList
name|bool
name|CppCodeParser
operator|::
name|matchBaseList
parameter_list|(
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|bool
name|isClass
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|matchBaseSpecifier
argument_list|(
name|classe
argument_list|,
name|isClass
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tok
operator|==
name|Tok_LeftBrace
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Comma
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Parse a C++ class, union, or struct declarion.  */
end_comment
begin_function
DECL|function|matchClassDecl
name|bool
name|CppCodeParser
operator|::
name|matchClassDecl
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|templateStuff
parameter_list|)
block|{
name|bool
name|isClass
init|=
operator|(
name|tok
operator|==
name|Tok_class
operator|)
decl_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|bool
name|compat
init|=
name|matchCompat
argument_list|()
decl_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_Ident
condition|)
return|return
literal|false
return|;
while|while
condition|(
name|tok
operator|==
name|Tok_Ident
condition|)
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_Colon
operator|&&
name|tok
operator|!=
name|Tok_LeftBrace
condition|)
return|return
literal|false
return|;
comment|/*       So far, so good. We have 'class Foo {' or 'class Foo :'.       This is enough to recognize a class definition.     */
name|ClassNode
modifier|*
name|classe
init|=
operator|new
name|ClassNode
argument_list|(
name|parent
argument_list|,
name|previousLexeme
argument_list|()
argument_list|)
decl_stmt|;
name|classe
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|classe
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
name|classe
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Compat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|moduleName
operator|.
name|isEmpty
argument_list|()
condition|)
name|classe
operator|->
name|setModuleName
argument_list|(
name|moduleName
argument_list|)
expr_stmt|;
name|classe
operator|->
name|setTemplateStuff
argument_list|(
name|templateStuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Colon
argument_list|)
operator|&&
operator|!
name|matchBaseList
argument_list|(
name|classe
argument_list|,
name|isClass
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_LeftBrace
argument_list|)
condition|)
return|return
literal|false
return|;
name|Node
operator|::
name|Access
name|outerAccess
init|=
name|access
decl_stmt|;
name|access
operator|=
name|isClass
condition|?
name|Node
operator|::
name|Private
else|:
name|Node
operator|::
name|Public
expr_stmt|;
name|FunctionNode
operator|::
name|Metaness
name|outerMetaness
init|=
name|metaness
decl_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
name|bool
name|matches
init|=
operator|(
name|matchDeclList
argument_list|(
name|classe
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_RightBrace
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Semicolon
argument_list|)
operator|)
decl_stmt|;
name|access
operator|=
name|outerAccess
expr_stmt|;
name|metaness
operator|=
name|outerMetaness
expr_stmt|;
return|return
name|matches
return|;
block|}
end_function
begin_function
DECL|function|matchNamespaceDecl
name|bool
name|CppCodeParser
operator|::
name|matchNamespaceDecl
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|readToken
argument_list|()
expr_stmt|;
comment|// skip 'namespace'
if|if
condition|(
name|tok
operator|!=
name|Tok_Ident
condition|)
return|return
literal|false
return|;
while|while
condition|(
name|tok
operator|==
name|Tok_Ident
condition|)
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_LeftBrace
condition|)
return|return
literal|false
return|;
comment|/*         So far, so good. We have 'namespace Foo {'.     */
name|QString
name|namespaceName
init|=
name|previousLexeme
argument_list|()
decl_stmt|;
name|NamespaceNode
modifier|*
name|ns
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|ns
operator|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|parent
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|namespaceName
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ns
condition|)
block|{
name|ns
operator|=
operator|new
name|NamespaceNode
argument_list|(
name|parent
argument_list|,
name|namespaceName
argument_list|)
expr_stmt|;
name|ns
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|ns
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readToken
argument_list|()
expr_stmt|;
comment|// skip '{'
name|bool
name|matched
init|=
name|matchDeclList
argument_list|(
name|ns
argument_list|)
decl_stmt|;
return|return
name|matched
operator|&&
name|match
argument_list|(
name|Tok_RightBrace
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|matchUsingDecl
name|bool
name|CppCodeParser
operator|::
name|matchUsingDecl
parameter_list|()
block|{
name|readToken
argument_list|()
expr_stmt|;
comment|// skip 'using'
comment|// 'namespace'
if|if
condition|(
name|tok
operator|!=
name|Tok_namespace
condition|)
return|return
literal|false
return|;
name|readToken
argument_list|()
expr_stmt|;
comment|// identifier
if|if
condition|(
name|tok
operator|!=
name|Tok_Ident
condition|)
return|return
literal|false
return|;
name|QString
name|name
decl_stmt|;
while|while
condition|(
name|tok
operator|==
name|Tok_Ident
condition|)
block|{
name|name
operator|+=
name|lexeme
argument_list|()
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|Tok_Semicolon
condition|)
break|break;
elseif|else
if|if
condition|(
name|tok
operator|!=
name|Tok_Gulbrandsen
condition|)
return|return
literal|false
return|;
name|name
operator|+=
literal|"::"
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
comment|/*         So far, so good. We have 'using namespace Foo;'.     */
name|activeNamespaces_
operator|.
name|insert
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchEnumItem
name|bool
name|CppCodeParser
operator|::
name|matchEnumItem
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|EnumNode
modifier|*
name|enume
parameter_list|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
return|return
literal|false
return|;
name|QString
name|name
init|=
name|previousLexeme
argument_list|()
decl_stmt|;
name|CodeChunk
name|val
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Equal
argument_list|)
condition|)
block|{
while|while
condition|(
name|tok
operator|!=
name|Tok_Comma
operator|&&
name|tok
operator|!=
name|Tok_RightBrace
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
name|val
operator|.
name|append
argument_list|(
name|lexeme
argument_list|()
argument_list|)
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enume
condition|)
block|{
name|QString
name|strVal
init|=
name|val
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|strVal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|enume
operator|->
name|items
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|strVal
operator|=
literal|"0"
expr_stmt|;
block|}
else|else
block|{
name|QString
name|last
init|=
name|enume
operator|->
name|items
argument_list|()
operator|.
name|last
argument_list|()
operator|.
name|value
argument_list|()
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|n
init|=
name|last
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|last
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|&&
name|last
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|last
operator|.
name|startsWith
argument_list|(
literal|"0x"
argument_list|)
operator|||
name|last
operator|.
name|startsWith
argument_list|(
literal|"0X"
argument_list|)
condition|)
name|strVal
operator|=
name|last
operator|.
name|left
argument_list|(
literal|2
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|n
operator|+
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|strVal
operator|=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|n
operator|+
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|strVal
operator|=
name|QString
operator|::
name|number
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|enume
operator|->
name|addItem
argument_list|(
name|EnumItem
argument_list|(
name|name
argument_list|,
name|strVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VariableNode
modifier|*
name|var
init|=
operator|new
name|VariableNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|var
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|var
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|var
operator|->
name|setLeftType
argument_list|(
literal|"const int"
argument_list|)
expr_stmt|;
name|var
operator|->
name|setStatic
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchEnumDecl
name|bool
name|CppCodeParser
operator|::
name|matchEnumDecl
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|QString
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_enum
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|name
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|Tok_LeftBrace
condition|)
return|return
literal|false
return|;
name|EnumNode
modifier|*
name|enume
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enume
operator|=
operator|new
name|EnumNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|enume
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|enume
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|matchEnumItem
argument_list|(
name|parent
argument_list|,
name|enume
argument_list|)
condition|)
return|return
literal|false
return|;
while|while
condition|(
name|match
argument_list|(
name|Tok_Comma
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|matchEnumItem
argument_list|(
name|parent
argument_list|,
name|enume
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
name|match
argument_list|(
name|Tok_RightBrace
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Semicolon
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|matchTypedefDecl
name|bool
name|CppCodeParser
operator|::
name|matchTypedefDecl
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|CodeChunk
name|dataType
decl_stmt|;
name|QString
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_typedef
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|matchDataType
argument_list|(
operator|&
name|dataType
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Semicolon
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|name
argument_list|,
name|Node
operator|::
name|Typedef
argument_list|)
condition|)
block|{
name|TypedefNode
modifier|*
name|td
init|=
operator|new
name|TypedefNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|td
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|td
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|matchProperty
name|bool
name|CppCodeParser
operator|::
name|matchProperty
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|expected_tok
init|=
name|Tok_LeftParen
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Q_PRIVATE_PROPERTY
argument_list|)
condition|)
block|{
name|expected_tok
operator|=
name|Tok_Comma
expr_stmt|;
if|if
condition|(
operator|!
name|skipTo
argument_list|(
name|Tok_Comma
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Q_PROPERTY
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|Tok_Q_OVERRIDE
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|Tok_QDOC_PROPERTY
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|match
argument_list|(
name|expected_tok
argument_list|)
condition|)
return|return
literal|false
return|;
name|QString
name|name
decl_stmt|;
name|CodeChunk
name|dataType
decl_stmt|;
if|if
condition|(
operator|!
name|matchDataType
argument_list|(
operator|&
name|dataType
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
name|PropertyNode
modifier|*
name|property
init|=
operator|new
name|PropertyNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|property
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
name|property
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|property
operator|->
name|setDataType
argument_list|(
name|dataType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_RightParen
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
return|return
literal|false
return|;
name|QString
name|key
init|=
name|previousLexeme
argument_list|()
decl_stmt|;
name|QString
name|value
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Ident
argument_list|)
operator|||
name|match
argument_list|(
name|Tok_Number
argument_list|)
condition|)
block|{
name|value
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
condition|)
block|{
name|int
name|depth
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
if|if
condition|(
name|tok
operator|==
name|Tok_LeftParen
condition|)
block|{
name|readToken
argument_list|()
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_RightParen
condition|)
block|{
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
name|value
operator|=
literal|"?"
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|"READ"
condition|)
name|qdb_
operator|->
name|addPropertyFunction
argument_list|(
name|property
argument_list|,
name|value
argument_list|,
name|PropertyNode
operator|::
name|Getter
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|"WRITE"
condition|)
block|{
name|qdb_
operator|->
name|addPropertyFunction
argument_list|(
name|property
argument_list|,
name|value
argument_list|,
name|PropertyNode
operator|::
name|Setter
argument_list|)
expr_stmt|;
name|property
operator|->
name|setWritable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|"STORED"
condition|)
name|property
operator|->
name|setStored
argument_list|(
name|value
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|"DESIGNABLE"
condition|)
block|{
name|QString
name|v
init|=
name|value
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|"true"
condition|)
name|property
operator|->
name|setDesignable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|"false"
condition|)
name|property
operator|->
name|setDesignable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
else|else
block|{
name|property
operator|->
name|setDesignable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|property
operator|->
name|setRuntimeDesFunc
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|"RESET"
condition|)
name|qdb_
operator|->
name|addPropertyFunction
argument_list|(
name|property
argument_list|,
name|value
argument_list|,
name|PropertyNode
operator|::
name|Resetter
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|"NOTIFY"
condition|)
block|{
name|qdb_
operator|->
name|addPropertyFunction
argument_list|(
name|property
argument_list|,
name|value
argument_list|,
name|PropertyNode
operator|::
name|Notifier
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|"REVISION"
condition|)
block|{
name|int
name|revision
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|revision
operator|=
name|value
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|property
operator|->
name|setRevision
argument_list|(
name|revision
argument_list|)
expr_stmt|;
else|else
name|parent
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid revision number: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|"SCRIPTABLE"
condition|)
block|{
name|QString
name|v
init|=
name|value
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|"true"
condition|)
name|property
operator|->
name|setScriptable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|"false"
condition|)
name|property
operator|->
name|setScriptable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
else|else
block|{
name|property
operator|->
name|setScriptable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|property
operator|->
name|setRuntimeScrFunc
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|"CONSTANT"
condition|)
name|property
operator|->
name|setConstant
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|"FINAL"
condition|)
name|property
operator|->
name|setFinal
argument_list|()
expr_stmt|;
block|}
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Parse a C++ declaration.  */
end_comment
begin_function
DECL|function|matchDeclList
name|bool
name|CppCodeParser
operator|::
name|matchDeclList
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|QString
name|templateStuff
decl_stmt|;
name|int
name|braceDepth0
init|=
name|tokenizer
operator|->
name|braceDepth
argument_list|()
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|Tok_RightBrace
condition|)
comment|// prevents failure on empty body
name|braceDepth0
operator|++
expr_stmt|;
while|while
condition|(
name|tokenizer
operator|->
name|braceDepth
argument_list|()
operator|>=
name|braceDepth0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|Tok_Colon
case|:
name|readToken
argument_list|()
expr_stmt|;
break|break;
case|case
name|Tok_class
case|:
case|case
name|Tok_struct
case|:
case|case
name|Tok_union
case|:
name|matchClassDecl
argument_list|(
name|parent
argument_list|,
name|templateStuff
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_namespace
case|:
name|matchNamespaceDecl
argument_list|(
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_using
case|:
name|matchUsingDecl
argument_list|()
expr_stmt|;
break|break;
case|case
name|Tok_template
case|:
name|templateStuff
operator|=
name|matchTemplateHeader
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|Tok_enum
case|:
name|matchEnumDecl
argument_list|(
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_typedef
case|:
name|matchTypedefDecl
argument_list|(
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_private
case|:
name|readToken
argument_list|()
expr_stmt|;
name|access
operator|=
name|Node
operator|::
name|Private
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
break|break;
case|case
name|Tok_protected
case|:
name|readToken
argument_list|()
expr_stmt|;
name|access
operator|=
name|Node
operator|::
name|Protected
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
break|break;
case|case
name|Tok_public
case|:
name|readToken
argument_list|()
expr_stmt|;
name|access
operator|=
name|Node
operator|::
name|Public
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
break|break;
case|case
name|Tok_signals
case|:
case|case
name|Tok_Q_SIGNALS
case|:
name|readToken
argument_list|()
expr_stmt|;
name|access
operator|=
name|Node
operator|::
name|Public
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Signal
expr_stmt|;
break|break;
case|case
name|Tok_slots
case|:
case|case
name|Tok_Q_SLOTS
case|:
name|readToken
argument_list|()
expr_stmt|;
name|metaness
operator|=
name|FunctionNode
operator|::
name|Slot
expr_stmt|;
break|break;
case|case
name|Tok_Q_OBJECT
case|:
name|readToken
argument_list|()
expr_stmt|;
break|break;
case|case
name|Tok_Q_OVERRIDE
case|:
case|case
name|Tok_Q_PROPERTY
case|:
case|case
name|Tok_Q_PRIVATE_PROPERTY
case|:
case|case
name|Tok_QDOC_PROPERTY
case|:
name|matchProperty
argument_list|(
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Q_DECLARE_SEQUENTIAL_ITERATOR
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|sequentialIteratorClasses
operator|.
name|insert
argument_list|(
name|previousLexeme
argument_list|()
argument_list|,
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Q_DECLARE_MUTABLE_SEQUENTIAL_ITERATOR
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|mutableSequentialIteratorClasses
operator|.
name|insert
argument_list|(
name|previousLexeme
argument_list|()
argument_list|,
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Q_DECLARE_ASSOCIATIVE_ITERATOR
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|associativeIteratorClasses
operator|.
name|insert
argument_list|(
name|previousLexeme
argument_list|()
argument_list|,
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Q_DECLARE_MUTABLE_ASSOCIATIVE_ITERATOR
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|mutableAssociativeIteratorClasses
operator|.
name|insert
argument_list|(
name|previousLexeme
argument_list|()
argument_list|,
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Q_DECLARE_FLAGS
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
block|{
name|QString
name|flagsType
init|=
name|previousLexeme
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_Comma
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
block|{
name|QString
name|name
init|=
name|previousLexeme
argument_list|()
decl_stmt|;
name|TypedefNode
modifier|*
name|flagsNode
init|=
operator|new
name|TypedefNode
argument_list|(
name|parent
argument_list|,
name|flagsType
argument_list|)
decl_stmt|;
name|flagsNode
operator|->
name|setAccess
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|flagsNode
operator|->
name|setLocation
argument_list|(
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|EnumNode
modifier|*
name|en
init|=
cast|static_cast
argument_list|<
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|parent
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|name
argument_list|,
name|Node
operator|::
name|Enum
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|en
condition|)
name|en
operator|->
name|setFlagsType
argument_list|(
name|flagsNode
argument_list|)
expr_stmt|;
block|}
block|}
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_QT_MODULE
case|:
name|readToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|Tok_LeftParen
argument_list|)
operator|&&
name|match
argument_list|(
name|Tok_Ident
argument_list|)
condition|)
name|moduleName
operator|=
name|previousLexeme
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|moduleName
operator|.
name|startsWith
argument_list|(
literal|"Qt"
argument_list|)
condition|)
name|moduleName
operator|.
name|prepend
argument_list|(
literal|"Qt"
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|Tok_RightParen
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|matchFunctionDecl
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|templateStuff
argument_list|)
condition|)
block|{
while|while
condition|(
name|tok
operator|!=
name|Tok_Eoi
operator|&&
operator|(
name|tokenizer
operator|->
name|braceDepth
argument_list|()
operator|>
name|braceDepth0
operator|||
operator|(
operator|!
name|match
argument_list|(
name|Tok_Semicolon
argument_list|)
operator|&&
name|tok
operator|!=
name|Tok_public
operator|&&
name|tok
operator|!=
name|Tok_protected
operator|&&
name|tok
operator|!=
name|Tok_private
operator|)
operator|)
condition|)
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
name|templateStuff
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   This is called by parseSourceFile() to do the actual parsing   and tree building.  */
end_comment
begin_function
DECL|function|matchDocsAndStuff
name|bool
name|CppCodeParser
operator|::
name|matchDocsAndStuff
parameter_list|()
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|topicCommandsAllowed
init|=
name|topicCommands
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|otherMetacommandsAllowed
init|=
name|otherMetaCommands
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|metacommandsAllowed
init|=
name|topicCommandsAllowed
operator|+
name|otherMetacommandsAllowed
decl_stmt|;
while|while
condition|(
name|tok
operator|!=
name|Tok_Eoi
condition|)
block|{
if|if
condition|(
name|tok
operator|==
name|Tok_Doc
condition|)
block|{
comment|/*               lexeme() returns an entire qdoc comment.              */
name|QString
name|comment
init|=
name|lexeme
argument_list|()
decl_stmt|;
name|Location
name|start_loc
argument_list|(
name|location
argument_list|()
argument_list|)
decl_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|Doc
operator|::
name|trimCStyleComment
argument_list|(
name|start_loc
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|Location
name|end_loc
argument_list|(
name|location
argument_list|()
argument_list|)
decl_stmt|;
comment|/*               Doc parses the comment.              */
name|Doc
name|doc
argument_list|(
name|start_loc
argument_list|,
name|end_loc
argument_list|,
name|comment
argument_list|,
name|metacommandsAllowed
argument_list|)
decl_stmt|;
name|QString
name|topic
decl_stmt|;
name|ArgList
name|args
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|topicCommandsUsed
init|=
name|topicCommandsAllowed
operator|&
name|doc
operator|.
name|metaCommandsUsed
argument_list|()
decl_stmt|;
comment|/*               There should be one topic command in the set,               or none. If the set is empty, then the comment               should be a function description.              */
if|if
condition|(
name|topicCommandsUsed
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|topic
operator|=
operator|*
name|topicCommandsUsed
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|args
operator|=
name|doc
operator|.
name|metaCommandArgs
argument_list|(
name|topic
argument_list|)
expr_stmt|;
block|}
name|NodeList
name|nodes
decl_stmt|;
name|QList
argument_list|<
name|Doc
argument_list|>
name|docs
decl_stmt|;
if|if
condition|(
name|topic
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|parentPath
decl_stmt|;
name|FunctionNode
modifier|*
name|clone
decl_stmt|;
name|FunctionNode
modifier|*
name|func
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|matchFunctionDecl
argument_list|(
literal|0
argument_list|,
operator|&
name|parentPath
argument_list|,
operator|&
name|clone
argument_list|)
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|usedNamespace_
decl|,
name|activeNamespaces_
control|)
block|{
name|QStringList
name|newPath
init|=
name|usedNamespace_
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|parentPath
decl_stmt|;
name|func
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|newPath
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|func
operator|==
literal|0
condition|)
name|func
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|parentPath
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|func
operator|->
name|borrowParameterNames
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|append
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|docs
operator|.
name|append
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
operator|delete
name|clone
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot tie this documentation to anything"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"I found a /*! ... */ comment, but there was no "
literal|"topic command (e.g., '\\%1', '\\%2') in the "
literal|"comment and no function definition following "
literal|"the comment."
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_FN
argument_list|)
operator|.
name|arg
argument_list|(
name|COMMAND_PAGE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*                   There is a topic command. Process it.                  */
if|if
condition|(
operator|(
name|topic
operator|==
name|COMMAND_QMLPROPERTY
operator|)
operator|||
operator|(
name|topic
operator|==
name|COMMAND_QMLATTACHEDPROPERTY
operator|)
condition|)
block|{
name|Doc
name|nodeDoc
init|=
name|doc
decl_stmt|;
name|Node
modifier|*
name|node
init|=
name|processTopicCommandGroup
argument_list|(
name|nodeDoc
argument_list|,
name|topic
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|0
condition|)
block|{
name|nodes
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|docs
operator|.
name|append
argument_list|(
name|nodeDoc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|topicCommandsUsed
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QString
name|topics
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|t
init|=
name|topicCommandsUsed
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|topicCommandsUsed
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|topics
operator|+=
literal|" \\"
operator|+
operator|*
name|t
operator|+
literal|","
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
name|topics
index|[
name|topics
operator|.
name|lastIndexOf
argument_list|(
literal|','
argument_list|)
index|]
operator|=
literal|'.'
expr_stmt|;
name|int
name|i
init|=
name|topics
operator|.
name|lastIndexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
name|topics
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|topics
operator|.
name|insert
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Multiple topic commands found in comment: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|topics
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArgList
operator|::
name|ConstIterator
name|a
init|=
name|args
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|args
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Doc
name|nodeDoc
init|=
name|doc
decl_stmt|;
name|Node
modifier|*
name|node
init|=
name|processTopicCommand
argument_list|(
name|nodeDoc
argument_list|,
name|topic
argument_list|,
operator|*
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|0
condition|)
block|{
name|nodes
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|docs
operator|.
name|append
argument_list|(
name|nodeDoc
argument_list|)
expr_stmt|;
block|}
operator|++
name|a
expr_stmt|;
block|}
block|}
block|}
name|NodeList
operator|::
name|Iterator
name|n
init|=
name|nodes
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|Doc
argument_list|>
operator|::
name|Iterator
name|d
init|=
name|docs
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nodes
operator|.
name|end
argument_list|()
condition|)
block|{
name|processOtherMetaCommands
argument_list|(
operator|*
name|d
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|n
operator|)
operator|->
name|setDoc
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|checkModuleInclusion
argument_list|(
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|n
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|(
name|InnerNode
operator|*
operator|)
operator|*
name|n
operator|)
operator|->
name|includes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|m
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|n
argument_list|)
decl_stmt|;
while|while
condition|(
name|m
operator|->
name|parent
argument_list|()
operator|!=
name|qdb_
operator|->
name|treeRoot
argument_list|()
condition|)
name|m
operator|=
name|m
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|*
name|n
condition|)
operator|(
operator|(
name|InnerNode
operator|*
operator|)
operator|*
name|n
operator|)
operator|->
name|addInclude
argument_list|(
operator|(
operator|*
name|n
operator|)
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
else|else
operator|(
operator|(
name|InnerNode
operator|*
operator|)
operator|*
name|n
operator|)
operator|->
name|setIncludes
argument_list|(
name|m
operator|->
name|includes
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|d
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|Tok_using
condition|)
block|{
name|matchUsingDecl
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|parentPath
decl_stmt|;
name|FunctionNode
modifier|*
name|clone
decl_stmt|;
name|FunctionNode
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|matchFunctionDecl
argument_list|(
literal|0
argument_list|,
operator|&
name|parentPath
argument_list|,
operator|&
name|clone
argument_list|)
condition|)
block|{
comment|/*                   The location of the definition is more interesting                   than that of the declaration. People equipped with                   a sophisticated text editor can respond to warnings                   concerning undocumented functions very quickly.                    Signals are implemented in uninteresting files                   generated by moc.                 */
name|node
operator|=
name|qdb_
operator|->
name|findFunctionNode
argument_list|(
name|parentPath
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Signal
condition|)
name|node
operator|->
name|setLocation
argument_list|(
name|clone
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|clone
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tok
operator|!=
name|Tok_Doc
condition|)
name|readToken
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   This function uses a Tokenizer to parse the function \a signature   in an attempt to match it to the signature of a child node of \a root.   If a match is found, \a funcPtr is set to point to the matching node   and true is returned.  */
end_comment
begin_function
DECL|function|makeFunctionNode
name|bool
name|CppCodeParser
operator|::
name|makeFunctionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QStringList
modifier|*
name|parentPathPtr
parameter_list|,
name|FunctionNode
modifier|*
modifier|*
name|funcPtr
parameter_list|,
name|InnerNode
modifier|*
name|root
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
block|{
name|Tokenizer
modifier|*
name|outerTokenizer
init|=
name|tokenizer
decl_stmt|;
name|int
name|outerTok
init|=
name|tok
decl_stmt|;
name|Location
name|loc
decl_stmt|;
name|QByteArray
name|latin1
init|=
name|signature
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|Tokenizer
name|stringTokenizer
argument_list|(
name|loc
argument_list|,
name|latin1
argument_list|)
decl_stmt|;
name|stringTokenizer
operator|.
name|setParsingFnOrMacro
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tokenizer
operator|=
operator|&
name|stringTokenizer
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|bool
name|ok
init|=
name|matchFunctionDecl
argument_list|(
name|root
argument_list|,
name|parentPathPtr
argument_list|,
name|funcPtr
argument_list|,
name|QString
argument_list|()
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
decl_stmt|;
comment|// potential memory leak with funcPtr
name|tokenizer
operator|=
name|outerTokenizer
expr_stmt|;
name|tok
operator|=
name|outerTok
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*!   Create a new FunctionNode for a QML method or signal, as   specified by \a type, as a child of \a parent. \a sig is   the complete signature, and if \a attached is true, the   method or signal is "attached". \a qdoctag is the text of   the \a type.    \a parent is the QML class node. The QML module and QML   element names have already been consumed to find \a parent.   What remains in \a sig is the method signature. The method   must be a child of \a parent.  */
end_comment
begin_function
DECL|function|makeFunctionNode
name|FunctionNode
modifier|*
name|CppCodeParser
operator|::
name|makeFunctionNode
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|sig
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|bool
name|attached
parameter_list|,
name|QString
name|qdoctag
parameter_list|)
block|{
name|QStringList
name|pp
decl_stmt|;
name|FunctionNode
modifier|*
name|fn
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|makeFunctionNode
argument_list|(
name|sig
argument_list|,
operator|&
name|pp
argument_list|,
operator|&
name|fn
argument_list|,
name|parent
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
operator|&&
operator|!
name|makeFunctionNode
argument_list|(
literal|"void "
operator|+
name|sig
argument_list|,
operator|&
name|pp
argument_list|,
operator|&
name|fn
argument_list|,
name|parent
argument_list|,
name|type
argument_list|,
name|attached
argument_list|)
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid syntax in '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|qdoctag
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fn
return|;
block|}
end_function
begin_function
DECL|function|parseQiteratorDotH
name|void
name|CppCodeParser
operator|::
name|parseQiteratorDotH
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return;
name|QString
name|text
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|text
operator|.
name|remove
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|text
operator|.
name|remove
argument_list|(
literal|"\\\n"
argument_list|)
expr_stmt|;
name|QStringList
name|lines
init|=
name|text
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
decl_stmt|;
name|lines
operator|=
name|lines
operator|.
name|filter
argument_list|(
literal|"Q_DECLARE"
argument_list|)
expr_stmt|;
name|lines
operator|.
name|replaceInStrings
argument_list|(
name|QRegExp
argument_list|(
literal|"#define Q[A-Z_]*\\(C\\)"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|size
argument_list|()
operator|==
literal|4
condition|)
block|{
name|sequentialIteratorDefinition
operator|=
name|lines
index|[
literal|0
index|]
expr_stmt|;
name|mutableSequentialIteratorDefinition
operator|=
name|lines
index|[
literal|1
index|]
expr_stmt|;
name|associativeIteratorDefinition
operator|=
name|lines
index|[
literal|2
index|]
expr_stmt|;
name|mutableAssociativeIteratorDefinition
operator|=
name|lines
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"The qiterator.h hack failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|instantiateIteratorMacro
name|void
name|CppCodeParser
operator|::
name|instantiateIteratorMacro
parameter_list|(
specifier|const
name|QString
modifier|&
name|container
parameter_list|,
specifier|const
name|QString
modifier|&
name|includeFile
parameter_list|,
specifier|const
name|QString
modifier|&
name|macroDef
parameter_list|)
block|{
name|QString
name|resultingCode
init|=
name|macroDef
decl_stmt|;
name|resultingCode
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"\\bC\\b"
argument_list|)
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|resultingCode
operator|.
name|remove
argument_list|(
name|QRegExp
argument_list|(
literal|"\\s*##\\s*"
argument_list|)
argument_list|)
expr_stmt|;
name|Location
name|loc
argument_list|(
name|includeFile
argument_list|)
decl_stmt|;
comment|// hack to get the include file for free
name|QByteArray
name|latin1
init|=
name|resultingCode
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|Tokenizer
name|stringTokenizer
argument_list|(
name|loc
argument_list|,
name|latin1
argument_list|)
decl_stmt|;
name|tokenizer
operator|=
operator|&
name|stringTokenizer
expr_stmt|;
name|readToken
argument_list|()
expr_stmt|;
name|matchDeclList
argument_list|(
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
operator|->
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createExampleFileNodes
name|void
name|CppCodeParser
operator|::
name|createExampleFileNodes
parameter_list|(
name|DocNode
modifier|*
name|dn
parameter_list|)
block|{
name|QString
name|examplePath
init|=
name|dn
operator|->
name|name
argument_list|()
decl_stmt|;
name|QString
name|proFileName
init|=
name|examplePath
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|examplePath
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|.
name|last
argument_list|()
operator|+
literal|".pro"
decl_stmt|;
name|QString
name|userFriendlyFilePath
decl_stmt|;
name|QString
name|fullPath
init|=
name|Config
operator|::
name|findFile
argument_list|(
name|dn
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|exampleFiles
argument_list|,
name|exampleDirs
argument_list|,
name|proFileName
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|tmp
init|=
name|proFileName
decl_stmt|;
name|proFileName
operator|=
name|examplePath
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|"qbuild.pro"
expr_stmt|;
name|userFriendlyFilePath
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fullPath
operator|=
name|Config
operator|::
name|findFile
argument_list|(
name|dn
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|exampleFiles
argument_list|,
name|exampleDirs
argument_list|,
name|proFileName
argument_list|,
name|userFriendlyFilePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|proFileName
operator|=
name|examplePath
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|examplePath
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|.
name|last
argument_list|()
operator|+
literal|".qmlproject"
expr_stmt|;
name|userFriendlyFilePath
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fullPath
operator|=
name|Config
operator|::
name|findFile
argument_list|(
name|dn
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|exampleFiles
argument_list|,
name|exampleDirs
argument_list|,
name|proFileName
argument_list|,
name|userFriendlyFilePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dn
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find file '%1' or '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|tmp
argument_list|)
operator|.
name|arg
argument_list|(
name|proFileName
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"  EXAMPLE PATH DOES NOT EXIST: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|examplePath
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|int
name|sizeOfBoringPartOfName
init|=
name|fullPath
operator|.
name|size
argument_list|()
operator|-
name|proFileName
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullPath
operator|.
name|startsWith
argument_list|(
literal|"./"
argument_list|)
condition|)
name|sizeOfBoringPartOfName
operator|=
name|sizeOfBoringPartOfName
operator|-
literal|2
expr_stmt|;
name|fullPath
operator|.
name|truncate
argument_list|(
name|fullPath
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
name|exampleFiles
init|=
name|Config
operator|::
name|getFilesHere
argument_list|(
name|fullPath
argument_list|,
name|exampleNameFilter
argument_list|)
decl_stmt|;
name|QString
name|imagesPath
init|=
name|fullPath
operator|+
literal|"/images"
decl_stmt|;
name|QStringList
name|imageFiles
init|=
name|Config
operator|::
name|getFilesHere
argument_list|(
name|imagesPath
argument_list|,
name|exampleImageFilter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exampleFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// move main.cpp and to the end, if it exists
name|QString
name|mainCpp
decl_stmt|;
name|QMutableStringListIterator
name|i
argument_list|(
name|exampleFiles
argument_list|)
decl_stmt|;
name|i
operator|.
name|toBack
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|QString
name|fileName
init|=
name|i
operator|.
name|previous
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileName
operator|.
name|endsWith
argument_list|(
literal|"/main.cpp"
argument_list|)
condition|)
block|{
name|mainCpp
operator|=
name|fileName
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|contains
argument_list|(
literal|"/qrc_"
argument_list|)
operator|||
name|fileName
operator|.
name|contains
argument_list|(
literal|"/moc_"
argument_list|)
operator|||
name|fileName
operator|.
name|contains
argument_list|(
literal|"/ui_"
argument_list|)
condition|)
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mainCpp
operator|.
name|isEmpty
argument_list|()
condition|)
name|exampleFiles
operator|.
name|append
argument_list|(
name|mainCpp
argument_list|)
expr_stmt|;
comment|// add any qmake Qt resource files and qmake project files
name|exampleFiles
operator|+=
name|Config
operator|::
name|getFilesHere
argument_list|(
name|fullPath
argument_list|,
literal|"*.qrc *.pro *.qmlproject qmldir"
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|exampleFile
decl|,
name|exampleFiles
control|)
block|{
operator|new
name|DocNode
argument_list|(
name|dn
argument_list|,
name|exampleFile
operator|.
name|mid
argument_list|(
name|sizeOfBoringPartOfName
argument_list|)
argument_list|,
name|Node
operator|::
name|File
argument_list|,
name|Node
operator|::
name|NoPageType
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|imageFile
decl|,
name|imageFiles
control|)
block|{
operator|new
name|DocNode
argument_list|(
name|dn
argument_list|,
name|imageFile
operator|.
name|mid
argument_list|(
name|sizeOfBoringPartOfName
argument_list|)
argument_list|,
name|Node
operator|::
name|Image
argument_list|,
name|Node
operator|::
name|NoPageType
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
