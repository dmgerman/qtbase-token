begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"qdoctagfiles.h"
end_include
begin_include
include|#
directive|include
file|"qdocindexfiles.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|emptyNodeMap_
specifier|static
name|NodeMap
name|emptyNodeMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyNodeMultiMap_
specifier|static
name|NodeMultiMap
name|emptyNodeMultiMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|debug
name|bool
name|QDocDatabase
operator|::
name|debug
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*! \class QDocForest   This class manages a collection of trees. Each tree is an   instance of class Tree, which is a private class.    The forest is populated as each index file is loaded.   Each index file adds a tree to the forest. Each tree   is named with the name of the module it represents.    The search order is created by searchOrder(), if it has   not already been created. The search order and module   names arrays have parallel structure, i.e. modulNames_[i]   is the module name of the Tree at searchOrder_[i].  */
end_comment
begin_comment
comment|/*!   Destroys the qdoc forest. This requires deleting   each Tree in the forest. Note that the forest has   been transferred into the search order array, so   what is really being used to destroy the forest   is the search order array.  */
end_comment
begin_destructor
DECL|function|~QDocForest
name|QDocForest
operator|::
name|~
name|QDocForest
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|searchOrder_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|searchOrder_
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|indexSearchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleNames_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaryTree_
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Initializes the forest prior to a traversal and   returns a pointer to the root node of the primary   tree. If the forest is empty, it return 0  */
end_comment
begin_function
DECL|function|firstRoot
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|firstRoot
parameter_list|()
block|{
name|currentIndex_
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|!
name|searchOrder
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
literal|0
index|]
operator|->
name|root
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Increments the forest's current tree index. If the current   tree index is still within the forest, the function returns   the root node of the current tree. Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|nextRoot
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|nextRoot
parameter_list|()
block|{
operator|++
name|currentIndex_
expr_stmt|;
return|return
operator|(
name|currentIndex_
operator|<
name|searchOrder
argument_list|()
operator|.
name|size
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
name|currentIndex_
index|]
operator|->
name|root
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Initializes the forest prior to a traversal and   returns a pointer to the primary tree. If the   forest is empty, it returns 0.  */
end_comment
begin_function
DECL|function|firstTree
name|Tree
modifier|*
name|QDocForest
operator|::
name|firstTree
parameter_list|()
block|{
name|currentIndex_
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|!
name|searchOrder
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
literal|0
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Increments the forest's current tree index. If the current   tree index is still within the forest, the function returns   the pointer to the current tree. Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|nextTree
name|Tree
modifier|*
name|QDocForest
operator|::
name|nextTree
parameter_list|()
block|{
operator|++
name|currentIndex_
expr_stmt|;
return|return
operator|(
name|currentIndex_
operator|<
name|searchOrder
argument_list|()
operator|.
name|size
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
name|currentIndex_
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn Tree* QDocForest::primaryTree()    Returns the pointer to the primary tree.  */
end_comment
begin_comment
comment|/*!   If the search order array is empty, create the search order.   If the search order array is not empty, do nothing.  */
end_comment
begin_function
DECL|function|setSearchOrder
name|void
name|QDocForest
operator|::
name|setSearchOrder
parameter_list|()
block|{
if|if
condition|(
operator|!
name|searchOrder_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|primaryName
init|=
name|primaryTree
argument_list|()
operator|->
name|moduleName
argument_list|()
decl_stmt|;
name|searchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchOrder_
operator|.
name|reserve
argument_list|(
name|forest_
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|reserve
argument_list|(
name|forest_
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|searchOrder_
operator|.
name|append
argument_list|(
name|primaryTree_
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
name|primaryName
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Tree
modifier|*
argument_list|>
operator|::
name|iterator
name|i
decl_stmt|;
if|if
condition|(
name|primaryName
operator|!=
literal|"QtCore"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtCore"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtCore"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtGui"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtGui"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtGui"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtNetwork"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtNetwork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtNetwork"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtOpenGL"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtOpenGL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtOpenGL"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtWidgets"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtWidgets"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtWidgets"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtSql"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtSql"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtSql"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtXml"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtXml"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtXml"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtSvg"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtSvg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtSvg"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtDoc"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtDoc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtDoc"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtQuick"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtQuick"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtQuick"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtQml"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtQml"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtQml"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtPrintSupport"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtPrintSupport"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtPrintSupport"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtGraphicalEffects"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtGraphicalEffects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtGraphicalEffects"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primaryName
operator|!=
literal|"QtConcurrent"
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
literal|"QtConcurrent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
literal|"QtConcurrent"
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (primaryName != "zzz") {         i = forest_.find("zzz");         if (i != forest_.end()) {             searchOrder_.append(i.value());             moduleNames_.append("zzz");             forest_.erase(i);         }     }
endif|#
directive|endif
comment|/*       If any trees remain in the forest, just add them       to the search order sequentially, because we don't       know any better at this point.      */
if|if
condition|(
operator|!
name|forest_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|forest_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*       Rebuild the forest after constructing the search order.       It was destroyed during construction of the search order,       but it is needed for module-specific searches.      */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|searchOrder_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|forest_
operator|.
name|insert
argument_list|(
name|moduleNames_
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|,
name|searchOrder_
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|qDebug()<< "  SEARCH ORDER:";     for (int i=0; i<moduleNames_.size(); ++i)         qDebug()<< "    "<< i+1<< "."<< moduleNames_.at(i);
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Returns an ordered array of Tree pointers that represents   the order in which the trees should be searched. The first   Tree in the array is the tree for the current module, i.e.   the module for which qdoc is generating documentation.    The other Tree pointers in the array represent the index   files that were loaded in preparation for generating this   module's documentation. Each Tree pointer represents one   index file. The index file Tree points have been ordered   heuristically to, hopefully, minimize searching. Thr order   will probably be changed.    If the search order array is empty, this function calls   indexSearchOrder(). The search order array is empty while   the index files are being loaded, but some searches must   be performed during this time, notably searches for base   class nodes. These searches require a temporary search   order. The temporary order changes throughout the loading   of the index files, but it is always the tree for the   current index file first, followed by the trees for the   index files that have already been loaded. The only   ordering required in this temporary search order is that   the current tree must be searched first.  */
end_comment
begin_function
DECL|function|searchOrder
specifier|const
name|QVector
argument_list|<
name|Tree
modifier|*
argument_list|>
modifier|&
name|QDocForest
operator|::
name|searchOrder
parameter_list|()
block|{
if|if
condition|(
name|searchOrder_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|indexSearchOrder
argument_list|()
return|;
return|return
name|searchOrder_
return|;
block|}
end_function
begin_comment
comment|/*!   There are two search orders used by qdoc when searching for   things. The normal search order is returned by searchOrder(),   but this normal search order is not known until all the index   files have been read. At that point, setSearchOrder() is   called.    During the reading of the index files, the vector holding   the normal search order remains empty. Whenever the search   order is requested, if that vector is empty, this function   is called to return a temporary search order, which includes   all the index files that have been read so far, plus the   one being read now. That one is prepended to the front of   the vector.  */
end_comment
begin_function
DECL|function|indexSearchOrder
specifier|const
name|QVector
argument_list|<
name|Tree
modifier|*
argument_list|>
modifier|&
name|QDocForest
operator|::
name|indexSearchOrder
parameter_list|()
block|{
if|if
condition|(
name|forest_
operator|.
name|size
argument_list|()
operator|>
name|indexSearchOrder_
operator|.
name|size
argument_list|()
condition|)
name|indexSearchOrder_
operator|.
name|prepend
argument_list|(
name|primaryTree_
argument_list|)
expr_stmt|;
return|return
name|indexSearchOrder_
return|;
block|}
end_function
begin_comment
comment|/*!   Create a new Tree for the index file for the specified   \a module and add it to the forest. Return the pointer   to its root.  */
end_comment
begin_function
DECL|function|newIndexTree
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|newIndexTree
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|)
block|{
name|primaryTree_
operator|=
operator|new
name|Tree
argument_list|(
name|module
argument_list|,
name|qdb_
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|insert
argument_list|(
name|module
argument_list|,
name|primaryTree_
argument_list|)
expr_stmt|;
return|return
name|primaryTree_
operator|->
name|root
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Create a new Tree for use as the primary tree. This tree   will represent the primary module.  */
end_comment
begin_function
DECL|function|newPrimaryTree
name|void
name|QDocForest
operator|::
name|newPrimaryTree
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|)
block|{
name|primaryTree_
operator|=
operator|new
name|Tree
argument_list|(
name|module
argument_list|,
name|qdb_
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Searches the trees for a node named \a target and returns   a pointer to it if found. The \a relative node is the starting   point, but it only makes sense in the primary tree, which is   searched first. After the primary tree is searched, \a relative   is set to 0 for searching the index trees. When relative is 0,   the root nodes of the index trees are the starting points.  */
end_comment
begin_function
DECL|function|resolveTarget
specifier|const
name|Node
modifier|*
name|QDocForest
operator|::
name|resolveTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QStringList
name|path
init|=
name|target
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
operator||
name|NonFunction
decl_stmt|;
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|t
operator|->
name|findNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
name|relative
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Searches the Tree \a t for a type node named by the \a path   and returns a pointer to it if found. The \a relative node   is the starting point, but it only makes sense when searching   the primary tree. Therefore, when this function is called with   \a t being an index tree, \a relative is 0. When relative is 0,   the root node of \a t is the starting point.  */
end_comment
begin_function
DECL|function|resolveTypeHelper
specifier|const
name|Node
modifier|*
name|QDocForest
operator|::
name|resolveTypeHelper
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|Tree
modifier|*
name|t
parameter_list|)
block|{
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
operator||
name|NonFunction
decl_stmt|;
return|return
name|t
operator|->
name|findNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function merges all the collection maps for collection   nodes of node type \a t into the collection multimap \a cnmm,   which is cleared before starting.    This is mainly useful for groups, which often cross module   boundaries. It might be true that neither modules nor QML   modules cross module boundaries, but this function works for   those cases as well.  */
end_comment
begin_function
DECL|function|mergeCollectionMaps
name|void
name|QDocForest
operator|::
name|mergeCollectionMaps
parameter_list|(
name|Node
operator|::
name|Type
name|nt
parameter_list|,
name|CNMultiMap
modifier|&
name|cnmm
parameter_list|)
block|{
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
specifier|const
name|CNMap
modifier|&
name|cnm
init|=
name|t
operator|->
name|getCollections
argument_list|(
name|nt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cnm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|cnm
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|cnm
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|value
argument_list|()
operator|->
name|isInternal
argument_list|()
condition|)
name|cnmm
operator|.
name|insert
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*! \class QDocDatabase   This class provides exclusive access to the qdoc database,   which consists of a forrest of trees and a lot of maps and   other useful data structures.  */
end_comment
begin_decl_stmt
DECL|member|qdocDB_
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB_
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|typeNodeMap_
name|NodeMap
name|QDocDatabase
operator|::
name|typeNodeMap_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs the singleton qdoc database object. The singleton   constructs the \a forest_ object, which is also a singleton.   \a showInternal_ is normally false. If it is true, qdoc will   write documentation for nodes marked \c internal.  */
end_comment
begin_constructor
DECL|function|QDocDatabase
name|QDocDatabase
operator|::
name|QDocDatabase
parameter_list|()
member_init_list|:
name|showInternal_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|forest_
argument_list|(
name|this
argument_list|)
block|{
comment|// nothing
block|}
end_constructor
begin_comment
comment|/*!   Destroys the qdoc database object. This requires destroying   the forest object, which contains an array of tree pointers.   Each tree is deleted.  */
end_comment
begin_destructor
DECL|function|~QDocDatabase
name|QDocDatabase
operator|::
name|~
name|QDocDatabase
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Creates the singleton. Allows only one instance of the class   to be created. Returns a pointer to the singleton. */
end_comment
begin_function
DECL|function|qdocDB
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdocDB_
condition|)
block|{
name|qdocDB_
operator|=
operator|new
name|QDocDatabase
expr_stmt|;
name|initializeDB
argument_list|()
expr_stmt|;
block|}
return|return
name|qdocDB_
return|;
block|}
end_function
begin_comment
comment|/*!   Destroys the singleton.  */
end_comment
begin_function
DECL|function|destroyQdocDB
name|void
name|QDocDatabase
operator|::
name|destroyQdocDB
parameter_list|()
block|{
if|if
condition|(
name|qdocDB_
condition|)
block|{
operator|delete
name|qdocDB_
expr_stmt|;
name|qdocDB_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Initialize data structures in the singleton qdoc database.    In particular, the type node map is initialized with a lot   type names that don't refer to documented types. For example,   the C++ standard types are included. These might be documented   here at some point, but for now they are not. Other examples   include \c array and \c data, which are just generic names   used as place holders in function signatures that appear in   the documentation.    Also calls Node::initialize() to initialize the search goal map.  */
end_comment
begin_function
DECL|function|initializeDB
name|void
name|QDocDatabase
operator|::
name|initializeDB
parameter_list|()
block|{
name|Node
operator|::
name|initialize
argument_list|()
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"accepted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"actionPerformed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"activated"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"alias"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"anchors"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"any"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"array"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"autoSearch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"axis"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"backClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"bool"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"boomTime"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"border"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"buttonClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"callback"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"char"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"clicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"close"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"closed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"color"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"cond"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dataReady"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dateString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dateTimeString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"datetime"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"day"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"deactivated"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"double"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"drag"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"easing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"enumeration"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"error"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"exposure"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"fatalError"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"fileSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"flags"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"float"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"focus"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"focusZone"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"format"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"framePainted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"from"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"frontClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"function"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hasOpened"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hovered"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hoveredTitle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hoveredUrl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"imageCapture"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"imageProcessing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"index"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"initialized"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"int"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"isLoaded"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"item"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"jsdict"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"jsobject"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"key"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"keysequence"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"listViewClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"loadRequest"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"locale"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"location"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"long"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"messageReceived"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"mode"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"month"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"number"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"object"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"offset"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"ok"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openCamera"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openImage"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openVideo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"padding"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"parent"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"path"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"photoModeSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"position"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"precision"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"presetClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"preview"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"previewSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"progress"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"puzzleLost"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"qmlSignal"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"real"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"rectangle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"request"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"requestId"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"section"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"selected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"send"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"settingsClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"shoe"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"short"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"signed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sizeChanged"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"size_t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sockaddr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"someOtherSignal"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sourceSize"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"startButtonClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"state"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::initializer_list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::map"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::pair"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::string"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::vector"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"string"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"stringlist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"swapPlayers"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"symbol"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"T"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"tagChanged"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"timeString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"timeout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"to"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"toggled"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"type"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"unsigned"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"urllist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"va_list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"value"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"valueEmitted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoFramePainted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoModeSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoRecorder"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"void"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"volatile"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"wchar_t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"y"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"zoom"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"zoomTo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn NamespaceNode* QDocDatabase::primaryTreeRoot()   Returns a pointer to the root node of the primary tree.  */
end_comment
begin_comment
comment|/*!   \fn const GroupMap& QDocDatabase::groups()   Returns a const reference to the collection of all   group nodes in the primary tree. */
end_comment
begin_comment
comment|/*!   \fn const ModuleMap& QDocDatabase::modules()   Returns a const reference to the collection of all   module nodes in the primary tree. */
end_comment
begin_comment
comment|/*!   \fn const QmlModuleMap& QDocDatabase::qmlModules()   Returns a const reference to the collection of all   QML module nodes in the primary tree. */
end_comment
begin_comment
comment|/*! \fn GroupNode* QDocDatabase::getGroup(const QString& name)   Find the group node named \a name and return a pointer   to it. If a matching node is not found, return 0.  */
end_comment
begin_comment
comment|/*! \fn GroupNode* QDocDatabase::findGroup(const QString& name)   Find the group node named \a name and return a pointer   to it. If a matching node is not found, add a new group   node named \a name and return a pointer to that one.    If a new group node is added, its parent is the tree root,   and the new group node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn ModuleNode* QDocDatabase::findModule(const QString& name)   Find the module node named \a name and return a pointer   to it. If a matching node is not found, add a new module   node named \a name and return a pointer to that one.    If a new module node is added, its parent is the tree root,   and the new module node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn QmlModuleNode* QDocDatabase::findQmlModule(const QString& name)   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, add a new QML module   node named \a name and return a pointer to that one.    If a new QML module node is added, its parent is the tree root,   and the new QML module node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn GroupNode* QDocDatabase::addGroup(const QString& name)   Looks up the group named \a name in the primary tree. If   a match is found, a pointer to the node is returned.   Otherwise, a new group node named \a name is created and   inserted into the collection, and the pointer to that node   is returned.  */
end_comment
begin_comment
comment|/*! \fn ModuleNode* QDocDatabase::addModule(const QString& name)   Looks up the module named \a name in the primary tree. If   a match is found, a pointer to the node is returned.   Otherwise, a new module node named \a name is created and   inserted into the collection, and the pointer to that node   is returned.  */
end_comment
begin_comment
comment|/*! \fn QmlModuleNode* QDocDatabase::addQmlModule(const QString& name)   Looks up the QML module named \a name in the primary tree.   If a match is found, a pointer to the node is returned.   Otherwise, a new QML module node named \a name is created   and inserted into the collection, and the pointer to that   node is returned.  */
end_comment
begin_comment
comment|/*! \fn GroupNode* QDocDatabase::addToGroup(const QString& name, Node* node)   Looks up the group node named \a name in the collection   of all group nodes. If a match is not found, a new group   node named \a name is created and inserted into the collection.   Then append \a node to the group's members list, and append the   group node to the member list of the \a node. The parent of the   \a node is not changed by this function. Returns a pointer to   the group node.  */
end_comment
begin_comment
comment|/*! \fn ModuleNode* QDocDatabase::addToModule(const QString& name, Node* node)   Looks up the module node named \a name in the collection   of all module nodes. If a match is not found, a new module   node named \a name is created and inserted into the collection.   Then append \a node to the module's members list. The parent of   \a node is not changed by this function. Returns the module node.  */
end_comment
begin_comment
comment|/*! \fn QmlModuleNode* QDocDatabase::addToQmlModule(const QString& name, Node* node)   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.  */
end_comment
begin_comment
comment|/*!   Looks up the QML type node identified by the qualified Qml   type \a name and returns a pointer to the QML type node.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   \a qmid and QML type \a name and returns a pointer to the   QML type node. The key is \a qmid + "::" + \a name.    If the QML module id is empty, it looks up the QML type by   \a name only.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|qmid
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qmid
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|t
init|=
name|qmid
operator|+
literal|"::"
operator|+
name|name
decl_stmt|;
name|QmlClassNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
name|QStringList
name|path
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|forest_
operator|.
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|isQmlType
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|isCollisionNode
argument_list|()
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
decl_stmt|;
name|ncn
operator|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|ncn
operator|->
name|findAny
argument_list|(
name|Node
operator|::
name|QmlType
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   constructed from the strings in the \a import record and the   QML type \a name and returns a pointer to the QML type node.   If a QML type node is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|ImportRec
modifier|&
name|import
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|import
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|dotSplit
decl_stmt|;
name|dotSplit
operator|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|qmName
decl_stmt|;
if|if
condition|(
name|import
operator|.
name|importUri_
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmName
operator|=
name|import
operator|.
name|name_
expr_stmt|;
else|else
name|qmName
operator|=
name|import
operator|.
name|importUri_
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dotSplit
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|qualifiedName
init|=
name|qmName
operator|+
literal|"::"
operator|+
name|dotSplit
index|[
name|i
index|]
decl_stmt|;
name|QmlClassNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function calls \a func for each tree in the forest.  */
end_comment
begin_function
DECL|function|processForest
name|void
name|QDocDatabase
operator|::
name|processForest
parameter_list|(
name|void
function_decl|(
name|QDocDatabase
operator|::
modifier|*
name|func
function_decl|)
parameter_list|(
name|InnerNode
modifier|*
parameter_list|)
parameter_list|)
block|{
name|Tree
modifier|*
name|t
init|=
name|forest_
operator|.
name|firstTree
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
condition|)
block|{
operator|(
name|this
operator|->*
operator|(
name|func
operator|)
operator|)
operator|(
name|t
operator|->
name|root
argument_list|()
operator|)
expr_stmt|;
name|t
operator|=
name|forest_
operator|.
name|nextTree
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Constructs the collection of legalese texts, if it has not   already been constructed and returns a reference to it.  */
end_comment
begin_function
DECL|function|getLegaleseTexts
name|TextToNodeMap
modifier|&
name|QDocDatabase
operator|::
name|getLegaleseTexts
parameter_list|()
block|{
if|if
condition|(
name|legaleseTexts_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
argument_list|)
expr_stmt|;
return|return
name|legaleseTexts_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of C++ classes with obsolete members.  */
end_comment
begin_function
DECL|function|getClassesWithObsoleteMembers
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getClassesWithObsoleteMembers
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|classesWithObsoleteMembers_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of obsolete QML types.  */
end_comment
begin_function
DECL|function|getObsoleteQmlTypes
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getObsoleteQmlTypes
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|obsoleteQmlTypes_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of QML types with obsolete members.  */
end_comment
begin_function
DECL|function|getQmlTypesWithObsoleteMembers
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypesWithObsoleteMembers
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|qmlTypesWithObsoleteMembers_
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs the C++ namespace data structure, if it has not   already been constructed. Returns a reference to it.  */
end_comment
begin_function
DECL|function|getNamespaces
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getNamespaces
parameter_list|()
block|{
if|if
condition|(
name|namespaceIndex_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllNamespaces
argument_list|)
expr_stmt|;
return|return
name|namespaceIndex_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the C++ class data structures, if they have not   already been constructed. Returns a reference to the map   of C++ service clases.    \note This is currently not used.  */
end_comment
begin_function
DECL|function|getServiceClasses
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getServiceClasses
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlClasses_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|serviceClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for QML basic types, if they   have not already been constructed. Returns a reference to   the map of QML basic types.  */
end_comment
begin_function
DECL|function|getQmlBasicTypes
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlBasicTypes
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlBasicTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|qmlBasicTypes_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of obsolete QML types.  */
end_comment
begin_function
DECL|function|getQmlTypes
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypes
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlClasses_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|qmlClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of obsolete C++ clases.  */
end_comment
begin_function
DECL|function|getObsoleteClasses
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getObsoleteClasses
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|obsoleteClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the C++ class data structures, if they have not   already been constructed. Returns a reference to the map   of compatibility C++ clases.  */
end_comment
begin_function
DECL|function|getCompatibilityClasses
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getCompatibilityClasses
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlClasses_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|compatClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the C++ class data structures, if they have not   already been constructed. Returns a reference to the map   of main C++ clases.    \note The main C++ classes data structure is currently not   used.  */
end_comment
begin_function
DECL|function|getMainClasses
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getMainClasses
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlClasses_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|mainClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the C++ class data structures, if they have not   already been constructed. Returns a reference to the map   of all C++ classes.  */
end_comment
begin_function
DECL|function|getCppClasses
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getCppClasses
parameter_list|()
block|{
if|if
condition|(
name|nonCompatClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlClasses_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|nonCompatClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the C++ class nodes and QML type nodes and   sorts them into maps.  */
end_comment
begin_function
DECL|function|findAllClasses
name|void
name|QDocDatabase
operator|::
name|findAllClasses
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|isInternal
argument_list|()
operator|||
name|showInternal_
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|className
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Compat
condition|)
block|{
name|compatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonCompatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Main
condition|)
name|mainClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
name|QString
name|serviceName
init|=
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|serviceName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|serviceClasses_
operator|.
name|insert
argument_list|(
name|serviceName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlBasicType
argument_list|()
operator|)
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|qmlTypeName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|qmlTypeName
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
else|else
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
comment|//also add to the QML basic type map
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlBasicType
argument_list|()
condition|)
name|qmlBasicTypes_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllClasses
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Construct the function index data structure and return it.   This data structure is used to output the function index page.  */
end_comment
begin_function
DECL|function|getFunctionIndex
name|NodeMapMap
modifier|&
name|QDocDatabase
operator|::
name|getFunctionIndex
parameter_list|()
block|{
name|funcIndex_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllFunctions
argument_list|)
expr_stmt|;
return|return
name|funcIndex_
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the function nodes  */
end_comment
begin_function
DECL|function|findAllFunctions
name|void
name|QDocDatabase
operator|::
name|findAllFunctions
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllFunctions
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|!
name|func
operator|->
name|isInternal
argument_list|()
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|funcIndex_
index|[
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes containing legalese text and puts them   in a map.  */
end_comment
begin_function
DECL|function|findAllLegaleseTexts
name|void
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|legaleseTexts_
operator|.
name|insertMulti
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllLegaleseTexts
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the namespace nodes and puts them in an index.  */
end_comment
begin_function
DECL|function|findAllNamespaces
name|void
name|QDocDatabase
operator|::
name|findAllNamespaces
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllNamespaces
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
comment|// Ensure that the namespace's name is not empty (the root
comment|// namespace has no name).
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|namespaceIndex_
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all nodes with status = Obsolete and sorts them into   maps. They can be C++ classes, QML types, or they can be   functions, enum types, typedefs, methods, etc.  */
end_comment
begin_function
DECL|function|findAllObsoleteThings
name|void
name|QDocDatabase
operator|::
name|findAllObsoleteThings
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|QString
name|name
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteClasses_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|qmlModuleName
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteQmlTypes_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
case|case
name|Node
operator|::
name|Variable
case|:
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|classesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|QmlSignal
case|:
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
case|case
name|Node
operator|::
name|QmlMethod
case|:
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|parent
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
operator|&&
name|parent
operator|->
name|parent
argument_list|()
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|isQmlType
argument_list|()
operator|&&
operator|!
name|parent
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
name|parent
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|qmlTypesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllObsoleteThings
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes where a \e{since} command appeared in the   qdoc comment and sorts them into maps according to the kind of   node.    This function is used for generating the "New Classes... in x.y"   section on the \e{What's New in Qt x.y} page.  */
end_comment
begin_function
DECL|function|findAllSince
name|void
name|QDocDatabase
operator|::
name|findAllSince
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|child
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|child
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|sinceString
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|since
argument_list|()
decl_stmt|;
comment|// Insert a new entry into each map for each new since string found.
if|if
condition|(
operator|(
operator|(
operator|*
name|child
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
operator|&&
operator|!
name|sinceString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMultiMapMap
operator|::
name|iterator
name|nsmap
init|=
name|newSinceMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsmap
operator|==
name|newSinceMaps_
operator|.
name|end
argument_list|()
condition|)
name|nsmap
operator|=
name|newSinceMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|ncmap
init|=
name|newClassMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncmap
operator|==
name|newClassMaps_
operator|.
name|end
argument_list|()
condition|)
name|ncmap
operator|=
name|newClassMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|nqcmap
init|=
name|newQmlTypeMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nqcmap
operator|==
name|newQmlTypeMaps_
operator|.
name|end
argument_list|()
condition|)
name|nqcmap
operator|=
name|newQmlTypeMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
comment|// Insert functions into the general since map.
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
comment|// Insert classes into the since and class maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|ncmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
comment|// Insert QML elements into the since and element maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|nqcmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
comment|// Insert QML properties into the since map.
name|QString
name|propertyName
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|propertyName
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert external documents into the general since map.
name|QString
name|name
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Recursively find child nodes with since commands.
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllSince
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|child
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new class maps, and return a   reference to the value, which is a NodeMap. If \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getClassMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getClassMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newClassMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newClassMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new QML type maps, and return a   reference to the value, which is a NodeMap. If the \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getQmlTypeMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypeMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newQmlTypeMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newQmlTypeMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new \e {since} maps, and return   a reference to the value, which is a NodeMultiMap. If \a key   is not found, return a reference to an empty NodeMultiMap.  */
end_comment
begin_function
DECL|function|getSinceMap
specifier|const
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getSinceMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMultiMapMap
operator|::
name|const_iterator
name|i
init|=
name|newSinceMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newSinceMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMultiMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Performs several housekeeping algorithms that create   certain data structures and resolve lots of links, prior   to generating documentation.  */
end_comment
begin_function
DECL|function|resolveIssues
name|void
name|QDocDatabase
operator|::
name|resolveIssues
parameter_list|()
block|{
name|resolveQmlInheritance
argument_list|(
name|primaryTreeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|resolveTargets
argument_list|()
expr_stmt|;
name|primaryTree
argument_list|()
operator|->
name|resolveCppToQmlLinks
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is called for autolinking to a \a type,   which could be a function return type or a parameter   type. The tree node that represents the \a type is   returned. All the trees are searched until a match is   found. When searching the primary tree, the search   begins at \a relative and proceeds up the parent chain.   When searching the index trees, the search begins at the   root.  */
end_comment
begin_function
DECL|function|resolveType
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|resolveType
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QStringList
name|path
init|=
name|type
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
index|[
literal|0
index|]
operator|.
name|isLower
argument_list|()
operator|||
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QString
argument_list|(
literal|"T"
argument_list|)
operator|)
condition|)
block|{
name|NodeMap
operator|::
name|iterator
name|i
init|=
name|typeNodeMap_
operator|.
name|find
argument_list|(
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|typeNodeMap_
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|forest_
operator|.
name|resolveType
argument_list|(
name|path
argument_list|,
name|relative
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the node that will generate the documentation that   contains the \a target and returns a pointer to it.    Can this be improved by using the target map in Tree?  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
name|node
operator|=
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|target
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|resolveTarget
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|findDocNodeByTitle
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   For each QML Type node in the tree beginning at \a root,   if it has a QML base type name but its QML base type node   pointer is 0, use the QML base type name to look up the   base type node. If the node is found in the tree, set the   node's QML base type node pointer.  */
end_comment
begin_function
DECL|function|resolveQmlInheritance
name|void
name|QDocDatabase
operator|::
name|resolveQmlInheritance
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
name|NodeMap
name|previousSearches
decl_stmt|;
comment|// Do we need recursion?
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
operator|->
name|qmlBaseNodeNotSet
argument_list|()
operator|&&
operator|!
name|qcn
operator|->
name|qmlBaseName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|bqcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|previousSearches
operator|.
name|value
argument_list|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bqcn
condition|)
name|qcn
operator|->
name|setQmlBaseNode
argument_list|(
name|bqcn
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|qcn
operator|->
name|importList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ImportList
modifier|&
name|imports
init|=
name|qcn
operator|->
name|importList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|imports
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|imports
index|[
name|i
index|]
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bqcn
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|bqcn
operator|==
literal|0
condition|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|QString
argument_list|()
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bqcn
condition|)
block|{
name|qcn
operator|->
name|setQmlBaseNode
argument_list|(
name|bqcn
argument_list|)
expr_stmt|;
name|previousSearches
operator|.
name|insert
argument_list|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|,
name|bqcn
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {                         qDebug()<< "Temporary error message (ignore): UNABLE to resolve QML base type:"<< qcn->qmlBaseName()<< "for QML type:"<< qcn->name();                     }
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Generates a tag file and writes it to \a name.  */
end_comment
begin_function
DECL|function|generateTagFile
name|void
name|QDocDatabase
operator|::
name|generateTagFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDocTagFiles
operator|::
name|qdocTagFiles
argument_list|()
operator|->
name|generateTagFile
argument_list|(
name|name
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|QDocTagFiles
operator|::
name|destroyQDocTagFiles
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the qdoc index files listed in \a indexFiles.  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|QDocDatabase
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|indexFiles
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|readIndexes
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates a qdoc index file and write it to \a fileName. The   index file is generated with the parameters \a url, \a title,   \a g, and \a generateInternalNodes.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|QDocDatabase
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|generateIndex
argument_list|(
name|fileName
argument_list|,
name|url
argument_list|,
name|title
argument_list|,
name|g
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   If there are open namespaces, search for the function node   having the same function name as the \a clone node in each   open namespace. The \a parentPath is a portion of the path   name provided with the function name at the point of   reference. \a parentPath is usually a class name. Return   the pointer to the function node if one is found in an   open namespace. Otherwise return 0.    This open namespace concept is of dubious value and might   be removed.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|FunctionNode
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|path
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|parentPath
decl_stmt|;
name|fn
operator|=
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
break|break;
block|}
block|}
return|return
name|fn
return|;
block|}
end_function
begin_comment
comment|/*!   Find a node of the specified \a type that is reached with   the specified \a path qualified with the name of one of the   open namespaces (might not be any open ones). If the node   is found in an open namespace, prefix \a path with the name   of the open namespace and "::" and return a pointer to the   node. Othewrwise return 0.    This function only searches in the current primary tree.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|Node
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|path
index|[
literal|0
index|]
condition|)
name|p
operator|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|path
expr_stmt|;
else|else
name|p
operator|=
name|path
expr_stmt|;
name|n
operator|=
name|primaryTree
argument_list|()
operator|->
name|findNodeByNameAndType
argument_list|(
name|p
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|path
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the collection nodes of type \a nt into the   collection node map \a cnn. Nodes that match \a relative   are not included.  */
end_comment
begin_function
DECL|function|mergeCollections
name|void
name|QDocDatabase
operator|::
name|mergeCollections
parameter_list|(
name|Node
operator|::
name|Type
name|nt
parameter_list|,
name|CNMap
modifier|&
name|cnm
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QRegExp
name|singleDigit
argument_list|(
literal|"\\b([0-9])\\b"
argument_list|)
decl_stmt|;
name|CNMultiMap
name|cnmm
decl_stmt|;
name|forest_
operator|.
name|mergeCollectionMaps
argument_list|(
name|nt
argument_list|,
name|cnmm
argument_list|)
expr_stmt|;
name|cnm
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cnmm
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QStringList
name|keys
init|=
name|cnmm
operator|.
name|uniqueKeys
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QString
name|key
decl|,
name|keys
control|)
block|{
name|QList
argument_list|<
name|CollectionNode
modifier|*
argument_list|>
name|values
init|=
name|cnmm
operator|.
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|CollectionNode
modifier|*
name|n
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|v
decl|,
name|values
control|)
block|{
if|if
condition|(
name|v
operator|&&
name|v
operator|->
name|wasSeen
argument_list|()
operator|&&
operator|(
name|v
operator|!=
name|relative
operator|)
condition|)
block|{
name|n
operator|=
name|v
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|v
decl|,
name|values
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|n
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|t
decl|,
name|v
operator|->
name|members
argument_list|()
control|)
name|n
operator|->
name|addMember
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|n
operator|->
name|members
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|sortKey
init|=
name|n
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
name|cnm
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the collection nodes with the same name   and type as \a cn and merges their members into the   members list of \a cn.  */
end_comment
begin_function
DECL|function|mergeCollections
name|void
name|QDocDatabase
operator|::
name|mergeCollections
parameter_list|(
name|CollectionNode
modifier|*
name|cn
parameter_list|)
block|{
name|CollectionList
name|cl
decl_stmt|;
name|forest_
operator|.
name|getCorrespondingCollections
argument_list|(
name|cn
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cl
operator|.
name|empty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|v
decl|,
name|cl
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|cn
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|t
decl|,
name|v
operator|->
name|members
argument_list|()
control|)
name|cn
operator|->
name|addMember
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function is called when the \a{atom} might be a link   atom. It handles the optional, square bracket parameters   for the link command.  */
end_comment
begin_function
DECL|function|findNode
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNode
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
name|QStringList
name|path
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|specifiesDomain
argument_list|()
condition|)
block|{
return|return
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|atom
operator|->
name|goal
argument_list|()
argument_list|)
return|;
block|}
name|qDebug
argument_list|()
operator|<<
literal|"FINDNODE:"
operator|<<
name|path
operator|<<
name|atom
operator|->
name|goal
argument_list|()
expr_stmt|;
return|return
name|forest_
operator|.
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|atom
operator|->
name|goal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findDocNodeByTitle
specifier|const
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findDocNodeByTitle
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
return|return
name|forest_
operator|.
name|findDocNodeByTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Searches for the node that matches the path in \a atom. The   \a relative node is used if the first leg of the path is   empty, i.e. if the path begins with a hashtag. The function   also sets \a ref if there remains an unused leg in the path   after the node is found. The node is returned as well as the   \a ref. If the returned node pointer is null, \a ref is not   valid.  */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNode
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QStringList
name|path
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|QString
name|first
init|=
name|path
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
comment|// search for a target on the current page.
elseif|else
if|if
condition|(
name|atom
operator|->
name|specifiesDomain
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Processing LinkAtom"
expr_stmt|;
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
comment|// The target is an html file.
name|node
operator|=
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|first
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
comment|// The target is a C++ function or QML method.
name|node
operator|=
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|resolveFunctionTarget
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//relative);
block|}
else|else
block|{
name|node
operator|=
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|resolveTarget
argument_list|(
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// relative);
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|findUnambiguousTarget
argument_list|(
name|first
argument_list|,
name|ref
argument_list|)
expr_stmt|;
comment|// ref
if|if
condition|(
operator|!
name|node
operator|&&
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|atom
operator|->
name|domain
argument_list|()
operator|->
name|findDocNodeByTitle
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
comment|// The target is an html file.
name|node
operator|=
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|first
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
comment|// ref
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
comment|// The target is a C++ function or QML method.
name|node
operator|=
name|resolveFunctionTarget
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|resolveTarget
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
comment|// ref
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|findUnambiguousTarget
argument_list|(
name|first
argument_list|,
name|ref
argument_list|)
expr_stmt|;
comment|// ref
if|if
condition|(
operator|!
name|node
operator|&&
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|findDocNodeByTitle
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|&&
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
return|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|findTarget
argument_list|(
name|path
operator|.
name|first
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
