begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"qdoctagfiles.h"
end_include
begin_include
include|#
directive|include
file|"qdocindexfiles.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|emptyNodeMap_
specifier|static
name|NodeMap
name|emptyNodeMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyNodeMultiMap_
specifier|static
name|NodeMultiMap
name|emptyNodeMultiMap_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*! \class QDocDatabase  */
end_comment
begin_decl_stmt
DECL|member|qdocDB_
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB_
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs the singleton qdoc database object.   It constructs a singleton Tree object with this   qdoc database pointer.  */
end_comment
begin_constructor
DECL|function|QDocDatabase
name|QDocDatabase
operator|::
name|QDocDatabase
parameter_list|()
block|{
name|tree_
operator|=
operator|new
name|Tree
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the qdoc database object. This requires deleting   the tree of nodes, which deletes each node.  */
end_comment
begin_destructor
DECL|function|~QDocDatabase
name|QDocDatabase
operator|::
name|~
name|QDocDatabase
parameter_list|()
block|{
name|masterMap_
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|tree_
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \fn Tree* QDocDatabase::tree()   Returns the pointer to the tree. This function is for compatibility   with the current qdoc. It will be removed when the QDocDatabase class   replaces the current structures.  */
end_comment
begin_comment
comment|/*!   Creates the singleton. Allows only one instance of the class   to be created. Returns a pointer to the singleton. */
end_comment
begin_function
DECL|function|qdocDB
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdocDB_
condition|)
name|qdocDB_
operator|=
operator|new
name|QDocDatabase
expr_stmt|;
return|return
name|qdocDB_
return|;
block|}
end_function
begin_comment
comment|/*!   Destroys the singleton.  */
end_comment
begin_function
DECL|function|destroyQdocDB
name|void
name|QDocDatabase
operator|::
name|destroyQdocDB
parameter_list|()
block|{
if|if
condition|(
name|qdocDB_
condition|)
block|{
operator|delete
name|qdocDB_
expr_stmt|;
name|qdocDB_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \fn const DocNodeMap& QDocDatabase::modules() const   Returns a const reference to the collection of all   module nodes. */
end_comment
begin_comment
comment|/*!   \fn const DocNodeMap& QDocDatabase::qmlModules() const   Returns a const reference to the collection of all   QML module nodes. */
end_comment
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_function
DECL|function|addModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
return|return
name|findModule
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module node named \a name in the collection   of all QML module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new QML module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_function
DECL|function|addQmlModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
return|return
name|findQmlModule
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the C++ module named \a moduleName. If it isn't   there, create it. Then append \a node to the module's child   list. The parent of \a node is not changed by this function.   Returns the module node.  */
end_comment
begin_function
DECL|function|addToModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addToModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|moduleName
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|findModule
argument_list|(
name|moduleName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|dn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setModuleName
argument_list|(
name|moduleName
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module named \a qmlModuleName. If it isn't   there, create it. Then append \a node to the module's child   list. The parent of \a node is not changed by this function.   Returns a pointer to the QML module node.  */
end_comment
begin_function
DECL|function|addToQmlModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addToQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|qmlModuleName
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|findQmlModule
argument_list|(
name|qmlModuleName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|dn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setQmlModuleInfo
argument_list|(
name|qmlModuleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QString
name|t
init|=
name|node
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
literal|"::"
operator|+
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
name|QmlClassNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qmlTypeMap_
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
name|qmlTypeMap_
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|node
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the module node named \a name and return a pointer   to it. If a matching node is not found and \a addIfNotFound   is true, add a new module node named \a name and return   a pointer to that one. Otherwise, return 0.    If a new module node is added, its parent is the tree root,   but the new module node is not added to the child list of the   tree root.  */
end_comment
begin_function
DECL|function|findModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|addIfNotFound
parameter_list|)
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
if|if
condition|(
name|addIfNotFound
condition|)
block|{
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|Module
argument_list|,
name|Node
operator|::
name|OverviewPage
argument_list|)
decl_stmt|;
name|modules_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found and \a addIfNotFound   is true, add a new QML module node named \a name and return   a pointer to that one. Otherwise, return 0.    If a new QML module node is added, its parent is the tree root,   but the new QML module node is not added to the child list of   the tree root.  */
end_comment
begin_function
DECL|function|findQmlModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|addIfNotFound
parameter_list|)
block|{
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|qmid
init|=
name|blankSplit
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmid
operator|+=
name|dotSplit
index|[
literal|0
index|]
expr_stmt|;
block|}
name|DocNode
modifier|*
name|dn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qmlModules_
operator|.
name|contains
argument_list|(
name|qmid
argument_list|)
condition|)
name|dn
operator|=
name|qmlModules_
operator|.
name|value
argument_list|(
name|qmid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addIfNotFound
condition|)
block|{
name|dn
operator|=
operator|new
name|DocNode
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|QmlModule
argument_list|,
name|Node
operator|::
name|OverviewPage
argument_list|)
expr_stmt|;
name|dn
operator|->
name|setQmlModuleInfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|qmlModules_
operator|.
name|insert
argument_list|(
name|qmid
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|masterMap_
operator|.
name|insert
argument_list|(
name|qmid
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|masterMap_
operator|.
name|insert
argument_list|(
name|dn
operator|->
name|name
argument_list|()
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   \a qmid and QML type \a name and returns a pointer to the   QML type node. The key is \a qmid + "::" + \a name.    If the QML module id is empty, it looks up the QML type by   \a name only.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|qmid
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|qmid
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|qmlTypeMap_
operator|.
name|value
argument_list|(
name|qmid
operator|+
literal|"::"
operator|+
name|name
argument_list|)
return|;
name|QStringList
name|path
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|tree_
operator|->
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
decl_stmt|;
name|ncn
operator|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|ncn
operator|->
name|findAny
argument_list|(
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   For debugging only.  */
end_comment
begin_function
DECL|function|printModules
name|void
name|QDocDatabase
operator|::
name|printModules
parameter_list|()
specifier|const
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"  "
operator|<<
name|i
operator|.
name|key
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   For debugging only.  */
end_comment
begin_function
DECL|function|printQmlModules
name|void
name|QDocDatabase
operator|::
name|printQmlModules
parameter_list|()
specifier|const
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|qmlModules_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|qmlModules_
operator|.
name|end
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"  "
operator|<<
name|i
operator|.
name|key
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Traverses the database to construct useful data structures   for use when outputting certain significant collections of   things, C++ classes, QML types, "since" lists, and other   stuff.  */
end_comment
begin_function
DECL|function|buildCollections
name|void
name|QDocDatabase
operator|::
name|buildCollections
parameter_list|()
block|{
name|nonCompatClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mainClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|compatClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|obsoleteClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|funcIndex_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|legaleseTexts_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|serviceClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qmlClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|findAllClasses
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllFunctions
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllLegaleseTexts
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllNamespaces
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllSince
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Finds all the C++ class nodes and QML type nodes and   sorts them into maps.  */
end_comment
begin_function
DECL|function|findAllClasses
name|void
name|QDocDatabase
operator|::
name|findAllClasses
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|className
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
if|if
condition|(
operator|!
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|hideFromMainList
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Compat
condition|)
block|{
name|compatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|obsoleteClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonCompatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Main
condition|)
name|mainClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|QString
name|serviceName
init|=
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|serviceName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
condition|)
name|serviceClasses_
operator|.
name|insert
argument_list|(
name|serviceName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|qmlTypeName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|qmlTypeName
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
else|else
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllClasses
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the function nodes  */
end_comment
begin_function
DECL|function|findAllFunctions
name|void
name|QDocDatabase
operator|::
name|findAllFunctions
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllFunctions
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|!
name|func
operator|->
name|isInternal
argument_list|()
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|funcIndex_
index|[
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes containing legalese text and puts them   in a map.  */
end_comment
begin_function
DECL|function|findAllLegaleseTexts
name|void
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|legaleseTexts_
operator|.
name|insertMulti
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllLegaleseTexts
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the namespace nodes and puts them in an index.  */
end_comment
begin_function
DECL|function|findAllNamespaces
name|void
name|QDocDatabase
operator|::
name|findAllNamespaces
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllNamespaces
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
specifier|const
name|NamespaceNode
modifier|*
name|nspace
init|=
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
comment|// Ensure that the namespace's name is not empty (the root
comment|// namespace has no name).
if|if
condition|(
operator|!
name|nspace
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|namespaceIndex_
operator|.
name|insert
argument_list|(
name|nspace
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes where a \e{since} command appeared in the   qdoc comment and sorts them into maps according to the kind of   node.    This function is used for generating the "New Classes... in x.y"   section on the \e{What's New in Qt x.y} page.  */
end_comment
begin_function
DECL|function|findAllSince
name|void
name|QDocDatabase
operator|::
name|findAllSince
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|child
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|child
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|sinceString
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|since
argument_list|()
decl_stmt|;
comment|// Insert a new entry into each map for each new since string found.
if|if
condition|(
operator|(
operator|(
operator|*
name|child
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
operator|&&
operator|!
name|sinceString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMultiMapMap
operator|::
name|iterator
name|nsmap
init|=
name|newSinceMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsmap
operator|==
name|newSinceMaps_
operator|.
name|end
argument_list|()
condition|)
name|nsmap
operator|=
name|newSinceMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|ncmap
init|=
name|newClassMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncmap
operator|==
name|newClassMaps_
operator|.
name|end
argument_list|()
condition|)
name|ncmap
operator|=
name|newClassMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|nqcmap
init|=
name|newQmlTypeMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nqcmap
operator|==
name|newQmlTypeMaps_
operator|.
name|end
argument_list|()
condition|)
name|nqcmap
operator|=
name|newQmlTypeMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
comment|// Insert functions into the general since map.
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Insert classes into the since and class maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|ncmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
comment|// Insert QML elements into the since and element maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|nqcmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
comment|// Insert QML properties into the since map.
name|QString
name|propertyName
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|propertyName
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Insert external documents into the general since map.
name|QString
name|name
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// Recursively find child nodes with since commands.
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllSince
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|child
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new class maps, and return a   reference to the value, which is a NodeMap. If \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getClassMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getClassMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newClassMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newClassMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new QML type maps, and return a   reference to the value, which is a NodeMap. If the \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getQmlTypeMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypeMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newQmlTypeMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newQmlTypeMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new \e {since} maps, and return   a reference to the value, which is a NodeMultiMap. If \a key   is not found, return a reference to an empty NodeMultiMap.  */
end_comment
begin_function
DECL|function|getSinceMap
specifier|const
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getSinceMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMultiMapMap
operator|::
name|const_iterator
name|i
init|=
name|newSinceMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newSinceMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMultiMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Performs several housekeeping algorithms that create   certain data structures and resolve lots of links, prior   to generating documentation.  */
end_comment
begin_function
DECL|function|resolveIssues
name|void
name|QDocDatabase
operator|::
name|resolveIssues
parameter_list|()
block|{
name|tree_
operator|->
name|resolveGroups
argument_list|()
expr_stmt|;
name|resolveTargets
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|tree_
operator|->
name|resolveCppToQmlLinks
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Look up group \a name in the map of groups. If found, populate   the node map \a group with the classes in the group that are   not marked internal or private.  */
end_comment
begin_function
DECL|function|getGroup
name|void
name|QDocDatabase
operator|::
name|getGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|NodeMap
modifier|&
name|group
parameter_list|)
specifier|const
block|{
name|group
operator|.
name|clear
argument_list|()
expr_stmt|;
name|NodeList
name|values
init|=
name|tree_
operator|->
name|groups
argument_list|()
operator|.
name|values
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
operator|&&
operator|(
name|n
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
condition|)
block|{
name|group
operator|.
name|insert
argument_list|(
name|n
operator|->
name|nameForLists
argument_list|()
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Searches the \a database for a node named \a target and returns   a pointer to it if found.  */
end_comment
begin_function
DECL|function|resolveTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|resolveTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
name|QString
name|funcName
init|=
name|target
decl_stmt|;
name|funcName
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|QStringList
name|path
init|=
name|funcName
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
name|tree_
operator|->
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|SearchBaseClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
comment|/*               Why is this case not accepted?              */
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
name|node
operator|=
name|fn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
condition|)
block|{
comment|// This error message is never printed; I think we can remove the case.
name|qDebug
argument_list|()
operator|<<
literal|"qdoc: target case not handled:"
operator|<<
name|target
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|path
init|=
name|target
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
operator||
name|NonFunction
decl_stmt|;
name|node
operator|=
name|tree_
operator|->
name|findNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|,
name|self
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the node that will generate the documentation that   contains the \a target and returns a pointer to it.  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|node
operator|=
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|target
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|=
name|resolveTarget
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|findDocNodeByTitle
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   Inserts a new target into the target table with the specified   \a name, \a node, and \a priority.  */
end_comment
begin_function
DECL|function|insertTarget
name|void
name|QDocDatabase
operator|::
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|node
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
name|priority
expr_stmt|;
name|Atom
name|a
init|=
name|Atom
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|targetMultiMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a \a target anchor node. If it   finds one, it sets \a ref and returns the found node.  */
end_comment
begin_function
specifier|const
name|Node
modifier|*
DECL|function|findUnambiguousTarget
name|QDocDatabase
operator|::
name|findUnambiguousTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|Target
name|bestTarget
decl_stmt|;
name|int
name|numBestTargets
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|Target
argument_list|>
name|bestTargetList
decl_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetMultiMap
operator|::
name|iterator
name|i
init|=
name|targetMultiMap_
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|targetMultiMap_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|!=
name|key
condition|)
break|break;
specifier|const
name|Target
modifier|&
name|candidate
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|<
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|==
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|numBestTargets
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numBestTargets
operator|==
literal|1
condition|)
block|{
name|ref
operator|=
name|bestTarget
operator|.
name|ref_
expr_stmt|;
return|return
name|bestTarget
operator|.
name|node_
return|;
block|}
elseif|else
if|if
condition|(
name|bestTargetList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bestTargetList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
condition|)
block|{
name|ref
operator|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|ref_
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
block|}
block|}
block|}
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with the specified \a title.   If \a relative node is provided, it is used to disambiguate if   it has a QML module identifier.  */
end_comment
begin_function
DECL|function|findDocNodeByTitle
specifier|const
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findDocNodeByTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|DocNodeMultiMap
operator|::
name|const_iterator
name|i
init|=
name|docNodesByTitle_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|dn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|parent
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|nl
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|it
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
condition|)
block|{
comment|/*                           By returning here, we avoid printing all the duplicate                           header warnings, which are not really duplicates now,                           because of the QML module identifier being used as a                           namespace qualifier.                         */
name|dn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
comment|/*           Reporting all these duplicate section titles is probably           overkill. We should report the duplicate file and let           that suffice.         */
name|DocNodeMultiMap
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Location
argument_list|>
name|internalLocations
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
operator|&&
name|j
operator|.
name|value
argument_list|()
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|internalLocations
operator|.
name|append
argument_list|(
name|j
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|internalLocations
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|i
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"This page exists in more than one file: \"%1\""
argument_list|)
operator|.
name|arg
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Location
modifier|&
name|location
decl|,
name|internalLocations
control|)
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"[It also exists here]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with a canonical title   constructed from \a target. If the node it finds is \a node,   it returns the ref from that node. Otherwise it returns an   empty string.  */
end_comment
begin_function
DECL|function|findTarget
name|QString
name|QDocDatabase
operator|::
name|findTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetMultiMap
operator|::
name|const_iterator
name|i
init|=
name|targetMultiMap_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|targetMultiMap_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|node_
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|.
name|ref_
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|targetMultiMap_
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
do|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveTargets
name|void
name|QDocDatabase
operator|::
name|resolveTargets
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// need recursion
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|DocNode
modifier|*
name|node
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
decl_stmt|;
name|docNodesByTitle_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|resolveTargets
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|targetMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|keywords
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|targetMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|targetMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Generates a tag file and writes it to \a name.  */
end_comment
begin_function
DECL|function|generateTagFile
name|void
name|QDocDatabase
operator|::
name|generateTagFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDocTagFiles
operator|::
name|qdocTagFiles
argument_list|()
operator|->
name|generateTagFile
argument_list|(
name|name
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|QDocTagFiles
operator|::
name|destroyQDocTagFiles
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the qdoc index files listed in \a indexFiles.  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|QDocDatabase
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|indexFiles
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|readIndexes
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates a qdoc index file and write it to \a fileName. The   index file is generated with the parameters \a url, \a title,   \a g, and \a generateInternalNodes.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|QDocDatabase
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|generateIndex
argument_list|(
name|fileName
argument_list|,
name|url
argument_list|,
name|title
argument_list|,
name|g
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|refForAtom
name|QString
name|QDocDatabase
operator|::
name|refForAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Target
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
