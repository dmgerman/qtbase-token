begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"qdoctagfiles.h"
end_include
begin_include
include|#
directive|include
file|"qdocindexfiles.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|emptyNodeMap_
specifier|static
name|NodeMap
name|emptyNodeMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyNodeMultiMap_
specifier|static
name|NodeMultiMap
name|emptyNodeMultiMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|debug
name|bool
name|QDocDatabase
operator|::
name|debug
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*! \class QDocForest   This class manages a collection of trees. Each tree is an   instance of class Tree, which is a private class.    The forest is populated as each index file is loaded.   Each index file adds a tree to the forest. Each tree   is named with the name of the module it represents.    The search order is created by searchOrder(), if it has   not already been created. The search order and module   names arrays have parallel structure, i.e. modulNames_[i]   is the module name of the Tree at searchOrder_[i].  */
end_comment
begin_comment
comment|/*!   Destroys the qdoc forest. This requires deleting   each Tree in the forest. Note that the forest has   been transferred into the search order array, so   what is really being used to destroy the forest   is the search order array.  */
end_comment
begin_destructor
DECL|function|~QDocForest
name|QDocForest
operator|::
name|~
name|QDocForest
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|searchOrder_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|searchOrder_
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|searchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|indexSearchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleNames_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaryTree_
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Initializes the forest prior to a traversal and   returns a pointer to the root node of the primary   tree. If the forest is empty, it return 0  */
end_comment
begin_function
DECL|function|firstRoot
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|firstRoot
parameter_list|()
block|{
name|currentIndex_
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|!
name|searchOrder
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
literal|0
index|]
operator|->
name|root
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Increments the forest's current tree index. If the current   tree index is still within the forest, the function returns   the root node of the current tree. Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|nextRoot
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|nextRoot
parameter_list|()
block|{
operator|++
name|currentIndex_
expr_stmt|;
return|return
operator|(
name|currentIndex_
operator|<
name|searchOrder
argument_list|()
operator|.
name|size
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
name|currentIndex_
index|]
operator|->
name|root
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Initializes the forest prior to a traversal and   returns a pointer to the primary tree. If the   forest is empty, it returns 0.  */
end_comment
begin_function
DECL|function|firstTree
name|Tree
modifier|*
name|QDocForest
operator|::
name|firstTree
parameter_list|()
block|{
name|currentIndex_
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|!
name|searchOrder
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
literal|0
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Increments the forest's current tree index. If the current   tree index is still within the forest, the function returns   the pointer to the current tree. Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|nextTree
name|Tree
modifier|*
name|QDocForest
operator|::
name|nextTree
parameter_list|()
block|{
operator|++
name|currentIndex_
expr_stmt|;
return|return
operator|(
name|currentIndex_
operator|<
name|searchOrder
argument_list|()
operator|.
name|size
argument_list|()
condition|?
name|searchOrder
argument_list|()
index|[
name|currentIndex_
index|]
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn Tree* QDocForest::primaryTree()    Returns the pointer to the primary tree.  */
end_comment
begin_comment
comment|/*!   Finds the tree for module \a t in the forest and   sets the primary tree to be that tree. After the   primary tree is set, that tree is removed from the   forest.    \node It gets re-inserted into the forest after the   search order is built.  */
end_comment
begin_function
DECL|function|setPrimaryTree
name|void
name|QDocForest
operator|::
name|setPrimaryTree
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|QString
name|T
init|=
name|t
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|primaryTree_
operator|=
name|findTree
argument_list|(
name|T
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|remove
argument_list|(
name|T
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|primaryTree_
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"ERROR: Could not set primary tree to:"
operator|<<
name|t
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   If the search order array is empty, create the search order.   If the search order array is not empty, do nothing.  */
end_comment
begin_function
DECL|function|setSearchOrder
name|void
name|QDocForest
operator|::
name|setSearchOrder
parameter_list|(
name|QStringList
modifier|&
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|searchOrder_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|/* Allocate space for the search order. */
name|searchOrder_
operator|.
name|reserve
argument_list|(
name|forest_
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|searchOrder_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleNames_
operator|.
name|reserve
argument_list|(
name|forest_
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|/* The primary tree is always first in the search order. */
name|QString
name|primaryName
init|=
name|primaryTree
argument_list|()
operator|->
name|physicalModuleName
argument_list|()
decl_stmt|;
name|searchOrder_
operator|.
name|append
argument_list|(
name|primaryTree_
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
name|primaryName
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|remove
argument_list|(
name|primaryName
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Tree
modifier|*
argument_list|>
operator|::
name|iterator
name|i
decl_stmt|;
foreach|foreach
control|(
name|QString
name|m
decl|,
name|t
control|)
block|{
if|if
condition|(
name|primaryName
operator|!=
name|m
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|find
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*       If any trees remain in the forest, just add them       to the search order sequentially, because we don't       know any better at this point.      */
if|if
condition|(
operator|!
name|forest_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|i
operator|=
name|forest_
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|forest_
operator|.
name|end
argument_list|()
condition|)
block|{
name|searchOrder_
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|moduleNames_
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|forest_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*       Rebuild the forest after constructing the search order.       It was destroyed during construction of the search order,       but it is needed for module-specific searches.        Note that this loop also inserts the primary tree into the       forrest. That is a requirement.      */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|searchOrder_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|forest_
operator|.
name|contains
argument_list|(
name|moduleNames_
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|forest_
operator|.
name|insert
argument_list|(
name|moduleNames_
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|searchOrder_
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|qDebug()<< "    SEARCH ORDER:";     for (int i=0; i<moduleNames_.size(); ++i)         qDebug()<< "      "<< i+1<< "."<< moduleNames_.at(i);     qDebug()<< "    FOREST:"<< forest_.keys();     qDebug()<< "SEARCH ORDER:"<< moduleNames_;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Returns an ordered array of Tree pointers that represents   the order in which the trees should be searched. The first   Tree in the array is the tree for the current module, i.e.   the module for which qdoc is generating documentation.    The other Tree pointers in the array represent the index   files that were loaded in preparation for generating this   module's documentation. Each Tree pointer represents one   index file. The index file Tree points have been ordered   heuristically to, hopefully, minimize searching. Thr order   will probably be changed.    If the search order array is empty, this function calls   indexSearchOrder(). The search order array is empty while   the index files are being loaded, but some searches must   be performed during this time, notably searches for base   class nodes. These searches require a temporary search   order. The temporary order changes throughout the loading   of the index files, but it is always the tree for the   current index file first, followed by the trees for the   index files that have already been loaded. The only   ordering required in this temporary search order is that   the current tree must be searched first.  */
end_comment
begin_function
DECL|function|searchOrder
specifier|const
name|QVector
argument_list|<
name|Tree
modifier|*
argument_list|>
modifier|&
name|QDocForest
operator|::
name|searchOrder
parameter_list|()
block|{
if|if
condition|(
name|searchOrder_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|indexSearchOrder
argument_list|()
return|;
return|return
name|searchOrder_
return|;
block|}
end_function
begin_comment
comment|/*!   There are two search orders used by qdoc when searching for   things. The normal search order is returned by searchOrder(),   but this normal search order is not known until all the index   files have been read. At that point, setSearchOrder() is   called.    During the reading of the index files, the vector holding   the normal search order remains empty. Whenever the search   order is requested, if that vector is empty, this function   is called to return a temporary search order, which includes   all the index files that have been read so far, plus the   one being read now. That one is prepended to the front of   the vector.  */
end_comment
begin_function
DECL|function|indexSearchOrder
specifier|const
name|QVector
argument_list|<
name|Tree
modifier|*
argument_list|>
modifier|&
name|QDocForest
operator|::
name|indexSearchOrder
parameter_list|()
block|{
if|if
condition|(
name|forest_
operator|.
name|size
argument_list|()
operator|>
name|indexSearchOrder_
operator|.
name|size
argument_list|()
condition|)
name|indexSearchOrder_
operator|.
name|prepend
argument_list|(
name|primaryTree_
argument_list|)
expr_stmt|;
return|return
name|indexSearchOrder_
return|;
block|}
end_function
begin_comment
comment|/*!   Create a new Tree for the index file for the specified   \a module and add it to the forest. Return the pointer   to its root.  */
end_comment
begin_function
DECL|function|newIndexTree
name|NamespaceNode
modifier|*
name|QDocForest
operator|::
name|newIndexTree
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|)
block|{
name|primaryTree_
operator|=
operator|new
name|Tree
argument_list|(
name|module
argument_list|,
name|qdb_
argument_list|)
expr_stmt|;
name|forest_
operator|.
name|insert
argument_list|(
name|module
argument_list|,
name|primaryTree_
argument_list|)
expr_stmt|;
return|return
name|primaryTree_
operator|->
name|root
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Create a new Tree for use as the primary tree. This tree   will represent the primary module. \a module is camel case.  */
end_comment
begin_function
DECL|function|newPrimaryTree
name|void
name|QDocForest
operator|::
name|newPrimaryTree
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|)
block|{
name|primaryTree_
operator|=
operator|new
name|Tree
argument_list|(
name|module
argument_list|,
name|qdb_
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Searches through the forest for a node named \a targetPath   and returns a pointer to it if found. The \a relative node   is the starting point. It only makes sense for the primary   tree, which is searched first. After the primary tree has   been searched, \a relative is set to 0 for searching the   other trees, which are all index trees. With relative set   to 0, the starting point for each index tree is the root   of the index tree.  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|QDocForest
operator|::
name|findNodeForTarget
parameter_list|(
name|QStringList
modifier|&
name|targetPath
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
decl_stmt|;
name|QString
name|entity
init|=
name|targetPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|targetPath
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|QStringList
name|entityPath
init|=
name|entity
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|QString
name|target
decl_stmt|;
if|if
condition|(
operator|!
name|targetPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|target
operator|=
name|targetPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|targetPath
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|t
operator|->
name|findNodeForTarget
argument_list|(
name|entityPath
argument_list|,
name|target
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
name|relative
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Print the list of module names ordered according   to how many successful searches each tree had.  */
end_comment
begin_function
DECL|function|printLinkCounts
name|void
name|QDocForest
operator|::
name|printLinkCounts
parameter_list|(
specifier|const
name|QString
modifier|&
name|project
parameter_list|)
block|{
name|Location
operator|::
name|null
operator|.
name|report
argument_list|(
name|QString
argument_list|(
literal|"%1: Link Counts"
argument_list|)
operator|.
name|arg
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|m
decl_stmt|;
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|->
name|linkCount
argument_list|()
operator|<
literal|0
condition|)
name|m
operator|.
name|insert
argument_list|(
name|t
operator|->
name|linkCount
argument_list|()
argument_list|,
name|t
operator|->
name|physicalModuleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|depends
init|=
literal|"depends                 +="
decl_stmt|;
name|QString
name|module
init|=
name|project
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
operator|::
name|iterator
name|i
init|=
name|m
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|m
operator|.
name|end
argument_list|()
condition|)
block|{
name|QString
name|line
init|=
literal|"  "
operator|+
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|!=
name|module
condition|)
name|depends
operator|+=
literal|" "
operator|+
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
name|int
name|pad
init|=
literal|30
operator|-
name|line
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|pad
condition|;
operator|++
name|k
control|)
name|line
operator|+=
literal|" "
expr_stmt|;
name|line
operator|+=
literal|"%1"
expr_stmt|;
name|Location
operator|::
name|null
operator|.
name|report
argument_list|(
name|line
operator|.
name|arg
argument_list|(
operator|-
operator|(
name|i
operator|.
name|key
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|Location
operator|::
name|null
operator|.
name|report
argument_list|(
literal|"Optimal depends variable:"
argument_list|)
expr_stmt|;
name|Location
operator|::
name|null
operator|.
name|report
argument_list|(
name|depends
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Print the list of module names ordered according   to how many successful searches each tree had.  */
end_comment
begin_function
DECL|function|getLinkCounts
name|QString
name|QDocForest
operator|::
name|getLinkCounts
parameter_list|(
name|QStringList
modifier|&
name|strings
parameter_list|,
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|counts
parameter_list|)
block|{
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|m
decl_stmt|;
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|->
name|linkCount
argument_list|()
operator|<
literal|0
condition|)
name|m
operator|.
name|insert
argument_list|(
name|t
operator|->
name|linkCount
argument_list|()
argument_list|,
name|t
operator|->
name|physicalModuleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|depends
init|=
literal|"depends                 +="
decl_stmt|;
name|QString
name|module
init|=
name|Generator
operator|::
name|defaultModuleName
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
operator|::
name|iterator
name|i
init|=
name|m
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|m
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|!=
name|module
condition|)
block|{
name|counts
operator|.
name|append
argument_list|(
operator|-
operator|(
name|i
operator|.
name|key
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|strings
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|depends
operator|+=
literal|" "
operator|+
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
return|return
name|depends
return|;
block|}
end_function
begin_comment
comment|/*! \class QDocDatabase   This class provides exclusive access to the qdoc database,   which consists of a forrest of trees and a lot of maps and   other useful data structures.  */
end_comment
begin_decl_stmt
DECL|member|qdocDB_
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB_
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|typeNodeMap_
name|NodeMap
name|QDocDatabase
operator|::
name|typeNodeMap_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs the singleton qdoc database object. The singleton   constructs the \a forest_ object, which is also a singleton.   \a showInternal_ is normally false. If it is true, qdoc will   write documentation for nodes marked \c internal.    \a singleExec_ is false when qdoc is being used in the standard   way of running qdoc twices for each module, first with -prepare   and then with -generate. First the -prepare phase is run for   each module, then the -generate phase is run for each module.    When \a singleExec_ is true, qdoc is run only once. During the   single execution, qdoc processes the qdocconf files for all the   modules sequentially in a loop. Each source file for each module   is read exactly once.  */
end_comment
begin_constructor
DECL|function|QDocDatabase
name|QDocDatabase
operator|::
name|QDocDatabase
parameter_list|()
member_init_list|:
name|showInternal_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|singleExec_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|forest_
argument_list|(
name|this
argument_list|)
block|{
comment|// nothing
block|}
end_constructor
begin_comment
comment|/*!   Destroys the qdoc database object. This requires destroying   the forest object, which contains an array of tree pointers.   Each tree is deleted.  */
end_comment
begin_destructor
DECL|function|~QDocDatabase
name|QDocDatabase
operator|::
name|~
name|QDocDatabase
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Creates the singleton. Allows only one instance of the class   to be created. Returns a pointer to the singleton. */
end_comment
begin_function
DECL|function|qdocDB
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdocDB_
condition|)
block|{
name|qdocDB_
operator|=
operator|new
name|QDocDatabase
expr_stmt|;
name|initializeDB
argument_list|()
expr_stmt|;
block|}
return|return
name|qdocDB_
return|;
block|}
end_function
begin_comment
comment|/*!   Destroys the singleton.  */
end_comment
begin_function
DECL|function|destroyQdocDB
name|void
name|QDocDatabase
operator|::
name|destroyQdocDB
parameter_list|()
block|{
if|if
condition|(
name|qdocDB_
condition|)
block|{
operator|delete
name|qdocDB_
expr_stmt|;
name|qdocDB_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Initialize data structures in the singleton qdoc database.    In particular, the type node map is initialized with a lot   type names that don't refer to documented types. For example,   the C++ standard types are included. These might be documented   here at some point, but for now they are not. Other examples   include \c array and \c data, which are just generic names   used as place holders in function signatures that appear in   the documentation.    Also calls Node::initialize() to initialize the search goal map.  */
end_comment
begin_function
DECL|function|initializeDB
name|void
name|QDocDatabase
operator|::
name|initializeDB
parameter_list|()
block|{
name|Node
operator|::
name|initialize
argument_list|()
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"accepted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"actionPerformed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"activated"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"alias"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"anchors"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"any"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"array"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"autoSearch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"axis"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"backClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"bool"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"boomTime"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"border"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"buttonClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"callback"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"char"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"clicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"close"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"closed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"color"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"cond"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dataReady"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dateString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"dateTimeString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"datetime"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"day"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"deactivated"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"double"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"drag"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"easing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"enumeration"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"error"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"exposure"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"fatalError"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"fileSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"flags"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"float"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"focus"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"focusZone"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"format"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"framePainted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"from"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"frontClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"function"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hasOpened"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hovered"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hoveredTitle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"hoveredUrl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"imageCapture"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"imageProcessing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"index"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"initialized"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"int"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"isLoaded"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"item"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"jsdict"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"jsobject"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"key"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"keysequence"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"listViewClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"loadRequest"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"locale"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"location"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"long"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"messageReceived"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"mode"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"month"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"number"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"object"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"offset"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"ok"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openCamera"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openImage"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"openVideo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"padding"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"parent"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"path"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"photoModeSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"position"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"precision"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"presetClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"preview"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"previewSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"progress"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"puzzleLost"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"qmlSignal"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"real"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"rectangle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"request"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"requestId"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"section"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"selected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"send"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"settingsClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"shoe"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"short"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"signed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sizeChanged"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"size_t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sockaddr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"someOtherSignal"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"sourceSize"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"startButtonClicked"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"state"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::initializer_list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::map"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::pair"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::string"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"std::vector"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"string"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"stringlist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"swapPlayers"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"symbol"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"T"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"tagChanged"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"timeString"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"timeout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"to"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"toggled"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"type"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"unsigned"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"urllist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"va_list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"value"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"valueEmitted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoFramePainted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoModeSelected"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"videoRecorder"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"void"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"volatile"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"wchar_t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"y"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"zoom"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typeNodeMap_
operator|.
name|insert
argument_list|(
literal|"zoomTo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn NamespaceNode* QDocDatabase::primaryTreeRoot()   Returns a pointer to the root node of the primary tree.  */
end_comment
begin_comment
comment|/*!   \fn const CNMap& QDocDatabase::groups()   Returns a const reference to the collection of all   group nodes in the primary tree. */
end_comment
begin_comment
comment|/*!   \fn const CNMap& QDocDatabase::modules()   Returns a const reference to the collection of all   module nodes in the primary tree. */
end_comment
begin_comment
comment|/*!   \fn const CNMap& QDocDatabase::qmlModules()   Returns a const reference to the collection of all   QML module nodes in the primary tree. */
end_comment
begin_comment
comment|/*!   \fn const CNMap& QDocDatabase::jsModules()   Returns a const reference to the collection of all   JovaScript module nodes in the primary tree. */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::findGroup(const QString& name)   Find the group node named \a name and return a pointer   to it. If a matching node is not found, add a new group   node named \a name and return a pointer to that one.    If a new group node is added, its parent is the tree root,   and the new group node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::findModule(const QString& name)   Find the module node named \a name and return a pointer   to it. If a matching node is not found, add a new module   node named \a name and return a pointer to that one.    If a new module node is added, its parent is the tree root,   and the new module node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::findQmlModule(const QString& name, bool javaScript)   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, add a new QML module   node named \a name and return a pointer to that one.    If \a javaScript is set, the return collection must be a   JavaScript module.    If a new QML or JavaScript module node is added, its parent   is the tree root, and the new node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addGroup(const QString& name)   Looks up the group named \a name in the primary tree. If   a match is found, a pointer to the node is returned.   Otherwise, a new group node named \a name is created and   inserted into the collection, and the pointer to that node   is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addModule(const QString& name)   Looks up the module named \a name in the primary tree. If   a match is found, a pointer to the node is returned.   Otherwise, a new module node named \a name is created and   inserted into the collection, and the pointer to that node   is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addQmlModule(const QString& name)   Looks up the QML module named \a name in the primary tree.   If a match is found, a pointer to the node is returned.   Otherwise, a new QML module node named \a name is created   and inserted into the collection, and the pointer to that   node is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addJsModule(const QString& name)   Looks up the JavaScript module named \a name in the primary   tree. If a match is found, a pointer to the node is returned.   Otherwise, a new JavaScript module node named \a name is   created and inserted into the collection, and the pointer to   that node is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addToGroup(const QString& name, Node* node)   Looks up the group node named \a name in the collection   of all group nodes. If a match is not found, a new group   node named \a name is created and inserted into the collection.   Then append \a node to the group's members list, and append the   group node to the member list of the \a node. The parent of the   \a node is not changed by this function. Returns a pointer to   the group node.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* QDocDatabase::addToModule(const QString& name, Node* node)   Looks up the module node named \a name in the collection   of all module nodes. If a match is not found, a new module   node named \a name is created and inserted into the collection.   Then append \a node to the module's members list. The parent of   \a node is not changed by this function. Returns the module node.  */
end_comment
begin_comment
comment|/*! \fn Collection* QDocDatabase::addToQmlModule(const QString& name, Node* node)   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.  */
end_comment
begin_comment
comment|/*! \fn Collection* QDocDatabase::addToJsModule(const QString& name, Node* node)   Looks up the JavaScript module named \a name. If it isn't there,   create it. Then append \a node to the JavaScript module's member   list. The parent of \a node is not changed by this function.  */
end_comment
begin_comment
comment|/*!   Looks up the QML type node identified by the qualified Qml   type \a name and returns a pointer to the QML type node.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlTypeNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   \a qmid and QML type \a name and returns a pointer to the   QML type node. The key is \a qmid + "::" + \a name.    If the QML module id is empty, it looks up the QML type by   \a name only.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlTypeNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|qmid
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qmid
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|t
init|=
name|qmid
operator|+
literal|"::"
operator|+
name|name
decl_stmt|;
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
name|QStringList
name|path
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|forest_
operator|.
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   constructed from the strings in the \a import record and the   QML type \a name and returns a pointer to the QML type node.   If a QML type node is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlTypeNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|ImportRec
modifier|&
name|import
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|import
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|dotSplit
decl_stmt|;
name|dotSplit
operator|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|qmName
decl_stmt|;
if|if
condition|(
name|import
operator|.
name|importUri_
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmName
operator|=
name|import
operator|.
name|name_
expr_stmt|;
else|else
name|qmName
operator|=
name|import
operator|.
name|importUri_
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dotSplit
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|qualifiedName
init|=
name|qmName
operator|+
literal|"::"
operator|+
name|dotSplit
index|[
name|i
index|]
decl_stmt|;
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|forest_
operator|.
name|lookupQmlType
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function calls a set of functions for each tree in the   forest that has not already been analyzed. In this way, when   running qdoc in \e singleExec mode, each tree is analyzed in   turn, and its classes and types are added to the appropriate   node maps.  */
end_comment
begin_function
DECL|function|processForest
name|void
name|QDocDatabase
operator|::
name|processForest
parameter_list|()
block|{
name|Tree
modifier|*
name|t
init|=
name|forest_
operator|.
name|firstTree
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|findAllClasses
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllFunctions
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllObsoleteThings
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllLegaleseTexts
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllSince
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|->
name|setTreeHasBeenAnalyzed
argument_list|()
expr_stmt|;
name|t
operator|=
name|forest_
operator|.
name|nextTree
argument_list|()
expr_stmt|;
block|}
name|resolveNamespaces
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function calls \a func for each tree in the forest,   but only if Tree::treeHasBeenAnalyzed() returns false for   the tree. In this way, when running qdoc in \e singleExec   mode, each tree is analyzed in turn, and its classes and   types are added to the appropriate node maps.  */
end_comment
begin_function
DECL|function|processForest
name|void
name|QDocDatabase
operator|::
name|processForest
parameter_list|(
name|void
function_decl|(
name|QDocDatabase
operator|::
modifier|*
name|func
function_decl|)
parameter_list|(
name|InnerNode
modifier|*
parameter_list|)
parameter_list|)
block|{
name|Tree
modifier|*
name|t
init|=
name|forest_
operator|.
name|firstTree
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|treeHasBeenAnalyzed
argument_list|()
condition|)
block|{
operator|(
name|this
operator|->*
operator|(
name|func
operator|)
operator|)
operator|(
name|t
operator|->
name|root
argument_list|()
operator|)
expr_stmt|;
block|}
name|t
operator|=
name|forest_
operator|.
name|nextTree
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Constructs the collection of legalese texts, if it has not   already been constructed and returns a reference to it.  */
end_comment
begin_function
DECL|function|getLegaleseTexts
name|TextToNodeMap
modifier|&
name|QDocDatabase
operator|::
name|getLegaleseTexts
parameter_list|()
block|{
if|if
condition|(
name|legaleseTexts_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
argument_list|)
expr_stmt|;
return|return
name|legaleseTexts_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of C++ classes with obsolete members.  */
end_comment
begin_function
DECL|function|getClassesWithObsoleteMembers
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getClassesWithObsoleteMembers
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|classesWithObsoleteMembers_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of obsolete QML types.  */
end_comment
begin_function
DECL|function|getObsoleteQmlTypes
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getObsoleteQmlTypes
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|obsoleteQmlTypes_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of QML types with obsolete members.  */
end_comment
begin_function
DECL|function|getQmlTypesWithObsoleteMembers
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypesWithObsoleteMembers
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|qmlTypesWithObsoleteMembers_
return|;
block|}
end_function
begin_comment
comment|/*! \fn NodeMultiMap& QDocDatabase::getNamespaces()   Returns a reference to the map of all namespace nodes.   This function must not be called in the -prepare phase.  */
end_comment
begin_comment
comment|/*!   Construct the data structures for QML basic types, if they   have not already been constructed. Returns a reference to   the map of QML basic types.  */
end_comment
begin_function
DECL|function|getQmlBasicTypes
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlBasicTypes
parameter_list|()
block|{
if|if
condition|(
name|cppClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlBasicTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|qmlBasicTypes_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the multimap of QML types.  */
end_comment
begin_function
DECL|function|getQmlTypes
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypes
parameter_list|()
block|{
if|if
condition|(
name|cppClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|qmlTypes_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the data structures for obsolete things, if they   have not already been constructed. Returns a reference to   the map of obsolete C++ clases.  */
end_comment
begin_function
DECL|function|getObsoleteClasses
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getObsoleteClasses
parameter_list|()
block|{
if|if
condition|(
name|obsoleteClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|obsoleteQmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllObsoleteThings
argument_list|)
expr_stmt|;
return|return
name|obsoleteClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the C++ class data structures, if they have not   already been constructed. Returns a reference to the map   of all C++ classes.  */
end_comment
begin_function
DECL|function|getCppClasses
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getCppClasses
parameter_list|()
block|{
if|if
condition|(
name|cppClasses_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qmlTypes_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllClasses
argument_list|)
expr_stmt|;
return|return
name|cppClasses_
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the C++ class nodes and QML type nodes and   sorts them into maps.  */
end_comment
begin_function
DECL|function|findAllClasses
name|void
name|QDocDatabase
operator|::
name|findAllClasses
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|isInternal
argument_list|()
operator|||
name|showInternal_
operator|)
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|tree
argument_list|()
operator|->
name|camelCaseModuleName
argument_list|()
operator|!=
name|QString
argument_list|(
literal|"QDoc"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|className
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
name|cppClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlBasicType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isJsType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isJsBasicType
argument_list|()
operator|)
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|qmlTypeName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|qmlTypeName
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|qmlTypes_
operator|.
name|insert
argument_list|(
name|qmlTypeName
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
else|else
name|qmlTypes_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
comment|//also add to the QML basic type map
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlBasicType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isJsType
argument_list|()
condition|)
name|qmlBasicTypes_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllClasses
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Construct the function index data structure and return it.   This data structure is used to output the function index page.  */
end_comment
begin_function
DECL|function|getFunctionIndex
name|NodeMapMap
modifier|&
name|QDocDatabase
operator|::
name|getFunctionIndex
parameter_list|()
block|{
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllFunctions
argument_list|)
expr_stmt|;
return|return
name|funcIndex_
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the function nodes  */
end_comment
begin_function
DECL|function|findAllFunctions
name|void
name|QDocDatabase
operator|::
name|findAllFunctions
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllFunctions
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|!
name|func
operator|->
name|isInternal
argument_list|()
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|funcIndex_
index|[
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes containing legalese text and puts them   in a map.  */
end_comment
begin_function
DECL|function|findAllLegaleseTexts
name|void
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|legaleseTexts_
operator|.
name|insertMulti
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllLegaleseTexts
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the namespace nodes and puts them in an index.  */
end_comment
begin_function
DECL|function|findAllNamespaces
name|void
name|QDocDatabase
operator|::
name|findAllNamespaces
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllNamespaces
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
block|{
comment|// Ensure that the namespace's name is not empty (the root
comment|// namespace has no name).
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nmm_
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all nodes with status = Obsolete and sorts them into   maps. They can be C++ classes, QML types, or they can be   functions, enum types, typedefs, methods, etc.  */
end_comment
begin_function
DECL|function|findAllObsoleteThings
name|void
name|QDocDatabase
operator|::
name|findAllObsoleteThings
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|QString
name|name
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteClasses_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isJsType
argument_list|()
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|logicalModuleName
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteQmlTypes_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
case|case
name|Node
operator|::
name|Variable
case|:
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|classesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isQmlType
argument_list|()
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|isJsType
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|QmlSignal
case|:
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
case|case
name|Node
operator|::
name|QmlMethod
case|:
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|parent
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|parent
operator|->
name|isQmlPropertyGroup
argument_list|()
operator|||
name|parent
operator|->
name|isJsPropertyGroup
argument_list|()
operator|)
operator|&&
name|parent
operator|->
name|parent
argument_list|()
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
operator|(
name|parent
operator|->
name|isQmlType
argument_list|()
operator|||
name|parent
operator|->
name|isJsType
argument_list|()
operator|)
operator|&&
operator|!
name|parent
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
name|parent
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|qmlTypesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllObsoleteThings
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes where a \e{since} command appeared in the   qdoc comment and sorts them into maps according to the kind of   node.    This function is used for generating the "New Classes... in x.y"   section on the \e{What's New in Qt x.y} page.  */
end_comment
begin_function
DECL|function|findAllSince
name|void
name|QDocDatabase
operator|::
name|findAllSince
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|child
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|child
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|sinceString
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|since
argument_list|()
decl_stmt|;
comment|// Insert a new entry into each map for each new since string found.
if|if
condition|(
operator|(
operator|(
operator|*
name|child
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
operator|&&
operator|!
name|sinceString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMultiMapMap
operator|::
name|iterator
name|nsmap
init|=
name|newSinceMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsmap
operator|==
name|newSinceMaps_
operator|.
name|end
argument_list|()
condition|)
name|nsmap
operator|=
name|newSinceMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|ncmap
init|=
name|newClassMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncmap
operator|==
name|newClassMaps_
operator|.
name|end
argument_list|()
condition|)
name|ncmap
operator|=
name|newClassMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|nqcmap
init|=
name|newQmlTypeMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nqcmap
operator|==
name|newQmlTypeMaps_
operator|.
name|end
argument_list|()
condition|)
name|nqcmap
operator|=
name|newQmlTypeMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
comment|// Insert functions into the general since map.
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
comment|// Insert classes into the since and class maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|ncmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isQmlType
argument_list|()
operator|||
operator|(
operator|*
name|child
operator|)
operator|->
name|isJsType
argument_list|()
condition|)
block|{
comment|// Insert QML elements into the since and element maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|nqcmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isQmlProperty
argument_list|()
operator|||
operator|(
operator|*
name|child
operator|)
operator|->
name|isJsProperty
argument_list|()
condition|)
block|{
comment|// Insert QML properties into the since map.
name|QString
name|propertyName
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|propertyName
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert external documents into the general since map.
name|QString
name|name
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Recursively find child nodes with since commands.
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllSince
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|child
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new class maps, and return a   reference to the value, which is a NodeMap. If \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getClassMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getClassMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newClassMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newClassMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new QML type maps, and return a   reference to the value, which is a NodeMap. If the \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getQmlTypeMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypeMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newQmlTypeMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newQmlTypeMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new \e {since} maps, and return   a reference to the value, which is a NodeMultiMap. If \a key   is not found, return a reference to an empty NodeMultiMap.  */
end_comment
begin_function
DECL|function|getSinceMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getSinceMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|newSinceMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newClassMaps_
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newQmlTypeMaps_
operator|.
name|isEmpty
argument_list|()
condition|)
name|processForest
argument_list|(
operator|&
name|QDocDatabase
operator|::
name|findAllSince
argument_list|)
expr_stmt|;
name|NodeMultiMapMap
operator|::
name|const_iterator
name|i
init|=
name|newSinceMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newSinceMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMultiMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Performs several housekeeping algorithms that create   certain data structures and resolve lots of links, prior   to generating documentation.  */
end_comment
begin_function
DECL|function|resolveIssues
name|void
name|QDocDatabase
operator|::
name|resolveIssues
parameter_list|()
block|{
name|resolveQmlInheritance
argument_list|(
name|primaryTreeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|primaryTree
argument_list|()
operator|->
name|resolveTargets
argument_list|(
name|primaryTreeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|primaryTree
argument_list|()
operator|->
name|resolveCppToQmlLinks
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveStuff
name|void
name|QDocDatabase
operator|::
name|resolveStuff
parameter_list|()
block|{
name|primaryTree
argument_list|()
operator|->
name|resolveInheritance
argument_list|()
expr_stmt|;
name|resolveQmlInheritance
argument_list|(
name|primaryTreeRoot
argument_list|()
argument_list|)
expr_stmt|;
comment|//primaryTree()->resolveTargets(primaryTreeRoot());
name|primaryTree
argument_list|()
operator|->
name|resolveCppToQmlLinks
argument_list|()
expr_stmt|;
name|primaryTree
argument_list|()
operator|->
name|resolveUsingClauses
argument_list|()
expr_stmt|;
name|resolveNamespaces
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveNamespaces
name|void
name|QDocDatabase
operator|::
name|resolveNamespaces
parameter_list|()
block|{
if|if
condition|(
operator|!
name|namespaceIndex_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|Tree
modifier|*
name|t
init|=
name|forest_
operator|.
name|firstTree
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|findAllNamespaces
argument_list|(
name|t
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|=
name|forest_
operator|.
name|nextTree
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|QString
argument_list|>
name|keys
init|=
name|nmm_
operator|.
name|uniqueKeys
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QString
name|s
decl|,
name|keys
control|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|nodes
init|=
name|nmm_
operator|.
name|values
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|nmm_
operator|.
name|remove
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|n
decl|,
name|nodes
control|)
block|{
if|if
condition|(
name|n
operator|->
name|isNamespace
argument_list|()
operator|&&
name|n
operator|->
name|wasSeen
argument_list|()
condition|)
block|{
name|ns
operator|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|ns
operator|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|nodes
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|&&
name|ns
operator|->
name|wasSeen
argument_list|()
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|n
decl|,
name|nodes
control|)
block|{
if|if
condition|(
name|n
operator|->
name|isNamespace
argument_list|()
condition|)
block|{
name|NamespaceNode
modifier|*
name|NS
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|NS
operator|!=
name|ns
condition|)
block|{
while|while
condition|(
operator|!
name|NS
operator|->
name|childNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|child
init|=
name|NS
operator|->
name|childNodes
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|NS
operator|->
name|removeChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ns
operator|->
name|addChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|namespaceIndex_
operator|.
name|insert
argument_list|(
name|ns
operator|->
name|name
argument_list|()
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function is called for autolinking to a \a type,   which could be a function return type or a parameter   type. The tree node that represents the \a type is   returned. All the trees are searched until a match is   found. When searching the primary tree, the search   begins at \a relative and proceeds up the parent chain.   When searching the index trees, the search begins at the   root.  */
end_comment
begin_function
DECL|function|findTypeNode
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findTypeNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QStringList
name|path
init|=
name|type
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
index|[
literal|0
index|]
operator|.
name|isLower
argument_list|()
operator|||
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QString
argument_list|(
literal|"T"
argument_list|)
operator|)
condition|)
block|{
name|NodeMap
operator|::
name|iterator
name|i
init|=
name|typeNodeMap_
operator|.
name|find
argument_list|(
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|typeNodeMap_
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|forest_
operator|.
name|findTypeNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the node that will generate the documentation that   contains the \a target and returns a pointer to it.    Can this be improved by using the target map in Tree?  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|node
operator|=
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|target
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
else|else
block|{
name|QStringList
name|path
init|=
name|target
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
decl_stmt|;
comment|// | NonFunction;
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|t
operator|->
name|findNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|,
name|Node
operator|::
name|DontCare
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
name|relative
operator|=
literal|0
expr_stmt|;
block|}
name|node
operator|=
name|findDocumentNodeByTitle
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   For each QML Type node in the tree beginning at \a root,   if it has a QML base type name but its QML base type node   pointer is 0, use the QML base type name to look up the   base type node. If the node is found in the tree, set the   node's QML base type node pointer.  */
end_comment
begin_function
DECL|function|resolveQmlInheritance
name|void
name|QDocDatabase
operator|::
name|resolveQmlInheritance
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
name|NodeMap
name|previousSearches
decl_stmt|;
comment|// Do we need recursion?
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|isQmlType
argument_list|()
operator|||
name|child
operator|->
name|isJsType
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
operator|->
name|qmlBaseNodeNotSet
argument_list|()
operator|&&
operator|!
name|qcn
operator|->
name|qmlBaseName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|bqcn
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|previousSearches
operator|.
name|value
argument_list|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bqcn
condition|)
name|qcn
operator|->
name|setQmlBaseNode
argument_list|(
name|bqcn
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|qcn
operator|->
name|importList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ImportList
modifier|&
name|imports
init|=
name|qcn
operator|->
name|importList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|imports
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|imports
index|[
name|i
index|]
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bqcn
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|bqcn
operator|==
literal|0
condition|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|QString
argument_list|()
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bqcn
condition|)
block|{
name|qcn
operator|->
name|setQmlBaseNode
argument_list|(
name|bqcn
argument_list|)
expr_stmt|;
name|previousSearches
operator|.
name|insert
argument_list|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|,
name|bqcn
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {                         qDebug()<< "Temporary error message (ignore): UNABLE to resolve QML base type:"<< qcn->qmlBaseName()<< "for QML type:"<< qcn->name();                     }
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Generates a tag file and writes it to \a name.  */
end_comment
begin_function
DECL|function|generateTagFile
name|void
name|QDocDatabase
operator|::
name|generateTagFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDocTagFiles
operator|::
name|qdocTagFiles
argument_list|()
operator|->
name|generateTagFile
argument_list|(
name|name
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|QDocTagFiles
operator|::
name|destroyQDocTagFiles
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the qdoc index files listed in \a t.  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|QDocDatabase
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|t
parameter_list|)
block|{
name|QStringList
name|indexFiles
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|f
decl|,
name|t
control|)
block|{
name|QString
name|fn
init|=
name|f
operator|.
name|mid
argument_list|(
name|f
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isLoaded
argument_list|(
name|fn
argument_list|)
condition|)
name|indexFiles
operator|<<
name|f
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"This index file is already in memory:"
operator|<<
name|f
expr_stmt|;
block|}
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|readIndexes
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates a qdoc index file and write it to \a fileName. The   index file is generated with the parameters \a url, \a title,   \a g, and \a generateInternalNodes.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|QDocDatabase
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QString
name|t
init|=
name|fileName
operator|.
name|mid
argument_list|(
name|fileName
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|primaryTree
argument_list|()
operator|->
name|setIndexFileName
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|generateIndex
argument_list|(
name|fileName
argument_list|,
name|url
argument_list|,
name|title
argument_list|,
name|g
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   If there are open namespaces, search for the function node   having the same function name as the \a clone node in each   open namespace. The \a parentPath is a portion of the path   name provided with the function name at the point of   reference. \a parentPath is usually a class name. Return   the pointer to the function node if one is found in an   open namespace. Otherwise return 0.    This open namespace concept is of dubious value and might   be removed.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|FunctionNode
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|path
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|parentPath
decl_stmt|;
name|fn
operator|=
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
break|break;
block|}
block|}
return|return
name|fn
return|;
block|}
end_function
begin_comment
comment|/*!   Find a node of the specified \a type that is reached with   the specified \a path qualified with the name of one of the   open namespaces (might not be any open ones). If the node   is found in an open namespace, prefix \a path with the name   of the open namespace and "::" and return a pointer to the   node. Othewrwise return 0.    This function only searches in the current primary tree.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|Node
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|path
index|[
literal|0
index|]
condition|)
name|p
operator|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|path
expr_stmt|;
else|else
name|p
operator|=
name|path
expr_stmt|;
name|n
operator|=
name|primaryTree
argument_list|()
operator|->
name|findNodeByNameAndType
argument_list|(
name|p
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|path
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!   Finds all the collection nodes of the specified \a genus   into the collection node map \a cnm. Nodes that match the   \a relative node are not included.  */
end_comment
begin_function
DECL|function|mergeCollections
name|void
name|QDocDatabase
operator|::
name|mergeCollections
parameter_list|(
name|Node
operator|::
name|Genus
name|genus
parameter_list|,
name|CNMap
modifier|&
name|cnm
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|cnm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|CNMultiMap
name|cnmm
decl_stmt|;
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
name|CNMap
modifier|*
name|m
init|=
name|t
operator|->
name|getCollectionMap
argument_list|(
name|genus
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|&&
operator|!
name|m
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|m
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|m
operator|->
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|value
argument_list|()
operator|->
name|isInternal
argument_list|()
condition|)
name|cnmm
operator|.
name|insert
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cnmm
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QRegExp
name|singleDigit
argument_list|(
literal|"\\b([0-9])\\b"
argument_list|)
decl_stmt|;
name|QStringList
name|keys
init|=
name|cnmm
operator|.
name|uniqueKeys
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|key
decl|,
name|keys
control|)
block|{
name|QList
argument_list|<
name|CollectionNode
modifier|*
argument_list|>
name|values
init|=
name|cnmm
operator|.
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|CollectionNode
modifier|*
name|n
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|v
decl|,
name|values
control|)
block|{
if|if
condition|(
name|v
operator|&&
name|v
operator|->
name|wasSeen
argument_list|()
operator|&&
operator|(
name|v
operator|!=
name|relative
operator|)
condition|)
block|{
name|n
operator|=
name|v
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|v
decl|,
name|values
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|n
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|t
decl|,
name|v
operator|->
name|members
argument_list|()
control|)
name|n
operator|->
name|addMember
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|n
operator|->
name|members
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|sortKey
init|=
name|n
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
name|cnm
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the collection nodes with the same name   and genus as \a c and merges their members into the   members list of \a c.  */
end_comment
begin_function
DECL|function|mergeCollections
name|void
name|QDocDatabase
operator|::
name|mergeCollections
parameter_list|(
name|CollectionNode
modifier|*
name|c
parameter_list|)
block|{
foreach|foreach
control|(
name|Tree
modifier|*
name|t
decl|,
name|searchOrder
argument_list|()
control|)
block|{
name|CollectionNode
modifier|*
name|cn
init|=
name|t
operator|->
name|getCollection
argument_list|(
name|c
operator|->
name|name
argument_list|()
argument_list|,
name|c
operator|->
name|genus
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|!=
name|c
condition|)
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|n
decl|,
name|cn
operator|->
name|members
argument_list|()
control|)
name|c
operator|->
name|addMember
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Searches for the node that matches the path in \a atom. The   \a relative node is used if the first leg of the path is   empty, i.e. if the path begins with a hashtag. The function   also sets \a ref if there remains an unused leg in the path   after the node is found. The node is returned as well as the   \a ref. If the returned node pointer is null, \a ref is not   valid.  */
end_comment
begin_function
DECL|function|findNodeForAtom
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeForAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|a
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|Atom
modifier|*
name|atom
init|=
cast|const_cast
argument_list|<
name|Atom
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|QStringList
name|targetPath
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|QString
name|first
init|=
name|targetPath
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|Tree
modifier|*
name|domain
init|=
literal|0
decl_stmt|;
name|Node
operator|::
name|Genus
name|genus
init|=
name|Node
operator|::
name|DontCare
decl_stmt|;
comment|// Reserved for future use
comment|//Node::Type goal = Node::NoType;
if|if
condition|(
name|atom
operator|->
name|isLinkAtom
argument_list|()
condition|)
block|{
name|domain
operator|=
name|atom
operator|->
name|domain
argument_list|()
expr_stmt|;
name|genus
operator|=
name|atom
operator|->
name|genus
argument_list|()
expr_stmt|;
comment|// Reserved for future use
comment|//goal = atom->goal();
block|}
if|if
condition|(
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
comment|// search for a target on the current page.
elseif|else
if|if
condition|(
name|domain
condition|)
block|{
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|node
operator|=
name|domain
operator|->
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|first
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
name|node
operator|=
name|domain
operator|->
name|findFunctionNode
argument_list|(
name|first
argument_list|,
literal|0
argument_list|,
name|genus
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
decl_stmt|;
name|QStringList
name|nodePath
init|=
name|first
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|QString
name|target
decl_stmt|;
name|targetPath
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|targetPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|target
operator|=
name|targetPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|targetPath
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|relative
operator|&&
name|relative
operator|->
name|tree
argument_list|()
operator|->
name|physicalModuleName
argument_list|()
operator|!=
name|domain
operator|->
name|physicalModuleName
argument_list|()
condition|)
name|relative
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|domain
operator|->
name|findNodeForTarget
argument_list|(
name|nodePath
argument_list|,
name|target
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
name|node
operator|=
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|first
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
comment|// the path may also refer to an example file with .html extension
if|if
condition|(
operator|!
name|node
operator|&&
name|first
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
condition|)
return|return
name|findNodeForTarget
argument_list|(
name|targetPath
argument_list|,
name|relative
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
name|node
operator|=
name|findFunctionNode
argument_list|(
name|first
argument_list|,
name|relative
argument_list|,
name|genus
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|=
name|findNodeForTarget
argument_list|(
name|targetPath
argument_list|,
name|relative
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
if|if
condition|(
name|node
operator|&&
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
return|;
name|targetPath
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|targetPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|node
operator|->
name|root
argument_list|()
operator|->
name|tree
argument_list|()
operator|->
name|getRef
argument_list|(
name|targetPath
operator|.
name|first
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
