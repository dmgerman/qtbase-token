begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"qdoctagfiles.h"
end_include
begin_include
include|#
directive|include
file|"qdocindexfiles.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|emptyNodeMap_
specifier|static
name|NodeMap
name|emptyNodeMap_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyNodeMultiMap_
specifier|static
name|NodeMultiMap
name|emptyNodeMultiMap_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*! \class QDocDatabase  */
end_comment
begin_decl_stmt
DECL|member|qdocDB_
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB_
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs the singleton qdoc database object.   It constructs a singleton Tree object with this   qdoc database pointer.  */
end_comment
begin_constructor
DECL|function|QDocDatabase
name|QDocDatabase
operator|::
name|QDocDatabase
parameter_list|()
block|{
name|tree_
operator|=
operator|new
name|Tree
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the qdoc database object. This requires deleting   the tree of nodes, which deletes each node.  */
end_comment
begin_destructor
DECL|function|~QDocDatabase
name|QDocDatabase
operator|::
name|~
name|QDocDatabase
parameter_list|()
block|{
name|masterMap_
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|tree_
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \fn Tree* QDocDatabase::tree()   Returns the pointer to the tree. This function is for compatibility   with the current qdoc. It will be removed when the QDocDatabase class   replaces the current structures.  */
end_comment
begin_comment
comment|/*!   Creates the singleton. Allows only one instance of the class   to be created. Returns a pointer to the singleton. */
end_comment
begin_function
DECL|function|qdocDB
name|QDocDatabase
modifier|*
name|QDocDatabase
operator|::
name|qdocDB
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdocDB_
condition|)
name|qdocDB_
operator|=
operator|new
name|QDocDatabase
expr_stmt|;
return|return
name|qdocDB_
return|;
block|}
end_function
begin_comment
comment|/*!   Destroys the singleton.  */
end_comment
begin_function
DECL|function|destroyQdocDB
name|void
name|QDocDatabase
operator|::
name|destroyQdocDB
parameter_list|()
block|{
if|if
condition|(
name|qdocDB_
condition|)
block|{
operator|delete
name|qdocDB_
expr_stmt|;
name|qdocDB_
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \fn const DocNodeMap& QDocDatabase::groups() const   Returns a const reference to the collection of all   group nodes. */
end_comment
begin_comment
comment|/*!   \fn const DocNodeMap& QDocDatabase::modules() const   Returns a const reference to the collection of all   module nodes. */
end_comment
begin_comment
comment|/*!   \fn const DocNodeMap& QDocDatabase::qmlModules() const   Returns a const reference to the collection of all   QML module nodes. */
end_comment
begin_comment
comment|/*!   Find the group node named \a name and return a pointer   to it. If a matching node is not found, return 0.  */
end_comment
begin_function
DECL|function|getGroup
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|getGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|groups_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|groups_
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the group node named \a name and return a pointer   to it. If a matching node is not found, add a new group   node named \a name and return a pointer to that one.    If a new group node is added, its parent is the tree root,   and the new group node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findGroup
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|groups_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|groups_
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|Group
argument_list|,
name|Node
operator|::
name|OverviewPage
argument_list|)
decl_stmt|;
name|dn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|groups_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the module node named \a name and return a pointer   to it. If a matching node is not found, add a new module   node named \a name and return a pointer to that one.    If a new module node is added, its parent is the tree root,   and the new module node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
name|DocNode
modifier|*
name|dn
init|=
operator|new
name|DocNode
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|Module
argument_list|,
name|Node
operator|::
name|OverviewPage
argument_list|)
decl_stmt|;
name|dn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|modules_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, add a new QML module   node named \a name and return a pointer to that one.    If a new QML module node is added, its parent is the tree root,   and the new QML module node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findQmlModule
name|QmlModuleNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|qmlModules_
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlModuleNode
operator|*
argument_list|>
argument_list|(
name|qmlModules_
operator|.
name|value
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
name|QmlModuleNode
modifier|*
name|qmn
init|=
operator|new
name|QmlModuleNode
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|qmn
operator|->
name|setQmlModuleInfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|qmlModules_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|qmn
argument_list|)
expr_stmt|;
name|masterMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|qmn
argument_list|)
expr_stmt|;
return|return
name|qmn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the group node named \a name in the collection   of all group nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new group node named \a name   is created and inserted into the collection, and the pointer   to that node is returned. The group node is marked \e{seen}   in either case.  */
end_comment
begin_function
DECL|function|addGroup
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|DocNode
modifier|*
name|group
init|=
name|findGroup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|group
operator|->
name|markSeen
argument_list|()
expr_stmt|;
return|return
name|group
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned. The module node is marked \e{seen}   in either case.  */
end_comment
begin_function
DECL|function|addModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|DocNode
modifier|*
name|module
init|=
name|findModule
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|module
operator|->
name|markSeen
argument_list|()
expr_stmt|;
return|return
name|module
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module node named \a name in the collection   of all QML module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new QML module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned. The QML module node is marked \e{seen}   in either case.  */
end_comment
begin_function
DECL|function|addQmlModule
name|QmlModuleNode
modifier|*
name|QDocDatabase
operator|::
name|addQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|QmlModuleNode
modifier|*
name|qmn
init|=
name|findQmlModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|setQmlModuleInfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|qmn
operator|->
name|markSeen
argument_list|()
expr_stmt|;
comment|//masterMap_.insert(qmn->qmlModuleIdentifier(),qmn);
return|return
name|qmn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the group node named \a name in the collection   of all group nodes. If a match is not found, a new group   node named \a name is created and inserted into the collection.   Then append \a node to the group's members list, and append the   group node to the member list of the \a node. The parent of the   \a node is not changed by this function. Returns a pointer to   the group node.  */
end_comment
begin_function
DECL|function|addToGroup
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addToGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|findGroup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|dn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|addMember
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is not found, a new module   node named \a name is created and inserted into the collection.   Then append \a node to the module's members list. The parent of   \a node is not changed by this function. Returns the module node.  */
end_comment
begin_function
DECL|function|addToModule
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|addToModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|DocNode
modifier|*
name|dn
init|=
name|findModule
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|dn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setModuleName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.  */
end_comment
begin_function
DECL|function|addToQmlModule
name|void
name|QDocDatabase
operator|::
name|addToQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QStringList
name|qmid
decl_stmt|;
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|blankSplit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|QmlModuleNode
modifier|*
name|qmn
init|=
name|findQmlModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setQmlModule
argument_list|(
name|qmn
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmid
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|key
init|=
name|qmid
index|[
name|i
index|]
operator|+
literal|"::"
operator|+
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qmlTypeMap_
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
name|qmlTypeMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|masterMap_
operator|.
name|contains
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|node
argument_list|)
condition|)
name|masterMap_
operator|.
name|insert
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   \a qmid and QML type \a name and returns a pointer to the   QML type node. The key is \a qmid + "::" + \a name.    If the QML module id is empty, it looks up the QML type by   \a name only.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|qmid
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|qmid
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|qmlTypeMap_
operator|.
name|value
argument_list|(
name|qmid
operator|+
literal|"::"
operator|+
name|name
argument_list|)
return|;
name|QStringList
name|path
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|tree_
operator|->
name|findNodeByNameAndType
argument_list|(
name|path
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
decl_stmt|;
name|ncn
operator|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|ncn
operator|->
name|findAny
argument_list|(
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML type node identified by the Qml module id   constructed from the strings in the \a import record and the   QML type \a name and returns a pointer to the QML type node.   If a QML type node is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlType
name|QmlClassNode
modifier|*
name|QDocDatabase
operator|::
name|findQmlType
parameter_list|(
specifier|const
name|ImportRec
modifier|&
name|import
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|import
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|dotSplit
decl_stmt|;
name|dotSplit
operator|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|qmName
decl_stmt|;
if|if
condition|(
name|import
operator|.
name|importUri_
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmName
operator|=
name|import
operator|.
name|name_
expr_stmt|;
else|else
name|qmName
operator|=
name|import
operator|.
name|importUri_
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dotSplit
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|qmid
init|=
name|qmName
operator|+
name|import
operator|.
name|version_
decl_stmt|;
name|QString
name|qualifiedName
init|=
name|qmid
operator|+
literal|"::"
operator|+
name|dotSplit
index|[
name|i
index|]
decl_stmt|;
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qmlTypeMap_
operator|.
name|value
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
return|return
name|qcn
return|;
block|}
if|if
condition|(
name|import
operator|.
name|version_
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|int
name|dot
init|=
name|import
operator|.
name|version_
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|>
literal|0
condition|)
block|{
name|qmid
operator|=
name|import
operator|.
name|name_
operator|+
name|import
operator|.
name|version_
operator|.
name|left
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|qualifiedName
operator|=
name|qmid
operator|+
literal|"::"
operator|+
name|dotSplit
index|[
name|i
index|]
expr_stmt|;
name|qcn
operator|=
name|qmlTypeMap_
operator|.
name|value
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
return|return
name|qcn
return|;
block|}
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   For debugging only.  */
end_comment
begin_function
DECL|function|printModules
name|void
name|QDocDatabase
operator|::
name|printModules
parameter_list|()
specifier|const
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"  "
operator|<<
name|i
operator|.
name|key
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   For debugging only.  */
end_comment
begin_function
DECL|function|printQmlModules
name|void
name|QDocDatabase
operator|::
name|printQmlModules
parameter_list|()
specifier|const
block|{
name|DocNodeMap
operator|::
name|const_iterator
name|i
init|=
name|qmlModules_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|qmlModules_
operator|.
name|end
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"  "
operator|<<
name|i
operator|.
name|key
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Traverses the database to construct useful data structures   for use when outputting certain significant collections of   things, C++ classes, QML types, "since" lists, and other   stuff.  */
end_comment
begin_function
DECL|function|buildCollections
name|void
name|QDocDatabase
operator|::
name|buildCollections
parameter_list|()
block|{
name|nonCompatClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mainClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|compatClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|obsoleteClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|funcIndex_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|legaleseTexts_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|serviceClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qmlClasses_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|findAllClasses
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllFunctions
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllLegaleseTexts
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllNamespaces
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllSince
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|findAllObsoleteThings
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Finds all the C++ class nodes and QML type nodes and   sorts them into maps.  */
end_comment
begin_function
DECL|function|findAllClasses
name|void
name|QDocDatabase
operator|::
name|findAllClasses
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|className
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Compat
condition|)
block|{
name|compatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonCompatClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Main
condition|)
name|mainClasses_
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
name|QString
name|serviceName
init|=
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|serviceName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|serviceClasses_
operator|.
name|insert
argument_list|(
name|serviceName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|qmlTypeName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|qmlTypeName
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
else|else
name|qmlClasses_
operator|.
name|insert
argument_list|(
name|qmlTypeName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllClasses
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the function nodes  */
end_comment
begin_function
DECL|function|findAllFunctions
name|void
name|QDocDatabase
operator|::
name|findAllFunctions
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllFunctions
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|!
name|func
operator|->
name|isInternal
argument_list|()
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|funcIndex_
index|[
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes containing legalese text and puts them   in a map.  */
end_comment
begin_function
DECL|function|findAllLegaleseTexts
name|void
name|QDocDatabase
operator|::
name|findAllLegaleseTexts
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|legaleseTexts_
operator|.
name|insertMulti
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllLegaleseTexts
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the namespace nodes and puts them in an index.  */
end_comment
begin_function
DECL|function|findAllNamespaces
name|void
name|QDocDatabase
operator|::
name|findAllNamespaces
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllNamespaces
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
comment|// Ensure that the namespace's name is not empty (the root
comment|// namespace has no name).
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|namespaceIndex_
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all nodes with status = Obsolete and sorts them into   maps. They can be C++ classes, QML types, or they can be   functions, enum types, typedefs, methods, etc.  */
end_comment
begin_function
DECL|function|findAllObsoleteThings
name|void
name|QDocDatabase
operator|::
name|findAllObsoleteThings
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|QString
name|name
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteClasses_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|qmlModuleName
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|obsoleteQmlTypes_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
case|case
name|Node
operator|::
name|Variable
case|:
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
name|classesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|bool
name|inserted
init|=
literal|false
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|p
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|QmlSignal
case|:
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
case|case
name|Node
operator|::
name|QmlMethod
case|:
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|parent
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
operator|&&
name|parent
operator|->
name|parent
argument_list|()
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
operator|!
name|parent
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|name
operator|=
name|parent
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|qmlTypesWithObsoleteMembers_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|inserted
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllObsoleteThings
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Finds all the nodes where a \e{since} command appeared in the   qdoc comment and sorts them into maps according to the kind of   node.    This function is used for generating the "New Classes... in x.y"   section on the \e{What's New in Qt x.y} page.  */
end_comment
begin_function
DECL|function|findAllSince
name|void
name|QDocDatabase
operator|::
name|findAllSince
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|child
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|child
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|sinceString
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|since
argument_list|()
decl_stmt|;
comment|// Insert a new entry into each map for each new since string found.
if|if
condition|(
operator|(
operator|(
operator|*
name|child
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
operator|&&
operator|!
name|sinceString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMultiMapMap
operator|::
name|iterator
name|nsmap
init|=
name|newSinceMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsmap
operator|==
name|newSinceMaps_
operator|.
name|end
argument_list|()
condition|)
name|nsmap
operator|=
name|newSinceMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|ncmap
init|=
name|newClassMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncmap
operator|==
name|newClassMaps_
operator|.
name|end
argument_list|()
condition|)
name|ncmap
operator|=
name|newClassMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMapMap
operator|::
name|iterator
name|nqcmap
init|=
name|newQmlTypeMaps_
operator|.
name|find
argument_list|(
name|sinceString
argument_list|)
decl_stmt|;
if|if
condition|(
name|nqcmap
operator|==
name|newQmlTypeMaps_
operator|.
name|end
argument_list|()
condition|)
name|nqcmap
operator|=
name|newQmlTypeMaps_
operator|.
name|insert
argument_list|(
name|sinceString
argument_list|,
name|NodeMap
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
comment|// Insert functions into the general since map.
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
comment|// Insert classes into the since and class maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|ncmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
comment|// Insert QML elements into the since and element maps.
name|QString
name|className
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|className
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
name|nqcmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
comment|// Insert QML properties into the since map.
name|QString
name|propertyName
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|propertyName
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Insert external documents into the general since map.
name|QString
name|name
init|=
operator|(
operator|*
name|child
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|!
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
operator|(
operator|*
name|child
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|name
expr_stmt|;
block|}
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|child
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Recursively find child nodes with since commands.
if|if
condition|(
operator|(
operator|*
name|child
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllSince
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|child
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new class maps, and return a   reference to the value, which is a NodeMap. If \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getClassMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getClassMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newClassMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newClassMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new QML type maps, and return a   reference to the value, which is a NodeMap. If the \a key is not   found, return a reference to an empty NodeMap.  */
end_comment
begin_function
DECL|function|getQmlTypeMap
specifier|const
name|NodeMap
modifier|&
name|QDocDatabase
operator|::
name|getQmlTypeMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMapMap
operator|::
name|const_iterator
name|i
init|=
name|newQmlTypeMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newQmlTypeMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Find the \a key in the map of new \e {since} maps, and return   a reference to the value, which is a NodeMultiMap. If \a key   is not found, return a reference to an empty NodeMultiMap.  */
end_comment
begin_function
DECL|function|getSinceMap
specifier|const
name|NodeMultiMap
modifier|&
name|QDocDatabase
operator|::
name|getSinceMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|NodeMultiMapMap
operator|::
name|const_iterator
name|i
init|=
name|newSinceMaps_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|newSinceMaps_
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
return|return
name|emptyNodeMultiMap_
return|;
block|}
end_function
begin_comment
comment|/*!   Performs several housekeeping algorithms that create   certain data structures and resolve lots of links, prior   to generating documentation.  */
end_comment
begin_function
DECL|function|resolveIssues
name|void
name|QDocDatabase
operator|::
name|resolveIssues
parameter_list|()
block|{
name|resolveQmlInheritance
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|resolveTargets
argument_list|(
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
name|tree_
operator|->
name|resolveCppToQmlLinks
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Searches the \a database for a node named \a target and returns   a pointer to it if found.  */
end_comment
begin_function
DECL|function|resolveTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|resolveTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
name|QString
name|funcName
init|=
name|target
decl_stmt|;
name|funcName
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|QStringList
name|path
init|=
name|funcName
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
name|tree_
operator|->
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|SearchBaseClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
comment|/*               Why is this case not accepted?              */
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
name|node
operator|=
name|fn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
condition|)
block|{
comment|// This error message is never printed; I think we can remove the case.
name|qDebug
argument_list|()
operator|<<
literal|"qdoc: target case not handled:"
operator|<<
name|target
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|path
init|=
name|target
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|SearchBaseClasses
operator||
name|SearchEnumValues
operator||
name|NonFunction
decl_stmt|;
name|node
operator|=
name|tree_
operator|->
name|findNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|flags
argument_list|,
name|self
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the node that will generate the documentation that   contains the \a target and returns a pointer to it.  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
name|relative
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|node
operator|=
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|target
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|=
name|resolveTarget
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|findDocNodeByTitle
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_comment
comment|/*!   Inserts a new target into the target table with the specified   \a name, \a node, and \a priority.  */
end_comment
begin_function
DECL|function|insertTarget
name|void
name|QDocDatabase
operator|::
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|TargetRec
operator|::
name|Type
name|type
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|type_
operator|=
name|type
expr_stmt|;
name|target
operator|.
name|node_
operator|=
name|node
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
name|priority
expr_stmt|;
name|Atom
name|a
init|=
name|Atom
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|targetRecMultiMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a \a target anchor node. If it   finds one, it sets \a ref and returns the found node.  */
end_comment
begin_function
specifier|const
name|Node
modifier|*
DECL|function|findUnambiguousTarget
name|QDocDatabase
operator|::
name|findUnambiguousTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|TargetRec
name|bestTarget
decl_stmt|;
name|int
name|numBestTargets
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|TargetRec
argument_list|>
name|bestTargetList
decl_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetRecMultiMap
operator|::
name|iterator
name|i
init|=
name|targetRecMultiMap_
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|targetRecMultiMap_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|!=
name|key
condition|)
break|break;
specifier|const
name|TargetRec
modifier|&
name|candidate
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|<
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|==
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|numBestTargets
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numBestTargets
operator|==
literal|1
condition|)
block|{
name|ref
operator|=
name|bestTarget
operator|.
name|ref_
expr_stmt|;
return|return
name|bestTarget
operator|.
name|node_
return|;
block|}
elseif|else
if|if
condition|(
name|bestTargetList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bestTargetList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|relative
operator|->
name|qmlModuleName
argument_list|()
operator|==
name|n
operator|->
name|qmlModuleName
argument_list|()
condition|)
block|{
name|ref
operator|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|ref_
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
block|}
block|}
block|}
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with the specified \a title.   If \a relative node is provided, it is used to disambiguate if   it has a QML module identifier.  */
end_comment
begin_function
DECL|function|findDocNodeByTitle
specifier|const
name|DocNode
modifier|*
name|QDocDatabase
operator|::
name|findDocNodeByTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|DocNodeMultiMap
operator|::
name|const_iterator
name|i
init|=
name|docNodesByTitle_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|dn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|parent
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|nl
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|it
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|qmlModuleName
argument_list|()
operator|==
name|relative
operator|->
name|qmlModuleName
argument_list|()
condition|)
block|{
comment|/*                           By returning here, we avoid printing                           all the duplicate header warnings,                           which are not really duplicates now,                           because of the QML module name being                           used as a namespace qualifier.                         */
name|dn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
return|return
name|dn
return|;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
comment|/*           Reporting all these duplicate section titles is probably           overkill. We should report the duplicate file and let           that suffice.         */
name|DocNodeMultiMap
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Location
argument_list|>
name|internalLocations
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
operator|&&
name|j
operator|.
name|value
argument_list|()
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|internalLocations
operator|.
name|append
argument_list|(
name|j
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|// Just report one duplicate for now.
block|}
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|internalLocations
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|i
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"This page title exists in more than one file: \"%1\""
argument_list|)
operator|.
name|arg
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Location
modifier|&
name|location
decl|,
name|internalLocations
control|)
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"[It also exists here]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with a canonical title   constructed from \a target. If the node it finds is \a node,   it returns the ref from that node. Otherwise it returns an   empty string.  */
end_comment
begin_function
DECL|function|findTarget
name|QString
name|QDocDatabase
operator|::
name|findTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetRecMultiMap
operator|::
name|const_iterator
name|i
init|=
name|targetRecMultiMap_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|targetRecMultiMap_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|node_
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|.
name|ref_
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|targetRecMultiMap_
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
do|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   For each QML Type node in the tree beginning at \a root,   if it has a QML base type name but its QML base type node   pointer is 0, use the QML base type name to look up the   base type node. If the node is found in the tree, set the   node's QML base type node pointer.  */
end_comment
begin_function
DECL|function|resolveQmlInheritance
name|void
name|QDocDatabase
operator|::
name|resolveQmlInheritance
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// Dop we need recursion?
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|!
name|qcn
operator|->
name|qmlBaseName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|bqcn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|bqcn
operator|=
name|qmlTypeMap_
operator|.
name|value
argument_list|(
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|ImportList
modifier|&
name|imports
init|=
name|qcn
operator|->
name|importList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|imports
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|imports
index|[
name|i
index|]
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bqcn
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|bqcn
operator|==
literal|0
condition|)
block|{
name|bqcn
operator|=
name|findQmlType
argument_list|(
name|QString
argument_list|()
argument_list|,
name|qcn
operator|->
name|qmlBaseName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bqcn
condition|)
block|{
name|qcn
operator|->
name|setQmlBaseNode
argument_list|(
name|bqcn
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {                     qDebug()<< "Temporary error message (ignore): UNABLE to resolve QML base type:"<< qcn->qmlBaseName()<< "for QML type:"<< qcn->name();                 }
endif|#
directive|endif
block|}
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void QDocDatabase::resolveQmlInheritance(InnerNode* root) {
comment|// Dop we need recursion?
end_comment
begin_endif
unit|foreach (Node* child, root->childNodes()) {         if (child->type() == Node::Document&& child->subType() == Node::QmlClass) {             QmlClassNode* qcn = static_cast<QmlClassNode*>(child);             if ((qcn->qmlBaseNode() == 0)&& !qcn->qmlBaseName().isEmpty()) {                 QmlClassNode* bqcn = findQmlType(QString(), qcn->qmlBaseName());                 if (bqcn) {                     qcn->setQmlBaseNode(bqcn);                 }             }         }     } }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveTargets
name|void
name|QDocDatabase
operator|::
name|resolveTargets
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// need recursion
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|DocNode
modifier|*
name|node
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|DocNode
modifier|*
argument_list|>
name|nodes
init|=
name|docNodesByTitle_
operator|.
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|bool
name|alreadyThere
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|empty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|==
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|()
condition|)
block|{
name|alreadyThere
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|alreadyThere
condition|)
block|{
name|docNodesByTitle_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|resolveTargets
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|targetRecMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|keywords
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|targetRecMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|targetRecMultiMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Generates a tag file and writes it to \a name.  */
end_comment
begin_function
DECL|function|generateTagFile
name|void
name|QDocDatabase
operator|::
name|generateTagFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDocTagFiles
operator|::
name|qdocTagFiles
argument_list|()
operator|->
name|generateTagFile
argument_list|(
name|name
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|QDocTagFiles
operator|::
name|destroyQDocTagFiles
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Reads and parses the qdoc index files listed in \a indexFiles.  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|QDocDatabase
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|indexFiles
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|readIndexes
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates a qdoc index file and write it to \a fileName. The   index file is generated with the parameters \a url, \a title,   \a g, and \a generateInternalNodes.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|QDocDatabase
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|Generator
modifier|*
name|g
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QDocIndexFiles
operator|::
name|qdocIndexFiles
argument_list|()
operator|->
name|generateIndex
argument_list|(
name|fileName
argument_list|,
name|url
argument_list|,
name|title
argument_list|,
name|g
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
name|QDocIndexFiles
operator|::
name|destroyQDocIndexFiles
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|refForAtom
name|QString
name|QDocDatabase
operator|::
name|refForAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Target
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   If there are open namespaces, search for the function node   having the same function name as the \a clone node in each   open namespace. The \a parentPath is a portion of the path   name provided with the function name at the point of   reference. \a parentPath is usually a class name. Return   the pointer to the function node if one is found in an   open namespace. Otherwise return 0.    This open namespace concept is of dubious value and might   be removed.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|FunctionNode
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|path
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|parentPath
decl_stmt|;
name|fn
operator|=
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
break|break;
block|}
block|}
return|return
name|fn
return|;
block|}
end_function
begin_comment
comment|/*!   Find a node of the specified \a type and \a subtype that is   reached with the specified \a path. If such a node is found   in an open namespace, prefix \a path with the name of the   open namespace and "::" and return a pointer to the node.   Othewrwise return 0.  */
end_comment
begin_function
DECL|function|findNodeInOpenNamespace
name|Node
modifier|*
name|QDocDatabase
operator|::
name|findNodeInOpenNamespace
parameter_list|(
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|openNamespaces_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|openNamespaces_
control|)
block|{
name|QStringList
name|p
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|+
name|path
decl_stmt|;
name|n
operator|=
name|findNodeByNameAndType
argument_list|(
name|p
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|path
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
