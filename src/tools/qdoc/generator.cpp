begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   generator.cpp */
end_comment
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"ditaxmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"editdistance.h"
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"openedlist.h"
end_include
begin_include
include|#
directive|include
file|"quoter.h"
end_include
begin_include
include|#
directive|include
file|"separator.h"
end_include
begin_include
include|#
directive|include
file|"tokenizer.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|member|currentGenerator_
name|Generator
modifier|*
name|Generator
operator|::
name|currentGenerator_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleDirs
name|QStringList
name|Generator
operator|::
name|exampleDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleImgExts
name|QStringList
name|Generator
operator|::
name|exampleImgExts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|fmtLeftMaps
name|QMap
argument_list|<
name|QString
argument_list|,
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|Generator
operator|::
name|fmtLeftMaps
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|fmtRightMaps
name|QMap
argument_list|<
name|QString
argument_list|,
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|Generator
operator|::
name|fmtRightMaps
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|generators
name|QList
argument_list|<
name|Generator
modifier|*
argument_list|>
name|Generator
operator|::
name|generators
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|imageDirs
name|QStringList
name|Generator
operator|::
name|imageDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|imageFiles
name|QStringList
name|Generator
operator|::
name|imageFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|imgFileExts
name|QMap
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|Generator
operator|::
name|imgFileExts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|outDir_
name|QString
name|Generator
operator|::
name|outDir_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|outSubdir_
name|QString
name|Generator
operator|::
name|outSubdir_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|outputFormats
name|QSet
argument_list|<
name|QString
argument_list|>
name|Generator
operator|::
name|outputFormats
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|outputPrefixes
name|QHash
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|Generator
operator|::
name|outputPrefixes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|project
name|QString
name|Generator
operator|::
name|project
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|scriptDirs
name|QStringList
name|Generator
operator|::
name|scriptDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|scriptFiles
name|QStringList
name|Generator
operator|::
name|scriptFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|sinceTitles
name|QString
name|Generator
operator|::
name|sinceTitles
index|[]
init|=
block|{
literal|"    New Namespaces"
block|,
literal|"    New Classes"
block|,
literal|"    New Member Functions"
block|,
literal|"    New Functions in Namespaces"
block|,
literal|"    New Global Functions"
block|,
literal|"    New Macros"
block|,
literal|"    New Enum Types"
block|,
literal|"    New Typedefs"
block|,
literal|"    New Properties"
block|,
literal|"    New Variables"
block|,
literal|"    New QML Types"
block|,
literal|"    New QML Properties"
block|,
literal|"    New QML Signals"
block|,
literal|"    New QML Signal Handlers"
block|,
literal|"    New QML Methods"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|styleDirs
name|QStringList
name|Generator
operator|::
name|styleDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|styleFiles
name|QStringList
name|Generator
operator|::
name|styleFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|debugging_
name|bool
name|Generator
operator|::
name|debugging_
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|noLinkErrors_
name|bool
name|Generator
operator|::
name|noLinkErrors_
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|redirectDocumentationToDevNull_
name|bool
name|Generator
operator|::
name|redirectDocumentationToDevNull_
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|qdocPass_
name|Generator
operator|::
name|Passes
name|Generator
operator|::
name|qdocPass_
init|=
name|Both
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|setDebugSegfaultFlag
name|void
name|Generator
operator|::
name|setDebugSegfaultFlag
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"DEBUG: Setting debug flag."
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"DEBUG: Clearing debug flag."
expr_stmt|;
name|debugging_
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Prints \a message as an aid to debugging the release version.  */
end_comment
begin_function
DECL|function|debugSegfault
name|void
name|Generator
operator|::
name|debugSegfault
parameter_list|(
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
if|if
condition|(
name|debugging
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"DEBUG:"
operator|<<
name|message
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Constructs the generator base class. Prepends the newly   constructed generator to the list of output generators.   Sets a pointer to the QDoc database singleton, which is   available to the generator subclasses.  */
end_comment
begin_constructor
DECL|function|Generator
name|Generator
operator|::
name|Generator
parameter_list|()
member_init_list|:
name|amp
argument_list|(
literal|"&amp;"
argument_list|)
member_init_list|,
name|gt
argument_list|(
literal|"&gt;"
argument_list|)
member_init_list|,
name|lt
argument_list|(
literal|"&lt;"
argument_list|)
member_init_list|,
name|quot
argument_list|(
literal|"&quot;"
argument_list|)
member_init_list|,
name|tag
argument_list|(
literal|"</?@[^>]*>"
argument_list|)
member_init_list|,
name|inLink_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inContents_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inSectionHeading_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inTableHeader_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|threeColumnEnumValueTable_
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|numTableRows_
argument_list|(
literal|0
argument_list|)
block|{
name|qdb_
operator|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
expr_stmt|;
name|generators
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the generator after removing it from the list of   output generators.  */
end_comment
begin_destructor
DECL|function|~Generator
name|Generator
operator|::
name|~
name|Generator
parameter_list|()
block|{
name|generators
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|appendFullName
name|void
name|Generator
operator|::
name|appendFullName
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|Node
modifier|*
name|apparentNode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
name|actualNode
parameter_list|)
block|{
if|if
condition|(
name|actualNode
operator|==
literal|0
condition|)
name|actualNode
operator|=
name|apparentNode
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|actualNode
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|apparentNode
operator|->
name|plainFullName
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendFullName
name|void
name|Generator
operator|::
name|appendFullName
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|Node
modifier|*
name|apparentNode
parameter_list|,
specifier|const
name|QString
modifier|&
name|fullName
parameter_list|,
specifier|const
name|Node
modifier|*
name|actualNode
parameter_list|)
block|{
if|if
condition|(
name|actualNode
operator|==
literal|0
condition|)
name|actualNode
operator|=
name|apparentNode
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|actualNode
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|fullName
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendFullNames
name|void
name|Generator
operator|::
name|appendFullNames
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|nodes
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|n
init|=
name|nodes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nodes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|appendFullName
argument_list|(
name|text
argument_list|,
operator|*
name|n
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|text
operator|<<
name|comma
argument_list|(
name|index
operator|++
argument_list|,
name|nodes
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendSortedNames
name|void
name|Generator
operator|::
name|appendSortedNames
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|ClassNode
modifier|*
name|classe
parameter_list|,
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|classes
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Text
argument_list|>
name|classMap
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|classes
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|classes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Public
operator|&&
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|&&
operator|!
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|className
decl_stmt|;
name|appendFullName
argument_list|(
name|className
argument_list|,
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|,
name|classe
argument_list|)
expr_stmt|;
name|classMap
index|[
name|className
operator|.
name|toString
argument_list|()
operator|.
name|toLower
argument_list|()
index|]
operator|=
name|className
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
name|QStringList
name|classNames
init|=
name|classMap
operator|.
name|keys
argument_list|()
decl_stmt|;
name|classNames
operator|.
name|sort
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|className
decl|,
name|classNames
control|)
block|{
name|text
operator|<<
name|classMap
index|[
name|className
index|]
expr_stmt|;
name|text
operator|<<
name|separator
argument_list|(
name|index
operator|++
argument_list|,
name|classNames
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendSortedQmlNames
name|void
name|Generator
operator|::
name|appendSortedQmlNames
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|Node
modifier|*
name|base
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|subs
parameter_list|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Text
argument_list|>
name|classMap
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Text
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|isQtQuickNode
argument_list|()
operator|||
operator|!
name|subs
index|[
name|i
index|]
operator|->
name|isQtQuickNode
argument_list|()
operator|||
operator|(
name|base
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
name|subs
index|[
name|i
index|]
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|)
condition|)
block|{
name|appendFullName
argument_list|(
name|t
argument_list|,
name|subs
index|[
name|i
index|]
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|classMap
index|[
name|t
operator|.
name|toString
argument_list|()
operator|.
name|toLower
argument_list|()
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
name|QStringList
name|names
init|=
name|classMap
operator|.
name|keys
argument_list|()
decl_stmt|;
name|names
operator|.
name|sort
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|names
control|)
block|{
name|text
operator|<<
name|classMap
index|[
name|name
index|]
expr_stmt|;
name|text
operator|<<
name|separator
argument_list|(
name|index
operator|++
argument_list|,
name|names
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|outFileNames
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|outFileNames
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   For debugging qdoc.  */
end_comment
begin_function
DECL|function|writeOutFileNames
name|void
name|Generator
operator|::
name|writeOutFileNames
parameter_list|()
block|{
name|QFile
modifier|*
name|files
init|=
operator|new
name|QFile
argument_list|(
literal|"/Users/msmith/depot/qt5/qtdoc/outputlist.txt"
argument_list|)
decl_stmt|;
name|files
operator|->
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QTextStream
modifier|*
name|filesout
init|=
operator|new
name|QTextStream
argument_list|(
name|files
argument_list|)
decl_stmt|;
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|ConstIterator
name|i
init|=
name|outFileNames
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|outFileNames
operator|.
name|end
argument_list|()
condition|)
block|{
operator|(
operator|*
name|filesout
operator|)
operator|<<
name|i
operator|.
name|key
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|filesout
operator|->
name|flush
argument_list|()
expr_stmt|;
name|files
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Creates the file named \a fileName in the output directory.   Attaches a QTextStream to the created file, which is written   to all over the place using out().  */
end_comment
begin_function
DECL|function|beginSubPage
name|void
name|Generator
operator|::
name|beginSubPage
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QString
name|path
init|=
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|path
operator|+=
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|path
operator|+=
name|fileName
expr_stmt|;
name|Generator
operator|::
name|debugSegfault
argument_list|(
literal|"Writing: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|outFileNames
operator|.
name|insert
argument_list|(
name|fileName
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QFile
modifier|*
name|outFile
init|=
operator|new
name|QFile
argument_list|(
name|redirectDocumentationToDevNull_
condition|?
name|QStringLiteral
argument_list|(
literal|"/dev/null"
argument_list|)
else|:
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outFile
operator|->
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
condition|)
name|node
operator|->
name|location
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open output file '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outFile
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTextStream
modifier|*
name|out
init|=
operator|new
name|QTextStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|outputCodec
condition|)
name|out
operator|->
name|setCodec
argument_list|(
name|outputCodec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outStreamStack
operator|.
name|push
argument_list|(
name|out
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|setOutputFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Flush the text stream associated with the subpage, and   then pop it off the text stream stack and delete it.   This terminates output of the subpage.  */
end_comment
begin_function
DECL|function|endSubPage
name|void
name|Generator
operator|::
name|endSubPage
parameter_list|()
block|{
name|outStreamStack
operator|.
name|top
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
operator|delete
name|outStreamStack
operator|.
name|top
argument_list|()
operator|->
name|device
argument_list|()
expr_stmt|;
operator|delete
name|outStreamStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fileBase
name|QString
name|Generator
operator|::
name|fileBase
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|node
operator|->
name|relates
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|relates
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
operator|->
name|currentChild
argument_list|()
condition|)
return|return
name|fileBase
argument_list|(
name|ncn
operator|->
name|currentChild
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|node
operator|->
name|hasBaseName
argument_list|()
condition|)
block|{
comment|//qDebug()<< "RETURNING:"<< node->baseName();
return|return
name|node
operator|->
name|baseName
argument_list|()
return|;
block|}
name|QString
name|base
decl_stmt|;
specifier|const
name|Node
modifier|*
name|p
init|=
name|node
decl_stmt|;
forever|forever
block|{
specifier|const
name|Node
modifier|*
name|pp
init|=
name|p
operator|->
name|parent
argument_list|()
decl_stmt|;
name|base
operator|.
name|prepend
argument_list|(
name|p
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|base
operator|.
name|prepend
argument_list|(
name|p
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
name|QChar
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
comment|/*           To avoid file name conflicts in the html directory,           we prepend a prefix (by default, "qml-") to the file name of QML           element doc files.          */
if|if
condition|(
operator|(
name|p
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
operator|||
operator|(
name|p
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
operator|)
condition|)
block|{
name|base
operator|.
name|prepend
argument_list|(
name|outputPrefix
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pp
operator|||
name|pp
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|pp
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
break|break;
name|base
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
operator|->
name|currentChild
argument_list|()
condition|)
return|return
name|fileBase
argument_list|(
name|ncn
operator|->
name|currentChild
argument_list|()
argument_list|)
return|;
name|base
operator|.
name|prepend
argument_list|(
literal|"collision-"
argument_list|)
expr_stmt|;
block|}
comment|//Was QDOC2_COMPAT, required for index.html
if|if
condition|(
name|base
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|base
operator|.
name|truncate
argument_list|(
name|base
operator|.
name|length
argument_list|()
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlModule
condition|)
block|{
name|base
operator|.
name|prepend
argument_list|(
literal|"qmlmodule-"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
name|base
operator|.
name|append
argument_list|(
literal|"-module"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the code below is effectively equivalent to:
comment|//   base.replace(QRegExp("[^A-Za-z0-9]+"), " ");
comment|//   base = base.trimmed();
comment|//   base.replace(QLatin1Char(' '), QLatin1Char('-'));
comment|//   base = base.toLower();
comment|// as this function accounted for ~8% of total running time
comment|// we optimize a bit...
name|QString
name|res
decl_stmt|;
comment|// +5 prevents realloc in fileName() below
name|res
operator|.
name|reserve
argument_list|(
name|base
operator|.
name|size
argument_list|()
operator|+
literal|5
argument_list|)
expr_stmt|;
name|bool
name|begun
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|base
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|c
init|=
name|base
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
condition|)
name|u
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|res
operator|+=
name|QLatin1Char
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|begun
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begun
condition|)
block|{
name|res
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|begun
operator|=
literal|false
expr_stmt|;
block|}
block|}
while|while
condition|(
name|res
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|)
name|res
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|n
operator|->
name|setBaseName
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!   If the \a node has a URL, return the URL as the file name.   Otherwise, construct the file name from the fileBase() and   the fileExtension(), and return the constructed name.  */
end_comment
begin_function
DECL|function|fileName
name|QString
name|Generator
operator|::
name|fileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
name|QString
name|name
init|=
name|fileBase
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|name
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|name
operator|+=
name|fileExtension
argument_list|()
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|formattingLeftMap
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
modifier|&
name|Generator
operator|::
name|formattingLeftMap
parameter_list|()
block|{
return|return
name|fmtLeftMaps
index|[
name|format
argument_list|()
index|]
return|;
block|}
end_function
begin_function
DECL|function|formattingRightMap
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
modifier|&
name|Generator
operator|::
name|formattingRightMap
parameter_list|()
block|{
return|return
name|fmtRightMaps
index|[
name|format
argument_list|()
index|]
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the full document location.  */
end_comment
begin_function
DECL|function|fullDocumentLocation
name|QString
name|Generator
operator|::
name|fullDocumentLocation
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|subdir
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
name|QString
name|parentName
decl_stmt|;
name|QString
name|anchorRef
decl_stmt|;
name|QString
name|fdl
decl_stmt|;
comment|/*       If the output is being sent to subdirectories of the       output directory, and if the subdir parameter is set,       prepend the subdirectory name + '/' to the result.      */
if|if
condition|(
name|subdir
condition|)
block|{
name|fdl
operator|=
name|node
operator|->
name|outputSubdirectory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fdl
operator|.
name|isEmpty
argument_list|()
condition|)
name|fdl
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
comment|// The root namespace has no name - check for this before creating
comment|// an attribute containing the location of any documentation.
if|if
condition|(
operator|!
name|fileBase
argument_list|(
name|node
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|parentName
operator|=
name|fileBase
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
expr_stmt|;
else|else
return|return
name|QString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
operator|||
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
operator|)
condition|)
block|{
name|QString
name|fb
init|=
name|fileBase
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fb
operator|.
name|startsWith
argument_list|(
name|Generator
operator|::
name|outputPrefix
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|fb
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
return|;
else|else
block|{
name|QString
name|mq
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mq
operator|=
name|node
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|replace
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QChar
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|mq
operator|=
name|mq
operator|.
name|toLower
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
return|return
name|fdl
operator|+
name|Generator
operator|::
name|outputPrefix
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
operator|+
name|mq
operator|+
name|fileBase
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
return|;
block|}
block|}
else|else
block|{
name|parentName
operator|=
name|fileBase
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fileBase
argument_list|(
name|node
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|Node
modifier|*
name|parentNode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|parentNode
operator|=
name|node
operator|->
name|relates
argument_list|()
operator|)
condition|)
block|{
name|parentName
operator|=
name|fullDocumentLocation
argument_list|(
name|node
operator|->
name|relates
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|parentNode
operator|=
name|node
operator|->
name|parent
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|parentNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|parentNode
operator|=
name|parentNode
operator|->
name|parent
argument_list|()
expr_stmt|;
name|parentName
operator|=
name|fullDocumentLocation
argument_list|(
name|parentNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parentName
operator|=
name|fullDocumentLocation
argument_list|(
name|node
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Class
case|:
case|case
name|Node
operator|::
name|Namespace
case|:
name|parentName
operator|=
name|fileBase
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
condition|)
name|anchorRef
operator|=
literal|"#dtor."
operator|+
name|functionNode
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|functionNode
operator|->
name|associatedProperty
argument_list|()
condition|)
return|return
name|fullDocumentLocation
argument_list|(
name|functionNode
operator|->
name|associatedProperty
argument_list|()
argument_list|)
return|;
elseif|else
if|if
condition|(
name|functionNode
operator|->
name|overloadNumber
argument_list|()
operator|>
literal|1
condition|)
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|functionNode
operator|->
name|name
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|functionNode
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|functionNode
operator|->
name|name
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*       Use node->name() instead of fileBase(node) as       the latter returns the name in lower-case. For       HTML anchors, we need to preserve the case.     */
case|case
name|Node
operator|::
name|Enum
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-typedef"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-prop"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-prop"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal-handler"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-method"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|anchorRef
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-var"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Document
case|:
block|{
name|parentName
operator|=
name|fileBase
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|parentName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|parentName
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// Various objects can be compat (deprecated) or obsolete.
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Class
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Namespace
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Compat
case|:
name|parentName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
argument_list|,
literal|"-compat."
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|parentName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
argument_list|,
literal|"-obsolete."
operator|+
name|currentGenerator
argument_list|()
operator|->
name|fileExtension
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
return|return
name|fdl
operator|+
name|parentName
operator|.
name|toLower
argument_list|()
operator|+
name|anchorRef
return|;
block|}
end_function
begin_function
DECL|function|generateAlsoList
name|void
name|Generator
operator|::
name|generateAlsoList
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Text
argument_list|>
name|alsoList
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|alsoList
argument_list|()
decl_stmt|;
name|supplementAlsoList
argument_list|(
name|node
argument_list|,
name|alsoList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alsoList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"See also "
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alsoList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|text
operator|<<
name|alsoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
name|separator
argument_list|(
name|i
argument_list|,
name|alsoList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateAtom
name|int
name|Generator
operator|::
name|generateAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
comment|/* atom */
parameter_list|,
specifier|const
name|Node
modifier|*
comment|/* relative */
parameter_list|,
name|CodeMarker
modifier|*
comment|/* marker */
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|generateAtomList
specifier|const
name|Atom
modifier|*
name|Generator
operator|::
name|generateAtomList
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|bool
name|generate
parameter_list|,
name|int
modifier|&
name|numAtoms
parameter_list|)
block|{
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormatIf
condition|)
block|{
name|int
name|numAtoms0
init|=
name|numAtoms
decl_stmt|;
name|bool
name|rightFormat
init|=
name|canHandleFormat
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|atom
operator|=
name|generateAtomList
argument_list|(
name|atom
operator|->
name|next
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|generate
operator|&&
name|rightFormat
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atom
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormatElse
condition|)
block|{
operator|++
name|numAtoms
expr_stmt|;
name|atom
operator|=
name|generateAtomList
argument_list|(
name|atom
operator|->
name|next
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|generate
operator|&&
operator|!
name|rightFormat
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atom
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormatEndif
condition|)
block|{
if|if
condition|(
name|generate
operator|&&
name|numAtoms0
operator|==
name|numAtoms
condition|)
block|{
name|relative
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Output format %1 not handled %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|format
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|outFileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Atom
name|unhandledFormatAtom
argument_list|(
name|Atom
operator|::
name|UnhandledFormat
argument_list|,
name|format
argument_list|()
argument_list|)
decl_stmt|;
name|generateAtomList
argument_list|(
operator|&
name|unhandledFormatAtom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|generate
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
block|}
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormatElse
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormatEndif
condition|)
block|{
return|return
name|atom
return|;
block|}
else|else
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|generate
condition|)
block|{
name|n
operator|+=
name|generateAtom
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|numAtoms
operator|+=
name|n
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|generateBody
name|void
name|Generator
operator|::
name|generateBody
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|bool
name|quiet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
operator|)
operator|||
operator|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
operator|)
condition|)
block|{
name|quiet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isWrapper
argument_list|()
operator|&&
operator|!
name|quiet
operator|&&
operator|!
name|node
operator|->
name|isReimp
argument_list|()
condition|)
block|{
comment|// ### might be unnecessary
name|node
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No documentation for '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|reimplementedFrom
argument_list|()
operator|!=
literal|0
condition|)
name|generateReimplementedFrom
argument_list|(
name|func
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|generateText
argument_list|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|body
argument_list|()
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|isReimp
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
operator|(
specifier|const
name|EnumNode
operator|*
operator|)
name|node
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|definedItems
decl_stmt|;
name|QList
argument_list|<
name|EnumItem
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|enume
operator|->
name|items
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|enume
operator|->
name|items
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|definedItems
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|QSet
argument_list|<
name|QString
argument_list|>
name|documentedItems
init|=
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|enumItemNames
argument_list|()
operator|.
name|toSet
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|allItems
init|=
name|definedItems
operator|+
name|documentedItems
decl_stmt|;
if|if
condition|(
name|allItems
operator|.
name|count
argument_list|()
operator|>
name|definedItems
operator|.
name|count
argument_list|()
operator|||
name|allItems
operator|.
name|count
argument_list|()
operator|>
name|documentedItems
operator|.
name|count
argument_list|()
condition|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|a
init|=
name|allItems
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|allItems
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|definedItems
operator|.
name|contains
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
name|QString
name|details
decl_stmt|;
name|QString
name|best
init|=
name|nearestName
argument_list|(
operator|*
name|a
argument_list|,
name|definedItems
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|best
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|documentedItems
operator|.
name|contains
argument_list|(
name|best
argument_list|)
condition|)
name|details
operator|=
name|tr
argument_list|(
literal|"Maybe you meant '%1'?"
argument_list|)
operator|.
name|arg
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No such enum item '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|a
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|,
name|details
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a
operator|==
literal|"Void"
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"VOID:"
operator|<<
name|node
operator|->
name|name
argument_list|()
operator|<<
name|definedItems
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|documentedItems
operator|.
name|contains
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Undocumented enum item '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|a
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|a
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|definedParams
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|*
name|p
operator|)
operator|.
name|leftType
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"..."
argument_list|)
operator|&&
name|func
operator|->
name|name
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"operator++"
argument_list|)
operator|&&
name|func
operator|->
name|name
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"operator--"
argument_list|)
condition|)
block|{
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing parameter name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|definedParams
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|QSet
argument_list|<
name|QString
argument_list|>
name|documentedParams
init|=
name|func
operator|->
name|doc
argument_list|()
operator|.
name|parameterNames
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|allParams
init|=
name|definedParams
operator|+
name|documentedParams
decl_stmt|;
if|if
condition|(
name|allParams
operator|.
name|count
argument_list|()
operator|>
name|definedParams
operator|.
name|count
argument_list|()
operator|||
name|allParams
operator|.
name|count
argument_list|()
operator|>
name|documentedParams
operator|.
name|count
argument_list|()
condition|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|a
init|=
name|allParams
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|allParams
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|definedParams
operator|.
name|contains
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
name|QString
name|details
decl_stmt|;
name|QString
name|best
init|=
name|nearestName
argument_list|(
operator|*
name|a
argument_list|,
name|definedParams
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|best
operator|.
name|isEmpty
argument_list|()
condition|)
name|details
operator|=
name|tr
argument_list|(
literal|"Maybe you meant '%1'?"
argument_list|)
operator|.
name|arg
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No such parameter '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|a
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|,
name|details
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|*
name|a
operator|)
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|documentedParams
operator|.
name|contains
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
name|bool
name|needWarning
init|=
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|>
literal|1
condition|)
block|{
name|FunctionNode
modifier|*
name|primaryFunc
init|=
name|func
operator|->
name|parent
argument_list|()
operator|->
name|findFunctionNode
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|primaryFunc
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|param
decl|,
name|primaryFunc
operator|->
name|parameters
argument_list|()
control|)
block|{
if|if
condition|(
name|param
operator|.
name|name
argument_list|()
operator|==
operator|*
name|a
condition|)
block|{
name|needWarning
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|needWarning
operator|&&
operator|!
name|func
operator|->
name|isReimp
argument_list|()
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Undocumented parameter '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|a
argument_list|)
operator|.
name|arg
argument_list|(
name|node
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|a
expr_stmt|;
block|}
block|}
comment|/*               Something like this return value check should               be implemented at some point.             */
if|if
condition|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|&&
name|func
operator|->
name|returnType
argument_list|()
operator|==
literal|"bool"
operator|&&
name|func
operator|->
name|reimplementedFrom
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|func
operator|->
name|isOverload
argument_list|()
condition|)
block|{
name|QString
name|body
init|=
name|func
operator|->
name|doc
argument_list|()
operator|.
name|body
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|body
operator|.
name|contains
argument_list|(
literal|"return"
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Undocumented return value"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
condition|)
block|{
name|generateExampleFiles
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|Quoter
name|quoter
decl_stmt|;
name|Doc
operator|::
name|quoteFromFile
argument_list|(
name|dn
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|quoter
argument_list|,
name|dn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|code
init|=
name|quoter
operator|.
name|quoteTo
argument_list|(
name|dn
operator|->
name|location
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
decl_stmt|;
name|CodeMarker
modifier|*
name|codeMarker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|dn
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|codeMarker
operator|->
name|atomType
argument_list|()
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|dn
argument_list|,
name|codeMarker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateClassLikeNode
name|void
name|Generator
operator|::
name|generateClassLikeNode
parameter_list|(
name|InnerNode
modifier|*
comment|/* classe */
parameter_list|,
name|CodeMarker
modifier|*
comment|/* marker */
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|generateExampleFiles
name|void
name|Generator
operator|::
name|generateExampleFiles
parameter_list|(
specifier|const
name|DocNode
modifier|*
name|dn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|dn
operator|->
name|childNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|generateFileList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|Node
operator|::
name|File
argument_list|,
name|QString
argument_list|(
literal|"Files:"
argument_list|)
argument_list|)
expr_stmt|;
name|generateFileList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|Node
operator|::
name|Image
argument_list|,
name|QString
argument_list|(
literal|"Images:"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateDocNode
name|void
name|Generator
operator|::
name|generateDocNode
parameter_list|(
name|DocNode
modifier|*
comment|/* dn */
parameter_list|,
name|CodeMarker
modifier|*
comment|/* marker */
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!   This function is called when the documentation for an   example is being formatted. It outputs the list of source   files comprising the example, and the list of images used   by the example. The images are copied into a subtree of   \c{...doc/html/images/used-in-examples/...}  */
end_comment
begin_function
DECL|function|generateFileList
name|void
name|Generator
operator|::
name|generateFileList
parameter_list|(
specifier|const
name|DocNode
modifier|*
name|dn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|,
specifier|const
name|QString
modifier|&
name|tag
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Text
name|text
decl_stmt|;
name|OpenedList
name|openedList
argument_list|(
name|OpenedList
operator|::
name|Bullet
argument_list|)
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|tag
operator|<<
name|Atom
operator|::
name|ParaRight
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListLeft
argument_list|,
name|openedList
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|child
decl|,
name|dn
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|subtype
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|QString
name|file
init|=
name|child
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|Node
operator|::
name|Image
condition|)
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDir
name|dirInfo
decl_stmt|;
name|QString
name|userFriendlyFilePath
decl_stmt|;
name|QString
name|srcPath
init|=
name|Config
operator|::
name|findFile
argument_list|(
name|dn
operator|->
name|location
argument_list|()
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|exampleDirs
argument_list|,
name|file
argument_list|,
name|exampleImgExts
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
name|userFriendlyFilePath
operator|.
name|truncate
argument_list|(
name|userFriendlyFilePath
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|imgOutDir
init|=
name|outDir_
operator|+
literal|"/images/used-in-examples/"
operator|+
name|userFriendlyFilePath
decl_stmt|;
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|mkpath
argument_list|(
name|imgOutDir
argument_list|)
condition|)
name|dn
operator|->
name|location
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create output directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|imgOutDir
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|imgOutName
init|=
name|Config
operator|::
name|copyFile
argument_list|(
name|dn
operator|->
name|location
argument_list|()
argument_list|,
name|srcPath
argument_list|,
name|file
argument_list|,
name|imgOutDir
argument_list|)
decl_stmt|;
block|}
block|}
name|openedList
operator|.
name|next
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemNumber
argument_list|,
name|openedList
operator|.
name|numberString
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|,
name|openedList
operator|.
name|styleString
argument_list|()
argument_list|)
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|file
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|file
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
operator|::
name|ParaRight
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|,
name|openedList
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListRight
argument_list|,
name|openedList
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|generateText
argument_list|(
name|text
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateInheritedBy
name|void
name|Generator
operator|::
name|generateInheritedBy
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|classe
operator|->
name|derivedClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"Inherited by: "
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|appendSortedNames
argument_list|(
name|text
argument_list|,
name|classe
argument_list|,
name|classe
operator|->
name|derivedClasses
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|classe
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateInherits
name|void
name|Generator
operator|::
name|generateInherits
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"Inherits: "
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|r
operator|=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
operator|(
operator|*
name|r
operator|)
operator|.
name|dataTypeWithTemplateArgs
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|access
operator|==
name|Node
operator|::
name|Protected
condition|)
block|{
name|text
operator|<<
literal|" (protected)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|access
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|text
operator|<<
literal|" (private)"
expr_stmt|;
block|}
name|text
operator|<<
name|separator
argument_list|(
name|index
operator|++
argument_list|,
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|classe
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Recursive writing of HTML files from the root \a node.    \note NameCollisionNodes are skipped here and processed   later. See HtmlGenerator::generateCollisionPages() for   more on this.  */
end_comment
begin_function
DECL|function|generateInnerNode
name|void
name|Generator
operator|::
name|generateInnerNode
parameter_list|(
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return;
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return;
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|count
argument_list|()
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"PAGE %s HAS CHILDREN"
argument_list|,
name|qPrintable
argument_list|(
name|docNode
operator|->
name|title
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
return|return;
comment|/*       Obtain a code marker for the source file.      */
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|node
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/*           Skip name collision nodes here and process them           later in generateCollisionPages(). Each one is           appended to a list for later.          */
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|)
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|collisionNodes
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|ncn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|generateClassLikeNode
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|generateDocNode
argument_list|(
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
name|endSubPage
argument_list|()
expr_stmt|;
block|}
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|generateInnerNode
argument_list|(
operator|(
name|InnerNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate a list of maintainers in the output  */
end_comment
begin_function
DECL|function|generateMaintainerList
name|void
name|Generator
operator|::
name|generateMaintainerList
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QStringList
name|sl
init|=
name|getMetadataElements
argument_list|(
name|node
argument_list|,
literal|"maintainer"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"Maintained by: "
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|text
operator|<<
name|sl
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
name|separator
argument_list|(
name|i
argument_list|,
name|sl
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "Inherit by" list for the QML element,   if it is inherited by any other elements.  */
end_comment
begin_function
DECL|function|generateQmlInheritedBy
name|void
name|Generator
operator|::
name|generateQmlInheritedBy
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|qcn
condition|)
block|{
name|NodeList
name|subs
decl_stmt|;
name|QmlClassNode
operator|::
name|subclasses
argument_list|(
name|qcn
operator|->
name|name
argument_list|()
argument_list|,
name|subs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
literal|"Inherited by "
expr_stmt|;
name|appendSortedQmlNames
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|subs
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|generateQmlInherits
name|void
name|Generator
operator|::
name|generateQmlInherits
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
parameter_list|,
name|CodeMarker
modifier|*
parameter_list|)
block|{
comment|// stub.
block|}
end_function
begin_comment
comment|/*!   Extract sections of markup text surrounded by \e qmltext   and \e endqmltext and output them.  */
end_comment
begin_function
DECL|function|generateQmlText
name|bool
name|Generator
operator|::
name|generateQmlText
parameter_list|(
specifier|const
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
comment|/* qmlName */
parameter_list|)
block|{
specifier|const
name|Atom
modifier|*
name|atom
init|=
name|text
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
name|bool
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|atom
operator|!=
literal|0
condition|)
block|{
name|initializeTextOutput
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|QmlText
condition|)
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
else|else
block|{
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
operator|&&
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|EndQmlText
operator|)
condition|)
block|{
name|int
name|n
init|=
literal|1
operator|+
name|generateAtom
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|generateReimplementedFrom
name|void
name|Generator
operator|::
name|generateReimplementedFrom
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|func
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|func
operator|->
name|reimplementedFrom
argument_list|()
operator|!=
literal|0
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|&&
name|from
operator|->
name|parent
argument_list|()
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
literal|"Reimplemented from "
expr_stmt|;
name|QString
name|fullName
init|=
name|from
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|from
operator|->
name|name
argument_list|()
operator|+
literal|"()"
decl_stmt|;
name|appendFullName
argument_list|(
name|text
argument_list|,
name|from
operator|->
name|parent
argument_list|()
argument_list|,
name|fullName
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|func
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateSince
name|void
name|Generator
operator|::
name|generateSince
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|since
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
name|text
operator|<<
literal|" was introduced or modified in "
expr_stmt|;
else|else
name|text
operator|<<
literal|" was introduced in "
expr_stmt|;
name|QStringList
name|since
init|=
name|node
operator|->
name|since
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|since
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Handle legacy use of \since<version>.
if|if
condition|(
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|<<
literal|"version"
expr_stmt|;
else|else
name|text
operator|<<
name|project
expr_stmt|;
name|text
operator|<<
literal|" "
operator|<<
name|since
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// Reconstruct the<project><version> string.
name|text
operator|<<
literal|" "
operator|<<
name|since
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|text
operator|<<
literal|"."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateStatus
name|void
name|Generator
operator|::
name|generateStatus
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|text
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Commendable
case|:
case|case
name|Node
operator|::
name|Main
case|:
break|break;
case|case
name|Node
operator|::
name|Preliminary
case|:
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is under development and is subject to change."
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Deprecated
case|:
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is deprecated."
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is obsolete."
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" It is provided to keep old source code working. "
operator|<<
literal|"We strongly advise against "
operator|<<
literal|"using it in new code."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
comment|// reimplemented in HtmlGenerator subclass
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is part of the Qt compatibility layer."
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" It is provided to keep old source code working. "
operator|<<
literal|"We strongly advise against using it in new code."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Internal
case|:
default|default:
break|break;
block|}
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateText
name|bool
name|Generator
operator|::
name|generateText
parameter_list|(
specifier|const
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|bool
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|firstAtom
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|int
name|numAtoms
init|=
literal|0
decl_stmt|;
name|initializeTextOutput
argument_list|()
expr_stmt|;
name|generateAtomList
argument_list|(
name|text
operator|.
name|firstAtom
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|generateThreadSafeness
name|void
name|Generator
operator|::
name|generateThreadSafeness
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|text
decl_stmt|;
name|Node
operator|::
name|ThreadSafeness
name|threadSafeness
init|=
name|node
operator|->
name|threadSafeness
argument_list|()
decl_stmt|;
name|Text
name|rlink
decl_stmt|;
name|rlink
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
literal|"reentrant"
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
literal|"reentrant"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|Text
name|tlink
decl_stmt|;
name|tlink
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
literal|"thread-safe"
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
literal|"thread-safe"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|threadSafeness
condition|)
block|{
case|case
name|Node
operator|::
name|UnspecifiedSafeness
case|:
break|break;
case|case
name|Node
operator|::
name|NonReentrant
case|:
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"Warning:"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is not "
operator|<<
name|rlink
operator|<<
literal|"."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Reentrant
case|:
case|case
name|Node
operator|::
name|ThreadSafe
case|:
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"Note:"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" "
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|innerNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|text
operator|<<
literal|"All functions in this "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" are "
expr_stmt|;
if|if
condition|(
name|threadSafeness
operator|==
name|Node
operator|::
name|ThreadSafe
condition|)
name|text
operator|<<
name|tlink
expr_stmt|;
else|else
name|text
operator|<<
name|rlink
expr_stmt|;
name|bool
name|exceptions
init|=
literal|false
decl_stmt|;
name|NodeList
name|reentrant
decl_stmt|;
name|NodeList
name|threadsafe
decl_stmt|;
name|NodeList
name|nonreentrant
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|innerNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|innerNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Obsolete
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|threadSafeness
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Reentrant
case|:
name|reentrant
operator|.
name|append
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadSafeness
operator|==
name|Node
operator|::
name|ThreadSafe
condition|)
name|exceptions
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ThreadSafe
case|:
name|threadsafe
operator|.
name|append
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadSafeness
operator|==
name|Node
operator|::
name|Reentrant
condition|)
name|exceptions
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|NonReentrant
case|:
name|nonreentrant
operator|.
name|append
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|exceptions
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exceptions
condition|)
name|text
operator|<<
literal|"."
expr_stmt|;
elseif|else
if|if
condition|(
name|threadSafeness
operator|==
name|Node
operator|::
name|Reentrant
condition|)
block|{
if|if
condition|(
name|nonreentrant
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|threadsafe
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|<<
literal|", but "
expr_stmt|;
name|appendFullNames
argument_list|(
name|text
argument_list|,
name|threadsafe
argument_list|,
name|innerNode
argument_list|)
expr_stmt|;
name|singularPlural
argument_list|(
name|text
argument_list|,
name|threadsafe
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" also "
operator|<<
name|tlink
operator|<<
literal|"."
expr_stmt|;
block|}
else|else
name|text
operator|<<
literal|"."
expr_stmt|;
block|}
else|else
block|{
name|text
operator|<<
literal|", except for "
expr_stmt|;
name|appendFullNames
argument_list|(
name|text
argument_list|,
name|nonreentrant
argument_list|,
name|innerNode
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|", which"
expr_stmt|;
name|singularPlural
argument_list|(
name|text
argument_list|,
name|nonreentrant
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" nonreentrant."
expr_stmt|;
if|if
condition|(
operator|!
name|threadsafe
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|<<
literal|" "
expr_stmt|;
name|appendFullNames
argument_list|(
name|text
argument_list|,
name|threadsafe
argument_list|,
name|innerNode
argument_list|)
expr_stmt|;
name|singularPlural
argument_list|(
name|text
argument_list|,
name|threadsafe
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" "
operator|<<
name|tlink
operator|<<
literal|"."
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// thread-safe
if|if
condition|(
operator|!
name|nonreentrant
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|reentrant
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|<<
literal|", except for "
expr_stmt|;
if|if
condition|(
operator|!
name|reentrant
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|appendFullNames
argument_list|(
name|text
argument_list|,
name|reentrant
argument_list|,
name|innerNode
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|", which"
expr_stmt|;
name|singularPlural
argument_list|(
name|text
argument_list|,
name|reentrant
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" only "
operator|<<
name|rlink
expr_stmt|;
if|if
condition|(
operator|!
name|nonreentrant
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|<<
literal|", and "
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonreentrant
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|appendFullNames
argument_list|(
name|text
argument_list|,
name|nonreentrant
argument_list|,
name|innerNode
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|", which"
expr_stmt|;
name|singularPlural
argument_list|(
name|text
argument_list|,
name|nonreentrant
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" nonreentrant."
expr_stmt|;
block|}
name|text
operator|<<
literal|"."
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|text
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is "
expr_stmt|;
if|if
condition|(
name|threadSafeness
operator|==
name|Node
operator|::
name|ThreadSafe
condition|)
name|text
operator|<<
name|tlink
expr_stmt|;
else|else
name|text
operator|<<
name|rlink
expr_stmt|;
name|text
operator|<<
literal|"."
expr_stmt|;
block|}
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
block|}
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Traverses the database recursivly to generate all the documentation.  */
end_comment
begin_function
DECL|function|generateTree
name|void
name|Generator
operator|::
name|generateTree
parameter_list|()
block|{
name|generateInnerNode
argument_list|(
name|qdb_
operator|->
name|treeRoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generatorForFormat
name|Generator
modifier|*
name|Generator
operator|::
name|generatorForFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QList
argument_list|<
name|Generator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|g
init|=
name|generators
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|g
operator|!=
name|generators
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
operator|==
name|format
condition|)
return|return
operator|*
name|g
return|;
operator|++
name|g
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function can be called if getLink() returns an empty   string. It tests the \a atom string to see if it is a link   of the form<element> ::<name>, where<element> is a QML   element or component without a module qualifier. If so, it   constructs a link to the<name> clause on the disambiguation   page for<element> and returns that link string. It also   adds the<name> as a target in the NameCollisionNode for<element>. These clauses are then constructed when the   disambiguation page is actually generated.  */
end_comment
begin_function
DECL|function|getCollisionLink
name|QString
name|Generator
operator|::
name|getCollisionLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
name|QString
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
return|return
name|link
return|;
name|QStringList
name|path
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|NameCollisionNode
modifier|*
name|ncn
init|=
name|qdb_
operator|->
name|findCollisionNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
condition|)
block|{
name|QString
name|label
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormattingLeft
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
name|label
operator|=
name|atom
operator|->
name|next
argument_list|()
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
expr_stmt|;
block|}
name|ncn
operator|->
name|addLinkTarget
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|link
operator|=
name|fileName
argument_list|(
name|ncn
argument_list|)
expr_stmt|;
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|link
operator|+=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the tag \a t in the map of metadata values for the   current topic in \a inner. If a value for the tag is found,   the value is returned.    \note If \a t is found in the metadata map, it is erased.   i.e. Once you call this function for a particular \a t,   you consume \a t.  */
end_comment
begin_function
DECL|function|getMetadataElement
name|QString
name|Generator
operator|::
name|getMetadataElement
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|QString
name|s
decl_stmt|;
name|QStringMultiMap
modifier|&
name|metaTagMap
init|=
cast|const_cast
argument_list|<
name|QStringMultiMap
operator|&
argument_list|>
argument_list|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|metaTagMap
argument_list|()
argument_list|)
decl_stmt|;
name|QStringMultiMap
operator|::
name|iterator
name|i
init|=
name|metaTagMap
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|metaTagMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|s
operator|=
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
name|metaTagMap
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the tag \a t in the map of metadata values for the   current topic in \a inner. If values for the tag are found,   they are returned in a string list.    \note If \a t is found in the metadata map, all the pairs   having the key \a t are erased. i.e. Once you call this   function for a particular \a t, you consume \a t.  */
end_comment
begin_function
DECL|function|getMetadataElements
name|QStringList
name|Generator
operator|::
name|getMetadataElements
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|QStringList
name|s
decl_stmt|;
name|QStringMultiMap
modifier|&
name|metaTagMap
init|=
cast|const_cast
argument_list|<
name|QStringMultiMap
operator|&
argument_list|>
argument_list|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|metaTagMap
argument_list|()
argument_list|)
decl_stmt|;
name|s
operator|=
name|metaTagMap
operator|.
name|values
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|metaTagMap
operator|.
name|remove
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a relative path name for an image.  */
end_comment
begin_function
DECL|function|imageFileName
name|QString
name|Generator
operator|::
name|imageFileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileBase
parameter_list|)
block|{
name|QString
name|userFriendlyFilePath
decl_stmt|;
name|QString
name|filePath
init|=
name|Config
operator|::
name|findFile
argument_list|(
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|imageFiles
argument_list|,
name|imageDirs
argument_list|,
name|fileBase
argument_list|,
name|imgFileExts
index|[
name|format
argument_list|()
index|]
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|path
init|=
name|Config
operator|::
name|copyFile
argument_list|(
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|filePath
argument_list|,
name|userFriendlyFilePath
argument_list|,
name|outputDir
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"/images"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|images_slash
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|"images/"
argument_list|)
decl_stmt|;
name|QString
name|relImagePath
decl_stmt|;
if|if
condition|(
name|images_slash
operator|!=
operator|-
literal|1
condition|)
name|relImagePath
operator|=
name|path
operator|.
name|mid
argument_list|(
name|images_slash
argument_list|)
expr_stmt|;
return|return
name|relImagePath
return|;
block|}
end_function
begin_function
DECL|function|indent
name|QString
name|Generator
operator|::
name|indent
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
name|markedCode
return|;
name|QString
name|t
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|markedCode
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|markedCode
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|column
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|level
condition|;
name|j
operator|++
control|)
name|t
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|column
operator|++
expr_stmt|;
block|}
name|t
operator|+=
name|markedCode
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|initialize
name|void
name|Generator
operator|::
name|initialize
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|outputFormats
operator|=
name|config
operator|.
name|getOutputFormats
argument_list|()
expr_stmt|;
name|redirectDocumentationToDevNull_
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|CONFIG_REDIRECTDOCUMENTATIONTODEVNULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputFormats
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|outDir_
operator|=
name|config
operator|.
name|getOutputDir
argument_list|()
expr_stmt|;
if|if
condition|(
name|outDir_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"No output directory specified in "
literal|"configuration file or on the command line"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outSubdir_
operator|=
name|outDir_
operator|.
name|mid
argument_list|(
name|outDir_
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|QDir
name|dirInfo
decl_stmt|;
if|if
condition|(
name|dirInfo
operator|.
name|exists
argument_list|(
name|outDir_
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|runGenerateOnly
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|Config
operator|::
name|removeDirContents
argument_list|(
name|outDir_
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|error
argument_list|(
name|tr
argument_list|(
literal|"Cannot empty output directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|mkpath
argument_list|(
name|outDir_
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create output directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|exists
argument_list|(
name|outDir_
operator|+
literal|"/images"
argument_list|)
operator|&&
operator|!
name|dirInfo
operator|.
name|mkdir
argument_list|(
name|outDir_
operator|+
literal|"/images"
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create images directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
operator|+
literal|"/images"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|exists
argument_list|(
name|outDir_
operator|+
literal|"/images/used-in-examples"
argument_list|)
operator|&&
operator|!
name|dirInfo
operator|.
name|mkdir
argument_list|(
name|outDir_
operator|+
literal|"/images/used-in-examples"
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create images used in examples directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
operator|+
literal|"/images/used-in-examples"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|exists
argument_list|(
name|outDir_
operator|+
literal|"/scripts"
argument_list|)
operator|&&
operator|!
name|dirInfo
operator|.
name|mkdir
argument_list|(
name|outDir_
operator|+
literal|"/scripts"
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create scripts directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
operator|+
literal|"/scripts"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|exists
argument_list|(
name|outDir_
operator|+
literal|"/style"
argument_list|)
operator|&&
operator|!
name|dirInfo
operator|.
name|mkdir
argument_list|(
name|outDir_
operator|+
literal|"/style"
argument_list|)
condition|)
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot create style directory '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outDir_
operator|+
literal|"/style"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|imageFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_IMAGES
argument_list|)
expr_stmt|;
name|imageDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_IMAGEDIRS
argument_list|)
expr_stmt|;
name|scriptFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_SCRIPTS
argument_list|)
expr_stmt|;
name|scriptDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_SCRIPTDIRS
argument_list|)
expr_stmt|;
name|styleFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_STYLES
argument_list|)
expr_stmt|;
name|styleDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_STYLEDIRS
argument_list|)
expr_stmt|;
name|exampleDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_EXAMPLEDIRS
argument_list|)
expr_stmt|;
name|exampleImgExts
operator|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EXAMPLES
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_IMAGEEXTENSIONS
argument_list|)
expr_stmt|;
name|QString
name|imagesDotFileExtensions
init|=
name|CONFIG_IMAGES
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_FILEEXTENSIONS
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|formats
init|=
name|config
operator|.
name|subVars
argument_list|(
name|imagesDotFileExtensions
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|formats
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|formats
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|imgFileExts
index|[
operator|*
name|f
index|]
operator|=
name|config
operator|.
name|getStringList
argument_list|(
name|imagesDotFileExtensions
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|f
argument_list|)
expr_stmt|;
operator|++
name|f
expr_stmt|;
block|}
name|QList
argument_list|<
name|Generator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|g
init|=
name|generators
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|g
operator|!=
name|generators
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|outputFormats
operator|.
name|contains
argument_list|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
argument_list|)
condition|)
block|{
name|currentGenerator_
operator|=
operator|(
operator|*
name|g
operator|)
expr_stmt|;
operator|(
operator|*
name|g
operator|)
operator|->
name|initializeGenerator
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|QStringList
name|extraImages
init|=
name|config
operator|.
name|getPathList
argument_list|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_EXTRAIMAGES
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|e
init|=
name|extraImages
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|extraImages
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
operator|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
name|Config
operator|::
name|copyFile
argument_list|(
name|config
operator|.
name|lastLocation
argument_list|()
argument_list|,
name|filePath
argument_list|,
name|filePath
argument_list|,
operator|(
operator|*
name|g
operator|)
operator|->
name|outputDir
argument_list|()
operator|+
literal|"/images"
argument_list|)
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
comment|// Documentation template handling
name|QStringList
name|scripts
init|=
name|config
operator|.
name|getPathList
argument_list|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_SCRIPTS
argument_list|)
decl_stmt|;
name|e
operator|=
name|scripts
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|scripts
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
operator|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
name|Config
operator|::
name|copyFile
argument_list|(
name|config
operator|.
name|lastLocation
argument_list|()
argument_list|,
name|filePath
argument_list|,
name|filePath
argument_list|,
operator|(
operator|*
name|g
operator|)
operator|->
name|outputDir
argument_list|()
operator|+
literal|"/scripts"
argument_list|)
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
name|QStringList
name|styles
init|=
name|config
operator|.
name|getPathList
argument_list|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_STYLESHEETS
argument_list|)
decl_stmt|;
name|e
operator|=
name|styles
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|styles
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
operator|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
name|Config
operator|::
name|copyFile
argument_list|(
name|config
operator|.
name|lastLocation
argument_list|()
argument_list|,
name|filePath
argument_list|,
name|filePath
argument_list|,
operator|(
operator|*
name|g
operator|)
operator|->
name|outputDir
argument_list|()
operator|+
literal|"/style"
argument_list|)
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
block|}
operator|++
name|g
expr_stmt|;
block|}
name|QRegExp
name|secondParamAndAbove
argument_list|(
literal|"[\2-\7]"
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|formattingNames
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_FORMATTING
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|n
init|=
name|formattingNames
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|formattingNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|formattingDotName
init|=
name|CONFIG_FORMATTING
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|n
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|formats
init|=
name|config
operator|.
name|subVars
argument_list|(
name|formattingDotName
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|formats
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|formats
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|def
init|=
name|config
operator|.
name|getString
argument_list|(
name|formattingDotName
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|numParams
init|=
name|Config
operator|::
name|numParams
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|int
name|numOccs
init|=
name|def
operator|.
name|count
argument_list|(
literal|"\1"
argument_list|)
decl_stmt|;
if|if
condition|(
name|numParams
operator|!=
literal|1
condition|)
block|{
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Formatting '%1' must "
literal|"have exactly one "
literal|"parameter (found %2)"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|n
argument_list|)
operator|.
name|arg
argument_list|(
name|numParams
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numOccs
operator|>
literal|1
condition|)
block|{
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Formatting '%1' must "
literal|"contain exactly one "
literal|"occurrence of '\\1' "
literal|"(found %2)"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|n
argument_list|)
operator|.
name|arg
argument_list|(
name|numOccs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|paramPos
init|=
name|def
operator|.
name|indexOf
argument_list|(
literal|"\1"
argument_list|)
decl_stmt|;
name|fmtLeftMaps
index|[
operator|*
name|f
index|]
operator|.
name|insert
argument_list|(
operator|*
name|n
argument_list|,
name|def
operator|.
name|left
argument_list|(
name|paramPos
argument_list|)
argument_list|)
expr_stmt|;
name|fmtRightMaps
index|[
operator|*
name|f
index|]
operator|.
name|insert
argument_list|(
operator|*
name|n
argument_list|,
name|def
operator|.
name|mid
argument_list|(
name|paramPos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|f
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
name|project
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_PROJECT
argument_list|)
expr_stmt|;
name|QStringList
name|prefixes
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_OUTPUTPREFIXES
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prefixes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|prefix
decl|,
name|prefixes
control|)
name|outputPrefixes
index|[
name|prefix
index|]
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_OUTPUTPREFIXES
operator|+
name|Config
operator|::
name|dot
operator|+
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
name|outputPrefixes
index|[
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
index|]
operator|=
name|QLatin1String
argument_list|(
literal|"qml-"
argument_list|)
expr_stmt|;
name|noLinkErrors_
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_NOLINKERRORS
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Appends each directory path in \a moreImageDirs to the   list of image directories.  */
end_comment
begin_function
DECL|function|augmentImageDirs
name|void
name|Generator
operator|::
name|augmentImageDirs
parameter_list|(
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|moreImageDirs
parameter_list|)
block|{
if|if
condition|(
name|moreImageDirs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|moreImageDirs
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|moreImageDirs
operator|.
name|end
argument_list|()
condition|)
block|{
name|imageDirs
operator|.
name|append
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Sets the generator's pointer to the Config instance.  */
end_comment
begin_function
DECL|function|initializeGenerator
name|void
name|Generator
operator|::
name|initializeGenerator
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|config_
operator|=
operator|&
name|config
expr_stmt|;
block|}
end_function
begin_function
DECL|function|matchAhead
name|bool
name|Generator
operator|::
name|matchAhead
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
name|Atom
operator|::
name|Type
name|expectedAtomType
parameter_list|)
block|{
return|return
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|expectedAtomType
return|;
block|}
end_function
begin_comment
comment|/*!   Used for writing to the current output stream. Returns a   reference to the current output stream, which is then used   with the \c {<<} operator for writing.  */
end_comment
begin_function
DECL|function|out
name|QTextStream
modifier|&
name|Generator
operator|::
name|out
parameter_list|()
block|{
return|return
operator|*
name|outStreamStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|outFileName
name|QString
name|Generator
operator|::
name|outFileName
parameter_list|()
block|{
return|return
name|QFileInfo
argument_list|(
cast|static_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|out
argument_list|()
operator|.
name|device
argument_list|()
argument_list|)
operator|->
name|fileName
argument_list|()
argument_list|)
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|outputPrefix
name|QString
name|Generator
operator|::
name|outputPrefix
parameter_list|(
specifier|const
name|QString
modifier|&
name|nodeType
parameter_list|)
block|{
return|return
name|outputPrefixes
index|[
name|nodeType
index|]
return|;
block|}
end_function
begin_function
DECL|function|parseArg
name|bool
name|Generator
operator|::
name|parseArg
parameter_list|(
specifier|const
name|QString
modifier|&
name|src
parameter_list|,
specifier|const
name|QString
modifier|&
name|tag
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
name|n
parameter_list|,
name|QStringRef
modifier|*
name|contents
parameter_list|,
name|QStringRef
modifier|*
name|par1
parameter_list|,
name|bool
name|debug
parameter_list|)
block|{
DECL|macro|SKIP_CHAR
define|#
directive|define
name|SKIP_CHAR
parameter_list|(
name|c
parameter_list|)
define|\
value|if (debug) \     qDebug()<< "looking for "<< c<< " at "<< QString(src.data() + i, n - i); \     if (i>= n || src[i] != c) { \     if (debug) \     qDebug()<< " char '"<< c<< "' not found"; \     return false; \ } \     ++i;
DECL|macro|SKIP_SPACE
define|#
directive|define
name|SKIP_SPACE
define|\
value|while (i< n&& src[i] == ' ') \     ++i;
name|int
name|i
init|=
operator|*
name|pos
decl_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// assume "<@" has been parsed outside
comment|//SKIP_CHAR('<');
comment|//SKIP_CHAR('@');
if|if
condition|(
name|tag
operator|!=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|&&
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"tag "
operator|<<
name|tag
operator|<<
literal|" not found at "
operator|<<
name|i
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"haystack:"
operator|<<
name|src
operator|<<
literal|"needle:"
operator|<<
name|tag
operator|<<
literal|"i:"
operator|<<
name|i
expr_stmt|;
comment|// skip tag
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// parse stuff like:  linkTag("(<@link node=\"([^\"]+)\">).*(</@link>)");
if|if
condition|(
name|par1
condition|)
block|{
name|SKIP_SPACE
expr_stmt|;
comment|// read parameter name
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
index|[
name|i
index|]
operator|.
name|isLetter
argument_list|()
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"read parameter"
operator|<<
name|QString
argument_list|(
name|src
operator|.
name|data
argument_list|()
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|// skip parameter name
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
index|[
name|i
index|]
operator|!=
literal|'"'
condition|)
operator|++
name|i
expr_stmt|;
operator|*
name|par1
operator|=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|SKIP_SPACE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"no optional parameter found"
expr_stmt|;
block|}
block|}
name|SKIP_SPACE
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
comment|// find contents up to closing "</@tag>
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
literal|true
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|4
operator|+
name|tag
operator|.
name|length
argument_list|()
operator|>
name|n
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|!=
literal|'<'
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|'@'
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|!=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
operator|+
literal|3
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|3
operator|+
name|tag
operator|.
name|length
argument_list|()
index|]
operator|!=
literal|'>'
condition|)
continue|continue;
break|break;
block|}
operator|*
name|contents
operator|=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
operator|+
literal|4
expr_stmt|;
operator|*
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|" tag "
operator|<<
name|tag
operator|<<
literal|" found: pos now: "
operator|<<
name|i
expr_stmt|;
return|return
literal|true
return|;
DECL|macro|SKIP_CHAR
undef|#
directive|undef
name|SKIP_CHAR
block|}
end_function
begin_function
DECL|function|plainCode
name|QString
name|Generator
operator|::
name|plainCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|)
block|{
name|QString
name|t
init|=
name|markedCode
decl_stmt|;
name|t
operator|.
name|replace
argument_list|(
name|tag
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|replace
argument_list|(
name|quot
argument_list|,
name|QLatin1String
argument_list|(
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|replace
argument_list|(
name|gt
argument_list|,
name|QLatin1String
argument_list|(
literal|">"
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|replace
argument_list|(
name|lt
argument_list|,
name|QLatin1String
argument_list|(
literal|"<"
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|replace
argument_list|(
name|amp
argument_list|,
name|QLatin1String
argument_list|(
literal|"&"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|setImageFileExtensions
name|void
name|Generator
operator|::
name|setImageFileExtensions
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|extensions
parameter_list|)
block|{
name|imgFileExts
index|[
name|format
argument_list|()
index|]
operator|=
name|extensions
expr_stmt|;
block|}
end_function
begin_function
DECL|function|singularPlural
name|void
name|Generator
operator|::
name|singularPlural
parameter_list|(
name|Text
modifier|&
name|text
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
name|text
operator|<<
literal|" is"
expr_stmt|;
else|else
name|text
operator|<<
literal|" are"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|skipAtoms
name|int
name|Generator
operator|::
name|skipAtoms
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
name|Atom
operator|::
name|Type
name|type
parameter_list|)
specifier|const
block|{
name|int
name|skipAhead
init|=
literal|0
decl_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|type
condition|)
block|{
name|skipAhead
operator|++
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|skipAhead
return|;
block|}
end_function
begin_comment
comment|/*!   Resets the variables used during text output.  */
end_comment
begin_function
DECL|function|initializeTextOutput
name|void
name|Generator
operator|::
name|initializeTextOutput
parameter_list|()
block|{
name|inLink_
operator|=
literal|false
expr_stmt|;
name|inContents_
operator|=
literal|false
expr_stmt|;
name|inSectionHeading_
operator|=
literal|false
expr_stmt|;
name|inTableHeader_
operator|=
literal|false
expr_stmt|;
name|numTableRows_
operator|=
literal|0
expr_stmt|;
name|threeColumnEnumValueTable_
operator|=
literal|true
expr_stmt|;
name|link_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionNumber_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|supplementAlsoList
name|void
name|Generator
operator|::
name|supplementAlsoList
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|QList
argument_list|<
name|Text
argument_list|>
modifier|&
name|alsoList
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QString
name|alternateName
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|alternateFunc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"set"
argument_list|)
operator|&&
name|func
operator|->
name|name
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
literal|4
condition|)
block|{
name|alternateName
operator|=
name|func
operator|->
name|name
argument_list|()
index|[
literal|3
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|alternateName
operator|+=
name|func
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|alternateFunc
operator|=
name|func
operator|->
name|parent
argument_list|()
operator|->
name|findFunctionNode
argument_list|(
name|alternateName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alternateFunc
condition|)
block|{
name|alternateName
operator|=
literal|"is"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|alternateFunc
operator|=
name|func
operator|->
name|parent
argument_list|()
operator|->
name|findFunctionNode
argument_list|(
name|alternateName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alternateFunc
condition|)
block|{
name|alternateName
operator|=
literal|"has"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|alternateFunc
operator|=
name|func
operator|->
name|parent
argument_list|()
operator|->
name|findFunctionNode
argument_list|(
name|alternateName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|func
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|alternateName
operator|=
literal|"set"
expr_stmt|;
name|alternateName
operator|+=
name|func
operator|->
name|name
argument_list|()
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|alternateName
operator|+=
name|func
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alternateFunc
operator|=
name|func
operator|->
name|parent
argument_list|()
operator|->
name|findFunctionNode
argument_list|(
name|alternateName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alternateFunc
operator|&&
name|alternateFunc
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alsoList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|alsoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|alternateName
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|alsoList
operator|.
name|size
argument_list|()
condition|)
block|{
name|alternateName
operator|+=
literal|"()"
expr_stmt|;
name|Text
name|also
decl_stmt|;
name|also
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|alternateName
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|alternateName
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|alsoList
operator|.
name|prepend
argument_list|(
name|also
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|terminate
name|void
name|Generator
operator|::
name|terminate
parameter_list|()
block|{
name|QList
argument_list|<
name|Generator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|g
init|=
name|generators
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|g
operator|!=
name|generators
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|outputFormats
operator|.
name|contains
argument_list|(
operator|(
operator|*
name|g
operator|)
operator|->
name|format
argument_list|()
argument_list|)
condition|)
operator|(
operator|*
name|g
operator|)
operator|->
name|terminateGenerator
argument_list|()
expr_stmt|;
operator|++
name|g
expr_stmt|;
block|}
name|fmtLeftMaps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fmtRightMaps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|imgFileExts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|imageFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|imageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outDir_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QmlClassNode
operator|::
name|terminate
argument_list|()
expr_stmt|;
name|ExampleNode
operator|::
name|terminate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|terminateGenerator
name|void
name|Generator
operator|::
name|terminateGenerator
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   Trims trailing whitespace off the \a string and returns   the trimmed string.  */
end_comment
begin_function
DECL|function|trimmedTrailing
name|QString
name|Generator
operator|::
name|trimmedTrailing
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|QString
name|trimmed
init|=
name|string
decl_stmt|;
while|while
condition|(
name|trimmed
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|trimmed
index|[
name|trimmed
operator|.
name|length
argument_list|()
operator|-
literal|1
index|]
operator|.
name|isSpace
argument_list|()
condition|)
name|trimmed
operator|.
name|truncate
argument_list|(
name|trimmed
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|trimmed
return|;
block|}
end_function
begin_function
DECL|function|typeString
name|QString
name|Generator
operator|::
name|typeString
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
return|return
literal|"namespace"
return|;
case|case
name|Node
operator|::
name|Class
case|:
return|return
literal|"class"
return|;
case|case
name|Node
operator|::
name|Document
case|:
block|{
switch|switch
condition|(
name|node
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlClass
case|:
return|return
literal|"type"
return|;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
return|return
literal|"type"
return|;
default|default:
return|return
literal|"documentation"
return|;
block|}
block|}
case|case
name|Node
operator|::
name|Enum
case|:
return|return
literal|"enum"
return|;
case|case
name|Node
operator|::
name|Typedef
case|:
return|return
literal|"typedef"
return|;
case|case
name|Node
operator|::
name|Function
case|:
return|return
literal|"function"
return|;
case|case
name|Node
operator|::
name|Property
case|:
return|return
literal|"property"
return|;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
return|return
literal|"property group"
return|;
case|case
name|Node
operator|::
name|QmlProperty
case|:
return|return
literal|"QML property"
return|;
case|case
name|Node
operator|::
name|QmlSignal
case|:
return|return
literal|"QML signal"
return|;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
return|return
literal|"QML signal handler"
return|;
case|case
name|Node
operator|::
name|QmlMethod
case|:
return|return
literal|"QML method"
return|;
default|default:
return|return
literal|"documentation"
return|;
block|}
block|}
end_function
begin_function
DECL|function|unknownAtom
name|void
name|Generator
operator|::
name|unknownAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
name|Location
operator|::
name|internalError
argument_list|(
name|tr
argument_list|(
literal|"unknown atom type '%1' in %2 generator"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|typeString
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|format
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
