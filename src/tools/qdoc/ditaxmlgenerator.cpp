begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   ditaxmlgenerator.cpp */
end_comment
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QList>
end_include
begin_include
include|#
directive|include
file|<qiterator.h>
end_include
begin_include
include|#
directive|include
file|<QTextCodec>
end_include
begin_include
include|#
directive|include
file|<QUuid>
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"codeparser.h"
end_include
begin_include
include|#
directive|include
file|"ditaxmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"quoter.h"
end_include
begin_include
include|#
directive|include
file|"separator.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|COMMAND_VERSION
define|#
directive|define
name|COMMAND_VERSION
value|Doc::alias("version")
DECL|member|id
name|int
name|DitaXmlGenerator
operator|::
name|id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   The strings in this array must appear in the same order as   the values in enum DitaXmlGenerator::DitaTag.  */
end_comment
begin_decl_stmt
DECL|member|ditaTags
name|QString
name|DitaXmlGenerator
operator|::
name|ditaTags
index|[]
init|=
block|{
literal|""
block|,
literal|"alt"
block|,
literal|"apiDesc"
block|,
literal|"APIMap"
block|,
literal|"apiName"
block|,
literal|"apiRelation"
block|,
literal|"audience"
block|,
literal|"author"
block|,
literal|"b"
block|,
literal|"body"
block|,
literal|"bodydiv"
block|,
literal|"brand"
block|,
literal|"category"
block|,
literal|"codeblock"
block|,
literal|"comment"
block|,
literal|"component"
block|,
literal|"copyrholder"
block|,
literal|"copyright"
block|,
literal|"copyryear"
block|,
literal|"created"
block|,
literal|"critdates"
block|,
literal|"cxxAPIMap"
block|,
literal|"cxxClass"
block|,
literal|"cxxClassAbstract"
block|,
literal|"cxxClassAccessSpecifier"
block|,
literal|"cxxClassAPIItemLocation"
block|,
literal|"cxxClassBaseClass"
block|,
literal|"cxxClassDeclarationFile"
block|,
literal|"cxxClassDeclarationFileLine"
block|,
literal|"cxxClassDeclarationFileLineStart"
block|,
literal|"cxxClassDeclarationFileLineEnd"
block|,
literal|"cxxClassDefinition"
block|,
literal|"cxxClassDerivation"
block|,
literal|"cxxClassDerivationAccessSpecifier"
block|,
literal|"cxxClassDerivations"
block|,
literal|"cxxClassDetail"
block|,
literal|"cxxClassNested"
block|,
literal|"cxxClassNestedClass"
block|,
literal|"cxxClassNestedDetail"
block|,
literal|"cxxDefine"
block|,
literal|"cxxDefineAccessSpecifier"
block|,
literal|"cxxDefineAPIItemLocation"
block|,
literal|"cxxDefineDeclarationFile"
block|,
literal|"cxxDefineDeclarationFileLine"
block|,
literal|"cxxDefineDefinition"
block|,
literal|"cxxDefineDetail"
block|,
literal|"cxxDefineNameLookup"
block|,
literal|"cxxDefineParameter"
block|,
literal|"cxxDefineParameterDeclarationName"
block|,
literal|"cxxDefineParameters"
block|,
literal|"cxxDefinePrototype"
block|,
literal|"cxxDefineReimplemented"
block|,
literal|"cxxEnumeration"
block|,
literal|"cxxEnumerationAccessSpecifier"
block|,
literal|"cxxEnumerationAPIItemLocation"
block|,
literal|"cxxEnumerationDeclarationFile"
block|,
literal|"cxxEnumerationDeclarationFileLine"
block|,
literal|"cxxEnumerationDeclarationFileLineStart"
block|,
literal|"cxxEnumerationDeclarationFileLineEnd"
block|,
literal|"cxxEnumerationDefinition"
block|,
literal|"cxxEnumerationDetail"
block|,
literal|"cxxEnumerationNameLookup"
block|,
literal|"cxxEnumerationPrototype"
block|,
literal|"cxxEnumerationScopedName"
block|,
literal|"cxxEnumerator"
block|,
literal|"cxxEnumeratorInitialiser"
block|,
literal|"cxxEnumeratorNameLookup"
block|,
literal|"cxxEnumeratorPrototype"
block|,
literal|"cxxEnumerators"
block|,
literal|"cxxEnumeratorScopedName"
block|,
literal|"cxxFunction"
block|,
literal|"cxxFunctionAccessSpecifier"
block|,
literal|"cxxFunctionAPIItemLocation"
block|,
literal|"cxxFunctionConst"
block|,
literal|"cxxFunctionConstructor"
block|,
literal|"cxxFunctionDeclarationFile"
block|,
literal|"cxxFunctionDeclarationFileLine"
block|,
literal|"cxxFunctionDeclaredType"
block|,
literal|"cxxFunctionDefinition"
block|,
literal|"cxxFunctionDestructor"
block|,
literal|"cxxFunctionDetail"
block|,
literal|"cxxFunctionNameLookup"
block|,
literal|"cxxFunctionParameter"
block|,
literal|"cxxFunctionParameterDeclarationName"
block|,
literal|"cxxFunctionParameterDeclaredType"
block|,
literal|"cxxFunctionParameterDefaultValue"
block|,
literal|"cxxFunctionParameters"
block|,
literal|"cxxFunctionPrototype"
block|,
literal|"cxxFunctionPureVirtual"
block|,
literal|"cxxFunctionReimplemented"
block|,
literal|"cxxFunctionScopedName"
block|,
literal|"cxxFunctionStorageClassSpecifierStatic"
block|,
literal|"cxxFunctionVirtual"
block|,
literal|"cxxTypedef"
block|,
literal|"cxxTypedefAccessSpecifier"
block|,
literal|"cxxTypedefAPIItemLocation"
block|,
literal|"cxxTypedefDeclarationFile"
block|,
literal|"cxxTypedefDeclarationFileLine"
block|,
literal|"cxxTypedefDefinition"
block|,
literal|"cxxTypedefDetail"
block|,
literal|"cxxTypedefNameLookup"
block|,
literal|"cxxTypedefScopedName"
block|,
literal|"cxxVariable"
block|,
literal|"cxxVariableAccessSpecifier"
block|,
literal|"cxxVariableAPIItemLocation"
block|,
literal|"cxxVariableDeclarationFile"
block|,
literal|"cxxVariableDeclarationFileLine"
block|,
literal|"cxxVariableDeclaredType"
block|,
literal|"cxxVariableDefinition"
block|,
literal|"cxxVariableDetail"
block|,
literal|"cxxVariableNameLookup"
block|,
literal|"cxxVariablePrototype"
block|,
literal|"cxxVariableReimplemented"
block|,
literal|"cxxVariableScopedName"
block|,
literal|"cxxVariableStorageClassSpecifierStatic"
block|,
literal|"data"
block|,
literal|"data-about"
block|,
literal|"dd"
block|,
literal|"dl"
block|,
literal|"dlentry"
block|,
literal|"dt"
block|,
literal|"entry"
block|,
literal|"fig"
block|,
literal|"i"
block|,
literal|"image"
block|,
literal|"keyword"
block|,
literal|"keywords"
block|,
literal|"li"
block|,
literal|"link"
block|,
literal|"linktext"
block|,
literal|"lq"
block|,
literal|"map"
block|,
literal|"mapref"
block|,
literal|"metadata"
block|,
literal|"note"
block|,
literal|"ol"
block|,
literal|"othermeta"
block|,
literal|"p"
block|,
literal|"parameter"
block|,
literal|"permissions"
block|,
literal|"ph"
block|,
literal|"platform"
block|,
literal|"pre"
block|,
literal|"prodinfo"
block|,
literal|"prodname"
block|,
literal|"prolog"
block|,
literal|"publisher"
block|,
literal|"related-links"
block|,
literal|"resourceid"
block|,
literal|"revised"
block|,
literal|"row"
block|,
literal|"section"
block|,
literal|"sectiondiv"
block|,
literal|"shortdesc"
block|,
literal|"simpletable"
block|,
literal|"source"
block|,
literal|"stentry"
block|,
literal|"sthead"
block|,
literal|"strow"
block|,
literal|"sub"
block|,
literal|"sup"
block|,
literal|"table"
block|,
literal|"tbody"
block|,
literal|"tgroup"
block|,
literal|"thead"
block|,
literal|"title"
block|,
literal|"tm"
block|,
literal|"topic"
block|,
literal|"topicmeta"
block|,
literal|"topicref"
block|,
literal|"tt"
block|,
literal|"u"
block|,
literal|"uicontrol"
block|,
literal|"ul"
block|,
literal|"unknown"
block|,
literal|"vrm"
block|,
literal|"vrmlist"
block|,
literal|"xref"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|showBrokenLinks
specifier|static
name|bool
name|showBrokenLinks
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Quick, dirty, and very ugly. Unescape \a text   so QXmlStreamWriter::writeCharacters() can put   the escapes back in again!  */
end_comment
begin_function
DECL|function|writeCharacters
name|void
name|DitaXmlGenerator
operator|::
name|writeCharacters
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|QString
name|t
init|=
name|text
decl_stmt|;
name|t
operator|=
name|t
operator|.
name|replace
argument_list|(
literal|"&lt;"
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|replace
argument_list|(
literal|"&gt;"
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|replace
argument_list|(
literal|"&amp;"
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|replace
argument_list|(
literal|"&quot;"
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Appends an<xref> element to the current XML stream   with the \a href attribute and the \a text.  */
end_comment
begin_function
DECL|function|addLink
name|void
name|DitaXmlGenerator
operator|::
name|addLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|href
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|text
parameter_list|,
name|DitaTag
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|href
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// formathtml
name|writeHrefAttribute
argument_list|(
name|href
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</t>
block|}
else|else
block|{
name|writeCharacters
argument_list|(
name|text
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Push \a t onto the dita tag stack and write the appropriate   start tag to the DITA XML file.  */
end_comment
begin_function
DECL|function|writeStartTag
name|void
name|DitaXmlGenerator
operator|::
name|writeStartTag
parameter_list|(
name|DitaTag
name|t
parameter_list|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
name|ditaTags
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|tagStack
operator|.
name|push
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Pop the current DITA tag off the stack, and write the   appropriate end tag to the DITA XML file. If \a t is   not \e DT_NONE (default), then \a t contains the enum   value of the tag that should be on top of the stack.    If the stack is empty, no end tag is written and false   is returned. Otherwise, an end tag is written and true   is returned.  */
end_comment
begin_function
DECL|function|writeEndTag
name|bool
name|DitaXmlGenerator
operator|::
name|writeEndTag
parameter_list|(
name|DitaTag
name|t
parameter_list|)
block|{
if|if
condition|(
name|tagStack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|DitaTag
name|top
init|=
name|tagStack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|DT_NONE
operator|&&
name|top
operator|!=
name|t
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"Expected:"
operator|<<
name|t
operator|<<
literal|"ACTUAL:"
operator|<<
name|top
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Return the current DITA element tag, the one   on top of the stack.  */
end_comment
begin_function
DECL|function|currentTag
name|DitaXmlGenerator
operator|::
name|DitaTag
name|DitaXmlGenerator
operator|::
name|currentTag
parameter_list|()
block|{
return|return
name|tagStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Write the start tag \c{<apiDesc>}. if \a title is not   empty, generate a GUID from it and write the GUID as the   value of the \e{id} attribute.    Then if \a outputclass is not empty, write it as the value   of the \a outputclass attribute.    Fiunally, set the section nesting level to 1 and return 1.  */
end_comment
begin_function
DECL|function|enterApiDesc
name|int
name|DitaXmlGenerator
operator|::
name|enterApiDesc
parameter_list|(
specifier|const
name|QString
modifier|&
name|outputclass
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|writeStartTag
argument_list|(
name|DT_apiDesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeGuidAttribute
argument_list|(
name|title
argument_list|)
expr_stmt|;
comment|//Are there cases where the spectitle is required?
comment|//xmlWriter().writeAttribute("spectitle",title);
block|}
if|if
condition|(
operator|!
name|outputclass
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|outputclass
argument_list|)
expr_stmt|;
name|sectionNestingLevel
operator|=
literal|1
expr_stmt|;
return|return
name|sectionNestingLevel
return|;
block|}
end_function
begin_comment
comment|/*!   If the section nesting level is 0, output a \c{<section>}   element with an \e id attribute generated from \a title and   an \e outputclass attribute set to \a outputclass.   If \a title is null, no \e id attribute is output.   If \a outputclass is empty, no \e outputclass attribute   is output.    Finally, increment the section nesting level and return   the new value.  */
end_comment
begin_function
DECL|function|enterSection
name|int
name|DitaXmlGenerator
operator|::
name|enterSection
parameter_list|(
specifier|const
name|QString
modifier|&
name|outputclass
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
if|if
condition|(
name|sectionNestingLevel
operator|==
literal|0
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeGuidAttribute
argument_list|(
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputclass
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|outputclass
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputclass
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|outputclass
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
return|return
operator|++
name|sectionNestingLevel
return|;
block|}
end_function
begin_comment
comment|/*!   If the section nesting level is greater than 0, decrement   it. If it becomes 0, output a \c {</section>}. Return the   decremented section nesting level.  */
end_comment
begin_function
DECL|function|leaveSection
name|int
name|DitaXmlGenerator
operator|::
name|leaveSection
parameter_list|()
block|{
if|if
condition|(
name|sectionNestingLevel
operator|>
literal|0
condition|)
block|{
operator|--
name|sectionNestingLevel
expr_stmt|;
if|if
condition|(
name|sectionNestingLevel
operator|==
literal|0
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</section> or</apiDesc>
block|}
return|return
name|sectionNestingLevel
return|;
block|}
end_function
begin_comment
comment|/*!   The default constructor.  */
end_comment
begin_constructor
DECL|function|DitaXmlGenerator
name|DitaXmlGenerator
operator|::
name|DitaXmlGenerator
parameter_list|()
member_init_list|:
name|inContents
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inDetailedDescription
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inLegaleseText
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inLink
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inObsoleteLink
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inSectionHeading
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inTableHeader
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inTableBody
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|noLinks
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|obsoleteLinks
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|offlineDocs
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|threeColumnEnumValueTable
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|codeIndent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|numTableRows
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|divNestingLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sectionNestingLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|tableColumnCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|funcLeftParen
argument_list|(
literal|"\\S(\\()"
argument_list|)
member_init_list|,
name|tree_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|nodeTypeMaps
argument_list|(
name|Node
operator|::
name|LastType
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|nodeSubtypeMaps
argument_list|(
name|Node
operator|::
name|LastSubtype
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|pageTypeMaps
argument_list|(
name|Node
operator|::
name|OnBeyondZebra
argument_list|,
literal|0
argument_list|)
block|{
comment|// nothing yet.
block|}
end_constructor
begin_comment
comment|/*!   The destructor has nothing to do.  */
end_comment
begin_destructor
DECL|function|~DitaXmlGenerator
name|DitaXmlGenerator
operator|::
name|~
name|DitaXmlGenerator
parameter_list|()
block|{
name|GuidMaps
operator|::
name|iterator
name|i
init|=
name|guidMaps
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|guidMaps
operator|.
name|end
argument_list|()
condition|)
block|{
operator|delete
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!   A lot of internal structures are initialized.  */
end_comment
begin_function
DECL|function|initializeGenerator
name|void
name|DitaXmlGenerator
operator|::
name|initializeGenerator
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|Generator
operator|::
name|initializeGenerator
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|obsoleteLinks
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OBSOLETELINKS
argument_list|)
argument_list|)
expr_stmt|;
name|setImageFileExtensions
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"png"
operator|<<
literal|"jpg"
operator|<<
literal|"jpeg"
operator|<<
literal|"gif"
argument_list|)
expr_stmt|;
name|style
operator|=
name|config
operator|.
name|getString
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_STYLE
argument_list|)
expr_stmt|;
name|postHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_POSTHEADER
argument_list|)
expr_stmt|;
name|postPostHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_POSTPOSTHEADER
argument_list|)
expr_stmt|;
name|footer
operator|=
name|config
operator|.
name|getString
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_FOOTER
argument_list|)
expr_stmt|;
name|address
operator|=
name|config
operator|.
name|getString
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_ADDRESS
argument_list|)
expr_stmt|;
name|pleaseGenerateMacRef
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_GENERATEMACREFS
argument_list|)
expr_stmt|;
name|project
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_PROJECT
argument_list|)
expr_stmt|;
name|projectDescription
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_DESCRIPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|projectDescription
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|projectDescription
operator|=
name|project
operator|+
literal|" Reference Documentation"
expr_stmt|;
name|projectUrl
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_URL
argument_list|)
expr_stmt|;
name|outputEncoding
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_OUTPUTENCODING
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputEncoding
operator|.
name|isEmpty
argument_list|()
condition|)
name|outputEncoding
operator|=
name|QLatin1String
argument_list|(
literal|"ISO-8859-1"
argument_list|)
expr_stmt|;
name|outputCodec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|outputEncoding
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
name|naturalLanguage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NATURALLANGUAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|naturalLanguage
operator|.
name|isEmpty
argument_list|()
condition|)
name|naturalLanguage
operator|=
name|QLatin1String
argument_list|(
literal|"en"
argument_list|)
expr_stmt|;
name|config
operator|.
name|subVarsAndValues
argument_list|(
literal|"dita.metadata.default"
argument_list|,
name|metadataDefaults
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|editionNames
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_EDITION
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|edition
init|=
name|editionNames
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|edition
operator|!=
name|editionNames
operator|.
name|end
argument_list|()
condition|)
block|{
name|QString
name|editionName
init|=
operator|*
name|edition
decl_stmt|;
name|QStringList
name|editionModules
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"modules"
argument_list|)
decl_stmt|;
name|QStringList
name|editionGroups
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"groups"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|editionModules
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionModuleMap
index|[
name|editionName
index|]
operator|=
name|editionModules
expr_stmt|;
if|if
condition|(
operator|!
name|editionGroups
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionGroupMap
index|[
name|editionName
index|]
operator|=
name|editionGroups
expr_stmt|;
operator|++
name|edition
expr_stmt|;
block|}
name|stylesheets
operator|=
name|config
operator|.
name|getStringList
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_STYLESHEETS
argument_list|)
expr_stmt|;
name|customHeadElements
operator|=
name|config
operator|.
name|getStringList
argument_list|(
name|DitaXmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|DITAXMLGENERATOR_CUSTOMHEADELEMENTS
argument_list|)
expr_stmt|;
name|codeIndent
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|CONFIG_CODEINDENT
argument_list|)
expr_stmt|;
name|version
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_VERSION
argument_list|)
expr_stmt|;
name|vrm
operator|=
name|version
operator|.
name|split
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   All this does is call the same function in the base class.  */
end_comment
begin_function
DECL|function|terminateGenerator
name|void
name|DitaXmlGenerator
operator|::
name|terminateGenerator
parameter_list|()
block|{
name|Generator
operator|::
name|terminateGenerator
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns "DITAXML".  */
end_comment
begin_function
DECL|function|format
name|QString
name|DitaXmlGenerator
operator|::
name|format
parameter_list|()
block|{
return|return
literal|"DITAXML"
return|;
block|}
end_function
begin_comment
comment|/*!   Calls lookupGuid() to get a GUID for \a text, then writes   it to the XML stream as an "id" attribute, and returns it.  */
end_comment
begin_function
DECL|function|writeGuidAttribute
name|QString
name|DitaXmlGenerator
operator|::
name|writeGuidAttribute
parameter_list|(
name|QString
name|text
parameter_list|)
block|{
name|QString
name|guid
init|=
name|lookupGuid
argument_list|(
name|outFileName
argument_list|()
argument_list|,
name|text
argument_list|)
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
name|guid
return|;
block|}
end_function
begin_comment
comment|/*!   Write's the GUID for the \a node to the current XML stream   as an "id" attribute. If the \a node doesn't yet have a GUID,   one is generated.  */
end_comment
begin_function
DECL|function|writeGuidAttribute
name|void
name|DitaXmlGenerator
operator|::
name|writeGuidAttribute
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|node
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Looks up \a text in the GUID map. If it finds \a text,   it returns the associated GUID. Otherwise it inserts   \a text into the map with a new GUID, and it returns   the new GUID.  */
end_comment
begin_function
DECL|function|lookupGuid
name|QString
name|DitaXmlGenerator
operator|::
name|lookupGuid
parameter_list|(
name|QString
name|text
parameter_list|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|name2guidMap
operator|.
name|find
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|name2guidMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
if|#
directive|if
literal|0
block|QString t = QUuid::createUuid().toString();     QString guid = "id-" + t.mid(1,t.length()-2);
endif|#
directive|endif
name|QString
name|guid
init|=
name|Node
operator|::
name|cleanId
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|name2guidMap
operator|.
name|insert
argument_list|(
name|text
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
name|guid
return|;
block|}
end_function
begin_comment
comment|/*!   First, look up the GUID map for \a fileName. If there isn't   a GUID map for \a fileName, create one and insert it into   the map of GUID maps. Then look up \a text in that GUID map.   If \a text is found, return the associated GUID. Otherwise,   insert \a text into the GUID map with a new GUID, and return   the new GUID.  */
end_comment
begin_function
DECL|function|lookupGuid
name|QString
name|DitaXmlGenerator
operator|::
name|lookupGuid
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|GuidMap
modifier|*
name|gm
init|=
name|lookupGuidMap
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|GuidMap
operator|::
name|const_iterator
name|i
init|=
name|gm
operator|->
name|find
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|gm
operator|->
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
if|#
directive|if
literal|0
block|QString t = QUuid::createUuid().toString();     QString guid = "id-" + t.mid(1,t.length()-2);
endif|#
directive|endif
name|QString
name|guid
init|=
name|Node
operator|::
name|cleanId
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|gm
operator|->
name|insert
argument_list|(
name|text
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
name|guid
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up \a fileName in the map of GUID maps. If it finds   \a fileName, it returns a pointer to the associated GUID   map. Otherwise it creates a new GUID map and inserts it   into the map of GUID maps with \a fileName as its key.  */
end_comment
begin_function
DECL|function|lookupGuidMap
name|GuidMap
modifier|*
name|DitaXmlGenerator
operator|::
name|lookupGuidMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|GuidMaps
operator|::
name|const_iterator
name|i
init|=
name|guidMaps
operator|.
name|find
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|guidMaps
operator|.
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
name|GuidMap
modifier|*
name|gm
init|=
operator|new
name|GuidMap
decl_stmt|;
name|guidMaps
operator|.
name|insert
argument_list|(
name|fileName
argument_list|,
name|gm
argument_list|)
expr_stmt|;
return|return
name|gm
return|;
block|}
end_function
begin_comment
comment|/*!   This is where the DITA XML files are written.   \note The file is created in PageGenerator::generateTree().  */
end_comment
begin_function
DECL|function|generateTree
name|void
name|DitaXmlGenerator
operator|::
name|generateTree
parameter_list|(
specifier|const
name|Tree
modifier|*
name|tree
parameter_list|)
block|{
name|tree_
operator|=
name|tree
expr_stmt|;
name|nonCompatClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mainClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|compatClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|obsoleteClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleClassMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moduleNamespaceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|funcIndex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|legaleseTexts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|serviceClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qmlClasses
operator|.
name|clear
argument_list|()
expr_stmt|;
name|findAllClasses
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllFunctions
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllLegaleseTexts
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllNamespaces
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|findAllSince
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|Generator
operator|::
name|generateTree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|writeDitaMap
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startText
name|void
name|DitaXmlGenerator
operator|::
name|startText
parameter_list|(
specifier|const
name|Node
modifier|*
comment|/* relative */
parameter_list|,
name|CodeMarker
modifier|*
comment|/* marker */
parameter_list|)
block|{
name|inLink
operator|=
literal|false
expr_stmt|;
name|inContents
operator|=
literal|false
expr_stmt|;
name|inSectionHeading
operator|=
literal|false
expr_stmt|;
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|numTableRows
operator|=
literal|0
expr_stmt|;
name|threeColumnEnumValueTable
operator|=
literal|true
expr_stmt|;
name|link
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionNumber
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|countTableColumns
specifier|static
name|int
name|countTableColumns
parameter_list|(
specifier|const
name|Atom
modifier|*
name|t
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|TableHeaderLeft
condition|)
block|{
while|while
condition|(
name|t
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|TableHeaderLeft
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|t
operator|=
name|t
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|TableHeaderRight
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|TableItemLeft
condition|)
operator|++
name|count
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|result
condition|)
name|result
operator|=
name|count
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|TableRowLeft
condition|)
block|{
while|while
condition|(
name|t
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|TableRowRight
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|TableItemLeft
condition|)
operator|++
name|result
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Generate html from an instance of Atom.  */
end_comment
begin_function
DECL|function|generateAtom
name|int
name|DitaXmlGenerator
operator|::
name|generateAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|int
name|skipAhead
init|=
literal|0
decl_stmt|;
name|QString
name|hx
decl_stmt|,
name|str
decl_stmt|;
specifier|static
name|bool
name|in_para
init|=
literal|false
decl_stmt|;
name|QString
name|guid
decl_stmt|,
name|hc
decl_stmt|,
name|attr
decl_stmt|;
switch|switch
condition|(
name|atom
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Atom
operator|::
name|AbstractLeft
case|:
break|break;
case|case
name|Atom
operator|::
name|AbstractRight
case|:
break|break;
case|case
name|Atom
operator|::
name|AutoLink
case|:
if|if
condition|(
operator|!
name|noLinks
operator|&&
operator|!
name|inLink
operator|&&
operator|!
name|inContents
operator|&&
operator|!
name|inSectionHeading
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|link
init|=
name|getLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|beginLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|generateLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|endLink
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BaseName
case|:
break|break;
case|case
name|Atom
operator|::
name|BriefLeft
case|:
comment|//if (relative->type() == Node::Fake) {
comment|//skipAhead = skipAtoms(atom, Atom::BriefRight);
comment|//break;
comment|//}
if|if
condition|(
name|inSection
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"brief"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|noLinks
operator|=
literal|true
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_shortdesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
operator|||
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"This "
argument_list|)
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"property"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"variable"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" holds "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noLinks
condition|)
block|{
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|BriefRight
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|AutoLink
condition|)
name|str
operator|+=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|skipAhead
operator|++
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
name|str
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|str
operator|.
name|truncate
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|str
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BriefRight
case|:
comment|//        if (relative->type() != Node::Fake)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</shortdesc> or</p>
name|noLinks
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|C
case|:
name|writeStartTag
argument_list|(
name|DT_tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|inLink
condition|)
block|{
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeText
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|// see writeStartElement() above
break|break;
case|case
name|Atom
operator|::
name|Code
case|:
block|{
name|writeStartTag
argument_list|(
name|DT_codeblock
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"cpp"
argument_list|)
expr_stmt|;
name|QString
name|chars
init|=
name|trimmedTrailing
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|writeText
argument_list|(
name|chars
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</codeblock>
block|}
break|break;
case|case
name|Atom
operator|::
name|Qml
case|:
name|writeStartTag
argument_list|(
name|DT_codeblock
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"qml"
argument_list|)
expr_stmt|;
name|writeText
argument_list|(
name|trimmedTrailing
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</codeblock>
break|break;
case|case
name|Atom
operator|::
name|CodeNew
case|:
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"you can rewrite it as"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|writeStartTag
argument_list|(
name|DT_codeblock
argument_list|)
expr_stmt|;
name|writeText
argument_list|(
name|trimmedTrailing
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</codeblock>
break|break;
case|case
name|Atom
operator|::
name|CodeOld
case|:
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"For example, if you have code like"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
comment|// fallthrough
case|case
name|Atom
operator|::
name|CodeBad
case|:
name|writeStartTag
argument_list|(
name|DT_codeblock
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|trimmedTrailing
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</codeblock>
break|break;
case|case
name|Atom
operator|::
name|DivLeft
case|:
block|{
name|bool
name|inStartElement
init|=
literal|false
decl_stmt|;
name|attr
operator|=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|DitaTag
name|t
init|=
name|currentTag
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|==
name|DT_section
operator|)
operator|||
operator|(
name|t
operator|==
name|DT_sectiondiv
operator|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_sectiondiv
argument_list|)
expr_stmt|;
name|divNestingLevel
operator|++
expr_stmt|;
name|inStartElement
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|==
name|DT_body
operator|)
operator|||
operator|(
name|t
operator|==
name|DT_bodydiv
operator|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_bodydiv
argument_list|)
expr_stmt|;
name|divNestingLevel
operator|++
expr_stmt|;
name|inStartElement
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|attr
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
name|QString
name|values
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|++
name|index
expr_stmt|;
name|from
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|from
condition|)
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|values
operator|+=
name|attr
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|index
operator|-
name|from
argument_list|)
expr_stmt|;
name|from
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|attr
operator|=
name|values
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inStartElement
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|DivRight
case|:
if|if
condition|(
operator|(
name|currentTag
argument_list|()
operator|==
name|DT_sectiondiv
operator|)
operator|||
operator|(
name|currentTag
argument_list|()
operator|==
name|DT_bodydiv
operator|)
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sectiondiv>,</bodydiv>, or</p>
if|if
condition|(
name|divNestingLevel
operator|>
literal|0
condition|)
operator|--
name|divNestingLevel
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|FootnoteLeft
case|:
comment|// ### For now
if|if
condition|(
name|in_para
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"<!-- "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FootnoteRight
case|:
comment|// ### For now
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FormatElse
case|:
case|case
name|Atom
operator|::
name|FormatEndif
case|:
case|case
name|Atom
operator|::
name|FormatIf
case|:
break|break;
case|case
name|Atom
operator|::
name|FormattingLeft
case|:
block|{
name|DitaTag
name|t
init|=
name|DT_LAST
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_BOLD
condition|)
name|t
operator|=
name|DT_b
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_PARAMETER
condition|)
name|t
operator|=
name|DT_i
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_ITALIC
condition|)
name|t
operator|=
name|DT_i
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_TELETYPE
condition|)
name|t
operator|=
name|DT_tt
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"span "
argument_list|)
condition|)
block|{
name|t
operator|=
name|DT_keyword
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_UICONTROL
condition|)
name|t
operator|=
name|DT_uicontrol
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_UNDERLINE
condition|)
name|t
operator|=
name|DT_u
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_INDEX
condition|)
name|t
operator|=
name|DT_comment
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_SUBSCRIPT
condition|)
name|t
operator|=
name|DT_sub
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_SUPERSCRIPT
condition|)
name|t
operator|=
name|DT_sup
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"DT_LAST"
expr_stmt|;
name|writeStartTag
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_PARAMETER
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
block|{
name|QRegExp
name|subscriptRegExp
argument_list|(
literal|"([a-z]+)_([0-9n])"
argument_list|)
decl_stmt|;
if|if
condition|(
name|subscriptRegExp
operator|.
name|exactMatch
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_sub
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sub>
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|DT_keyword
condition|)
block|{
name|QString
name|attr
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|attr
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
name|QString
name|values
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|++
name|index
expr_stmt|;
name|from
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|from
condition|)
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|values
operator|+=
name|attr
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|index
operator|-
name|from
argument_list|)
expr_stmt|;
name|from
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|attr
operator|=
name|values
expr_stmt|;
block|}
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|FormattingRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_LINK
condition|)
block|{
name|endLink
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|// ?
block|}
break|break;
case|case
name|Atom
operator|::
name|AnnotatedList
case|:
block|{
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|values
init|=
name|tree_
operator|->
name|groups
argument_list|()
operator|.
name|values
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|NodeMap
name|nodeMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
operator|&&
operator|(
name|n
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
condition|)
block|{
name|nodeMap
operator|.
name|insert
argument_list|(
name|n
operator|->
name|nameForLists
argument_list|()
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nodeMap
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|GeneratedList
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"annotatedclasses"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nonCompatClasses
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classes"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nonCompatClasses
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"qmlclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|qmlClasses
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"classesbymodule"
argument_list|)
condition|)
block|{
name|QString
name|arg
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QString
name|moduleName
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"classesbymodule"
argument_list|)
operator|+
literal|15
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|moduleClassMap
operator|.
name|contains
argument_list|(
name|moduleName
argument_list|)
condition|)
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|moduleClassMap
index|[
name|moduleName
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"classesbyedition"
argument_list|)
condition|)
block|{
name|QString
name|arg
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QString
name|editionName
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"classesbyedition"
argument_list|)
operator|+
literal|16
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|editionModuleMap
operator|.
name|contains
argument_list|(
name|editionName
argument_list|)
condition|)
block|{
comment|// Add all classes in the modules listed for that edition.
name|NodeMap
name|editionClasses
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|moduleName
decl|,
name|editionModuleMap
index|[
name|editionName
index|]
control|)
block|{
if|if
condition|(
name|moduleClassMap
operator|.
name|contains
argument_list|(
name|moduleName
argument_list|)
condition|)
name|editionClasses
operator|.
name|unite
argument_list|(
name|moduleClassMap
index|[
name|moduleName
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Add additional groups and remove groups of classes that
comment|// should be excluded from the edition.
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
name|groups
init|=
name|tree_
operator|->
name|groups
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|groupName
decl|,
name|editionGroupMap
index|[
name|editionName
index|]
control|)
block|{
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|groupClasses
decl_stmt|;
if|if
condition|(
name|groupName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|)
block|{
name|groupClasses
operator|=
name|groups
operator|.
name|values
argument_list|(
name|groupName
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|groupClasses
control|)
name|editionClasses
operator|.
name|remove
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|groupClasses
operator|=
name|groups
operator|.
name|values
argument_list|(
name|groupName
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|groupClasses
control|)
name|editionClasses
operator|.
name|insert
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|editionClasses
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classhierarchy"
condition|)
block|{
name|generateClassHierarchy
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nonCompatClasses
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"compatclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|compatClasses
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoleteclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|obsoleteClasses
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"functionindex"
condition|)
block|{
name|generateFunctionIndex
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"legalese"
condition|)
block|{
name|generateLegaleseList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"mainclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|mainClasses
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"services"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|serviceClasses
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"overviews"
condition|)
block|{
name|generateOverviewList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"namespaces"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|namespaceIndex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"related"
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fake
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|fake
operator|&&
operator|!
name|fake
operator|->
name|groupMembers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
name|groupMembersMap
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|fake
operator|->
name|groupMembers
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
name|groupMembersMap
index|[
name|fullName
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
index|]
operator|=
name|node
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|,
name|groupMembersMap
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|SinceList
case|:
block|{
name|NewSinceMaps
operator|::
name|const_iterator
name|nsmap
decl_stmt|;
name|nsmap
operator|=
name|newSinceMaps
operator|.
name|find
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
name|NewClassMaps
operator|::
name|const_iterator
name|ncmap
decl_stmt|;
name|ncmap
operator|=
name|newClassMaps
operator|.
name|find
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
name|NewClassMaps
operator|::
name|const_iterator
name|nqcmap
decl_stmt|;
name|nqcmap
operator|=
name|newQmlClassMaps
operator|.
name|find
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nsmap
operator|!=
name|newSinceMaps
operator|.
name|constEnd
argument_list|()
operator|)
operator|&&
operator|!
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LastSinceType
condition|;
operator|++
name|i
control|)
name|sections
operator|.
name|append
argument_list|(
name|Section
argument_list|(
name|sinceTitle
argument_list|(
name|i
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|NodeMultiMap
operator|::
name|const_iterator
name|n
init|=
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nsmap
operator|.
name|value
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|n
operator|.
name|value
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Fake
case|:
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|sections
index|[
name|QmlClass
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|sections
index|[
name|Namespace
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|sections
index|[
name|Class
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|sections
index|[
name|Enum
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|sections
index|[
name|Typedef
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
name|sections
index|[
name|Macro
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|Node
modifier|*
name|p
init|=
name|fn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
name|sections
index|[
name|MemberFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
name|sections
index|[
name|NamespaceFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Property
case|:
name|sections
index|[
name|Property
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|sections
index|[
name|Variable
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|sections
index|[
name|QmlProperty
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|sections
index|[
name|QmlSignal
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|sections
index|[
name|QmlSignalHandler
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|sections
index|[
name|QmlMethod
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|++
name|n
expr_stmt|;
block|}
comment|/*                   First generate the table of contents.                  */
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|li
init|=
name|outFileName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
decl_stmt|;
name|writeXrefListItem
argument_list|(
name|li
argument_list|,
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
if|if
condition|(
name|idx
operator|==
name|Class
condition|)
name|generateCompactList
argument_list|(
literal|0
argument_list|,
name|marker
argument_list|,
name|ncmap
operator|.
name|value
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QString
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|QmlClass
condition|)
name|generateCompactList
argument_list|(
literal|0
argument_list|,
name|marker
argument_list|,
name|nqcmap
operator|.
name|value
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QString
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|MemberFunction
condition|)
block|{
name|ParentMaps
name|parentmaps
decl_stmt|;
name|ParentMaps
operator|::
name|iterator
name|pmap
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|s
operator|->
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|s
operator|->
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|p
init|=
operator|(
operator|*
name|i
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
name|pmap
operator|=
name|parentmaps
operator|.
name|find
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
name|pmap
operator|=
name|parentmaps
operator|.
name|insert
argument_list|(
name|p
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|pmap
operator|=
name|parentmaps
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|pmap
operator|!=
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
block|{
name|NodeList
name|nlist
init|=
name|pmap
operator|->
name|values
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Class "
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|linkForNode
argument_list|(
name|pmap
operator|.
name|key
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
init|=
name|fullName
argument_list|(
name|pmap
operator|.
name|key
argument_list|()
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|)
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateSection
argument_list|(
name|nlist
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
operator|++
name|pmap
expr_stmt|;
block|}
block|}
else|else
block|{
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|idx
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|Image
case|:
case|case
name|Atom
operator|::
name|InlineImage
case|:
block|{
name|QString
name|fileName
init|=
name|imageFileName
argument_list|(
name|relative
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
condition|)
name|text
operator|=
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|images
init|=
literal|"images"
decl_stmt|;
if|if
condition|(
operator|!
name|baseDir
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|images
operator|.
name|prepend
argument_list|(
literal|"../"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|images
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|fileName
operator|=
name|images
operator|+
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|relative
operator|&&
operator|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
operator|)
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|cen
init|=
cast|static_cast
argument_list|<
specifier|const
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|cen
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ExampleNode
modifier|*
name|en
init|=
cast|const_cast
argument_list|<
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|cen
argument_list|)
decl_stmt|;
name|en
operator|->
name|setImageFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentTag
argument_list|()
operator|!=
name|DT_xref
condition|)
name|writeStartTag
argument_list|(
name|DT_fig
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_image
argument_list|)
expr_stmt|;
name|writeHrefAttribute
argument_list|(
name|protectEnc
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|InlineImage
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"placement"
argument_list|,
literal|"inline"
argument_list|)
expr_stmt|;
else|else
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"placement"
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"align"
argument_list|,
literal|"center"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_alt
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</alt>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</image>
if|if
condition|(
name|currentTag
argument_list|()
operator|!=
name|DT_xref
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</fig>
block|}
break|break;
case|case
name|Atom
operator|::
name|ImageText
case|:
comment|// nothing
break|break;
case|case
name|Atom
operator|::
name|ImportantLeft
case|:
name|writeStartTag
argument_list|(
name|DT_note
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
literal|"important"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ImportantRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</note>
break|break;
case|case
name|Atom
operator|::
name|NoteLeft
case|:
name|writeStartTag
argument_list|(
name|DT_note
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
literal|"note"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|NoteRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</note>
break|break;
case|case
name|Atom
operator|::
name|LegaleseLeft
case|:
name|inLegaleseText
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LegaleseRight
case|:
name|inLegaleseText
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LineBreak
case|:
comment|//xmlWriter().writeEmptyElement("br");
break|break;
case|case
name|Atom
operator|::
name|Link
case|:
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|myLink
init|=
name|getLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|myLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Can't link to '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
name|relative
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inSectionHeading
condition|)
block|{
name|beginLink
argument_list|(
name|myLink
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {
comment|//xmlWriter().writeCharacters(atom->string());
comment|//qDebug()<< "MYLINK:"<< myLink<< outFileName()<< atom->string();
block|}
endif|#
directive|endif
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|GuidLink
case|:
block|{
name|beginLink
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|LinkNode
case|:
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|beginLink
argument_list|(
name|linkForNode
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListLeft
case|:
if|if
condition|(
name|in_para
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_dl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|threeColumnEnumValueTable
operator|=
name|isThreeColumnEnumValueTable
argument_list|(
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|threeColumnEnumValueTable
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_simpletable
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"valuelist"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_sthead
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Constant"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Value"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Description"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sthead>
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_simpletable
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"valuelist"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_sthead
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Constant"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Value"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sthead>
block|}
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_ol
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERALPHA
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"upperalpha"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERALPHA
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"loweralpha"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERROMAN
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"upperroman"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERROMAN
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"lowerroman"
argument_list|)
expr_stmt|;
else|else
comment|// (atom->string() == ATOM_LIST_NUMERIC)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"numeric"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|!=
literal|1
condition|)
block|{
comment|// I don't think this attribute is supported.
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"start"
argument_list|,
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|ListItemNumber
case|:
comment|// nothing
break|break;
case|case
name|Atom
operator|::
name|ListTagLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_dt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// (atom->string() == ATOM_LIST_VALUE)
name|writeStartTag
argument_list|(
name|DT_strow
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tt
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|marker
operator|->
name|markedUpEnumValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|,
name|relative
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tt>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
name|QString
name|itemValue
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|itemValue
operator|=
name|enume
operator|->
name|itemValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemValue
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_tt
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|itemValue
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tt>
block|}
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListTagRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dt>
break|break;
case|case
name|Atom
operator|::
name|ListItemLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_dd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
if|if
condition|(
name|threeColumnEnumValueTable
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeStartTag
argument_list|(
name|DT_stentry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ListItemRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dd>
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</stentry>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</strow>
block|}
else|else
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
break|break;
case|case
name|Atom
operator|::
name|ListRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dl>
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</simpletable>
block|}
else|else
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ol>
block|}
break|break;
case|case
name|Atom
operator|::
name|Nop
case|:
comment|// nothing
break|break;
case|case
name|Atom
operator|::
name|ParaLeft
case|:
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inLegaleseText
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"legalese"
argument_list|)
expr_stmt|;
name|in_para
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ParaRight
case|:
name|endLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|QuotationLeft
case|:
name|writeStartTag
argument_list|(
name|DT_lq
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|QuotationRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</lq>
break|break;
case|case
name|Atom
operator|::
name|RawString
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|" "
condition|)
break|break;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
condition|)
name|writeCharacters
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"<sup>*</sup>"
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_sup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sup>
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"<sup>&reg;</sup>"
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_tm
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"tmtype"
argument_list|,
literal|"reg"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tm>
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_pre
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"raw-html"
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</pre>
block|}
break|break;
case|case
name|Atom
operator|::
name|SectionLeft
case|:
if|#
directive|if
literal|0
block|if (inApiDesc) {             writeEndTag();
comment|//</apiDesc>
block|inApiDesc = false;         }
endif|#
directive|endif
name|enterSection
argument_list|(
literal|"details"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|//writeGuidAttribute(Doc::canonicalTitle(Text::sectionHeading(atom).toString()));
break|break;
case|case
name|Atom
operator|::
name|SectionRight
case|:
name|leaveSection
argument_list|()
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingLeft
case|:
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|QString
name|id
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|id
operator|=
name|stripMarkup
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|id
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|hx
operator|=
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|hOffset
argument_list|(
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|hx
argument_list|)
expr_stmt|;
name|inSectionHeading
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</title> (see case Atom::SectionHeadingLeft)
name|inSectionHeading
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SidebarLeft
case|:
comment|// nothing
break|break;
case|case
name|Atom
operator|::
name|SidebarRight
case|:
comment|// nothing
break|break;
case|case
name|Atom
operator|::
name|String
case|:
if|if
condition|(
name|inLink
operator|&&
operator|!
name|inContents
operator|&&
operator|!
name|inSectionHeading
condition|)
block|{
name|generateLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeCharacters
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableLeft
case|:
block|{
name|QString
name|attr
decl_stmt|;
if|if
condition|(
operator|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|(
literal|0
argument_list|)
operator|==
literal|"borderless"
operator|)
condition|)
name|attr
operator|=
literal|"borderless"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|(
literal|1
argument_list|)
operator|==
literal|"borderless"
operator|)
condition|)
name|attr
operator|=
literal|"borderless"
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|numTableRows
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tableColumnCount
operator|!=
literal|0
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"ERROR: Nested tables!"
expr_stmt|;
name|tableColumnCount
operator|=
literal|0
expr_stmt|;
block|}
name|tableColumnCount
operator|=
name|countTableColumns
argument_list|(
name|atom
operator|->
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tgroup
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"cols"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|tableColumnCount
argument_list|)
argument_list|)
expr_stmt|;
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableBody
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tbody>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tgroup>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</table>
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableBody
operator|=
literal|false
expr_stmt|;
name|tableColumnCount
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderLeft
case|:
if|if
condition|(
name|inTableBody
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tbody>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tgroup>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</table>
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableBody
operator|=
literal|false
expr_stmt|;
name|tableColumnCount
operator|=
literal|0
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_table
argument_list|)
expr_stmt|;
name|numTableRows
operator|=
literal|0
expr_stmt|;
name|tableColumnCount
operator|=
name|countTableColumns
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tgroup
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"cols"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|tableColumnCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_thead
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"valign"
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_row
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"valign"
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
name|inTableHeader
operator|=
literal|true
expr_stmt|;
name|inTableBody
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</row>
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|TableHeaderLeft
argument_list|)
condition|)
block|{
name|skipAhead
operator|=
literal|1
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_row
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"valign"
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</thead>
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableBody
operator|=
literal|true
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tbody
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRowLeft
case|:
if|if
condition|(
operator|!
name|inTableHeader
operator|&&
operator|!
name|inTableBody
condition|)
block|{
name|inTableBody
operator|=
literal|true
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tbody
argument_list|)
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_row
argument_list|)
expr_stmt|;
name|attr
operator|=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|attr
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
name|QString
name|values
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|++
name|index
expr_stmt|;
name|from
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|from
condition|)
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|values
operator|+=
name|attr
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|index
operator|-
name|from
argument_list|)
expr_stmt|;
name|from
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|attr
operator|=
name|values
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"valign"
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableRowRight
case|:
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</row>
break|break;
case|case
name|Atom
operator|::
name|TableItemLeft
case|:
block|{
name|QString
name|values
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_entry
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atom
operator|->
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|attr
operator|=
name|atom
operator|->
name|string
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|++
name|index
expr_stmt|;
name|from
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|attr
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|from
condition|)
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|values
operator|+=
name|attr
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|index
operator|-
name|from
argument_list|)
expr_stmt|;
name|from
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|QStringList
name|spans
init|=
name|attr
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|spans
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|spans
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|()
operator|>
literal|1
operator|)
operator|||
operator|(
name|spans
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
name|values
operator|+=
literal|"span("
operator|+
name|spans
index|[
literal|0
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|spans
index|[
literal|1
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableItemRight
case|:
if|if
condition|(
name|inTableHeader
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</entry>
else|else
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</entry>
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableOfContents
case|:
block|{
name|int
name|numColumns
init|=
literal|1
decl_stmt|;
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
decl_stmt|;
name|Doc
operator|::
name|Sections
name|sectionUnit
init|=
name|Doc
operator|::
name|Section4
decl_stmt|;
name|QStringList
name|params
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|columnText
init|=
name|params
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QStringList
name|pieces
init|=
name|columnText
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|columnText
operator|=
name|pieces
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pieces
operator|.
name|pop_front
argument_list|()
expr_stmt|;
name|QString
name|path
init|=
name|pieces
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|node
operator|=
name|findNodeForTarget
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|atom
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numColumns
operator|=
name|qMax
argument_list|(
name|columnText
operator|.
name|toInt
argument_list|()
argument_list|,
name|numColumns
argument_list|)
expr_stmt|;
name|sectionUnit
operator|=
operator|(
name|Doc
operator|::
name|Sections
operator|)
name|params
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
condition|)
name|generateTableOfContents
argument_list|(
name|node
argument_list|,
name|marker
argument_list|,
name|sectionUnit
argument_list|,
name|numColumns
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|Target
case|:
if|if
condition|(
name|in_para
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
comment|//xmlWriter().writeCharacters(protectEnc(atom->string()));
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
break|break;
case|case
name|Atom
operator|::
name|UnhandledFormat
case|:
name|writeStartTag
argument_list|(
name|DT_b
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"<Missing DITAXML>"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</b>
break|break;
case|case
name|Atom
operator|::
name|UnknownCommand
case|:
name|writeStartTag
argument_list|(
name|DT_b
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"error unknown-command"
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</b>
break|break;
case|case
name|Atom
operator|::
name|QmlText
case|:
case|case
name|Atom
operator|::
name|EndQmlText
case|:
comment|// don't do anything with these. They are just tags.
break|break;
default|default:
comment|//        unknownAtom(atom);
break|break;
block|}
return|return
name|skipAhead
return|;
block|}
end_function
begin_comment
comment|/*!   Generate a<cxxClass> element (and all the stuff inside it)   for the C++ class represented by \a innerNode. \a marker is   for marking up the code. I don't know what that means exactly.  */
end_comment
begin_function
name|void
DECL|function|generateClassLikeNode
name|DitaXmlGenerator
operator|::
name|generateClassLikeNode
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|QString
name|title
decl_stmt|;
name|QString
name|rawTitle
decl_stmt|;
name|QString
name|fullTitle
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
specifier|const
name|NamespaceNode
modifier|*
name|nsn
init|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
name|rawTitle
operator|=
name|marker
operator|->
name|plainName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|fullTitle
operator|=
name|marker
operator|->
name|plainFullName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Namespace"
expr_stmt|;
comment|/*           Note: Because the C++ specialization we are using           has no<cxxNamespace> element, we are using the<cxxClass> element with an outputclass attribute           set to "namespace" .          */
name|generateHeader
argument_list|(
name|inner
argument_list|,
name|fullTitle
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<shortdesc>
name|writeProlog
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDefinition
argument_list|)
expr_stmt|;
name|writeLocation
argument_list|(
name|nsn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassDefinition>
name|enterApiDesc
argument_list|(
name|QString
argument_list|()
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// To be removed, if really not needed.
block|Text brief = nsn->doc().briefText();
comment|// zzz
block|if (!brief.isEmpty()) {             writeStartTag(DT_p);             generateText(brief, nsn, marker);             writeEndTag();
comment|//</p>
block|}
endif|#
directive|endif
name|generateStatus
argument_list|(
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Detailed Description"
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
comment|//</apiDesc>
name|bool
name|needOtherSection
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|summarySections
decl_stmt|;
name|summarySections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summarySections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enterSection
argument_list|(
literal|"redundant"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|needOtherSection
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|QString
name|attr
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</title>
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|QString
argument_list|(
literal|"Reimplemented "
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|name
decl_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</title>
name|generateSection
argument_list|(
name|s
operator|->
name|reimpMembers
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|needOtherSection
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Additional Inherited Members"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</title>
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
name|leaveSection
argument_list|()
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDetail>
comment|// not included:<related-links>
comment|// not included:<cxxClassNested>
name|QList
argument_list|<
name|Section
argument_list|>
name|detailSections
decl_stmt|;
name|detailSections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Classes"
condition|)
block|{
name|writeNestedClasses
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|nsn
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Function Documentation"
condition|)
block|{
name|writeFunctions
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|nsn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Type Documentation"
condition|)
block|{
name|writeEnumerations
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeTypedefs
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Namespaces"
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Nested namespaces"
operator|<<
name|outFileName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Macro Documentation"
condition|)
block|{
comment|//writeMacros((*s),marker);
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClass>
block|}
elseif|else
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
cast|const_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
name|rawTitle
operator|=
name|marker
operator|->
name|plainName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|fullTitle
operator|=
name|marker
operator|->
name|plainFullName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Class"
expr_stmt|;
name|generateHeader
argument_list|(
name|inner
argument_list|,
name|fullTitle
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<shortdesc>
name|writeProlog
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|inner
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassAccessSpecifier>
if|if
condition|(
name|cn
operator|->
name|isAbstract
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxClassAbstract
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"abstract"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"abstract"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassAbstract>
block|}
name|writeDerivations
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<cxxClassDerivations>
comment|// not included:<cxxClassTemplateParameters>
name|writeLocation
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassDefinition>
name|enterApiDesc
argument_list|(
name|QString
argument_list|()
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// To be removed, if really not needed.
block|Text brief = cn->doc().briefText();
comment|// zzz
block|if (!brief.isEmpty()) {             writeStartTag(DT_p);             generateText(brief, cn, marker);             writeEndTag();
comment|//</p>
block|}
endif|#
directive|endif
name|generateStatus
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateInherits
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateInheritedBy
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Detailed Description"
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
comment|//</apiDesc>
name|bool
name|needOtherSection
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|summarySections
decl_stmt|;
name|summarySections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summarySections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enterSection
argument_list|(
literal|"redundant"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|needOtherSection
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|QString
name|attr
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|QString
argument_list|(
literal|"Reimplemented "
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|name
decl_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateSection
argument_list|(
name|s
operator|->
name|reimpMembers
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|needOtherSection
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Additional Inherited Members"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
name|leaveSection
argument_list|()
expr_stmt|;
block|}
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDetail>
comment|// not included:<related-links>
comment|// not included:<cxxClassNested>
name|QList
argument_list|<
name|Section
argument_list|>
name|detailSections
decl_stmt|;
name|detailSections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Function Documentation"
condition|)
block|{
name|writeFunctions
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Type Documentation"
condition|)
block|{
name|writeEnumerations
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeTypedefs
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Variable Documentation"
condition|)
block|{
name|writeDataMembers
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Property Documentation"
condition|)
block|{
name|writeProperties
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Macro Documentation"
condition|)
block|{
comment|//writeMacros((*s),marker);
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Related Non-Members"
condition|)
block|{
name|QString
name|attribute
argument_list|(
literal|"related-non-member"
argument_list|)
decl_stmt|;
name|writeFunctions
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClass>
block|}
elseif|else
if|if
condition|(
operator|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
operator|)
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fn
init|=
cast|const_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
name|rawTitle
operator|=
name|marker
operator|->
name|plainName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|fullTitle
operator|=
name|marker
operator|->
name|plainFullName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|title
operator|=
name|rawTitle
expr_stmt|;
comment|/*           Note: Because the C++ specialization we are using           has no<cxxHeaderFile> element, we are using the<cxxClass> element with an outputclass attribute           set to "headerfile" .          */
name|generateHeader
argument_list|(
name|inner
argument_list|,
name|fullTitle
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<shortdesc>
name|writeProlog
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDetail
argument_list|)
expr_stmt|;
name|enterApiDesc
argument_list|(
name|QString
argument_list|()
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// To be removed, if really not needed.
block|Text brief = fn->doc().briefText();
comment|// zzz
block|if (!brief.isEmpty()) {             writeStartTag(DT_p);             generateText(brief, fn, marker);             writeEndTag();
comment|//</p>
block|}
endif|#
directive|endif
name|generateStatus
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Detailed Description"
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
comment|//</apiDesc>
name|bool
name|needOtherSection
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|summarySections
decl_stmt|;
name|summarySections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summarySections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enterSection
argument_list|(
literal|"redundant"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|needOtherSection
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|QString
name|attr
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|QString
argument_list|(
literal|"Reimplemented "
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|name
decl_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateSection
argument_list|(
name|s
operator|->
name|reimpMembers
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|needOtherSection
condition|)
block|{
name|enterSection
argument_list|(
literal|"additional-inherited-members redundant"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Additional Inherited Members"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
name|leaveSection
argument_list|()
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDetail>
comment|// not included:<related-links>
comment|// not included:<cxxClassNested>
name|QList
argument_list|<
name|Section
argument_list|>
name|detailSections
decl_stmt|;
name|detailSections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Classes"
condition|)
block|{
name|writeNestedClasses
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Function Documentation"
condition|)
block|{
name|writeFunctions
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Type Documentation"
condition|)
block|{
name|writeEnumerations
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeTypedefs
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Namespaces"
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Nested namespaces"
operator|<<
name|outFileName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Macro Documentation"
condition|)
block|{
comment|//writeMacros((*s),marker);
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
name|generateLowStatusMembers
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClass>
block|}
elseif|else
if|if
condition|(
operator|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
condition|)
block|{
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|const_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
name|rawTitle
operator|=
name|marker
operator|->
name|plainName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|fullTitle
operator|=
name|marker
operator|->
name|plainFullName
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Element"
expr_stmt|;
comment|//QString fullTitle = fake->fullTitle();
comment|//QString htmlTitle = fullTitle;
name|generateHeader
argument_list|(
name|inner
argument_list|,
name|fullTitle
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<shortdesc>
name|writeProlog
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDetail
argument_list|)
expr_stmt|;
name|enterApiDesc
argument_list|(
name|QString
argument_list|()
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// To be removed, if really not needed.
block|Text brief = qcn->doc().briefText();
comment|// zzz
block|if (!brief.isEmpty()) {             writeStartTag(DT_p);             generateText(brief, qcn, marker);             writeEndTag();
comment|//</p>
block|}
endif|#
directive|endif
name|generateQmlInstantiates
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlInherits
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlInheritedBy
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Detailed Description"
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|generateQmlText
argument_list|(
name|cn
operator|->
name|doc
argument_list|()
operator|.
name|body
argument_list|()
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
name|leaveSection
argument_list|()
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
comment|//</apiDesc>
name|QList
argument_list|<
name|Section
argument_list|>
name|summarySections
decl_stmt|;
name|summarySections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qcn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summarySections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enterSection
argument_list|(
literal|"redundant"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|summarySections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|summarySections
operator|.
name|end
argument_list|()
condition|)
block|{
name|QString
name|attr
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|generateQmlSummary
argument_list|(
operator|*
name|s
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//generateSection(s->members, inner, marker, CodeMarker::Summary);
comment|//generateSectionInheritedList(*s, inner, marker);
block|}
operator|++
name|s
expr_stmt|;
block|}
name|leaveSection
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|Section
argument_list|>
name|detailSections
decl_stmt|;
name|detailSections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qcn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detailSections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|enterSection
argument_list|(
literal|"details"
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|detailSections
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|detailSections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|attr
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|attr
operator|=
name|cleanRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|+
literal|" h2"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
name|generateDetailedQmlMember
argument_list|(
operator|*
name|m
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
name|leaveSection
argument_list|()
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDetail>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClass>
block|}
block|}
end_function
begin_comment
comment|/*!   Write a list item for a \a link with the given \a text.  */
end_comment
begin_function
DECL|function|writeXrefListItem
name|void
name|DitaXmlGenerator
operator|::
name|writeXrefListItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|link
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|writeHrefAttribute
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
end_function
begin_comment
comment|/*!   Generate the DITA page for a qdoc file that doesn't map   to an underlying c++ file.  */
end_comment
begin_function
DECL|function|generateFakeNode
name|void
name|DitaXmlGenerator
operator|::
name|generateFakeNode
parameter_list|(
specifier|const
name|FakeNode
modifier|*
name|fake
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
comment|/*       If the fake node is a page node, and if the page type       is DITA map page, write the node's contents as a dita       map and return without doing anything else.      */
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
operator|&&
name|fake
operator|->
name|pageType
argument_list|()
operator|==
name|Node
operator|::
name|DitaMapPage
condition|)
block|{
specifier|const
name|DitaMapNode
modifier|*
name|dmn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DitaMapNode
operator|*
argument_list|>
argument_list|(
name|fake
argument_list|)
decl_stmt|;
name|writeDitaMap
argument_list|(
name|dmn
argument_list|)
expr_stmt|;
return|return;
block|}
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|fullTitle
init|=
name|fake
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
block|{
name|fullTitle
operator|=
literal|"QML Basic Type: "
operator|+
name|fullTitle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|fullTitle
operator|=
literal|"Name Collision: "
operator|+
name|fullTitle
expr_stmt|;
block|}
name|generateHeader
argument_list|(
name|fake
argument_list|,
name|fullTitle
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|//<shortdesc>
name|writeProlog
argument_list|(
name|fake
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_body
argument_list|)
expr_stmt|;
name|enterSection
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
name|generateStatus
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|moduleNamespaceMap
operator|.
name|contains
argument_list|(
name|fake
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Namespaces"
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|,
name|moduleNamespaceMap
index|[
name|fake
operator|->
name|name
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|moduleClassMap
operator|.
name|contains
argument_list|(
name|fake
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Classes"
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|,
name|moduleClassMap
index|[
name|fake
operator|->
name|name
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fake
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|Quoter
name|quoter
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"small-subtitle"
argument_list|)
expr_stmt|;
name|text
operator|<<
name|fake
operator|->
name|subTitle
argument_list|()
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|Doc
operator|::
name|quoteFromFile
argument_list|(
name|fake
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|,
name|quoter
argument_list|,
name|fake
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|code
init|=
name|quoter
operator|.
name|quoteTo
argument_list|(
name|fake
operator|->
name|location
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
name|enterSection
argument_list|(
literal|"h2"
argument_list|,
literal|"Detailed Description"
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|generateBody
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
name|generateAlsoList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fake
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlModule
operator|)
operator|&&
operator|!
name|fake
operator|->
name|qmlModuleMembers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
name|qmlModuleMembersMap
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|fake
operator|->
name|qmlModuleMembers
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|qmlModuleMembersMap
index|[
name|node
operator|->
name|name
argument_list|()
index|]
operator|=
name|node
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|,
name|qmlModuleMembersMap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fake
operator|->
name|groupMembers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
name|groupMembersMap
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|fake
operator|->
name|groupMembers
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
name|groupMembersMap
index|[
name|node
operator|->
name|name
argument_list|()
index|]
operator|=
name|node
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|,
name|groupMembersMap
argument_list|)
expr_stmt|;
block|}
block|}
name|leaveSection
argument_list|()
expr_stmt|;
comment|//</section>
if|if
condition|(
operator|!
name|writeEndTag
argument_list|()
condition|)
block|{
comment|//</body>
name|fake
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Pop of empty XML tag stack; generating DITA for '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|fake
operator|->
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|writeRelatedLinks
argument_list|(
name|fake
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topic>
block|}
end_function
begin_comment
comment|/*!   This function writes a \e{<link>} element inside a   \e{<related-links>} element.    \sa writeRelatedLinks()  */
end_comment
begin_function
DECL|function|writeLink
name|void
name|DitaXmlGenerator
operator|::
name|writeLink
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QString
modifier|&
name|role
parameter_list|)
block|{
if|if
condition|(
name|node
condition|)
block|{
name|QString
name|link
init|=
name|fileName
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|node
operator|->
name|guid
argument_list|()
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|endsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"LINK ENDS WITH #:"
operator|<<
name|link
operator|<<
name|outFileName
argument_list|()
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_link
argument_list|)
expr_stmt|;
name|writeHrefAttribute
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"role"
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_linktext
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</linktext>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</link>
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes a \e{<related-links>} element, which   contains the \c{next}, \c{previous}, and \c{start}   links for topic pages that have them. Note that the   value of the \e role attribute is \c{parent} for the   \c{start} link.  */
end_comment
begin_function
DECL|function|writeRelatedLinks
name|void
name|DitaXmlGenerator
operator|::
name|writeRelatedLinks
parameter_list|(
specifier|const
name|FakeNode
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|linkNode
init|=
literal|0
decl_stmt|;
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|linkPair
decl_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_relatedLinks
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|PreviousLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|PreviousLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeLink
argument_list|(
name|linkNode
argument_list|,
name|linkPair
operator|.
name|second
argument_list|,
literal|"previous"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|NextLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|NextLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeLink
argument_list|(
name|linkNode
argument_list|,
name|linkPair
operator|.
name|second
argument_list|,
literal|"next"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|StartLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|StartLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeLink
argument_list|(
name|linkNode
argument_list|,
name|linkPair
operator|.
name|second
argument_list|,
literal|"parent"
argument_list|)
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</related-links>
block|}
block|}
end_function
begin_comment
comment|/*!   Returns "dita" for this subclass of class Generator.  */
end_comment
begin_function
DECL|function|fileExtension
name|QString
name|DitaXmlGenerator
operator|::
name|fileExtension
parameter_list|(
specifier|const
name|Node
modifier|*
comment|/* node */
parameter_list|)
specifier|const
block|{
return|return
literal|"dita"
return|;
block|}
end_function
begin_comment
comment|/*!   Writes an XML file header to the current XML stream. This   depends on which kind of DITA XML file is being generated,   which is determined by the \a node type and subtype and the   \a subpage flag. If the \subpage flag is true, a \c{<topic>}   header is written, regardless of the type of \a node.  */
end_comment
begin_function
DECL|function|generateHeader
name|void
name|DitaXmlGenerator
operator|::
name|generateHeader
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|subpage
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return;
name|DitaTag
name|mainTag
init|=
name|DT_cxxClass
decl_stmt|;
name|DitaTag
name|nameTag
init|=
name|DT_apiName
decl_stmt|;
name|QString
name|doctype
decl_stmt|;
name|QString
name|dtd
decl_stmt|;
name|QString
name|base
decl_stmt|;
name|QString
name|version
decl_stmt|;
name|QString
name|outputclass
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|mainTag
operator|=
name|DT_cxxClass
expr_stmt|;
name|nameTag
operator|=
name|DT_apiName
expr_stmt|;
name|dtd
operator|=
literal|"dtd/cxxClass.dtd"
expr_stmt|;
name|version
operator|=
literal|"0.7.0"
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE "
operator|+
name|ditaTags
index|[
name|mainTag
index|]
operator|+
literal|" PUBLIC \"-//NOKIA//DTD DITA C++ API Class Reference Type v"
operator|+
name|version
operator|+
literal|"//EN\" \""
operator|+
name|dtd
operator|+
literal|"\">"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|mainTag
operator|=
name|DT_cxxClass
expr_stmt|;
name|nameTag
operator|=
name|DT_apiName
expr_stmt|;
name|dtd
operator|=
literal|"dtd/cxxClass.dtd"
expr_stmt|;
name|version
operator|=
literal|"0.7.0"
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE "
operator|+
name|ditaTags
index|[
name|mainTag
index|]
operator|+
literal|" PUBLIC \"-//NOKIA//DTD DITA C++ API Class Reference Type v"
operator|+
name|version
operator|+
literal|"//EN\" \""
operator|+
name|dtd
operator|+
literal|"\">"
expr_stmt|;
name|outputclass
operator|=
literal|"namespace"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|||
name|subpage
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
condition|)
block|{
name|mainTag
operator|=
name|DT_cxxClass
expr_stmt|;
name|nameTag
operator|=
name|DT_apiName
expr_stmt|;
name|dtd
operator|=
literal|"dtd/cxxClass.dtd"
expr_stmt|;
name|version
operator|=
literal|"0.7.0"
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE "
operator|+
name|ditaTags
index|[
name|mainTag
index|]
operator|+
literal|" PUBLIC \"-//NOKIA//DTD DITA C++ API Class Reference Type v"
operator|+
name|version
operator|+
literal|"//EN\" \""
operator|+
name|dtd
operator|+
literal|"\">"
expr_stmt|;
name|outputclass
operator|=
literal|"headerfile"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|mainTag
operator|=
name|DT_cxxClass
expr_stmt|;
name|nameTag
operator|=
name|DT_apiName
expr_stmt|;
name|dtd
operator|=
literal|"dtd/cxxClass.dtd"
expr_stmt|;
name|version
operator|=
literal|"0.7.0"
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE "
operator|+
name|ditaTags
index|[
name|mainTag
index|]
operator|+
literal|" PUBLIC \"-//NOKIA//DTD DITA C++ API Class Reference Type v"
operator|+
name|version
operator|+
literal|"//EN\" \""
operator|+
name|dtd
operator|+
literal|"\">"
expr_stmt|;
name|outputclass
operator|=
literal|"QML-class"
expr_stmt|;
block|}
else|else
block|{
name|mainTag
operator|=
name|DT_topic
expr_stmt|;
name|nameTag
operator|=
name|DT_title
expr_stmt|;
name|dtd
operator|=
literal|"dtd/topic.dtd"
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE "
operator|+
name|ditaTags
index|[
name|mainTag
index|]
operator|+
literal|" PUBLIC \"-//OASIS//DTD DITA Topic//EN\" \""
operator|+
name|dtd
operator|+
literal|"\">"
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Page
case|:
name|outputclass
operator|=
name|node
operator|->
name|pageTypeString
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Group
case|:
name|outputclass
operator|=
literal|"group"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Example
case|:
name|outputclass
operator|=
literal|"example"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|File
case|:
name|outputclass
operator|=
literal|"file"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Image
case|:
comment|// not used
name|outputclass
operator|=
literal|"image"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Module
case|:
name|outputclass
operator|=
literal|"module"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
comment|// not used
name|outputclass
operator|=
literal|"externalpage"
expr_stmt|;
break|break;
default|default:
name|outputclass
operator|=
literal|"page"
expr_stmt|;
block|}
block|}
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeDTD
argument_list|(
name|doctype
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeComment
argument_list|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|mainTag
argument_list|)
expr_stmt|;
name|QString
name|id
init|=
name|node
operator|->
name|guid
argument_list|()
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputclass
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|outputclass
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|nameTag
argument_list|)
expr_stmt|;
comment|//<title> or<apiName>
name|writeCharacters
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</title> or</apiName>
block|}
end_function
begin_comment
comment|/*!   Outputs the \e brief command as a<shortdesc> element.  */
end_comment
begin_function
DECL|function|generateBrief
name|void
name|DitaXmlGenerator
operator|::
name|generateBrief
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// zzz
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   zzz   Generates a table of contents beginning at \a node.   Currently just returns without writing anything.  */
end_comment
begin_function
DECL|function|generateTableOfContents
name|void
name|DitaXmlGenerator
operator|::
name|generateTableOfContents
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|Doc
operator|::
name|Sections
name|sectionUnit
parameter_list|,
name|int
name|numColumns
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
return|return;
if|if
condition|(
operator|!
name|node
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
return|return;
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|toc
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
if|if
condition|(
name|toc
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|nodeName
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|relative
condition|)
name|nodeName
operator|=
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
name|QStringList
name|sectionNumber
decl_stmt|;
name|int
name|columnSize
init|=
literal|0
decl_stmt|;
name|QString
name|tdTag
decl_stmt|;
if|if
condition|(
name|numColumns
operator|>
literal|1
condition|)
block|{
name|tdTag
operator|=
literal|"<td>"
expr_stmt|;
comment|/* width=\"" + QString::number((100 + numColumns - 1) / numColumns) + "%\">";*/
name|out
argument_list|()
operator|<<
literal|"<table class=\"toc\">\n<tr class=\"topAlign\">"
operator|<<
name|tdTag
operator|<<
literal|'\n'
expr_stmt|;
block|}
comment|// disable nested links in table of contents
name|inContents
operator|=
literal|true
expr_stmt|;
name|inLink
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|atom
init|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|nextLevel
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextLevel
operator|>
operator|(
name|int
operator|)
name|sectionUnit
condition|)
continue|continue;
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
block|{
do|do
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>"
expr_stmt|;
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|>
name|nextLevel
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|sectionNumber
operator|.
name|last
argument_list|()
operator|=
name|QString
operator|::
name|number
argument_list|(
name|sectionNumber
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|numAtoms
decl_stmt|;
name|Text
name|headingText
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
decl_stmt|;
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|columnSize
operator|>
name|toc
operator|.
name|size
argument_list|()
operator|/
name|numColumns
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</ul></td>"
operator|<<
name|tdTag
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|columnSize
operator|=
literal|0
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<xref href=\""
operator|<<
name|nodeName
operator|<<
literal|"#"
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|headingText
operator|.
name|toString
argument_list|()
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|generateAtomList
argument_list|(
name|headingText
operator|.
name|firstAtom
argument_list|()
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</xref></li>\n"
expr_stmt|;
operator|++
name|columnSize
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|sectionNumber
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numColumns
operator|>
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr></table>\n"
expr_stmt|;
name|inContents
operator|=
literal|false
expr_stmt|;
name|inLink
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   zzz   Revised for the new doc format.   Generates a table of contents beginning at \a node.  */
end_comment
begin_function
DECL|function|generateTableOfContents
name|void
name|DitaXmlGenerator
operator|::
name|generateTableOfContents
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|QList
argument_list|<
name|Section
argument_list|>
modifier|*
name|sections
parameter_list|)
block|{
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|toc
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
name|toc
operator|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
expr_stmt|;
if|if
condition|(
name|toc
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|sections
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Module
operator|)
condition|)
return|return;
name|QStringList
name|sectionNumber
decl_stmt|;
name|int
name|detailsBase
init|=
literal|0
decl_stmt|;
comment|// disable nested links in table of contents
name|inContents
operator|=
literal|true
expr_stmt|;
name|inLink
operator|=
literal|true
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"toc\">\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h3>Contents</h3>\n"
expr_stmt|;
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
if|if
condition|(
name|moduleNamespaceMap
operator|.
name|contains
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><xref href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"namespaces"
argument_list|)
operator|<<
literal|"\">Namespaces</xref></li>\n"
expr_stmt|;
block|}
if|if
condition|(
name|moduleClassMap
operator|.
name|contains
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><xref href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"classes"
argument_list|)
operator|<<
literal|"\">Classes</xref></li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><xref href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</xref></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sections
operator|&&
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|)
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|sections
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|->
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><xref href=\"#"
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|pluralMember
argument_list|)
operator|<<
literal|"\">"
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|<<
literal|"</xref></li>\n"
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><xref href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</xref></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|atom
init|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|nextLevel
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|detailsBase
decl_stmt|;
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
block|{
do|do
block|{
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|>
name|nextLevel
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|sectionNumber
operator|.
name|last
argument_list|()
operator|=
name|QString
operator|::
name|number
argument_list|(
name|sectionNumber
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|numAtoms
decl_stmt|;
name|Text
name|headingText
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
decl_stmt|;
name|QString
name|s
init|=
name|headingText
operator|.
name|toString
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<xref href=\""
operator|<<
literal|"#"
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|s
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|generateAtomList
argument_list|(
name|headingText
operator|.
name|firstAtom
argument_list|()
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</xref></li>\n"
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|sectionNumber
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
name|inContents
operator|=
literal|false
expr_stmt|;
name|inLink
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateLowStatusMembers
name|void
name|DitaXmlGenerator
operator|::
name|generateLowStatusMembers
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|Status
name|status
parameter_list|)
block|{
name|QString
name|attribute
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Compat
condition|)
name|attribute
operator|=
literal|"Qt3-support"
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Obsolete
condition|)
name|attribute
operator|=
literal|"obsolete"
expr_stmt|;
else|else
return|return;
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
init|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|status
argument_list|)
decl_stmt|;
name|QMutableListIterator
argument_list|<
name|Section
argument_list|>
name|j
argument_list|(
name|sections
argument_list|)
decl_stmt|;
while|while
condition|(
name|j
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|next
argument_list|()
operator|.
name|members
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|j
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|sections
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Function Documentation"
condition|)
block|{
name|writeFunctions
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Type Documentation"
condition|)
block|{
name|writeEnumerations
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeTypedefs
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Member Variable Documentation"
condition|)
block|{
name|writeDataMembers
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Property Documentation"
condition|)
block|{
name|writeProperties
argument_list|(
operator|(
operator|*
name|s
operator|)
argument_list|,
name|marker
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|==
literal|"Macro Documentation"
condition|)
block|{
comment|//writeMacros((*s),marker,attribute);
block|}
operator|++
name|s
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Write the XML for the class hierarchy to the current XML stream.  */
end_comment
begin_function
DECL|function|generateClassHierarchy
name|void
name|DitaXmlGenerator
operator|::
name|generateClassHierarchy
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QMap
argument_list|<
name|QString
argument_list|,
specifier|const
name|Node
modifier|*
argument_list|>
modifier|&
name|classMap
parameter_list|)
block|{
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|NodeMap
name|topLevel
decl_stmt|;
name|NodeMap
operator|::
name|ConstIterator
name|c
init|=
name|classMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|classe
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|topLevel
operator|.
name|insert
argument_list|(
name|classe
operator|->
name|name
argument_list|()
argument_list|,
name|classe
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|QStack
argument_list|<
name|NodeMap
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|topLevel
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
if|if
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
else|else
block|{
specifier|const
name|ClassNode
modifier|*
name|child
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|generateFullName
argument_list|(
name|child
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
name|stack
operator|.
name|top
argument_list|()
operator|.
name|erase
argument_list|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMap
name|newTop
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|d
decl|,
name|child
operator|->
name|derivedClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|d
operator|.
name|access
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|!
name|d
operator|.
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|newTop
operator|.
name|insert
argument_list|(
name|d
operator|.
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|d
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newTop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|newTop
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Write XML for the contents of the \a nodeMap to the current   XML stream.  */
end_comment
begin_function
DECL|function|generateAnnotatedList
name|void
name|DitaXmlGenerator
operator|::
name|generateAnnotatedList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|nodeMap
parameter_list|)
block|{
if|if
condition|(
name|nodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_table
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"annotated"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tgroup
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"cols"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_tbody
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|nodeMap
operator|.
name|keys
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|nodeMap
index|[
name|name
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
continue|continue;
name|writeStartTag
argument_list|(
name|DT_row
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_entry
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|generateFullName
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<entry>
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
condition|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|trimmedBriefText
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_entry
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<entry>
block|}
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_entry
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// zzz
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<entry>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</row>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tbody>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tgroup>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</table>
block|}
end_function
begin_comment
comment|/*!   This function finds the common prefix of the names of all   the classes in \a classMap and then generates a compact   list of the class names alphabetized on the part of the   name not including the common prefix. You can tell the   function to use \a comonPrefix as the common prefix, but   normally you let it figure it out itself by looking at   the name of the first and last classes in \a classMap.  */
end_comment
begin_function
DECL|function|generateCompactList
name|void
name|DitaXmlGenerator
operator|::
name|generateCompactList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|classMap
parameter_list|,
name|bool
name|includeAlphabet
parameter_list|,
name|QString
name|commonPrefix
parameter_list|)
block|{
specifier|const
name|int
name|NumParagraphs
init|=
literal|37
decl_stmt|;
comment|// '0' to '9', 'A' to 'Z', '_'
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|/*       If commonPrefix is not empty, then the caller knows what       the common prefix is and has passed it in, so just use that       one. But if the commonPrefix is empty (it normally is), then       compute a common prefix using this simple algorithm. Note we       assume the prefix length is 1, i.e. we will have a single       character as the common prefix.      */
name|int
name|commonPrefixLen
init|=
name|commonPrefix
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|commonPrefixLen
operator|==
literal|0
condition|)
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|count
argument_list|(
literal|26
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|NodeMap
operator|::
name|const_iterator
name|iter
init|=
name|classMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|!=
name|classMap
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|iter
operator|.
name|key
argument_list|()
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|QChar
name|c
init|=
name|iter
operator|.
name|key
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|int
name|idx
init|=
name|c
operator|.
name|unicode
argument_list|()
operator|-
name|QChar
argument_list|(
literal|'A'
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
operator|++
name|count
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
operator|++
name|iter
expr_stmt|;
block|}
name|int
name|highest
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|count
index|[
name|i
index|]
operator|>
name|highest
condition|)
block|{
name|highest
operator|=
name|count
index|[
name|i
index|]
expr_stmt|;
name|idx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|idx
operator|+=
name|QChar
argument_list|(
literal|'A'
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|QChar
name|common
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|commonPrefix
operator|=
name|common
expr_stmt|;
name|commonPrefixLen
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/*           The algorithm below eventually failed, so it was replaced           with the simple (perhaps too simple) algorithm above.            The caller didn't pass in a common prefix, so get the common           prefix by looking at the class names of the first and last           classes in the class map. Discard any namespace names and           just use the bare class names. For Qt, the prefix is "Q".            Note that the algorithm used here to derive the common prefix           from the first and last classes in alphabetical order (QAccel           and QXtWidget in Qt 2.1), fails if either class name does not           begin with Q.         */
block|QString first;         QString last;         NodeMap::const_iterator iter = classMap.begin();         while (iter != classMap.end()) {             if (!iter.key().contains("::")) {                 first = iter.key();                 break;             }             ++iter;         }          if (first.isEmpty())             first = classMap.begin().key();          iter = classMap.end();         while (iter != classMap.begin()) {             --iter;             if (!iter.key().contains("::")) {                 last = iter.key();                 break;             }         }          if (last.isEmpty())             last = classMap.begin().key();          if (classMap.size()> 1) {             while (commonPrefixLen< first.length() + 1&&                    commonPrefixLen< last.length() + 1&&                    first[commonPrefixLen] == last[commonPrefixLen])                 ++commonPrefixLen;         }          commonPrefix = first.left(commonPrefixLen);
endif|#
directive|endif
block|}
comment|/*       Divide the data into 37 paragraphs: 0, ..., 9, A, ..., Z,       underscore (_). QAccel will fall in paragraph 10 (A) and       QXtWidget in paragraph 33 (X). This is the only place where we       assume that NumParagraphs is 37. Each paragraph is a NodeMap.     */
name|NodeMap
name|paragraph
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QString
name|paragraphName
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QSet
argument_list|<
name|char
argument_list|>
name|usedParagraphNames
decl_stmt|;
name|NodeMap
operator|::
name|ConstIterator
name|c
init|=
name|classMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|QStringList
name|pieces
init|=
name|c
operator|.
name|key
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|int
name|idx
init|=
name|commonPrefixLen
decl_stmt|;
if|if
condition|(
operator|!
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|startsWith
argument_list|(
name|commonPrefix
argument_list|)
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|mid
argument_list|(
name|idx
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
else|else
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|int
name|paragraphNr
init|=
name|NumParagraphs
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|paragraphNr
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|key
index|[
literal|0
index|]
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|paragraphNr
operator|=
literal|10
operator|+
name|key
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|-
literal|'a'
expr_stmt|;
block|}
name|paragraphName
index|[
name|paragraphNr
index|]
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|usedParagraphNames
operator|.
name|insert
argument_list|(
name|key
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|paragraph
index|[
name|paragraphNr
index|]
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|c
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
comment|/*       Each paragraph j has a size: paragraph[j].count(). In the       discussion, we will assume paragraphs 0 to 5 will have sizes       3, 1, 4, 1, 5, 9.        We now want to compute the paragraph offset. Paragraphs 0 to 6       start at offsets 0, 3, 4, 8, 9, 14, 23.     */
name|int
name|paragraphOffset
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
comment|// 37 + 1
name|paragraphOffset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumParagraphs
condition|;
name|i
operator|++
control|)
comment|// i = 0..36
name|paragraphOffset
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|paragraphOffset
index|[
name|i
index|]
operator|+
name|paragraph
index|[
name|i
index|]
operator|.
name|count
argument_list|()
expr_stmt|;
name|int
name|curParNr
init|=
literal|0
decl_stmt|;
name|int
name|curParOffset
init|=
literal|0
decl_stmt|;
name|QMap
argument_list|<
name|QChar
argument_list|,
name|QString
argument_list|>
name|cmap
decl_stmt|;
comment|/*       Output the alphabet as a row of links.      */
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"alphabet"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|usedParagraphNames
operator|.
name|contains
argument_list|(
name|char
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|QString
name|guid
init|=
name|lookupGuid
argument_list|(
name|outFileName
argument_list|()
argument_list|,
name|QString
argument_list|(
name|ch
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|attr
init|=
name|outFileName
argument_list|()
operator|+
name|QString
argument_list|(
literal|"#%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|guid
argument_list|)
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|QString
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
block|}
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
comment|/*       Output a<p> element to contain all the<dl> elements.      */
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"compactlist"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classMap
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|(
name|curParOffset
operator|==
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|count
argument_list|()
operator|)
condition|)
block|{
operator|++
name|curParNr
expr_stmt|;
name|curParOffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*           Starting a new paragraph means starting a new<dl>.         */
if|if
condition|(
name|curParOffset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dlentry>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dl>
block|}
name|writeStartTag
argument_list|(
name|DT_dl
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_dlentry
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|QChar
name|c
init|=
name|paragraphName
index|[
name|curParNr
index|]
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|writeGuidAttribute
argument_list|(
name|QString
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"sublist-header"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|paragraphName
index|[
name|curParNr
index|]
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dt>
block|}
comment|/*           Output a<dd> for the current offset in the current paragraph.          */
name|writeStartTag
argument_list|(
name|DT_dd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|!
name|paragraphName
index|[
name|curParNr
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
operator|::
name|Iterator
name|it
decl_stmt|;
name|it
operator|=
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|curParOffset
condition|;
name|i
operator|++
control|)
operator|++
name|it
expr_stmt|;
comment|/*               Previously, we used generateFullName() for this, but we               require some special formatting.             */
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|writeHrefAttribute
argument_list|(
name|linkForNode
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|pieces
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
else|else
name|pieces
operator|=
name|fullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dd>
name|curParOffset
operator|++
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dlentry>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</dl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
end_function
begin_comment
comment|/*!   Write XML for a function index to the current XML stream.  */
end_comment
begin_function
DECL|function|generateFunctionIndex
name|void
name|DitaXmlGenerator
operator|::
name|generateFunctionIndex
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"alphabet"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|QString
name|guid
init|=
name|lookupGuid
argument_list|(
name|outFileName
argument_list|()
argument_list|,
name|QString
argument_list|(
name|ch
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|attr
init|=
name|outFileName
argument_list|()
operator|+
name|QString
argument_list|(
literal|"#%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|guid
argument_list|)
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|QString
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|char
name|nextLetter
init|=
literal|'a'
decl_stmt|;
name|char
name|currentLetter
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|NodeMap
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|funcIndex
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|funcIndex
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|currentLetter
operator|=
name|f
operator|.
name|key
argument_list|()
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
while|while
condition|(
name|islower
argument_list|(
name|currentLetter
argument_list|)
operator|&&
name|currentLetter
operator|>=
name|nextLetter
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|QString
argument_list|(
name|nextLetter
argument_list|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|QString
argument_list|(
name|nextLetter
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|nextLetter
operator|++
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|f
operator|.
name|key
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|NodeMap
operator|::
name|ConstIterator
name|s
init|=
operator|(
operator|*
name|f
operator|)
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
operator|*
name|f
operator|)
operator|.
name|end
argument_list|()
condition|)
block|{
name|generateFullName
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
operator|++
name|f
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
end_function
begin_comment
comment|/*!   Write the legalese texts as XML to the current XML stream.  */
end_comment
begin_function
DECL|function|generateLegaleseList
name|void
name|DitaXmlGenerator
operator|::
name|generateLegaleseList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QMap
argument_list|<
name|Text
argument_list|,
specifier|const
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|legaleseTexts
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|end
argument_list|()
condition|)
block|{
name|Text
name|text
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
do|do
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
operator|++
name|it
expr_stmt|;
block|}
do|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|text
condition|)
do|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
end_function
begin_comment
comment|/*!   Generate the text for the QML item described by \a node   and write it to the current XML stream.  */
end_comment
begin_function
DECL|function|generateQmlItem
name|void
name|DitaXmlGenerator
operator|::
name|generateQmlItem
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|bool
name|summary
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpQmlItem
argument_list|(
name|node
argument_list|,
name|summary
argument_list|)
decl_stmt|;
name|QRegExp
name|tag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|tag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|tmp
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|tag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|tag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i>\\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|marked.replace("<@param>", "<i>");     marked.replace("</@param>", "</i>");      marked.replace("<@extra>", "<tt>");     marked.replace("</@extra>", "</tt>");
endif|#
directive|endif
if|if
condition|(
name|summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|writeText
argument_list|(
name|marked
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Write the XML for the overview list to the current XML stream.  */
end_comment
begin_function
DECL|function|generateOverviewList
name|void
name|DitaXmlGenerator
operator|::
name|generateOverviewList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
comment|/* marker */
parameter_list|)
block|{
name|QMap
argument_list|<
specifier|const
name|FakeNode
modifier|*
argument_list|,
name|QMap
argument_list|<
name|QString
argument_list|,
name|FakeNode
modifier|*
argument_list|>
argument_list|>
name|fakeNodeMap
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
specifier|const
name|FakeNode
modifier|*
argument_list|>
name|groupTitlesMap
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|FakeNode
modifier|*
argument_list|>
name|uncategorizedNodeMap
decl_stmt|;
name|QRegExp
name|singleDigit
argument_list|(
literal|"\\b([0-9])\\b"
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
name|children
init|=
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|childNodes
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|children
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|child
operator|!=
name|relative
condition|)
block|{
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
comment|// Check whether the page is part of a group or is the group
comment|// definition page.
name|QString
name|group
decl_stmt|;
name|bool
name|isGroupPage
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fakeNode
operator|->
name|doc
argument_list|()
operator|.
name|metaCommandsUsed
argument_list|()
operator|.
name|contains
argument_list|(
literal|"group"
argument_list|)
condition|)
block|{
name|group
operator|=
name|fakeNode
operator|->
name|doc
argument_list|()
operator|.
name|metaCommandArgs
argument_list|(
literal|"group"
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|isGroupPage
operator|=
literal|true
expr_stmt|;
block|}
comment|// there are too many examples; they would clutter the list
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
condition|)
continue|continue;
comment|// not interested either in individual (Qt Designer etc.) manual chapters
if|if
condition|(
name|fakeNode
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|ContentsLink
argument_list|)
condition|)
continue|continue;
comment|// Discard external nodes.
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
continue|continue;
name|QString
name|sortKey
init|=
name|fakeNode
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|isGroupPage
condition|)
block|{
comment|// If we encounter a group definition page, we add all
comment|// the pages in that group to the list for that group.
foreach|foreach
control|(
name|Node
modifier|*
name|member
decl|,
name|fakeNode
operator|->
name|groupMembers
argument_list|()
control|)
block|{
if|if
condition|(
name|member
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Fake
condition|)
continue|continue;
name|FakeNode
modifier|*
name|page
init|=
cast|static_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
condition|)
block|{
name|QString
name|sortKey
init|=
name|page
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
name|fakeNodeMap
index|[
cast|const_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|fakeNode
argument_list|)
index|]
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|groupTitlesMap
index|[
name|fakeNode
operator|->
name|fullTitle
argument_list|()
index|]
operator|=
cast|const_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|fakeNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isGroupPage
condition|)
block|{
comment|// If we encounter a page that belongs to a group then
comment|// we add that page to the list for that group.
specifier|const
name|FakeNode
modifier|*
name|groupNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|findNode
argument_list|(
name|group
argument_list|,
name|Node
operator|::
name|Fake
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupNode
condition|)
name|fakeNodeMap
index|[
name|groupNode
index|]
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|fakeNode
argument_list|)
expr_stmt|;
comment|//else
comment|//    uncategorizedNodeMap.insert(sortKey, fakeNode);
block|}
comment|// else
comment|//    uncategorizedNodeMap.insert(sortKey, fakeNode);
block|}
comment|// else
comment|//    uncategorizedNodeMap.insert(sortKey, fakeNode);
block|}
block|}
comment|// We now list all the pages found that belong to groups.
comment|// If only certain pages were found for a group, but the definition page
comment|// for that group wasn't listed, the list of pages will be intentionally
comment|// incomplete. However, if the group definition page was listed, all the
comment|// pages in that group are listed for completeness.
if|if
condition|(
operator|!
name|fakeNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|groupTitle
decl|,
name|groupTitlesMap
operator|.
name|keys
argument_list|()
control|)
block|{
specifier|const
name|FakeNode
modifier|*
name|groupNode
init|=
name|groupTitlesMap
index|[
name|groupTitle
index|]
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|linkForNode
argument_list|(
name|groupNode
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|groupNode
operator|->
name|fullTitle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
if|if
condition|(
name|fakeNodeMap
index|[
name|groupNode
index|]
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|FakeNode
modifier|*
name|fakeNode
decl|,
name|fakeNodeMap
index|[
name|groupNode
index|]
control|)
block|{
name|QString
name|title
init|=
name|fakeNode
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|startsWith
argument_list|(
literal|"The "
argument_list|)
condition|)
name|title
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|linkForNode
argument_list|(
name|fakeNode
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
if|if
condition|(
operator|!
name|uncategorizedNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Miscellaneous"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|FakeNode
modifier|*
name|fakeNode
decl|,
name|uncategorizedNodeMap
control|)
block|{
name|QString
name|title
init|=
name|fakeNode
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|startsWith
argument_list|(
literal|"The "
argument_list|)
condition|)
name|title
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|linkForNode
argument_list|(
name|fakeNode
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
end_function
begin_comment
comment|/*!   Write the XML for a standard section of a page, e.g.   "Public Functions" or "Protected Slots." The section   is written too the current XML stream as a table.  */
end_comment
begin_function
DECL|function|generateSection
name|void
name|DitaXmlGenerator
operator|::
name|generateSection
parameter_list|(
specifier|const
name|NodeList
modifier|&
name|nl
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|nl
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|nl
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|QString
name|marked
init|=
name|getMarkedUpSynopsis
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|style
argument_list|)
decl_stmt|;
name|writeText
argument_list|(
name|marked
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
operator|++
name|m
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
end_function
begin_comment
comment|/*!   Writes the "inherited from" list to the current XML stream.  */
end_comment
begin_function
DECL|function|generateSectionInheritedList
name|void
name|DitaXmlGenerator
operator|::
name|generateSectionInheritedList
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|section
operator|.
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|InnerNode
modifier|*
argument_list|,
name|int
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|section
operator|.
name|inherited
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|section
operator|.
name|inherited
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|QString
name|text
decl_stmt|;
name|text
operator|.
name|setNum
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|second
argument_list|)
expr_stmt|;
name|text
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|second
operator|==
literal|1
condition|)
name|text
operator|+=
name|section
operator|.
name|singularMember
expr_stmt|;
else|else
name|text
operator|+=
name|section
operator|.
name|pluralMember
expr_stmt|;
name|text
operator|+=
literal|" inherited from "
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
comment|// zzz
name|text
operator|=
name|fileName
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|text
operator|+=
name|DitaXmlGenerator
operator|::
name|cleanRef
argument_list|(
name|section
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|protectEnc
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
argument_list|,
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
operator|++
name|p
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
end_function
begin_comment
comment|/*!   Get the synopsis from the \a node using the \a relative   node if needed, and mark up the synopsis using \a marker.   Use the style to decide which kind of sysnopsis to build,   normally \c Summary or \c Detailed. Return the marked up   string.  */
end_comment
begin_function
DECL|function|getMarkedUpSynopsis
name|QString
name|DitaXmlGenerator
operator|::
name|getMarkedUpSynopsis
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpSynopsis
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|style
argument_list|)
decl_stmt|;
name|QRegExp
name|tag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|tag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|tmp
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|tag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|tag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i> \\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|marked.replace("<@param>","<i>");     marked.replace("</@param>","</i>");
endif|#
directive|endif
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@name>"
argument_list|)
expr_stmt|;
comment|// was "<b>"
name|marked
operator|.
name|remove
argument_list|(
literal|"</@name>"
argument_list|)
expr_stmt|;
comment|// was "</b>"
block|}
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|QRegExp
name|extraRegExp
argument_list|(
literal|"<@extra>.*</@extra>"
argument_list|)
decl_stmt|;
name|extraRegExp
operator|.
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
name|extraRegExp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else {         marked.replace("<@extra>","<tt>");         marked.replace("</@extra>","</tt>");     }
endif|#
directive|endif
if|if
condition|(
name|style
operator|!=
name|CodeMarker
operator|::
name|Detailed
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
return|return
name|marked
return|;
block|}
end_function
begin_comment
comment|/*!   Renamed from highlightedCode() in the html generator. Gets the text   from \a markedCode , and then the text is written to the current XML   stream.  */
end_comment
begin_function
DECL|function|writeText
name|void
name|DitaXmlGenerator
operator|::
name|writeText
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QString
name|src
init|=
name|markedCode
decl_stmt|;
name|QString
name|text
decl_stmt|;
name|QStringRef
name|arg
decl_stmt|;
name|QStringRef
name|par1
decl_stmt|;
specifier|const
name|QChar
name|charLangle
init|=
literal|'<'
decl_stmt|;
specifier|const
name|QChar
name|charAt
init|=
literal|'@'
decl_stmt|;
comment|/*       First strip out all the extraneous markup. The table       below contains the markup we want to keep. Everything       else that begins with "<@" or "</@" is stripped out.      */
specifier|static
specifier|const
name|QString
name|spanTags
index|[]
init|=
block|{
literal|"<@link "
block|,
literal|"<@link "
block|,
literal|"<@type>"
block|,
literal|"<@type>"
block|,
literal|"<@headerfile>"
block|,
literal|"<@headerfile>"
block|,
literal|"<@func>"
block|,
literal|"<@func>"
block|,
literal|"<@func "
block|,
literal|"<@func "
block|,
literal|"<@param>"
block|,
literal|"<@param>"
block|,
literal|"<@extra>"
block|,
literal|"<@extra>"
block|,
literal|"</@link>"
block|,
literal|"</@link>"
block|,
literal|"</@type>"
block|,
literal|"</@type>"
block|,
literal|"</@headerfile>"
block|,
literal|"</@headerfile>"
block|,
literal|"</@func>"
block|,
literal|"</@func>"
block|,
literal|"</@param>"
block|,
literal|"</@param>"
block|,
literal|"</@extra>"
block|,
literal|"</@extra>"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
condition|)
block|{
name|bool
name|handled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|!=
literal|13
condition|;
operator|++
name|k
control|)
block|{
specifier|const
name|QString
modifier|&
name|tag
init|=
name|spanTags
index|[
literal|2
operator|*
name|k
index|]
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|text
operator|+=
name|spanTags
index|[
literal|2
operator|*
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charAt
operator|||
operator|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
operator|)
condition|)
block|{
comment|// drop 'our' unknown tags (the ones still containing '@')
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// retain all others
name|text
operator|+=
name|charLangle
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|text
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
comment|// replace all<@link> tags: "(<@link node=\"([^\"]+)\">).*(</@link>)"
comment|// replace all "(<@(type|headerfile|func)(?: +[^>]*)?>)(.*)(</@\\2>)" tags
name|src
operator|=
name|text
expr_stmt|;
name|text
operator|=
name|QString
argument_list|()
expr_stmt|;
specifier|static
specifier|const
name|QString
name|markTags
index|[]
init|=
block|{
comment|// 0       1         2           3       4        5
literal|"link"
block|,
literal|"type"
block|,
literal|"headerfile"
block|,
literal|"func"
block|,
literal|"param"
block|,
literal|"extra"
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|!=
literal|6
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|markTags
index|[
name|k
index|]
argument_list|,
operator|&
name|i
argument_list|,
name|n
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
comment|//<@link>
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|par1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|==
literal|4
condition|)
block|{
comment|//<@param>
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_i
argument_list|)
expr_stmt|;
comment|//writeCharacters(" " + arg.toString());
name|writeCharacters
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</i>
block|}
elseif|else
if|if
condition|(
name|k
operator|==
literal|5
condition|)
block|{
comment|//<@extra>
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|DT_tt
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tt>
block|}
else|else
block|{
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
name|QString
name|link
decl_stmt|;
name|n
operator|=
name|marker
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|tree_
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|link
operator|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeCharacters
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// (zzz) Is this correct for all cases?
name|link
operator|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
name|text
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateLink
name|void
name|DitaXmlGenerator
operator|::
name|generateLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
comment|/* relative */
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|static
name|QRegExp
name|camelCase
argument_list|(
literal|"[A-Z][A-Z][a-z]|[a-z][A-Z0-9]|_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcLeftParen
operator|.
name|indexIn
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|marker
operator|->
name|recognizeLanguage
argument_list|(
literal|"Cpp"
argument_list|)
condition|)
block|{
comment|// hack for C++: move () outside of link
name|int
name|k
init|=
name|funcLeftParen
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|left
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</i>
block|}
else|else
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
name|inLink
operator|=
literal|false
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker
operator|->
name|recognizeLanguage
argument_list|(
literal|"Java"
argument_list|)
condition|)
block|{
comment|// hack for Java: remove () and use<tt> when appropriate
name|bool
name|func
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
decl_stmt|;
name|bool
name|tt
init|=
operator|(
name|func
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
name|camelCase
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|tt
condition|)
name|writeStartTag
argument_list|(
name|DT_tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|left
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</tt>
block|}
else|else
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanRef
name|QString
name|DitaXmlGenerator
operator|::
name|cleanRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clean
return|;
name|clean
operator|.
name|reserve
argument_list|(
name|ref
operator|.
name|size
argument_list|()
operator|+
literal|20
argument_list|)
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'~'
condition|)
block|{
name|clean
operator|+=
literal|"dtor."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'_'
condition|)
block|{
name|clean
operator|+=
literal|"underscore."
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ref
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
name|u
operator|==
literal|'-'
operator|||
name|u
operator|==
literal|'_'
operator|||
name|u
operator|==
literal|':'
operator|||
name|u
operator|==
literal|'.'
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'!'
condition|)
block|{
name|clean
operator|+=
literal|"-not"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'&'
condition|)
block|{
name|clean
operator|+=
literal|"-and"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'<'
condition|)
block|{
name|clean
operator|+=
literal|"-lt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'='
condition|)
block|{
name|clean
operator|+=
literal|"-eq"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'>'
condition|)
block|{
name|clean
operator|+=
literal|"-gt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'#'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|clean
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|registerRef
name|QString
name|DitaXmlGenerator
operator|::
name|registerRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
init|=
name|DitaXmlGenerator
operator|::
name|cleanRef
argument_list|(
name|ref
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QString
modifier|&
name|prevRef
init|=
name|refMap
index|[
name|clean
operator|.
name|toLower
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|prevRef
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prevRef
operator|=
name|ref
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|prevRef
operator|==
name|ref
condition|)
break|break;
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
block|}
return|return
name|clean
return|;
block|}
end_function
begin_comment
comment|/*!   Calls protect() with the \a string. Returns the result.  */
end_comment
begin_function
DECL|function|protectEnc
name|QString
name|DitaXmlGenerator
operator|::
name|protectEnc
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
return|return
name|protect
argument_list|(
name|string
argument_list|,
name|outputEncoding
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|protect
name|QString
name|DitaXmlGenerator
operator|::
name|protect
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
comment|//outputEncoding)
block|{
DECL|macro|APPEND
define|#
directive|define
name|APPEND
parameter_list|(
name|x
parameter_list|)
define|\
value|if (xml.isEmpty()) { \     xml = string; \     xml.truncate(i); \ } \     xml += (x);
name|QString
name|xml
decl_stmt|;
name|int
name|n
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if ((outputEncoding == "ISO-8859-1"&& ch.unicode()> 0x007F) ||                  (ch == QLatin1Char('*')&& i + 1< n&& string.at(i) == QLatin1Char('/')) ||                  (ch == QLatin1Char('.')&& i> 2&& string.at(i - 2) == QLatin1Char('.'))) {
comment|// we escape '*/' and the last dot in 'e.g.' and 'i.e.' for the Javadoc generator
if|APPEND("&#x");             xml += QString::number(ch.unicode(), 16);             xml += QLatin1Char(';');         }
endif|#
directive|endif
else|else
block|{
if|if
condition|(
operator|!
name|xml
operator|.
name|isEmpty
argument_list|()
condition|)
name|xml
operator|+=
name|ch
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|xml
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|xml
return|;
return|return
name|string
return|;
DECL|macro|APPEND
undef|#
directive|undef
name|APPEND
block|}
end_function
begin_comment
comment|/*!   Constructs a file name appropriate for the \a node   and returns the file name.  */
end_comment
begin_function
DECL|function|fileBase
name|QString
name|DitaXmlGenerator
operator|::
name|fileBase
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
name|result
operator|=
name|Generator
operator|::
name|fileBase
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!node->isInnerNode()) {         switch (node->status()) {         case Node::Compat:             result += "-qt3";             break;         case Node::Obsolete:             result += "-obsolete";             break;         default:             ;         }     }
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|guidForNode
name|QString
name|DitaXmlGenerator
operator|::
name|guidForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
default|default:
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|Typedef
case|:
block|{
specifier|const
name|TypedefNode
modifier|*
name|tdn
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdn
operator|->
name|associatedEnum
argument_list|()
condition|)
return|return
name|guidForNode
argument_list|(
name|tdn
operator|->
name|associatedEnum
argument_list|()
argument_list|)
return|;
block|}
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|Function
case|:
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
return|return
name|guidForNode
argument_list|(
name|fn
operator|->
name|associatedProperty
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|QString
name|ref
init|=
name|fn
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|ref
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|fn
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fn
operator|->
name|guid
argument_list|()
return|;
block|}
case|case
name|Node
operator|::
name|Fake
case|:
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
condition|)
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|Property
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|QmlSignal
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|QmlMethod
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|Variable
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
case|case
name|Node
operator|::
name|Target
case|:
return|return
name|node
operator|->
name|guid
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs a file name appropriate for the \a node and returns   it. If the \a node is not a fake node, or if it is a fake node but   it is neither an external page node nor an image node, call the   PageGenerator::fileName() function.  */
end_comment
begin_function
DECL|function|fileName
name|QString
name|DitaXmlGenerator
operator|::
name|fileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
block|}
return|return
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|linkForNode
name|QString
name|DitaXmlGenerator
operator|::
name|linkForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
name|node
operator|==
name|relative
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
if|if
condition|(
name|fileBase
argument_list|(
name|node
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fn
init|=
name|fileName
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
name|node
operator|->
name|parent
argument_list|()
operator|!=
name|relative
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isAbstract
argument_list|()
condition|)
block|{
comment|/*                   This is a bit of a hack. What we discover with                   the three 'if' statements immediately above,                   is that node's parent is marked \qmlabstract                   but the link appears in a qdoc comment for a                   subclass of the node's parent. This means the                   link should refer to the file for the relative                   node, not the file for node.                  */
name|fn
operator|=
name|fileName
argument_list|(
name|relative
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG_ABSTRACT
name|qDebug
argument_list|()
operator|<<
literal|"ABSTRACT:"
operator|<<
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|<<
name|node
operator|->
name|name
argument_list|()
operator|<<
name|relative
operator|->
name|name
argument_list|()
operator|<<
name|node
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|<<
name|node
operator|->
name|parent
argument_list|()
operator|->
name|subType
argument_list|()
operator|<<
name|relative
operator|->
name|type
argument_list|()
operator|<<
name|relative
operator|->
name|subType
argument_list|()
operator|<<
name|outFileName
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|QString
name|link
init|=
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
operator|||
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QString
name|guid
init|=
name|guidForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|relative
operator|&&
name|fn
operator|==
name|fileName
argument_list|(
name|relative
argument_list|)
operator|&&
name|guid
operator|==
name|guidForNode
argument_list|(
name|relative
argument_list|)
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|link
operator|+=
name|guid
expr_stmt|;
block|}
comment|/*       If the output is going to subdirectories, then if the       two nodes will be output to different directories, then       the link must go up to the parent directory and then       back down into the other subdirectory.      */
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
operator|(
name|node
operator|!=
name|relative
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|!=
name|relative
operator|->
name|outputSubdirectory
argument_list|()
condition|)
name|link
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
literal|"../"
operator|+
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function
begin_function
DECL|function|refForAtom
name|QString
name|DitaXmlGenerator
operator|::
name|refForAtom
parameter_list|(
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
comment|/* node */
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Target
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|generateFullName
name|void
name|DitaXmlGenerator
operator|::
name|generateFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|apparentNode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Node
modifier|*
name|actualNode
parameter_list|)
block|{
if|if
condition|(
name|actualNode
operator|==
literal|0
condition|)
name|actualNode
operator|=
name|apparentNode
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|QString
name|href
init|=
name|linkForNode
argument_list|(
name|actualNode
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|writeHrefAttribute
argument_list|(
name|href
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|protectEnc
argument_list|(
name|fullName
argument_list|(
name|apparentNode
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
block|}
end_function
begin_function
DECL|function|findAllClasses
name|void
name|DitaXmlGenerator
operator|::
name|findAllClasses
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|className
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|className
expr_stmt|;
if|if
condition|(
operator|!
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|hideFromMainList
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Compat
condition|)
block|{
name|compatClasses
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|obsoleteClasses
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonCompatClasses
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Main
condition|)
name|mainClasses
operator|.
name|insert
argument_list|(
name|className
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|QString
name|moduleName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|moduleName
argument_list|()
decl_stmt|;
if|if
condition|(
name|moduleName
operator|==
literal|"Qt3SupportLight"
condition|)
block|{
name|moduleClassMap
index|[
name|moduleName
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|moduleName
operator|=
literal|"Qt3Support"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moduleName
operator|.
name|isEmpty
argument_list|()
condition|)
name|moduleClassMap
index|[
name|moduleName
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|QString
name|serviceName
init|=
operator|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|)
operator|->
name|serviceName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
condition|)
name|serviceClasses
operator|.
name|insert
argument_list|(
name|serviceName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|qmlClassName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|qmlClasses
operator|.
name|insert
argument_list|(
name|qmlClassName
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|findAllClasses
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findAllFunctions
name|void
name|DitaXmlGenerator
operator|::
name|findAllFunctions
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|findAllFunctions
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func
operator|->
name|status
argument_list|()
operator|>
name|Node
operator|::
name|Obsolete
operator|)
operator|&&
operator|!
name|func
operator|->
name|isInternal
argument_list|()
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Ctor
operator|)
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|Dtor
operator|)
condition|)
block|{
name|funcIndex
index|[
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|parent
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findAllLegaleseTexts
name|void
name|DitaXmlGenerator
operator|::
name|findAllLegaleseTexts
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|legaleseTexts
operator|.
name|insertMulti
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|legaleseText
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
name|findAllLegaleseTexts
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findAllNamespaces
name|void
name|DitaXmlGenerator
operator|::
name|findAllNamespaces
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|findAllNamespaces
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
specifier|const
name|NamespaceNode
modifier|*
name|nspace
init|=
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
comment|// Ensure that the namespace's name is not empty (the root
comment|// namespace has no name).
if|if
condition|(
operator|!
name|nspace
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|namespaceIndex
operator|.
name|insert
argument_list|(
name|nspace
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|QString
name|moduleName
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|moduleName
argument_list|()
decl_stmt|;
if|if
condition|(
name|moduleName
operator|==
literal|"Qt3SupportLight"
condition|)
block|{
name|moduleNamespaceMap
index|[
name|moduleName
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|moduleName
operator|=
literal|"Qt3Support"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moduleName
operator|.
name|isEmpty
argument_list|()
condition|)
name|moduleNamespaceMap
index|[
name|moduleName
index|]
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   We're writing an attribute that indicates that the text   data is a heading, hence, h1, h2, h3... etc, and we must   decide which number to use.  */
end_comment
begin_function
DECL|function|hOffset
name|int
name|DitaXmlGenerator
operator|::
name|hOffset
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
return|return
literal|2
return|;
case|case
name|Node
operator|::
name|Fake
case|:
return|return
literal|1
return|;
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
default|default:
return|return
literal|3
return|;
block|}
block|}
end_function
begin_function
DECL|function|isThreeColumnEnumValueTable
name|bool
name|DitaXmlGenerator
operator|::
name|isThreeColumnEnumValueTable
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListRight
operator|&&
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
operator|)
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListItemLeft
operator|&&
operator|!
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ListItemRight
argument_list|)
condition|)
return|return
literal|true
return|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|DitaXmlGenerator
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|node
operator|=
name|relative
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
name|node
operator|=
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|findNode
argument_list|(
name|target
argument_list|,
name|Node
operator|::
name|Fake
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker
condition|)
block|{
name|node
operator|=
name|marker
operator|->
name|resolveTarget
argument_list|(
name|target
argument_list|,
name|tree_
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|tree_
operator|->
name|findFakeNodeByTitle
argument_list|(
name|target
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|&&
name|atom
condition|)
block|{
name|node
operator|=
name|tree_
operator|->
name|findUnambiguousTarget
argument_list|(
name|target
argument_list|,
operator|*
cast|const_cast
argument_list|<
name|Atom
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|atom
argument_list|)
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|node
condition|)
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|anchorForNode
specifier|const
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|DitaXmlGenerator
operator|::
name|anchorForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|anchorPair
decl_stmt|;
name|anchorPair
operator|.
name|first
operator|=
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|anchorPair
operator|.
name|second
operator|=
name|fakeNode
operator|->
name|title
argument_list|()
expr_stmt|;
block|}
return|return
name|anchorPair
return|;
block|}
end_function
begin_function
DECL|function|getLink
name|QString
name|DitaXmlGenerator
operator|::
name|getLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Node
modifier|*
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|link
decl_stmt|;
operator|*
name|node
operator|=
literal|0
expr_stmt|;
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"http:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"https:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"ftp:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"mailto:"
argument_list|)
operator|)
condition|)
block|{
name|link
operator|=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|path
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|'#'
argument_list|)
condition|)
name|path
operator|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
else|else
name|path
operator|.
name|append
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
name|Atom
modifier|*
name|targetAtom
init|=
literal|0
decl_stmt|;
name|QString
name|first
init|=
name|path
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|node
operator|=
name|relative
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
operator|*
name|node
operator|=
name|tree_
operator|->
name|root
argument_list|()
operator|->
name|findNode
argument_list|(
name|first
argument_list|,
name|Node
operator|::
name|Fake
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|node
operator|=
name|marker
operator|->
name|resolveTarget
argument_list|(
name|first
argument_list|,
name|tree_
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
operator|*
name|node
operator|=
name|tree_
operator|->
name|findFakeNodeByTitle
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
operator|*
name|node
operator|=
name|tree_
operator|->
name|findUnambiguousTarget
argument_list|(
name|first
argument_list|,
name|targetAtom
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|node
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
return|;
block|}
else|else
block|{
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|node
operator|=
name|relative
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|node
operator|&&
operator|(
operator|*
name|node
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|(
name|relative
operator|->
name|parent
argument_list|()
operator|!=
operator|*
name|node
operator|)
operator|&&
operator|(
name|relative
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Obsolete
operator|)
condition|)
block|{
name|bool
name|porting
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fake
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|fake
operator|->
name|title
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Porting"
argument_list|)
condition|)
name|porting
operator|=
literal|true
expr_stmt|;
block|}
name|QString
name|name
init|=
name|marker
operator|->
name|plainFullName
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|porting
operator|&&
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"Q3"
argument_list|)
condition|)
block|{
if|if
condition|(
name|obsoleteLinks
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Link to obsolete item '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inObsoleteLink
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|targetAtom
operator|=
name|tree_
operator|->
name|findTarget
argument_list|(
name|path
operator|.
name|first
argument_list|()
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetAtom
operator|==
literal|0
condition|)
break|break;
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|link
operator|=
name|linkForNode
argument_list|(
operator|*
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node
operator|&&
operator|(
operator|*
name|node
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
name|link
operator|=
literal|"images/used-in-examples/"
operator|+
name|link
expr_stmt|;
if|if
condition|(
name|targetAtom
condition|)
block|{
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
name|link
operator|=
name|outFileName
argument_list|()
expr_stmt|;
name|QString
name|guid
init|=
name|lookupGuid
argument_list|(
name|link
argument_list|,
name|refForAtom
argument_list|(
name|targetAtom
argument_list|,
operator|*
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|guid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|*
name|node
operator|&&
operator|(
name|link
operator|.
name|endsWith
argument_list|(
literal|".xml"
argument_list|)
operator|||
name|link
operator|.
name|endsWith
argument_list|(
literal|".dita"
argument_list|)
operator|)
condition|)
block|{
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
operator|(
operator|*
name|node
operator|)
operator|->
name|guid
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*           If the output is going to subdirectories, then if the           two nodes will be output to different directories, then           the link must go up to the parent directory and then           back down into the other subdirectory.         */
if|if
condition|(
name|link
operator|.
name|startsWith
argument_list|(
literal|"images/"
argument_list|)
condition|)
block|{
name|link
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
literal|"../"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|node
operator|&&
name|relative
operator|&&
operator|(
operator|*
name|node
operator|!=
name|relative
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|node
operator|)
operator|->
name|outputSubdirectory
argument_list|()
operator|!=
name|relative
operator|->
name|outputSubdirectory
argument_list|()
condition|)
block|{
name|link
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
literal|"../"
operator|+
operator|(
operator|*
name|node
operator|)
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|link
operator|.
name|isEmpty
argument_list|()
operator|&&
name|link
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|link
operator|.
name|prepend
argument_list|(
name|outFileName
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"LOCAL LINK:"
operator|<<
name|link
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function
begin_comment
comment|/*!   This function can be called if getLink() returns an empty   string.  */
end_comment
begin_function
DECL|function|getDisambiguationLink
name|QString
name|DitaXmlGenerator
operator|::
name|getDisambiguationLink
parameter_list|(
specifier|const
name|Atom
modifier|*
parameter_list|,
name|CodeMarker
modifier|*
parameter_list|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Unimplemented function called: "
operator|<<
literal|"QString DitaXmlGenerator::getDisambiguationLink()"
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|generateIndex
name|void
name|DitaXmlGenerator
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileBase
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|tree_
operator|->
name|generateIndex
argument_list|(
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|fileBase
operator|+
literal|".index"
argument_list|,
name|url
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateStatus
name|void
name|DitaXmlGenerator
operator|::
name|generateStatus
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|text
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is part of the Qt 3 support library."
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" It is provided to keep old source code working. "
operator|<<
literal|"We strongly advise against "
operator|<<
literal|"using it in new code. See "
expr_stmt|;
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
name|tree_
operator|->
name|findFakeNodeByTitle
argument_list|(
literal|"Porting To Qt 4"
argument_list|)
decl_stmt|;
name|Atom
modifier|*
name|targetAtom
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fakeNode
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|QString
name|oldName
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|oldName
operator|.
name|remove
argument_list|(
name|QLatin1Char
argument_list|(
literal|'3'
argument_list|)
argument_list|)
expr_stmt|;
name|targetAtom
operator|=
name|tree_
operator|->
name|findTarget
argument_list|(
name|oldName
argument_list|,
name|fakeNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetAtom
condition|)
block|{
name|QString
name|fn
init|=
name|fileName
argument_list|(
name|fakeNode
argument_list|)
decl_stmt|;
name|QString
name|guid
init|=
name|lookupGuid
argument_list|(
name|fn
argument_list|,
name|refForAtom
argument_list|(
name|targetAtom
argument_list|,
name|fakeNode
argument_list|)
argument_list|)
decl_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|GuidLink
argument_list|,
name|fn
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|guid
argument_list|)
expr_stmt|;
block|}
else|else
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
literal|" for more information."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
block|}
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|beginLink
name|void
name|DitaXmlGenerator
operator|::
name|beginLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|link
parameter_list|)
block|{
name|this
operator|->
name|link
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_xref
argument_list|)
expr_stmt|;
comment|// formathtml
name|writeHrefAttribute
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|inLink
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endLink
name|void
name|DitaXmlGenerator
operator|::
name|endLink
parameter_list|()
block|{
if|if
condition|(
name|inLink
condition|)
block|{
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</i>
block|}
else|else
block|{
if|if
condition|(
name|inObsoleteLink
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_sup
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"(obsolete)"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</sup>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</xref>
block|}
block|}
name|inLink
operator|=
literal|false
expr_stmt|;
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates the summary for the \a section. Only used for   sections of QML element documentation.    Currently handles only the QML property group.  */
end_comment
begin_function
DECL|function|generateQmlSummary
name|void
name|DitaXmlGenerator
operator|::
name|generateQmlSummary
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
decl_stmt|;
name|m
operator|=
name|section
operator|.
name|members
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|section
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|generateQmlItem
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
operator|++
name|m
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
end_function
begin_comment
comment|/*!   Outputs the DITA detailed documentation for a section   on a QML element reference page.  */
end_comment
begin_function
DECL|function|generateDetailedQmlMember
name|void
name|DitaXmlGenerator
operator|::
name|generateDetailedQmlMember
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QString
name|marked
decl_stmt|;
specifier|const
name|QmlPropertyNode
modifier|*
name|qpn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|QmlPropGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropGroupNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|qpn
argument_list|)
expr_stmt|;
name|QString
name|attr
decl_stmt|;
name|int
name|ro
init|=
name|qpn
operator|->
name|getReadOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|ro
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|tree_
argument_list|)
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ro
operator|>
literal|0
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
if|if
condition|(
name|qpgn
operator|->
name|isDefault
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|attr
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|attr
operator|+=
literal|"default"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
operator|++
name|p
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/*           If the QML property node has a single subproperty,           override, replace qpn with that override node and           proceed as normal.          */
if|if
condition|(
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
name|qpn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/*           Now qpn either has no overrides, or it has more           than 1. If it has none, proceed to output as nortmal.          */
if|if
condition|(
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|qpn
argument_list|)
expr_stmt|;
name|QString
name|attr
decl_stmt|;
name|int
name|ro
init|=
name|qpn
operator|->
name|getReadOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|ro
operator|<
literal|0
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
name|qpn
operator|->
name|declarativeCppNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|tree_
argument_list|)
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ro
operator|>
literal|0
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|attr
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|attr
operator|+=
literal|"default"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
else|else
block|{
comment|/*               The QML property node has multiple override nodes.               Process the whole list as we would for a QML property               group.              */
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|q
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
name|QString
name|attr
decl_stmt|;
name|int
name|ro
init|=
name|qpn
operator|->
name|getReadOnly
argument_list|()
decl_stmt|;
if|if
condition|(
name|ro
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|tree_
argument_list|)
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ro
operator|>
literal|0
condition|)
name|attr
operator|=
literal|"read-only"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|attr
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|attr
operator|+=
literal|"default"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attr
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|generateQmlItem
argument_list|(
name|q
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
block|}
operator|++
name|p
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
condition|)
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|marked
operator|=
name|getMarkedUpSynopsis
argument_list|(
name|n
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|writeText
argument_list|(
name|marked
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
condition|)
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|marked
operator|=
name|getMarkedUpSynopsis
argument_list|(
name|n
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|writeText
argument_list|(
name|marked
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
condition|)
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_ul
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_li
argument_list|)
expr_stmt|;
name|writeGuidAttribute
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|marked
operator|=
name|getMarkedUpSynopsis
argument_list|(
name|n
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|writeText
argument_list|(
name|marked
argument_list|,
name|marker
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</li>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</ul>
block|}
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Output the "Inherits" line for the QML element,   if there should be one.  */
end_comment
begin_function
DECL|function|generateQmlInherits
name|void
name|DitaXmlGenerator
operator|::
name|generateQmlInherits
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcn
condition|)
return|return;
specifier|const
name|FakeNode
modifier|*
name|base
init|=
name|qcn
operator|->
name|qmlBase
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"inherits"
argument_list|)
expr_stmt|;
name|Text
name|text
decl_stmt|;
name|text
operator|<<
literal|"[Inherits "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|base
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"]"
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[Xxx instantiates the C++ class QmlGraphicsXxx]"   line for the QML element, if there should be one.    If there is no class node, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateQmlInstantiates
name|void
name|DitaXmlGenerator
operator|::
name|generateQmlInstantiates
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
operator|(
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"instantiates"
argument_list|)
expr_stmt|;
name|Text
name|text
decl_stmt|;
name|text
operator|<<
literal|"["
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" instantiates the C++ class "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"]"
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[QmlGraphicsXxx is instantiated by QML element Xxx]"   line for the class, if there should be one.    If there is no QML element, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateInstantiatedBy
name|void
name|DitaXmlGenerator
operator|::
name|generateInstantiatedBy
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|&&
name|cn
operator|->
name|qmlElement
argument_list|()
operator|!=
literal|0
condition|)
block|{
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|cn
operator|->
name|qmlElement
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_p
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"instantiated-by"
argument_list|)
expr_stmt|;
name|Text
name|text
decl_stmt|;
name|text
operator|<<
literal|"["
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" is instantiated by QML element "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|"]"
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</p>
block|}
block|}
end_function
begin_comment
comment|/*!   Return the full qualification of the node \a n, but without   the name of \a n itself. e.g. A::B::C  */
end_comment
begin_function
DECL|function|fullQualification
name|QString
name|DitaXmlGenerator
operator|::
name|fullQualification
parameter_list|(
specifier|const
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|QString
name|fq
decl_stmt|;
name|InnerNode
modifier|*
name|in
init|=
name|n
operator|->
name|parent
argument_list|()
decl_stmt|;
while|while
condition|(
name|in
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|)
operator|||
operator|(
name|in
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
if|if
condition|(
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
name|fq
operator|=
name|in
operator|->
name|name
argument_list|()
expr_stmt|;
else|else
name|fq
operator|=
name|in
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|fq
expr_stmt|;
block|}
else|else
break|break;
name|in
operator|=
name|in
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
name|fq
return|;
block|}
end_function
begin_comment
comment|/*!   Outputs the<cxxClassDerivations> element.   \code<cxxClassDerivations><cxxClassDerivation>    ...</cxxClassDerivation>   ...</cxxClassDerivations>   \endcode    The<cxxClassDerivation> element is:    \code<cxxClassDerivation><cxxClassDerivationAccessSpecifier value="public"/><cxxClassBaseClass href="class_base">Base</cxxClassBaseClass></cxxClassDerivation>   \endcode  */
end_comment
begin_function
DECL|function|writeDerivations
name|void
name|DitaXmlGenerator
operator|::
name|writeDerivations
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxClassDerivations
argument_list|)
expr_stmt|;
name|r
operator|=
name|cn
operator|->
name|baseClasses
argument_list|()
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|cn
operator|->
name|baseClasses
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxClassDerivation
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassDerivationAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
operator|(
operator|*
name|r
operator|)
operator|.
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDerivationAccessSpecifier>
comment|// not included:<cxxClassDerivationVirtual>
name|writeStartTag
argument_list|(
name|DT_cxxClassBaseClass
argument_list|)
expr_stmt|;
name|QString
name|attr
init|=
name|fileName
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|guid
argument_list|()
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassBaseClass>
comment|// not included:<ClassBaseStruct> or<cxxClassBaseUnion>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDerivation>
comment|// not included:<cxxStructDerivation>
operator|++
name|r
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxClassDerivations>
block|}
block|}
end_function
begin_comment
comment|/*!   Writes a<cxxXXXAPIItemLocation> element, depending on the   type of the node \a n, which can be a class, function, enum,   typedef, or property.  */
end_comment
begin_function
DECL|function|writeLocation
name|void
name|DitaXmlGenerator
operator|::
name|writeLocation
parameter_list|(
specifier|const
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|DitaTag
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3a
decl_stmt|,
name|s3b
decl_stmt|;
name|s1
operator|=
name|DT_cxxClassAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxClassDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxClassDeclarationFileLineStart
expr_stmt|;
name|s3b
operator|=
name|DT_cxxClassDeclarationFileLineEnd
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|||
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|s1
operator|=
name|DT_cxxClassAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxClassDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxClassDeclarationFileLineStart
expr_stmt|;
name|s3b
operator|=
name|DT_cxxClassDeclarationFileLineEnd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
block|{
name|s1
operator|=
name|DT_cxxDefineAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxDefineDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxDefineDeclarationFileLine
expr_stmt|;
name|s3b
operator|=
name|DT_NONE
expr_stmt|;
block|}
else|else
block|{
name|s1
operator|=
name|DT_cxxFunctionAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxFunctionDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxFunctionDeclarationFileLine
expr_stmt|;
name|s3b
operator|=
name|DT_NONE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
name|s1
operator|=
name|DT_cxxEnumerationAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxEnumerationDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxEnumerationDeclarationFileLineStart
expr_stmt|;
name|s3b
operator|=
name|DT_cxxEnumerationDeclarationFileLineEnd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
name|s1
operator|=
name|DT_cxxTypedefAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxTypedefDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxTypedefDeclarationFileLine
expr_stmt|;
name|s3b
operator|=
name|DT_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
operator|)
operator|||
operator|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
operator|)
condition|)
block|{
name|s1
operator|=
name|DT_cxxVariableAPIItemLocation
expr_stmt|;
name|s2
operator|=
name|DT_cxxVariableDeclarationFile
expr_stmt|;
name|s3a
operator|=
name|DT_cxxVariableDeclarationFileLine
expr_stmt|;
name|s3b
operator|=
name|DT_NONE
expr_stmt|;
block|}
name|writeStartTag
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"filePath"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|n
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<s2>
name|writeStartTag
argument_list|(
name|s3a
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"lineNumber"
argument_list|)
expr_stmt|;
name|QString
name|lineNr
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|lineNr
operator|.
name|setNum
argument_list|(
name|n
operator|->
name|location
argument_list|()
operator|.
name|lineNo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</s3a>
if|if
condition|(
name|s3b
operator|!=
name|DT_NONE
condition|)
block|{
name|writeStartTag
argument_list|(
name|s3b
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"lineNumber"
argument_list|)
expr_stmt|;
name|QString
name|lineNr
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|lineNr
operator|.
name|setNum
argument_list|(
name|n
operator|->
name|location
argument_list|()
operator|.
name|lineNo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</s3b>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxx<s1>ApiItemLocation>
block|}
end_function
begin_comment
comment|/*!   Write the<cxxFunction> elements.  */
end_comment
begin_function
DECL|function|writeFunctions
name|void
name|DitaXmlGenerator
operator|::
name|writeFunctions
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxFunction
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|fn
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Signal
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Slot
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included:<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxFunctionDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxFunctionDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxFunctionAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|fn
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionAccessSpecifier>
comment|// not included:<cxxFunctionStorageClassSpecifierExtern>
if|if
condition|(
name|fn
operator|->
name|isStatic
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionStorageClassSpecifierStatic
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionStorageClassSpecifierStatic>
block|}
comment|// not included:<cxxFunctionStorageClassSpecifierMutable>,
if|if
condition|(
name|fn
operator|->
name|isConst
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionConst
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionConst>
block|}
comment|// not included:<cxxFunctionExplicit>
comment|//<cxxFunctionInline
if|if
condition|(
name|fn
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionVirtual
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"virtual"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"virtual"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionVirtual>
if|if
condition|(
name|fn
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|PureVirtual
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionPureVirtual
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"pure virtual"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"pure virtual"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionPureVirtual>
block|}
block|}
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
operator|==
name|parent
operator|->
name|name
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionConstructor
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionConstructor>
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
index|[
literal|0
index|]
operator|==
name|QChar
argument_list|(
literal|'~'
argument_list|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionDestructor
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"destructor"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"destructor"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionDestructor>
block|}
else|else
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionDeclaredType
argument_list|)
expr_stmt|;
name|QString
name|src
init|=
name|marker
operator|->
name|typified
argument_list|(
name|fn
operator|->
name|returnType
argument_list|()
argument_list|)
decl_stmt|;
name|replaceTypesWithLinks
argument_list|(
name|fn
argument_list|,
name|parent
argument_list|,
name|marker
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionDeclaredType>
block|}
comment|// not included:<cxxFunctionReturnType>
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionScopedName>
block|}
name|writeStartTag
argument_list|(
name|DT_cxxFunctionPrototype
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fn
operator|->
name|signature
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionPrototype>
name|QString
name|fnl
init|=
name|fn
operator|->
name|signature
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|fnl
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
else|else
operator|++
name|idx
expr_stmt|;
name|fnl
operator|=
name|fn
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|fnl
operator|.
name|mid
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxFunctionNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fnl
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionNameLookup>
if|if
condition|(
operator|!
name|fn
operator|->
name|isInternal
argument_list|()
operator|&&
name|fn
operator|->
name|isReimp
argument_list|()
operator|&&
name|fn
operator|->
name|reimplementedFrom
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|FunctionNode
modifier|*
name|rfn
init|=
operator|(
name|FunctionNode
operator|*
operator|)
name|fn
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|rfn
operator|&&
operator|!
name|rfn
operator|->
name|isInternal
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionReimplemented
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|rfn
operator|->
name|ditaXmlHref
argument_list|()
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
name|rfn
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxFunctionReimplemented>
block|}
block|}
name|writeParameters
argument_list|(
name|fn
argument_list|,
name|parent
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeLocation
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionDefinition>
name|writeApiDesc
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// generateAlsoList(inner, marker);
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxFunctionDetail>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxFunction>
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Ctor
operator|||
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
operator|||
name|fn
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
block|{             }
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
specifier|static
specifier|const
name|QString
name|typeTag
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|charLangle
specifier|static
specifier|const
name|QChar
name|charLangle
init|=
literal|'<'
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|charAt
specifier|static
specifier|const
name|QChar
name|charAt
init|=
literal|'@'
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   This function replaces class and enum names with<apiRelation>   elements, i.e. links.  */
end_comment
begin_function
DECL|function|replaceTypesWithLinks
name|void
name|DitaXmlGenerator
operator|::
name|replaceTypesWithLinks
parameter_list|(
specifier|const
name|Node
modifier|*
name|n
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|QString
modifier|&
name|src
parameter_list|)
block|{
name|QStringRef
name|arg
decl_stmt|;
name|QStringRef
name|par1
decl_stmt|;
name|int
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
decl_stmt|;
name|QString
name|text
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|typeTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
specifier|const
name|Node
modifier|*
name|tn
init|=
name|marker
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|tree_
argument_list|,
name|parent
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|tn
condition|)
block|{
comment|//Do not generate a link from a C++ function to a QML Basic Type (such as int)
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
operator|&&
name|tn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
name|writeCharacters
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|tn
argument_list|,
name|parent
argument_list|)
argument_list|,
name|arg
argument_list|,
name|DT_apiRelation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|text
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes the<cxxFunctionParameters> element.  */
end_comment
begin_function
DECL|function|writeParameters
name|void
name|DitaXmlGenerator
operator|::
name|writeParameters
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|fn
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|Parameter
argument_list|>
modifier|&
name|parameters
init|=
name|fn
operator|->
name|parameters
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parameters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionParameters
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|parameters
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|parameters
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionParameter
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxFunctionParameterDeclaredType
argument_list|)
expr_stmt|;
name|QString
name|src
init|=
name|marker
operator|->
name|typified
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|leftType
argument_list|()
argument_list|)
decl_stmt|;
name|replaceTypesWithLinks
argument_list|(
name|fn
argument_list|,
name|parent
argument_list|,
name|marker
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|//writeCharacters((*p).leftType());
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
operator|.
name|rightType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeCharacters
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionParameterDeclaredType>
name|writeStartTag
argument_list|(
name|DT_cxxFunctionParameterDeclarationName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionParameterDeclarationName>
comment|// not included:<cxxFunctionParameterDefinitionName>
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
operator|.
name|defaultValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxFunctionParameterDefaultValue
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|defaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionParameterDefaultValue>
block|}
comment|// not included:<apiDefNote>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionParameter>
operator|++
name|p
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxFunctionParameters>
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes the enum types.  */
end_comment
begin_function
DECL|function|writeEnumerations
name|void
name|DitaXmlGenerator
operator|::
name|writeEnumerations
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|en
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxEnumeration
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|en
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|en
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|en
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|en
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerationAccessSpecifier>
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|en
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerationScopedName>
block|}
specifier|const
name|QList
argument_list|<
name|EnumItem
argument_list|>
modifier|&
name|items
init|=
name|en
operator|->
name|items
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|items
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationPrototype
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|en
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" = { "
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|EnumItem
argument_list|>
operator|::
name|ConstIterator
name|i
init|=
name|items
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|items
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeCharacters
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|i
operator|)
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|items
operator|.
name|end
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerationPrototype>
block|}
name|writeStartTag
argument_list|(
name|DT_cxxEnumerationNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|en
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|en
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerationNameLookup>
comment|// not included:<cxxEnumerationReimplemented>
if|if
condition|(
operator|!
name|items
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumerators
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|EnumItem
argument_list|>
operator|::
name|ConstIterator
name|i
init|=
name|items
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|items
operator|.
name|end
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumerator
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|en
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumeratorScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
operator|+
literal|"::"
operator|+
operator|(
operator|*
name|i
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumeratorScopedName>
block|}
name|writeStartTag
argument_list|(
name|DT_cxxEnumeratorPrototype
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumeratorPrototype>
name|writeStartTag
argument_list|(
name|DT_cxxEnumeratorNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|en
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
operator|(
operator|*
name|i
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumeratorNameLookup>
if|if
condition|(
operator|!
operator|(
operator|*
name|i
operator|)
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxEnumeratorInitialiser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|.
name|value
argument_list|()
operator|.
name|toInt
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
operator|(
operator|*
name|i
operator|)
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumeratorInitialiser>
block|}
comment|// not included:<cxxEnumeratorAPIItemLocation>
if|if
condition|(
operator|!
operator|(
operator|*
name|i
operator|)
operator|.
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_apiDesc
argument_list|)
expr_stmt|;
name|generateText
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|.
name|text
argument_list|()
argument_list|,
name|en
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiDesc>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerator>
operator|++
name|i
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerators>
block|}
name|writeLocation
argument_list|(
name|en
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxEnumerationDefinition>
name|writeApiDesc
argument_list|(
name|en
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxEnumerationDetail>
comment|// not included:<related-links>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxEnumeration>
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes the output for the \typedef commands.  */
end_comment
begin_function
DECL|function|writeTypedefs
name|void
name|DitaXmlGenerator
operator|::
name|writeTypedefs
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|tn
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxTypedef
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|tn
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|tn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|tn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included:<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxTypedefDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxTypedefDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxTypedefAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|tn
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxTypedefAccessSpecifier>
comment|// not included:<cxxTypedefDeclaredType>
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|tn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxTypedefScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxTypedefScopedName>
block|}
comment|// not included:<cxxTypedefPrototype>
name|writeStartTag
argument_list|(
name|DT_cxxTypedefNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|tn
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|tn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxTypedefNameLookup>
comment|// not included:<cxxTypedefReimplemented>
name|writeLocation
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxTypedefDefinition>
name|writeApiDesc
argument_list|(
name|tn
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxTypedefDetail>
comment|// not included:<related-links>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxTypedef>
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes the output for the \property commands.   This is the Q_PROPERTYs.  */
end_comment
begin_function
DECL|function|writeProperties
name|void
name|DitaXmlGenerator
operator|::
name|writeProperties
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
specifier|const
name|PropertyNode
modifier|*
name|pn
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariable
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|pn
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|pn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|pn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included:<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxVariableDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariableDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariableAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|pn
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableAccessSpecifier>
comment|// not included:<cxxVariableStorageClassSpecifierExtern>,
comment|//<cxxVariableStorageClassSpecifierStatic>,
comment|//<cxxVariableStorageClassSpecifierMutable>,
comment|//<cxxVariableConst>,<cxxVariableVolatile>
if|if
condition|(
operator|!
name|pn
operator|->
name|qualifiedDataType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxVariableDeclaredType
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|pn
operator|->
name|qualifiedDataType
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableDeclaredType>
block|}
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|pn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxVariableScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableScopedName>
block|}
name|writeStartTag
argument_list|(
name|DT_cxxVariablePrototype
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"Q_PROPERTY("
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|pn
operator|->
name|qualifiedDataType
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|pn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writePropertyParameter
argument_list|(
literal|"READ"
argument_list|,
name|pn
operator|->
name|getters
argument_list|()
argument_list|)
expr_stmt|;
name|writePropertyParameter
argument_list|(
literal|"WRITE"
argument_list|,
name|pn
operator|->
name|setters
argument_list|()
argument_list|)
expr_stmt|;
name|writePropertyParameter
argument_list|(
literal|"RESET"
argument_list|,
name|pn
operator|->
name|resetters
argument_list|()
argument_list|)
expr_stmt|;
name|writePropertyParameter
argument_list|(
literal|"NOTIFY"
argument_list|,
name|pn
operator|->
name|notifiers
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|isDesignable
argument_list|()
operator|!=
name|pn
operator|->
name|designableDefault
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" DESIGNABLE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|runtimeDesignabilityFunction
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeCharacters
argument_list|(
name|pn
operator|->
name|runtimeDesignabilityFunction
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|pn
operator|->
name|isDesignable
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|isScriptable
argument_list|()
operator|!=
name|pn
operator|->
name|scriptableDefault
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" SCRIPTABLE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|runtimeScriptabilityFunction
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeCharacters
argument_list|(
name|pn
operator|->
name|runtimeScriptabilityFunction
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|pn
operator|->
name|isScriptable
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|isWritable
argument_list|()
operator|!=
name|pn
operator|->
name|writableDefault
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" STORED "
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|pn
operator|->
name|isStored
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|isUser
argument_list|()
operator|!=
name|pn
operator|->
name|userDefault
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" USER "
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|pn
operator|->
name|isUser
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|isConstant
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" CONSTANT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|isFinal
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" FINAL"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariablePrototype>
name|writeStartTag
argument_list|(
name|DT_cxxVariableNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|pn
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|pn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableNameLookup>
if|if
condition|(
name|pn
operator|->
name|overriddenFrom
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|PropertyNode
modifier|*
name|opn
init|=
operator|(
name|PropertyNode
operator|*
operator|)
name|pn
operator|->
name|overriddenFrom
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariableReimplemented
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|opn
operator|->
name|ditaXmlHref
argument_list|()
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
name|opn
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxVariableReimplemented>
block|}
name|writeLocation
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableDefinition>
name|writeApiDesc
argument_list|(
name|pn
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxVariableDetail>
comment|// not included:<related-links>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxVariable>
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function outputs the nodes resulting from \variable commands.  */
end_comment
begin_function
DECL|function|writeDataMembers
name|void
name|DitaXmlGenerator
operator|::
name|writeDataMembers
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
specifier|const
name|VariableNode
modifier|*
name|vn
init|=
cast|static_cast
argument_list|<
specifier|const
name|VariableNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariable
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|vn
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|vn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|vn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included:<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxVariableDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariableDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxVariableAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|vn
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableAccessSpecifier>
comment|// not included:<cxxVAriableStorageClassSpecifierExtern>
if|if
condition|(
name|vn
operator|->
name|isStatic
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxVariableStorageClassSpecifierStatic
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableStorageClassSpecifierStatic>
block|}
comment|// not included:<cxxVAriableStorageClassSpecifierMutable>,
comment|//<cxxVariableConst>,<cxxVariableVolatile>
name|writeStartTag
argument_list|(
name|DT_cxxVariableDeclaredType
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|vn
operator|->
name|leftType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vn
operator|->
name|rightType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeCharacters
argument_list|(
name|vn
operator|->
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableDeclaredType>
name|QString
name|fq
init|=
name|fullQualification
argument_list|(
name|vn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxVariableScopedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fq
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableScopedName>
block|}
name|writeStartTag
argument_list|(
name|DT_cxxVariablePrototype
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|vn
operator|->
name|leftType
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
comment|//writeCharacters(vn->parent()->name() + "::" + vn->name());
name|writeCharacters
argument_list|(
name|vn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vn
operator|->
name|rightType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeCharacters
argument_list|(
name|vn
operator|->
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariablePrototype>
name|writeStartTag
argument_list|(
name|DT_cxxVariableNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|vn
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|vn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableNameLookup>
comment|// not included:<cxxVariableReimplemented>
name|writeLocation
argument_list|(
name|vn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxVariableDefinition>
name|writeApiDesc
argument_list|(
name|vn
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxVariableDetail>
comment|// not included:<related-links>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxVariable>
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes a \macro as a<cxxDefine>.  */
end_comment
begin_function
DECL|function|writeMacros
name|void
name|DitaXmlGenerator
operator|::
name|writeMacros
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|attribute
parameter_list|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxDefine
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"id"
argument_list|,
name|fn
operator|->
name|guid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"outputclass"
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_apiName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</apiName>
name|generateBrief
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|// not included:<prolog>
name|writeStartTag
argument_list|(
name|DT_cxxDefineDetail
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxDefineDefinition
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxDefineAccessSpecifier
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|fn
operator|->
name|accessString
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineAccessSpecifier>
name|writeStartTag
argument_list|(
name|DT_cxxDefinePrototype
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"#define "
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithParams
condition|)
block|{
name|QStringList
name|params
init|=
name|fn
operator|->
name|parameterNames
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|params
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
else|else
name|writeCharacters
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|params
operator|.
name|size
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefinePrototype>
name|writeStartTag
argument_list|(
name|DT_cxxDefineNameLookup
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineNameLookup>
if|if
condition|(
name|fn
operator|->
name|reimplementedFrom
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|FunctionNode
modifier|*
name|rfn
init|=
operator|(
name|FunctionNode
operator|*
operator|)
name|fn
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxDefineReimplemented
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|rfn
operator|->
name|ditaXmlHref
argument_list|()
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|marker
operator|->
name|plainFullName
argument_list|(
name|rfn
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxDefineReimplemented>
block|}
if|if
condition|(
name|fn
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithParams
condition|)
block|{
name|QStringList
name|params
init|=
name|fn
operator|->
name|parameterNames
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|params
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxDefineParameters
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxDefineParameter
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxDefineParameterDeclarationName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineParameterDeclarationName>
comment|// not included:<apiDefNote>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineParameter>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineParameters>
block|}
block|}
name|writeLocation
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxDefineDefinition>
name|writeApiDesc
argument_list|(
name|fn
argument_list|,
name|marker
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// not included:<example> or<apiImpl>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxDefineDetail>
comment|// not included:<related-links>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</cxxDefine>
block|}
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function writes one parameter of a Q_PROPERTY macro.   The property is identified by \a tag ("READ" "WRIE" etc),   and it is found in the 'a nlist.  */
end_comment
begin_function
DECL|function|writePropertyParameter
name|void
name|DitaXmlGenerator
operator|::
name|writePropertyParameter
parameter_list|(
specifier|const
name|QString
modifier|&
name|tag
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|nlist
parameter_list|)
block|{
name|NodeList
operator|::
name|const_iterator
name|n
init|=
name|nlist
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nlist
operator|.
name|end
argument_list|()
condition|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
operator|(
operator|*
name|n
operator|)
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Calls beginSubPage() in the base class to open the file.   Then creates a new XML stream writer using the IO device   from opened file and pushes the XML writer onto a stackj.   Creates the file named \a fileName in the output directory.   Attaches a QTextStream to the created file, which is written   to all over the place using out(). Finally, it sets some   parameters in the XML writer and calls writeStartDocument().    It also ensures that a GUID map is created for the output file.  */
end_comment
begin_function
DECL|function|beginSubPage
name|void
name|DitaXmlGenerator
operator|::
name|beginSubPage
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Generator
operator|::
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lookupGuidMap
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|QXmlStreamWriter
modifier|*
name|writer
init|=
operator|new
name|QXmlStreamWriter
argument_list|(
name|out
argument_list|()
operator|.
name|device
argument_list|()
argument_list|)
decl_stmt|;
name|xmlWriterStack
operator|.
name|push
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormattingIndent
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|writer
operator|->
name|writeStartDocument
argument_list|()
expr_stmt|;
name|clearSectionNesting
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Calls writeEndDocument() and then pops the XML stream writer   off the stack and deletes it. Then it calls endSubPage() in   the base class to close the device.  */
end_comment
begin_function
DECL|function|endSubPage
name|void
name|DitaXmlGenerator
operator|::
name|endSubPage
parameter_list|()
block|{
if|if
condition|(
name|inSection
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"Missing</section> in"
operator|<<
name|outFileName
argument_list|()
operator|<<
name|sectionNestingLevel
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
operator|delete
name|xmlWriterStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|Generator
operator|::
name|endSubPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns a reference to the XML stream writer currently in use.   There is one XML stream writer open for each XML file being   written, and they are kept on a stack. The one on top of the   stack is the one being written to at the moment.  */
end_comment
begin_function
DECL|function|xmlWriter
name|QXmlStreamWriter
modifier|&
name|DitaXmlGenerator
operator|::
name|xmlWriter
parameter_list|()
block|{
return|return
operator|*
name|xmlWriterStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Writes the \e {<apiDesc>} element for \a node to the current XML   stream using the code \a marker and the \a title.  */
end_comment
begin_function
DECL|function|writeApiDesc
name|void
name|DitaXmlGenerator
operator|::
name|writeApiDesc
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|inDetailedDescription
operator|=
literal|true
expr_stmt|;
name|enterApiDesc
argument_list|(
name|QString
argument_list|()
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|leaveSection
argument_list|()
expr_stmt|;
block|}
name|inDetailedDescription
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Write the nested class elements.  */
end_comment
begin_function
DECL|function|writeNestedClasses
name|void
name|DitaXmlGenerator
operator|::
name|writeNestedClasses
parameter_list|(
specifier|const
name|Section
modifier|&
name|s
parameter_list|,
specifier|const
name|Node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_cxxClassNested
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_cxxClassNestedDetail
argument_list|)
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|s
operator|.
name|members
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|s
operator|.
name|members
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_cxxClassNestedClass
argument_list|)
expr_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
operator|(
operator|*
name|m
operator|)
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|n
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
operator|(
operator|*
name|m
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|writeCharacters
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassNestedClass>
block|}
operator|++
name|m
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassNestedDetail>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<cxxClassNested>
block|}
end_function
begin_comment
comment|/*!   Recursive writing of DITA XML files from the root \a node.  */
end_comment
begin_function
name|void
DECL|function|generateInnerNode
name|DitaXmlGenerator
operator|::
name|generateInnerNode
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|count
argument_list|()
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"PAGE %s HAS CHILDREN"
argument_list|,
name|qPrintable
argument_list|(
name|fakeNode
operator|->
name|title
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*       Obtain a code marker for the source file.      */
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|node
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|name
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".ditamap"
argument_list|)
condition|)
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|generateClassLikeNode
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
condition|)
name|generateClassLikeNode
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|generateClassLikeNode
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
else|else
name|generateFakeNode
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
operator|->
name|name
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".ditamap"
argument_list|)
condition|)
name|endSubPage
argument_list|()
expr_stmt|;
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
name|generateInnerNode
argument_list|(
operator|(
specifier|const
name|InnerNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns true if \a format is "XML" or "HTML" .  */
end_comment
begin_function
DECL|function|canHandleFormat
name|bool
name|DitaXmlGenerator
operator|::
name|canHandleFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
return|return
operator|(
name|format
operator|==
literal|"HTML"
operator|)
operator|||
operator|(
name|format
operator|==
name|this
operator|->
name|format
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   If the node multimap \a nmm contains nodes mapped to \a key,   if any of the nodes mapped to \a key has the same href as the   \a node, return true. Otherwise, return false.  */
end_comment
begin_function
DECL|function|isDuplicate
name|bool
name|DitaXmlGenerator
operator|::
name|isDuplicate
parameter_list|(
name|NodeMultiMap
modifier|*
name|nmm
parameter_list|,
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|matches
init|=
name|nmm
operator|->
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|matches
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|==
name|node
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|fileName
argument_list|(
name|node
argument_list|)
operator|==
name|fileName
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Collect all the nodes in the tree according to their type or subtype.    If a node is found that is named index.html, return that node as the   root page node.    type: Class   type: Namespace    subtype: Example   subtype: External page   subtype: Group   subtype: Header file   subtype: Module   subtype: Page   subtype: QML basic type   subtype: QML class   subtype: QML module  */
end_comment
begin_function
DECL|function|collectNodesByTypeAndSubtype
name|Node
modifier|*
name|DitaXmlGenerator
operator|::
name|collectNodesByTypeAndSubtype
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|Node
modifier|*
name|rootPageNode
init|=
literal|0
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|rootPageNode
return|;
name|QString
name|message
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|)
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fake
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|collectNodesByTypeAndSubtype
argument_list|(
name|fake
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|rootPageNode
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|isInternal
argument_list|()
operator|||
name|child
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|name
argument_list|()
operator|==
literal|"index.html"
condition|)
block|{
name|rootPageNode
operator|=
name|child
expr_stmt|;
block|}
switch|switch
condition|(
name|child
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Namespace
index|]
argument_list|,
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Namespace
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Class
index|]
argument_list|,
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Class
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Fake
case|:
switch|switch
condition|(
name|child
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Example
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Example
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Example
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|HeaderFile
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|HeaderFile
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|HeaderFile
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|File
case|:
break|break;
case|case
name|Node
operator|::
name|Image
case|:
break|break;
case|case
name|Node
operator|::
name|Group
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Group
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Group
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Module
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Module
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Module
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Page
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|pageTypeMaps
index|[
name|child
operator|->
name|pageType
argument_list|()
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|pageTypeMaps
index|[
name|child
operator|->
name|pageType
argument_list|()
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|ExternalPage
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|ExternalPage
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlClass
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlClass
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlClass
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlBasicType
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlBasicType
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlModule
case|:
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlModule
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlModule
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Collision
case|:
name|qDebug
argument_list|()
operator|<<
literal|"FAKE NODE: Collision"
expr_stmt|;
if|if
condition|(
operator|!
name|isDuplicate
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Collision
index|]
argument_list|,
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
condition|)
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Collision
index|]
operator|->
name|insert
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
break|break;
case|case
name|Node
operator|::
name|Function
case|:
break|break;
case|case
name|Node
operator|::
name|Property
case|:
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
break|break;
case|case
name|Node
operator|::
name|Target
case|:
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|rootPageNode
return|;
block|}
end_function
begin_comment
comment|/*!   Creates the DITA map for the qdoc run. The map is written   to the file \e{qt.ditamap" in the DITA XML output directory.  */
end_comment
begin_function
DECL|function|writeDitaMap
name|void
name|DitaXmlGenerator
operator|::
name|writeDitaMap
parameter_list|(
specifier|const
name|Tree
modifier|*
name|tree
parameter_list|)
block|{
name|QString
name|doctype
decl_stmt|;
comment|/*     Remove #if 0 to get a flat ditamap. */
if|#
directive|if
literal|0
block|beginSubPage(tree->root(),"qt.ditamap");     doctype = "<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">";     xmlWriter().writeDTD(doctype);     writeStartTag(DT_map);     writeStartTag(DT_topicmeta);     writeStartTag(DT_shortdesc);     xmlWriter().writeCharacters("The top level map for the Qt documentation");     writeEndTag();
comment|//</shortdesc>
block|writeEndTag();
comment|//</topicmeta>
block|GuidMaps::iterator i = guidMaps.begin();     while (i != guidMaps.end()) {         writeStartTag(DT_topicref);         if (i.key() != "qt.ditamap")             xmlWriter().writeAttribute("href",i.key());         writeEndTag();
comment|//</topicref>
block|++i;     }     endSubPage();
endif|#
directive|endif
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|LastType
condition|;
operator|++
name|i
control|)
name|nodeTypeMaps
index|[
name|i
index|]
operator|=
operator|new
name|NodeMultiMap
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|LastSubtype
condition|;
operator|++
name|i
control|)
name|nodeSubtypeMaps
index|[
name|i
index|]
operator|=
operator|new
name|NodeMultiMap
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|OnBeyondZebra
condition|;
operator|++
name|i
control|)
name|pageTypeMaps
index|[
name|i
index|]
operator|=
operator|new
name|NodeMultiMap
expr_stmt|;
name|Node
modifier|*
name|rootPageNode
init|=
name|collectNodesByTypeAndSubtype
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
decl_stmt|;
name|beginSubPage
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|,
literal|"qt.ditamap"
argument_list|)
expr_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeDTD
argument_list|(
name|doctype
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_map
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_topicmeta
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_shortdesc
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
literal|"The top level map for the Qt documentation"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</shortdesc>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicmeta>
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootPageNode
condition|)
block|{
if|if
condition|(
operator|!
name|rootPageNode
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|rootPageNode
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|project
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|rootPageNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|project
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|pageTypeMaps
index|[
name|Node
operator|::
name|OverviewPage
index|]
argument_list|,
literal|"overviews"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|pageTypeMaps
index|[
name|Node
operator|::
name|HowToPage
index|]
argument_list|,
literal|"howtos"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|pageTypeMaps
index|[
name|Node
operator|::
name|TutorialPage
index|]
argument_list|,
literal|"tutorials"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|pageTypeMaps
index|[
name|Node
operator|::
name|FAQPage
index|]
argument_list|,
literal|"faqs"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|pageTypeMaps
index|[
name|Node
operator|::
name|ArticlePage
index|]
argument_list|,
literal|"articles"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Example
index|]
argument_list|,
literal|"examples"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlClass
index|]
argument_list|,
literal|"QML classes"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Class
index|]
argument_list|,
literal|"C++ classes"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeTypeMaps
index|[
name|Node
operator|::
name|Namespace
index|]
argument_list|,
literal|"C++ namespaces"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|HeaderFile
index|]
argument_list|,
literal|"header files"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Module
index|]
argument_list|,
literal|"modules"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|Group
index|]
argument_list|,
literal|"groups"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlModule
index|]
argument_list|,
literal|"QML modules"
argument_list|)
expr_stmt|;
name|writeTopicrefs
argument_list|(
name|nodeSubtypeMaps
index|[
name|Node
operator|::
name|QmlBasicType
index|]
argument_list|,
literal|"QML basic types"
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
name|endSubPage
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|LastType
condition|;
operator|++
name|i
control|)
operator|delete
name|nodeTypeMaps
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|LastSubtype
condition|;
operator|++
name|i
control|)
operator|delete
name|nodeSubtypeMaps
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Node
operator|::
name|OnBeyondZebra
condition|;
operator|++
name|i
control|)
operator|delete
name|pageTypeMaps
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Creates the DITA map from the topicrefs in \a node,   which is a DitaMapNode.  */
end_comment
begin_function
DECL|function|writeDitaMap
name|void
name|DitaXmlGenerator
operator|::
name|writeDitaMap
parameter_list|(
specifier|const
name|DitaMapNode
modifier|*
name|node
parameter_list|)
block|{
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|doctype
decl_stmt|;
name|doctype
operator|=
literal|"<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">"
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeDTD
argument_list|(
name|doctype
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_map
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_topicmeta
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_shortdesc
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</shortdesc>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicmeta>
specifier|const
name|DitaRefList
name|map
init|=
name|node
operator|->
name|map
argument_list|()
decl_stmt|;
name|writeDitaRefs
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Write the \a ditarefs to the current output file.  */
end_comment
begin_function
DECL|function|writeDitaRefs
name|void
name|DitaXmlGenerator
operator|::
name|writeDitaRefs
parameter_list|(
specifier|const
name|DitaRefList
modifier|&
name|ditarefs
parameter_list|)
block|{
foreach|foreach
control|(
name|DitaRef
modifier|*
name|t
decl|,
name|ditarefs
control|)
block|{
if|if
condition|(
name|t
operator|->
name|isMapRef
argument_list|()
condition|)
name|writeStartTag
argument_list|(
name|DT_mapref
argument_list|)
expr_stmt|;
else|else
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|href
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fn
init|=
name|tree_
operator|->
name|findFakeNodeByTitle
argument_list|(
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|t
operator|->
name|href
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|subrefs
argument_list|()
operator|&&
operator|!
name|t
operator|->
name|subrefs
argument_list|()
operator|->
name|isEmpty
argument_list|()
condition|)
name|writeDitaRefs
argument_list|(
operator|*
operator|(
name|t
operator|->
name|subrefs
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref> or</mapref>
block|}
block|}
end_function
begin_function
DECL|function|writeTopicrefs
name|void
name|DitaXmlGenerator
operator|::
name|writeTopicrefs
parameter_list|(
name|NodeMultiMap
modifier|*
name|nmm
parameter_list|,
specifier|const
name|QString
modifier|&
name|navtitle
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nmm
operator|||
name|nmm
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|navtitle
argument_list|)
expr_stmt|;
name|NodeMultiMap
operator|::
name|iterator
name|i
init|=
name|nmm
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|nmm
operator|->
name|end
argument_list|()
condition|)
block|{
comment|// Hardcode not writing index.dita multiple times in the tree.
comment|// index.dita should only appear at the top of the ditamap.
if|if
condition|(
name|fileName
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
operator|==
literal|"index.dita"
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|value
argument_list|()
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Fake
case|:
block|{
specifier|const
name|FakeNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fn
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Group
case|:
block|{
specifier|const
name|NodeList
modifier|&
name|members
init|=
name|fn
operator|->
name|groupMembers
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|members
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|members
index|[
name|j
index|]
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|members
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|QmlModule
case|:
block|{
specifier|const
name|NodeList
modifier|&
name|members
init|=
name|fn
operator|->
name|qmlModuleMembers
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|members
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|members
index|[
name|j
index|]
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|members
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Example
case|:
block|{
specifier|const
name|ExampleNode
modifier|*
name|en
init|=
cast|static_cast
argument_list|<
specifier|const
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|en
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
literal|"image"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|en
operator|->
name|imageFileName
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
specifier|const
name|NodeList
modifier|&
name|files
init|=
name|en
operator|->
name|childNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|files
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|files
index|[
name|j
index|]
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Module
case|:
block|{
if|if
condition|(
name|moduleNamespaceMap
operator|.
name|contains
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|NodeMap
modifier|&
name|nodeMap
init|=
name|moduleNamespaceMap
index|[
name|fn
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|nodeMap
operator|.
name|keys
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|nodeMap
index|[
name|name
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
operator|||
name|node
operator|->
name|isInternal
argument_list|()
operator|||
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
block|}
if|if
condition|(
name|moduleClassMap
operator|.
name|contains
argument_list|(
name|fn
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|NodeMap
modifier|&
name|nodeMap
init|=
name|moduleClassMap
index|[
name|fn
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|nodeMap
operator|.
name|keys
argument_list|()
control|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|nodeMap
index|[
name|name
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
operator|||
name|node
operator|->
name|isInternal
argument_list|()
operator|||
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Namespace
case|:
block|{
specifier|const
name|NamespaceNode
modifier|*
name|nn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|c
init|=
name|nn
operator|->
name|childNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|c
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|c
index|[
name|j
index|]
operator|->
name|isInternal
argument_list|()
operator|||
name|c
index|[
name|j
index|]
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|c
index|[
name|j
index|]
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|c
index|[
name|j
index|]
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|c
index|[
name|j
index|]
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|c
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Class
case|:
block|{
specifier|const
name|NamespaceNode
modifier|*
name|nn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|c
init|=
name|nn
operator|->
name|childNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|c
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|c
index|[
name|j
index|]
operator|->
name|isInternal
argument_list|()
operator|||
name|c
index|[
name|j
index|]
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|c
index|[
name|j
index|]
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|c
index|[
name|j
index|]
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_topicref
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|c
index|[
name|j
index|]
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|c
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
operator|++
name|i
expr_stmt|;
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</topicref>
block|}
end_function
begin_comment
comment|/*!   Looks up the tag name for \a t in the map of metadata   values for the current topic in \a inner. If a value   for the tag is found, the element is written with the   found value. Otherwise if \a force is set, an empty   element is written using the tag.    Returns true or false depending on whether it writes   an element using the tag \a t.    \note If \a t is found in the metadata map, it is erased.   i.e. Once you call this function for a particular \a t,   you consume \a t.  */
end_comment
begin_function
DECL|function|writeMetadataElement
name|bool
name|DitaXmlGenerator
operator|::
name|writeMetadataElement
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|DitaXmlGenerator
operator|::
name|DitaTag
name|t
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|QString
name|s
init|=
name|getMetadataElement
argument_list|(
name|inner
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|force
condition|)
return|return
literal|false
return|;
name|writeStartTag
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the tag name for \a t in the map of metadata   values for the current topic in \a inner. If one or more   value sfor the tag are found, the elements are written.   Otherwise nothing is written.    Returns true or false depending on whether it writes   at least one element using the tag \a t.    \note If \a t is found in the metadata map, it is erased.   i.e. Once you call this function for a particular \a t,   you consume \a t.  */
end_comment
begin_function
DECL|function|writeMetadataElements
name|bool
name|DitaXmlGenerator
operator|::
name|writeMetadataElements
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|DitaXmlGenerator
operator|::
name|DitaTag
name|t
parameter_list|)
block|{
name|QStringList
name|s
init|=
name|getMetadataElements
argument_list|(
name|inner
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|writeStartTag
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the tag name for \a t in the map of metadata   values for the current topic in \a inner. If a value   for the tag is found, the value is returned.    \note If \a t is found in the metadata map, it is erased.   i.e. Once you call this function for a particular \a t,   you consume \a t.  */
end_comment
begin_function
DECL|function|getMetadataElement
name|QString
name|DitaXmlGenerator
operator|::
name|getMetadataElement
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|DitaXmlGenerator
operator|::
name|DitaTag
name|t
parameter_list|)
block|{
name|QString
name|s
init|=
name|Generator
operator|::
name|getMetadataElement
argument_list|(
name|inner
argument_list|,
name|ditaTags
index|[
name|t
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|=
name|metadataDefault
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the tag name for \a t in the map of metadata   values for the current topic in \a inner. If values   for the tag are found, they are returned in a string   list.    \note If \a t is found in the metadata map, all the   pairs having the key \a t are erased. i.e. Once you   all this function for a particular \a t, you consume   \a t.  */
end_comment
begin_function
DECL|function|getMetadataElements
name|QStringList
name|DitaXmlGenerator
operator|::
name|getMetadataElements
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|DitaXmlGenerator
operator|::
name|DitaTag
name|t
parameter_list|)
block|{
name|QStringList
name|s
init|=
name|Generator
operator|::
name|getMetadataElements
argument_list|(
name|inner
argument_list|,
name|ditaTags
index|[
name|t
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|.
name|append
argument_list|(
name|metadataDefault
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the value of key \a t or an empty string   if \a t is not found in the map.  */
end_comment
begin_function
DECL|function|metadataDefault
name|QString
name|DitaXmlGenerator
operator|::
name|metadataDefault
parameter_list|(
name|DitaTag
name|t
parameter_list|)
specifier|const
block|{
return|return
name|metadataDefaults
operator|.
name|value
argument_list|(
name|ditaTags
index|[
name|t
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Writes the<prolog> element for the \a inner node   using the \a marker. The<prolog> element contains   the<metadata> element, plus some others. This   function writes one or more of these elements:    \list     \o<audience> *     \o<author> *     \o<brand> not used     \o<category> *     \o<compomnent> *     \o<copyrholder> *     \o<copyright> *     \o<created> not used     \o<copyryear> *     \o<critdates> not used     \o<keyword> not used     \o<keywords> not used     \o<metadata> *     \o<othermeta> *     \o<permissions> *     \o<platform> not used     \o<prodinfo> *     \o<prodname> *     \o<prolog> *     \o<publisher> *     \o<resourceid> not used     \o<revised> not used     \o<source> not used     \o<tm> not used     \o<unknown> not used     \o<vrm> *     \o<vrmlist> *   \endlist    \node * means the tag has been used.   */
end_comment
begin_function
name|void
DECL|function|writeProlog
name|DitaXmlGenerator
operator|::
name|writeProlog
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inner
condition|)
return|return;
name|writeStartTag
argument_list|(
name|DT_prolog
argument_list|)
expr_stmt|;
name|writeMetadataElements
argument_list|(
name|inner
argument_list|,
name|DT_author
argument_list|)
expr_stmt|;
name|writeMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_publisher
argument_list|)
expr_stmt|;
name|QString
name|s
init|=
name|getMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_copyryear
argument_list|)
decl_stmt|;
name|QString
name|t
init|=
name|getMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_copyrholder
argument_list|)
decl_stmt|;
name|writeStartTag
argument_list|(
name|DT_copyright
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_copyryear
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"year"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</copyryear>
name|writeStartTag
argument_list|(
name|DT_copyrholder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</copyrholder>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</copyright>
name|s
operator|=
name|getMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_permissions
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_permissions
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"view"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</permissions>
name|writeStartTag
argument_list|(
name|DT_metadata
argument_list|)
expr_stmt|;
name|QStringList
name|sl
init|=
name|getMetadataElements
argument_list|(
name|inner
argument_list|,
name|DT_audience
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|writeStartTag
argument_list|(
name|DT_audience
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|sl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</audience>
block|}
block|}
if|if
condition|(
operator|!
name|writeMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_category
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_category
argument_list|)
expr_stmt|;
name|QString
name|category
init|=
literal|"Page"
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
name|category
operator|=
literal|"Class reference"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
name|category
operator|=
literal|"Namespace"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|category
operator|=
literal|"QML Reference"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
name|category
operator|=
literal|"QML Basic Type"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
condition|)
name|category
operator|=
literal|"Header File"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
name|category
operator|=
literal|"Module"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
name|category
operator|=
literal|"Example Source File"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
condition|)
name|category
operator|=
literal|"Example"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
name|category
operator|=
literal|"Image"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Group
condition|)
name|category
operator|=
literal|"Group"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
condition|)
name|category
operator|=
literal|"Page"
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
name|category
operator|=
literal|"External Page"
expr_stmt|;
comment|// Is this necessary?
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|category
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</category>
block|}
if|if
condition|(
name|vrm
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_prodinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_prodname
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_prodname
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|projectDescription
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</prodname>
block|}
name|writeStartTag
argument_list|(
name|DT_vrmlist
argument_list|)
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_vrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrm
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"version"
argument_list|,
name|vrm
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrm
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"release"
argument_list|,
name|vrm
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrm
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"modification"
argument_list|,
name|vrm
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<vrm>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//<vrmlist>
if|if
condition|(
operator|!
name|writeMetadataElement
argument_list|(
name|inner
argument_list|,
name|DT_component
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|QString
name|component
init|=
name|inner
operator|->
name|moduleName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|component
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_component
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</component>
block|}
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</prodinfo>
block|}
specifier|const
name|QStringMultiMap
modifier|&
name|metaTagMap
init|=
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|metaTagMap
argument_list|()
decl_stmt|;
name|QMapIterator
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|i
argument_list|(
name|metaTagMap
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|writeStartTag
argument_list|(
name|DT_othermeta
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"content"
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</othermeta>
block|}
if|if
condition|(
operator|(
name|tagStack
operator|.
name|first
argument_list|()
operator|==
name|DT_cxxClass
operator|&&
operator|!
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|inner
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
operator|)
condition|)
block|{
name|writeStartTag
argument_list|(
name|DT_othermeta
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
literal|"includeFile"
argument_list|)
expr_stmt|;
name|QString
name|text
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|i
init|=
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
operator|&&
operator|(
operator|*
name|i
operator|)
operator|.
name|endsWith
argument_list|(
literal|">"
argument_list|)
condition|)
name|text
operator|+=
operator|*
name|i
expr_stmt|;
else|else
name|text
operator|+=
literal|"<"
operator|+
operator|*
name|i
operator|+
literal|">"
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
name|text
operator|+=
literal|"\n"
expr_stmt|;
block|}
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"content"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</othermeta>
block|}
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</metadata>
name|writeEndTag
argument_list|()
expr_stmt|;
comment|//</prolog>
block|}
end_function
begin_comment
comment|/*!   This function should be called to write the \a href attribute   if the href could be an \e http or \e ftp link. If \a href is   one or the other, a \e scope attribute is also writen, with   value \e external.  */
end_comment
begin_function
DECL|function|writeHrefAttribute
name|void
name|DitaXmlGenerator
operator|::
name|writeHrefAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|href
parameter_list|)
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|href
argument_list|)
expr_stmt|;
if|if
condition|(
name|href
operator|.
name|startsWith
argument_list|(
literal|"http:"
argument_list|)
operator|||
name|href
operator|.
name|startsWith
argument_list|(
literal|"ftp:"
argument_list|)
operator|||
name|href
operator|.
name|startsWith
argument_list|(
literal|"https:"
argument_list|)
operator|||
name|href
operator|.
name|startsWith
argument_list|(
literal|"mailto:"
argument_list|)
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"scope"
argument_list|,
literal|"external"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Strips the markup tags from \a src, when we are trying to   create an \e{id} attribute. Returns the stripped text.  */
end_comment
begin_function
DECL|function|stripMarkup
name|QString
name|DitaXmlGenerator
operator|::
name|stripMarkup
parameter_list|(
specifier|const
name|QString
modifier|&
name|src
parameter_list|)
specifier|const
block|{
name|QString
name|text
decl_stmt|;
specifier|const
name|QChar
name|charAt
init|=
literal|'@'
decl_stmt|;
specifier|const
name|QChar
name|charSlash
init|=
literal|'/'
decl_stmt|;
specifier|const
name|QChar
name|charLangle
init|=
literal|'<'
decl_stmt|;
specifier|const
name|QChar
name|charRangle
init|=
literal|'>'
decl_stmt|;
name|int
name|n
init|=
name|src
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charAt
operator|||
operator|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charSlash
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
operator|)
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|charRangle
condition|)
operator|++
name|i
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|text
operator|+=
name|charLangle
expr_stmt|;
block|}
block|}
else|else
name|text
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
