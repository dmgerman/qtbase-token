begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*     This file is a self-contained interactive indenter for C++ and Qt     Script.      The general problem of indenting a C++ program is ill posed. On     the one hand, an indenter has to analyze programs written in a     free-form formal language that is best described in terms of     tokens, not characters, not lines. On the other hand, indentation     applies to lines and white space characters matter, and otherwise     the programs to indent are formally invalid in general, as they     are begin edited.      The approach taken here works line by line. We receive a program     consisting of N lines or more, and we want to compute the     indentation appropriate for the Nth line. Lines beyond the Nth     lines are of no concern to us, so for simplicity we pretend the     program has exactly N lines and we call the Nth line the "bottom     line". Typically, we have to indent the bottom line when it's     still empty, so we concentrate our analysis on the N - 1 lines     that precede.      By inspecting the (N - 1)-th line, the (N - 2)-th line, ...     backwards, we determine the kind of the bottom line and indent it     accordingly.        * The bottom line is a comment line. See         bottomLineStartsInCComment() and         indentWhenBottomLineStartsInCComment().       * The bottom line is a continuation line. See isContinuationLine()         and indentForContinuationLine().       * The bottom line is a standalone line. See         indentForStandaloneLine().      Certain tokens that influence the indentation, notably braces,     are looked for in the lines. This is done by simple string     comparison, without a real tokenizer. Confusing constructs such     as comments and string literals are removed beforehand. */
end_comment
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/* qmake ignore Q_OBJECT */
comment|/*     The indenter avoids getting stuck in almost infinite loops by     imposing arbitrary limits on the number of lines it analyzes when     looking for a construct.      For example, the indenter never considers more than BigRoof lines     backwards when looking for the start of a C-style comment. */
DECL|variable|SmallRoof
specifier|static
specifier|const
name|int
name|SmallRoof
init|=
literal|40
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|BigRoof
specifier|static
specifier|const
name|int
name|BigRoof
init|=
literal|400
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     The indenter supports a few parameters:        * ppHardwareTabSize is the size of a '\t' in your favorite editor.       * ppIndentSize is the size of an indentation, or software tab         size.       * ppContinuationIndentSize is the extra indent for a continuation         line, when there is nothing to align against on the previous         line.       * ppCommentOffset is the indentation within a C-style comment,         when it cannot be picked up. */
end_comment
begin_decl_stmt
DECL|variable|ppHardwareTabSize
specifier|static
name|int
name|ppHardwareTabSize
init|=
literal|8
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ppIndentSize
specifier|static
name|int
name|ppIndentSize
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ppContinuationIndentSize
specifier|static
name|int
name|ppContinuationIndentSize
init|=
literal|8
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ppCommentOffset
specifier|static
specifier|const
name|int
name|ppCommentOffset
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|setTabSize
name|void
name|setTabSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ppHardwareTabSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setIndentSize
name|void
name|setIndentSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|ppIndentSize
operator|=
name|size
expr_stmt|;
name|ppContinuationIndentSize
operator|=
literal|2
operator|*
name|size
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|literal
specifier|static
name|QRegExp
modifier|*
name|literal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|label
specifier|static
name|QRegExp
modifier|*
name|label
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|inlineCComment
specifier|static
name|QRegExp
modifier|*
name|inlineCComment
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|braceX
specifier|static
name|QRegExp
modifier|*
name|braceX
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iflikeKeyword
specifier|static
name|QRegExp
modifier|*
name|iflikeKeyword
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     Returns the first non-space character in the string t, or     QChar::Null if the string is made only of white space. */
end_comment
begin_function
DECL|function|firstNonWhiteSpace
specifier|static
name|QChar
name|firstNonWhiteSpace
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|t
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
condition|)
return|return
name|t
index|[
name|i
index|]
return|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|QChar
operator|::
name|Null
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if string t is made only of white space; otherwise     returns false. */
end_comment
begin_function
DECL|function|isOnlyWhiteSpace
specifier|static
name|bool
name|isOnlyWhiteSpace
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
return|return
name|firstNonWhiteSpace
argument_list|(
name|t
argument_list|)
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     Assuming string t is a line, returns the column number of a given     index. Column numbers and index are identical for strings that don't     contain '\t's. */
end_comment
begin_function
DECL|function|columnForIndex
name|int
name|columnForIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|index
operator|>
operator|(
name|int
operator|)
name|t
operator|.
name|length
argument_list|()
condition|)
name|index
operator|=
name|t
operator|.
name|length
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
index|[
name|i
index|]
operator|==
name|QChar
argument_list|(
literal|'\t'
argument_list|)
condition|)
block|{
name|col
operator|=
operator|(
operator|(
name|col
operator|/
name|ppHardwareTabSize
operator|)
operator|+
literal|1
operator|)
operator|*
name|ppHardwareTabSize
expr_stmt|;
block|}
else|else
block|{
name|col
operator|++
expr_stmt|;
block|}
block|}
return|return
name|col
return|;
block|}
end_function
begin_comment
comment|/*     Returns the indentation size of string t. */
end_comment
begin_function
DECL|function|indentOfLine
name|int
name|indentOfLine
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
return|return
name|columnForIndex
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|indexOf
argument_list|(
name|firstNonWhiteSpace
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     Replaces t[k] by ch, unless t[k] is '\t'. Tab characters are better     left alone since they break the "index equals column" rule. No     provisions are taken against '\n' or '\r', which shouldn't occur in     t anyway. */
end_comment
begin_function
DECL|function|eraseChar
specifier|static
specifier|inline
name|void
name|eraseChar
parameter_list|(
name|QString
modifier|&
name|t
parameter_list|,
name|int
name|k
parameter_list|,
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|t
index|[
name|k
index|]
operator|!=
literal|'\t'
condition|)
name|t
index|[
name|k
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    Removes some nefast constructs from a code line and returns the    resulting line. */
end_comment
begin_function
DECL|function|trimmedCodeLine
specifier|static
name|QString
name|trimmedCodeLine
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|QString
name|trimmed
init|=
name|t
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/*         Replace character and string literals by X's, since they may         contain confusing characters (such as '{' and ';'). "Hello!" is         replaced by XXXXXXXX. The literals are rigourously of the same         length before and after; otherwise, we would break alignment of         continuation lines.     */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|trimmed
operator|.
name|indexOf
argument_list|(
operator|*
name|literal
argument_list|,
name|k
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|literal
operator|->
name|matchedLength
argument_list|()
condition|;
name|i
operator|++
control|)
name|eraseChar
argument_list|(
name|trimmed
argument_list|,
name|k
operator|+
name|i
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
name|k
operator|+=
name|literal
operator|->
name|matchedLength
argument_list|()
expr_stmt|;
block|}
comment|/*         Replace inline C-style comments by spaces. Other comments are         handled elsewhere.     */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|trimmed
operator|.
name|indexOf
argument_list|(
operator|*
name|inlineCComment
argument_list|,
name|k
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inlineCComment
operator|->
name|matchedLength
argument_list|()
condition|;
name|i
operator|++
control|)
name|eraseChar
argument_list|(
name|trimmed
argument_list|,
name|k
operator|+
name|i
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|k
operator|+=
name|inlineCComment
operator|->
name|matchedLength
argument_list|()
expr_stmt|;
block|}
comment|/*         Replace goto and switch labels by whitespace, but be careful         with this case:          foo1: bar1;                 bar2;     */
while|while
condition|(
name|trimmed
operator|.
name|lastIndexOf
argument_list|(
literal|':'
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|trimmed
operator|.
name|indexOf
argument_list|(
operator|*
name|label
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|cap1
init|=
name|label
operator|->
name|cap
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|pos1
init|=
name|label
operator|->
name|pos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|stop
init|=
name|cap1
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos1
operator|+
name|stop
operator|<
operator|(
name|int
operator|)
name|trimmed
operator|.
name|length
argument_list|()
operator|&&
name|ppIndentSize
operator|<
name|stop
condition|)
name|stop
operator|=
name|ppIndentSize
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|stop
condition|)
block|{
name|eraseChar
argument_list|(
name|trimmed
argument_list|,
name|pos1
operator|+
name|i
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|cap1
operator|.
name|length
argument_list|()
condition|)
block|{
name|eraseChar
argument_list|(
name|trimmed
argument_list|,
name|pos1
operator|+
name|i
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/*         Remove C++-style comments.     */
name|k
operator|=
name|trimmed
operator|.
name|indexOf
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
operator|-
literal|1
condition|)
name|trimmed
operator|.
name|truncate
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|trimmed
return|;
block|}
end_function
begin_comment
comment|/*     Returns '(' if the last parenthesis is opening, ')' if it is     closing, and QChar::Null if there are no parentheses in t. */
end_comment
begin_function
DECL|function|lastParen
specifier|static
specifier|inline
name|QChar
name|lastParen
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|int
name|i
init|=
name|t
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|t
index|[
name|i
index|]
operator|==
name|QChar
argument_list|(
literal|'('
argument_list|)
operator|||
name|t
index|[
name|i
index|]
operator|==
name|QChar
argument_list|(
literal|')'
argument_list|)
condition|)
return|return
name|t
index|[
name|i
index|]
return|;
block|}
return|return
name|QChar
operator|::
name|Null
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if typedIn the same as okayCh or is null; otherwise     returns false. */
end_comment
begin_function
DECL|function|okay
specifier|static
specifier|inline
name|bool
name|okay
parameter_list|(
name|QChar
name|typedIn
parameter_list|,
name|QChar
name|okayCh
parameter_list|)
block|{
return|return
name|typedIn
operator|==
name|QChar
operator|::
name|Null
operator|||
name|typedIn
operator|==
name|okayCh
return|;
block|}
end_function
begin_comment
comment|/*     The "linizer" is a group of functions and variables to iterate     through the source code of the program to indent. The program is     given as a list of strings, with the bottom line being the line     to indent. The actual program might contain extra lines, but     those are uninteresting and not passed over to us. */
end_comment
begin_struct
DECL|struct|LinizerState
struct|struct
name|LinizerState
block|{
DECL|member|line
name|QString
name|line
decl_stmt|;
DECL|member|braceDepth
name|int
name|braceDepth
decl_stmt|;
DECL|member|leftBraceFollows
name|bool
name|leftBraceFollows
decl_stmt|;
DECL|member|iter
name|QStringList
operator|::
name|ConstIterator
name|iter
decl_stmt|;
DECL|member|inCComment
name|bool
name|inCComment
decl_stmt|;
DECL|member|pendingRightBrace
name|bool
name|pendingRightBrace
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|yyProgram
specifier|static
name|QStringList
modifier|*
name|yyProgram
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yyLinizerState
specifier|static
name|LinizerState
modifier|*
name|yyLinizerState
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// shorthands
end_comment
begin_decl_stmt
DECL|variable|yyLine
specifier|static
specifier|const
name|QString
modifier|*
name|yyLine
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yyBraceDepth
specifier|static
specifier|const
name|int
modifier|*
name|yyBraceDepth
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yyLeftBraceFollows
specifier|static
specifier|const
name|bool
modifier|*
name|yyLeftBraceFollows
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     Saves and restores the state of the global linizer. This enables     backtracking. */
end_comment
begin_define
DECL|macro|YY_SAVE
define|#
directive|define
name|YY_SAVE
parameter_list|()
define|\
value|LinizerState savedState = *yyLinizerState
end_define
begin_define
DECL|macro|YY_RESTORE
define|#
directive|define
name|YY_RESTORE
parameter_list|()
define|\
value|*yyLinizerState = savedState
end_define
begin_comment
comment|/*     Advances to the previous line in yyProgram and update yyLine     accordingly. yyLine is cleaned from comments and other damageable     constructs. Empty lines are skipped. */
end_comment
begin_function
DECL|function|readLine
specifier|static
name|bool
name|readLine
parameter_list|()
block|{
name|int
name|k
decl_stmt|;
name|yyLinizerState
operator|->
name|leftBraceFollows
operator|=
operator|(
name|firstNonWhiteSpace
argument_list|(
name|yyLinizerState
operator|->
name|line
argument_list|)
operator|==
name|QChar
argument_list|(
literal|'{'
argument_list|)
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|yyLinizerState
operator|->
name|iter
operator|==
name|yyProgram
operator|->
name|constBegin
argument_list|()
condition|)
block|{
name|yyLinizerState
operator|->
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|--
name|yyLinizerState
operator|->
name|iter
expr_stmt|;
name|yyLinizerState
operator|->
name|line
operator|=
operator|*
name|yyLinizerState
operator|->
name|iter
expr_stmt|;
name|yyLinizerState
operator|->
name|line
operator|=
name|trimmedCodeLine
argument_list|(
name|yyLinizerState
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/*             Remove C-style comments that span multiple lines. If the             bottom line starts in a C-style comment, we are not aware             of that and eventually yyLine will contain a slash-aster.              Notice that both if's can be executed, since             yyLinizerState->inCComment is potentially set to false in             the first if. The order of the if's is also important.         */
if|if
condition|(
name|yyLinizerState
operator|->
name|inCComment
condition|)
block|{
name|QString
name|slashAster
argument_list|(
literal|"/*"
argument_list|)
decl_stmt|;
name|k
operator|=
name|yyLinizerState
operator|->
name|line
operator|.
name|indexOf
argument_list|(
name|slashAster
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|yyLinizerState
operator|->
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|yyLinizerState
operator|->
name|line
operator|.
name|truncate
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|yyLinizerState
operator|->
name|inCComment
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|yyLinizerState
operator|->
name|inCComment
condition|)
block|{
name|QString
name|asterSlash
argument_list|(
literal|"*/"
argument_list|)
decl_stmt|;
name|k
operator|=
name|yyLinizerState
operator|->
name|line
operator|.
name|indexOf
argument_list|(
name|asterSlash
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|k
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|eraseChar
argument_list|(
name|yyLinizerState
operator|->
name|line
argument_list|,
name|i
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|yyLinizerState
operator|->
name|inCComment
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/*             Remove preprocessor directives.         */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|k
operator|<
operator|(
name|int
operator|)
name|yyLinizerState
operator|->
name|line
operator|.
name|length
argument_list|()
condition|)
block|{
name|QChar
name|ch
init|=
name|yyLinizerState
operator|->
name|line
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QChar
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
name|yyLinizerState
operator|->
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
break|break;
block|}
name|k
operator|++
expr_stmt|;
block|}
comment|/*             Remove trailing spaces.         */
name|k
operator|=
name|yyLinizerState
operator|->
name|line
operator|.
name|length
argument_list|()
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
name|yyLinizerState
operator|->
name|line
index|[
name|k
operator|-
literal|1
index|]
operator|.
name|isSpace
argument_list|()
condition|)
name|k
operator|--
expr_stmt|;
name|yyLinizerState
operator|->
name|line
operator|.
name|truncate
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/*             '}' increment the brace depth and '{' decrements it and not             the other way around, as we are parsing backwards.         */
name|yyLinizerState
operator|->
name|braceDepth
operator|+=
name|yyLinizerState
operator|->
name|line
operator|.
name|count
argument_list|(
literal|'}'
argument_list|)
operator|-
name|yyLinizerState
operator|->
name|line
operator|.
name|count
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
comment|/*             We use a dirty trick for                  } else ...              We don't count the '}' yet, so that it's more or less             equivalent to the friendly construct                  }                 else ...         */
if|if
condition|(
name|yyLinizerState
operator|->
name|pendingRightBrace
condition|)
name|yyLinizerState
operator|->
name|braceDepth
operator|++
expr_stmt|;
name|yyLinizerState
operator|->
name|pendingRightBrace
operator|=
operator|(
name|yyLinizerState
operator|->
name|line
operator|.
name|indexOf
argument_list|(
operator|*
name|braceX
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|yyLinizerState
operator|->
name|pendingRightBrace
condition|)
name|yyLinizerState
operator|->
name|braceDepth
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|yyLinizerState
operator|->
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     Resets the linizer to its initial state, with yyLine containing the     line above the bottom line of the program. */
end_comment
begin_function
DECL|function|startLinizer
specifier|static
name|void
name|startLinizer
parameter_list|()
block|{
name|yyLinizerState
operator|->
name|braceDepth
operator|=
literal|0
expr_stmt|;
name|yyLinizerState
operator|->
name|inCComment
operator|=
literal|false
expr_stmt|;
name|yyLinizerState
operator|->
name|pendingRightBrace
operator|=
literal|false
expr_stmt|;
name|yyLine
operator|=
operator|&
name|yyLinizerState
operator|->
name|line
expr_stmt|;
name|yyBraceDepth
operator|=
operator|&
name|yyLinizerState
operator|->
name|braceDepth
expr_stmt|;
name|yyLeftBraceFollows
operator|=
operator|&
name|yyLinizerState
operator|->
name|leftBraceFollows
expr_stmt|;
name|yyLinizerState
operator|->
name|iter
operator|=
name|yyProgram
operator|->
name|constEnd
argument_list|()
expr_stmt|;
operator|--
name|yyLinizerState
operator|->
name|iter
expr_stmt|;
name|yyLinizerState
operator|->
name|line
operator|=
operator|*
name|yyLinizerState
operator|->
name|iter
expr_stmt|;
name|readLine
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Returns true if the start of the bottom line of yyProgram (and     potentially the whole line) is part of a C-style comment;     otherwise returns false. */
end_comment
begin_function
DECL|function|bottomLineStartsInCComment
specifier|static
name|bool
name|bottomLineStartsInCComment
parameter_list|()
block|{
name|QString
name|slashAster
argument_list|(
literal|"/*"
argument_list|)
decl_stmt|;
name|QString
name|asterSlash
argument_list|(
literal|"*/"
argument_list|)
decl_stmt|;
comment|/*         We could use the linizer here, but that would slow us down         terribly. We are better to trim only the code lines we need.     */
name|QStringList
operator|::
name|ConstIterator
name|p
init|=
name|yyProgram
operator|->
name|constEnd
argument_list|()
decl_stmt|;
operator|--
name|p
expr_stmt|;
comment|// skip bottom line
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BigRoof
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|==
name|yyProgram
operator|->
name|constBegin
argument_list|()
condition|)
return|return
literal|false
return|;
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|indexOf
argument_list|(
name|slashAster
argument_list|)
operator|!=
operator|-
literal|1
operator|||
operator|(
operator|*
name|p
operator|)
operator|.
name|indexOf
argument_list|(
name|asterSlash
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|trimmed
init|=
name|trimmedCodeLine
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|trimmed
operator|.
name|indexOf
argument_list|(
name|slashAster
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|trimmed
operator|.
name|indexOf
argument_list|(
name|asterSlash
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*     Returns the recommended indent for the bottom line of yyProgram     assuming that it starts in a C-style comment, a condition that is     tested elsewhere.      Essentially, we're trying to align against some text on the     previous line. */
end_comment
begin_function
DECL|function|indentWhenBottomLineStartsInCComment
specifier|static
name|int
name|indentWhenBottomLineStartsInCComment
parameter_list|()
block|{
name|int
name|k
init|=
name|yyLine
operator|->
name|lastIndexOf
argument_list|(
literal|"/*"
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*           We found a normal text line in a comment. Align the           bottom line with the text on this line.         */
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
return|;
block|}
else|else
block|{
comment|/*           The C-style comment starts on this line. If there is           text on the same line, align with it. Otherwise, align           with the slash-aster plus a given offset.         */
name|int
name|indent
init|=
name|columnForIndex
argument_list|(
operator|*
name|yyLine
argument_list|,
name|k
argument_list|)
decl_stmt|;
name|k
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|k
operator|<
operator|(
name|int
operator|)
name|yyLine
operator|->
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|yyLine
operator|)
index|[
name|k
index|]
operator|.
name|isSpace
argument_list|()
condition|)
return|return
name|columnForIndex
argument_list|(
operator|*
name|yyLine
argument_list|,
name|k
argument_list|)
return|;
name|k
operator|++
expr_stmt|;
block|}
return|return
name|indent
operator|+
name|ppCommentOffset
return|;
block|}
block|}
end_function
begin_comment
comment|/*     A function called match...() modifies the linizer state. If it     returns true, yyLine is the top line of the matched construct;     otherwise, the linizer is left in an unknown state.      A function called is...() keeps the linizer state intact. */
end_comment
begin_comment
comment|/*     Returns true if the current line (and upwards) forms a braceless     control statement; otherwise returns false.      The first line of the following example is a "braceless control     statement":          if ( x )             y; */
end_comment
begin_function
DECL|function|matchBracelessControlStatement
specifier|static
name|bool
name|matchBracelessControlStatement
parameter_list|()
block|{
name|int
name|delimDepth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yyLine
operator|->
name|endsWith
argument_list|(
literal|"else"
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|yyLine
operator|->
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SmallRoof
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|yyLine
operator|->
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|QChar
name|ch
init|=
operator|(
operator|*
name|yyLine
operator|)
index|[
name|j
index|]
decl_stmt|;
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|')'
case|:
name|delimDepth
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|delimDepth
operator|--
expr_stmt|;
if|if
condition|(
name|delimDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|yyLine
operator|->
name|indexOf
argument_list|(
operator|*
name|iflikeKeyword
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*                             We have                                  if ( x )                                     y                              "if ( x )" is not part of the statement                             "y".                         */
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|delimDepth
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*                       We have                            if ( (1 +                                 2)                        and not                            if ( 1 +                                2 )                     */
return|return
literal|false
return|;
block|}
break|break;
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|';'
case|:
comment|/*                     We met a statement separator, but not where we                     expected it. What follows is probably a weird                     continuation line. Be careful with ';' in for,                     though.                 */
if|if
condition|(
name|ch
operator|!=
name|QChar
argument_list|(
literal|';'
argument_list|)
operator|||
name|delimDepth
operator|==
literal|0
condition|)
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|readLine
argument_list|()
condition|)
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if yyLine is an unfinished line; otherwise returns     false.      In many places we'll use the terms "standalone line", "unfinished     line" and "continuation line". The meaning of these should be     evident from this code example:          a = b;    // standalone line         c = d +   // unfinished line             e +   // unfinished continuation line             f +   // unfinished continuation line             g;    // continuation line */
end_comment
begin_function
DECL|function|isUnfinishedLine
specifier|static
name|bool
name|isUnfinishedLine
parameter_list|()
block|{
name|bool
name|unf
init|=
literal|false
decl_stmt|;
name|YY_SAVE
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyLine
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QChar
name|lastCh
init|=
operator|(
operator|*
name|yyLine
operator|)
index|[
operator|(
name|int
operator|)
name|yyLine
operator|->
name|length
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QString
argument_list|(
literal|"{};"
argument_list|)
operator|.
name|indexOf
argument_list|(
name|lastCh
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|!
name|yyLine
operator|->
name|endsWith
argument_list|(
literal|"..."
argument_list|)
condition|)
block|{
comment|/*           It doesn't end with ';' or similar. If it's neither           "Q_OBJECT" nor "if ( x )", it must be an unfinished line.         */
name|unf
operator|=
operator|(
name|yyLine
operator|->
name|indexOf
argument_list|(
literal|"Q_OBJECT"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|!
name|matchBracelessControlStatement
argument_list|()
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastCh
operator|==
name|QChar
argument_list|(
literal|';'
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastParen
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|==
name|QChar
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
comment|/*               Exception:                    for ( int i = 1; i< 10;             */
name|unf
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readLine
argument_list|()
operator|&&
name|yyLine
operator|->
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
operator|&&
name|lastParen
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|==
name|QChar
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
comment|/*               Exception:                    for ( int i = 1;                         i< 10;             */
name|unf
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|YY_RESTORE
argument_list|()
expr_stmt|;
return|return
name|unf
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if yyLine is a continuation line; otherwise returns     false. */
end_comment
begin_function
DECL|function|isContinuationLine
specifier|static
name|bool
name|isContinuationLine
parameter_list|()
block|{
name|bool
name|cont
init|=
literal|false
decl_stmt|;
name|YY_SAVE
argument_list|()
expr_stmt|;
if|if
condition|(
name|readLine
argument_list|()
condition|)
name|cont
operator|=
name|isUnfinishedLine
argument_list|()
expr_stmt|;
name|YY_RESTORE
argument_list|()
expr_stmt|;
return|return
name|cont
return|;
block|}
end_function
begin_comment
comment|/*     Returns the recommended indent for the bottom line of yyProgram,     assuming it's a continuation line.      We're trying to align the continuation line against some parenthesis     or other bracked left opened on a previous line, or some interesting     operator such as '='. */
end_comment
begin_function
DECL|function|indentForContinuationLine
specifier|static
name|int
name|indentForContinuationLine
parameter_list|()
block|{
name|int
name|braceDepth
init|=
literal|0
decl_stmt|;
name|int
name|delimDepth
init|=
literal|0
decl_stmt|;
name|bool
name|leftBraceFollowed
init|=
operator|*
name|yyLeftBraceFollows
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SmallRoof
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hook
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|j
init|=
name|yyLine
operator|->
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
name|hook
operator|<
literal|0
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|QChar
name|ch
init|=
operator|(
operator|*
name|yyLine
operator|)
index|[
name|j
index|]
decl_stmt|;
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|')'
case|:
case|case
literal|']'
case|:
name|delimDepth
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|braceDepth
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'['
case|:
name|delimDepth
operator|--
expr_stmt|;
comment|/*                     An unclosed delimiter is a good place to align at,                     at least for some styles (including Qt's).                 */
if|if
condition|(
name|delimDepth
operator|==
operator|-
literal|1
condition|)
name|hook
operator|=
name|j
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|braceDepth
operator|--
expr_stmt|;
comment|/*                     A left brace followed by other stuff on the same                     line is typically for an enum or an initializer.                     Such a brace must be treated just like the other                     delimiters.                 */
if|if
condition|(
name|braceDepth
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|j
operator|<
operator|(
name|int
operator|)
name|yyLine
operator|->
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|hook
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
comment|// shouldn't happen
block|}
block|}
break|break;
case|case
literal|'='
case|:
comment|/*                     An equal sign is a very natural alignment hook                     because it's usually the operator with the lowest                     precedence in statements it appears in. Case in                     point:                          int x = 1 +                                 2;                      However, we have to beware of constructs such as                     default arguments and explicit enum constant                     values:                          void foo( int x = 0,                                   int y = 0 );                      And not                          void foo( int x = 0,                                         int y = 0 );                      These constructs are caracterized by a ',' at the                     end of the unfinished lines or by unbalanced                     parentheses.                 */
if|if
condition|(
name|QString
argument_list|(
literal|"!=<>"
argument_list|)
operator|.
name|indexOf
argument_list|(
operator|(
operator|*
name|yyLine
operator|)
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
operator|*
name|yyLine
operator|)
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
if|if
condition|(
name|braceDepth
operator|==
literal|0
operator|&&
name|delimDepth
operator|==
literal|0
operator|&&
name|j
operator|<
operator|(
name|int
operator|)
name|yyLine
operator|->
name|length
argument_list|()
operator|-
literal|1
operator|&&
operator|!
name|yyLine
operator|->
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
operator|&&
operator|(
name|yyLine
operator|->
name|contains
argument_list|(
literal|'('
argument_list|)
operator|==
name|yyLine
operator|->
name|contains
argument_list|(
literal|')'
argument_list|)
operator|)
condition|)
name|hook
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hook
operator|>=
literal|0
condition|)
block|{
comment|/*                 Yes, we have a delimiter or an operator to align                 against! We don't really align against it, but rather                 against the following token, if any. In this example,                 the following token is "11":                      int x = ( 11 +                               2 );                  If there is no such token, we use a continuation indent:                      static QRegExp foo( QString(                             "foo foo foo foo foo foo foo foo foo") );             */
name|hook
operator|++
expr_stmt|;
while|while
condition|(
name|hook
operator|<
operator|(
name|int
operator|)
name|yyLine
operator|->
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|yyLine
operator|)
index|[
name|hook
index|]
operator|.
name|isSpace
argument_list|()
condition|)
return|return
name|columnForIndex
argument_list|(
operator|*
name|yyLine
argument_list|,
name|hook
argument_list|)
return|;
name|hook
operator|++
expr_stmt|;
block|}
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|+
name|ppContinuationIndentSize
return|;
block|}
if|if
condition|(
name|braceDepth
operator|!=
literal|0
condition|)
break|break;
comment|/*             The line's delimiters are balanced. It looks like a             continuation line or something.         */
if|if
condition|(
name|delimDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|leftBraceFollowed
condition|)
block|{
comment|/*                     We have                          int main()                         {                      or                          Bar::Bar()                             : Foo( x )                         {                      The "{" should be flush left.                 */
if|if
condition|(
operator|!
name|isContinuationLine
argument_list|()
condition|)
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isContinuationLine
argument_list|()
operator|||
name|yyLine
operator|->
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
condition|)
block|{
comment|/*                     We have                          x = a +                             b +                             c;                      or                          int t[] = {                             1, 2, 3,                             4, 5, 6                      The "c;" should fall right under the "b +", and the                     "4, 5, 6" right under the "1, 2, 3,".                 */
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
return|;
block|}
else|else
block|{
comment|/*                     We have                          stream<< 1 +                                 2;                      We could, but we don't, try to analyze which                     operator has precedence over which and so on, to                     obtain the excellent result                          stream<< 1 +                                   2;                      We do have a special trick above for the assignment                     operator above, though.                 */
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|+
name|ppContinuationIndentSize
return|;
block|}
block|}
if|if
condition|(
operator|!
name|readLine
argument_list|()
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*     Returns the recommended indent for the bottom line of yyProgram if     that line is standalone (or should be indented likewise).      Indenting a standalone line is tricky, mostly because of braceless     control statements. Grossly, we are looking backwards for a special     line, a "hook line", that we can use as a starting point to indent,     and then modify the indentation level according to the braces met     along the way to that hook.      Let's consider a few examples. In all cases, we want to indent the     bottom line.      Example 1:          x = 1;         y = 2;      The hook line is "x = 1;". We met 0 opening braces and 0 closing     braces. Therefore, "y = 2;" inherits the indent of "x = 1;".      Example 2:          if ( x ) {             y;      The hook line is "if ( x ) {". No matter what precedes it, "y;" has     to be indented one level deeper than the hook line, since we met one     opening brace along the way.      Example 3:          if ( a )             while ( b ) {                 c;             }         d;      To indent "d;" correctly, we have to go as far as the "if ( a )".     Compare with          if ( a ) {             while ( b ) {                 c;             }             d;      Still, we're striving to go back as little as possible to     accommodate people with irregular indentation schemes. A hook line     near at hand is much more reliable than a remote one. */
end_comment
begin_function
DECL|function|indentForStandaloneLine
specifier|static
name|int
name|indentForStandaloneLine
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SmallRoof
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|yyLeftBraceFollows
condition|)
block|{
name|YY_SAVE
argument_list|()
expr_stmt|;
if|if
condition|(
name|matchBracelessControlStatement
argument_list|()
condition|)
block|{
comment|/*                     The situation is this, and we want to indent "z;":                          if ( x&&                              y )                             z;                      yyLine is "if ( x&&".                 */
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|+
name|ppIndentSize
return|;
block|}
name|YY_RESTORE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yyLine
operator|->
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
operator|||
name|yyLine
operator|->
name|contains
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|/*                 The situation is possibly this, and we want to indent                 "z;":                      while ( x )                         y;                     z;                  We return the indent of "while ( x )". In place of "y;",                 any arbitrarily complex compound statement can appear.             */
if|if
condition|(
operator|*
name|yyBraceDepth
operator|>
literal|0
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|readLine
argument_list|()
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|yyBraceDepth
operator|>
literal|0
condition|)
do|;
block|}
name|LinizerState
name|hookState
decl_stmt|;
while|while
condition|(
name|isContinuationLine
argument_list|()
condition|)
name|readLine
argument_list|()
expr_stmt|;
name|hookState
operator|=
operator|*
name|yyLinizerState
expr_stmt|;
name|readLine
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|yyBraceDepth
operator|<=
literal|0
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|matchBracelessControlStatement
argument_list|()
condition|)
break|break;
name|hookState
operator|=
operator|*
name|yyLinizerState
expr_stmt|;
block|}
do|while
condition|(
name|readLine
argument_list|()
condition|)
do|;
block|}
operator|*
name|yyLinizerState
operator|=
name|hookState
expr_stmt|;
while|while
condition|(
name|isContinuationLine
argument_list|()
condition|)
name|readLine
argument_list|()
expr_stmt|;
comment|/*               Never trust lines containing only '{' or '}', as some               people (Richard M. Stallman) format them weirdly.             */
if|if
condition|(
name|yyLine
operator|->
name|trimmed
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
return|return
name|indentOfLine
argument_list|(
operator|*
name|yyLine
argument_list|)
operator|-
operator|*
name|yyBraceDepth
operator|*
name|ppIndentSize
return|;
block|}
if|if
condition|(
operator|!
name|readLine
argument_list|()
condition|)
return|return
operator|-
operator|*
name|yyBraceDepth
operator|*
name|ppIndentSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*     Constructs global variables used by the indenter. */
end_comment
begin_function
DECL|function|initializeIndenter
specifier|static
name|void
name|initializeIndenter
parameter_list|()
block|{
name|literal
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"([\"'])(?:\\\\.|[^\\\\])*\\1"
argument_list|)
expr_stmt|;
name|literal
operator|->
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|label
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"^\\s*((?:case\\b([^:]|::)+|[a-zA-Z_0-9]+)(?:\\s+slots)?:)(?!:)"
argument_list|)
expr_stmt|;
name|inlineCComment
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"/\\*.*\\*/"
argument_list|)
expr_stmt|;
name|inlineCComment
operator|->
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|braceX
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"^\\s*\\}\\s*(?:else|catch)\\b"
argument_list|)
expr_stmt|;
name|iflikeKeyword
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"\\b(?:catch|do|for|if|while)\\b"
argument_list|)
expr_stmt|;
name|yyLinizerState
operator|=
operator|new
name|LinizerState
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Destroys global variables used by the indenter. */
end_comment
begin_function
DECL|function|terminateIndenter
specifier|static
name|void
name|terminateIndenter
parameter_list|()
block|{
operator|delete
name|literal
expr_stmt|;
operator|delete
name|label
expr_stmt|;
operator|delete
name|inlineCComment
expr_stmt|;
operator|delete
name|braceX
expr_stmt|;
operator|delete
name|iflikeKeyword
expr_stmt|;
operator|delete
name|yyLinizerState
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Returns the recommended indent for the bottom line of program.     Unless null, typedIn stores the character of yyProgram that     triggered reindentation.      This function works better if typedIn is set properly; it is     slightly more conservative if typedIn is completely wild, and     slighly more liberal if typedIn is always null. The user might be     annoyed by the liberal behavior. */
end_comment
begin_function
DECL|function|indentForBottomLine
name|int
name|indentForBottomLine
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|program
parameter_list|,
name|QChar
name|typedIn
parameter_list|)
block|{
if|if
condition|(
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|initializeIndenter
argument_list|()
expr_stmt|;
name|yyProgram
operator|=
operator|new
name|QStringList
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|startLinizer
argument_list|()
expr_stmt|;
specifier|const
name|QString
modifier|&
name|bottomLine
init|=
name|program
operator|.
name|last
argument_list|()
decl_stmt|;
name|QChar
name|firstCh
init|=
name|firstNonWhiteSpace
argument_list|(
name|bottomLine
argument_list|)
decl_stmt|;
name|int
name|indent
decl_stmt|;
if|if
condition|(
name|bottomLineStartsInCComment
argument_list|()
condition|)
block|{
comment|/*             The bottom line starts in a C-style comment. Indent it             smartly, unless the user has already played around with it,             in which case it's better to leave her stuff alone.         */
if|if
condition|(
name|isOnlyWhiteSpace
argument_list|(
name|bottomLine
argument_list|)
condition|)
block|{
name|indent
operator|=
name|indentWhenBottomLineStartsInCComment
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|indent
operator|=
name|indentOfLine
argument_list|(
name|bottomLine
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|okay
argument_list|(
name|typedIn
argument_list|,
literal|'#'
argument_list|)
operator|&&
name|firstCh
operator|==
name|QChar
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
comment|/*             Preprocessor directives go flush left.         */
name|indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isUnfinishedLine
argument_list|()
condition|)
block|{
name|indent
operator|=
name|indentForContinuationLine
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|indent
operator|=
name|indentForStandaloneLine
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|okay
argument_list|(
name|typedIn
argument_list|,
literal|'}'
argument_list|)
operator|&&
name|firstCh
operator|==
name|QChar
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
comment|/*                 A closing brace is one level more to the left than the                 code it follows.             */
name|indent
operator|-=
name|ppIndentSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|okay
argument_list|(
name|typedIn
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|QRegExp
name|caseLabel
argument_list|(
literal|"\\s*(?:case\\b(?:[^:]|::)+"
literal|"|(?:public|protected|private|signals|default)(?:\\s+slots)?\\s*"
literal|")?:.*"
argument_list|)
decl_stmt|;
if|if
condition|(
name|caseLabel
operator|.
name|exactMatch
argument_list|(
name|bottomLine
argument_list|)
condition|)
block|{
comment|/*                     Move a case label (or the ':' in front of a                     constructor initialization list) one level to the                     left, but only if the user did not play around with                     it yet. Some users have exotic tastes in the                     matter, and most users probably are not patient                     enough to wait for the final ':' to format their                     code properly.                      We don't attempt the same for goto labels, as the                     user is probably the middle of "foo::bar". (Who                     uses goto, anyway?)                 */
if|if
condition|(
name|indentOfLine
argument_list|(
name|bottomLine
argument_list|)
operator|<=
name|indent
condition|)
name|indent
operator|-=
name|ppIndentSize
expr_stmt|;
else|else
name|indent
operator|=
name|indentOfLine
argument_list|(
name|bottomLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|delete
name|yyProgram
expr_stmt|;
name|terminateIndenter
argument_list|()
expr_stmt|;
return|return
name|qMax
argument_list|(
literal|0
argument_list|,
name|indent
argument_list|)
return|;
block|}
end_function
begin_function
name|QT_END_NAMESPACE
ifdef|#
directive|ifdef
name|Q_TEST_YYINDENT
comment|/*   Test driver. */
include|#
directive|include
file|<qfile.h>
include|#
directive|include
file|<qtextstream.h>
include|#
directive|include
file|<errno.h>
name|QT_BEGIN_NAMESPACE
DECL|function|fileContents
specifier|static
name|QString
name|fileContents
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|f
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"yyindent error: Cannot open file '%s' for reading: %s"
argument_list|,
name|fileName
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QTextStream
name|t
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|QString
name|contents
init|=
name|t
operator|.
name|read
argument_list|()
decl_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|contents
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"yyindent error: File '%s' is empty"
argument_list|,
name|fileName
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|contents
return|;
block|}
end_function
begin_function
name|QT_END_NAMESPACE
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|QT_USE_NAMESPACE
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"usage: yyindent file.cpp"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|QString
name|code
init|=
name|fileContents
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|QStringList
name|program
init|=
name|QStringList
operator|::
name|split
argument_list|(
literal|'\n'
argument_list|,
name|code
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|QStringList
name|p
decl_stmt|;
name|QString
name|out
decl_stmt|;
while|while
condition|(
operator|!
name|program
operator|.
name|isEmpty
argument_list|()
operator|&&
name|program
operator|.
name|last
argument_list|()
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|program
operator|.
name|remove
argument_list|(
name|program
operator|.
name|fromLast
argument_list|()
argument_list|)
expr_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|line
init|=
name|program
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
name|program
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|p
operator|.
name|push_back
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
name|QChar
name|typedIn
init|=
name|firstNonWhiteSpace
argument_list|(
operator|*
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|last
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
name|typedIn
operator|=
literal|':'
expr_stmt|;
name|int
name|indent
init|=
name|indentForBottomLine
argument_list|(
name|p
argument_list|,
name|typedIn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|line
operator|)
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|out
operator|+=
operator|(
operator|*
name|line
operator|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|++
name|line
expr_stmt|;
block|}
while|while
condition|(
name|out
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
condition|)
name|out
operator|.
name|truncate
argument_list|(
name|out
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|out
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_TEST_YYINDENT
end_comment
end_unit
