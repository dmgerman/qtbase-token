begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   htmlgenerator.cpp */
end_comment
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"codeparser.h"
end_include
begin_include
include|#
directive|include
file|"helpprojectwriter.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"separator.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qiterator.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<quuid.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|COMMAND_VERSION
define|#
directive|define
name|COMMAND_VERSION
value|Doc::alias("version")
DECL|member|id
name|int
name|HtmlGenerator
operator|::
name|id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|debugging_on
name|bool
name|HtmlGenerator
operator|::
name|debugging_on
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|divNavTop
name|QString
name|HtmlGenerator
operator|::
name|divNavTop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|showBrokenLinks
specifier|static
name|bool
name|showBrokenLinks
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|linkTag
argument_list|(
literal|"(<@link node=\"([^\"]+)\">).*(</@link>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|funcTag
argument_list|(
literal|"(<@func target=\"([^\"]*)\">)(.*)(</@func>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|typeTag
argument_list|(
literal|"(<@(type|headerfile|func)(?: +[^>]*)?>)(.*)(</@\\2>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|spanTag
argument_list|(
literal|"</@(?:comment|preprocessor|string|char|number|op|type|name|keyword)>"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|unknownTag
argument_list|(
literal|"</?@[^>]*>"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|addLink
specifier|static
name|void
name|addLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|linkTarget
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|nestedStuff
parameter_list|,
name|QString
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkTarget
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|res
operator|+=
literal|"<a href=\""
expr_stmt|;
operator|*
name|res
operator|+=
name|linkTarget
expr_stmt|;
operator|*
name|res
operator|+=
literal|"\">"
expr_stmt|;
operator|*
name|res
operator|+=
name|nestedStuff
expr_stmt|;
operator|*
name|res
operator|+=
literal|"</a>"
expr_stmt|;
block|}
else|else
block|{
operator|*
name|res
operator|+=
name|nestedStuff
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Constructs the HTML output generator.  */
end_comment
begin_constructor
DECL|function|HtmlGenerator
name|HtmlGenerator
operator|::
name|HtmlGenerator
parameter_list|()
member_init_list|:
name|codeIndent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|helpProjectWriter
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|inObsoleteLink
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|funcLeftParen
argument_list|(
literal|"\\S(\\()"
argument_list|)
member_init_list|,
name|obsoleteLinks
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys the HTML output generator. Deletes the singleton   instance of HelpProjectWriter.  */
end_comment
begin_destructor
DECL|function|~HtmlGenerator
name|HtmlGenerator
operator|::
name|~
name|HtmlGenerator
parameter_list|()
block|{
if|if
condition|(
name|helpProjectWriter
condition|)
operator|delete
name|helpProjectWriter
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Initializes the HTML output generator's data structures   from the configuration class \a config.  */
end_comment
begin_function
DECL|function|initializeGenerator
name|void
name|HtmlGenerator
operator|::
name|initializeGenerator
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|left
decl_stmt|;
specifier|const
name|char
modifier|*
name|right
decl_stmt|;
block|}
name|defaults
index|[]
init|=
block|{
block|{
name|ATOM_FORMATTING_BOLD
block|,
literal|"<b>"
block|,
literal|"</b>"
block|}
block|,
block|{
name|ATOM_FORMATTING_INDEX
block|,
literal|"<!--"
block|,
literal|"-->"
block|}
block|,
block|{
name|ATOM_FORMATTING_ITALIC
block|,
literal|"<i>"
block|,
literal|"</i>"
block|}
block|,
block|{
name|ATOM_FORMATTING_PARAMETER
block|,
literal|"<i>"
block|,
literal|"</i>"
block|}
block|,
block|{
name|ATOM_FORMATTING_SUBSCRIPT
block|,
literal|"<sub>"
block|,
literal|"</sub>"
block|}
block|,
block|{
name|ATOM_FORMATTING_SUPERSCRIPT
block|,
literal|"<sup>"
block|,
literal|"</sup>"
block|}
block|,
block|{
name|ATOM_FORMATTING_TELETYPE
block|,
literal|"<tt>"
block|,
literal|"</tt>"
block|}
block|,
block|{
name|ATOM_FORMATTING_UICONTROL
block|,
literal|"<b>"
block|,
literal|"</b>"
block|}
block|,
block|{
name|ATOM_FORMATTING_UNDERLINE
block|,
literal|"<u>"
block|,
literal|"</u>"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|Generator
operator|::
name|initializeGenerator
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|obsoleteLinks
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OBSOLETELINKS
argument_list|)
argument_list|)
expr_stmt|;
name|setImageFileExtensions
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"png"
operator|<<
literal|"jpg"
operator|<<
literal|"jpeg"
operator|<<
literal|"gif"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
condition|)
block|{
name|formattingLeftMap
argument_list|()
operator|.
name|insert
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|formattingRightMap
argument_list|()
operator|.
name|insert
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|style
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_STYLE
argument_list|)
expr_stmt|;
name|endHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_ENDHEADER
argument_list|)
expr_stmt|;
name|postHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_POSTHEADER
argument_list|)
expr_stmt|;
name|postPostHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_POSTPOSTHEADER
argument_list|)
expr_stmt|;
name|footer
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_FOOTER
argument_list|)
expr_stmt|;
name|address
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_ADDRESS
argument_list|)
expr_stmt|;
name|pleaseGenerateMacRef
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_GENERATEMACREFS
argument_list|)
expr_stmt|;
name|noBreadCrumbs
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_NOBREADCRUMBS
argument_list|)
expr_stmt|;
name|project
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_PROJECT
argument_list|)
expr_stmt|;
name|projectDescription
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_DESCRIPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|projectDescription
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|projectDescription
operator|=
name|project
operator|+
literal|" Reference Documentation"
expr_stmt|;
name|projectUrl
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_URL
argument_list|)
expr_stmt|;
name|tagFile_
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_TAGFILE
argument_list|)
expr_stmt|;
name|outputEncoding
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_OUTPUTENCODING
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputEncoding
operator|.
name|isEmpty
argument_list|()
condition|)
name|outputEncoding
operator|=
name|QLatin1String
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|outputCodec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|outputEncoding
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
name|naturalLanguage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NATURALLANGUAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|naturalLanguage
operator|.
name|isEmpty
argument_list|()
condition|)
name|naturalLanguage
operator|=
name|QLatin1String
argument_list|(
literal|"en"
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|editionNames
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_EDITION
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|edition
init|=
name|editionNames
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|edition
operator|!=
name|editionNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|editionName
init|=
operator|*
name|edition
decl_stmt|;
name|QStringList
name|editionModules
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"modules"
argument_list|)
decl_stmt|;
name|QStringList
name|editionGroups
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"groups"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|editionModules
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionModuleMap
index|[
name|editionName
index|]
operator|=
name|editionModules
expr_stmt|;
if|if
condition|(
operator|!
name|editionGroups
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionGroupMap
index|[
name|editionName
index|]
operator|=
name|editionGroups
expr_stmt|;
operator|++
name|edition
expr_stmt|;
block|}
comment|// The following line was changed to fix QTBUG-27798
comment|//codeIndent = config.getInt(CONFIG_CODEINDENT);
name|helpProjectWriter
operator|=
operator|new
name|HelpProjectWriter
argument_list|(
name|config
argument_list|,
name|project
operator|.
name|toLower
argument_list|()
operator|+
literal|".qhp"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Documentation template handling
name|headerScripts
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_HEADERSCRIPTS
argument_list|)
expr_stmt|;
name|headerStyles
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_HEADERSTYLES
argument_list|)
expr_stmt|;
name|QString
name|prefix
init|=
name|CONFIG_QHP
operator|+
name|Config
operator|::
name|dot
operator|+
name|project
operator|+
name|Config
operator|::
name|dot
decl_stmt|;
name|manifestDir
operator|=
literal|"qthelp://"
operator|+
name|config
operator|.
name|getString
argument_list|(
name|prefix
operator|+
literal|"namespace"
argument_list|)
expr_stmt|;
name|manifestDir
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|config
operator|.
name|getString
argument_list|(
name|prefix
operator|+
literal|"virtualFolder"
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|examplesPath
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_EXAMPLESINSTALLPATH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|examplesPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|examplesPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Gracefully terminates the HTML output generator.  */
end_comment
begin_function
DECL|function|terminateGenerator
name|void
name|HtmlGenerator
operator|::
name|terminateGenerator
parameter_list|()
block|{
name|Generator
operator|::
name|terminateGenerator
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format
name|QString
name|HtmlGenerator
operator|::
name|format
parameter_list|()
block|{
return|return
literal|"HTML"
return|;
block|}
end_function
begin_comment
comment|/*!   Traverses the database generating all the HTML documentation.  */
end_comment
begin_function
DECL|function|generateTree
name|void
name|HtmlGenerator
operator|::
name|generateTree
parameter_list|()
block|{
name|qdb_
operator|->
name|buildCollections
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|runPrepareOnly
argument_list|()
condition|)
block|{
name|Generator
operator|::
name|generateTree
argument_list|()
expr_stmt|;
name|generateCollisionPages
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|runGenerateOnly
argument_list|()
condition|)
block|{
name|QString
name|fileBase
init|=
name|project
operator|.
name|toLower
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
decl_stmt|;
name|qdb_
operator|->
name|generateIndex
argument_list|(
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|fileBase
operator|+
literal|".index"
argument_list|,
name|projectUrl
argument_list|,
name|projectDescription
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|runPrepareOnly
argument_list|()
condition|)
block|{
name|helpProjectWriter
operator|->
name|generate
argument_list|()
expr_stmt|;
name|generateManifestFiles
argument_list|()
expr_stmt|;
comment|/*           Generate the XML tag file, if it was requested.         */
name|qdb_
operator|->
name|generateTagFile
argument_list|(
name|tagFile_
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate html from an instance of Atom.  */
end_comment
begin_function
DECL|function|generateAtom
name|int
name|HtmlGenerator
operator|::
name|generateAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|int
name|skipAhead
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|in_para
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|Generator
operator|::
name|debugging
argument_list|()
condition|)
block|{
name|atom
operator|->
name|dump
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|atom
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Atom
operator|::
name|AbstractLeft
case|:
if|if
condition|(
name|relative
condition|)
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\abstract is not implemented."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Location
operator|::
name|information
argument_list|(
name|tr
argument_list|(
literal|"\abstract is not implemented."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|AbstractRight
case|:
break|break;
case|case
name|Atom
operator|::
name|AutoLink
case|:
if|if
condition|(
operator|!
name|inLink_
operator|&&
operator|!
name|inContents_
operator|&&
operator|!
name|inSectionHeading_
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|link
init|=
name|getLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|beginLink
argument_list|(
name|link
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|generateLink
argument_list|(
name|atom
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|endLink
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BaseName
case|:
break|break;
case|case
name|Atom
operator|::
name|BriefLeft
case|:
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
name|relative
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Example
condition|)
block|{
name|skipAhead
operator|=
name|skipAtoms
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|BriefRight
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
operator|||
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
name|QString
name|str
decl_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|BriefRight
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|AutoLink
condition|)
name|str
operator|+=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|skipAhead
operator|++
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
name|str
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|str
operator|.
name|truncate
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"This "
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
name|out
argument_list|()
operator|<<
literal|"property"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"variable"
expr_stmt|;
name|QStringList
name|words
init|=
name|str
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"contains"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"specifies"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"describes"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"defines"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"holds"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"determines"
operator|)
condition|)
name|out
argument_list|()
operator|<<
literal|" holds "
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|out
argument_list|()
operator|<<
name|str
operator|<<
literal|'.'
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BriefRight
case|:
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Document
condition|)
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|C
case|:
comment|// This may at one time have been used to mark up C++ code but it is
comment|// now widely used to write teletype text. As a result, text marked
comment|// with the \c command is not passed to a code marker.
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
if|if
condition|(
name|inLink_
condition|)
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CaptionLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p class=\"figCaption\">"
expr_stmt|;
name|in_para
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CaptionRight
case|:
name|endLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|Code
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Qml
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"qml\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|JavaScript
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"js\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CodeNew
case|:
name|out
argument_list|()
operator|<<
literal|"<p>you can rewrite it as</p>\n"
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CodeOld
case|:
name|out
argument_list|()
operator|<<
literal|"<p>For example, if you have code like</p>\n"
expr_stmt|;
comment|// fallthrough
case|case
name|Atom
operator|::
name|CodeBad
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|DivLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<div"
expr_stmt|;
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|' '
operator|<<
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|DivRight
case|:
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FootnoteLeft
case|:
comment|// ### For now
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<!-- "
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FootnoteRight
case|:
comment|// ### For now
name|out
argument_list|()
operator|<<
literal|"-->"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FormatElse
case|:
case|case
name|Atom
operator|::
name|FormatEndif
case|:
case|case
name|Atom
operator|::
name|FormatIf
case|:
break|break;
case|case
name|Atom
operator|::
name|FormattingLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"span "
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|'<'
operator|+
name|atom
operator|->
name|string
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
block|}
else|else
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|atom
operator|->
name|string
argument_list|()
index|]
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_PARAMETER
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
block|{
name|QRegExp
name|subscriptRegExp
argument_list|(
literal|"([a-z]+)_([0-9n])"
argument_list|)
decl_stmt|;
if|if
condition|(
name|subscriptRegExp
operator|.
name|exactMatch
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|<<
literal|"<sub>"
operator|<<
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
operator|<<
literal|"</sub>"
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|FormattingRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_LINK
condition|)
block|{
name|endLink
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"span "
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</span>"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|atom
operator|->
name|string
argument_list|()
index|]
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|AnnotatedList
case|:
block|{
name|DocNode
modifier|*
name|dn
init|=
name|qdb_
operator|->
name|getGroup
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
condition|)
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|dn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|GeneratedList
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"annotatedclasses"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classes"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"qmlclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getQmlTypes
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"classesbymodule"
argument_list|)
condition|)
block|{
name|QString
name|arg
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QString
name|moduleName
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"classesbymodule"
argument_list|)
operator|+
literal|15
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QDocDatabase
modifier|*
name|qdb
init|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
decl_stmt|;
name|DocNode
modifier|*
name|dn
init|=
name|qdb
operator|->
name|findModule
argument_list|(
name|moduleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
condition|)
block|{
name|NodeMap
name|m
decl_stmt|;
name|dn
operator|->
name|getMemberClasses
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classhierarchy"
condition|)
block|{
name|generateClassHierarchy
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"compatclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getCompatibilityClasses
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoleteclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getObsoleteClasses
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"functionindex"
condition|)
block|{
name|generateFunctionIndex
argument_list|(
name|relative
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"legalese"
condition|)
block|{
name|generateLegaleseList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"mainclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getMainClasses
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"services"
condition|)
block|{
name|generateCompactList
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getServiceClasses
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"overviews"
condition|)
block|{
name|generateOverviewList
argument_list|(
name|relative
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"namespaces"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|qdb_
operator|->
name|getNamespaces
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"related"
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
condition|)
name|generateAnnotatedList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|dn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"relatedinline"
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|&&
operator|!
name|dn
operator|->
name|members
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Reverse the list into the original scan order.
comment|// Should be sorted.  But on what?  It may not be a
comment|// regular class or page definition.
name|QList
argument_list|<
specifier|const
name|Node
modifier|*
argument_list|>
name|list
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|dn
operator|->
name|members
argument_list|()
control|)
name|list
operator|.
name|prepend
argument_list|(
name|node
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|list
control|)
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|SinceList
case|:
block|{
specifier|const
name|NodeMultiMap
modifier|&
name|nsmap
init|=
name|qdb_
operator|->
name|getSinceMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeMap
modifier|&
name|ncmap
init|=
name|qdb_
operator|->
name|getClassMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeMap
modifier|&
name|nqcmap
init|=
name|qdb_
operator|->
name|getQmlTypeMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nsmap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LastSinceType
condition|;
operator|++
name|i
control|)
name|sections
operator|.
name|append
argument_list|(
name|Section
argument_list|(
name|sinceTitle
argument_list|(
name|i
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|NodeMultiMap
operator|::
name|const_iterator
name|n
init|=
name|nsmap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nsmap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|n
operator|.
name|value
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Document
case|:
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|sections
index|[
name|QmlClass
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|sections
index|[
name|Namespace
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|sections
index|[
name|Class
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|sections
index|[
name|Enum
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|sections
index|[
name|Typedef
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
name|sections
index|[
name|Macro
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|Node
modifier|*
name|p
init|=
name|fn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
name|sections
index|[
name|MemberFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
name|sections
index|[
name|NamespaceFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Property
case|:
name|sections
index|[
name|Property
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|sections
index|[
name|Variable
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|sections
index|[
name|QmlProperty
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|sections
index|[
name|QmlSignal
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|sections
index|[
name|QmlSignalHandler
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|sections
index|[
name|QmlMethod
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|++
name|n
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
operator|<<
literal|"<a href=\"#"
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\">"
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h3>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h3>\n"
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|Class
condition|)
name|generateCompactList
argument_list|(
literal|0
argument_list|,
name|ncmap
argument_list|,
literal|false
argument_list|,
name|QString
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|QmlClass
condition|)
name|generateCompactList
argument_list|(
literal|0
argument_list|,
name|nqcmap
argument_list|,
literal|false
argument_list|,
name|QString
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|MemberFunction
condition|)
block|{
name|ParentMaps
name|parentmaps
decl_stmt|;
name|ParentMaps
operator|::
name|iterator
name|pmap
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|s
operator|->
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|s
operator|->
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|p
init|=
operator|(
operator|*
name|i
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
name|pmap
operator|=
name|parentmaps
operator|.
name|find
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
name|pmap
operator|=
name|parentmaps
operator|.
name|insert
argument_list|(
name|p
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|pmap
operator|=
name|parentmaps
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|pmap
operator|!=
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
block|{
name|NodeList
name|nlist
init|=
name|pmap
operator|->
name|values
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>Class "
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|pmap
operator|.
name|key
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|QStringList
name|pieces
init|=
name|pmap
operator|.
name|key
argument_list|()
operator|->
name|fullName
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
operator|<<
literal|":</p>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|nlist
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
operator|++
name|pmap
expr_stmt|;
block|}
block|}
else|else
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
operator|++
name|idx
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|BR
case|:
name|out
argument_list|()
operator|<<
literal|"<br />\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|HR
case|:
name|out
argument_list|()
operator|<<
literal|"<hr />\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Image
case|:
case|case
name|Atom
operator|::
name|InlineImage
case|:
block|{
name|QString
name|fileName
init|=
name|imageFileName
argument_list|(
name|relative
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
condition|)
name|text
operator|=
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Image
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"centerAlign\">"
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|relative
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing image: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<font color=\"red\">[Missing image "
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"]</font>"
expr_stmt|;
block|}
else|else
block|{
name|QString
name|prefix
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<img src=\""
operator|<<
name|protectEnc
argument_list|(
name|prefix
operator|+
name|fileName
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|" alt=\""
operator|<<
name|protectEnc
argument_list|(
name|text
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|" alt=\"\""
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|" />"
expr_stmt|;
name|helpProjectWriter
operator|->
name|addExtraFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
operator|)
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|cen
init|=
cast|static_cast
argument_list|<
specifier|const
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|cen
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ExampleNode
modifier|*
name|en
init|=
cast|const_cast
argument_list|<
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|cen
argument_list|)
decl_stmt|;
name|en
operator|->
name|setImageFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Image
condition|)
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ImageText
case|:
break|break;
case|case
name|Atom
operator|::
name|ImportantLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"Important: "
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ImportantRight
case|:
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|NoteLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"Note: "
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|NoteRight
case|:
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LegaleseLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<div class=\"LegaleseLeft\">"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LegaleseRight
case|:
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LineBreak
case|:
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Link
case|:
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|myLink
init|=
name|getLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|myLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|myLink
operator|=
name|getCollisionLink
argument_list|(
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|myLink
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|noLinkErrors
argument_list|()
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Can't link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|=
literal|0
expr_stmt|;
block|}
name|beginLink
argument_list|(
name|myLink
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|LinkNode
case|:
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|beginLink
argument_list|(
name|linkForNode
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListLeft
case|:
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dl>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|threeColumnEnumValueTable_
operator|=
name|isThreeColumnEnumValueTable
argument_list|(
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|threeColumnEnumValueTable_
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"valuelist\">"
expr_stmt|;
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"even\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<th class=\"tblConst\">Constant</th>"
operator|<<
literal|"<th class=\"tblval\">Value</th>"
operator|<<
literal|"<th class=\"tbldscr\">Description</th></tr>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"valuelist\">"
operator|<<
literal|"<tr><th class=\"tblConst\">Constant</th><th class=\"tblVal\">Value</th></tr>\n"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<ol class="
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERALPHA
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"A\""
expr_stmt|;
block|}
comment|/* why type? changed to */
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERALPHA
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"a\""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERROMAN
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"I\""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERROMAN
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"i\""
expr_stmt|;
block|}
else|else
block|{
comment|// (atom->string() == ATOM_LIST_NUMERIC)
name|out
argument_list|()
operator|<<
literal|"\"1\""
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|!=
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|" start=\""
operator|<<
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
operator|<<
literal|'"'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|">\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListItemNumber
case|:
break|break;
case|case
name|Atom
operator|::
name|ListTagLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dt>"
expr_stmt|;
block|}
else|else
block|{
comment|// (atom->string() == ATOM_LIST_VALUE)
comment|// ### Trenton
name|QString
name|t
init|=
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|marker
operator|->
name|markedUpEnumValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|,
name|relative
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"topAlign\"><tt>"
operator|<<
name|t
operator|<<
literal|"</tt></td><td class=\"topAlign\">"
expr_stmt|;
name|QString
name|itemValue
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|itemValue
operator|=
name|enume
operator|->
name|itemValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemValue
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|'?'
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tt>"
operator|<<
name|protectEnc
argument_list|(
name|itemValue
argument_list|)
operator|<<
literal|"</tt>"
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListTagRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
name|out
argument_list|()
operator|<<
literal|"</dt>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ListItemLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dd>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
if|if
condition|(
name|threeColumnEnumValueTable_
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</td><td class=\"topAlign\">"
expr_stmt|;
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ListItemRight
argument_list|)
condition|)
name|out
argument_list|()
operator|<<
literal|"&nbsp;"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ListItemRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</dd>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ol>\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|Nop
case|:
break|break;
case|case
name|Atom
operator|::
name|ParaLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|in_para
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ParaRight
case|:
name|endLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
comment|//if (!matchAhead(atom, Atom::ListItemRight)&& !matchAhead(atom, Atom::TableItemRight))
comment|//    out()<< "</p>\n";
break|break;
case|case
name|Atom
operator|::
name|QuotationLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<blockquote>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|QuotationRight
case|:
name|out
argument_list|()
operator|<<
literal|"</blockquote>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|RawString
case|:
name|out
argument_list|()
operator|<<
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionRight
case|:
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<h"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|hOffset
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|inSectionHeading_
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingRight
case|:
name|out
argument_list|()
operator|<<
literal|"</h"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|hOffset
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|+
literal|">\n"
expr_stmt|;
name|inSectionHeading_
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SidebarLeft
case|:
break|break;
case|case
name|Atom
operator|::
name|SidebarRight
case|:
break|break;
case|case
name|Atom
operator|::
name|String
case|:
if|if
condition|(
name|inLink_
operator|&&
operator|!
name|inContents_
operator|&&
operator|!
name|inSectionHeading_
condition|)
block|{
name|generateLink
argument_list|(
name|atom
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableLeft
case|:
block|{
name|QString
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|QString
name|attr
init|=
literal|"generic"
decl_stmt|;
name|QString
name|width
decl_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p1
operator|=
name|atom
operator|->
name|string
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|1
condition|)
name|p2
operator|=
name|atom
operator|->
name|string
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|p1
operator|==
literal|"borderless"
condition|)
name|attr
operator|=
name|p1
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|.
name|contains
argument_list|(
literal|"%"
argument_list|)
condition|)
name|width
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|p2
operator|==
literal|"borderless"
condition|)
name|attr
operator|=
name|p2
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|.
name|contains
argument_list|(
literal|"%"
argument_list|)
condition|)
name|width
operator|=
name|p2
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<table class=\""
operator|<<
name|attr
operator|<<
literal|"\""
expr_stmt|;
if|if
condition|(
operator|!
name|width
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|" width=\""
operator|<<
name|width
operator|<<
literal|"\""
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|">\n "
expr_stmt|;
name|numTableRows_
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRight
case|:
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<thead><tr class=\"qt-style\">"
expr_stmt|;
name|inTableHeader_
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderRight
case|:
name|out
argument_list|()
operator|<<
literal|"</tr>"
expr_stmt|;
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|TableHeaderLeft
argument_list|)
condition|)
block|{
name|skipAhead
operator|=
literal|1
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"\n<tr class=\"qt-style\">"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</thead>\n"
expr_stmt|;
name|inTableHeader_
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRowLeft
case|:
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr "
operator|<<
name|atom
operator|->
name|string
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"even\">"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableRowRight
case|:
name|out
argument_list|()
operator|<<
literal|"</tr>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableItemLeft
case|:
block|{
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|"<th "
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<td "
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atom
operator|->
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|QString
name|p
init|=
name|atom
operator|->
name|string
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
name|p
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|spans
init|=
name|p
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|spans
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|spans
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|"1"
condition|)
name|out
argument_list|()
operator|<<
literal|" colspan=\""
operator|<<
name|spans
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
if|if
condition|(
name|spans
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|!=
literal|"1"
condition|)
name|out
argument_list|()
operator|<<
literal|" rowspan=\""
operator|<<
name|spans
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
comment|//out()<< "><p>";
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableItemRight
case|:
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|"</th>"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</td>"
expr_stmt|;
comment|//out()<< "</p></td>";
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableOfContents
case|:
break|break;
case|case
name|Atom
operator|::
name|Target
case|:
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|UnhandledFormat
case|:
name|out
argument_list|()
operator|<<
literal|"<b class=\"redFont\">&lt;Missing HTML&gt;</b>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|UnknownCommand
case|:
name|out
argument_list|()
operator|<<
literal|"<b class=\"redFont\"><code>\\"
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"</code></b>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|QmlText
case|:
case|case
name|Atom
operator|::
name|EndQmlText
case|:
comment|// don't do anything with these. They are just tags.
break|break;
default|default:
name|unknownAtom
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
return|return
name|skipAhead
return|;
block|}
end_function
begin_comment
comment|/*!   Generate a reference page for a C++ class.  */
end_comment
begin_function
DECL|function|generateClassLikeNode
name|void
name|HtmlGenerator
operator|::
name|generateClassLikeNode
parameter_list|(
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|ClassNode
modifier|*
name|classe
init|=
literal|0
decl_stmt|;
name|QString
name|title
decl_stmt|;
name|QString
name|rawTitle
decl_stmt|;
name|QString
name|fullTitle
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|rawTitle
operator|=
name|inner
operator|->
name|plainName
argument_list|()
expr_stmt|;
name|fullTitle
operator|=
name|inner
operator|->
name|plainFullName
argument_list|()
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Namespace"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|classe
operator|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|rawTitle
operator|=
name|inner
operator|->
name|plainName
argument_list|()
expr_stmt|;
name|fullTitle
operator|=
name|inner
operator|->
name|plainFullName
argument_list|()
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Class"
expr_stmt|;
block|}
name|Text
name|subtitleText
decl_stmt|;
if|if
condition|(
name|rawTitle
operator|!=
name|fullTitle
condition|)
name|subtitleText
operator|<<
literal|"("
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|fullTitle
argument_list|)
operator|<<
literal|")"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LineBreak
argument_list|)
expr_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|generateTableOfContents
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
operator|&
name|sections
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|subtitleText
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateIncludes
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|classe
condition|)
block|{
name|generateInherits
argument_list|(
name|classe
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateInheritedBy
argument_list|(
name|classe
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|classe
operator|->
name|qmlElement
argument_list|()
operator|!=
literal|0
condition|)
name|generateInstantiatedBy
argument_list|(
name|classe
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
name|generateThreadSafeness
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|QString
name|membersLink
init|=
name|generateListOfAllMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|membersLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|membersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|QString
name|obsoleteLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obsoleteLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|obsoleteLink
operator|<<
literal|"\">"
operator|<<
literal|"Obsolete members</a></li>\n"
expr_stmt|;
name|QString
name|compatLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compatLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|compatLink
operator|<<
literal|"\">"
operator|<<
literal|"Compatibility members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|bool
name|needOtherSection
init|=
literal|false
decl_stmt|;
comment|/*       sections is built above for the call to generateTableOfContents().      */
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|needOtherSection
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|"\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|QString
argument_list|(
literal|"Reimplemented "
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|name
decl_stmt|;
comment|//  out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|"\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|s
operator|->
name|reimpMembers
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|needOtherSection
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h3>Additional Inherited Members</h3>\n"
literal|"<ul>\n"
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|!
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|inner
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
comment|//out()<< "<hr />\n"
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\">\n"
comment|// QTBUG-9504
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateBody
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateMaintainerList
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|inner
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|//out()<< "<hr />\n";
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<div class=\""
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|<<
literal|"\">\n"
expr_stmt|;
comment|// QTBUG-9504
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
comment|// ### check necessary?
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Class
condition|)
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<h3> class "
expr_stmt|;
name|generateFullName
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>"
expr_stmt|;
name|generateBrief
argument_list|(
operator|*
name|m
argument_list|,
name|marker
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
name|QStringList
name|names
decl_stmt|;
name|names
operator|<<
operator|(
operator|*
name|m
operator|)
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Ctor
operator|||
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
operator|||
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|names
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
specifier|const
name|PropertyNode
modifier|*
name|prop
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|names
operator|.
name|contains
argument_list|(
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
condition|)
name|names
operator|<<
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|setters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|setters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|resetters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|resetters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|notifiers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|notifiers
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|enume
operator|->
name|flagsType
argument_list|()
condition|)
name|names
operator|<<
name|enume
operator|->
name|flagsType
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|enumName
decl|,
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|enumItemNames
argument_list|()
operator|.
name|toSet
argument_list|()
operator|-
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|omitEnumItemNames
argument_list|()
operator|.
name|toSet
argument_list|()
control|)
name|names
operator|<<
name|plainCode
argument_list|(
name|marker
operator|->
name|markedUpEnumValue
argument_list|(
name|enumName
argument_list|,
name|enume
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   We delayed generation of the disambiguation pages until now, after   all the other pages have been generated. We do this because we might   encounter a link command that tries to link to a target on a QML   component page, but the link doesn't specify the module identifer   for the component, and the component name without a module   identifier is ambiguous. When such a link is found, qdoc can't find   the target, so it appends the target to the NameCollisionNode. After   the tree has been traversed and all these ambiguous links have been   added to the name collision nodes, this function is called. The list   of collision nodes is traversed here, and the disambiguation page for   each collision is generated. The disambiguation page will not only   disambiguate links to the component pages, but it will also disambiguate   links to properties, section headers, etc.  */
end_comment
begin_function
DECL|function|generateCollisionPages
name|void
name|HtmlGenerator
operator|::
name|generateCollisionPages
parameter_list|()
block|{
if|if
condition|(
name|collisionNodes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisionNodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
name|collisionNodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ncn
condition|)
continue|continue;
name|NodeList
name|collisions
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|nl
init|=
name|ncn
operator|->
name|childNodes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|it
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|->
name|isInternal
argument_list|()
condition|)
name|collisions
operator|.
name|append
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
if|if
condition|(
name|collisions
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
continue|continue;
name|ncn
operator|->
name|clearCurrentChild
argument_list|()
expr_stmt|;
name|beginSubPage
argument_list|(
name|ncn
argument_list|,
name|Generator
operator|::
name|fileName
argument_list|(
name|ncn
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|fullTitle
init|=
name|ncn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|QString
name|htmlTitle
init|=
name|fullTitle
decl_stmt|;
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|ncn
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
operator|->
name|isQmlNode
argument_list|()
condition|)
block|{
comment|// Replace the marker with a QML code marker.
if|if
condition|(
name|ncn
operator|->
name|isQmlNode
argument_list|()
condition|)
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generateHeader
argument_list|(
name|htmlTitle
argument_list|,
name|ncn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullTitle
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<h1 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
name|fullTitle
argument_list|)
operator|<<
literal|"</h1>\n"
expr_stmt|;
name|NodeMap
name|nm
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|t
operator|=
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
literal|"::"
expr_stmt|;
name|t
operator|+=
name|protectEnc
argument_list|(
name|fullTitle
argument_list|)
expr_stmt|;
name|nm
operator|.
name|insertMulti
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|ncn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QString
argument_list|>
name|targets
decl_stmt|;
if|if
condition|(
operator|!
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|ConstIterator
name|t
init|=
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|findChildNodeByName
argument_list|(
name|t
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|targets
operator|.
name|append
argument_list|(
name|t
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|++
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|targets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|t
init|=
name|targets
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|targets
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|*
name|t
argument_list|)
operator|<<
literal|"\"></a>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
operator|*
name|t
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|p
init|=
name|n
operator|->
name|findChildNodeByName
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QString
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|label
operator|=
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
literal|"::"
expr_stmt|;
name|label
operator|+=
name|n
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|p
operator|->
name|name
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|label
argument_list|)
operator|<<
literal|"</a>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
name|generateFooter
argument_list|(
name|ncn
argument_list|)
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate the HTML page for an entity that doesn't map   to any underlying parsable C++ class or QML component.  */
end_comment
begin_function
DECL|function|generateDocNode
name|void
name|HtmlGenerator
operator|::
name|generateDocNode
parameter_list|(
name|DocNode
modifier|*
name|dn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
comment|/*       If the document node is a page node, and if the page type       is DITA map page, write the node's contents as a dita       map and return without doing anything else.      */
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
operator|&&
name|dn
operator|->
name|pageType
argument_list|()
operator|==
name|Node
operator|::
name|DitaMapPage
condition|)
block|{
specifier|const
name|DitaMapNode
modifier|*
name|dmn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DitaMapNode
operator|*
argument_list|>
argument_list|(
name|dn
argument_list|)
decl_stmt|;
name|writeDitaMap
argument_list|(
name|dmn
argument_list|)
expr_stmt|;
return|return;
block|}
name|SubTitleSize
name|subTitleSize
init|=
name|LargeSubTitle
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|fullTitle
init|=
name|dn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|QString
name|htmlTitle
init|=
name|fullTitle
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
operator|&&
operator|!
name|dn
operator|->
name|subTitle
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|subTitleSize
operator|=
name|SmallSubTitle
expr_stmt|;
name|htmlTitle
operator|+=
literal|" ("
operator|+
name|dn
operator|->
name|subTitle
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
block|{
name|fullTitle
operator|=
literal|"QML Basic Type: "
operator|+
name|fullTitle
expr_stmt|;
name|htmlTitle
operator|=
name|fullTitle
expr_stmt|;
comment|// Replace the marker with a QML code marker.
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generateHeader
argument_list|(
name|htmlTitle
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|/*       Generate the TOC for the new doc format.       Don't generate a TOC for the home page.     */
name|QmlClassNode
modifier|*
name|qml_cn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|qml_cn
operator|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qml_cn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|generateTableOfContents
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
operator|&
name|sections
argument_list|)
expr_stmt|;
comment|// Replace the marker with a QML code marker.
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Collision
operator|&&
name|dn
operator|->
name|name
argument_list|()
operator|!=
name|QString
argument_list|(
literal|"index.html"
argument_list|)
condition|)
name|generateTableOfContents
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|fullTitle
argument_list|,
name|Text
argument_list|()
operator|<<
name|dn
operator|->
name|subTitle
argument_list|()
argument_list|,
name|subTitleSize
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
comment|// Generate brief text and status for modules.
name|generateBrief
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|NodeMap
name|nm
decl_stmt|;
name|dn
operator|->
name|getMemberNamespaces
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"namespaces"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>Namespaces</h2>\n"
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
name|nm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dn
operator|->
name|getMemberClasses
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"classes"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>Classes</h2>\n"
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
name|nm
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
condition|)
block|{
comment|// Generate brief text and status for modules.
name|generateBrief
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|QString
name|membersLink
init|=
name|generateListOfAllMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|membersLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|membersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|QString
name|obsoleteLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obsoleteLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|obsoleteLink
operator|<<
literal|"\">"
operator|<<
literal|"Obsolete members</a></li>\n"
expr_stmt|;
name|QString
name|compatLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compatLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|compatLink
operator|<<
literal|"\">"
operator|<<
literal|"Compatibility members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
cast|const_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|dn
argument_list|)
operator|->
name|setCurrentChild
argument_list|()
expr_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
name|qml_cn
operator|->
name|classNode
argument_list|()
decl_stmt|;
name|generateBrief
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlInherits
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlInheritedBy
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlInstantiates
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|QString
name|allQmlMembersLink
init|=
name|generateAllQmlMembersFile
argument_list|(
name|qml_cn
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allQmlMembersLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|allQmlMembersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateQmlSummary
argument_list|(
operator|*
name|s
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateBody
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
condition|)
name|generateQmlText
argument_list|(
name|cn
operator|->
name|doc
argument_list|()
operator|.
name|body
argument_list|()
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|,
name|dn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
comment|//out()<< "<hr />\n";
name|sections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qml_cn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|generateDetailedQmlMember
argument_list|(
operator|*
name|m
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>\n"
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|dn
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|dn
argument_list|)
operator|->
name|clearCurrentChild
argument_list|()
expr_stmt|;
return|return;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|dn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
operator|*
name|s
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|Text
name|brief
init|=
name|dn
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
operator|&&
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\">\n"
expr_stmt|;
comment|// QTBUG-9504
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
block|}
else|else
block|{
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\"><a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
comment|// QTBUG-9504
block|}
name|generateBody
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Group
operator|)
condition|)
name|generateAnnotatedList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|dn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlModule
condition|)
name|generateAnnotatedList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|dn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|dn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|//out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns "html" for this subclass of Generator.  */
end_comment
begin_function
DECL|function|fileExtension
name|QString
name|HtmlGenerator
operator|::
name|fileExtension
parameter_list|()
specifier|const
block|{
return|return
literal|"html"
return|;
block|}
end_function
begin_comment
comment|/*!   Output breadcrumb list in the html file.  */
end_comment
begin_function
DECL|function|generateBreadCrumbs
name|void
name|HtmlGenerator
operator|::
name|generateBreadCrumbs
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|noBreadCrumbs
condition|)
return|return;
name|Text
name|breadcrumbs
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|node
operator|->
name|moduleName
argument_list|()
decl_stmt|;
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"All Modules"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Modules"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|name
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|cn
operator|->
name|name
argument_list|()
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"All Modules"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Modules"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|name
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Group
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
operator|==
name|QString
argument_list|(
literal|"modules"
argument_list|)
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Modules"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
operator|==
name|QString
argument_list|(
literal|"qdeclarativeexamples.html"
argument_list|)
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"Qt Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|QLatin1String
argument_list|(
literal|"QML Examples& Demos"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"examples-"
argument_list|)
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"Qt Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|name
argument_list|()
operator|==
name|QString
argument_list|(
literal|"namespaces.html"
argument_list|)
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Namespaces"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|QLatin1String
argument_list|(
literal|"Basic QML Types"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"Qt Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Examples"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|QStringList
name|sl
init|=
name|fn
operator|->
name|name
argument_list|()
operator|.
name|split
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sl
operator|.
name|contains
argument_list|(
literal|"declarative"
argument_list|)
condition|)
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|QLatin1String
argument_list|(
literal|"QML Examples& Demos"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
else|else
block|{
name|QString
name|name
init|=
name|protectEnc
argument_list|(
literal|"examples-"
operator|+
name|sl
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|+
literal|".html"
argument_list|)
decl_stmt|;
comment|// this generates an empty link
name|QString
name|t
init|=
name|CodeParser
operator|::
name|titleFromName
argument_list|(
name|name
argument_list|)
decl_stmt|;
block|}
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|QLatin1String
argument_list|(
literal|"All Namespaces"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"Namespaces"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
name|breadcrumbs
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|protectEnc
argument_list|(
name|title
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
name|generateText
argument_list|(
name|breadcrumbs
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateHeader
name|void
name|HtmlGenerator
operator|::
name|generateHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<?xml version=\"1.0\" encoding=\"%1\"?>\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|outputEncoding
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"%1\" lang=\"%1\">\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|naturalLanguage
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<head>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n"
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<!-- "
operator|<<
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
operator|<<
literal|" -->\n"
expr_stmt|;
name|QString
name|shortVersion
init|=
name|qdb_
operator|->
name|version
argument_list|()
decl_stmt|;
if|if
condition|(
name|shortVersion
operator|.
name|count
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|==
literal|2
condition|)
name|shortVersion
operator|.
name|truncate
argument_list|(
name|shortVersion
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|shortVersion
operator|=
name|project
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|shortVersion
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
else|else
name|shortVersion
operator|=
name|QLatin1String
argument_list|(
literal|"Qt "
argument_list|)
operator|+
name|shortVersion
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
comment|// Generating page title
name|out
argument_list|()
operator|<<
literal|"<title>"
operator|<<
name|shortVersion
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
literal|"</title>\n"
expr_stmt|;
comment|// Include style sheet and script links.
name|out
argument_list|()
operator|<<
name|headerStyles
expr_stmt|;
name|out
argument_list|()
operator|<<
name|headerScripts
expr_stmt|;
if|if
condition|(
name|endHeader
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"</head>\n<body>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
name|endHeader
expr_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
if|if
condition|(
name|mainPage
condition|)
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|postHeader
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|generateBreadCrumbs
argument_list|(
name|title
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|postPostHeader
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|navigationLinks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|linkPair
decl_stmt|;
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|anchorPair
decl_stmt|;
specifier|const
name|Node
modifier|*
name|linkNode
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|PreviousLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|PreviousLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"prev\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
name|navigationLinks
operator|+=
literal|"<a class=\"prevPage\" href=\""
operator|+
name|anchorPair
operator|.
name|first
operator|+
literal|"\">"
expr_stmt|;
if|if
condition|(
name|linkPair
operator|.
name|first
operator|==
name|linkPair
operator|.
name|second
operator|&&
operator|!
name|anchorPair
operator|.
name|second
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|anchorPair
operator|.
name|second
argument_list|)
expr_stmt|;
else|else
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|linkPair
operator|.
name|second
argument_list|)
expr_stmt|;
name|navigationLinks
operator|+=
literal|"</a>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|NextLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|NextLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"next\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
name|navigationLinks
operator|+=
literal|"<a class=\"nextPage\" href=\""
operator|+
name|anchorPair
operator|.
name|first
operator|+
literal|"\">"
expr_stmt|;
if|if
condition|(
name|linkPair
operator|.
name|first
operator|==
name|linkPair
operator|.
name|second
operator|&&
operator|!
name|anchorPair
operator|.
name|second
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|anchorPair
operator|.
name|second
argument_list|)
expr_stmt|;
else|else
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|linkPair
operator|.
name|second
argument_list|)
expr_stmt|;
name|navigationLinks
operator|+=
literal|"</a>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|StartLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|StartLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"start\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"naviNextPrevious headerNavi\">\n"
operator|<<
name|navigationLinks
operator|<<
literal|"</p><p/>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateTitle
name|void
name|HtmlGenerator
operator|::
name|generateTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Text
modifier|&
name|subTitle
parameter_list|,
name|SubTitleSize
name|subTitleSize
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<h1 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
literal|"</h1>\n"
expr_stmt|;
if|if
condition|(
operator|!
name|subTitle
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<span"
expr_stmt|;
if|if
condition|(
name|subTitleSize
operator|==
name|SmallSubTitle
condition|)
name|out
argument_list|()
operator|<<
literal|" class=\"small-subtitle\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|" class=\"subtitle\">"
expr_stmt|;
name|generateText
argument_list|(
name|subTitle
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</span>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFooter
name|void
name|HtmlGenerator
operator|::
name|generateFooter
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"naviNextPrevious footerNavi\">\n"
operator|<<
name|navigationLinks
operator|<<
literal|"</p>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|footer
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
operator|<<
name|QString
argument_list|(
name|address
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</body>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</html>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateBrief
name|void
name|HtmlGenerator
operator|::
name|generateBrief
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|BriefMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relative
operator|||
name|node
operator|==
name|relative
condition|)
name|out
argument_list|()
operator|<<
literal|"<a href=\"#"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
operator|<<
literal|'#'
expr_stmt|;
name|out
argument_list|()
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">More...</a></p>\n"
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateIncludes
name|void
name|HtmlGenerator
operator|::
name|generateIncludes
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|marker
operator|->
name|markedUpIncludes
argument_list|(
name|inner
operator|->
name|includes
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
argument_list|)
operator|<<
literal|"</pre>"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Revised for the new doc format.   Generates a table of contents beginning at \a node.  */
end_comment
begin_function
DECL|function|generateTableOfContents
name|void
name|HtmlGenerator
operator|::
name|generateTableOfContents
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|QList
argument_list|<
name|Section
argument_list|>
modifier|*
name|sections
parameter_list|)
block|{
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|toc
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
name|toc
operator|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
expr_stmt|;
if|if
condition|(
name|toc
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|sections
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Module
operator|)
condition|)
return|return;
name|QStringList
name|sectionNumber
decl_stmt|;
name|int
name|detailsBase
init|=
literal|0
decl_stmt|;
comment|// disable nested links in table of contents
name|inContents_
operator|=
literal|true
expr_stmt|;
name|inLink_
operator|=
literal|true
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"toc\">\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h3><a name=\"toc\">Contents</a></h3>\n"
expr_stmt|;
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Module
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|hasNamespaces
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"namespaces"
argument_list|)
operator|<<
literal|"\">Namespaces</a></li>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|hasClasses
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"classes"
argument_list|)
operator|<<
literal|"\">Classes</a></li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</a></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sections
operator|&&
operator|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|)
operator|||
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|)
operator|||
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
operator|)
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|sections
operator|->
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|->
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|pluralMember
argument_list|)
operator|<<
literal|"\">"
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</a></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|atom
init|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|nextLevel
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|detailsBase
decl_stmt|;
if|if
condition|(
name|nextLevel
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
block|{
do|do
block|{
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|>
name|nextLevel
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|sectionNumber
operator|.
name|last
argument_list|()
operator|=
name|QString
operator|::
name|number
argument_list|(
name|sectionNumber
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numAtoms
decl_stmt|;
name|Text
name|headingText
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
decl_stmt|;
name|QString
name|s
init|=
name|headingText
operator|.
name|toString
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
literal|'#'
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|s
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|generateAtomList
argument_list|(
name|headingText
operator|.
name|firstAtom
argument_list|()
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|sectionNumber
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
name|inContents_
operator|=
literal|false
expr_stmt|;
name|inLink_
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateListOfAllMemberFile
name|QString
name|HtmlGenerator
operator|::
name|generateListOfAllMemberFile
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fileName
init|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-members."
operator|+
name|fileExtension
argument_list|()
decl_stmt|;
name|beginSubPage
argument_list|(
name|inner
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
literal|"List of All Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
decl_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>This is the complete list of members for "
expr_stmt|;
name|generateFullName
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|", including inherited members.</p>\n"
expr_stmt|;
name|Section
name|section
init|=
name|sections
operator|.
name|first
argument_list|()
decl_stmt|;
name|generateSectionList
argument_list|(
name|section
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|)
expr_stmt|;
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_comment
comment|/*!   This function creates an html page on which are listed all   the members of QML class \a qml_cn, including the inherited   members. The \a marker is used for formatting stuff.  */
end_comment
begin_function
DECL|function|generateAllQmlMembersFile
name|QString
name|HtmlGenerator
operator|::
name|generateAllQmlMembersFile
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qml_cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|sections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qml_cn
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fileName
init|=
name|fileBase
argument_list|(
name|qml_cn
argument_list|)
operator|+
literal|"-members."
operator|+
name|fileExtension
argument_list|()
decl_stmt|;
name|beginSubPage
argument_list|(
name|qml_cn
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
literal|"List of All Members for "
operator|+
name|qml_cn
operator|->
name|name
argument_list|()
decl_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>This is the complete list of members for "
expr_stmt|;
name|generateFullName
argument_list|(
name|qml_cn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|", including inherited members.</p>\n"
expr_stmt|;
name|Section
name|section
init|=
name|sections
operator|.
name|first
argument_list|()
decl_stmt|;
name|generateSectionList
argument_list|(
name|section
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|)
expr_stmt|;
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|generateLowStatusMemberFile
name|QString
name|HtmlGenerator
operator|::
name|generateLowStatusMemberFile
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|Status
name|status
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
init|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|status
argument_list|)
decl_stmt|;
name|QMutableListIterator
argument_list|<
name|Section
argument_list|>
name|j
argument_list|(
name|sections
argument_list|)
decl_stmt|;
while|while
condition|(
name|j
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|next
argument_list|()
operator|.
name|members
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|j
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|i
decl_stmt|;
name|QString
name|title
decl_stmt|;
name|QString
name|fileName
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Compat
condition|)
block|{
name|title
operator|=
literal|"Compatibility Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
expr_stmt|;
name|fileName
operator|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-compat."
operator|+
name|fileExtension
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|title
operator|=
literal|"Obsolete Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
expr_stmt|;
name|fileName
operator|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-obsolete."
operator|+
name|fileExtension
argument_list|()
expr_stmt|;
block|}
name|beginSubPage
argument_list|(
name|inner
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Compat
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>The following class members are part of the "
literal|"Qt compatibility layer.</b> We advise against "
literal|"using them in new code.</p>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>The following class members are obsolete.</b> "
operator|<<
literal|"They are provided to keep old source code working. "
operator|<<
literal|"We strongly advise against using them in new code.</p>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<p><ul><li><a href=\""
operator|<<
name|linkForNode
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
name|inner
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|" class reference</a></li></ul></p>\n"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sections
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sections
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|//out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
block|}
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|generateClassHierarchy
name|void
name|HtmlGenerator
operator|::
name|generateClassHierarchy
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|NodeMap
modifier|&
name|classMap
parameter_list|)
block|{
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|NodeMap
name|topLevel
decl_stmt|;
name|NodeMap
operator|::
name|Iterator
name|c
init|=
name|classMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|classe
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|topLevel
operator|.
name|insert
argument_list|(
name|classe
operator|->
name|name
argument_list|()
argument_list|,
name|classe
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|QStack
argument_list|<
name|NodeMap
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|topLevel
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
else|else
block|{
name|ClassNode
modifier|*
name|child
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|generateFullName
argument_list|(
name|child
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|stack
operator|.
name|top
argument_list|()
operator|.
name|erase
argument_list|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMap
name|newTop
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|d
decl|,
name|child
operator|->
name|derivedClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|d
operator|.
name|access
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|!
name|d
operator|.
name|node
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|newTop
operator|.
name|insert
argument_list|(
name|d
operator|.
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|d
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newTop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|newTop
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Output an annotated list of the nodes in \a nodeMap.   A two-column table is output.  */
end_comment
begin_function
DECL|function|generateAnnotatedList
name|void
name|HtmlGenerator
operator|::
name|generateAnnotatedList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|nodeMap
parameter_list|)
block|{
if|if
condition|(
name|nodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|NodeList
name|nl
decl_stmt|;
name|NodeMap
operator|::
name|const_iterator
name|i
init|=
name|nodeMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|nodeMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|nl
operator|.
name|append
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateAnnotatedList
name|void
name|HtmlGenerator
operator|::
name|generateAnnotatedList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|nodes
parameter_list|)
block|{
name|bool
name|allInternal
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|nodes
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isInternal
argument_list|()
operator|&&
name|node
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|allInternal
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allInternal
condition|)
return|return;
name|out
argument_list|()
operator|<<
literal|"<table class=\"annotated\">\n"
expr_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|->
name|isInternal
argument_list|()
operator|||
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
continue|continue;
if|if
condition|(
operator|++
name|row
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr class=\"odd topAlign\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr class=\"even topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblName\"><p>"
expr_stmt|;
name|generateFullName
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
condition|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|trimmedBriefText
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblDescr\"><p>"
expr_stmt|;
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblDescr\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</tr>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function finds the common prefix of the names of all   the classes in \a classMap and then generates a compact   list of the class names alphabetized on the part of the   name not including the common prefix. You can tell the   function to use \a comonPrefix as the common prefix, but   normally you let it figure it out itself by looking at   the name of the first and last classes in \a classMap.  */
end_comment
begin_function
DECL|function|generateCompactList
name|void
name|HtmlGenerator
operator|::
name|generateCompactList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|classMap
parameter_list|,
name|bool
name|includeAlphabet
parameter_list|,
name|QString
name|commonPrefix
parameter_list|)
block|{
specifier|const
name|int
name|NumParagraphs
init|=
literal|37
decl_stmt|;
comment|// '0' to '9', 'A' to 'Z', '_'
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|/*       If commonPrefix is not empty, then the caller knows what       the common prefix is and has passed it in, so just use that       one. But if the commonPrefix is empty (it normally is), then       compute a common prefix using this simple algorithm. Note we       assume the prefix length is 1, i.e. we will have a single       character as the common prefix.      */
name|int
name|commonPrefixLen
init|=
name|commonPrefix
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|commonPrefixLen
operator|==
literal|0
condition|)
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|count
argument_list|(
literal|26
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|NodeMap
operator|::
name|const_iterator
name|iter
init|=
name|classMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|!=
name|classMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|iter
operator|.
name|key
argument_list|()
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|QChar
name|c
init|=
name|iter
operator|.
name|key
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|int
name|idx
init|=
name|c
operator|.
name|unicode
argument_list|()
operator|-
name|QChar
argument_list|(
literal|'A'
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
operator|++
name|count
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
operator|++
name|iter
expr_stmt|;
block|}
name|int
name|highest
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|count
index|[
name|i
index|]
operator|>
name|highest
condition|)
block|{
name|highest
operator|=
name|count
index|[
name|i
index|]
expr_stmt|;
name|idx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|idx
operator|+=
name|QChar
argument_list|(
literal|'A'
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|QChar
name|common
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|commonPrefix
operator|=
name|common
expr_stmt|;
name|commonPrefixLen
operator|=
literal|1
expr_stmt|;
block|}
comment|/*       Divide the data into 37 paragraphs: 0, ..., 9, A, ..., Z,       underscore (_). QAccel will fall in paragraph 10 (A) and       QXtWidget in paragraph 33 (X). This is the only place where we       assume that NumParagraphs is 37. Each paragraph is a NodeMap.     */
name|NodeMap
name|paragraph
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QString
name|paragraphName
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QSet
argument_list|<
name|char
argument_list|>
name|usedParagraphNames
decl_stmt|;
name|NodeMap
operator|::
name|ConstIterator
name|c
init|=
name|classMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QStringList
name|pieces
init|=
name|c
operator|.
name|key
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|int
name|idx
init|=
name|commonPrefixLen
decl_stmt|;
if|if
condition|(
operator|!
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|startsWith
argument_list|(
name|commonPrefix
argument_list|)
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|mid
argument_list|(
name|idx
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
else|else
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|int
name|paragraphNr
init|=
name|NumParagraphs
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|paragraphNr
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|key
index|[
literal|0
index|]
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|paragraphNr
operator|=
literal|10
operator|+
name|key
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|-
literal|'a'
expr_stmt|;
block|}
name|paragraphName
index|[
name|paragraphNr
index|]
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|usedParagraphNames
operator|.
name|insert
argument_list|(
name|key
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|paragraph
index|[
name|paragraphNr
index|]
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|c
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
comment|/*       Each paragraph j has a size: paragraph[j].count(). In the       discussion, we will assume paragraphs 0 to 5 will have sizes       3, 1, 4, 1, 5, 9.        We now want to compute the paragraph offset. Paragraphs 0 to 6       start at offsets 0, 3, 4, 8, 9, 14, 23.     */
name|int
name|paragraphOffset
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
comment|// 37 + 1
name|paragraphOffset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumParagraphs
condition|;
name|i
operator|++
control|)
comment|// i = 0..36
name|paragraphOffset
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|paragraphOffset
index|[
name|i
index|]
operator|+
name|paragraph
index|[
name|i
index|]
operator|.
name|count
argument_list|()
expr_stmt|;
comment|/*       Output the alphabet as a row of links.      */
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p  class=\"centerAlign functionIndex\"><b>"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|usedParagraphNames
operator|.
name|contains
argument_list|(
name|char
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
argument_list|)
condition|)
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a href=\"#%1\">%2</a>&nbsp;"
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</b></p>\n"
expr_stmt|;
block|}
comment|/*       Output a<div> element to contain all the<dl> elements.      */
name|out
argument_list|()
operator|<<
literal|"<div class=\"flowListDiv\">\n"
expr_stmt|;
name|numTableRows_
operator|=
literal|0
expr_stmt|;
name|int
name|curParNr
init|=
literal|0
decl_stmt|;
name|int
name|curParOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classMap
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|(
name|curParOffset
operator|==
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|count
argument_list|()
operator|)
condition|)
block|{
operator|++
name|curParNr
expr_stmt|;
name|curParOffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*           Starting a new paragraph means starting a new<dl>.         */
if|if
condition|(
name|curParOffset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<dl class=\"flowList odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<dl class=\"flowList even\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<dt class=\"alphaChar\">"
expr_stmt|;
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|QChar
name|c
init|=
name|paragraphName
index|[
name|curParNr
index|]
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a name=\"%1\"></a>"
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<b>"
operator|<<
name|paragraphName
index|[
name|curParNr
index|]
operator|<<
literal|"</b>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</dt>\n"
expr_stmt|;
block|}
comment|/*           Output a<dd> for the current offset in the current paragraph.          */
name|out
argument_list|()
operator|<<
literal|"<dd>"
expr_stmt|;
if|if
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|!
name|paragraphName
index|[
name|curParNr
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
operator|::
name|Iterator
name|it
decl_stmt|;
name|it
operator|=
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|curParOffset
condition|;
name|i
operator|++
control|)
operator|++
name|it
expr_stmt|;
comment|/*               Previously, we used generateFullName() for this, but we               require some special formatting.             */
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|QStringList
name|pieces
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|pieces
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
else|else
name|pieces
operator|=
name|it
operator|.
name|value
argument_list|()
operator|->
name|fullName
argument_list|(
name|relative
argument_list|)
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|" ("
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|')'
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</dd>\n"
expr_stmt|;
name|curParOffset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|classMap
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateFunctionIndex
name|void
name|HtmlGenerator
operator|::
name|generateFunctionIndex
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p  class=\"centerAlign functionIndex\"><b>"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a href=\"#%1\">%2</a>&nbsp;"
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</b></p>\n"
expr_stmt|;
name|char
name|nextLetter
init|=
literal|'a'
decl_stmt|;
name|char
name|currentLetter
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|NodeMapMap
name|funcIndex
init|=
name|qdb_
operator|->
name|getFunctionIndex
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|NodeMap
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|funcIndex
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|funcIndex
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|f
operator|.
name|key
argument_list|()
argument_list|)
operator|<<
literal|':'
expr_stmt|;
name|currentLetter
operator|=
name|f
operator|.
name|key
argument_list|()
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
while|while
condition|(
name|islower
argument_list|(
name|currentLetter
argument_list|)
operator|&&
name|currentLetter
operator|>=
name|nextLetter
condition|)
block|{
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a name=\"%1\"></a>"
argument_list|)
operator|.
name|arg
argument_list|(
name|nextLetter
argument_list|)
expr_stmt|;
name|nextLetter
operator|++
expr_stmt|;
block|}
name|NodeMap
operator|::
name|ConstIterator
name|s
init|=
operator|(
operator|*
name|f
operator|)
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
operator|*
name|f
operator|)
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|generateFullName
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|'\n'
expr_stmt|;
operator|++
name|f
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateLegaleseList
name|void
name|HtmlGenerator
operator|::
name|generateLegaleseList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|TextToNodeMap
modifier|&
name|legaleseTexts
init|=
name|qdb_
operator|->
name|getLegaleseTexts
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|Text
argument_list|,
specifier|const
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|legaleseTexts
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Text
name|text
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
comment|//out()<< "<hr />\n";
name|generateText
argument_list|(
name|text
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
do|do
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
do|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|text
condition|)
do|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateQmlItem
name|void
name|HtmlGenerator
operator|::
name|generateQmlItem
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|bool
name|summary
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpQmlItem
argument_list|(
name|node
argument_list|,
name|summary
argument_list|)
decl_stmt|;
name|QRegExp
name|templateTag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|templateTag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|contents
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i>\\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@param>"
argument_list|,
literal|"<i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@param>"
argument_list|,
literal|"</i>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
name|marked
operator|.
name|replace
argument_list|(
literal|"@name>"
argument_list|,
literal|"b>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@extra>"
argument_list|,
literal|"<tt>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@extra>"
argument_list|,
literal|"</tt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|highlightedCode
argument_list|(
name|marked
argument_list|,
name|relative
argument_list|,
literal|false
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateOverviewList
name|void
name|HtmlGenerator
operator|::
name|generateOverviewList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QMap
argument_list|<
specifier|const
name|DocNode
modifier|*
argument_list|,
name|QMap
argument_list|<
name|QString
argument_list|,
name|DocNode
modifier|*
argument_list|>
argument_list|>
name|docNodeMap
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
specifier|const
name|DocNode
modifier|*
argument_list|>
name|groupTitlesMap
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|DocNode
modifier|*
argument_list|>
name|uncategorizedNodeMap
decl_stmt|;
name|QRegExp
name|singleDigit
argument_list|(
literal|"\\b([0-9])\\b"
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
name|children
init|=
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|childNodes
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|children
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|child
operator|!=
name|relative
condition|)
block|{
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
comment|// Check whether the page is part of a group or is the group
comment|// definition page.
name|QString
name|group
decl_stmt|;
name|bool
name|isGroupPage
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|docNode
operator|->
name|doc
argument_list|()
operator|.
name|metaCommandsUsed
argument_list|()
operator|.
name|contains
argument_list|(
literal|"group"
argument_list|)
condition|)
block|{
name|group
operator|=
name|docNode
operator|->
name|doc
argument_list|()
operator|.
name|metaCommandArgs
argument_list|(
literal|"group"
argument_list|)
index|[
literal|0
index|]
operator|.
name|first
expr_stmt|;
name|isGroupPage
operator|=
literal|true
expr_stmt|;
block|}
comment|// there are too many examples; they would clutter the list
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Example
condition|)
continue|continue;
comment|// not interested either in individual (Qt Designer etc.) manual chapters
if|if
condition|(
name|docNode
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|ContentsLink
argument_list|)
condition|)
continue|continue;
comment|// Discard external nodes.
if|if
condition|(
name|docNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
continue|continue;
name|QString
name|sortKey
init|=
name|docNode
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|isGroupPage
condition|)
block|{
comment|// If we encounter a group definition page, we add all
comment|// the pages in that group to the list for that group.
foreach|foreach
control|(
name|Node
modifier|*
name|member
decl|,
name|docNode
operator|->
name|members
argument_list|()
control|)
block|{
if|if
condition|(
name|member
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Document
condition|)
continue|continue;
name|DocNode
modifier|*
name|page
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
condition|)
block|{
name|QString
name|sortKey
init|=
name|page
operator|->
name|fullTitle
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortKey
operator|.
name|startsWith
argument_list|(
literal|"the "
argument_list|)
condition|)
name|sortKey
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sortKey
operator|.
name|replace
argument_list|(
name|singleDigit
argument_list|,
literal|"0\\1"
argument_list|)
expr_stmt|;
name|docNodeMap
index|[
cast|const_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|docNode
argument_list|)
index|]
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|groupTitlesMap
index|[
name|docNode
operator|->
name|fullTitle
argument_list|()
index|]
operator|=
cast|const_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|docNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isGroupPage
condition|)
block|{
comment|// If we encounter a page that belongs to a group then
comment|// we add that page to the list for that group.
specifier|const
name|DocNode
modifier|*
name|gn
init|=
name|qdb_
operator|->
name|getGroup
argument_list|(
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|gn
condition|)
name|docNodeMap
index|[
name|gn
index|]
operator|.
name|insert
argument_list|(
name|sortKey
argument_list|,
name|docNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// We now list all the pages found that belong to groups.
comment|// If only certain pages were found for a group, but the definition page
comment|// for that group wasn't listed, the list of pages will be intentionally
comment|// incomplete. However, if the group definition page was listed, all the
comment|// pages in that group are listed for completeness.
if|if
condition|(
operator|!
name|docNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|groupTitle
decl|,
name|groupTitlesMap
operator|.
name|keys
argument_list|()
control|)
block|{
specifier|const
name|DocNode
modifier|*
name|groupNode
init|=
name|groupTitlesMap
index|[
name|groupTitle
index|]
decl_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<h3><a href=\"%1\">%2</a></h3>\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkForNode
argument_list|(
name|groupNode
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|protectEnc
argument_list|(
name|groupNode
operator|->
name|fullTitle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|docNodeMap
index|[
name|groupNode
index|]
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|DocNode
modifier|*
name|docNode
decl|,
name|docNodeMap
index|[
name|groupNode
index|]
control|)
block|{
name|QString
name|title
init|=
name|docNode
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|startsWith
argument_list|(
literal|"The "
argument_list|)
condition|)
name|title
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|linkForNode
argument_list|(
name|docNode
argument_list|,
name|relative
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|uncategorizedNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<h3>Miscellaneous</h3>\n"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|DocNode
modifier|*
name|docNode
decl|,
name|uncategorizedNodeMap
control|)
block|{
name|QString
name|title
init|=
name|docNode
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|startsWith
argument_list|(
literal|"The "
argument_list|)
condition|)
name|title
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|linkForNode
argument_list|(
name|docNode
argument_list|,
name|relative
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateSection
name|void
name|HtmlGenerator
operator|::
name|generateSection
parameter_list|(
specifier|const
name|NodeList
modifier|&
name|nl
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|bool
name|alignNames
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|nl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|twoColumn
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|alignNames
operator|=
literal|false
expr_stmt|;
name|twoColumn
operator|=
operator|(
name|nl
operator|.
name|count
argument_list|()
operator|>=
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nl
operator|.
name|first
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|twoColumn
operator|=
operator|(
name|nl
operator|.
name|count
argument_list|()
operator|>=
literal|5
operator|)
expr_stmt|;
name|alignNames
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"<table class=\"propsummary\">\n"
operator|<<
literal|"<tr><td class=\"topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
operator|++
name|m
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"memItemLeft rightAlign topAlign\"> "
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
operator|&&
name|i
operator|==
call|(
name|int
call|)
argument_list|(
name|nl
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
operator|/
literal|2
condition|)
name|out
argument_list|()
operator|<<
literal|"</ul></td><td class=\"topAlign\"><ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
block|}
name|generateSynopsis
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|style
argument_list|,
name|alignNames
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n</table>\n"
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateSectionList
name|void
name|HtmlGenerator
operator|::
name|generateSectionList
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|bool
name|alignNames
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|twoColumn
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|alignNames
operator|=
literal|false
expr_stmt|;
name|twoColumn
operator|=
operator|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|>=
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|.
name|members
operator|.
name|first
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|twoColumn
operator|=
operator|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|>=
literal|5
operator|)
expr_stmt|;
name|alignNames
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"<table class=\"propsummary\">\n"
operator|<<
literal|"<tr><td class=\"topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|section
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|section
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
operator|++
name|m
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"memItemLeft topAlign rightAlign\"> "
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
operator|&&
name|i
operator|==
call|(
name|int
call|)
argument_list|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
operator|/
literal|2
condition|)
name|out
argument_list|()
operator|<<
literal|"</ul></td><td class=\"topAlign\"><ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
block|}
name|QString
name|prefix
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|section
operator|.
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|prefix
operator|.
name|left
argument_list|(
name|section
operator|.
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"::"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|generateSynopsis
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|style
argument_list|,
name|alignNames
argument_list|,
operator|&
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n</table>\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Summary
operator|&&
operator|!
name|section
operator|.
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
name|section
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateSectionInheritedList
name|void
name|HtmlGenerator
operator|::
name|generateSectionInheritedList
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QList
argument_list|<
name|QPair
argument_list|<
name|InnerNode
modifier|*
argument_list|,
name|int
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|section
operator|.
name|inherited
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|section
operator|.
name|inherited
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|second
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|second
operator|==
literal|1
condition|)
block|{
name|out
argument_list|()
operator|<<
name|section
operator|.
name|singularMember
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|section
operator|.
name|pluralMember
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|" inherited from<a href=\""
operator|<<
name|fileName
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
argument_list|)
operator|<<
literal|'#'
operator|<<
name|HtmlGenerator
operator|::
name|cleanRef
argument_list|(
name|section
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
operator|->
name|plainFullName
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</a></li>\n"
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateSynopsis
name|void
name|HtmlGenerator
operator|::
name|generateSynopsis
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|,
name|bool
name|alignNames
parameter_list|,
specifier|const
name|QString
modifier|*
name|prefix
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpSynopsis
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
name|marked
operator|.
name|prepend
argument_list|(
operator|*
name|prefix
argument_list|)
expr_stmt|;
name|QRegExp
name|templateTag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|templateTag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|contents
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i>\\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@param>"
argument_list|,
literal|"<i> "
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@param>"
argument_list|,
literal|"</i>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@name>"
argument_list|)
expr_stmt|;
comment|// was "<b>"
name|marked
operator|.
name|remove
argument_list|(
literal|"</@name>"
argument_list|)
expr_stmt|;
comment|// was "</b>"
block|}
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|QRegExp
name|extraRegExp
argument_list|(
literal|"<@extra>.*</@extra>"
argument_list|)
decl_stmt|;
name|extraRegExp
operator|.
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
name|extraRegExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|marked
operator|.
name|replace
argument_list|(
literal|"<@extra>"
argument_list|,
literal|"<tt>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@extra>"
argument_list|,
literal|"</tt>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|!=
name|CodeMarker
operator|::
name|Detailed
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|highlightedCode
argument_list|(
name|marked
argument_list|,
name|relative
argument_list|,
name|alignNames
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|highlightedCode
name|QString
name|HtmlGenerator
operator|::
name|highlightedCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|bool
name|alignNames
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|)
block|{
name|QString
name|src
init|=
name|markedCode
decl_stmt|;
name|QString
name|html
decl_stmt|;
name|QStringRef
name|arg
decl_stmt|;
name|QStringRef
name|par1
decl_stmt|;
specifier|const
name|QChar
name|charLangle
init|=
literal|'<'
decl_stmt|;
specifier|const
name|QChar
name|charAt
init|=
literal|'@'
decl_stmt|;
specifier|static
specifier|const
name|QString
name|typeTag
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|headerTag
argument_list|(
literal|"headerfile"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|funcTag
argument_list|(
literal|"func"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|linkTag
argument_list|(
literal|"link"
argument_list|)
decl_stmt|;
comment|// replace all<@link> tags: "(<@link node=\"([^\"]+)\">).*(</@link>)"
name|bool
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
if|if
condition|(
name|alignNames
operator|&&
operator|!
name|done
condition|)
block|{
name|html
operator|+=
literal|"</td><td class=\"memItemRight bottomAlign\">"
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|linkTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|html
operator|+=
literal|"<b>"
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|par1
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|html
operator|+=
literal|"</b>"
expr_stmt|;
block|}
else|else
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all<@func> tags: "(<@func target=\"([^\"]*)\">)(.*)(</@func>)"
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|funcTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|par1
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all "(<@(type|headerfile|func)(?: +[^>]*)?>)(.*)(</@\\2>)" tags
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|bool
name|handled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|typeTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|,
name|self
argument_list|)
decl_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<span class=\"type\">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|arg
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</span>"
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|headerTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|funcTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all
comment|// "<@comment>" -> "<span class=\"comment\">";
comment|// "<@preprocessor>" -> "<span class=\"preprocessor\">";
comment|// "<@string>" -> "<span class=\"string\">";
comment|// "<@char>" -> "<span class=\"char\">";
comment|// "<@number>" -> "<span class=\"number\">";
comment|// "<@op>" -> "<span class=\"operator\">";
comment|// "<@type>" -> "<span class=\"type\">";
comment|// "<@name>" -> "<span class=\"name\">";
comment|// "<@keyword>" -> "<span class=\"keyword\">";
comment|// "</@(?:comment|preprocessor|string|char|number|op|type|name|keyword)>" -> "</span>"
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
specifier|static
specifier|const
name|QString
name|spanTags
index|[]
init|=
block|{
literal|"<@comment>"
block|,
literal|"<span class=\"comment\">"
block|,
literal|"<@preprocessor>"
block|,
literal|"<span class=\"preprocessor\">"
block|,
literal|"<@string>"
block|,
literal|"<span class=\"string\">"
block|,
literal|"<@char>"
block|,
literal|"<span class=\"char\">"
block|,
literal|"<@number>"
block|,
literal|"<span class=\"number\">"
block|,
literal|"<@op>"
block|,
literal|"<span class=\"operator\">"
block|,
literal|"<@type>"
block|,
literal|"<span class=\"type\">"
block|,
literal|"<@name>"
block|,
literal|"<span class=\"name\">"
block|,
literal|"<@keyword>"
block|,
literal|"<span class=\"keyword\">"
block|,
literal|"</@comment>"
block|,
literal|"</span>"
block|,
literal|"</@preprocessor>"
block|,
literal|"</span>"
block|,
literal|"</@string>"
block|,
literal|"</span>"
block|,
literal|"</@char>"
block|,
literal|"</span>"
block|,
literal|"</@number>"
block|,
literal|"</span>"
block|,
literal|"</@op>"
block|,
literal|"</span>"
block|,
literal|"</@type>"
block|,
literal|"</span>"
block|,
literal|"</@name>"
block|,
literal|"</span>"
block|,
literal|"</@keyword>"
block|,
literal|"</span>"
block|,     }
decl_stmt|;
comment|// Update the upper bound of k in the following code to match the length
comment|// of the above array.
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
condition|)
block|{
name|bool
name|handled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|!=
literal|18
condition|;
operator|++
name|k
control|)
block|{
specifier|const
name|QString
modifier|&
name|tag
init|=
name|spanTags
index|[
literal|2
operator|*
name|k
index|]
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|html
operator|+=
name|spanTags
index|[
literal|2
operator|*
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charAt
operator|||
operator|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
operator|)
condition|)
block|{
comment|// drop 'our' unknown tags (the ones still containing '@')
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// retain all others
name|html
operator|+=
name|charLangle
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|html
return|;
block|}
end_function
begin_function
DECL|function|generateLink
name|void
name|HtmlGenerator
operator|::
name|generateLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|static
name|QRegExp
name|camelCase
argument_list|(
literal|"[A-Z][A-Z][a-z]|[a-z][A-Z0-9]|_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcLeftParen
operator|.
name|indexIn
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|marker
operator|->
name|recognizeLanguage
argument_list|(
literal|"Cpp"
argument_list|)
condition|)
block|{
comment|// hack for C++: move () outside of link
name|int
name|k
init|=
name|funcLeftParen
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|left
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"</i>"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
name|inLink_
operator|=
literal|false
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanRef
name|QString
name|HtmlGenerator
operator|::
name|cleanRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clean
return|;
name|clean
operator|.
name|reserve
argument_list|(
name|ref
operator|.
name|size
argument_list|()
operator|+
literal|20
argument_list|)
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'~'
condition|)
block|{
name|clean
operator|+=
literal|"dtor."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'_'
condition|)
block|{
name|clean
operator|+=
literal|"underscore."
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ref
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
name|u
operator|==
literal|'-'
operator|||
name|u
operator|==
literal|'_'
operator|||
name|u
operator|==
literal|':'
operator|||
name|u
operator|==
literal|'.'
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'!'
condition|)
block|{
name|clean
operator|+=
literal|"-not"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'&'
condition|)
block|{
name|clean
operator|+=
literal|"-and"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'<'
condition|)
block|{
name|clean
operator|+=
literal|"-lt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'='
condition|)
block|{
name|clean
operator|+=
literal|"-eq"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'>'
condition|)
block|{
name|clean
operator|+=
literal|"-gt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'#'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|clean
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|registerRef
name|QString
name|HtmlGenerator
operator|::
name|registerRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
init|=
name|HtmlGenerator
operator|::
name|cleanRef
argument_list|(
name|ref
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QString
modifier|&
name|prevRef
init|=
name|refMap
index|[
name|clean
operator|.
name|toLower
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|prevRef
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prevRef
operator|=
name|ref
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|prevRef
operator|==
name|ref
condition|)
block|{
break|break;
block|}
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
block|}
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|protectEnc
name|QString
name|HtmlGenerator
operator|::
name|protectEnc
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
return|return
name|protect
argument_list|(
name|string
argument_list|,
name|outputEncoding
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|protect
name|QString
name|HtmlGenerator
operator|::
name|protect
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|outputEncoding
parameter_list|)
block|{
DECL|macro|APPEND
define|#
directive|define
name|APPEND
parameter_list|(
name|x
parameter_list|)
define|\
value|if (html.isEmpty()) { \     html = string; \     html.truncate(i); \ } \     html += (x);
name|QString
name|html
decl_stmt|;
name|int
name|n
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outputEncoding
operator|==
literal|"ISO-8859-1"
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|>
literal|0x007F
operator|)
operator|||
operator|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|n
operator|&&
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|||
operator|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|i
operator|>
literal|2
operator|&&
name|string
operator|.
name|at
argument_list|(
name|i
operator|-
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
block|{
comment|// we escape '*/' and the last dot in 'e.g.' and 'i.e.' for the Javadoc generator
name|APPEND
argument_list|(
literal|"&#x"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|html
operator|.
name|isEmpty
argument_list|()
condition|)
name|html
operator|+=
name|ch
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|html
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|html
return|;
return|return
name|string
return|;
DECL|macro|APPEND
undef|#
directive|undef
name|APPEND
block|}
end_function
begin_function
DECL|function|fileBase
name|QString
name|HtmlGenerator
operator|::
name|fileBase
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
name|result
operator|=
name|Generator
operator|::
name|fileBase
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Compat
case|:
name|result
operator|+=
literal|"-compat"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|result
operator|+=
literal|"-obsolete"
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|HtmlGenerator
operator|::
name|fileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
block|}
return|return
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|refForNode
name|QString
name|HtmlGenerator
operator|::
name|refForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
decl_stmt|;
specifier|const
name|TypedefNode
modifier|*
name|typedeffe
decl_stmt|;
name|QString
name|ref
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
default|default:
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|typedeffe
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|typedeffe
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
return|return
name|refForNode
argument_list|(
name|typedeffe
operator|->
name|associatedEnum
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-typedef"
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
return|return
name|refForNode
argument_list|(
name|func
operator|->
name|associatedProperty
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|ref
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Document
case|:
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
condition|)
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|Property
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-prop"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal-handler"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ref
operator|=
name|func
operator|->
name|name
argument_list|()
operator|+
literal|"-method"
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|ref
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-var"
expr_stmt|;
break|break;
block|}
return|return
name|registerRef
argument_list|(
name|ref
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|DEBUG_ABSTRACT
define|#
directive|define
name|DEBUG_ABSTRACT
value|0
end_define
begin_comment
comment|/*!   Construct the link string for the \a node and return it.   The \a relative node is use to decide the link we are   generating is in the same file as the target. Note the   relative node can be 0, which pretty much guarantees   that the link and the target aren't in the same file.   */
end_comment
begin_function
DECL|function|linkForNode
name|QString
name|HtmlGenerator
operator|::
name|linkForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
name|node
operator|==
name|relative
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
if|if
condition|(
name|fileBase
argument_list|(
name|node
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fn
init|=
name|fileName
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
name|node
operator|->
name|parent
argument_list|()
operator|!=
name|relative
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|&&
name|relative
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isAbstract
argument_list|()
condition|)
block|{
comment|/*                   This is a bit of a hack. What we discover with                   the three 'if' statements immediately above,                   is that node's parent is marked \qmlabstract                   but the link appears in a qdoc comment for a                   subclass of the node's parent. This means the                   link should refer to the file for the relative                   node, not the file for node.                  */
name|fn
operator|=
name|fileName
argument_list|(
name|relative
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QString
name|link
init|=
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
operator|||
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QString
name|ref
init|=
name|refForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|relative
operator|&&
name|fn
operator|==
name|fileName
argument_list|(
name|relative
argument_list|)
operator|&&
name|ref
operator|==
name|refForNode
argument_list|(
name|relative
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|link
operator|+=
name|ref
expr_stmt|;
block|}
comment|/*       If the output is going to subdirectories, then if the       two nodes will be output to different directories, then       the link must go up to the parent directory and then       back down into the other subdirectory.      */
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
operator|(
name|node
operator|!=
name|relative
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|!=
name|relative
operator|->
name|outputSubdirectory
argument_list|()
condition|)
name|link
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
literal|"../"
operator|+
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function
begin_function
DECL|function|generateFullName
name|void
name|HtmlGenerator
operator|::
name|generateFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|apparentNode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
name|actualNode
parameter_list|)
block|{
if|if
condition|(
name|actualNode
operator|==
literal|0
condition|)
name|actualNode
operator|=
name|apparentNode
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|actualNode
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
literal|true
operator|||
name|relative
operator|==
literal|0
operator|||
name|relative
operator|->
name|status
argument_list|()
operator|!=
name|actualNode
operator|->
name|status
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|actualNode
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
name|out
argument_list|()
operator|<<
literal|"\" class=\"obsolete"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
name|out
argument_list|()
operator|<<
literal|"\" class=\"compat"
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|apparentNode
operator|->
name|fullName
argument_list|(
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateDetailedMember
name|void
name|HtmlGenerator
operator|::
name|generateDetailedMember
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|MemberMark
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
operator|&&
operator|(
name|enume
operator|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|)
operator|->
name|flagsType
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
argument_list|()
operator|<<
literal|"<h3 class=\"flags\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|node
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|enume
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<h3 class=\"fn\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|node
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
block|}
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
specifier|const
name|PropertyNode
modifier|*
name|property
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|Section
name|section
decl_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|getters
argument_list|()
expr_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|setters
argument_list|()
expr_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|resetters
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>Access functions:</b></p>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
name|section
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Accessors
argument_list|)
expr_stmt|;
block|}
name|Section
name|notifiers
decl_stmt|;
name|notifiers
operator|.
name|members
operator|+=
name|property
operator|->
name|notifiers
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|notifiers
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>Notifier signal:</b></p>\n"
expr_stmt|;
comment|//out()<< "<p>This signal is emitted when the property value is changed.</p>\n";
name|generateSectionList
argument_list|(
name|notifiers
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Accessors
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|enume
operator|->
name|flagsType
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p>The "
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|" type is a typedef for "
operator|<<
literal|"<a href=\"qflags.html\">QFlags</a>&lt;"
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"&gt;. It stores an OR combination of "
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|" values.</p>\n"
expr_stmt|;
block|}
block|}
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hOffset
name|int
name|HtmlGenerator
operator|::
name|hOffset
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
return|return
literal|2
return|;
case|case
name|Node
operator|::
name|Document
case|:
return|return
literal|1
return|;
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
default|default:
return|return
literal|3
return|;
block|}
block|}
end_function
begin_function
DECL|function|isThreeColumnEnumValueTable
name|bool
name|HtmlGenerator
operator|::
name|isThreeColumnEnumValueTable
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListRight
operator|&&
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
operator|)
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListItemLeft
operator|&&
operator|!
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ListItemRight
argument_list|)
condition|)
return|return
literal|true
return|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|anchorForNode
specifier|const
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|HtmlGenerator
operator|::
name|anchorForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|anchorPair
decl_stmt|;
name|anchorPair
operator|.
name|first
operator|=
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|anchorPair
operator|.
name|second
operator|=
name|docNode
operator|->
name|title
argument_list|()
expr_stmt|;
block|}
return|return
name|anchorPair
return|;
block|}
end_function
begin_function
DECL|function|getLink
name|QString
name|HtmlGenerator
operator|::
name|getLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|link
decl_stmt|;
operator|*
name|node
operator|=
literal|0
expr_stmt|;
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"http:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"https:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"ftp:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"mailto:"
argument_list|)
operator|)
condition|)
block|{
name|link
operator|=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|path
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
name|path
operator|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|append
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|ref
decl_stmt|;
name|QString
name|first
init|=
name|path
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|node
operator|=
name|relative
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
comment|/*               This is not a recursive search. That's ok in               this case, because we are searching for a page               node, which must be a direct child of the tree               root.             */
operator|*
name|node
operator|=
name|qdb_
operator|->
name|treeRoot
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|first
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findUnambiguousTarget
argument_list|(
name|first
argument_list|,
name|ref
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|node
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
return|;
block|}
else|else
block|{
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|node
operator|=
name|relative
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|node
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|node
operator|)
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
name|relative
condition|)
block|{
if|if
condition|(
name|relative
operator|->
name|parent
argument_list|()
operator|!=
operator|*
name|node
condition|)
block|{
if|if
condition|(
name|relative
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|bool
name|porting
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|title
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Porting"
argument_list|)
condition|)
name|porting
operator|=
literal|true
expr_stmt|;
block|}
name|QString
name|name
init|=
name|relative
operator|->
name|plainFullName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|porting
operator|&&
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"Q3"
argument_list|)
condition|)
block|{
if|if
condition|(
name|obsoleteLinks
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Link to obsolete item '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inObsoleteLink
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Link to Obsolete entity"
operator|<<
operator|(
operator|*
name|node
operator|)
operator|->
name|name
argument_list|()
operator|<<
literal|"no relative"
expr_stmt|;
block|}
block|}
block|}
comment|/*           This loop really only makes sense if *node is not 0.           In that case, The node *node points to represents a           qdoc page, so the link will ultimately point to some           target on that page. This loop finds that target on           the page that *node represents. ref is that target.          */
while|while
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|qdb_
operator|->
name|findTarget
argument_list|(
name|path
operator|.
name|first
argument_list|()
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
comment|/*           Given that *node is not null, we now cconstruct a link           to the page that *node represents, and then if there is           a target on that page, we connect the target to the link           with '#'.          */
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|link
operator|=
name|linkForNode
argument_list|(
operator|*
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node
operator|&&
operator|(
operator|*
name|node
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
name|link
operator|=
literal|"images/used-in-examples/"
operator|+
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|ref
expr_stmt|;
block|}
block|}
block|}
return|return
name|link
return|;
block|}
end_function
begin_function
DECL|function|generateStatus
name|void
name|HtmlGenerator
operator|::
name|generateStatus
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|text
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is part of the Qt 3 support library."
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" It is provided to keep old source code working. "
operator|<<
literal|"We strongly advise against "
operator|<<
literal|"using it in new code. See "
expr_stmt|;
specifier|const
name|DocNode
modifier|*
name|docNode
init|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
literal|"Porting To Qt 4"
argument_list|)
decl_stmt|;
name|QString
name|ref
decl_stmt|;
if|if
condition|(
name|docNode
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|QString
name|oldName
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|oldName
operator|.
name|remove
argument_list|(
name|QLatin1Char
argument_list|(
literal|'3'
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|qdb_
operator|->
name|findTarget
argument_list|(
name|oldName
argument_list|,
name|docNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|linkForNode
argument_list|(
name|docNode
argument_list|,
name|node
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
literal|" for more information."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
block|}
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
end_ifdef
begin_comment
comment|/*   No longer valid.  */
end_comment
begin_function
DECL|function|generateMacRef
name|void
name|HtmlGenerator
operator|::
name|generateMacRef
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pleaseGenerateMacRef
operator|||
name|marker
operator|==
literal|0
condition|)
return|return;
name|QStringList
name|macRefs
init|=
name|marker
operator|->
name|macRefsForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|macRef
decl|,
name|macRefs
control|)
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
literal|"//apple_ref/"
operator|<<
name|macRef
operator|<<
literal|"\"></a>\n"
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|beginLink
name|void
name|HtmlGenerator
operator|::
name|beginLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|link
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|link_
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"<i>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|(
name|relative
operator|!=
literal|0
operator|&&
name|node
operator|->
name|status
argument_list|()
operator|==
name|relative
operator|->
name|status
argument_list|()
operator|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\">"
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\" class=\"obsolete\">"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\" class=\"compat\">"
expr_stmt|;
break|break;
default|default:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\">"
expr_stmt|;
block|}
block|}
name|inLink_
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endLink
name|void
name|HtmlGenerator
operator|::
name|endLink
parameter_list|()
block|{
if|if
condition|(
name|inLink_
condition|)
block|{
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"</i>"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inObsoleteLink
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<sup>(obsolete)</sup>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
block|}
name|inLink_
operator|=
literal|false
expr_stmt|;
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates the summary for the \a section. Only used for   sections of QML element documentation.  */
end_comment
begin_function
DECL|function|generateQmlSummary
name|void
name|HtmlGenerator
operator|::
name|generateQmlSummary
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
decl_stmt|;
name|m
operator|=
name|section
operator|.
name|members
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|section
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|generateQmlItem
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Outputs the html detailed documentation for a section   on a QML element reference page.  */
end_comment
begin_function
DECL|function|generateDetailedQmlMember
name|void
name|HtmlGenerator
operator|::
name|generateDetailedQmlMember
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|MemberMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlitem\">"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|QmlPropGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropGroupNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlPropNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qpn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
if|if
condition|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|qdb_
argument_list|)
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmlreadonly\">read-only</span>"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmldefault\">default</span>"
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/*           If the QML property node has a single subproperty,           override, replace qpn with that override node and           proceed as normal.          */
if|if
condition|(
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
name|qpn
operator|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/*           Now qpn either has no overrides, or it has more           than 1. If it has none, proceed to output as nortmal.          */
if|if
condition|(
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlPropNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qpn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
if|if
condition|(
operator|!
name|qpn
operator|->
name|isReadOnlySet
argument_list|()
condition|)
block|{
if|if
condition|(
name|qpn
operator|->
name|declarativeCppNode
argument_list|()
condition|)
name|qpn
operator|->
name|setReadOnly
argument_list|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|qdb_
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qpn
operator|->
name|isReadOnly
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmlreadonly\">read-only</span>"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmldefault\">default</span>"
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
else|else
block|{
comment|/*               The QML property node has multiple override nodes.               Process the whole list as we would for a QML property               group.              */
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpn
operator|->
name|qmlPropNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|q
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlPropNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|q
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
if|if
condition|(
operator|!
name|qpn
operator|->
name|isReadOnlySet
argument_list|()
condition|)
name|qpn
operator|->
name|setReadOnly
argument_list|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|(
name|qdb_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isReadOnly
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmlreadonly\">read-only</span>"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmldefault\">default</span>"
expr_stmt|;
name|generateQmlItem
argument_list|(
name|q
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qsn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qsn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qsn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qshn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qshn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qshn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qmn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qmn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qmn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmldoc\">"
expr_stmt|;
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Output the "Inherits" line for the QML element,   if there should be one.  */
end_comment
begin_function
DECL|function|generateQmlInherits
name|void
name|HtmlGenerator
operator|::
name|generateQmlInherits
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcn
condition|)
return|return;
specifier|const
name|DocNode
modifier|*
name|base
init|=
name|qcn
operator|->
name|qmlBase
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
literal|"Inherits "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|base
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[Xxx instantiates the C++ class QmlGraphicsXxx]"   line for the QML element, if there should be one.    If there is no class node, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateQmlInstantiates
name|void
name|HtmlGenerator
operator|::
name|generateQmlInstantiates
parameter_list|(
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
operator|(
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|qcn
operator|->
name|name
argument_list|()
decl_stmt|;
comment|/*           Remove the "QML:" prefix, if present.           It shouldn't be present anymore.         */
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// remove the "QML:" prefix
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" instantiates the C++ class "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[QmlGraphicsXxx is instantiated by QML Type Xxx]"   line for the class, if there should be one.    If there is no QML element, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateInstantiatedBy
name|void
name|HtmlGenerator
operator|::
name|generateInstantiatedBy
parameter_list|(
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|&&
name|cn
operator|->
name|qmlElement
argument_list|()
operator|!=
literal|0
condition|)
block|{
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|cn
operator|->
name|qmlElement
argument_list|()
decl_stmt|;
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" is instantiated by QML Type "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateExtractionMark
name|void
name|HtmlGenerator
operator|::
name|generateExtractionMark
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|ExtractionMarkType
name|markType
parameter_list|)
block|{
if|if
condition|(
name|markType
operator|!=
name|EndMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<!-- $$$"
operator|+
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|markType
operator|==
name|MemberMark
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"[overload1]"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|+
name|func
operator|->
name|rawParameters
argument_list|()
operator|.
name|remove
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-prop"
expr_stmt|;
specifier|const
name|PropertyNode
modifier|*
name|prop
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|list
init|=
name|prop
operator|->
name|functions
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|propFuncNode
decl|,
name|list
control|)
block|{
if|if
condition|(
name|propFuncNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|propFuncNode
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|+
name|func
operator|->
name|rawParameters
argument_list|()
operator|.
name|remove
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enumNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|enumNode
operator|->
name|items
argument_list|()
control|)
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|item
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|markType
operator|==
name|BriefMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-brief"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markType
operator|==
name|DetailedDescriptionMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-description"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|" -->\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<!-- @@@"
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|" -->\n"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function outputs one or more manifest files in XML.   They are used by Creator.  */
end_comment
begin_function
DECL|function|generateManifestFiles
name|void
name|HtmlGenerator
operator|::
name|generateManifestFiles
parameter_list|()
block|{
name|generateManifestFile
argument_list|(
literal|"examples"
argument_list|,
literal|"example"
argument_list|)
expr_stmt|;
name|generateManifestFile
argument_list|(
literal|"demos"
argument_list|,
literal|"demo"
argument_list|)
expr_stmt|;
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is called by generaqteManiferstFile(), once   for each manifest file to be generated. \a manifest is the   type of manifest file.  */
end_comment
begin_function
DECL|function|generateManifestFile
name|void
name|HtmlGenerator
operator|::
name|generateManifestFile
parameter_list|(
name|QString
name|manifest
parameter_list|,
name|QString
name|element
parameter_list|)
block|{
if|if
condition|(
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|fileName
init|=
name|manifest
operator|+
literal|"-manifest.xml"
decl_stmt|;
name|QFile
name|file
argument_list|(
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
return|return ;
name|bool
name|demos
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|manifest
operator|==
literal|"demos"
condition|)
name|demos
operator|=
literal|true
expr_stmt|;
name|bool
name|proceed
init|=
literal|false
decl_stmt|;
name|ExampleNodeMap
operator|::
name|Iterator
name|i
init|=
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|en
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|demos
condition|)
block|{
if|if
condition|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
name|proceed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
name|proceed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|proceed
condition|)
return|return;
name|QXmlStreamWriter
name|writer
argument_list|(
operator|&
name|file
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartDocument
argument_list|()
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"instructionals"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|project
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
name|manifest
argument_list|)
expr_stmt|;
name|i
operator|=
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|ExampleNode
operator|::
name|exampleNodeMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|en
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|demos
condition|)
block|{
if|if
condition|(
operator|!
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|writer
operator|.
name|writeStartElement
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|en
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|docUrl
init|=
name|manifestDir
operator|+
name|fileBase
argument_list|(
name|en
argument_list|)
operator|+
literal|".html"
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"docUrl"
argument_list|,
name|docUrl
argument_list|)
expr_stmt|;
name|QStringList
name|proFiles
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|child
decl|,
name|en
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|QString
name|file
init|=
name|child
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|endsWith
argument_list|(
literal|".pro"
argument_list|)
operator|||
name|file
operator|.
name|endsWith
argument_list|(
literal|".qmlproject"
argument_list|)
condition|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
literal|"demos/"
argument_list|)
condition|)
name|file
operator|=
name|file
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|proFiles
operator|<<
name|file
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|proFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|proFiles
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|exampleName
init|=
name|en
operator|->
name|name
argument_list|()
operator|.
name|split
argument_list|(
literal|'/'
argument_list|)
operator|.
name|last
argument_list|()
decl_stmt|;
name|bool
name|proWithExampleNameFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|proFiles
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|proFiles
index|[
name|j
index|]
operator|.
name|endsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"%1/%1.pro"
argument_list|)
operator|.
name|arg
argument_list|(
name|exampleName
argument_list|)
argument_list|)
operator|||
name|proFiles
index|[
name|j
index|]
operator|.
name|endsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"%1/%1.qmlproject"
argument_list|)
operator|.
name|arg
argument_list|(
name|exampleName
argument_list|)
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|proWithExampleNameFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|proWithExampleNameFound
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|en
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"imageUrl"
argument_list|,
name|manifestDir
operator|+
name|en
operator|->
name|imageFileName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"description"
argument_list|)
expr_stmt|;
name|Text
name|brief
init|=
name|en
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeCDATA
argument_list|(
name|brief
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writer
operator|.
name|writeCDATA
argument_list|(
name|QString
argument_list|(
literal|"No description available"
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// description
name|QStringList
name|tags
init|=
name|en
operator|->
name|title
argument_list|()
operator|.
name|toLower
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"tags"
argument_list|)
expr_stmt|;
name|bool
name|wrote_one
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|tags
operator|.
name|size
argument_list|()
condition|;
operator|++
name|n
control|)
block|{
name|QString
name|tag
init|=
name|tags
operator|.
name|at
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isDigit
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|startsWith
argument_list|(
literal|"example"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|startsWith
argument_list|(
literal|"chapter"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
name|tag
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|wrote_one
condition|)
name|writer
operator|.
name|writeCharacters
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|wrote_one
operator|=
literal|true
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// tags
block|}
name|QString
name|ename
init|=
name|en
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|usedNames
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|child
decl|,
name|en
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|QString
name|file
init|=
name|child
operator|->
name|name
argument_list|()
decl_stmt|;
name|QString
name|fileName
init|=
name|file
operator|.
name|mid
argument_list|(
name|file
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QString
name|baseName
init|=
name|fileName
decl_stmt|;
if|if
condition|(
operator|(
name|fileName
operator|.
name|count
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".cpp"
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".h"
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".qml"
argument_list|)
operator|)
condition|)
name|baseName
operator|.
name|truncate
argument_list|(
name|baseName
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseName
operator|.
name|compare
argument_list|(
name|ename
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|usedNames
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"fileToOpen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
literal|"demos/"
argument_list|)
condition|)
name|file
operator|=
name|file
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|examplesPath
operator|+
name|file
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// fileToOpen
name|usedNames
operator|.
name|insert
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|toLower
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"main.cpp"
argument_list|)
operator|||
name|fileName
operator|.
name|toLower
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"main.qml"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|usedNames
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"fileToOpen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
literal|"demos/"
argument_list|)
condition|)
name|file
operator|=
name|file
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|examplesPath
operator|+
name|file
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// fileToOpen
name|usedNames
operator|.
name|insert
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// example
operator|++
name|i
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// examples
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// instructionals
name|writer
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Find global entities that have documentation but no   \e{relates} comand. Report these as errors if they   are not also marked \e {internal}.    type: Class   type: Namespace    subtype: Example   subtype: External page   subtype: Group   subtype: Header file   subtype: Module   subtype: Page   subtype: QML basic type   subtype: QML class   subtype: QML module  */
end_comment
begin_function
DECL|function|reportOrphans
name|void
name|HtmlGenerator
operator|::
name|reportOrphans
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|bool
name|related
decl_stmt|;
name|QString
name|message
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|isInternal
argument_list|()
operator|||
name|child
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|relates
argument_list|()
condition|)
block|{
name|related
operator|=
literal|true
expr_stmt|;
name|message
operator|=
name|child
operator|->
name|relates
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|related
operator|=
literal|false
expr_stmt|;
name|message
operator|=
literal|"has documentation but no \\relates command"
expr_stmt|;
block|}
switch|switch
condition|(
name|child
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
break|break;
case|case
name|Node
operator|::
name|Class
case|:
break|break;
case|case
name|Node
operator|::
name|Document
case|:
switch|switch
condition|(
name|child
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Example
case|:
break|break;
case|case
name|Node
operator|::
name|HeaderFile
case|:
break|break;
case|case
name|Node
operator|::
name|File
case|:
break|break;
case|case
name|Node
operator|::
name|Image
case|:
break|break;
case|case
name|Node
operator|::
name|Group
case|:
break|break;
case|case
name|Node
operator|::
name|Module
case|:
break|break;
case|case
name|Node
operator|::
name|Page
case|:
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
break|break;
case|case
name|Node
operator|::
name|QmlClass
case|:
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
break|break;
case|case
name|Node
operator|::
name|QmlModule
case|:
break|break;
case|case
name|Node
operator|::
name|Collision
case|:
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global enum, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global typedef, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
if|if
condition|(
operator|!
name|related
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global macro, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global function, %1(), %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Property
case|:
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global variable, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML property, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML, signal, %1 %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML signal handler, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML method, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Returns a reference to the XML stream writer currently in use.   There is one XML stream writer open for each XML file being   written, and they are kept on a stack. The one on top of the   stack is the one being written to at the moment. In the HTML   output generator, it is perhaps impossible for there to ever   be more than one writer open.  */
end_comment
begin_function
DECL|function|xmlWriter
name|QXmlStreamWriter
modifier|&
name|HtmlGenerator
operator|::
name|xmlWriter
parameter_list|()
block|{
return|return
operator|*
name|xmlWriterStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Calls beginSubPage() in the base class to open the file.   Then creates a new XML stream writer using the IO device   from opened file and pushes the XML writer onto a stackj.   Creates the file named \a fileName in the output directory.   Attaches a QTextStream to the created file, which is written   to all over the place using out(). Finally, it sets some   parameters in the XML writer and calls writeStartDocument().    It also ensures that a GUID map is created for the output file.  */
end_comment
begin_function
DECL|function|beginDitamapPage
name|void
name|HtmlGenerator
operator|::
name|beginDitamapPage
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Generator
operator|::
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QXmlStreamWriter
modifier|*
name|writer
init|=
operator|new
name|QXmlStreamWriter
argument_list|(
name|out
argument_list|()
operator|.
name|device
argument_list|()
argument_list|)
decl_stmt|;
name|xmlWriterStack
operator|.
name|push
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormattingIndent
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|writer
operator|->
name|writeStartDocument
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Calls writeEndDocument() and then pops the XML stream writer   off the stack and deletes it. Then it calls endSubPage() in   the base class to close the device.  */
end_comment
begin_function
DECL|function|endDitamapPage
name|void
name|HtmlGenerator
operator|::
name|endDitamapPage
parameter_list|()
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
operator|delete
name|xmlWriterStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|Generator
operator|::
name|endSubPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Creates the DITA map from the topicrefs in \a node,   which is a DitaMapNode.  */
end_comment
begin_function
DECL|function|writeDitaMap
name|void
name|HtmlGenerator
operator|::
name|writeDitaMap
parameter_list|(
specifier|const
name|DitaMapNode
modifier|*
name|node
parameter_list|)
block|{
name|beginDitamapPage
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|doctype
init|=
literal|"<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">"
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeDTD
argument_list|(
name|doctype
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"map"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"topicmeta"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"shortdesc"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</shortdesc>
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</topicmeta>
name|DitaRefList
name|map
init|=
name|node
operator|->
name|map
argument_list|()
decl_stmt|;
name|writeDitaRefs
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|endDitamapPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Write the \a ditarefs to the current output file.  */
end_comment
begin_function
DECL|function|writeDitaRefs
name|void
name|HtmlGenerator
operator|::
name|writeDitaRefs
parameter_list|(
specifier|const
name|DitaRefList
modifier|&
name|ditarefs
parameter_list|)
block|{
foreach|foreach
control|(
name|DitaRef
modifier|*
name|t
decl|,
name|ditarefs
control|)
block|{
if|if
condition|(
name|t
operator|->
name|isMapRef
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"mapref"
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"topicref"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|href
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|fn
init|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|t
operator|->
name|href
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|subrefs
argument_list|()
operator|&&
operator|!
name|t
operator|->
name|subrefs
argument_list|()
operator|->
name|isEmpty
argument_list|()
condition|)
name|writeDitaRefs
argument_list|(
operator|*
operator|(
name|t
operator|->
name|subrefs
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</topicref> or</mapref>
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
