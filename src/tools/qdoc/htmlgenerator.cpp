begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   htmlgenerator.cpp */
end_comment
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"codeparser.h"
end_include
begin_include
include|#
directive|include
file|"helpprojectwriter.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|"separator.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qiterator.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<quuid.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|COMMAND_VERSION
define|#
directive|define
name|COMMAND_VERSION
value|Doc::alias("version")
DECL|member|id
name|int
name|HtmlGenerator
operator|::
name|id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|debugging_on
name|bool
name|HtmlGenerator
operator|::
name|debugging_on
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|divNavTop
name|QString
name|HtmlGenerator
operator|::
name|divNavTop
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|showBrokenLinks
specifier|static
name|bool
name|showBrokenLinks
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|linkTag
argument_list|(
literal|"(<@link node=\"([^\"]+)\">).*(</@link>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|funcTag
argument_list|(
literal|"(<@func target=\"([^\"]*)\">)(.*)(</@func>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|typeTag
argument_list|(
literal|"(<@(type|headerfile|func)(?: +[^>]*)?>)(.*)(</@\\2>)"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|spanTag
argument_list|(
literal|"</@(?:comment|preprocessor|string|char|number|op|type|name|keyword)>"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
name|QRegExp
name|unknownTag
argument_list|(
literal|"</?@[^>]*>"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|addLink
specifier|static
name|void
name|addLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|linkTarget
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|nestedStuff
parameter_list|,
name|QString
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
operator|!
name|linkTarget
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|res
operator|+=
literal|"<a href=\""
expr_stmt|;
operator|*
name|res
operator|+=
name|linkTarget
expr_stmt|;
operator|*
name|res
operator|+=
literal|"\">"
expr_stmt|;
operator|*
name|res
operator|+=
name|nestedStuff
expr_stmt|;
operator|*
name|res
operator|+=
literal|"</a>"
expr_stmt|;
block|}
else|else
block|{
operator|*
name|res
operator|+=
name|nestedStuff
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Constructs the HTML output generator.  */
end_comment
begin_constructor
DECL|function|HtmlGenerator
name|HtmlGenerator
operator|::
name|HtmlGenerator
parameter_list|()
member_init_list|:
name|codeIndent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|helpProjectWriter
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|inObsoleteLink
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|funcLeftParen
argument_list|(
literal|"\\S(\\()"
argument_list|)
member_init_list|,
name|obsoleteLinks
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys the HTML output generator. Deletes the singleton   instance of HelpProjectWriter.  */
end_comment
begin_destructor
DECL|function|~HtmlGenerator
name|HtmlGenerator
operator|::
name|~
name|HtmlGenerator
parameter_list|()
block|{
if|if
condition|(
name|helpProjectWriter
condition|)
operator|delete
name|helpProjectWriter
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Initializes the HTML output generator's data structures   from the configuration class \a config.  */
end_comment
begin_function
DECL|function|initializeGenerator
name|void
name|HtmlGenerator
operator|::
name|initializeGenerator
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|left
decl_stmt|;
specifier|const
name|char
modifier|*
name|right
decl_stmt|;
block|}
name|defaults
index|[]
init|=
block|{
block|{
name|ATOM_FORMATTING_BOLD
block|,
literal|"<b>"
block|,
literal|"</b>"
block|}
block|,
block|{
name|ATOM_FORMATTING_INDEX
block|,
literal|"<!--"
block|,
literal|"-->"
block|}
block|,
block|{
name|ATOM_FORMATTING_ITALIC
block|,
literal|"<i>"
block|,
literal|"</i>"
block|}
block|,
block|{
name|ATOM_FORMATTING_PARAMETER
block|,
literal|"<i>"
block|,
literal|"</i>"
block|}
block|,
block|{
name|ATOM_FORMATTING_SUBSCRIPT
block|,
literal|"<sub>"
block|,
literal|"</sub>"
block|}
block|,
block|{
name|ATOM_FORMATTING_SUPERSCRIPT
block|,
literal|"<sup>"
block|,
literal|"</sup>"
block|}
block|,
block|{
name|ATOM_FORMATTING_TELETYPE
block|,
literal|"<tt>"
block|,
literal|"</tt>"
block|}
block|,
block|{
name|ATOM_FORMATTING_UICONTROL
block|,
literal|"<b>"
block|,
literal|"</b>"
block|}
block|,
block|{
name|ATOM_FORMATTING_UNDERLINE
block|,
literal|"<u>"
block|,
literal|"</u>"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|Generator
operator|::
name|initializeGenerator
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|obsoleteLinks
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|CONFIG_OBSOLETELINKS
argument_list|)
expr_stmt|;
name|setImageFileExtensions
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"png"
operator|<<
literal|"jpg"
operator|<<
literal|"jpeg"
operator|<<
literal|"gif"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
condition|)
block|{
name|formattingLeftMap
argument_list|()
operator|.
name|insert
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|formattingRightMap
argument_list|()
operator|.
name|insert
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|style
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_STYLE
argument_list|)
expr_stmt|;
name|endHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_ENDHEADER
argument_list|)
expr_stmt|;
name|postHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_POSTHEADER
argument_list|)
expr_stmt|;
name|postPostHeader
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_POSTPOSTHEADER
argument_list|)
expr_stmt|;
name|footer
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_FOOTER
argument_list|)
expr_stmt|;
name|address
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_ADDRESS
argument_list|)
expr_stmt|;
name|pleaseGenerateMacRef
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_GENERATEMACREFS
argument_list|)
expr_stmt|;
name|noNavigationBar
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_NONAVIGATIONBAR
argument_list|)
expr_stmt|;
name|tocDepth
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|HTMLGENERATOR_TOCDEPTH
argument_list|)
expr_stmt|;
name|project
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_PROJECT
argument_list|)
expr_stmt|;
name|projectDescription
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_DESCRIPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|projectDescription
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|projectDescription
operator|=
name|project
operator|+
literal|" Reference Documentation"
expr_stmt|;
name|projectUrl
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_URL
argument_list|)
expr_stmt|;
name|tagFile_
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_TAGFILE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|outputEncoding
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_OUTPUTENCODING
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputEncoding
operator|.
name|isEmpty
argument_list|()
condition|)
name|outputEncoding
operator|=
name|QLatin1String
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|outputCodec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|outputEncoding
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|naturalLanguage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NATURALLANGUAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|naturalLanguage
operator|.
name|isEmpty
argument_list|()
condition|)
name|naturalLanguage
operator|=
name|QLatin1String
argument_list|(
literal|"en"
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|editionNames
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_EDITION
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|edition
init|=
name|editionNames
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|edition
operator|!=
name|editionNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|editionName
init|=
operator|*
name|edition
decl_stmt|;
name|QStringList
name|editionModules
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"modules"
argument_list|)
decl_stmt|;
name|QStringList
name|editionGroups
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_EDITION
operator|+
name|Config
operator|::
name|dot
operator|+
name|editionName
operator|+
name|Config
operator|::
name|dot
operator|+
literal|"groups"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|editionModules
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionModuleMap
index|[
name|editionName
index|]
operator|=
name|editionModules
expr_stmt|;
if|if
condition|(
operator|!
name|editionGroups
operator|.
name|isEmpty
argument_list|()
condition|)
name|editionGroupMap
index|[
name|editionName
index|]
operator|=
name|editionGroups
expr_stmt|;
operator|++
name|edition
expr_stmt|;
block|}
comment|// The following line was changed to fix QTBUG-27798
comment|//codeIndent = config.getInt(CONFIG_CODEINDENT);
name|helpProjectWriter
operator|=
operator|new
name|HelpProjectWriter
argument_list|(
name|config
argument_list|,
name|project
operator|.
name|toLower
argument_list|()
operator|+
literal|".qhp"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Documentation template handling
name|headerScripts
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_HEADERSCRIPTS
argument_list|)
expr_stmt|;
name|headerStyles
operator|=
name|config
operator|.
name|getString
argument_list|(
name|HtmlGenerator
operator|::
name|format
argument_list|()
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_HEADERSTYLES
argument_list|)
expr_stmt|;
name|QString
name|prefix
init|=
name|CONFIG_QHP
operator|+
name|Config
operator|::
name|dot
operator|+
name|project
operator|+
name|Config
operator|::
name|dot
decl_stmt|;
name|manifestDir
operator|=
literal|"qthelp://"
operator|+
name|config
operator|.
name|getString
argument_list|(
name|prefix
operator|+
literal|"namespace"
argument_list|)
expr_stmt|;
name|manifestDir
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|config
operator|.
name|getString
argument_list|(
name|prefix
operator|+
literal|"virtualFolder"
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|readManifestMetaContent
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|examplesPath
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_EXAMPLESINSTALLPATH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|examplesPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|examplesPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
comment|//retrieve the config for the navigation bar
name|homepage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NAVIGATION
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_HOMEPAGE
argument_list|)
expr_stmt|;
name|landingpage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NAVIGATION
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_LANDINGPAGE
argument_list|)
expr_stmt|;
name|cppclassespage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NAVIGATION
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_CPPCLASSESPAGE
argument_list|)
expr_stmt|;
name|qmltypespage
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_NAVIGATION
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_QMLTYPESPAGE
argument_list|)
expr_stmt|;
name|buildversion
operator|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_BUILDVERSION
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Gracefully terminates the HTML output generator.  */
end_comment
begin_function
DECL|function|terminateGenerator
name|void
name|HtmlGenerator
operator|::
name|terminateGenerator
parameter_list|()
block|{
name|Generator
operator|::
name|terminateGenerator
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format
name|QString
name|HtmlGenerator
operator|::
name|format
parameter_list|()
block|{
return|return
literal|"HTML"
return|;
block|}
end_function
begin_comment
comment|/*!   Traverses the current tree generating all the HTML documentation.  */
end_comment
begin_function
DECL|function|generateDocs
name|void
name|HtmlGenerator
operator|::
name|generateDocs
parameter_list|()
block|{
name|Node
modifier|*
name|qflags
init|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
name|QStringList
argument_list|(
literal|"QFlags"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qflags
condition|)
name|qflagsHref_
operator|=
name|linkForNode
argument_list|(
name|qflags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|runPrepareOnly
argument_list|()
condition|)
block|{
name|Generator
operator|::
name|generateDocs
argument_list|()
expr_stmt|;
name|generateCollisionPages
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|runGenerateOnly
argument_list|()
condition|)
block|{
name|QString
name|fileBase
init|=
name|project
operator|.
name|toLower
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
decl_stmt|;
name|qdb_
operator|->
name|generateIndex
argument_list|(
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|fileBase
operator|+
literal|".index"
argument_list|,
name|projectUrl
argument_list|,
name|projectDescription
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|runPrepareOnly
argument_list|()
condition|)
block|{
name|helpProjectWriter
operator|->
name|generate
argument_list|()
expr_stmt|;
name|generateManifestFiles
argument_list|()
expr_stmt|;
comment|/*           Generate the XML tag file, if it was requested.         */
name|qdb_
operator|->
name|generateTagFile
argument_list|(
name|tagFile_
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate html from an instance of Atom.  */
end_comment
begin_function
DECL|function|generateAtom
name|int
name|HtmlGenerator
operator|::
name|generateAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|int
name|skipAhead
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|in_para
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|atom
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Atom
operator|::
name|AbstractLeft
case|:
if|if
condition|(
name|relative
condition|)
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\abstract is not implemented."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Location
operator|::
name|information
argument_list|(
name|tr
argument_list|(
literal|"\abstract is not implemented."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|AbstractRight
case|:
break|break;
case|case
name|Atom
operator|::
name|AutoLink
case|:
if|if
condition|(
operator|!
name|inLink_
operator|&&
operator|!
name|inContents_
operator|&&
operator|!
name|inSectionHeading_
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|link
init|=
name|getAutoLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|autolinkErrors
argument_list|()
condition|)
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Can't autolink to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
name|relative
operator|->
name|parent
argument_list|()
operator|!=
name|node
operator|)
operator|&&
operator|!
name|relative
operator|->
name|isObsolete
argument_list|()
condition|)
name|link
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|beginLink
argument_list|(
name|link
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|generateLink
argument_list|(
name|atom
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|endLink
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BaseName
case|:
break|break;
case|case
name|Atom
operator|::
name|BriefLeft
case|:
if|if
condition|(
name|relative
operator|->
name|isQmlBasicType
argument_list|()
operator|||
operator|(
name|relative
operator|->
name|isDocNode
argument_list|()
operator|&&
operator|!
name|relative
operator|->
name|isExample
argument_list|()
operator|)
condition|)
block|{
name|skipAhead
operator|=
name|skipAtoms
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|BriefRight
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
operator|||
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
name|QString
name|str
decl_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|BriefRight
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|AutoLink
condition|)
name|str
operator|+=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|skipAhead
operator|++
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
name|str
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|str
operator|.
name|truncate
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"This "
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
name|out
argument_list|()
operator|<<
literal|"property"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"variable"
expr_stmt|;
name|QStringList
name|words
init|=
name|str
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"contains"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"specifies"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"describes"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"defines"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"holds"
operator|||
name|words
operator|.
name|first
argument_list|()
operator|==
literal|"determines"
operator|)
condition|)
name|out
argument_list|()
operator|<<
literal|" holds "
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|out
argument_list|()
operator|<<
name|str
operator|<<
literal|'.'
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|BriefRight
case|:
if|if
condition|(
operator|!
name|relative
operator|->
name|isDocNode
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|C
case|:
comment|// This may at one time have been used to mark up C++ code but it is
comment|// now widely used to write teletype text. As a result, text marked
comment|// with the \c command is not passed to a code marker.
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
if|if
condition|(
name|inLink_
condition|)
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CaptionLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p class=\"figCaption\">"
expr_stmt|;
name|in_para
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CaptionRight
case|:
name|endLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|Code
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Qml
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"qml\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|JavaScript
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"js\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CodeNew
case|:
name|out
argument_list|()
operator|<<
literal|"<p>you can rewrite it as</p>\n"
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|CodeOld
case|:
name|out
argument_list|()
operator|<<
literal|"<p>For example, if you have code like</p>\n"
expr_stmt|;
comment|// fallthrough
case|case
name|Atom
operator|::
name|CodeBad
case|:
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|"</pre>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|DivLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<div"
expr_stmt|;
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|' '
operator|<<
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|DivRight
case|:
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FootnoteLeft
case|:
comment|// ### For now
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<!-- "
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FootnoteRight
case|:
comment|// ### For now
name|out
argument_list|()
operator|<<
literal|"-->"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|FormatElse
case|:
case|case
name|Atom
operator|::
name|FormatEndif
case|:
case|case
name|Atom
operator|::
name|FormatIf
case|:
break|break;
case|case
name|Atom
operator|::
name|FormattingLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"span "
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|'<'
operator|+
name|atom
operator|->
name|string
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
block|}
else|else
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|atom
operator|->
name|string
argument_list|()
index|]
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_PARAMETER
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
block|{
name|QRegExp
name|subscriptRegExp
argument_list|(
literal|"([a-z]+)_([0-9n])"
argument_list|)
decl_stmt|;
if|if
condition|(
name|subscriptRegExp
operator|.
name|exactMatch
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|<<
literal|"<sub>"
operator|<<
name|subscriptRegExp
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
operator|<<
literal|"</sub>"
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|FormattingRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_LINK
condition|)
block|{
name|endLink
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"span "
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</span>"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|atom
operator|->
name|string
argument_list|()
index|]
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|AnnotatedList
case|:
block|{
name|GroupNode
modifier|*
name|gn
init|=
name|qdb_
operator|->
name|getGroup
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|gn
condition|)
name|generateList
argument_list|(
name|gn
argument_list|,
name|marker
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|GeneratedList
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"annotatedclasses"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classes"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|,
literal|true
argument_list|,
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"classes "
argument_list|)
condition|)
block|{
name|QString
name|rootName
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"classes"
argument_list|)
operator|+
literal|7
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|,
literal|true
argument_list|,
name|rootName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"qmltypes"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getQmlTypes
argument_list|()
argument_list|,
literal|true
argument_list|,
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|"classesbymodule"
argument_list|)
condition|)
block|{
name|QString
name|moduleName
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"classesbymodule"
argument_list|)
operator|+
literal|15
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QDocDatabase
modifier|*
name|qdb
init|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
decl_stmt|;
name|ModuleNode
modifier|*
name|mn
init|=
name|qdb
operator|->
name|findModule
argument_list|(
name|moduleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mn
condition|)
block|{
name|NodeMap
name|m
decl_stmt|;
name|mn
operator|->
name|getMemberClasses
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"classhierarchy"
condition|)
block|{
name|generateClassHierarchy
argument_list|(
name|relative
argument_list|,
name|qdb_
operator|->
name|getCppClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"compatclasses"
condition|)
block|{
comment|// "compatclasses" is no longer used. Delete this at some point.
comment|// mws 03/10/2013
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getCompatibilityClasses
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoleteclasses"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getObsoleteClasses
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoleteqmltypes"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getObsoleteQmlTypes
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoletecppmembers"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Obsolete
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getClassesWithObsoleteMembers
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"obsoleteqmlmembers"
condition|)
block|{
name|generateCompactList
argument_list|(
name|Obsolete
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getQmlTypesWithObsoleteMembers
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"functionindex"
condition|)
block|{
name|generateFunctionIndex
argument_list|(
name|relative
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"legalese"
condition|)
block|{
name|generateLegaleseList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"mainclasses"
condition|)
block|{
comment|// "mainclasses" is no longer used. Delete this at some point.
comment|// mws 03/10/2013
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getMainClasses
argument_list|()
argument_list|,
literal|true
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"services"
condition|)
block|{
comment|// "services" is no longer used. Delete this at some point.
comment|// mws 03/10/2013
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
name|relative
argument_list|,
name|qdb_
operator|->
name|getServiceClasses
argument_list|()
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"overviews"
condition|)
block|{
name|generateList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
literal|"overviews"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"cpp-modules"
condition|)
block|{
name|generateList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
literal|"cpp-modules"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"qml-modules"
condition|)
block|{
name|generateList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
literal|"qml-modules"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"namespaces"
condition|)
block|{
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|qdb_
operator|->
name|getNamespaces
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
literal|"related"
condition|)
block|{
name|generateList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
literal|"related"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/*           This is not used in Qt5, as of 10/02/2014           Remove permanently if it is not missed.          */
block|else if (atom->string() == "relatedinline") {             const DocNode *dn = static_cast<const DocNode *>(relative);             if (dn&& !dn->members().isEmpty()) {
comment|// Reverse the list into the original scan order.
comment|// Should be sorted.  But on what?  It may not be a
comment|// regular class or page definition.
block|QList<const Node *> list;                 foreach (const Node *node, dn->members())                     list.prepend(node);                 foreach (const Node *node, list)                     generateBody(node, marker);             }         }
endif|#
directive|endif
break|break;
case|case
name|Atom
operator|::
name|SinceList
case|:
block|{
specifier|const
name|NodeMultiMap
modifier|&
name|nsmap
init|=
name|qdb_
operator|->
name|getSinceMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeMap
modifier|&
name|ncmap
init|=
name|qdb_
operator|->
name|getClassMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|NodeMap
modifier|&
name|nqcmap
init|=
name|qdb_
operator|->
name|getQmlTypeMap
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nsmap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LastSinceType
condition|;
operator|++
name|i
control|)
name|sections
operator|.
name|append
argument_list|(
name|Section
argument_list|(
name|sinceTitle
argument_list|(
name|i
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|NodeMultiMap
operator|::
name|const_iterator
name|n
init|=
name|nsmap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nsmap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|n
operator|.
name|value
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlType
case|:
name|sections
index|[
name|QmlClass
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|sections
index|[
name|Namespace
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|sections
index|[
name|Class
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|sections
index|[
name|Enum
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|sections
index|[
name|Typedef
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
name|sections
index|[
name|Macro
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|Node
modifier|*
name|p
init|=
name|fn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
name|sections
index|[
name|MemberFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
else|else
name|sections
index|[
name|NamespaceFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|sections
index|[
name|GlobalFunction
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Node
operator|::
name|Property
case|:
name|sections
index|[
name|Property
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|sections
index|[
name|Variable
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|sections
index|[
name|QmlProperty
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|sections
index|[
name|QmlSignal
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|sections
index|[
name|QmlSignalHandler
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|sections
index|[
name|QmlMethod
index|]
operator|.
name|appendMember
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|++
name|n
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
operator|<<
literal|"<a href=\"#"
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\">"
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h3>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h3>\n"
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|Class
condition|)
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
literal|0
argument_list|,
name|ncmap
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Q"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|QmlClass
condition|)
name|generateCompactList
argument_list|(
name|Generic
argument_list|,
literal|0
argument_list|,
name|nqcmap
argument_list|,
literal|false
argument_list|,
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|MemberFunction
condition|)
block|{
name|ParentMaps
name|parentmaps
decl_stmt|;
name|ParentMaps
operator|::
name|iterator
name|pmap
decl_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|s
operator|->
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|s
operator|->
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|p
init|=
operator|(
operator|*
name|i
operator|)
operator|->
name|parent
argument_list|()
decl_stmt|;
name|pmap
operator|=
name|parentmaps
operator|.
name|find
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
name|pmap
operator|=
name|parentmaps
operator|.
name|insert
argument_list|(
name|p
argument_list|,
name|NodeMultiMap
argument_list|()
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|pmap
operator|=
name|parentmaps
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|pmap
operator|!=
name|parentmaps
operator|.
name|end
argument_list|()
condition|)
block|{
name|NodeList
name|nlist
init|=
name|pmap
operator|->
name|values
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>Class "
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|pmap
operator|.
name|key
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|QStringList
name|pieces
init|=
name|pmap
operator|.
name|key
argument_list|()
operator|->
name|fullName
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
operator|<<
literal|":</p>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|nlist
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
operator|++
name|pmap
expr_stmt|;
block|}
block|}
else|else
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
operator|++
name|idx
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Atom
operator|::
name|BR
case|:
name|out
argument_list|()
operator|<<
literal|"<br />\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|HR
case|:
name|out
argument_list|()
operator|<<
literal|"<hr />\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Image
case|:
case|case
name|Atom
operator|::
name|InlineImage
case|:
block|{
name|QString
name|fileName
init|=
name|imageFileName
argument_list|(
name|relative
argument_list|,
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
condition|)
name|text
operator|=
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Image
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"centerAlign\">"
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|relative
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing image: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<font color=\"red\">[Missing image "
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"]</font>"
expr_stmt|;
block|}
else|else
block|{
name|QString
name|prefix
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<img src=\""
operator|<<
name|protectEnc
argument_list|(
name|prefix
operator|+
name|fileName
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|" alt=\""
operator|<<
name|protectEnc
argument_list|(
name|text
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|" alt=\"\""
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|" />"
expr_stmt|;
name|helpProjectWriter
operator|->
name|addExtraFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|relative
operator|->
name|isExample
argument_list|()
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|cen
init|=
cast|static_cast
argument_list|<
specifier|const
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|cen
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ExampleNode
modifier|*
name|en
init|=
cast|const_cast
argument_list|<
name|ExampleNode
operator|*
argument_list|>
argument_list|(
name|cen
argument_list|)
decl_stmt|;
name|en
operator|->
name|setImageFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Image
condition|)
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ImageText
case|:
break|break;
case|case
name|Atom
operator|::
name|ImportantLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"Important: "
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ImportantRight
case|:
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|NoteLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"Note: "
expr_stmt|;
name|out
argument_list|()
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|NoteRight
case|:
name|out
argument_list|()
operator|<<
literal|"</p>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LegaleseLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<div class=\"LegaleseLeft\">"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LegaleseRight
case|:
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|LineBreak
case|:
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|Link
case|:
block|{
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|link
init|=
name|getLink
argument_list|(
name|atom
argument_list|,
name|relative
argument_list|,
operator|&
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|noLinkErrors
argument_list|()
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Can't link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
if|if
condition|(
operator|(
name|relative
operator|->
name|parent
argument_list|()
operator|!=
name|node
operator|)
operator|&&
operator|!
name|relative
operator|->
name|isObsolete
argument_list|()
condition|)
block|{
name|inObsoleteLink
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|obsoleteLinks
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Link to obsolete item '%1' in %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|relative
operator|->
name|plainFullName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|beginLink
argument_list|(
name|link
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|LinkNode
case|:
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|beginLink
argument_list|(
name|linkForNode
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
argument_list|,
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListLeft
case|:
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dl>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|threeColumnEnumValueTable_
operator|=
name|isThreeColumnEnumValueTable
argument_list|(
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|threeColumnEnumValueTable_
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"valuelist\">"
expr_stmt|;
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"even\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<th class=\"tblConst\">Constant</th>"
operator|<<
literal|"<th class=\"tblval\">Value</th>"
operator|<<
literal|"<th class=\"tbldscr\">Description</th></tr>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"valuelist\">"
operator|<<
literal|"<tr><th class=\"tblConst\">Constant</th><th class=\"tblVal\">Value</th></tr>\n"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<ol class="
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERALPHA
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"A\""
expr_stmt|;
block|}
comment|/* why type? changed to */
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERALPHA
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"a\""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_UPPERROMAN
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"I\""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_LOWERROMAN
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"\"i\""
expr_stmt|;
block|}
else|else
block|{
comment|// (atom->string() == ATOM_LIST_NUMERIC)
name|out
argument_list|()
operator|<<
literal|"\"1\""
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|next
argument_list|()
operator|!=
literal|0
operator|&&
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|!=
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|" start=\""
operator|<<
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
operator|<<
literal|'"'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|">\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListItemNumber
case|:
break|break;
case|case
name|Atom
operator|::
name|ListTagLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dt>"
expr_stmt|;
block|}
else|else
block|{
comment|// (atom->string() == ATOM_LIST_VALUE)
comment|// ### Trenton
name|QString
name|t
init|=
name|protectEnc
argument_list|(
name|plainCode
argument_list|(
name|marker
operator|->
name|markedUpEnumValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|,
name|relative
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"topAlign\"><tt>"
operator|<<
name|t
operator|<<
literal|"</tt></td><td class=\"topAlign\">"
expr_stmt|;
name|QString
name|itemValue
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|itemValue
operator|=
name|enume
operator|->
name|itemValue
argument_list|(
name|atom
operator|->
name|next
argument_list|()
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemValue
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|'?'
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tt>"
operator|<<
name|protectEnc
argument_list|(
name|itemValue
argument_list|)
operator|<<
literal|"</tt>"
expr_stmt|;
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListTagRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
name|out
argument_list|()
operator|<<
literal|"</dt>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ListItemLeft
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<dd>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
if|if
condition|(
name|threeColumnEnumValueTable_
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</td><td class=\"topAlign\">"
expr_stmt|;
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ListItemRight
argument_list|)
condition|)
name|out
argument_list|()
operator|<<
literal|"&nbsp;"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ListItemRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</dd>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|ListRight
case|:
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_BULLET
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_TAG
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ol>\n"
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|Nop
case|:
break|break;
case|case
name|Atom
operator|::
name|ParaLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|in_para
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|ParaRight
case|:
name|endLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
comment|//if (!matchAhead(atom, Atom::ListItemRight)&& !matchAhead(atom, Atom::TableItemRight))
comment|//    out()<< "</p>\n";
break|break;
case|case
name|Atom
operator|::
name|QuotationLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<blockquote>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|QuotationRight
case|:
name|out
argument_list|()
operator|<<
literal|"</blockquote>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|RawString
case|:
name|out
argument_list|()
operator|<<
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionRight
case|:
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<h"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|hOffset
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|inSectionHeading_
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SectionHeadingRight
case|:
name|out
argument_list|()
operator|<<
literal|"</h"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|hOffset
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|+
literal|">\n"
expr_stmt|;
name|inSectionHeading_
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|SidebarLeft
case|:
break|break;
case|case
name|Atom
operator|::
name|SidebarRight
case|:
break|break;
case|case
name|Atom
operator|::
name|String
case|:
if|if
condition|(
name|inLink_
operator|&&
operator|!
name|inContents_
operator|&&
operator|!
name|inSectionHeading_
condition|)
block|{
name|generateLink
argument_list|(
name|atom
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableLeft
case|:
block|{
name|QString
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|QString
name|attr
init|=
literal|"generic"
decl_stmt|;
name|QString
name|width
decl_stmt|;
if|if
condition|(
name|in_para
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"</p>\n"
expr_stmt|;
name|in_para
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p1
operator|=
name|atom
operator|->
name|string
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|count
argument_list|()
operator|>
literal|1
condition|)
name|p2
operator|=
name|atom
operator|->
name|string
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|p1
operator|==
literal|"borderless"
condition|)
name|attr
operator|=
name|p1
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|.
name|contains
argument_list|(
literal|"%"
argument_list|)
condition|)
name|width
operator|=
name|p1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|p2
operator|==
literal|"borderless"
condition|)
name|attr
operator|=
name|p2
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|.
name|contains
argument_list|(
literal|"%"
argument_list|)
condition|)
name|width
operator|=
name|p2
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<table class=\""
operator|<<
name|attr
operator|<<
literal|"\""
expr_stmt|;
if|if
condition|(
operator|!
name|width
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|" width=\""
operator|<<
name|width
operator|<<
literal|"\""
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|">\n "
expr_stmt|;
name|numTableRows_
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRight
case|:
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderLeft
case|:
name|out
argument_list|()
operator|<<
literal|"<thead><tr class=\"qt-style\">"
expr_stmt|;
name|inTableHeader_
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableHeaderRight
case|:
name|out
argument_list|()
operator|<<
literal|"</tr>"
expr_stmt|;
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|TableHeaderLeft
argument_list|)
condition|)
block|{
name|skipAhead
operator|=
literal|1
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"\n<tr class=\"qt-style\">"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</thead>\n"
expr_stmt|;
name|inTableHeader_
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableRowLeft
case|:
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr "
operator|<<
name|atom
operator|->
name|string
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"even\">"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableRowRight
case|:
name|out
argument_list|()
operator|<<
literal|"</tr>\n"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableItemLeft
case|:
block|{
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|"<th "
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<td "
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atom
operator|->
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|QString
name|p
init|=
name|atom
operator|->
name|string
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
name|p
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|spans
init|=
name|p
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|spans
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|spans
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|"1"
condition|)
name|out
argument_list|()
operator|<<
literal|" colspan=\""
operator|<<
name|spans
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
if|if
condition|(
name|spans
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|!=
literal|"1"
condition|)
name|out
argument_list|()
operator|<<
literal|" rowspan=\""
operator|<<
name|spans
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|<<
literal|'"'
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|'>'
expr_stmt|;
comment|//out()<< "><p>";
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Atom
operator|::
name|TableItemRight
case|:
if|if
condition|(
name|inTableHeader_
condition|)
name|out
argument_list|()
operator|<<
literal|"</th>"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</td>"
expr_stmt|;
comment|//out()<< "</p></td>";
block|}
if|if
condition|(
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ParaLeft
argument_list|)
condition|)
name|skipAhead
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|TableOfContents
case|:
break|break;
case|case
name|Atom
operator|::
name|Target
case|:
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|UnhandledFormat
case|:
name|out
argument_list|()
operator|<<
literal|"<b class=\"redFont\">&lt;Missing HTML&gt;</b>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|UnknownCommand
case|:
name|out
argument_list|()
operator|<<
literal|"<b class=\"redFont\"><code>\\"
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|<<
literal|"</code></b>"
expr_stmt|;
break|break;
case|case
name|Atom
operator|::
name|QmlText
case|:
case|case
name|Atom
operator|::
name|EndQmlText
case|:
comment|// don't do anything with these. They are just tags.
break|break;
default|default:
name|unknownAtom
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
return|return
name|skipAhead
return|;
block|}
end_function
begin_comment
comment|/*!   Generate a reference page for a C++ class or a C++ namespace.  */
end_comment
begin_function
DECL|function|generateClassLikeNode
name|void
name|HtmlGenerator
operator|::
name|generateClassLikeNode
parameter_list|(
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|QString
name|title
decl_stmt|;
name|QString
name|rawTitle
decl_stmt|;
name|QString
name|fullTitle
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|rawTitle
operator|=
name|inner
operator|->
name|plainName
argument_list|()
expr_stmt|;
name|fullTitle
operator|=
name|inner
operator|->
name|plainFullName
argument_list|()
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Namespace"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|rawTitle
operator|=
name|inner
operator|->
name|plainName
argument_list|()
expr_stmt|;
name|fullTitle
operator|=
name|inner
operator|->
name|plainFullName
argument_list|()
expr_stmt|;
name|title
operator|=
name|rawTitle
operator|+
literal|" Class"
expr_stmt|;
block|}
name|Text
name|subtitleText
decl_stmt|;
if|if
condition|(
name|rawTitle
operator|!=
name|fullTitle
condition|)
name|subtitleText
operator|<<
literal|"("
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|fullTitle
argument_list|)
operator|<<
literal|")"
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LineBreak
argument_list|)
expr_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|generateTableOfContents
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
operator|&
name|sections
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|subtitleText
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateRequisites
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|QString
name|membersLink
init|=
name|generateListOfAllMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|membersLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|membersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|QString
name|obsoleteLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obsoleteLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|obsoleteLink
operator|<<
literal|"\">"
operator|<<
literal|"Obsolete members</a></li>\n"
expr_stmt|;
block|}
name|QString
name|compatLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compatLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|compatLink
operator|<<
literal|"\">"
operator|<<
literal|"Compatibility members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|bool
name|needOtherSection
init|=
literal|false
decl_stmt|;
comment|/*       sections is built above for the call to generateTableOfContents().      */
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|needOtherSection
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|"\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|s
operator|->
name|members
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|QString
argument_list|(
literal|"Reimplemented "
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|name
decl_stmt|;
comment|//  out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|"\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSection
argument_list|(
name|s
operator|->
name|reimpMembers
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|needOtherSection
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h3>Additional Inherited Members</h3>\n"
literal|"<ul>\n"
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|s
operator|->
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
name|generateSectionInheritedList
argument_list|(
operator|*
name|s
argument_list|,
name|inner
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|!
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|inner
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
comment|//out()<< "<hr />\n"
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\">\n"
comment|// QTBUG-9504
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateBody
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateMaintainerList
argument_list|(
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|inner
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|//out()<< "<hr />\n";
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<div class=\""
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|<<
literal|"\">\n"
expr_stmt|;
comment|// QTBUG-9504
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
comment|// ### check necessary?
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Class
condition|)
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<h3> class "
expr_stmt|;
name|generateFullName
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>"
expr_stmt|;
name|generateBrief
argument_list|(
operator|*
name|m
argument_list|,
name|marker
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
name|QStringList
name|names
decl_stmt|;
name|names
operator|<<
operator|(
operator|*
name|m
operator|)
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Ctor
operator|||
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
operator|||
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|names
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
specifier|const
name|PropertyNode
modifier|*
name|prop
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|names
operator|.
name|contains
argument_list|(
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
condition|)
name|names
operator|<<
name|prop
operator|->
name|getters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|setters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|setters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|resetters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|resetters
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prop
operator|->
name|notifiers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|names
operator|<<
name|prop
operator|->
name|notifiers
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|enume
operator|->
name|flagsType
argument_list|()
condition|)
name|names
operator|<<
name|enume
operator|->
name|flagsType
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|enumName
decl|,
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|enumItemNames
argument_list|()
operator|.
name|toSet
argument_list|()
operator|-
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|omitEnumItemNames
argument_list|()
operator|.
name|toSet
argument_list|()
control|)
name|names
operator|<<
name|plainCode
argument_list|(
name|marker
operator|->
name|markedUpEnumValue
argument_list|(
name|enumName
argument_list|,
name|enume
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|divClass
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generate the HTML page for a QML type. \qcn is the QML type.   \marker is the code markeup object.  */
end_comment
begin_function
DECL|function|generateQmlTypePage
name|void
name|HtmlGenerator
operator|::
name|generateQmlTypePage
parameter_list|(
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|SubTitleSize
name|subTitleSize
init|=
name|LargeSubTitle
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|fullTitle
init|=
name|qcn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|QString
name|htmlTitle
init|=
name|fullTitle
decl_stmt|;
name|generateHeader
argument_list|(
name|htmlTitle
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
init|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qcn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
decl_stmt|;
name|generateTableOfContents
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|,
operator|&
name|sections
argument_list|)
expr_stmt|;
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|fullTitle
argument_list|,
name|Text
argument_list|()
operator|<<
name|qcn
operator|->
name|subTitle
argument_list|()
argument_list|,
name|subTitleSize
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBrief
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateQmlRequisites
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|QString
name|allQmlMembersLink
init|=
name|generateAllQmlMembersFile
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allQmlMembersLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|allQmlMembersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateQmlSummary
argument_list|(
operator|*
name|s
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|generateExtractionMark
argument_list|(
name|qcn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateBody
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
condition|)
name|generateQmlText
argument_list|(
name|cn
operator|->
name|doc
argument_list|()
operator|.
name|body
argument_list|()
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|qcn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
comment|//out()<< "<hr />\n";
name|sections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qcn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|generateDetailedQmlMember
argument_list|(
operator|*
name|m
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>\n"
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generate the HTML page for the QML basic type represented   by the QML basic type node \a qbtn.  */
end_comment
begin_function
DECL|function|generateQmlBasicTypePage
name|void
name|HtmlGenerator
operator|::
name|generateQmlBasicTypePage
parameter_list|(
name|QmlBasicTypeNode
modifier|*
name|qbtn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|SubTitleSize
name|subTitleSize
init|=
name|LargeSubTitle
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|htmlTitle
init|=
name|qbtn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|QString
name|fullTitle
init|=
literal|"QML Basic Type: "
operator|+
name|htmlTitle
decl_stmt|;
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
name|generateHeader
argument_list|(
name|htmlTitle
argument_list|,
name|qbtn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|fullTitle
argument_list|,
name|Text
argument_list|()
operator|<<
name|qbtn
operator|->
name|subTitle
argument_list|()
argument_list|,
name|subTitleSize
argument_list|,
name|qbtn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|qbtn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\"><a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateBody
argument_list|(
name|qbtn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|qbtn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|qbtn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
name|generateFooter
argument_list|(
name|qbtn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   We delayed generation of the disambiguation pages until now, after   all the other pages have been generated. We do this because we might   encounter a link command that tries to link to a target on a QML   component page, but the link doesn't specify the module identifer   for the component, and the component name without a module   identifier is ambiguous. When such a link is found, qdoc can't find   the target, so it appends the target to the NameCollisionNode. After   the tree has been traversed and all these ambiguous links have been   added to the name collision nodes, this function is called. The list   of collision nodes is traversed here, and the disambiguation page for   each collision is generated. The disambiguation page will not only   disambiguate links to the component pages, but it will also disambiguate   links to properties, section headers, etc.  */
end_comment
begin_function
DECL|function|generateCollisionPages
name|void
name|HtmlGenerator
operator|::
name|generateCollisionPages
parameter_list|()
block|{
if|if
condition|(
name|collisionNodes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisionNodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
name|collisionNodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ncn
condition|)
continue|continue;
name|NodeList
name|collisions
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|nl
init|=
name|ncn
operator|->
name|childNodes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|it
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|->
name|isInternal
argument_list|()
condition|)
name|collisions
operator|.
name|append
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
if|if
condition|(
name|collisions
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
continue|continue;
name|beginSubPage
argument_list|(
name|ncn
argument_list|,
name|Generator
operator|::
name|fileName
argument_list|(
name|ncn
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|fullTitle
init|=
name|ncn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|ncn
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
operator|->
name|isQmlNode
argument_list|()
condition|)
block|{
comment|// Replace the marker with a QML code marker.
if|if
condition|(
name|ncn
operator|->
name|isQmlNode
argument_list|()
condition|)
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generateHeader
argument_list|(
name|fullTitle
argument_list|,
name|ncn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullTitle
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<h1 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
name|fullTitle
argument_list|)
operator|<<
literal|"</h1>\n"
expr_stmt|;
name|NodeMap
name|nm
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|t
operator|=
name|n
operator|->
name|qmlModuleName
argument_list|()
operator|+
literal|"::"
expr_stmt|;
name|t
operator|+=
name|protectEnc
argument_list|(
name|fullTitle
argument_list|)
expr_stmt|;
name|nm
operator|.
name|insertMulti
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|generateAnnotatedList
argument_list|(
name|ncn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QString
argument_list|>
name|targets
decl_stmt|;
if|if
condition|(
operator|!
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|ConstIterator
name|t
init|=
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|ncn
operator|->
name|linkTargets
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|findChildNode
argument_list|(
name|t
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|targets
operator|.
name|append
argument_list|(
name|t
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|++
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|targets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|t
init|=
name|targets
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|targets
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
operator|*
name|t
argument_list|)
operator|<<
literal|"\"></a>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
operator|*
name|t
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|collisions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|InnerNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|collisions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|p
init|=
name|n
operator|->
name|findChildNode
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QString
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|label
operator|=
name|n
operator|->
name|qmlModuleName
argument_list|()
operator|+
literal|"::"
expr_stmt|;
name|label
operator|+=
name|n
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|p
operator|->
name|name
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|label
argument_list|)
operator|<<
literal|"</a>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
name|generateFooter
argument_list|(
name|ncn
argument_list|)
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate the HTML page for an entity that doesn't map   to any underlying parsable C++ class or QML component.  */
end_comment
begin_function
DECL|function|generateDocNode
name|void
name|HtmlGenerator
operator|::
name|generateDocNode
parameter_list|(
name|DocNode
modifier|*
name|dn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
comment|/*       If the document node is a page node, and if the page type       is DITA map page, write the node's contents as a dita       map and return without doing anything else.      */
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
operator|&&
name|dn
operator|->
name|pageType
argument_list|()
operator|==
name|Node
operator|::
name|DitaMapPage
condition|)
block|{
specifier|const
name|DitaMapNode
modifier|*
name|dmn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DitaMapNode
operator|*
argument_list|>
argument_list|(
name|dn
argument_list|)
decl_stmt|;
name|writeDitaMap
argument_list|(
name|dmn
argument_list|)
expr_stmt|;
return|return;
block|}
name|SubTitleSize
name|subTitleSize
init|=
name|LargeSubTitle
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|fullTitle
init|=
name|dn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|generateHeader
argument_list|(
name|fullTitle
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
comment|/*       Generate the TOC for the new doc format.       Don't generate a TOC for the home page.     */
if|if
condition|(
operator|(
name|dn
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Collision
operator|)
operator|&&
operator|(
name|dn
operator|->
name|name
argument_list|()
operator|!=
name|QString
argument_list|(
literal|"index.html"
argument_list|)
operator|)
operator|&&
operator|(
name|dn
operator|->
name|name
argument_list|()
operator|!=
name|QString
argument_list|(
literal|"qtexamplesandtutorials.html"
argument_list|)
operator|)
condition|)
name|generateTableOfContents
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|fullTitle
argument_list|,
name|Text
argument_list|()
operator|<<
name|dn
operator|->
name|subTitle
argument_list|()
argument_list|,
name|subTitleSize
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|HeaderFile
condition|)
block|{
comment|// Generate brief text and status for modules.
name|generateBrief
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|QString
name|membersLink
init|=
name|generateListOfAllMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|membersLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|membersLink
operator|<<
literal|"\">"
operator|<<
literal|"List of all members, including inherited members</a></li>\n"
expr_stmt|;
name|QString
name|obsoleteLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Obsolete
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obsoleteLink
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|obsoleteLink
operator|<<
literal|"\">"
operator|<<
literal|"Obsolete members</a></li>\n"
expr_stmt|;
block|}
name|QString
name|compatLink
init|=
name|generateLowStatusMemberFile
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Compat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compatLink
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<li><a href=\""
operator|<<
name|compatLink
operator|<<
literal|"\">"
operator|<<
literal|"Compatibility members</a></li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|dn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
operator|*
name|s
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\"><a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateBody
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|dn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|dn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|//out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|dn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generate the HTML page for a group, module, or QML module.  */
end_comment
begin_function
DECL|function|generateCollectionNode
name|void
name|HtmlGenerator
operator|::
name|generateCollectionNode
parameter_list|(
name|CollectionNode
modifier|*
name|cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|SubTitleSize
name|subTitleSize
init|=
name|LargeSubTitle
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|const_iterator
name|s
decl_stmt|;
name|QString
name|fullTitle
init|=
name|cn
operator|->
name|fullTitle
argument_list|()
decl_stmt|;
name|QString
name|htmlTitle
init|=
name|fullTitle
decl_stmt|;
name|generateHeader
argument_list|(
name|htmlTitle
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTableOfContents
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|fullTitle
argument_list|,
name|Text
argument_list|()
operator|<<
name|cn
operator|->
name|subTitle
argument_list|()
argument_list|,
name|subTitleSize
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|isModule
argument_list|()
condition|)
block|{
comment|// Generate brief text and status for modules.
name|generateBrief
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateStatus
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|NodeMap
name|nm
decl_stmt|;
name|cn
operator|->
name|getMemberNamespaces
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"namespaces"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>Namespaces</h2>\n"
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
name|nm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cn
operator|->
name|getMemberClasses
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"classes"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>Classes</h2>\n"
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
name|nm
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|cn
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
operator|*
name|s
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|Text
name|brief
init|=
name|cn
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|->
name|isModule
argument_list|()
operator|&&
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|cn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\">\n"
expr_stmt|;
comment|// QTBUG-9504
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
literal|"Detailed Description"
operator|<<
literal|"</h2>\n"
expr_stmt|;
block|}
else|else
block|{
name|generateExtractionMark
argument_list|(
name|cn
argument_list|,
name|DetailedDescriptionMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"descr\"><a name=\""
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\"></a>\n"
expr_stmt|;
comment|// QTBUG-9504
block|}
name|generateBody
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
comment|// QTBUG-9504
name|generateAlsoList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|cn
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|isGroup
argument_list|()
condition|)
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|cn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cn
operator|->
name|isQmlModule
argument_list|()
condition|)
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|cn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|cn
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
name|s
operator|=
name|sections
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|//out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
operator|(
operator|*
name|s
operator|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|generateFooter
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns "html" for this subclass of Generator.  */
end_comment
begin_function
DECL|function|fileExtension
name|QString
name|HtmlGenerator
operator|::
name|fileExtension
parameter_list|()
specifier|const
block|{
return|return
literal|"html"
return|;
block|}
end_function
begin_comment
comment|/*!   Output navigation list in the html file.  */
end_comment
begin_function
DECL|function|generateNavigationBar
name|void
name|HtmlGenerator
operator|::
name|generateNavigationBar
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|noNavigationBar
condition|)
return|return;
name|Text
name|navigationbar
decl_stmt|;
if|if
condition|(
name|homepage
operator|==
name|title
condition|)
return|return;
if|if
condition|(
operator|!
name|homepage
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|homepage
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|landingpage
operator|.
name|isEmpty
argument_list|()
operator|&&
name|landingpage
operator|!=
name|title
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|landingpage
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isClass
argument_list|()
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|node
operator|->
name|moduleName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cppclassespage
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|cppclassespage
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"C++ Classes"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|qmltypespage
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|qmltypespage
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"QML Types"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|isQmlBasicType
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|qmltypespage
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|qmltypespage
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QLatin1String
argument_list|(
literal|"QML Types"
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|isDocNode
argument_list|()
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|&&
name|dn
operator|->
name|isExampleFile
argument_list|()
condition|)
block|{
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|dn
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|dn
operator|->
name|parent
argument_list|()
operator|->
name|title
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
name|navigationbar
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|title
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|)
expr_stmt|;
block|}
name|generateText
argument_list|(
name|navigationbar
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateHeader
name|void
name|HtmlGenerator
operator|::
name|generateHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<?xml version=\"1.0\" encoding=\"%1\"?>\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|outputEncoding
argument_list|)
expr_stmt|;
else|#
directive|else
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<?xml version=\"1.0\"?>\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
argument_list|()
operator|<<
literal|"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"%1\" lang=\"%1\">\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|naturalLanguage
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<head>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n"
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<!-- "
operator|<<
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
operator|<<
literal|" -->\n"
expr_stmt|;
name|QString
name|shortVersion
init|=
name|qdb_
operator|->
name|version
argument_list|()
decl_stmt|;
if|if
condition|(
name|shortVersion
operator|.
name|count
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|==
literal|2
condition|)
name|shortVersion
operator|.
name|truncate
argument_list|(
name|shortVersion
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|project
operator|.
name|isEmpty
argument_list|()
condition|)
name|shortVersion
operator|=
name|QLatin1String
argument_list|(
literal|" | "
argument_list|)
operator|+
name|project
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|shortVersion
expr_stmt|;
else|else
name|shortVersion
operator|=
name|QLatin1String
argument_list|(
literal|" | "
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"Qt "
argument_list|)
operator|+
name|shortVersion
expr_stmt|;
comment|// Generating page title
name|out
argument_list|()
operator|<<
literal|"<title>"
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
name|shortVersion
operator|<<
literal|"</title>\n"
expr_stmt|;
comment|// Include style sheet and script links.
name|out
argument_list|()
operator|<<
name|headerStyles
expr_stmt|;
name|out
argument_list|()
operator|<<
name|headerScripts
expr_stmt|;
if|if
condition|(
name|endHeader
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"</head>\n<body>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
name|endHeader
expr_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
if|if
condition|(
name|mainPage
condition|)
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|postHeader
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|generateNavigationBar
argument_list|(
name|title
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li id=\"buildversion\">\n"
operator|<<
name|buildversion
operator|<<
literal|"</li>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|postPostHeader
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|navigationLinks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|linkPair
decl_stmt|;
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|anchorPair
decl_stmt|;
specifier|const
name|Node
modifier|*
name|linkNode
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|PreviousLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|PreviousLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"prev\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
name|navigationLinks
operator|+=
literal|"<a class=\"prevPage\" href=\""
operator|+
name|anchorPair
operator|.
name|first
operator|+
literal|"\">"
expr_stmt|;
if|if
condition|(
name|linkPair
operator|.
name|first
operator|==
name|linkPair
operator|.
name|second
operator|&&
operator|!
name|anchorPair
operator|.
name|second
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|anchorPair
operator|.
name|second
argument_list|)
expr_stmt|;
else|else
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|linkPair
operator|.
name|second
argument_list|)
expr_stmt|;
name|navigationLinks
operator|+=
literal|"</a>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|NextLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|NextLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"next\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
name|navigationLinks
operator|+=
literal|"<a class=\"nextPage\" href=\""
operator|+
name|anchorPair
operator|.
name|first
operator|+
literal|"\">"
expr_stmt|;
if|if
condition|(
name|linkPair
operator|.
name|first
operator|==
name|linkPair
operator|.
name|second
operator|&&
operator|!
name|anchorPair
operator|.
name|second
operator|.
name|isEmpty
argument_list|()
condition|)
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|anchorPair
operator|.
name|second
argument_list|)
expr_stmt|;
else|else
name|navigationLinks
operator|+=
name|protect
argument_list|(
name|linkPair
operator|.
name|second
argument_list|)
expr_stmt|;
name|navigationLinks
operator|+=
literal|"</a>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|links
argument_list|()
operator|.
name|contains
argument_list|(
name|Node
operator|::
name|StartLink
argument_list|)
condition|)
block|{
name|linkPair
operator|=
name|node
operator|->
name|links
argument_list|()
index|[
name|Node
operator|::
name|StartLink
index|]
expr_stmt|;
name|linkNode
operator|=
name|qdb_
operator|->
name|findNodeForTarget
argument_list|(
name|linkPair
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
condition|)
name|node
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot link to '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|linkPair
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkNode
operator|||
name|linkNode
operator|==
name|node
condition|)
name|anchorPair
operator|=
name|linkPair
expr_stmt|;
else|else
name|anchorPair
operator|=
name|anchorForNode
argument_list|(
name|linkNode
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<link rel=\"start\" href=\""
operator|<<
name|anchorPair
operator|.
name|first
operator|<<
literal|"\" />\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"naviNextPrevious headerNavi\">\n"
operator|<<
name|navigationLinks
operator|<<
literal|"</p><p/>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateTitle
name|void
name|HtmlGenerator
operator|::
name|generateTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Text
modifier|&
name|subTitle
parameter_list|,
name|SubTitleSize
name|subTitleSize
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<h1 class=\"title\">"
operator|<<
name|protectEnc
argument_list|(
name|title
argument_list|)
operator|<<
literal|"</h1>\n"
expr_stmt|;
if|if
condition|(
operator|!
name|subTitle
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<span"
expr_stmt|;
if|if
condition|(
name|subTitleSize
operator|==
name|SmallSubTitle
condition|)
name|out
argument_list|()
operator|<<
literal|" class=\"small-subtitle\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|" class=\"subtitle\">"
expr_stmt|;
name|generateText
argument_list|(
name|subTitle
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</span>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFooter
name|void
name|HtmlGenerator
operator|::
name|generateFooter
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|links
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<p class=\"naviNextPrevious footerNavi\">\n"
operator|<<
name|navigationLinks
operator|<<
literal|"</p>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
name|footer
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
operator|<<
name|QString
argument_list|(
name|address
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\\"
operator|+
name|COMMAND_VERSION
argument_list|,
name|qdb_
operator|->
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</body>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</html>\n"
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Lists the required imports and includes in a table. The number of rows is known, so this path is simpler than the generateSection() path. */
end_comment
begin_function
DECL|function|generateRequisites
name|void
name|HtmlGenerator
operator|::
name|generateRequisites
parameter_list|(
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Text
argument_list|>
name|requisites
decl_stmt|;
name|Text
name|text
decl_stmt|;
specifier|const
name|QString
name|headerText
init|=
literal|"Header"
decl_stmt|;
specifier|const
name|QString
name|sinceText
init|=
literal|"Since"
decl_stmt|;
specifier|const
name|QString
name|inheritedBytext
init|=
literal|"Inherited By"
decl_stmt|;
specifier|const
name|QString
name|inheritsText
init|=
literal|"Inherits"
decl_stmt|;
specifier|const
name|QString
name|instantiatedByText
init|=
literal|"Instantiated By"
decl_stmt|;
specifier|const
name|QString
name|qtVariableText
init|=
literal|"qmake"
decl_stmt|;
comment|//add the includes to the map
if|if
condition|(
operator|!
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
operator|<<
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|marker
operator|->
name|markedUpIncludes
argument_list|(
name|inner
operator|->
name|includes
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|headerText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//The order of the requisites matter
name|QStringList
name|requisiteorder
decl_stmt|;
name|requisiteorder
operator|<<
name|headerText
operator|<<
name|qtVariableText
operator|<<
name|sinceText
operator|<<
name|instantiatedByText
operator|<<
name|inheritsText
operator|<<
name|inheritedBytext
expr_stmt|;
comment|//add the since and project into the map
if|if
condition|(
operator|!
name|inner
operator|->
name|since
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QStringList
name|since
init|=
name|inner
operator|->
name|since
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|since
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If there is only one argument, assume it is the Qt version number.
name|text
operator|<<
literal|" Qt "
operator|<<
name|since
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//Otherwise, reconstruct the<project><version> string.
name|text
operator|<<
literal|" "
operator|<<
name|since
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|sinceText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|||
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
comment|//add the QT variable to the map
if|if
condition|(
operator|!
name|inner
operator|->
name|moduleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ModuleNode
modifier|*
name|moduleNode
init|=
name|qdb_
operator|->
name|findModule
argument_list|(
name|inner
operator|->
name|moduleName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|moduleNode
operator|&&
operator|!
name|moduleNode
operator|->
name|qtVariable
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_TELETYPE
argument_list|)
operator|<<
literal|"QT += "
operator|+
name|moduleNode
operator|->
name|qtVariable
argument_list|()
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_TELETYPE
argument_list|)
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|qtVariableText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|ClassNode
modifier|*
name|classe
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|classe
operator|->
name|qmlElement
argument_list|()
operator|!=
literal|0
operator|&&
name|classe
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|classe
operator|->
name|qmlElement
argument_list|()
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|classe
operator|->
name|qmlElement
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|instantiatedByText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//add the inherits to the map
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|r
operator|=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
condition|)
block|{
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
operator|(
operator|*
name|r
operator|)
operator|.
name|signature_
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|access_
operator|==
name|Node
operator|::
name|Protected
condition|)
block|{
name|text
operator|<<
literal|" (protected)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|access_
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|text
operator|<<
literal|" (private)"
expr_stmt|;
block|}
name|text
operator|<<
name|separator
argument_list|(
name|index
operator|++
argument_list|,
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|inheritsText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//add the inherited-by to the map
if|if
condition|(
operator|!
name|classe
operator|->
name|derivedClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|appendSortedNames
argument_list|(
name|text
argument_list|,
name|classe
argument_list|,
name|classe
operator|->
name|derivedClasses
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|inheritedBytext
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|requisites
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//generate the table
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|requisiteorder
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|requisiteorder
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|requisites
operator|.
name|contains
argument_list|(
operator|*
name|i
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr>"
operator|<<
literal|"<td class=\"memItemLeft rightAlign topAlign\"> "
operator|<<
operator|*
name|i
operator|<<
literal|":"
operator|<<
literal|"</td><td class=\"memItemRight bottomAlign\"> "
expr_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
name|headerText
condition|)
name|out
argument_list|()
operator|<<
name|requisites
operator|.
name|value
argument_list|(
operator|*
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
else|else
name|generateText
argument_list|(
name|requisites
operator|.
name|value
argument_list|(
operator|*
name|i
argument_list|)
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</td></tr>"
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! Lists the required imports and includes in a table. The number of rows is known, so this path is simpler than the generateSection() path. */
end_comment
begin_function
DECL|function|generateQmlRequisites
name|void
name|HtmlGenerator
operator|::
name|generateQmlRequisites
parameter_list|(
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcn
condition|)
return|return;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Text
argument_list|>
name|requisites
decl_stmt|;
name|Text
name|text
decl_stmt|;
specifier|const
name|QString
name|importText
init|=
literal|"Import Statement:"
decl_stmt|;
specifier|const
name|QString
name|sinceText
init|=
literal|"Since:"
decl_stmt|;
specifier|const
name|QString
name|inheritedBytext
init|=
literal|"Inherited By:"
decl_stmt|;
specifier|const
name|QString
name|inheritsText
init|=
literal|"Inherits:"
decl_stmt|;
specifier|const
name|QString
name|instantiatesText
init|=
literal|"Instantiates:"
decl_stmt|;
comment|//The order of the requisites matter
name|QStringList
name|requisiteorder
decl_stmt|;
name|requisiteorder
operator|<<
name|importText
operator|<<
name|sinceText
operator|<<
name|instantiatesText
operator|<<
name|inheritsText
operator|<<
name|inheritedBytext
expr_stmt|;
comment|//add the module name and version to the map
name|QString
name|qmlModuleVersion
decl_stmt|;
name|QmlModuleNode
modifier|*
name|qmn
init|=
name|qdb_
operator|->
name|findQmlModule
argument_list|(
name|qcn
operator|->
name|qmlModuleName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmn
condition|)
name|qmlModuleVersion
operator|=
name|qmn
operator|->
name|qmlModuleVersion
argument_list|()
expr_stmt|;
else|else
name|qmlModuleVersion
operator|=
name|qcn
operator|->
name|qmlModuleVersion
argument_list|()
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_BOLD
index|]
operator|<<
name|formattingLeftMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
operator|<<
literal|"import "
operator|+
name|qcn
operator|->
name|qmlModuleName
argument_list|()
operator|+
literal|" "
operator|+
name|qmlModuleVersion
operator|<<
name|formattingRightMap
argument_list|()
index|[
name|ATOM_FORMATTING_TELETYPE
index|]
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|importText
argument_list|,
name|text
argument_list|)
expr_stmt|;
comment|//add the since and project into the map
if|if
condition|(
operator|!
name|qcn
operator|->
name|since
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QStringList
name|since
init|=
name|qcn
operator|->
name|since
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|since
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If there is only one argument, assume it is the Qt version number.
name|text
operator|<<
literal|" Qt "
operator|<<
name|since
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//Otherwise, reconstruct the<project><version> string.
name|text
operator|<<
literal|" "
operator|<<
name|since
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|sinceText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//add the instantiates to the map
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
operator|(
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|instantiatesText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//add the inherits to the map
name|QmlClassNode
modifier|*
name|base
init|=
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
decl_stmt|;
while|while
condition|(
name|base
operator|&&
name|base
operator|->
name|isInternal
argument_list|()
condition|)
block|{
name|base
operator|=
name|base
operator|->
name|qmlBaseNode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|base
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|base
argument_list|)
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|base
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|inheritsText
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|//add the inherited-by to the map
name|NodeList
name|subs
decl_stmt|;
name|QmlClassNode
operator|::
name|subclasses
argument_list|(
name|qcn
operator|->
name|name
argument_list|()
argument_list|,
name|subs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|appendSortedQmlNames
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|subs
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|requisites
operator|.
name|insert
argument_list|(
name|inheritedBytext
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|requisites
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//generate the table
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|requisiteorder
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|requisiteorder
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|requisites
operator|.
name|contains
argument_list|(
operator|*
name|i
argument_list|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr>"
operator|<<
literal|"<td class=\"memItemLeft rightAlign topAlign\"> "
operator|<<
operator|*
name|i
operator|<<
literal|"</td><td class=\"memItemRight bottomAlign\"> "
expr_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
name|importText
condition|)
name|out
argument_list|()
operator|<<
name|requisites
operator|.
name|value
argument_list|(
operator|*
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
else|else
name|generateText
argument_list|(
name|requisites
operator|.
name|value
argument_list|(
operator|*
name|i
argument_list|)
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</td></tr>"
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateBrief
name|void
name|HtmlGenerator
operator|::
name|generateBrief
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|BriefMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>"
expr_stmt|;
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relative
operator|||
name|node
operator|==
name|relative
condition|)
name|out
argument_list|()
operator|<<
literal|"<a href=\"#"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
operator|<<
literal|'#'
expr_stmt|;
name|out
argument_list|()
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">More...</a></p>\n"
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateIncludes
name|void
name|HtmlGenerator
operator|::
name|generateIncludes
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inner
operator|->
name|includes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<pre class=\"cpp\">"
operator|<<
name|trimmedTrailing
argument_list|(
name|highlightedCode
argument_list|(
name|indent
argument_list|(
name|codeIndent
argument_list|,
name|marker
operator|->
name|markedUpIncludes
argument_list|(
name|inner
operator|->
name|includes
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
argument_list|)
operator|<<
literal|"</pre>"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Revised for the new doc format.   Generates a table of contents beginning at \a node.  */
end_comment
begin_function
DECL|function|generateTableOfContents
name|void
name|HtmlGenerator
operator|::
name|generateTableOfContents
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|QList
argument_list|<
name|Section
argument_list|>
modifier|*
name|sections
parameter_list|)
block|{
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|toc
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
name|toc
operator|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
expr_stmt|;
if|if
condition|(
name|toc
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|sections
operator|&&
operator|!
name|node
operator|->
name|isModule
argument_list|()
condition|)
return|return;
comment|//turn off table of contents if HTML.tocdepth is set to 0
if|if
condition|(
name|tocDepth
operator|==
literal|0
condition|)
return|return;
name|QStringList
name|sectionNumber
decl_stmt|;
name|int
name|detailsBase
init|=
literal|0
decl_stmt|;
comment|// disable nested links in table of contents
name|inContents_
operator|=
literal|true
expr_stmt|;
name|inLink_
operator|=
literal|true
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"toc\">\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<h3><a name=\"toc\">Contents</a></h3>\n"
expr_stmt|;
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isModule
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|hasNamespaces
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"namespaces"
argument_list|)
operator|<<
literal|"\">Namespaces</a></li>\n"
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|hasClasses
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"classes"
argument_list|)
operator|<<
literal|"\">Classes</a></li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</a></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sections
operator|&&
operator|(
name|node
operator|->
name|isClass
argument_list|()
operator|||
name|node
operator|->
name|isNamespace
argument_list|()
operator|||
name|node
operator|->
name|isQmlType
argument_list|()
operator|)
condition|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|sections
operator|->
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|sections
operator|->
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|members
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|s
operator|->
name|reimpMembers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|pluralMember
argument_list|)
operator|<<
literal|"\">"
operator|<<
operator|(
operator|*
name|s
operator|)
operator|.
name|name
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\"><a href=\"#"
operator|<<
name|registerRef
argument_list|(
literal|"details"
argument_list|)
operator|<<
literal|"\">Detailed Description</a></li>\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
literal|1
condition|)
block|{
name|detailsBase
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|atom
init|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|nextLevel
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
name|detailsBase
decl_stmt|;
if|if
condition|(
name|nextLevel
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
block|{
do|do
block|{
name|sectionNumber
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<
name|nextLevel
condition|)
do|;
block|}
else|else
block|{
while|while
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|>
name|nextLevel
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|sectionNumber
operator|.
name|last
argument_list|()
operator|=
name|QString
operator|::
name|number
argument_list|(
name|sectionNumber
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|//restrict the ToC depth to the one set by the HTML.tocdepth variable or
comment|//print all levels if tocDepth is not set.
if|if
condition|(
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<=
name|tocDepth
operator|||
name|tocDepth
operator|<
literal|0
condition|)
block|{
name|int
name|numAtoms
decl_stmt|;
name|Text
name|headingText
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
decl_stmt|;
name|QString
name|s
init|=
name|headingText
operator|.
name|toString
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"level"
operator|<<
name|sectionNumber
operator|.
name|size
argument_list|()
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
literal|'#'
operator|<<
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|s
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
name|generateAtomList
argument_list|(
name|headingText
operator|.
name|firstAtom
argument_list|()
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|,
name|numAtoms
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a></li>\n"
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|sectionNumber
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sectionNumber
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
name|inContents_
operator|=
literal|false
expr_stmt|;
name|inLink_
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateListOfAllMemberFile
name|QString
name|HtmlGenerator
operator|::
name|generateListOfAllMemberFile
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|,
name|CodeMarker
operator|::
name|Okay
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fileName
init|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-members."
operator|+
name|fileExtension
argument_list|()
decl_stmt|;
name|beginSubPage
argument_list|(
name|inner
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
literal|"List of All Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
decl_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>This is the complete list of members for "
expr_stmt|;
name|generateFullName
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|", including inherited members.</p>\n"
expr_stmt|;
name|Section
name|section
init|=
name|sections
operator|.
name|first
argument_list|()
decl_stmt|;
name|generateSectionList
argument_list|(
name|section
argument_list|,
literal|0
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|)
expr_stmt|;
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_comment
comment|/*!   This function creates an html page on which are listed all   the members of QML class \a qml_cn, including the inherited   members. The \a marker is used for formatting stuff.  */
end_comment
begin_function
DECL|function|generateAllQmlMembersFile
name|QString
name|HtmlGenerator
operator|::
name|generateAllQmlMembersFile
parameter_list|(
name|QmlClassNode
modifier|*
name|qml_cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
name|QList
argument_list|<
name|Section
argument_list|>
operator|::
name|ConstIterator
name|s
decl_stmt|;
name|sections
operator|=
name|marker
operator|->
name|qmlSections
argument_list|(
name|qml_cn
argument_list|,
name|CodeMarker
operator|::
name|Subpage
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fileName
init|=
name|fileBase
argument_list|(
name|qml_cn
argument_list|)
operator|+
literal|"-members."
operator|+
name|fileExtension
argument_list|()
decl_stmt|;
name|beginSubPage
argument_list|(
name|qml_cn
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
literal|"List of All Members for "
operator|+
name|qml_cn
operator|->
name|name
argument_list|()
decl_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|qml_cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<p>This is the complete list of members for "
expr_stmt|;
name|generateFullName
argument_list|(
name|qml_cn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|", including inherited members.</p>\n"
expr_stmt|;
name|ClassKeysNodesList
modifier|&
name|cknl
init|=
name|sections
operator|.
name|first
argument_list|()
operator|.
name|classKeysNodesList_
decl_stmt|;
if|if
condition|(
operator|!
name|cknl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cknl
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ClassKeysNodes
modifier|*
name|ckn
init|=
name|cknl
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|ckn
operator|->
name|first
decl_stmt|;
name|KeysAndNodes
modifier|&
name|kn
init|=
name|ckn
operator|->
name|second
decl_stmt|;
name|QStringList
modifier|&
name|keys
init|=
name|kn
operator|.
name|first
decl_stmt|;
name|NodeList
modifier|&
name|nodes
init|=
name|kn
operator|.
name|second
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p>The following members are inherited from "
expr_stmt|;
name|generateFullName
argument_list|(
name|qcn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|".</p>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|j
index|]
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|nodes
index|[
name|j
index|]
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Internal
condition|)
block|{
continue|continue;
block|}
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|QString
name|prefix
decl_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|keys
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|prefix
operator|.
name|left
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"::"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|generateQmlItem
argument_list|(
name|nodes
index|[
name|j
index|]
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//generateSynopsis(nodes[j], qcn, marker, CodeMarker::Subpage, false,&prefix);
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|generateLowStatusMemberFile
name|QString
name|HtmlGenerator
operator|::
name|generateLowStatusMemberFile
parameter_list|(
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|Status
name|status
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
init|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|,
name|status
argument_list|)
decl_stmt|;
name|QMutableListIterator
argument_list|<
name|Section
argument_list|>
name|j
argument_list|(
name|sections
argument_list|)
decl_stmt|;
while|while
condition|(
name|j
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|next
argument_list|()
operator|.
name|members
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|j
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|i
decl_stmt|;
name|QString
name|title
decl_stmt|;
name|QString
name|fileName
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Compat
condition|)
block|{
name|title
operator|=
literal|"Compatibility Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
expr_stmt|;
name|fileName
operator|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-compat."
operator|+
name|fileExtension
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|title
operator|=
literal|"Obsolete Members for "
operator|+
name|inner
operator|->
name|name
argument_list|()
expr_stmt|;
name|fileName
operator|=
name|fileBase
argument_list|(
name|inner
argument_list|)
operator|+
literal|"-obsolete."
operator|+
name|fileExtension
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Obsolete
condition|)
block|{
name|QString
name|link
decl_stmt|;
if|if
condition|(
name|useOutputSubdirs
argument_list|()
operator|&&
operator|!
name|Generator
operator|::
name|outputSubdir
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|link
operator|=
name|QString
argument_list|(
literal|"../"
operator|+
name|Generator
operator|::
name|outputSubdir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|+=
name|fileName
expr_stmt|;
name|inner
operator|->
name|setObsoleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
name|beginSubPage
argument_list|(
name|inner
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|generateHeader
argument_list|(
name|title
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateTitle
argument_list|(
name|title
argument_list|,
name|Text
argument_list|()
argument_list|,
name|SmallSubTitle
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CodeMarker
operator|::
name|Compat
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>The following members of class "
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
name|inner
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"</a>"
operator|<<
literal|"are part of the "
literal|"Qt compatibility layer.</b> We advise against "
literal|"using them in new code.</p>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>The following members of class "
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
name|inner
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"</a>"
operator|<<
literal|" are obsolete.</b> "
operator|<<
literal|"They are provided to keep old source code working. "
operator|<<
literal|"We strongly advise against using them in new code.</p>\n"
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sections
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Summary
argument_list|)
expr_stmt|;
block|}
name|sections
operator|=
name|marker
operator|->
name|sections
argument_list|(
name|inner
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sections
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|//out()<< "<hr />\n";
name|out
argument_list|()
operator|<<
literal|"<h2>"
operator|<<
name|protectEnc
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|)
operator|<<
literal|"</h2>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
name|generateDetailedMember
argument_list|(
operator|*
name|m
argument_list|,
name|inner
argument_list|,
name|marker
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
block|}
name|generateFooter
argument_list|()
expr_stmt|;
name|endSubPage
argument_list|()
expr_stmt|;
return|return
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|generateClassHierarchy
name|void
name|HtmlGenerator
operator|::
name|generateClassHierarchy
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|NodeMap
modifier|&
name|classMap
parameter_list|)
block|{
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|NodeMap
name|topLevel
decl_stmt|;
name|NodeMap
operator|::
name|Iterator
name|c
init|=
name|classMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|classe
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|topLevel
operator|.
name|insert
argument_list|(
name|classe
operator|->
name|name
argument_list|()
argument_list|,
name|classe
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|QStack
argument_list|<
name|NodeMap
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|topLevel
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
else|else
block|{
name|ClassNode
modifier|*
name|child
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|generateFullName
argument_list|(
name|child
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|stack
operator|.
name|top
argument_list|()
operator|.
name|erase
argument_list|(
name|stack
operator|.
name|top
argument_list|()
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|NodeMap
name|newTop
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|d
decl|,
name|child
operator|->
name|derivedClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|d
operator|.
name|node_
operator|&&
operator|!
name|d
operator|.
name|isPrivate
argument_list|()
operator|&&
operator|!
name|d
operator|.
name|node_
operator|->
name|isInternal
argument_list|()
operator|&&
name|d
operator|.
name|node_
operator|->
name|hasDoc
argument_list|()
condition|)
name|newTop
operator|.
name|insert
argument_list|(
name|d
operator|.
name|node_
operator|->
name|name
argument_list|()
argument_list|,
name|d
operator|.
name|node_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newTop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|newTop
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Output an annotated list of the nodes in \a nodeMap.   A two-column table is output.  */
end_comment
begin_function
DECL|function|generateAnnotatedList
name|void
name|HtmlGenerator
operator|::
name|generateAnnotatedList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|nodeMap
parameter_list|)
block|{
if|if
condition|(
name|nodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nodeMap
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|generateAnnotatedList
name|void
name|HtmlGenerator
operator|::
name|generateAnnotatedList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|NodeList
modifier|&
name|unsortedNodes
parameter_list|)
block|{
name|NodeMap
name|nm
decl_stmt|;
name|bool
name|allInternal
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|node
decl|,
name|unsortedNodes
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isInternal
argument_list|()
operator|&&
operator|!
name|node
operator|->
name|isObsolete
argument_list|()
condition|)
block|{
name|allInternal
operator|=
literal|false
expr_stmt|;
name|nm
operator|.
name|insert
argument_list|(
name|node
operator|->
name|fullName
argument_list|(
name|relative
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allInternal
condition|)
return|return;
name|out
argument_list|()
operator|<<
literal|"<table class=\"annotated\">\n"
expr_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
name|NodeList
name|nodes
init|=
name|nm
operator|.
name|values
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|nodes
control|)
block|{
if|if
condition|(
operator|++
name|row
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<tr class=\"odd topAlign\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<tr class=\"even topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblName\"><p>"
expr_stmt|;
name|generateFullName
argument_list|(
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isDocNode
argument_list|()
condition|)
block|{
name|Text
name|brief
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|trimmedBriefText
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblDescr\"><p>"
expr_stmt|;
name|generateText
argument_list|(
name|brief
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|reconstitutedBrief
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblDescr\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|node
operator|->
name|reconstitutedBrief
argument_list|()
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblDescr\"><p>"
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|reconstitutedBrief
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
name|node
operator|->
name|reconstitutedBrief
argument_list|()
expr_stmt|;
block|}
else|else
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|node
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</tr>\n"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function finds the common prefix of the names of all   the classes in \a classMap and then generates a compact   list of the class names alphabetized on the part of the   name not including the common prefix. You can tell the   function to use \a comonPrefix as the common prefix, but   normally you let it figure it out itself by looking at   the name of the first and last classes in \a classMap.  */
end_comment
begin_function
DECL|function|generateCompactList
name|void
name|HtmlGenerator
operator|::
name|generateCompactList
parameter_list|(
name|ListType
name|listType
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|NodeMap
modifier|&
name|classMap
parameter_list|,
name|bool
name|includeAlphabet
parameter_list|,
name|QString
name|commonPrefix
parameter_list|)
block|{
if|if
condition|(
name|classMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|int
name|NumParagraphs
init|=
literal|37
decl_stmt|;
comment|// '0' to '9', 'A' to 'Z', '_'
name|int
name|commonPrefixLen
init|=
name|commonPrefix
operator|.
name|length
argument_list|()
decl_stmt|;
comment|/*       Divide the data into 37 paragraphs: 0, ..., 9, A, ..., Z,       underscore (_). QAccel will fall in paragraph 10 (A) and       QXtWidget in paragraph 33 (X). This is the only place where we       assume that NumParagraphs is 37. Each paragraph is a NodeMap.     */
name|NodeMap
name|paragraph
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QString
name|paragraphName
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
name|QSet
argument_list|<
name|char
argument_list|>
name|usedParagraphNames
decl_stmt|;
name|NodeMap
operator|::
name|ConstIterator
name|c
init|=
name|classMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QStringList
name|pieces
init|=
name|c
operator|.
name|key
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|int
name|idx
init|=
name|commonPrefixLen
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
operator|&&
operator|!
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|startsWith
argument_list|(
name|commonPrefix
argument_list|)
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|mid
argument_list|(
name|idx
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
else|else
name|key
operator|=
name|pieces
operator|.
name|last
argument_list|()
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|int
name|paragraphNr
init|=
name|NumParagraphs
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|paragraphNr
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|digitValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|key
index|[
literal|0
index|]
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|paragraphNr
operator|=
literal|10
operator|+
name|key
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|-
literal|'a'
expr_stmt|;
block|}
name|paragraphName
index|[
name|paragraphNr
index|]
operator|=
name|key
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|usedParagraphNames
operator|.
name|insert
argument_list|(
name|key
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|paragraph
index|[
name|paragraphNr
index|]
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|c
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
comment|/*       Each paragraph j has a size: paragraph[j].count(). In the       discussion, we will assume paragraphs 0 to 5 will have sizes       3, 1, 4, 1, 5, 9.        We now want to compute the paragraph offset. Paragraphs 0 to 6       start at offsets 0, 3, 4, 8, 9, 14, 23.     */
name|int
name|paragraphOffset
index|[
name|NumParagraphs
operator|+
literal|1
index|]
decl_stmt|;
comment|// 37 + 1
name|paragraphOffset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumParagraphs
condition|;
name|i
operator|++
control|)
comment|// i = 0..36
name|paragraphOffset
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|paragraphOffset
index|[
name|i
index|]
operator|+
name|paragraph
index|[
name|i
index|]
operator|.
name|count
argument_list|()
expr_stmt|;
comment|/*       Output the alphabet as a row of links.      */
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p  class=\"centerAlign functionIndex\"><b>"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|usedParagraphNames
operator|.
name|contains
argument_list|(
name|char
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
argument_list|)
condition|)
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a href=\"#%1\">%2</a>&nbsp;"
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</b></p>\n"
expr_stmt|;
block|}
comment|/*       Output a<div> element to contain all the<dl> elements.      */
name|out
argument_list|()
operator|<<
literal|"<div class=\"flowListDiv\">\n"
expr_stmt|;
name|numTableRows_
operator|=
literal|0
expr_stmt|;
name|int
name|curParNr
init|=
literal|0
decl_stmt|;
name|int
name|curParOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classMap
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|(
name|curParOffset
operator|==
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|count
argument_list|()
operator|)
condition|)
block|{
operator|++
name|curParNr
expr_stmt|;
name|curParOffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*           Starting a new paragraph means starting a new<dl>.         */
if|if
condition|(
name|curParOffset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
if|if
condition|(
operator|++
name|numTableRows_
operator|%
literal|2
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"<dl class=\"flowList odd\">"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"<dl class=\"flowList even\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<dt class=\"alphaChar\">"
expr_stmt|;
if|if
condition|(
name|includeAlphabet
condition|)
block|{
name|QChar
name|c
init|=
name|paragraphName
index|[
name|curParNr
index|]
index|[
literal|0
index|]
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a name=\"%1\"></a>"
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<b>"
operator|<<
name|paragraphName
index|[
name|curParNr
index|]
operator|<<
literal|"</b>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</dt>\n"
expr_stmt|;
block|}
comment|/*           Output a<dd> for the current offset in the current paragraph.          */
name|out
argument_list|()
operator|<<
literal|"<dd>"
expr_stmt|;
if|if
condition|(
operator|(
name|curParNr
operator|<
name|NumParagraphs
operator|)
operator|&&
operator|!
name|paragraphName
index|[
name|curParNr
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeMap
operator|::
name|Iterator
name|it
decl_stmt|;
name|it
operator|=
name|paragraph
index|[
name|curParNr
index|]
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|curParOffset
condition|;
name|i
operator|++
control|)
operator|++
name|it
expr_stmt|;
if|if
condition|(
name|listType
operator|==
name|Generic
condition|)
block|{
comment|/*                   Previously, we used generateFullName() for this, but we                   require some special formatting.                 */
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|)
operator|<<
literal|"\">"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|listType
operator|==
name|Obsolete
condition|)
block|{
name|QString
name|fileName
init|=
name|fileBase
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
operator|+
literal|"-obsolete."
operator|+
name|fileExtension
argument_list|()
decl_stmt|;
name|QString
name|link
decl_stmt|;
if|if
condition|(
name|useOutputSubdirs
argument_list|()
condition|)
name|link
operator|=
name|QString
argument_list|(
literal|"../"
operator|+
name|it
operator|.
name|value
argument_list|()
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|+=
name|fileName
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link
operator|<<
literal|"\">"
expr_stmt|;
block|}
name|QStringList
name|pieces
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|isQmlType
argument_list|()
condition|)
name|pieces
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
else|else
name|pieces
operator|=
name|it
operator|.
name|value
argument_list|()
operator|->
name|fullName
argument_list|(
name|relative
argument_list|)
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|pieces
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
if|if
condition|(
name|pieces
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|" ("
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|')'
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</dd>\n"
expr_stmt|;
name|curParOffset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|classMap
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
name|out
argument_list|()
operator|<<
literal|"</dl>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateFunctionIndex
name|void
name|HtmlGenerator
operator|::
name|generateFunctionIndex
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p  class=\"centerAlign functionIndex\"><b>"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a href=\"#%1\">%2</a>&nbsp;"
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</b></p>\n"
expr_stmt|;
name|char
name|nextLetter
init|=
literal|'a'
decl_stmt|;
name|char
name|currentLetter
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|NodeMapMap
name|funcIndex
init|=
name|qdb_
operator|->
name|getFunctionIndex
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|NodeMap
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|funcIndex
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|funcIndex
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|f
operator|.
name|key
argument_list|()
argument_list|)
operator|<<
literal|':'
expr_stmt|;
name|currentLetter
operator|=
name|f
operator|.
name|key
argument_list|()
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
while|while
condition|(
name|islower
argument_list|(
name|currentLetter
argument_list|)
operator|&&
name|currentLetter
operator|>=
name|nextLetter
condition|)
block|{
name|out
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"<a name=\"%1\"></a>"
argument_list|)
operator|.
name|arg
argument_list|(
name|nextLetter
argument_list|)
expr_stmt|;
name|nextLetter
operator|++
expr_stmt|;
block|}
name|NodeMap
operator|::
name|ConstIterator
name|s
init|=
operator|(
operator|*
name|f
operator|)
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
operator|*
name|f
operator|)
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|' '
expr_stmt|;
name|generateFullName
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|->
name|parent
argument_list|()
argument_list|,
name|relative
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</li>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|'\n'
expr_stmt|;
operator|++
name|f
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateLegaleseList
name|void
name|HtmlGenerator
operator|::
name|generateLegaleseList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|TextToNodeMap
modifier|&
name|legaleseTexts
init|=
name|qdb_
operator|->
name|getLegaleseTexts
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|Text
argument_list|,
specifier|const
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|legaleseTexts
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Text
name|text
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
comment|//out()<< "<hr />\n";
name|generateText
argument_list|(
name|text
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
do|do
block|{
name|out
argument_list|()
operator|<<
literal|"<li>"
expr_stmt|;
name|generateFullName
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
do|while
condition|(
name|it
operator|!=
name|legaleseTexts
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|text
condition|)
do|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateQmlItem
name|void
name|HtmlGenerator
operator|::
name|generateQmlItem
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|bool
name|summary
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpQmlItem
argument_list|(
name|node
argument_list|,
name|summary
argument_list|)
decl_stmt|;
name|QRegExp
name|templateTag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|templateTag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|contents
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i>\\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@param>"
argument_list|,
literal|"<i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@param>"
argument_list|,
literal|"</i>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
name|marked
operator|.
name|replace
argument_list|(
literal|"@name>"
argument_list|,
literal|"b>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@extra>"
argument_list|,
literal|"<tt>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@extra>"
argument_list|,
literal|"</tt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|highlightedCode
argument_list|(
name|marked
argument_list|,
name|relative
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateList
name|void
name|HtmlGenerator
operator|::
name|generateList
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
specifier|const
name|QString
modifier|&
name|selector
parameter_list|)
block|{
name|NodeList
name|nl
decl_stmt|;
name|CollectionList
name|cl
decl_stmt|;
name|QRegExp
name|singleDigit
argument_list|(
literal|"\\b([0-9])\\b"
argument_list|)
decl_stmt|;
if|if
condition|(
name|selector
operator|==
literal|"overviews"
condition|)
block|{
name|CNMap
name|groups
decl_stmt|;
name|qdb_
operator|->
name|mergeCollections
argument_list|(
name|Node
operator|::
name|Group
argument_list|,
name|groups
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|cl
operator|=
name|groups
operator|.
name|values
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|cn
decl|,
name|cl
control|)
name|nl
operator|.
name|append
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|selector
operator|==
literal|"cpp-modules"
condition|)
block|{
name|CNMap
name|modules
decl_stmt|;
name|qdb_
operator|->
name|mergeCollections
argument_list|(
name|Node
operator|::
name|Module
argument_list|,
name|modules
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|cl
operator|=
name|modules
operator|.
name|values
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|cn
decl|,
name|cl
control|)
name|nl
operator|.
name|append
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|selector
operator|==
literal|"qml-modules"
condition|)
block|{
name|CNMap
name|qmlModules
decl_stmt|;
name|qdb_
operator|->
name|mergeCollections
argument_list|(
name|Node
operator|::
name|QmlModule
argument_list|,
name|qmlModules
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|cl
operator|=
name|qmlModules
operator|.
name|values
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|CollectionNode
modifier|*
name|cn
decl|,
name|cl
control|)
name|nl
operator|.
name|append
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|relative
argument_list|,
name|marker
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*           \generatelist {selector} is only allowed in a           comment where the topic is \group, \module, or           \qmlmodule.         */
if|if
condition|(
operator|!
name|relative
operator|||
operator|!
name|relative
operator|->
name|isCollectionNode
argument_list|()
condition|)
block|{
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"\\generatelist {%1} is only allowed in \\group, \\module, and \\qmlmodule comments."
argument_list|)
operator|.
name|arg
argument_list|(
name|selector
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|selector
operator|==
literal|"related"
condition|)
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|CollectionNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
name|CollectionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|qdb_
operator|->
name|mergeCollections
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|cn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|CollectionNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
name|CollectionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|qdb_
operator|->
name|mergeCollections
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|generateAnnotatedList
argument_list|(
name|cn
argument_list|,
name|marker
argument_list|,
name|cn
operator|->
name|members
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|QStringList keys = groups.uniqueKeys();     foreach (QString key, keys) {         GroupNode* gn = static_cast<GroupNode*>(groups.value(key));         if (gn) {             out()<< QString("<h3><a href=\"%1\">%2</a></h3>\n").arg(                          linkForNode(gn, relative)).arg(                          protectEnc(gn->fullTitle()));
if|#
directive|if
literal|0
block|if (gn->members().isEmpty())                 continue;              NodeMap nm;             foreach (Node* member, gn->members()) {                 if (member->isInternal() || member->isExample() || member->isExternalPage() ||                     member->isObsolete())                     continue;
comment|// not interested either in individual (Qt Designer etc.) manual chapters
block|if (member->links().contains(Node::ContentsLink))                     continue;                 QString sortKey = member->fullTitle().toLower();                 if (sortKey.startsWith("the "))                     sortKey.remove(0, 4);                 sortKey.replace(singleDigit, "0\\1");                 nm.insert(sortKey, member);             }              out()<< "<ul>\n";             QStringList titles = nm.keys();             foreach (QString t, titles) {                 Node* member = nm.value(t);                 QString title = member->fullTitle();                 if (title.startsWith("The "))                     title.remove(0, 4);                 out()<< "<li><a href=\""<< linkForNode(member, relative)<< "\">"<< protectEnc(title)<< "</a></li>\n";             }             out()<< "</ul>\n";
endif|#
directive|endif
block|}     }
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|generateSection
name|void
name|HtmlGenerator
operator|::
name|generateSection
parameter_list|(
specifier|const
name|NodeList
modifier|&
name|nl
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|bool
name|alignNames
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|nl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|twoColumn
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|alignNames
operator|=
literal|false
expr_stmt|;
name|twoColumn
operator|=
operator|(
name|nl
operator|.
name|count
argument_list|()
operator|>=
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nl
operator|.
name|first
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|twoColumn
operator|=
operator|(
name|nl
operator|.
name|count
argument_list|()
operator|>=
literal|5
operator|)
expr_stmt|;
name|alignNames
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"<table class=\"propsummary\">\n"
operator|<<
literal|"<tr><td class=\"topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|nl
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|nl
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
operator|++
name|m
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"memItemLeft rightAlign topAlign\"> "
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
operator|&&
name|i
operator|==
call|(
name|int
call|)
argument_list|(
name|nl
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
operator|/
literal|2
condition|)
name|out
argument_list|()
operator|<<
literal|"</ul></td><td class=\"topAlign\"><ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
block|}
name|generateSynopsis
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|style
argument_list|,
name|alignNames
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n</table>\n"
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateSectionList
name|void
name|HtmlGenerator
operator|::
name|generateSectionList
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|bool
name|alignNames
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|twoColumn
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|alignNames
operator|=
literal|false
expr_stmt|;
name|twoColumn
operator|=
operator|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|>=
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|.
name|members
operator|.
name|first
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|twoColumn
operator|=
operator|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|>=
literal|5
operator|)
expr_stmt|;
name|alignNames
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<table class=\"alignedsummary\">\n"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"<table class=\"propsummary\">\n"
operator|<<
literal|"<tr><td class=\"topAlign\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
init|=
name|section
operator|.
name|members
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|section
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
operator|++
name|m
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|alignNames
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<tr><td class=\"memItemLeft topAlign rightAlign\"> "
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twoColumn
operator|&&
name|i
operator|==
call|(
name|int
call|)
argument_list|(
name|section
operator|.
name|members
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
operator|/
literal|2
condition|)
name|out
argument_list|()
operator|<<
literal|"</ul></td><td class=\"topAlign\"><ul>\n"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
block|}
name|QString
name|prefix
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|section
operator|.
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|prefix
operator|.
name|left
argument_list|(
name|section
operator|.
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"::"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|generateSynopsis
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|style
argument_list|,
name|alignNames
argument_list|,
operator|&
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n"
expr_stmt|;
else|else
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
if|if
condition|(
name|alignNames
condition|)
name|out
argument_list|()
operator|<<
literal|"</table>\n"
expr_stmt|;
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
if|if
condition|(
name|twoColumn
condition|)
name|out
argument_list|()
operator|<<
literal|"</td></tr>\n</table>\n"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Summary
operator|&&
operator|!
name|section
operator|.
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|generateSectionInheritedList
argument_list|(
name|section
argument_list|,
name|relative
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateSectionInheritedList
name|void
name|HtmlGenerator
operator|::
name|generateSectionInheritedList
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QList
argument_list|<
name|QPair
argument_list|<
name|InnerNode
modifier|*
argument_list|,
name|int
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|section
operator|.
name|inherited
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|section
operator|.
name|inherited
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|second
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|second
operator|==
literal|1
condition|)
block|{
name|out
argument_list|()
operator|<<
name|section
operator|.
name|singularMember
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|section
operator|.
name|pluralMember
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|" inherited from<a href=\""
operator|<<
name|fileName
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
argument_list|)
operator|<<
literal|'#'
operator|<<
name|HtmlGenerator
operator|::
name|cleanRef
argument_list|(
name|section
operator|.
name|name
operator|.
name|toLower
argument_list|()
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|protectEnc
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|first
operator|->
name|plainFullName
argument_list|(
name|relative
argument_list|)
argument_list|)
operator|<<
literal|"</a></li>\n"
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateSynopsis
name|void
name|HtmlGenerator
operator|::
name|generateSynopsis
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|,
name|CodeMarker
operator|::
name|SynopsisStyle
name|style
parameter_list|,
name|bool
name|alignNames
parameter_list|,
specifier|const
name|QString
modifier|*
name|prefix
parameter_list|)
block|{
name|QString
name|marked
init|=
name|marker
operator|->
name|markedUpSynopsis
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
name|marked
operator|.
name|prepend
argument_list|(
operator|*
name|prefix
argument_list|)
expr_stmt|;
name|QRegExp
name|templateTag
argument_list|(
literal|"(<[^@>]*>)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|marked
operator|.
name|indexOf
argument_list|(
name|templateTag
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|contents
init|=
name|protectEnc
argument_list|(
name|marked
operator|.
name|mid
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|marked
operator|.
name|replace
argument_list|(
name|templateTag
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
argument_list|,
name|templateTag
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|marked
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"<@param>([a-z]+)_([1-9n])</@param>"
argument_list|)
argument_list|,
literal|"<i>\\1<sub>\\2</sub></i>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"<@param>"
argument_list|,
literal|"<i> "
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@param>"
argument_list|,
literal|"</i>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Summary
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@name>"
argument_list|)
expr_stmt|;
comment|// was "<b>"
name|marked
operator|.
name|remove
argument_list|(
literal|"</@name>"
argument_list|)
expr_stmt|;
comment|// was "</b>"
block|}
if|if
condition|(
name|style
operator|==
name|CodeMarker
operator|::
name|Subpage
condition|)
block|{
name|QRegExp
name|extraRegExp
argument_list|(
literal|"<@extra>.*</@extra>"
argument_list|)
decl_stmt|;
name|extraRegExp
operator|.
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
name|extraRegExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|marked
operator|.
name|replace
argument_list|(
literal|"<@extra>"
argument_list|,
literal|"<tt>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|replace
argument_list|(
literal|"</@extra>"
argument_list|,
literal|"</tt>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|!=
name|CodeMarker
operator|::
name|Detailed
condition|)
block|{
name|marked
operator|.
name|remove
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|marked
operator|.
name|remove
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
name|highlightedCode
argument_list|(
name|marked
argument_list|,
name|relative
argument_list|,
name|alignNames
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|highlightedCode
name|QString
name|HtmlGenerator
operator|::
name|highlightedCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|bool
name|alignNames
parameter_list|)
block|{
name|QString
name|src
init|=
name|markedCode
decl_stmt|;
name|QString
name|html
decl_stmt|;
name|QStringRef
name|arg
decl_stmt|;
name|QStringRef
name|par1
decl_stmt|;
specifier|const
name|QChar
name|charLangle
init|=
literal|'<'
decl_stmt|;
specifier|const
name|QChar
name|charAt
init|=
literal|'@'
decl_stmt|;
specifier|static
specifier|const
name|QString
name|typeTag
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|headerTag
argument_list|(
literal|"headerfile"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|funcTag
argument_list|(
literal|"func"
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|QString
name|linkTag
argument_list|(
literal|"link"
argument_list|)
decl_stmt|;
comment|// replace all<@link> tags: "(<@link node=\"([^\"]+)\">).*(</@link>)"
name|bool
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
if|if
condition|(
name|alignNames
operator|&&
operator|!
name|done
condition|)
block|{
name|html
operator|+=
literal|"</td><td class=\"memItemRight bottomAlign\">"
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|linkTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|html
operator|+=
literal|"<b>"
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|CodeMarker
operator|::
name|nodeForString
argument_list|(
name|par1
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|html
operator|+=
literal|"</b>"
expr_stmt|;
block|}
else|else
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all<@func> tags: "(<@func target=\"([^\"]*)\">)(.*)(</@func>)"
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|funcTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveFunctionTarget
argument_list|(
name|par1
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|QString
name|link
init|=
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|addLink
argument_list|(
name|link
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all "(<@(type|headerfile)(?: +[^>]*)?>)(.*)(</@\\2>)" tags
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|srcSize
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|srcSize
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|bool
name|handled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|typeTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveType
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<span class=\"type\">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|isQmlBasicType
argument_list|()
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
name|relative
operator|->
name|isQmlType
argument_list|()
condition|)
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|arg
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</span>"
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseArg
argument_list|(
name|src
argument_list|,
name|headerTag
argument_list|,
operator|&
name|i
argument_list|,
name|srcSize
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|par1
argument_list|)
condition|)
block|{
name|par1
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QChar
argument_list|(
literal|'&'
argument_list|)
condition|)
name|html
operator|+=
name|arg
operator|.
name|toString
argument_list|()
expr_stmt|;
else|else
block|{
comment|// zzz resolveClassTarget()
specifier|const
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|arg
operator|.
name|toString
argument_list|()
argument_list|,
name|relative
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|addLink
argument_list|(
name|linkForNode
argument_list|(
name|n
argument_list|,
name|relative
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|&
name|html
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|arg
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|handled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
name|html
operator|+=
name|charLangle
expr_stmt|;
name|html
operator|+=
name|charAt
expr_stmt|;
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace all
comment|// "<@comment>" -> "<span class=\"comment\">";
comment|// "<@preprocessor>" -> "<span class=\"preprocessor\">";
comment|// "<@string>" -> "<span class=\"string\">";
comment|// "<@char>" -> "<span class=\"char\">";
comment|// "<@number>" -> "<span class=\"number\">";
comment|// "<@op>" -> "<span class=\"operator\">";
comment|// "<@type>" -> "<span class=\"type\">";
comment|// "<@name>" -> "<span class=\"name\">";
comment|// "<@keyword>" -> "<span class=\"keyword\">";
comment|// "</@(?:comment|preprocessor|string|char|number|op|type|name|keyword)>" -> "</span>"
name|src
operator|=
name|html
expr_stmt|;
name|html
operator|=
name|QString
argument_list|()
expr_stmt|;
specifier|static
specifier|const
name|QString
name|spanTags
index|[]
init|=
block|{
literal|"<@comment>"
block|,
literal|"<span class=\"comment\">"
block|,
literal|"<@preprocessor>"
block|,
literal|"<span class=\"preprocessor\">"
block|,
literal|"<@string>"
block|,
literal|"<span class=\"string\">"
block|,
literal|"<@char>"
block|,
literal|"<span class=\"char\">"
block|,
literal|"<@number>"
block|,
literal|"<span class=\"number\">"
block|,
literal|"<@op>"
block|,
literal|"<span class=\"operator\">"
block|,
literal|"<@type>"
block|,
literal|"<span class=\"type\">"
block|,
literal|"<@name>"
block|,
literal|"<span class=\"name\">"
block|,
literal|"<@keyword>"
block|,
literal|"<span class=\"keyword\">"
block|,
literal|"</@comment>"
block|,
literal|"</span>"
block|,
literal|"</@preprocessor>"
block|,
literal|"</span>"
block|,
literal|"</@string>"
block|,
literal|"</span>"
block|,
literal|"</@char>"
block|,
literal|"</span>"
block|,
literal|"</@number>"
block|,
literal|"</span>"
block|,
literal|"</@op>"
block|,
literal|"</span>"
block|,
literal|"</@type>"
block|,
literal|"</span>"
block|,
literal|"</@name>"
block|,
literal|"</span>"
block|,
literal|"</@keyword>"
block|,
literal|"</span>"
block|,     }
decl_stmt|;
comment|// Update the upper bound of k in the following code to match the length
comment|// of the above array.
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|src
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charLangle
condition|)
block|{
name|bool
name|handled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|!=
literal|18
condition|;
operator|++
name|k
control|)
block|{
specifier|const
name|QString
modifier|&
name|tag
init|=
name|spanTags
index|[
literal|2
operator|*
name|k
index|]
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|html
operator|+=
name|spanTags
index|[
literal|2
operator|*
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|charAt
operator|||
operator|(
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|charAt
operator|)
condition|)
block|{
comment|// drop 'our' unknown tags (the ones still containing '@')
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// retain all others
name|html
operator|+=
name|charLangle
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|html
operator|+=
name|src
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|html
return|;
block|}
end_function
begin_function
DECL|function|generateLink
name|void
name|HtmlGenerator
operator|::
name|generateLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|static
name|QRegExp
name|camelCase
argument_list|(
literal|"[A-Z][A-Z][a-z]|[a-z][A-Z0-9]|_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcLeftParen
operator|.
name|indexIn
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|marker
operator|->
name|recognizeLanguage
argument_list|(
literal|"Cpp"
argument_list|)
condition|)
block|{
comment|// hack for C++: move () outside of link
name|int
name|k
init|=
name|funcLeftParen
operator|.
name|pos
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|left
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"</i>"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
name|inLink_
operator|=
literal|false
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|mid
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanRef
name|QString
name|HtmlGenerator
operator|::
name|cleanRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clean
return|;
name|clean
operator|.
name|reserve
argument_list|(
name|ref
operator|.
name|size
argument_list|()
operator|+
literal|20
argument_list|)
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'~'
condition|)
block|{
name|clean
operator|+=
literal|"dtor."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'_'
condition|)
block|{
name|clean
operator|+=
literal|"underscore."
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ref
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|ref
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
name|u
operator|==
literal|'-'
operator|||
name|u
operator|==
literal|'_'
operator|||
name|u
operator|==
literal|':'
operator|||
name|u
operator|==
literal|'.'
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'!'
condition|)
block|{
name|clean
operator|+=
literal|"-not"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'&'
condition|)
block|{
name|clean
operator|+=
literal|"-and"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'<'
condition|)
block|{
name|clean
operator|+=
literal|"-lt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'='
condition|)
block|{
name|clean
operator|+=
literal|"-eq"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'>'
condition|)
block|{
name|clean
operator|+=
literal|"-gt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'#'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|clean
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|registerRef
name|QString
name|HtmlGenerator
operator|::
name|registerRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|QString
name|clean
init|=
name|HtmlGenerator
operator|::
name|cleanRef
argument_list|(
name|ref
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QString
modifier|&
name|prevRef
init|=
name|refMap
index|[
name|clean
operator|.
name|toLower
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|prevRef
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prevRef
operator|=
name|ref
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|prevRef
operator|==
name|ref
condition|)
block|{
break|break;
block|}
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
block|}
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|protectEnc
name|QString
name|HtmlGenerator
operator|::
name|protectEnc
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
return|return
name|protect
argument_list|(
name|string
argument_list|,
name|outputEncoding
argument_list|)
return|;
else|#
directive|else
return|return
name|protect
argument_list|(
name|string
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|protect
name|QString
name|HtmlGenerator
operator|::
name|protect
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|outputEncoding
parameter_list|)
block|{
DECL|macro|APPEND
define|#
directive|define
name|APPEND
parameter_list|(
name|x
parameter_list|)
define|\
value|if (html.isEmpty()) { \     html = string; \     html.truncate(i); \ } \     html += (x);
name|QString
name|html
decl_stmt|;
name|int
name|n
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|APPEND
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outputEncoding
operator|==
literal|"ISO-8859-1"
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|>
literal|0x007F
operator|)
operator|||
operator|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|n
operator|&&
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|||
operator|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|i
operator|>
literal|2
operator|&&
name|string
operator|.
name|at
argument_list|(
name|i
operator|-
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
block|{
comment|// we escape '*/' and the last dot in 'e.g.' and 'i.e.' for the Javadoc generator
name|APPEND
argument_list|(
literal|"&#x"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|html
operator|.
name|isEmpty
argument_list|()
condition|)
name|html
operator|+=
name|ch
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|html
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|html
return|;
return|return
name|string
return|;
DECL|macro|APPEND
undef|#
directive|undef
name|APPEND
block|}
end_function
begin_function
DECL|function|fileBase
name|QString
name|HtmlGenerator
operator|::
name|fileBase
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
name|result
operator|=
name|Generator
operator|::
name|fileBase
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Compat
case|:
name|result
operator|+=
literal|"-compat"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|result
operator|+=
literal|"-obsolete"
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|HtmlGenerator
operator|::
name|fileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return
name|node
operator|->
name|name
argument_list|()
return|;
block|}
return|return
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|refForNode
name|QString
name|HtmlGenerator
operator|::
name|refForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
decl_stmt|;
specifier|const
name|TypedefNode
modifier|*
name|typedeffe
decl_stmt|;
name|QString
name|ref
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
default|default:
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|typedeffe
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|typedeffe
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
return|return
name|refForNode
argument_list|(
name|typedeffe
operator|->
name|associatedEnum
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-typedef"
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
return|return
name|refForNode
argument_list|(
name|func
operator|->
name|associatedProperty
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|ref
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Document
case|:
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
case|case
name|Node
operator|::
name|QmlProperty
case|:
case|case
name|Node
operator|::
name|Property
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-prop"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-signal-handler"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ref
operator|=
name|func
operator|->
name|name
argument_list|()
operator|+
literal|"-method"
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|ref
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|ref
operator|=
name|node
operator|->
name|name
argument_list|()
operator|+
literal|"-var"
expr_stmt|;
break|break;
block|}
return|return
name|registerRef
argument_list|(
name|ref
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|DEBUG_ABSTRACT
define|#
directive|define
name|DEBUG_ABSTRACT
value|0
end_define
begin_comment
comment|/*!   Construct the link string for the \a node and return it.   The \a relative node is use to decide the link we are   generating is in the same file as the target. Note the   relative node can be 0, which pretty much guarantees   that the link and the target aren't in the same file.   */
end_comment
begin_function
DECL|function|linkForNode
name|QString
name|HtmlGenerator
operator|::
name|linkForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
name|node
operator|==
name|relative
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
if|if
condition|(
name|fileBase
argument_list|(
name|node
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|fn
init|=
name|fileName
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
name|node
operator|->
name|parent
argument_list|()
operator|!=
name|relative
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isQmlType
argument_list|()
operator|&&
name|relative
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isAbstract
argument_list|()
condition|)
block|{
comment|/*                   This is a bit of a hack. What we discover with                   the three 'if' statements immediately above,                   is that node's parent is marked \qmlabstract                   but the link appears in a qdoc comment for a                   subclass of the node's parent. This means the                   link should refer to the file for the relative                   node, not the file for node.                  */
name|fn
operator|=
name|fileName
argument_list|(
name|relative
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QString
name|link
init|=
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|QString
name|ref
init|=
name|refForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|relative
operator|&&
name|fn
operator|==
name|fileName
argument_list|(
name|relative
argument_list|)
operator|&&
name|ref
operator|==
name|refForNode
argument_list|(
name|relative
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|link
operator|+=
name|ref
expr_stmt|;
block|}
comment|/*       If the output is going to subdirectories, then if the       two nodes will be output to different directories, then       the link must go up to the parent directory and then       back down into the other subdirectory.      */
if|if
condition|(
name|node
operator|&&
name|relative
operator|&&
operator|(
name|node
operator|!=
name|relative
operator|)
condition|)
block|{
if|if
condition|(
name|useOutputSubdirs
argument_list|()
operator|&&
operator|!
name|node
operator|->
name|isExternalPage
argument_list|()
operator|&&
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|!=
name|relative
operator|->
name|outputSubdirectory
argument_list|()
condition|)
block|{
name|link
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
literal|"../"
operator|+
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|link
return|;
block|}
end_function
begin_function
DECL|function|generateFullName
name|void
name|HtmlGenerator
operator|::
name|generateFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|apparentNode
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
name|actualNode
parameter_list|)
block|{
if|if
condition|(
name|actualNode
operator|==
literal|0
condition|)
name|actualNode
operator|=
name|apparentNode
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|linkForNode
argument_list|(
name|actualNode
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
literal|true
operator|||
name|relative
operator|==
literal|0
operator|||
name|relative
operator|->
name|status
argument_list|()
operator|!=
name|actualNode
operator|->
name|status
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|actualNode
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
name|out
argument_list|()
operator|<<
literal|"\" class=\"obsolete"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
name|out
argument_list|()
operator|<<
literal|"\" class=\"compat"
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
name|protectEnc
argument_list|(
name|apparentNode
operator|->
name|fullName
argument_list|(
name|relative
argument_list|)
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateDetailedMember
name|void
name|HtmlGenerator
operator|::
name|generateDetailedMember
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|MemberMark
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
operator|&&
operator|(
name|enume
operator|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|)
operator|->
name|flagsType
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
argument_list|()
operator|<<
literal|"<h3 class=\"flags\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|node
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|enume
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<br/>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<h3 class=\"fn\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|node
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|node
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</h3>"
operator|<<
name|divNavTop
operator|<<
literal|'\n'
expr_stmt|;
block|}
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
specifier|const
name|PropertyNode
modifier|*
name|property
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|Section
name|section
decl_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|getters
argument_list|()
expr_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|setters
argument_list|()
expr_stmt|;
name|section
operator|.
name|members
operator|+=
name|property
operator|->
name|resetters
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>Access functions:</b></p>\n"
expr_stmt|;
name|generateSectionList
argument_list|(
name|section
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Accessors
argument_list|)
expr_stmt|;
block|}
name|Section
name|notifiers
decl_stmt|;
name|notifiers
operator|.
name|members
operator|+=
name|property
operator|->
name|notifiers
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|notifiers
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p><b>Notifier signal:</b></p>\n"
expr_stmt|;
comment|//out()<< "<p>This signal is emitted when the property value is changed.</p>\n";
name|generateSectionList
argument_list|(
name|notifiers
argument_list|,
name|node
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Accessors
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|enume
operator|->
name|flagsType
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<p>The "
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|flagsType
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|" type is a typedef for "
operator|<<
literal|"<a href=\""
operator|<<
name|qflagsHref_
operator|<<
literal|"\">QFlags</a>&lt;"
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|"&gt;. It stores an OR combination of "
operator|<<
name|protectEnc
argument_list|(
name|enume
operator|->
name|name
argument_list|()
argument_list|)
operator|<<
literal|" values.</p>\n"
expr_stmt|;
block|}
block|}
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hOffset
name|int
name|HtmlGenerator
operator|::
name|hOffset
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Class
case|:
return|return
literal|2
return|;
case|case
name|Node
operator|::
name|QmlType
case|:
case|case
name|Node
operator|::
name|Document
case|:
return|return
literal|1
return|;
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Property
case|:
default|default:
return|return
literal|3
return|;
block|}
block|}
end_function
begin_function
DECL|function|isThreeColumnEnumValueTable
name|bool
name|HtmlGenerator
operator|::
name|isThreeColumnEnumValueTable
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
while|while
condition|(
name|atom
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListRight
operator|&&
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
operator|)
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListItemLeft
operator|&&
operator|!
name|matchAhead
argument_list|(
name|atom
argument_list|,
name|Atom
operator|::
name|ListItemRight
argument_list|)
condition|)
return|return
literal|true
return|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|anchorForNode
specifier|const
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|HtmlGenerator
operator|::
name|anchorForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|anchorPair
decl_stmt|;
name|anchorPair
operator|.
name|first
operator|=
name|Generator
operator|::
name|fileName
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|docNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|anchorPair
operator|.
name|second
operator|=
name|docNode
operator|->
name|title
argument_list|()
expr_stmt|;
block|}
return|return
name|anchorPair
return|;
block|}
end_function
begin_comment
comment|/*!   This function is called for links, i.e. for words that   are marked with the qdoc link command. For autolinks   that are not marked with the qdoc link command, qdoc   calls getAutoLink().    Return the link represented by the \a atom, and set \a node   to point to the target node for that link. \a relative points   to the node holding the qdoc comment where the link command   was found.  */
end_comment
begin_function
DECL|function|getLink
name|QString
name|HtmlGenerator
operator|::
name|getLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"http:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"https:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"ftp:"
argument_list|)
operator|||
name|atom
operator|->
name|string
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"mailto:"
argument_list|)
operator|)
condition|)
block|{
return|return
name|atom
operator|->
name|string
argument_list|()
return|;
comment|// It's some kind of protocol.
block|}
name|QString
name|ref
decl_stmt|;
name|QString
name|link
decl_stmt|;
name|QString
name|first
decl_stmt|;
name|QStringList
name|path
decl_stmt|;
operator|*
name|node
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|atom
operator|->
name|string
argument_list|()
operator|.
name|contains
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
name|path
operator|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|split
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|first
operator|=
name|path
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|path
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
else|else
name|first
operator|=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
operator|*
name|node
operator|=
name|relative
expr_stmt|;
comment|// search for a target on the current page.
else|else
block|{
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
block|{
comment|// The target is an html file.
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findNodeByNameAndType
argument_list|(
name|QStringList
argument_list|(
name|first
argument_list|)
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
comment|//Node* n = qdb_->findHtmlFileNode(atom);
block|}
elseif|else
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
comment|// The target is a C++ function or QML method.
operator|*
name|node
operator|=
name|qdb_
operator|->
name|resolveFunctionTarget
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|first
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findUnambiguousTarget
argument_list|(
name|first
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node
operator|&&
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|final
init|=
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|+
literal|"#"
operator|+
name|ref
decl_stmt|;
return|return
name|final
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
return|return
name|link
return|;
comment|// empty
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
return|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|qdb_
operator|->
name|findTarget
argument_list|(
name|path
operator|.
name|first
argument_list|()
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|link
return|;
comment|// empty
block|}
comment|/*       Given that *node is not null, we now cconstruct a link       to the page that *node represents, and then if we found       a target on that page, we connect the target to the link       with '#'.     */
name|link
operator|=
name|linkForNode
argument_list|(
operator|*
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node
operator|&&
operator|(
operator|*
name|node
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
name|link
operator|=
literal|"images/used-in-examples/"
operator|+
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|ref
expr_stmt|;
return|return
name|link
return|;
block|}
end_function
begin_comment
comment|/*!   This function is called for autolinks, i.e. for words that   are not marked with the qdoc link command that qdoc has   reason to believe should be links. For links marked with   the qdoc link command, qdoc calls getLink().    Return the link represented by the \a atom, and set \a node   to point to the target node for that link. \a relative points   to the node holding the qdoc comment where the link command   was found.  */
end_comment
begin_function
DECL|function|getAutoLink
name|QString
name|HtmlGenerator
operator|::
name|getAutoLink
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Node
modifier|*
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|ref
decl_stmt|;
name|QString
name|link
decl_stmt|;
name|QString
name|path
init|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
operator|*
name|node
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|endsWith
argument_list|(
literal|"()"
argument_list|)
condition|)
block|{
comment|// The target is a C++ function or QML method.
operator|*
name|node
operator|=
name|qdb_
operator|->
name|resolveFunctionTarget
argument_list|(
name|path
argument_list|,
name|relative
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|resolveTarget
argument_list|(
name|path
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
block|{
operator|*
name|node
operator|=
name|qdb_
operator|->
name|findUnambiguousTarget
argument_list|(
name|path
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node
operator|&&
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|final
init|=
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|+
literal|"#"
operator|+
name|ref
decl_stmt|;
return|return
name|final
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
condition|)
return|return
name|link
return|;
comment|// empty
if|if
condition|(
operator|!
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|(
operator|*
name|node
operator|)
operator|->
name|url
argument_list|()
return|;
name|link
operator|=
name|linkForNode
argument_list|(
operator|*
name|node
argument_list|,
name|relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|link
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
operator|+
name|ref
expr_stmt|;
return|return
name|link
return|;
block|}
end_function
begin_function
DECL|function|generateStatus
name|void
name|HtmlGenerator
operator|::
name|generateStatus
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|Text
name|text
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|"This "
operator|<<
name|typeString
argument_list|(
name|node
argument_list|)
operator|<<
literal|" is part of the Qt 3 support library."
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
operator|<<
literal|" It is provided to keep old source code working. "
operator|<<
literal|"We strongly advise against "
operator|<<
literal|"using it in new code. See "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"Porting to Qt 4"
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
literal|" for more information."
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
block|}
name|generateText
argument_list|(
name|text
argument_list|,
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Generator
operator|::
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
end_ifdef
begin_comment
comment|/*   No longer valid.  */
end_comment
begin_function
DECL|function|generateMacRef
name|void
name|HtmlGenerator
operator|::
name|generateMacRef
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pleaseGenerateMacRef
operator|||
name|marker
operator|==
literal|0
condition|)
return|return;
name|QStringList
name|macRefs
init|=
name|marker
operator|->
name|macRefsForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|macRef
decl|,
name|macRefs
control|)
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|<<
literal|"//apple_ref/"
operator|<<
name|macRef
operator|<<
literal|"\"></a>\n"
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|beginLink
name|void
name|HtmlGenerator
operator|::
name|beginLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|link
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|link_
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"<i>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|(
name|relative
operator|!=
literal|0
operator|&&
name|node
operator|->
name|status
argument_list|()
operator|==
name|relative
operator|->
name|status
argument_list|()
operator|)
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\">"
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Obsolete
case|:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\" class=\"obsolete\">"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Compat
case|:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\" class=\"compat\">"
expr_stmt|;
break|break;
default|default:
name|out
argument_list|()
operator|<<
literal|"<a href=\""
operator|<<
name|link_
operator|<<
literal|"\">"
expr_stmt|;
block|}
block|}
name|inLink_
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endLink
name|void
name|HtmlGenerator
operator|::
name|endLink
parameter_list|()
block|{
if|if
condition|(
name|inLink_
condition|)
block|{
if|if
condition|(
name|link_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|showBrokenLinks
condition|)
name|out
argument_list|()
operator|<<
literal|"</i>"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inObsoleteLink
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<sup>(obsolete)</sup>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</a>"
expr_stmt|;
block|}
block|}
name|inLink_
operator|=
literal|false
expr_stmt|;
name|inObsoleteLink
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generates the summary for the \a section. Only used for   sections of QML element documentation.  */
end_comment
begin_function
DECL|function|generateQmlSummary
name|void
name|HtmlGenerator
operator|::
name|generateQmlSummary
parameter_list|(
specifier|const
name|Section
modifier|&
name|section
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section
operator|.
name|members
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|m
decl_stmt|;
name|m
operator|=
name|section
operator|.
name|members
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|section
operator|.
name|members
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|generateQmlItem
argument_list|(
operator|*
name|m
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|QmlPropertyGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyGroupNode
operator|*
argument_list|>
argument_list|(
operator|*
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<ul>\n"
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<li class=\"fn\">"
expr_stmt|;
name|generateQmlItem
argument_list|(
operator|*
name|p
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
name|out
argument_list|()
operator|<<
literal|"</li>\n"
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</ul>\n"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Outputs the html detailed documentation for a section   on a QML element reference page.  */
end_comment
begin_function
DECL|function|generateDetailedQmlMember
name|void
name|HtmlGenerator
operator|::
name|generateDetailedQmlMember
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|relative
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERATE_MAC_REFS
name|generateMacRef
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|MemberMark
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlitem\">"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|QmlPropertyGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyGroupNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|QString
name|heading
init|=
name|qpgn
operator|->
name|name
argument_list|()
operator|+
literal|" group"
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"even\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<th class=\"centerAlign\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qpgn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<b>"
operator|<<
name|heading
operator|<<
literal|"</b>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></th></tr>"
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlPropNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qpn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
if|if
condition|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmlreadonly\">read-only</span>"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmldefault\">default</span>"
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|qpn
operator|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlPropNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qpn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
if|if
condition|(
operator|!
name|qpn
operator|->
name|isReadOnlySet
argument_list|()
condition|)
block|{
if|if
condition|(
name|qpn
operator|->
name|declarativeCppNode
argument_list|()
condition|)
name|qpn
operator|->
name|setReadOnly
argument_list|(
operator|!
name|qpn
operator|->
name|isWritable
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qpn
operator|->
name|isReadOnly
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmlreadonly\">read-only</span>"
expr_stmt|;
if|if
condition|(
name|qpn
operator|->
name|isDefault
argument_list|()
condition|)
name|out
argument_list|()
operator|<<
literal|"<span class=\"qmldefault\">default</span>"
expr_stmt|;
name|generateQmlItem
argument_list|(
name|qpn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qsn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qsn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qsn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qshn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qshn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qshn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|qmn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmlproto\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<table class=\"qmlname\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<tr valign=\"top\" class=\"odd\">"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<td class=\"tblQmlFuncNode\"><p>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"<a name=\""
operator|+
name|refForNode
argument_list|(
name|qmn
argument_list|)
operator|+
literal|"\"></a>"
expr_stmt|;
name|generateSynopsis
argument_list|(
name|qmn
argument_list|,
name|relative
argument_list|,
name|marker
argument_list|,
name|CodeMarker
operator|::
name|Detailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</p></td></tr>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</table>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|"<div class=\"qmldoc\">"
expr_stmt|;
name|generateStatus
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateBody
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateThreadSafeness
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateSince
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|generateAlsoList
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"</div>"
expr_stmt|;
name|generateExtractionMark
argument_list|(
name|node
argument_list|,
name|EndMark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Output the "Inherits" line for the QML element,   if there should be one.  */
end_comment
begin_function
DECL|function|generateQmlInherits
name|void
name|HtmlGenerator
operator|::
name|generateQmlInherits
parameter_list|(
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qcn
condition|)
return|return;
name|QmlClassNode
modifier|*
name|base
init|=
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
decl_stmt|;
while|while
condition|(
name|base
operator|&&
name|base
operator|->
name|isInternal
argument_list|()
condition|)
block|{
name|base
operator|=
name|base
operator|->
name|qmlBaseNode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|base
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
operator|<<
literal|"Inherits "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|base
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[Xxx instantiates the C++ class QmlGraphicsXxx]"   line for the QML element, if there should be one.    If there is no class node, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateQmlInstantiates
name|void
name|HtmlGenerator
operator|::
name|generateQmlInstantiates
parameter_list|(
name|QmlClassNode
modifier|*
name|qcn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
operator|(
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|)
condition|)
block|{
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|qcn
operator|->
name|name
argument_list|()
decl_stmt|;
comment|/*           Remove the "QML:" prefix, if present.           It shouldn't be present anymore.         */
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// remove the "QML:" prefix
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" instantiates the C++ class "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|qcn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Output the "[QmlGraphicsXxx is instantiated by QML Type Xxx]"   line for the class, if there should be one.    If there is no QML element, or if the class node status   is set to Node::Internal, do nothing.  */
end_comment
begin_function
DECL|function|generateInstantiatedBy
name|void
name|HtmlGenerator
operator|::
name|generateInstantiatedBy
parameter_list|(
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Internal
operator|&&
name|cn
operator|->
name|qmlElement
argument_list|()
operator|!=
literal|0
condition|)
block|{
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|cn
operator|->
name|qmlElement
argument_list|()
decl_stmt|;
name|Text
name|text
decl_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaLeft
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
literal|" is instantiated by QML Type "
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|LinkNode
argument_list|,
name|CodeMarker
operator|::
name|stringForNode
argument_list|(
name|qcn
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|qcn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|text
operator|<<
name|Atom
operator|::
name|ParaRight
expr_stmt|;
name|generateText
argument_list|(
name|text
argument_list|,
name|cn
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateExtractionMark
name|void
name|HtmlGenerator
operator|::
name|generateExtractionMark
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|ExtractionMarkType
name|markType
parameter_list|)
block|{
if|if
condition|(
name|markType
operator|!=
name|EndMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"<!-- $$$"
operator|+
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|markType
operator|==
name|MemberMark
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|==
literal|1
condition|)
name|out
argument_list|()
operator|<<
literal|"[overload1]"
expr_stmt|;
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|+
name|func
operator|->
name|rawParameters
argument_list|()
operator|.
name|remove
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-prop"
expr_stmt|;
specifier|const
name|PropertyNode
modifier|*
name|prop
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|list
init|=
name|prop
operator|->
name|functions
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|propFuncNode
decl|,
name|list
control|)
block|{
if|if
condition|(
name|propFuncNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|propFuncNode
argument_list|)
decl_stmt|;
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|func
operator|->
name|name
argument_list|()
operator|+
name|func
operator|->
name|rawParameters
argument_list|()
operator|.
name|remove
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enumNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|enumNode
operator|->
name|items
argument_list|()
control|)
name|out
argument_list|()
operator|<<
literal|"$$$"
operator|+
name|item
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|markType
operator|==
name|BriefMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-brief"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markType
operator|==
name|DetailedDescriptionMark
condition|)
block|{
name|out
argument_list|()
operator|<<
literal|"-description"
expr_stmt|;
block|}
name|out
argument_list|()
operator|<<
literal|" -->\n"
expr_stmt|;
block|}
else|else
block|{
name|out
argument_list|()
operator|<<
literal|"<!-- @@@"
operator|+
name|node
operator|->
name|name
argument_list|()
operator|+
literal|" -->\n"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function outputs one or more manifest files in XML.   They are used by Creator.  */
end_comment
begin_function
DECL|function|generateManifestFiles
name|void
name|HtmlGenerator
operator|::
name|generateManifestFiles
parameter_list|()
block|{
name|generateManifestFile
argument_list|(
literal|"examples"
argument_list|,
literal|"example"
argument_list|)
expr_stmt|;
name|generateManifestFile
argument_list|(
literal|"demos"
argument_list|,
literal|"demo"
argument_list|)
expr_stmt|;
name|qdb_
operator|->
name|exampleNodeMap
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|manifestMetaContent
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is called by generateManifestFiles(), once   for each manifest file to be generated. \a manifest is the   type of manifest file.  */
end_comment
begin_function
DECL|function|generateManifestFile
name|void
name|HtmlGenerator
operator|::
name|generateManifestFile
parameter_list|(
name|QString
name|manifest
parameter_list|,
name|QString
name|element
parameter_list|)
block|{
name|ExampleNodeMap
modifier|&
name|exampleNodeMap
init|=
name|qdb_
operator|->
name|exampleNodeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|exampleNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|fileName
init|=
name|manifest
operator|+
literal|"-manifest.xml"
decl_stmt|;
name|QFile
name|file
argument_list|(
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
return|return ;
name|bool
name|demos
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|manifest
operator|==
literal|"demos"
condition|)
name|demos
operator|=
literal|true
expr_stmt|;
name|bool
name|proceed
init|=
literal|false
decl_stmt|;
name|ExampleNodeMap
operator|::
name|Iterator
name|i
init|=
name|exampleNodeMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|exampleNodeMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|en
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|demos
condition|)
block|{
if|if
condition|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
name|proceed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
name|proceed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|proceed
condition|)
return|return;
name|QXmlStreamWriter
name|writer
argument_list|(
operator|&
name|file
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartDocument
argument_list|()
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"instructionals"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|project
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
name|manifest
argument_list|)
expr_stmt|;
name|i
operator|=
name|exampleNodeMap
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|exampleNodeMap
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|ExampleNode
modifier|*
name|en
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|demos
condition|)
block|{
if|if
condition|(
operator|!
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"demos"
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|writer
operator|.
name|writeStartElement
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|en
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|docUrl
init|=
name|manifestDir
operator|+
name|fileBase
argument_list|(
name|en
argument_list|)
operator|+
literal|".html"
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"docUrl"
argument_list|,
name|docUrl
argument_list|)
expr_stmt|;
name|QStringList
name|proFiles
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|child
decl|,
name|en
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|QString
name|file
init|=
name|child
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|endsWith
argument_list|(
literal|".pro"
argument_list|)
operator|||
name|file
operator|.
name|endsWith
argument_list|(
literal|".qmlproject"
argument_list|)
condition|)
block|{
name|proFiles
operator|<<
name|file
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|proFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|proFiles
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|exampleName
init|=
name|en
operator|->
name|name
argument_list|()
operator|.
name|split
argument_list|(
literal|'/'
argument_list|)
operator|.
name|last
argument_list|()
decl_stmt|;
name|bool
name|proWithExampleNameFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|proFiles
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|proFiles
index|[
name|j
index|]
operator|.
name|endsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"%1/%1.pro"
argument_list|)
operator|.
name|arg
argument_list|(
name|exampleName
argument_list|)
argument_list|)
operator|||
name|proFiles
index|[
name|j
index|]
operator|.
name|endsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"%1/%1.qmlproject"
argument_list|)
operator|.
name|arg
argument_list|(
name|exampleName
argument_list|)
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|proWithExampleNameFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|proWithExampleNameFound
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"projectPath"
argument_list|,
name|examplesPath
operator|+
name|proFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|en
operator|->
name|imageFileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"imageUrl"
argument_list|,
name|manifestDir
operator|+
name|en
operator|->
name|imageFileName
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|fullName
init|=
name|project
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|en
operator|->
name|title
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|tags
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|manifestMetaContent
operator|.
name|size
argument_list|()
condition|;
operator|++
name|idx
control|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|manifestMetaContent
index|[
name|idx
index|]
operator|.
name|names
control|)
block|{
name|bool
name|match
init|=
literal|false
decl_stmt|;
name|int
name|wildcard
init|=
name|name
operator|.
name|indexOf
argument_list|(
name|QChar
argument_list|(
literal|'*'
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|wildcard
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|// no wildcard, exact match
name|match
operator|=
operator|(
name|fullName
operator|==
name|name
operator|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|// '*' matches all
name|match
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
comment|// match with wildcard at the end
name|match
operator|=
name|fullName
operator|.
name|startsWith
argument_list|(
name|name
operator|.
name|left
argument_list|(
name|wildcard
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|tags
operator|+=
name|manifestMetaContent
index|[
name|idx
index|]
operator|.
name|tags
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|attr
decl|,
name|manifestMetaContent
index|[
name|idx
index|]
operator|.
name|attributes
control|)
block|{
name|QLatin1Char
name|div
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|QStringList
name|attrList
init|=
name|attr
operator|.
name|split
argument_list|(
name|div
argument_list|)
decl_stmt|;
if|if
condition|(
name|attrList
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
name|attrList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|attrName
init|=
name|attrList
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
name|attrName
argument_list|,
name|attrList
operator|.
name|join
argument_list|(
name|div
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"description"
argument_list|)
expr_stmt|;
name|Text
name|brief
init|=
name|en
operator|->
name|doc
argument_list|()
operator|.
name|briefText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|brief
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeCDATA
argument_list|(
name|brief
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writer
operator|.
name|writeCDATA
argument_list|(
name|QString
argument_list|(
literal|"No description available"
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// description
comment|// Add words from module name as tags (QtQuickControls -> qt,quick,controls)
name|QRegExp
name|re
argument_list|(
literal|"([A-Z]+[a-z0-9]*)"
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|pos
operator|=
name|re
operator|.
name|indexIn
argument_list|(
name|project
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tags
operator|<<
name|re
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|pos
operator|+=
name|re
operator|.
name|matchedLength
argument_list|()
expr_stmt|;
block|}
name|tags
operator|+=
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|fromList
argument_list|(
name|en
operator|->
name|title
argument_list|()
operator|.
name|toLower
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"tags"
argument_list|)
expr_stmt|;
name|bool
name|wrote_one
init|=
literal|false
decl_stmt|;
comment|// Exclude invalid and common words
foreach|foreach
control|(
name|QString
name|tag
decl|,
name|tags
control|)
block|{
if|if
condition|(
name|tag
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isDigit
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|==
name|QStringLiteral
argument_list|(
literal|"qt"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|startsWith
argument_list|(
literal|"example"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|startsWith
argument_list|(
literal|"chapter"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
name|tag
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote_one
condition|)
name|writer
operator|.
name|writeCharacters
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|wrote_one
operator|=
literal|true
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// tags
block|}
name|QString
name|ename
init|=
name|en
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|en
operator|->
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|usedNames
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|child
decl|,
name|en
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|File
condition|)
block|{
name|QString
name|file
init|=
name|child
operator|->
name|name
argument_list|()
decl_stmt|;
name|QString
name|fileName
init|=
name|file
operator|.
name|mid
argument_list|(
name|file
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QString
name|baseName
init|=
name|fileName
decl_stmt|;
if|if
condition|(
operator|(
name|fileName
operator|.
name|count
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".cpp"
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".h"
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".qml"
argument_list|)
operator|)
condition|)
name|baseName
operator|.
name|truncate
argument_list|(
name|baseName
operator|.
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseName
operator|.
name|compare
argument_list|(
name|ename
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|usedNames
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"fileToOpen"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|examplesPath
operator|+
name|file
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// fileToOpen
name|usedNames
operator|.
name|insert
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|toLower
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"main.cpp"
argument_list|)
operator|||
name|fileName
operator|.
name|toLower
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"main.qml"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|usedNames
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"fileToOpen"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeCharacters
argument_list|(
name|examplesPath
operator|+
name|file
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// fileToOpen
name|usedNames
operator|.
name|insert
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// example
operator|++
name|i
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// examples
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// instructionals
name|writer
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Reads metacontent - additional attributes and tags to apply   when generating manifest files, read from config. Takes the   configuration class \a config as a parameter.  */
end_comment
begin_function
DECL|function|readManifestMetaContent
name|void
name|HtmlGenerator
operator|::
name|readManifestMetaContent
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|QStringList
name|names
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_MANIFESTMETA
operator|+
name|Config
operator|::
name|dot
operator|+
name|QStringLiteral
argument_list|(
literal|"filters"
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|manifest
decl|,
name|names
control|)
block|{
name|ManifestMetaFilter
name|filter
decl_stmt|;
name|QString
name|prefix
init|=
name|CONFIG_MANIFESTMETA
operator|+
name|Config
operator|::
name|dot
operator|+
name|manifest
operator|+
name|Config
operator|::
name|dot
decl_stmt|;
name|filter
operator|.
name|names
operator|=
name|config
operator|.
name|getStringSet
argument_list|(
name|prefix
operator|+
name|QStringLiteral
argument_list|(
literal|"names"
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|attributes
operator|=
name|config
operator|.
name|getStringSet
argument_list|(
name|prefix
operator|+
name|QStringLiteral
argument_list|(
literal|"attributes"
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|tags
operator|=
name|config
operator|.
name|getStringSet
argument_list|(
name|prefix
operator|+
name|QStringLiteral
argument_list|(
literal|"tags"
argument_list|)
argument_list|)
expr_stmt|;
name|manifestMetaContent
operator|.
name|append
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find global entities that have documentation but no   \e{relates} comand. Report these as errors if they   are not also marked \e {internal}.    type: Class   type: Namespace    subtype: Example   subtype: External page   subtype: Group   subtype: Header file   subtype: Module   subtype: Page   subtype: QML basic type   subtype: QML class   subtype: QML module  */
end_comment
begin_function
DECL|function|reportOrphans
name|void
name|HtmlGenerator
operator|::
name|reportOrphans
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|bool
name|related
decl_stmt|;
name|QString
name|message
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|isInternal
argument_list|()
operator|||
name|child
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|relates
argument_list|()
condition|)
block|{
name|related
operator|=
literal|true
expr_stmt|;
name|message
operator|=
name|child
operator|->
name|relates
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|related
operator|=
literal|false
expr_stmt|;
name|message
operator|=
literal|"has documentation but no \\relates command"
expr_stmt|;
block|}
switch|switch
condition|(
name|child
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
break|break;
case|case
name|Node
operator|::
name|Class
case|:
break|break;
case|case
name|Node
operator|::
name|QmlType
case|:
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
break|break;
case|case
name|Node
operator|::
name|Group
case|:
break|break;
case|case
name|Node
operator|::
name|Module
case|:
break|break;
case|case
name|Node
operator|::
name|QmlModule
case|:
break|break;
case|case
name|Node
operator|::
name|Document
case|:
switch|switch
condition|(
name|child
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Example
case|:
break|break;
case|case
name|Node
operator|::
name|HeaderFile
case|:
break|break;
case|case
name|Node
operator|::
name|File
case|:
break|break;
case|case
name|Node
operator|::
name|Image
case|:
break|break;
case|case
name|Node
operator|::
name|Page
case|:
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
break|break;
case|case
name|Node
operator|::
name|Collision
case|:
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global enum, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global typedef, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
if|if
condition|(
operator|!
name|related
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|isMacro
argument_list|()
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global macro, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global function, %1(), %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Property
case|:
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global variable, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML property, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML, signal, %1 %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML signal handler, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
if|if
condition|(
operator|!
name|related
condition|)
name|child
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Global QML method, %1, %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Returns a reference to the XML stream writer currently in use.   There is one XML stream writer open for each XML file being   written, and they are kept on a stack. The one on top of the   stack is the one being written to at the moment. In the HTML   output generator, it is perhaps impossible for there to ever   be more than one writer open.  */
end_comment
begin_function
DECL|function|xmlWriter
name|QXmlStreamWriter
modifier|&
name|HtmlGenerator
operator|::
name|xmlWriter
parameter_list|()
block|{
return|return
operator|*
name|xmlWriterStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Calls beginSubPage() in the base class to open the file.   Then creates a new XML stream writer using the IO device   from opened file and pushes the XML writer onto a stackj.   Creates the file named \a fileName in the output directory.   Attaches a QTextStream to the created file, which is written   to all over the place using out(). Finally, it sets some   parameters in the XML writer and calls writeStartDocument().    It also ensures that a GUID map is created for the output file.  */
end_comment
begin_function
DECL|function|beginDitamapPage
name|void
name|HtmlGenerator
operator|::
name|beginDitamapPage
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Generator
operator|::
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|QXmlStreamWriter
modifier|*
name|writer
init|=
operator|new
name|QXmlStreamWriter
argument_list|(
name|out
argument_list|()
operator|.
name|device
argument_list|()
argument_list|)
decl_stmt|;
name|xmlWriterStack
operator|.
name|push
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|->
name|setAutoFormattingIndent
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|writer
operator|->
name|writeStartDocument
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Calls writeEndDocument() and then pops the XML stream writer   off the stack and deletes it. Then it calls endSubPage() in   the base class to close the device.  */
end_comment
begin_function
DECL|function|endDitamapPage
name|void
name|HtmlGenerator
operator|::
name|endDitamapPage
parameter_list|()
block|{
name|xmlWriter
argument_list|()
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
operator|delete
name|xmlWriterStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|Generator
operator|::
name|endSubPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is only called for writing ditamaps.    Creates the DITA map from the topicrefs in \a node,   which is a DitaMapNode.  */
end_comment
begin_function
DECL|function|writeDitaMap
name|void
name|HtmlGenerator
operator|::
name|writeDitaMap
parameter_list|(
specifier|const
name|DitaMapNode
modifier|*
name|node
parameter_list|)
block|{
name|beginDitamapPage
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|doctype
init|=
literal|"<!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\">"
decl_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeDTD
argument_list|(
name|doctype
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"map"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"topicmeta"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"shortdesc"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeCharacters
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</shortdesc>
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</topicmeta>
name|DitaRefList
name|map
init|=
name|node
operator|->
name|map
argument_list|()
decl_stmt|;
name|writeDitaRefs
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|endDitamapPage
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Write the \a ditarefs to the current output file.  */
end_comment
begin_function
DECL|function|writeDitaRefs
name|void
name|HtmlGenerator
operator|::
name|writeDitaRefs
parameter_list|(
specifier|const
name|DitaRefList
modifier|&
name|ditarefs
parameter_list|)
block|{
foreach|foreach
control|(
name|DitaRef
modifier|*
name|t
decl|,
name|ditarefs
control|)
block|{
if|if
condition|(
name|t
operator|->
name|isMapRef
argument_list|()
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"mapref"
argument_list|)
expr_stmt|;
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeStartElement
argument_list|(
literal|"topicref"
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"navtitle"
argument_list|,
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|href
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|fn
init|=
name|qdb_
operator|->
name|findDocNodeByTitle
argument_list|(
name|t
operator|->
name|navtitle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|fileName
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|xmlWriter
argument_list|()
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|t
operator|->
name|href
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|subrefs
argument_list|()
operator|&&
operator|!
name|t
operator|->
name|subrefs
argument_list|()
operator|->
name|isEmpty
argument_list|()
condition|)
name|writeDitaRefs
argument_list|(
operator|*
operator|(
name|t
operator|->
name|subrefs
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|xmlWriter
argument_list|()
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|//</topicref> or</mapref>
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
