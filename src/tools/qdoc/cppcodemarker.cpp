begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   cppcodemarker.cpp */
end_comment
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"cppcodemarker.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!   The constructor does nothing.  */
DECL|function|CppCodeMarker
name|CppCodeMarker
operator|::
name|CppCodeMarker
parameter_list|()
block|{
comment|// nothing.
block|}
end_function
begin_comment
comment|/*!   The destructor does nothing.  */
end_comment
begin_destructor
DECL|function|~CppCodeMarker
name|CppCodeMarker
operator|::
name|~
name|CppCodeMarker
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Returns true.  */
end_comment
begin_function
DECL|function|recognizeCode
name|bool
name|CppCodeMarker
operator|::
name|recognizeCode
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/* code */
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if \a ext is any of a list of file extensions   for the C++ language.  */
end_comment
begin_function
DECL|function|recognizeExtension
name|bool
name|CppCodeMarker
operator|::
name|recognizeExtension
parameter_list|(
specifier|const
name|QString
modifier|&
name|extension
parameter_list|)
block|{
name|QByteArray
name|ext
init|=
name|extension
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
return|return
name|ext
operator|==
literal|"c"
operator|||
name|ext
operator|==
literal|"c++"
operator|||
name|ext
operator|==
literal|"qdoc"
operator|||
name|ext
operator|==
literal|"qtt"
operator|||
name|ext
operator|==
literal|"qtx"
operator|||
name|ext
operator|==
literal|"cc"
operator|||
name|ext
operator|==
literal|"cpp"
operator|||
name|ext
operator|==
literal|"cxx"
operator|||
name|ext
operator|==
literal|"ch"
operator|||
name|ext
operator|==
literal|"h"
operator|||
name|ext
operator|==
literal|"h++"
operator|||
name|ext
operator|==
literal|"hh"
operator|||
name|ext
operator|==
literal|"hpp"
operator|||
name|ext
operator|==
literal|"hxx"
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if \a lang is either "C" or "Cpp".  */
end_comment
begin_function
DECL|function|recognizeLanguage
name|bool
name|CppCodeMarker
operator|::
name|recognizeLanguage
parameter_list|(
specifier|const
name|QString
modifier|&
name|lang
parameter_list|)
block|{
return|return
name|lang
operator|==
name|QLatin1String
argument_list|(
literal|"C"
argument_list|)
operator|||
name|lang
operator|==
name|QLatin1String
argument_list|(
literal|"Cpp"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the type of atom used to represent C++ code in the documentation. */
end_comment
begin_function
DECL|function|atomType
name|Atom
operator|::
name|Type
name|CppCodeMarker
operator|::
name|atomType
parameter_list|()
specifier|const
block|{
return|return
name|Atom
operator|::
name|Code
return|;
block|}
end_function
begin_function
DECL|function|markedUpCode
name|QString
name|CppCodeMarker
operator|::
name|markedUpCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|code
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
block|{
return|return
name|addMarkUp
argument_list|(
name|code
argument_list|,
name|relative
argument_list|,
name|location
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|markedUpSynopsis
name|QString
name|CppCodeMarker
operator|::
name|markedUpSynopsis
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
comment|/* relative */
parameter_list|,
name|SynopsisStyle
name|style
parameter_list|)
block|{
specifier|const
name|int
name|MaxEnumValues
init|=
literal|6
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|func
decl_stmt|;
specifier|const
name|PropertyNode
modifier|*
name|property
decl_stmt|;
specifier|const
name|VariableNode
modifier|*
name|variable
decl_stmt|;
specifier|const
name|EnumNode
modifier|*
name|enume
decl_stmt|;
specifier|const
name|TypedefNode
modifier|*
name|typedeff
decl_stmt|;
name|QString
name|synopsis
decl_stmt|;
name|QString
name|extra
decl_stmt|;
name|QString
name|name
decl_stmt|;
name|name
operator|=
name|taggedNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|!=
name|Detailed
condition|)
name|name
operator|=
name|linkTag
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"<@name>"
operator|+
name|name
operator|+
literal|"</@name>"
expr_stmt|;
if|if
condition|(
operator|(
name|style
operator|==
name|Detailed
operator|)
operator|&&
operator|!
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Property
operator|)
operator|&&
operator|!
name|node
operator|->
name|isQmlNode
argument_list|()
condition|)
name|name
operator|.
name|prepend
argument_list|(
name|taggedNode
argument_list|(
name|node
operator|->
name|parent
argument_list|()
argument_list|)
operator|+
literal|"::"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|synopsis
operator|=
literal|"namespace "
operator|+
name|name
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|synopsis
operator|=
literal|"class "
operator|+
name|name
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|QmlSignal
case|:
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|func
operator|=
operator|(
specifier|const
name|FunctionNode
operator|*
operator|)
name|node
expr_stmt|;
if|if
condition|(
name|style
operator|!=
name|Subpage
operator|&&
operator|!
name|func
operator|->
name|returnType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|synopsis
operator|=
name|typified
argument_list|(
name|func
operator|->
name|returnType
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|synopsis
operator|+=
name|name
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
block|{
name|synopsis
operator|+=
literal|"("
expr_stmt|;
if|if
condition|(
operator|!
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//synopsis += QLatin1Char(' ');
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
condition|)
name|synopsis
operator|+=
literal|", "
expr_stmt|;
name|synopsis
operator|+=
name|typified
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|leftType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|!=
name|Subpage
operator|&&
operator|!
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|synopsis
operator|+=
literal|"<@param>"
operator|+
name|protect
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|"</@param>"
expr_stmt|;
name|synopsis
operator|+=
name|protect
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|!=
name|Subpage
operator|&&
operator|!
operator|(
operator|*
name|p
operator|)
operator|.
name|defaultValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|synopsis
operator|+=
literal|" = "
operator|+
name|protect
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|defaultValue
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|//synopsis += QLatin1Char(' ');
block|}
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|->
name|isConst
argument_list|()
condition|)
name|synopsis
operator|+=
literal|" const"
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|Summary
operator|||
name|style
operator|==
name|Accessors
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|synopsis
operator|.
name|prepend
argument_list|(
literal|"virtual "
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|PureVirtual
condition|)
name|synopsis
operator|.
name|append
argument_list|(
literal|" = 0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Subpage
condition|)
block|{
if|if
condition|(
operator|!
name|func
operator|->
name|returnType
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|func
operator|->
name|returnType
argument_list|()
operator|!=
literal|"void"
condition|)
name|synopsis
operator|+=
literal|" : "
operator|+
name|typified
argument_list|(
name|func
operator|->
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|bracketed
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|isStatic
argument_list|()
condition|)
block|{
name|bracketed
operator|+=
literal|"static"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|PureVirtual
condition|)
name|bracketed
operator|+=
literal|"pure"
expr_stmt|;
name|bracketed
operator|+=
literal|"virtual"
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Protected
condition|)
block|{
name|bracketed
operator|+=
literal|"protected"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|bracketed
operator|+=
literal|"private"
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Signal
condition|)
block|{
name|bracketed
operator|+=
literal|"signal"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Slot
condition|)
block|{
name|bracketed
operator|+=
literal|"slot"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bracketed
operator|.
name|isEmpty
argument_list|()
condition|)
name|extra
operator|+=
literal|" ["
operator|+
name|bracketed
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|enume
operator|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|synopsis
operator|=
literal|"enum "
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|Summary
condition|)
block|{
name|synopsis
operator|+=
literal|" { "
expr_stmt|;
name|QStringList
name|documentedItems
init|=
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|enumItemNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|documentedItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|enume
operator|->
name|items
argument_list|()
control|)
name|documentedItems
operator|<<
name|item
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
name|QStringList
name|omitItems
init|=
name|enume
operator|->
name|doc
argument_list|()
operator|.
name|omitEnumItemNames
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|item
decl|,
name|omitItems
control|)
name|documentedItems
operator|.
name|removeAll
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|documentedItems
operator|.
name|size
argument_list|()
operator|<=
name|MaxEnumValues
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|documentedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|synopsis
operator|+=
literal|", "
expr_stmt|;
name|synopsis
operator|+=
name|documentedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|documentedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|<
name|MaxEnumValues
operator|-
literal|2
operator|||
name|i
operator|==
name|documentedItems
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|synopsis
operator|+=
literal|", "
expr_stmt|;
name|synopsis
operator|+=
name|documentedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|MaxEnumValues
operator|-
literal|1
condition|)
block|{
name|synopsis
operator|+=
literal|", ..."
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|documentedItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|typedeff
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|typedeff
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|synopsis
operator|=
literal|"flags "
operator|+
name|name
expr_stmt|;
block|}
else|else
block|{
name|synopsis
operator|=
literal|"typedef "
operator|+
name|name
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|property
operator|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|synopsis
operator|=
name|name
operator|+
literal|" : "
operator|+
name|typified
argument_list|(
name|property
operator|->
name|qualifiedDataType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|variable
operator|=
cast|static_cast
argument_list|<
specifier|const
name|VariableNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|Subpage
condition|)
block|{
name|synopsis
operator|=
name|name
operator|+
literal|" : "
operator|+
name|typified
argument_list|(
name|variable
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|synopsis
operator|=
name|typified
argument_list|(
name|variable
operator|->
name|leftType
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|name
operator|+
name|protect
argument_list|(
name|variable
operator|->
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|synopsis
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|Summary
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Preliminary
condition|)
block|{
name|extra
operator|+=
literal|" (preliminary)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Deprecated
condition|)
block|{
name|extra
operator|+=
literal|" (deprecated)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|extra
operator|+=
literal|" (obsolete)"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|extra
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|extra
operator|.
name|prepend
argument_list|(
literal|"<@extra>"
argument_list|)
expr_stmt|;
name|extra
operator|.
name|append
argument_list|(
literal|"</@extra>"
argument_list|)
expr_stmt|;
block|}
return|return
name|synopsis
operator|+
name|extra
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|markedUpQmlItem
name|QString
name|CppCodeMarker
operator|::
name|markedUpQmlItem
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|summary
parameter_list|)
block|{
name|QString
name|name
init|=
name|taggedQmlNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|summary
condition|)
name|name
operator|=
name|linkTag
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
specifier|const
name|QmlPropertyNode
modifier|*
name|pn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|isAttached
argument_list|()
condition|)
name|name
operator|.
name|prepend
argument_list|(
name|pn
operator|->
name|element
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
literal|"<@name>"
operator|+
name|name
operator|+
literal|"</@name>"
expr_stmt|;
name|QString
name|synopsis
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
specifier|const
name|QmlPropertyNode
modifier|*
name|pn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|synopsis
operator|=
name|name
operator|+
literal|" : "
operator|+
name|typified
argument_list|(
name|pn
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
operator|)
operator|||
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
operator|)
operator|||
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
operator|)
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|func
operator|->
name|returnType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|synopsis
operator|=
name|typified
argument_list|(
name|func
operator|->
name|returnType
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|name
expr_stmt|;
else|else
name|synopsis
operator|=
name|name
expr_stmt|;
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|func
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
condition|)
name|synopsis
operator|+=
literal|", "
expr_stmt|;
name|synopsis
operator|+=
name|typified
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|leftType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|synopsis
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
argument_list|)
condition|)
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|synopsis
operator|+=
literal|"<@param>"
operator|+
name|protect
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|"</@param>"
expr_stmt|;
block|}
name|synopsis
operator|+=
name|protect
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|.
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|synopsis
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|synopsis
operator|=
name|name
expr_stmt|;
name|QString
name|extra
decl_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Preliminary
condition|)
block|{
name|extra
operator|+=
literal|" (preliminary)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Deprecated
condition|)
block|{
name|extra
operator|+=
literal|" (deprecated)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
name|extra
operator|+=
literal|" (obsolete)"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|extra
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|extra
operator|.
name|prepend
argument_list|(
literal|"<@extra>"
argument_list|)
expr_stmt|;
name|extra
operator|.
name|append
argument_list|(
literal|"</@extra>"
argument_list|)
expr_stmt|;
block|}
return|return
name|synopsis
operator|+
name|extra
return|;
block|}
end_function
begin_function
DECL|function|markedUpName
name|QString
name|CppCodeMarker
operator|::
name|markedUpName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|name
init|=
name|linkTag
argument_list|(
name|node
argument_list|,
name|taggedNode
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
name|name
operator|+=
literal|"()"
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|markedUpFullName
name|QString
name|CppCodeMarker
operator|::
name|markedUpFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"global"
return|;
block|}
else|else
block|{
name|QString
name|fullName
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fullName
operator|.
name|prepend
argument_list|(
name|markedUpName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|==
name|relative
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|fullName
operator|.
name|prepend
argument_list|(
literal|"<@op>::</@op>"
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
name|fullName
return|;
block|}
block|}
end_function
begin_function
DECL|function|markedUpEnumValue
name|QString
name|CppCodeMarker
operator|::
name|markedUpEnumValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|enumValue
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QString
name|fullName
decl_stmt|;
while|while
condition|(
name|node
operator|->
name|parent
argument_list|()
condition|)
block|{
name|fullName
operator|.
name|prepend
argument_list|(
name|markedUpName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|==
name|relative
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isCollisionNode
argument_list|()
condition|)
break|break;
name|fullName
operator|.
name|prepend
argument_list|(
literal|"<@op>::</@op>"
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fullName
operator|.
name|isEmpty
argument_list|()
condition|)
name|fullName
operator|.
name|append
argument_list|(
literal|"<@op>::</@op>"
argument_list|)
expr_stmt|;
name|fullName
operator|.
name|append
argument_list|(
name|enumValue
argument_list|)
expr_stmt|;
return|return
name|fullName
return|;
block|}
end_function
begin_function
DECL|function|markedUpIncludes
name|QString
name|CppCodeMarker
operator|::
name|markedUpIncludes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|includes
parameter_list|)
block|{
name|QString
name|code
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|inc
init|=
name|includes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|inc
operator|!=
name|includes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|code
operator|+=
literal|"<@preprocessor>#include&lt;<@headerfile>"
operator|+
operator|*
name|inc
operator|+
literal|"</@headerfile>&gt;</@preprocessor>\n"
expr_stmt|;
operator|++
name|inc
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function
begin_function
DECL|function|functionBeginRegExp
name|QString
name|CppCodeMarker
operator|::
name|functionBeginRegExp
parameter_list|(
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|)
block|{
return|return
name|QLatin1Char
argument_list|(
literal|'^'
argument_list|)
operator|+
name|QRegExp
operator|::
name|escape
argument_list|(
name|funcName
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'$'
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|functionEndRegExp
name|QString
name|CppCodeMarker
operator|::
name|functionEndRegExp
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/* funcName */
parameter_list|)
block|{
return|return
literal|"^\\}$"
return|;
block|}
end_function
begin_function
DECL|function|sections
name|QList
argument_list|<
name|Section
argument_list|>
name|CppCodeMarker
operator|::
name|sections
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|,
name|SynopsisStyle
name|style
parameter_list|,
name|Status
name|status
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|classNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Summary
condition|)
block|{
name|FastSection
name|privateFunctions
argument_list|(
name|classNode
argument_list|,
literal|"Private Functions"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"private function"
argument_list|,
literal|"private functions"
argument_list|)
decl_stmt|;
name|FastSection
name|privateSlots
argument_list|(
name|classNode
argument_list|,
literal|"Private Slots"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"private slot"
argument_list|,
literal|"private slots"
argument_list|)
decl_stmt|;
name|FastSection
name|privateTypes
argument_list|(
name|classNode
argument_list|,
literal|"Private Types"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"private type"
argument_list|,
literal|"private types"
argument_list|)
decl_stmt|;
name|FastSection
name|protectedFunctions
argument_list|(
name|classNode
argument_list|,
literal|"Protected Functions"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"protected function"
argument_list|,
literal|"protected functions"
argument_list|)
decl_stmt|;
name|FastSection
name|protectedSlots
argument_list|(
name|classNode
argument_list|,
literal|"Protected Slots"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"protected slot"
argument_list|,
literal|"protected slots"
argument_list|)
decl_stmt|;
name|FastSection
name|protectedTypes
argument_list|(
name|classNode
argument_list|,
literal|"Protected Types"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"protected type"
argument_list|,
literal|"protected types"
argument_list|)
decl_stmt|;
name|FastSection
name|protectedVariables
argument_list|(
name|classNode
argument_list|,
literal|"Protected Variables"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"protected type"
argument_list|,
literal|"protected variables"
argument_list|)
decl_stmt|;
name|FastSection
name|publicFunctions
argument_list|(
name|classNode
argument_list|,
literal|"Public Functions"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"public function"
argument_list|,
literal|"public functions"
argument_list|)
decl_stmt|;
name|FastSection
name|publicSignals
argument_list|(
name|classNode
argument_list|,
literal|"Signals"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"signal"
argument_list|,
literal|"signals"
argument_list|)
decl_stmt|;
name|FastSection
name|publicSlots
argument_list|(
name|classNode
argument_list|,
literal|"Public Slots"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"public slot"
argument_list|,
literal|"public slots"
argument_list|)
decl_stmt|;
name|FastSection
name|publicTypes
argument_list|(
name|classNode
argument_list|,
literal|"Public Types"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"public type"
argument_list|,
literal|"public types"
argument_list|)
decl_stmt|;
name|FastSection
name|publicVariables
argument_list|(
name|classNode
argument_list|,
literal|"Public Variables"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"public variable"
argument_list|,
literal|"public variables"
argument_list|)
decl_stmt|;
name|FastSection
name|properties
argument_list|(
name|classNode
argument_list|,
literal|"Properties"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"property"
argument_list|,
literal|"properties"
argument_list|)
decl_stmt|;
name|FastSection
name|relatedNonMembers
argument_list|(
name|classNode
argument_list|,
literal|"Related Non-Members"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"related non-member"
argument_list|,
literal|"related non-members"
argument_list|)
decl_stmt|;
name|FastSection
name|staticPrivateMembers
argument_list|(
name|classNode
argument_list|,
literal|"Static Private Members"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"static private member"
argument_list|,
literal|"static private members"
argument_list|)
decl_stmt|;
name|FastSection
name|staticProtectedMembers
argument_list|(
name|classNode
argument_list|,
literal|"Static Protected Members"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"static protected member"
argument_list|,
literal|"static protected members"
argument_list|)
decl_stmt|;
name|FastSection
name|staticPublicMembers
argument_list|(
name|classNode
argument_list|,
literal|"Static Public Members"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"static public member"
argument_list|,
literal|"static public members"
argument_list|)
decl_stmt|;
name|FastSection
name|macros
argument_list|(
name|inner
argument_list|,
literal|"Macros"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"macro"
argument_list|,
literal|"macros"
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|r
init|=
name|classNode
operator|->
name|relatedNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classNode
operator|->
name|relatedNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|isMacro
argument_list|()
condition|)
name|insert
argument_list|(
name|macros
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|relatedNonMembers
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert
argument_list|(
name|relatedNonMembers
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
name|QStack
argument_list|<
specifier|const
name|ClassNode
modifier|*
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|classNode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|ancestorClass
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|ancestorClass
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|ancestorClass
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|bool
name|isSlot
init|=
literal|false
decl_stmt|;
name|bool
name|isSignal
init|=
literal|false
decl_stmt|;
name|bool
name|isStatic
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
operator|(
specifier|const
name|FunctionNode
operator|*
operator|)
operator|*
name|c
decl_stmt|;
name|isSlot
operator|=
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Slot
operator|)
expr_stmt|;
name|isSignal
operator|=
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Signal
operator|)
expr_stmt|;
name|isStatic
operator|=
name|func
operator|->
name|isStatic
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|associatedProperty
argument_list|()
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
condition|)
block|{
operator|++
name|c
expr_stmt|;
continue|continue;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
specifier|const
name|VariableNode
modifier|*
name|var
init|=
cast|static_cast
argument_list|<
specifier|const
name|VariableNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|isStatic
operator|=
name|var
operator|->
name|isStatic
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Public
case|:
if|if
condition|(
name|isSlot
condition|)
block|{
name|insert
argument_list|(
name|publicSlots
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSignal
condition|)
block|{
name|insert
argument_list|(
name|publicSignals
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isStatic
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Variable
operator|||
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|staticPublicMembers
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|insert
argument_list|(
name|properties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|publicVariables
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
if|if
condition|(
operator|!
name|insertReimpFunc
argument_list|(
name|publicFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|publicFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insert
argument_list|(
name|publicTypes
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Protected
case|:
if|if
condition|(
name|isSlot
condition|)
block|{
name|insert
argument_list|(
name|protectedSlots
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isStatic
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Variable
operator|||
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|staticProtectedMembers
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|protectedVariables
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
if|if
condition|(
operator|!
name|insertReimpFunc
argument_list|(
name|protectedFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|protectedFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insert
argument_list|(
name|protectedTypes
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Private
case|:
if|if
condition|(
name|isSlot
condition|)
block|{
name|insert
argument_list|(
name|privateSlots
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isStatic
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Variable
operator|||
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|staticPrivateMembers
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
if|if
condition|(
operator|!
name|insertReimpFunc
argument_list|(
name|privateFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|privateFunctions
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insert
argument_list|(
name|privateTypes
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|ancestorClass
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|ancestorClass
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|stack
operator|.
name|prepend
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|)
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|publicTypes
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|properties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|publicFunctions
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|publicSlots
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|publicSignals
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|publicVariables
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|staticPublicMembers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|protectedTypes
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|protectedFunctions
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|protectedSlots
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|protectedVariables
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|staticProtectedMembers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|privateTypes
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|privateFunctions
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|privateSlots
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|staticPrivateMembers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|relatedNonMembers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|macros
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Detailed
condition|)
block|{
name|FastSection
name|memberFunctions
argument_list|(
name|classNode
argument_list|,
literal|"Member Function Documentation"
argument_list|,
literal|"func"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|memberTypes
argument_list|(
name|classNode
argument_list|,
literal|"Member Type Documentation"
argument_list|,
literal|"types"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|memberVariables
argument_list|(
name|classNode
argument_list|,
literal|"Member Variable Documentation"
argument_list|,
literal|"vars"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|properties
argument_list|(
name|classNode
argument_list|,
literal|"Property Documentation"
argument_list|,
literal|"prop"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|relatedNonMembers
argument_list|(
name|classNode
argument_list|,
literal|"Related Non-Members"
argument_list|,
literal|"relnonmem"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|macros
argument_list|(
name|classNode
argument_list|,
literal|"Macro Documentation"
argument_list|,
literal|"macros"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|r
init|=
name|classNode
operator|->
name|relatedNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classNode
operator|->
name|relatedNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|isMacro
argument_list|()
condition|)
name|insert
argument_list|(
name|macros
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|relatedNonMembers
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert
argument_list|(
name|relatedNonMembers
argument_list|,
operator|*
name|r
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|classNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
operator|||
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
name|insert
argument_list|(
name|memberTypes
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|insert
argument_list|(
name|properties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|c
operator|)
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|insert
argument_list|(
name|memberVariables
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|function
operator|->
name|associatedProperty
argument_list|()
condition|)
name|insert
argument_list|(
name|memberFunctions
argument_list|,
name|function
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|memberTypes
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|properties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|memberFunctions
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|memberVariables
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|relatedNonMembers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|macros
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FastSection
name|all
argument_list|(
name|classNode
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|QStack
argument_list|<
specifier|const
name|ClassNode
modifier|*
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|classNode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|ancestorClass
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|ancestorClass
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|ancestorClass
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Property
condition|)
name|insert
argument_list|(
name|all
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|ancestorClass
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|ancestorClass
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|stack
operator|.
name|prepend
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|)
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|all
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|style
operator|==
name|Summary
operator|||
name|style
operator|==
name|Detailed
condition|)
block|{
name|FastSection
name|namespaces
argument_list|(
name|inner
argument_list|,
literal|"Namespaces"
argument_list|,
name|style
operator|==
name|Detailed
condition|?
literal|"nmspace"
else|:
name|QString
argument_list|()
argument_list|,
literal|"namespace"
argument_list|,
literal|"namespaces"
argument_list|)
decl_stmt|;
name|FastSection
name|classes
argument_list|(
name|inner
argument_list|,
literal|"Classes"
argument_list|,
name|style
operator|==
name|Detailed
condition|?
literal|"classes"
else|:
name|QString
argument_list|()
argument_list|,
literal|"class"
argument_list|,
literal|"classes"
argument_list|)
decl_stmt|;
name|FastSection
name|types
argument_list|(
name|inner
argument_list|,
name|style
operator|==
name|Summary
condition|?
literal|"Types"
else|:
literal|"Type Documentation"
argument_list|,
name|style
operator|==
name|Detailed
condition|?
literal|"types"
else|:
name|QString
argument_list|()
argument_list|,
literal|"type"
argument_list|,
literal|"types"
argument_list|)
decl_stmt|;
name|FastSection
name|functions
argument_list|(
name|inner
argument_list|,
name|style
operator|==
name|Summary
condition|?
literal|"Functions"
else|:
literal|"Function Documentation"
argument_list|,
name|style
operator|==
name|Detailed
condition|?
literal|"func"
else|:
name|QString
argument_list|()
argument_list|,
literal|"function"
argument_list|,
literal|"functions"
argument_list|)
decl_stmt|;
name|FastSection
name|macros
argument_list|(
name|inner
argument_list|,
name|style
operator|==
name|Summary
condition|?
literal|"Macros"
else|:
literal|"Macro Documentation"
argument_list|,
name|style
operator|==
name|Detailed
condition|?
literal|"macros"
else|:
name|QString
argument_list|()
argument_list|,
literal|"macro"
argument_list|,
literal|"macros"
argument_list|)
decl_stmt|;
name|NodeList
name|nodeList
init|=
name|inner
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|nodeList
operator|+=
name|inner
operator|->
name|relatedNodes
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|n
init|=
name|nodeList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|nodeList
operator|.
name|constEnd
argument_list|()
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|n
operator|)
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|insert
argument_list|(
name|namespaces
argument_list|,
operator|*
name|n
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|insert
argument_list|(
name|classes
argument_list|,
operator|*
name|n
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
name|insert
argument_list|(
name|types
argument_list|,
operator|*
name|n
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|isMacro
argument_list|()
condition|)
name|insert
argument_list|(
name|macros
argument_list|,
operator|*
name|n
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|functions
argument_list|,
operator|*
name|n
argument_list|,
name|style
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|namespaces
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|classes
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|functions
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|macros
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sections
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|typeTable
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|typeTable
index|[]
init|=
block|{
literal|"bool"
block|,
literal|"char"
block|,
literal|"double"
block|,
literal|"float"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"short"
block|,
literal|"signed"
block|,
literal|"unsigned"
block|,
literal|"uint"
block|,
literal|"ulong"
block|,
literal|"ushort"
block|,
literal|"uchar"
block|,
literal|"void"
block|,
literal|"qlonglong"
block|,
literal|"qulonglong"
block|,
literal|"qint"
block|,
literal|"qint8"
block|,
literal|"qint16"
block|,
literal|"qint32"
block|,
literal|"qint64"
block|,
literal|"quint"
block|,
literal|"quint8"
block|,
literal|"quint16"
block|,
literal|"quint32"
block|,
literal|"quint64"
block|,
literal|"qreal"
block|,
literal|"cond"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keywordTable
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|keywordTable
index|[]
init|=
block|{
literal|"and"
block|,
literal|"and_eq"
block|,
literal|"asm"
block|,
literal|"auto"
block|,
literal|"bitand"
block|,
literal|"bitor"
block|,
literal|"break"
block|,
literal|"case"
block|,
literal|"catch"
block|,
literal|"class"
block|,
literal|"compl"
block|,
literal|"const"
block|,
literal|"const_cast"
block|,
literal|"continue"
block|,
literal|"default"
block|,
literal|"delete"
block|,
literal|"do"
block|,
literal|"dynamic_cast"
block|,
literal|"else"
block|,
literal|"enum"
block|,
literal|"explicit"
block|,
literal|"export"
block|,
literal|"extern"
block|,
literal|"false"
block|,
literal|"for"
block|,
literal|"friend"
block|,
literal|"goto"
block|,
literal|"if"
block|,
literal|"include"
block|,
literal|"inline"
block|,
literal|"monitor"
block|,
literal|"mutable"
block|,
literal|"namespace"
block|,
literal|"new"
block|,
literal|"not"
block|,
literal|"not_eq"
block|,
literal|"operator"
block|,
literal|"or"
block|,
literal|"or_eq"
block|,
literal|"private"
block|,
literal|"protected"
block|,
literal|"public"
block|,
literal|"register"
block|,
literal|"reinterpret_cast"
block|,
literal|"return"
block|,
literal|"sizeof"
block|,
literal|"static"
block|,
literal|"static_cast"
block|,
literal|"struct"
block|,
literal|"switch"
block|,
literal|"template"
block|,
literal|"this"
block|,
literal|"throw"
block|,
literal|"true"
block|,
literal|"try"
block|,
literal|"typedef"
block|,
literal|"typeid"
block|,
literal|"typename"
block|,
literal|"union"
block|,
literal|"using"
block|,
literal|"virtual"
block|,
literal|"volatile"
block|,
literal|"wchar_t"
block|,
literal|"while"
block|,
literal|"xor"
block|,
literal|"xor_eq"
block|,
literal|"synchronized"
block|,
comment|// Qt specific
literal|"signals"
block|,
literal|"slots"
block|,
literal|"emit"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     @char     @class     @comment     @function     @keyword     @number     @op     @preprocessor     @string     @type */
end_comment
begin_function
DECL|function|addMarkUp
name|QString
name|CppCodeMarker
operator|::
name|addMarkUp
parameter_list|(
specifier|const
name|QString
modifier|&
name|in
parameter_list|,
specifier|const
name|Node
modifier|*
comment|/* relative */
parameter_list|,
specifier|const
name|Location
modifier|&
comment|/* location */
parameter_list|)
block|{
DECL|macro|readChar
define|#
directive|define
name|readChar
parameter_list|()
define|\
value|ch = (i< (int)code.length()) ? code[i++].cell() : EOF
name|QString
name|code
init|=
name|in
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|types
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|keywords
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|typeTable
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|types
operator|.
name|insert
argument_list|(
name|QString
argument_list|(
name|typeTable
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|keywordTable
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|keywords
operator|.
name|insert
argument_list|(
name|QString
argument_list|(
name|keywordTable
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|QString
name|out
decl_stmt|;
name|int
name|braceDepth
init|=
literal|0
decl_stmt|;
name|int
name|parenDepth
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|finish
init|=
literal|0
decl_stmt|;
name|QChar
name|ch
decl_stmt|;
name|QRegExp
name|classRegExp
argument_list|(
literal|"Qt?(?:[A-Z3]+[a-z][A-Za-z]*|t)"
argument_list|)
decl_stmt|;
name|QRegExp
name|functionRegExp
argument_list|(
literal|"q([A-Z][a-z]+)+"
argument_list|)
decl_stmt|;
name|readChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
name|QString
name|tag
decl_stmt|;
name|bool
name|target
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ch
operator|.
name|isLetter
argument_list|()
operator|||
name|ch
operator|==
literal|'_'
condition|)
block|{
name|QString
name|ident
decl_stmt|;
do|do
block|{
name|ident
operator|+=
name|ch
expr_stmt|;
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|ch
operator|==
literal|'_'
condition|)
do|;
if|if
condition|(
name|classRegExp
operator|.
name|exactMatch
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|functionRegExp
operator|.
name|exactMatch
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"func"
argument_list|)
expr_stmt|;
name|target
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|types
operator|.
name|contains
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keywords
operator|.
name|contains
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"keyword"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|braceDepth
operator|==
literal|0
operator|&&
name|parenDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|QString
argument_list|(
name|code
operator|.
name|unicode
argument_list|()
operator|+
name|i
operator|-
literal|1
argument_list|,
name|code
operator|.
name|length
argument_list|()
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"^\\s*\\("
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"func"
argument_list|)
expr_stmt|;
name|target
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|.
name|isDigit
argument_list|()
condition|)
block|{
do|do
block|{
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|ch
operator|==
literal|'.'
condition|)
do|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"number"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'&'
case|:
case|case
literal|'*'
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'|'
case|:
case|case
literal|'~'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"op"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|readChar
argument_list|()
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|readChar
argument_list|()
expr_stmt|;
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"preprocessor"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|readChar
argument_list|()
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|parenDepth
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|parenDepth
operator|--
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
block|{
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"op"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
do|do
block|{
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
do|;
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|bool
name|metAster
init|=
literal|false
decl_stmt|;
name|bool
name|metAsterSlash
init|=
literal|false
decl_stmt|;
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|metAsterSlash
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
name|metAster
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|metAster
operator|&&
name|ch
operator|==
literal|'/'
condition|)
name|metAsterSlash
operator|=
literal|true
expr_stmt|;
else|else
name|metAster
operator|=
literal|false
expr_stmt|;
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"comment"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"op"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'{'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|braceDepth
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
name|braceDepth
operator|--
expr_stmt|;
break|break;
default|default:
name|finish
operator|=
name|i
expr_stmt|;
name|readChar
argument_list|()
expr_stmt|;
block|}
block|}
name|QString
name|text
decl_stmt|;
name|text
operator|=
name|code
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|finish
operator|-
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|finish
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"<@"
argument_list|)
operator|+
name|tag
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|" target=\""
argument_list|)
operator|+
name|text
operator|+
name|QLatin1String
argument_list|(
literal|"()\""
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
name|out
operator|+=
name|protect
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"</@"
argument_list|)
operator|+
name|tag
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|<
name|code
operator|.
name|length
argument_list|()
condition|)
block|{
name|out
operator|+=
name|protect
argument_list|(
name|code
operator|.
name|mid
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!   This function is for documenting QML properties. It returns   the list of documentation sections for the children of the   \a qmlClassNode.  */
end_comment
begin_function
DECL|function|qmlSections
name|QList
argument_list|<
name|Section
argument_list|>
name|CppCodeMarker
operator|::
name|qmlSections
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
name|qmlClassNode
parameter_list|,
name|SynopsisStyle
name|style
parameter_list|)
block|{
name|QList
argument_list|<
name|Section
argument_list|>
name|sections
decl_stmt|;
if|if
condition|(
name|qmlClassNode
condition|)
block|{
if|if
condition|(
name|style
operator|==
name|Summary
condition|)
block|{
name|FastSection
name|qmlproperties
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Properties"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"property"
argument_list|,
literal|"properties"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedproperties
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Properties"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"property"
argument_list|,
literal|"properties"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlsignals
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Signals"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"signal"
argument_list|,
literal|"signals"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlsignalhandlers
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Signal Handlers"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"signal handler"
argument_list|,
literal|"signal handlers"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedsignals
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Signals"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"signal"
argument_list|,
literal|"signals"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlmethods
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Methods"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"method"
argument_list|,
literal|"methods"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedmethods
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Methods"
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"method"
argument_list|,
literal|"methods"
argument_list|)
decl_stmt|;
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qmlClassNode
decl_stmt|;
while|while
condition|(
name|qcn
operator|!=
literal|0
condition|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|qcn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|qcn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|insert
argument_list|(
name|qmlproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
specifier|const
name|QmlPropertyNode
modifier|*
name|pn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
block|{
name|insert
argument_list|(
name|qmlproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|sn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedsignals
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|qmlsignals
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
condition|)
block|{
name|insert
argument_list|(
name|qmlsignalhandlers
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|mn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedmethods
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|qmlmethods
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|qcn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qcn
operator|->
name|isAbstract
argument_list|()
condition|)
name|qcn
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|qcn
operator|=
literal|0
expr_stmt|;
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|qmlproperties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedproperties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlsignals
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlsignalhandlers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedsignals
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlmethods
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedmethods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Detailed
condition|)
block|{
name|FastSection
name|qmlproperties
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Property Documentation"
argument_list|,
literal|"qmlprop"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedproperties
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Property Documentation"
argument_list|,
literal|"qmlattprop"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlsignals
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Signal Documentation"
argument_list|,
literal|"qmlsig"
argument_list|,
literal|"signal"
argument_list|,
literal|"signals"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlsignalhandlers
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Signal Handler Documentation"
argument_list|,
literal|"qmlsighan"
argument_list|,
literal|"signal handler"
argument_list|,
literal|"signal handlers"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedsignals
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Signal Documentation"
argument_list|,
literal|"qmlattsig"
argument_list|,
literal|"signal"
argument_list|,
literal|"signals"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlmethods
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Method Documentation"
argument_list|,
literal|"qmlmeth"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
name|FastSection
name|qmlattachedmethods
argument_list|(
name|qmlClassNode
argument_list|,
literal|"Attached Method Documentation"
argument_list|,
literal|"qmlattmeth"
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
specifier|const
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qmlClassNode
decl_stmt|;
while|while
condition|(
name|qcn
operator|!=
literal|0
condition|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|qcn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|qcn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|insert
argument_list|(
name|qmlproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
specifier|const
name|QmlPropertyNode
modifier|*
name|pn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|qmlproperties
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|sn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedsignals
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|qmlsignals
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
condition|)
block|{
name|insert
argument_list|(
name|qmlsignalhandlers
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|mn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|isAttached
argument_list|()
condition|)
name|insert
argument_list|(
name|qmlattachedmethods
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
name|qmlmethods
argument_list|,
operator|*
name|c
argument_list|,
name|style
argument_list|,
name|Okay
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|qcn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|qmlBaseNode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qcn
operator|->
name|isAbstract
argument_list|()
condition|)
name|qcn
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|qcn
operator|=
literal|0
expr_stmt|;
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|qmlproperties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedproperties
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlsignals
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlsignalhandlers
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedsignals
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlmethods
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|sections
argument_list|,
name|qmlattachedmethods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*               This is where the list of all members including inherited               members is prepared.              */
name|ClassMap
modifier|*
name|classMap
init|=
literal|0
decl_stmt|;
name|FastSection
name|all
argument_list|(
name|qmlClassNode
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|"member"
argument_list|,
literal|"members"
argument_list|)
decl_stmt|;
specifier|const
name|QmlClassNode
modifier|*
name|current
init|=
name|qmlClassNode
decl_stmt|;
while|while
condition|(
name|current
operator|!=
literal|0
condition|)
block|{
comment|/*                   If the QML type is abstract, do not create                   a new entry in the list for it. Instead,                   add its members to the current entry.                    However, if the first class is abstract,                   there is no current entry. In that case,                   create a new entry in the list anyway.                   I'm not sure that is correct, but it at                   least can prevent a crash.                  */
if|if
condition|(
operator|!
name|current
operator|->
name|isAbstract
argument_list|()
operator|||
operator|!
name|classMap
condition|)
block|{
name|classMap
operator|=
operator|new
name|ClassMap
expr_stmt|;
name|classMap
operator|->
name|first
operator|=
name|current
expr_stmt|;
name|all
operator|.
name|classMapList_
operator|.
name|append
argument_list|(
name|classMap
argument_list|)
expr_stmt|;
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|current
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|current
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|QmlPropertyGroupNode
modifier|*
name|qpgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|QmlPropertyGroupNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|p
init|=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|qpgn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QString
name|key
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|key
operator|=
name|sortName
argument_list|(
operator|*
name|p
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|all
operator|.
name|memberMap
operator|.
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|classMap
operator|->
name|second
operator|.
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
name|QString
name|key
init|=
operator|(
operator|*
name|c
operator|)
operator|->
name|name
argument_list|()
decl_stmt|;
name|key
operator|=
name|sortName
argument_list|(
operator|*
name|c
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|all
operator|.
name|memberMap
operator|.
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|classMap
operator|->
name|second
operator|.
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
name|current
operator|=
name|current
operator|->
name|qmlBaseNode
argument_list|()
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|isAbstract
argument_list|()
condition|)
break|break;
if|if
condition|(
name|current
operator|->
name|isInternal
argument_list|()
condition|)
name|current
operator|=
name|current
operator|->
name|qmlBaseNode
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
name|append
argument_list|(
name|sections
argument_list|,
name|all
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sections
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
