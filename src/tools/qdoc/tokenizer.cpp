begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"tokenizer.h"
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|LANGUAGE_CPP
define|#
directive|define
name|LANGUAGE_CPP
value|"Cpp"
comment|/* qmake ignore Q_OBJECT */
comment|/*   Keep in sync with tokenizer.h. */
DECL|variable|kwords
specifier|static
specifier|const
name|char
modifier|*
name|kwords
index|[]
init|=
block|{
literal|"char"
block|,
literal|"class"
block|,
literal|"const"
block|,
literal|"double"
block|,
literal|"enum"
block|,
literal|"explicit"
block|,
literal|"friend"
block|,
literal|"inline"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"namespace"
block|,
literal|"operator"
block|,
literal|"private"
block|,
literal|"protected"
block|,
literal|"public"
block|,
literal|"short"
block|,
literal|"signals"
block|,
literal|"signed"
block|,
literal|"slots"
block|,
literal|"static"
block|,
literal|"struct"
block|,
literal|"template"
block|,
literal|"typedef"
block|,
literal|"typename"
block|,
literal|"union"
block|,
literal|"unsigned"
block|,
literal|"using"
block|,
literal|"virtual"
block|,
literal|"void"
block|,
literal|"volatile"
block|,
literal|"__int64"
block|,
literal|"Q_OBJECT"
block|,
literal|"Q_OVERRIDE"
block|,
literal|"Q_PROPERTY"
block|,
literal|"Q_PRIVATE_PROPERTY"
block|,
literal|"Q_DECLARE_SEQUENTIAL_ITERATOR"
block|,
literal|"Q_DECLARE_MUTABLE_SEQUENTIAL_ITERATOR"
block|,
literal|"Q_DECLARE_ASSOCIATIVE_ITERATOR"
block|,
literal|"Q_DECLARE_MUTABLE_ASSOCIATIVE_ITERATOR"
block|,
literal|"Q_DECLARE_FLAGS"
block|,
literal|"Q_SIGNALS"
block|,
literal|"Q_SLOTS"
block|,
literal|"QT_COMPAT"
block|,
literal|"QT_COMPAT_CONSTRUCTOR"
block|,
literal|"QT_DEPRECATED"
block|,
literal|"QT_MOC_COMPAT"
block|,
literal|"QT_MODULE"
block|,
literal|"QT3_SUPPORT"
block|,
literal|"QT3_SUPPORT_CONSTRUCTOR"
block|,
literal|"QT3_MOC_SUPPORT"
block|,
literal|"QDOC_PROPERTY"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|KwordHashTableSize
specifier|static
specifier|const
name|int
name|KwordHashTableSize
init|=
literal|4096
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|kwordHashTable
specifier|static
name|int
name|kwordHashTable
index|[
name|KwordHashTableSize
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ignoredTokensAndDirectives
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|bool
argument_list|>
modifier|*
name|ignoredTokensAndDirectives
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|comment
specifier|static
name|QRegExp
modifier|*
name|comment
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|versionX
specifier|static
name|QRegExp
modifier|*
name|versionX
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|definedX
specifier|static
name|QRegExp
modifier|*
name|definedX
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|defines
specifier|static
name|QRegExp
modifier|*
name|defines
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|falsehoods
specifier|static
name|QRegExp
modifier|*
name|falsehoods
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sourceCodec
specifier|static
name|QTextCodec
modifier|*
name|sourceCodec
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   This function is a perfect hash function for the 37 keywords of C99   (with a hash table size of 512). It should perform well on our   Qt-enhanced C++ subset. */
end_comment
begin_function
DECL|function|hashKword
specifier|static
name|int
name|hashKword
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|uchar
operator|)
name|s
index|[
literal|0
index|]
operator|)
operator|+
operator|(
operator|(
operator|(
name|uchar
operator|)
name|s
index|[
literal|2
index|]
operator|)
operator|<<
literal|5
operator|)
operator|+
operator|(
operator|(
operator|(
name|uchar
operator|)
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|)
operator|<<
literal|3
operator|)
operator|)
operator|%
name|KwordHashTableSize
return|;
block|}
end_function
begin_function
DECL|function|insertKwordIntoHash
specifier|static
name|void
name|insertKwordIntoHash
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|int
name|k
init|=
name|hashKword
argument_list|(
name|s
argument_list|,
name|int
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|kwordHashTable
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|k
operator|==
name|KwordHashTableSize
condition|)
name|k
operator|=
literal|0
expr_stmt|;
block|}
name|kwordHashTable
index|[
name|k
index|]
operator|=
name|number
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|Tokenizer
name|Tokenizer
operator|::
name|Tokenizer
parameter_list|(
specifier|const
name|Location
modifier|&
name|loc
parameter_list|,
name|QFile
modifier|&
name|in
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|yyIn
operator|=
name|in
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|yyPos
operator|=
literal|0
expr_stmt|;
name|start
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|Tokenizer
name|Tokenizer
operator|::
name|Tokenizer
parameter_list|(
specifier|const
name|Location
modifier|&
name|loc
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|in
parameter_list|)
member_init_list|:
name|yyIn
argument_list|(
name|in
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|yyPos
operator|=
literal|0
expr_stmt|;
name|start
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~Tokenizer
name|Tokenizer
operator|::
name|~
name|Tokenizer
parameter_list|()
block|{
operator|delete
index|[]
name|yyLexBuf1
expr_stmt|;
operator|delete
index|[]
name|yyLexBuf2
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|getToken
name|int
name|Tokenizer
operator|::
name|getToken
parameter_list|()
block|{
name|char
modifier|*
name|t
init|=
name|yyPrevLex
decl_stmt|;
name|yyPrevLex
operator|=
name|yyLex
expr_stmt|;
name|yyLex
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|yyCh
operator|!=
name|EOF
condition|)
block|{
name|yyTokLoc
operator|=
name|yyCurLoc
expr_stmt|;
name|yyLexLen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|yyCh
argument_list|)
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|yyCh
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|yyCh
argument_list|)
operator|||
name|yyCh
operator|==
literal|'_'
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|yyCh
argument_list|)
operator|||
name|yyCh
operator|==
literal|'_'
condition|)
do|;
name|int
name|k
init|=
name|hashKword
argument_list|(
name|yyLex
argument_list|,
name|int
argument_list|(
name|yyLexLen
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
init|=
name|kwordHashTable
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
name|Tok_Ident
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|parsingMacro
operator|&&
name|ignoredTokensAndDirectives
operator|->
name|contains
argument_list|(
name|yyLex
argument_list|)
condition|)
block|{
if|if
condition|(
name|ignoredTokensAndDirectives
operator|->
name|value
argument_list|(
name|yyLex
argument_list|)
condition|)
block|{
comment|// it's a directive
name|int
name|parenDepth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|yyCh
operator|!=
name|EOF
operator|&&
operator|(
name|yyCh
operator|!=
literal|')'
operator|||
name|parenDepth
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'('
condition|)
operator|++
name|parenDepth
expr_stmt|;
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|')'
condition|)
operator|--
name|parenDepth
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yyCh
operator|==
literal|')'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|yyLex
argument_list|,
name|kwords
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ret
init|=
operator|(
name|int
operator|)
name|Tok_FirstKeyword
operator|+
name|i
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Tok_explicit
operator|&&
name|ret
operator|!=
name|Tok_inline
operator|&&
name|ret
operator|!=
name|Tok_typename
condition|)
return|return
name|ret
return|;
break|break;
block|}
if|if
condition|(
operator|++
name|k
operator|==
name|KwordHashTableSize
condition|)
name|k
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|yyCh
argument_list|)
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|yyCh
argument_list|)
operator|||
name|yyCh
operator|==
literal|'.'
operator|||
name|yyCh
operator|==
literal|'+'
operator|||
name|yyCh
operator|==
literal|'-'
condition|)
do|;
return|return
name|Tok_Number
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|yyCh
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
case|case
literal|'"'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|yyCh
operator|!=
name|EOF
operator|&&
name|yyCh
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'\\'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
name|EOF
condition|)
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unterminated C++ string literal"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Maybe you forgot '/*!' at the beginning of the file?"
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|Tok_String
return|;
break|break;
case|case
literal|'#'
case|:
return|return
name|getTokenAfterPreprocessor
argument_list|()
return|;
case|case
literal|'&'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'&'
operator|||
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_Ampersand
return|;
block|}
case|case
literal|'\''
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
comment|/*                   Allow empty character literal. QTBUG-25775                  */
if|if
condition|(
name|yyCh
operator|==
literal|'\''
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yyCh
operator|==
literal|'\\'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|yyCh
operator|!=
name|EOF
operator|&&
name|yyCh
operator|!=
literal|'\''
condition|)
do|;
if|if
condition|(
name|yyCh
operator|==
name|EOF
condition|)
block|{
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unterminated C++ character literal"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Number
return|;
block|}
break|break;
case|case
literal|'('
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyParenDepth
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|yyCh
argument_list|)
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|yyCh
argument_list|)
condition|)
do|;
name|yyLexLen
operator|=
literal|1
expr_stmt|;
name|yyLex
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|yyCh
operator|==
literal|'*'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_LeftParenAster
return|;
block|}
return|return
name|Tok_LeftParen
return|;
case|case
literal|')'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyParenDepth
operator|--
expr_stmt|;
return|return
name|Tok_RightParen
return|;
case|case
literal|'*'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_Aster
return|;
block|}
case|case
literal|'^'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_Caret
return|;
block|}
case|case
literal|'+'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'+'
operator|||
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
case|case
literal|','
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Comma
return|;
case|case
literal|'-'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'-'
operator|||
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|'>'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'*'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
return|return
name|Tok_SomeOperator
return|;
case|case
literal|'.'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'*'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|'.'
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|yyCh
operator|==
literal|'.'
condition|)
do|;
return|return
name|Tok_Ellipsis
return|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|yyCh
argument_list|)
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|yyCh
argument_list|)
operator|||
name|yyCh
operator|==
literal|'.'
operator|||
name|yyCh
operator|==
literal|'+'
operator|||
name|yyCh
operator|==
literal|'-'
condition|)
do|;
return|return
name|Tok_Number
return|;
block|}
return|return
name|Tok_SomeOperator
return|;
case|case
literal|'/'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'/'
condition|)
block|{
do|do
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|yyCh
operator|!=
name|EOF
operator|&&
name|yyCh
operator|!=
literal|'\n'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|'*'
condition|)
block|{
name|bool
name|metDoc
init|=
literal|false
decl_stmt|;
comment|// empty doc is no doc
name|bool
name|metSlashAsterBang
init|=
literal|false
decl_stmt|;
name|bool
name|metAster
init|=
literal|false
decl_stmt|;
name|bool
name|metAsterSlash
init|=
literal|false
decl_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'!'
condition|)
name|metSlashAsterBang
operator|=
literal|true
expr_stmt|;
while|while
condition|(
operator|!
name|metAsterSlash
condition|)
block|{
if|if
condition|(
name|yyCh
operator|==
name|EOF
condition|)
block|{
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unterminated C++ comment"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'*'
condition|)
block|{
name|metAster
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metAster
operator|&&
name|yyCh
operator|==
literal|'/'
condition|)
block|{
name|metAsterSlash
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|metAster
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|isgraph
argument_list|(
name|yyCh
argument_list|)
condition|)
name|metDoc
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metSlashAsterBang
operator|&&
name|metDoc
condition|)
return|return
name|Tok_Doc
return|;
elseif|else
if|if
condition|(
name|yyParenDepth
operator|>
literal|0
condition|)
return|return
name|Tok_Comment
return|;
block|}
else|else
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
break|break;
case|case
literal|':'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|':'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Gulbrandsen
return|;
block|}
else|else
block|{
return|return
name|Tok_Colon
return|;
block|}
case|case
literal|';'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Semicolon
return|;
case|case
literal|'<'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'<'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_LeftAngle
return|;
block|}
case|case
literal|'='
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_Equal
return|;
block|}
case|case
literal|'>'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'>'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
elseif|else
if|if
condition|(
name|yyCh
operator|==
literal|'='
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
block|}
else|else
block|{
return|return
name|Tok_RightAngle
return|;
block|}
case|case
literal|'?'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
case|case
literal|'['
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyBracketDepth
operator|++
expr_stmt|;
return|return
name|Tok_LeftBracket
return|;
case|case
literal|'\\'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
comment|// skip one character
break|break;
case|case
literal|']'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyBracketDepth
operator|--
expr_stmt|;
return|return
name|Tok_RightBracket
return|;
case|case
literal|'{'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyBraceDepth
operator|++
expr_stmt|;
return|return
name|Tok_LeftBrace
return|;
case|case
literal|'}'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
condition|)
name|yyBraceDepth
operator|--
expr_stmt|;
return|return
name|Tok_RightBrace
return|;
case|case
literal|'|'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'|'
operator|||
name|yyCh
operator|==
literal|'='
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_SomeOperator
return|;
case|case
literal|'~'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Tilde
return|;
case|case
literal|'@'
case|:
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_At
return|;
default|default:
comment|// ### We should really prevent qdoc from looking at snippet files rather than
comment|// ### suppress warnings when reading them.
if|if
condition|(
name|yyNumPreprocessorSkipping
operator|==
literal|0
operator|&&
operator|!
operator|(
name|yyTokLoc
operator|.
name|fileName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".qdoc"
argument_list|)
operator|||
name|yyTokLoc
operator|.
name|fileName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".js"
argument_list|)
operator|)
condition|)
block|{
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Hostile character 0x%1 in C++ source"
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|uchar
operator|)
name|yyCh
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|yyPreprocessorSkipping
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Expected #endif before end of file"
argument_list|)
argument_list|)
expr_stmt|;
comment|// clear it out or we get an infinite loop!
while|while
condition|(
operator|!
name|yyPreprocessorSkipping
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|popSkipping
argument_list|()
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|yyLex
argument_list|,
literal|"end-of-input"
argument_list|)
expr_stmt|;
name|yyLexLen
operator|=
name|strlen
argument_list|(
name|yyLex
argument_list|)
expr_stmt|;
return|return
name|Tok_Eoi
return|;
block|}
end_function
begin_function
DECL|function|initialize
name|void
name|Tokenizer
operator|::
name|initialize
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|QString
name|versionSym
init|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_VERSIONSYM
argument_list|)
decl_stmt|;
name|QString
name|sourceEncoding
init|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_SOURCEENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceEncoding
operator|.
name|isEmpty
argument_list|()
condition|)
name|sourceEncoding
operator|=
name|QLatin1String
argument_list|(
literal|"ISO-8859-1"
argument_list|)
expr_stmt|;
name|sourceCodec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|sourceEncoding
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
name|comment
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"/(?:\\*.*\\*/|/.*\n|/[^\n]*$)"
argument_list|)
expr_stmt|;
name|comment
operator|->
name|setMinimal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|versionX
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"$cannot possibly match^"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|versionSym
operator|.
name|isEmpty
argument_list|()
condition|)
name|versionX
operator|->
name|setPattern
argument_list|(
literal|"[ \t]*(?:"
operator|+
name|QRegExp
operator|::
name|escape
argument_list|(
name|versionSym
argument_list|)
operator|+
literal|")[ \t]+\"([^\"]*)\"[ \t]*"
argument_list|)
expr_stmt|;
name|definedX
operator|=
operator|new
name|QRegExp
argument_list|(
literal|"defined ?\\(?([A-Z_0-9a-z]+) ?\\)"
argument_list|)
expr_stmt|;
name|QStringList
name|d
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_DEFINES
argument_list|)
decl_stmt|;
name|d
operator|+=
literal|"qdoc"
expr_stmt|;
name|defines
operator|=
operator|new
name|QRegExp
argument_list|(
name|d
operator|.
name|join
argument_list|(
literal|'|'
argument_list|)
argument_list|)
expr_stmt|;
name|falsehoods
operator|=
operator|new
name|QRegExp
argument_list|(
name|config
operator|.
name|getStringList
argument_list|(
name|CONFIG_FALSEHOODS
argument_list|)
operator|.
name|join
argument_list|(
literal|'|'
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kwordHashTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kwordHashTable
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Tok_LastKeyword
operator|-
name|Tok_FirstKeyword
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|insertKwordIntoHash
argument_list|(
name|kwords
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ignoredTokensAndDirectives
operator|=
operator|new
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|bool
argument_list|>
expr_stmt|;
name|QStringList
name|tokens
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|LANGUAGE_CPP
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_IGNORETOKENS
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|t
decl|,
name|tokens
control|)
block|{
specifier|const
name|QByteArray
name|tb
init|=
name|t
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|ignoredTokensAndDirectives
operator|->
name|insert
argument_list|(
name|tb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|insertKwordIntoHash
argument_list|(
name|tb
operator|.
name|data
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|QStringList
name|directives
init|=
name|config
operator|.
name|getStringList
argument_list|(
name|LANGUAGE_CPP
operator|+
name|Config
operator|::
name|dot
operator|+
name|CONFIG_IGNOREDIRECTIVES
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|d
decl|,
name|directives
control|)
block|{
specifier|const
name|QByteArray
name|db
init|=
name|d
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|ignoredTokensAndDirectives
operator|->
name|insert
argument_list|(
name|db
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|insertKwordIntoHash
argument_list|(
name|db
operator|.
name|data
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|terminate
name|void
name|Tokenizer
operator|::
name|terminate
parameter_list|()
block|{
operator|delete
name|comment
expr_stmt|;
name|comment
operator|=
literal|0
expr_stmt|;
operator|delete
name|versionX
expr_stmt|;
name|versionX
operator|=
literal|0
expr_stmt|;
operator|delete
name|definedX
expr_stmt|;
name|definedX
operator|=
literal|0
expr_stmt|;
operator|delete
name|defines
expr_stmt|;
name|defines
operator|=
literal|0
expr_stmt|;
operator|delete
name|falsehoods
expr_stmt|;
name|falsehoods
operator|=
literal|0
expr_stmt|;
operator|delete
name|ignoredTokensAndDirectives
expr_stmt|;
name|ignoredTokensAndDirectives
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|Tokenizer
operator|::
name|init
parameter_list|()
block|{
name|yyLexBuf1
operator|=
operator|new
name|char
index|[
operator|(
name|int
operator|)
name|yyLexBufSize
index|]
expr_stmt|;
name|yyLexBuf2
operator|=
operator|new
name|char
index|[
operator|(
name|int
operator|)
name|yyLexBufSize
index|]
expr_stmt|;
name|yyPrevLex
operator|=
name|yyLexBuf1
expr_stmt|;
name|yyPrevLex
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yyLex
operator|=
name|yyLexBuf2
expr_stmt|;
name|yyLex
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yyLexLen
operator|=
literal|0
expr_stmt|;
name|yyPreprocessorSkipping
operator|.
name|push
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|yyNumPreprocessorSkipping
operator|=
literal|0
expr_stmt|;
name|yyBraceDepth
operator|=
literal|0
expr_stmt|;
name|yyParenDepth
operator|=
literal|0
expr_stmt|;
name|yyBracketDepth
operator|=
literal|0
expr_stmt|;
name|yyCh
operator|=
literal|'\0'
expr_stmt|;
name|parsingMacro
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|start
name|void
name|Tokenizer
operator|::
name|start
parameter_list|(
specifier|const
name|Location
modifier|&
name|loc
parameter_list|)
block|{
name|yyTokLoc
operator|=
name|loc
expr_stmt|;
name|yyCurLoc
operator|=
name|loc
expr_stmt|;
name|yyCurLoc
operator|.
name|start
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|yyPrevLex
argument_list|,
literal|"beginning-of-input"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|yyLex
argument_list|,
literal|"beginning-of-input"
argument_list|)
expr_stmt|;
name|yyLexLen
operator|=
name|strlen
argument_list|(
name|yyLex
argument_list|)
expr_stmt|;
name|yyBraceDepth
operator|=
literal|0
expr_stmt|;
name|yyParenDepth
operator|=
literal|0
expr_stmt|;
name|yyBracketDepth
operator|=
literal|0
expr_stmt|;
name|yyCh
operator|=
literal|'\0'
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Returns the next token, if # was met.  This function interprets the   preprocessor directive, skips over any #ifdef'd out tokens, and returns the   token after all of that. */
end_comment
begin_function
DECL|function|getTokenAfterPreprocessor
name|int
name|Tokenizer
operator|::
name|getTokenAfterPreprocessor
parameter_list|()
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|yyCh
argument_list|)
operator|&&
name|yyCh
operator|!=
literal|'\n'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
comment|/*       #directive condition     */
name|QString
name|directive
decl_stmt|;
name|QString
name|condition
decl_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
name|yyCh
argument_list|)
condition|)
block|{
name|directive
operator|+=
name|QChar
argument_list|(
name|yyCh
argument_list|)
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|directive
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
while|while
condition|(
name|yyCh
operator|!=
name|EOF
operator|&&
name|yyCh
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'\\'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|'\r'
condition|)
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
name|condition
operator|+=
name|yyCh
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
name|condition
operator|.
name|remove
argument_list|(
operator|*
name|comment
argument_list|)
expr_stmt|;
name|condition
operator|=
name|condition
operator|.
name|simplified
argument_list|()
expr_stmt|;
comment|/*           The #if, #ifdef, #ifndef, #elif, #else, and #endif           directives have an effect on the skipping stack.  For           instance, if the code processed so far is                #if 1               #if 0               #if 1               // ...               #else            the skipping stack contains, from bottom to top, false true           true (assuming 0 is false and 1 is true).  If at least one           entry of the stack is true, the tokens are skipped.            This mechanism is simple yet hard to understand.         */
if|if
condition|(
name|directive
index|[
literal|0
index|]
operator|==
name|QChar
argument_list|(
literal|'i'
argument_list|)
condition|)
block|{
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"if"
argument_list|)
condition|)
name|pushSkipping
argument_list|(
operator|!
name|isTrue
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"ifdef"
argument_list|)
condition|)
name|pushSkipping
argument_list|(
operator|!
name|defines
operator|->
name|exactMatch
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"ifndef"
argument_list|)
condition|)
name|pushSkipping
argument_list|(
name|defines
operator|->
name|exactMatch
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|directive
index|[
literal|0
index|]
operator|==
name|QChar
argument_list|(
literal|'e'
argument_list|)
condition|)
block|{
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"elif"
argument_list|)
condition|)
block|{
name|bool
name|old
init|=
name|popSkipping
argument_list|()
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|pushSkipping
argument_list|(
operator|!
name|isTrue
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pushSkipping
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"else"
argument_list|)
condition|)
block|{
name|pushSkipping
argument_list|(
operator|!
name|popSkipping
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"endif"
argument_list|)
condition|)
block|{
name|popSkipping
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|directive
operator|==
name|QString
argument_list|(
literal|"define"
argument_list|)
condition|)
block|{
if|if
condition|(
name|versionX
operator|->
name|exactMatch
argument_list|(
name|condition
argument_list|)
condition|)
name|yyVersion
operator|=
name|versionX
operator|->
name|cap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|tok
decl_stmt|;
do|do
block|{
comment|/*           We set yyLex now, and after getToken() this will be           yyPrevLex. This way, we skip over the preprocessor           directive.         */
name|qstrcpy
argument_list|(
name|yyLex
argument_list|,
name|yyPrevLex
argument_list|)
expr_stmt|;
comment|/*           If getToken() meets another #, it will call           getTokenAfterPreprocessor() once again, which could in turn           call getToken() again, etc. Unless there are 10,000 or so           preprocessor directives in a row, this shouldn't overflow           the stack.         */
name|tok
operator|=
name|getToken
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|yyNumPreprocessorSkipping
operator|>
literal|0
operator|&&
name|tok
operator|!=
name|Tok_Eoi
condition|)
do|;
return|return
name|tok
return|;
block|}
end_function
begin_comment
comment|/*   Pushes a new skipping value onto the stack.  This corresponds to entering a   new #if block. */
end_comment
begin_function
DECL|function|pushSkipping
name|void
name|Tokenizer
operator|::
name|pushSkipping
parameter_list|(
name|bool
name|skip
parameter_list|)
block|{
name|yyPreprocessorSkipping
operator|.
name|push
argument_list|(
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|yyNumPreprocessorSkipping
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Pops a skipping value from the stack.  This corresponds to reaching a #endif. */
end_comment
begin_function
DECL|function|popSkipping
name|bool
name|Tokenizer
operator|::
name|popSkipping
parameter_list|()
block|{
if|if
condition|(
name|yyPreprocessorSkipping
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|yyTokLoc
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected #elif, #else or #endif"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|bool
name|skip
init|=
name|yyPreprocessorSkipping
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|skip
condition|)
name|yyNumPreprocessorSkipping
operator|--
expr_stmt|;
return|return
name|skip
return|;
block|}
end_function
begin_comment
comment|/*   Returns true if the condition evaluates as true, otherwise false.  The   condition is represented by a string.  Unsophisticated parsing techniques are   used.  The preprocessing method could be named StriNg-Oriented PreProcessing,   as SNOBOL stands for StriNg-Oriented symBOlic Language. */
end_comment
begin_function
DECL|function|isTrue
name|bool
name|Tokenizer
operator|::
name|isTrue
parameter_list|(
specifier|const
name|QString
modifier|&
name|condition
parameter_list|)
block|{
name|int
name|firstOr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstAnd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|parenDepth
init|=
literal|0
decl_stmt|;
comment|/*       Find the first logical operator at top level, but be careful       about precedence. Examples:            X || Y          // the or           X || Y || Z     // the leftmost or           X || Y&& Z     // the or           X&& Y || Z     // the or           (X || Y)&& Z   // the and     */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|condition
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|ch
init|=
name|condition
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QChar
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
name|parenDepth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QChar
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|parenDepth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parenDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|condition
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|ch
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|QChar
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|firstOr
operator|=
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QChar
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstAnd
operator|==
operator|-
literal|1
condition|)
name|firstAnd
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|firstOr
operator|!=
operator|-
literal|1
condition|)
return|return
name|isTrue
argument_list|(
name|condition
operator|.
name|left
argument_list|(
name|firstOr
argument_list|)
argument_list|)
operator|||
name|isTrue
argument_list|(
name|condition
operator|.
name|mid
argument_list|(
name|firstOr
operator|+
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|firstAnd
operator|!=
operator|-
literal|1
condition|)
return|return
name|isTrue
argument_list|(
name|condition
operator|.
name|left
argument_list|(
name|firstAnd
argument_list|)
argument_list|)
operator|&&
name|isTrue
argument_list|(
name|condition
operator|.
name|mid
argument_list|(
name|firstAnd
operator|+
literal|2
argument_list|)
argument_list|)
return|;
name|QString
name|t
init|=
name|condition
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
name|QChar
argument_list|(
literal|'!'
argument_list|)
condition|)
return|return
operator|!
name|isTrue
argument_list|(
name|t
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
name|QChar
argument_list|(
literal|'('
argument_list|)
operator|&&
name|t
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|')'
argument_list|)
argument_list|)
condition|)
return|return
name|isTrue
argument_list|(
name|t
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|t
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|definedX
operator|->
name|exactMatch
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|defines
operator|->
name|exactMatch
argument_list|(
name|definedX
operator|->
name|cap
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|!
name|falsehoods
operator|->
name|exactMatch
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lexeme
name|QString
name|Tokenizer
operator|::
name|lexeme
parameter_list|()
specifier|const
block|{
return|return
name|sourceCodec
operator|->
name|toUnicode
argument_list|(
name|yyLex
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|previousLexeme
name|QString
name|Tokenizer
operator|::
name|previousLexeme
parameter_list|()
specifier|const
block|{
return|return
name|sourceCodec
operator|->
name|toUnicode
argument_list|(
name|yyPrevLex
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
