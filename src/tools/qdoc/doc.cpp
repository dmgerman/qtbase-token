begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"editdistance.h"
end_include
begin_include
include|#
directive|include
file|"openedlist.h"
end_include
begin_include
include|#
directive|include
file|"quoter.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tokenizer.h"
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qtextstream.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC
argument_list|(
name|QSet
argument_list|<
name|QString
argument_list|>
argument_list|,
name|null_Set_QString
argument_list|)
name|Q_GLOBAL_STATIC
argument_list|(
name|TopicList
argument_list|,
name|nullTopicList
argument_list|)
name|Q_GLOBAL_STATIC
argument_list|(
name|QStringList
argument_list|,
name|null_QStringList
argument_list|)
name|Q_GLOBAL_STATIC
argument_list|(
name|QList
argument_list|<
name|Text
argument_list|>
argument_list|,
name|null_QList_Text
argument_list|)
comment|//Q_GLOBAL_STATIC(QStringMap, null_QStringMap)
name|Q_GLOBAL_STATIC
argument_list|(
name|QStringMultiMap
argument_list|,
name|null_QStringMultiMap
argument_list|)
decl|struct
DECL|struct|Macro
name|Macro
argument_list|{
DECL|member|defaultDef
name|QString
name|defaultDef
argument_list|;
DECL|member|defaultDefLocation
name|Location
name|defaultDefLocation
argument_list|;
DECL|member|otherDefs
name|QStringMap
name|otherDefs
argument_list|;
DECL|member|numParams
name|int
name|numParams
argument_list|; }
decl_stmt|;
end_decl_stmt
begin_enum
enum|enum
block|{
DECL|enumerator|CMD_A
name|CMD_A
block|,
DECL|enumerator|CMD_ABSTRACT
name|CMD_ABSTRACT
block|,
DECL|enumerator|CMD_ANNOTATEDLIST
name|CMD_ANNOTATEDLIST
block|,
DECL|enumerator|CMD_B
name|CMD_B
block|,
DECL|enumerator|CMD_BADCODE
name|CMD_BADCODE
block|,
DECL|enumerator|CMD_BASENAME
name|CMD_BASENAME
block|,
DECL|enumerator|CMD_BOLD
name|CMD_BOLD
block|,
DECL|enumerator|CMD_BR
name|CMD_BR
block|,
DECL|enumerator|CMD_BRIEF
name|CMD_BRIEF
block|,
DECL|enumerator|CMD_C
name|CMD_C
block|,
DECL|enumerator|CMD_CAPTION
name|CMD_CAPTION
block|,
DECL|enumerator|CMD_CHAPTER
name|CMD_CHAPTER
block|,
DECL|enumerator|CMD_CODE
name|CMD_CODE
block|,
DECL|enumerator|CMD_CODELINE
name|CMD_CODELINE
block|,
DECL|enumerator|CMD_DIV
name|CMD_DIV
block|,
DECL|enumerator|CMD_DOTS
name|CMD_DOTS
block|,
DECL|enumerator|CMD_E
name|CMD_E
block|,
DECL|enumerator|CMD_ELSE
name|CMD_ELSE
block|,
DECL|enumerator|CMD_ENDABSTRACT
name|CMD_ENDABSTRACT
block|,
DECL|enumerator|CMD_ENDCHAPTER
name|CMD_ENDCHAPTER
block|,
DECL|enumerator|CMD_ENDCODE
name|CMD_ENDCODE
block|,
DECL|enumerator|CMD_ENDDIV
name|CMD_ENDDIV
block|,
DECL|enumerator|CMD_ENDFOOTNOTE
name|CMD_ENDFOOTNOTE
block|,
DECL|enumerator|CMD_ENDIF
name|CMD_ENDIF
block|,
DECL|enumerator|CMD_ENDLEGALESE
name|CMD_ENDLEGALESE
block|,
DECL|enumerator|CMD_ENDLINK
name|CMD_ENDLINK
block|,
DECL|enumerator|CMD_ENDLIST
name|CMD_ENDLIST
block|,
DECL|enumerator|CMD_ENDMAPREF
name|CMD_ENDMAPREF
block|,
DECL|enumerator|CMD_ENDOMIT
name|CMD_ENDOMIT
block|,
DECL|enumerator|CMD_ENDPART
name|CMD_ENDPART
block|,
DECL|enumerator|CMD_ENDQUOTATION
name|CMD_ENDQUOTATION
block|,
DECL|enumerator|CMD_ENDRAW
name|CMD_ENDRAW
block|,
DECL|enumerator|CMD_ENDSECTION1
name|CMD_ENDSECTION1
block|,
DECL|enumerator|CMD_ENDSECTION2
name|CMD_ENDSECTION2
block|,
DECL|enumerator|CMD_ENDSECTION3
name|CMD_ENDSECTION3
block|,
DECL|enumerator|CMD_ENDSECTION4
name|CMD_ENDSECTION4
block|,
DECL|enumerator|CMD_ENDSIDEBAR
name|CMD_ENDSIDEBAR
block|,
DECL|enumerator|CMD_ENDTABLE
name|CMD_ENDTABLE
block|,
DECL|enumerator|CMD_ENDTOPICREF
name|CMD_ENDTOPICREF
block|,
DECL|enumerator|CMD_FOOTNOTE
name|CMD_FOOTNOTE
block|,
DECL|enumerator|CMD_GENERATELIST
name|CMD_GENERATELIST
block|,
DECL|enumerator|CMD_GRANULARITY
name|CMD_GRANULARITY
block|,
DECL|enumerator|CMD_HEADER
name|CMD_HEADER
block|,
DECL|enumerator|CMD_HR
name|CMD_HR
block|,
DECL|enumerator|CMD_I
name|CMD_I
block|,
DECL|enumerator|CMD_IF
name|CMD_IF
block|,
DECL|enumerator|CMD_IMAGE
name|CMD_IMAGE
block|,
DECL|enumerator|CMD_IMPORTANT
name|CMD_IMPORTANT
block|,
DECL|enumerator|CMD_INCLUDE
name|CMD_INCLUDE
block|,
DECL|enumerator|CMD_INLINEIMAGE
name|CMD_INLINEIMAGE
block|,
DECL|enumerator|CMD_INDEX
name|CMD_INDEX
block|,
DECL|enumerator|CMD_KEYWORD
name|CMD_KEYWORD
block|,
DECL|enumerator|CMD_L
name|CMD_L
block|,
DECL|enumerator|CMD_LEGALESE
name|CMD_LEGALESE
block|,
DECL|enumerator|CMD_LI
name|CMD_LI
block|,
DECL|enumerator|CMD_LINK
name|CMD_LINK
block|,
DECL|enumerator|CMD_LIST
name|CMD_LIST
block|,
DECL|enumerator|CMD_MAPREF
name|CMD_MAPREF
block|,
DECL|enumerator|CMD_META
name|CMD_META
block|,
DECL|enumerator|CMD_NEWCODE
name|CMD_NEWCODE
block|,
DECL|enumerator|CMD_NOTE
name|CMD_NOTE
block|,
DECL|enumerator|CMD_O
name|CMD_O
block|,
DECL|enumerator|CMD_OLDCODE
name|CMD_OLDCODE
block|,
DECL|enumerator|CMD_OMIT
name|CMD_OMIT
block|,
DECL|enumerator|CMD_OMITVALUE
name|CMD_OMITVALUE
block|,
DECL|enumerator|CMD_OVERLOAD
name|CMD_OVERLOAD
block|,
DECL|enumerator|CMD_PART
name|CMD_PART
block|,
DECL|enumerator|CMD_PRINTLINE
name|CMD_PRINTLINE
block|,
DECL|enumerator|CMD_PRINTTO
name|CMD_PRINTTO
block|,
DECL|enumerator|CMD_PRINTUNTIL
name|CMD_PRINTUNTIL
block|,
DECL|enumerator|CMD_QUOTATION
name|CMD_QUOTATION
block|,
DECL|enumerator|CMD_QUOTEFILE
name|CMD_QUOTEFILE
block|,
DECL|enumerator|CMD_QUOTEFROMFILE
name|CMD_QUOTEFROMFILE
block|,
DECL|enumerator|CMD_QUOTEFUNCTION
name|CMD_QUOTEFUNCTION
block|,
DECL|enumerator|CMD_RAW
name|CMD_RAW
block|,
DECL|enumerator|CMD_ROW
name|CMD_ROW
block|,
DECL|enumerator|CMD_SA
name|CMD_SA
block|,
DECL|enumerator|CMD_SECTION1
name|CMD_SECTION1
block|,
DECL|enumerator|CMD_SECTION2
name|CMD_SECTION2
block|,
DECL|enumerator|CMD_SECTION3
name|CMD_SECTION3
block|,
DECL|enumerator|CMD_SECTION4
name|CMD_SECTION4
block|,
DECL|enumerator|CMD_SIDEBAR
name|CMD_SIDEBAR
block|,
DECL|enumerator|CMD_SINCELIST
name|CMD_SINCELIST
block|,
DECL|enumerator|CMD_SKIPLINE
name|CMD_SKIPLINE
block|,
DECL|enumerator|CMD_SKIPTO
name|CMD_SKIPTO
block|,
DECL|enumerator|CMD_SKIPUNTIL
name|CMD_SKIPUNTIL
block|,
DECL|enumerator|CMD_SNIPPET
name|CMD_SNIPPET
block|,
DECL|enumerator|CMD_SPAN
name|CMD_SPAN
block|,
DECL|enumerator|CMD_SUB
name|CMD_SUB
block|,
DECL|enumerator|CMD_SUP
name|CMD_SUP
block|,
DECL|enumerator|CMD_TABLE
name|CMD_TABLE
block|,
DECL|enumerator|CMD_TABLEOFCONTENTS
name|CMD_TABLEOFCONTENTS
block|,
DECL|enumerator|CMD_TARGET
name|CMD_TARGET
block|,
DECL|enumerator|CMD_TOPICREF
name|CMD_TOPICREF
block|,
DECL|enumerator|CMD_TT
name|CMD_TT
block|,
DECL|enumerator|CMD_UICONTROL
name|CMD_UICONTROL
block|,
DECL|enumerator|CMD_UNDERLINE
name|CMD_UNDERLINE
block|,
DECL|enumerator|CMD_UNICODE
name|CMD_UNICODE
block|,
DECL|enumerator|CMD_VALUE
name|CMD_VALUE
block|,
DECL|enumerator|CMD_WARNING
name|CMD_WARNING
block|,
DECL|enumerator|CMD_QML
name|CMD_QML
block|,
DECL|enumerator|CMD_ENDQML
name|CMD_ENDQML
block|,
DECL|enumerator|CMD_CPP
name|CMD_CPP
block|,
DECL|enumerator|CMD_ENDCPP
name|CMD_ENDCPP
block|,
DECL|enumerator|CMD_QMLTEXT
name|CMD_QMLTEXT
block|,
DECL|enumerator|CMD_ENDQMLTEXT
name|CMD_ENDQMLTEXT
block|,
DECL|enumerator|CMD_CPPTEXT
name|CMD_CPPTEXT
block|,
DECL|enumerator|CMD_ENDCPPTEXT
name|CMD_ENDCPPTEXT
block|,
DECL|enumerator|CMD_JS
name|CMD_JS
block|,
DECL|enumerator|CMD_ENDJS
name|CMD_ENDJS
block|,
DECL|enumerator|NOT_A_CMD
name|NOT_A_CMD
block|}
enum|;
end_enum
begin_struct
specifier|static
struct|struct
block|{
DECL|member|english
specifier|const
name|char
modifier|*
name|english
decl_stmt|;
DECL|member|no
name|int
name|no
decl_stmt|;
DECL|member|alias
name|QString
modifier|*
name|alias
decl_stmt|;
block|}
DECL|variable|cmds
name|cmds
index|[]
init|=
block|{
block|{
literal|"a"
block|,
name|CMD_A
block|,
literal|0
block|}
block|,
block|{
literal|"abstract"
block|,
name|CMD_ABSTRACT
block|,
literal|0
block|}
block|,
block|{
literal|"annotatedlist"
block|,
name|CMD_ANNOTATEDLIST
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
name|CMD_B
block|,
literal|0
block|}
block|,
block|{
literal|"badcode"
block|,
name|CMD_BADCODE
block|,
literal|0
block|}
block|,
block|{
literal|"basename"
block|,
name|CMD_BASENAME
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"bold"
block|,
name|CMD_BOLD
block|,
literal|0
block|}
block|,
block|{
literal|"br"
block|,
name|CMD_BR
block|,
literal|0
block|}
block|,
block|{
literal|"brief"
block|,
name|CMD_BRIEF
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
name|CMD_C
block|,
literal|0
block|}
block|,
block|{
literal|"caption"
block|,
name|CMD_CAPTION
block|,
literal|0
block|}
block|,
block|{
literal|"chapter"
block|,
name|CMD_CHAPTER
block|,
literal|0
block|}
block|,
block|{
literal|"code"
block|,
name|CMD_CODE
block|,
literal|0
block|}
block|,
block|{
literal|"codeline"
block|,
name|CMD_CODELINE
block|,
literal|0
block|}
block|,
block|{
literal|"div"
block|,
name|CMD_DIV
block|,
literal|0
block|}
block|,
block|{
literal|"dots"
block|,
name|CMD_DOTS
block|,
literal|0
block|}
block|,
block|{
literal|"e"
block|,
name|CMD_E
block|,
literal|0
block|}
block|,
block|{
literal|"else"
block|,
name|CMD_ELSE
block|,
literal|0
block|}
block|,
block|{
literal|"endabstract"
block|,
name|CMD_ENDABSTRACT
block|,
literal|0
block|}
block|,
block|{
literal|"endchapter"
block|,
name|CMD_ENDCHAPTER
block|,
literal|0
block|}
block|,
block|{
literal|"endcode"
block|,
name|CMD_ENDCODE
block|,
literal|0
block|}
block|,
block|{
literal|"enddiv"
block|,
name|CMD_ENDDIV
block|,
literal|0
block|}
block|,
block|{
literal|"endfootnote"
block|,
name|CMD_ENDFOOTNOTE
block|,
literal|0
block|}
block|,
block|{
literal|"endif"
block|,
name|CMD_ENDIF
block|,
literal|0
block|}
block|,
block|{
literal|"endlegalese"
block|,
name|CMD_ENDLEGALESE
block|,
literal|0
block|}
block|,
block|{
literal|"endlink"
block|,
name|CMD_ENDLINK
block|,
literal|0
block|}
block|,
block|{
literal|"endlist"
block|,
name|CMD_ENDLIST
block|,
literal|0
block|}
block|,
block|{
literal|"endmapref"
block|,
name|CMD_ENDMAPREF
block|,
literal|0
block|}
block|,
block|{
literal|"endomit"
block|,
name|CMD_ENDOMIT
block|,
literal|0
block|}
block|,
block|{
literal|"endpart"
block|,
name|CMD_ENDPART
block|,
literal|0
block|}
block|,
block|{
literal|"endquotation"
block|,
name|CMD_ENDQUOTATION
block|,
literal|0
block|}
block|,
block|{
literal|"endraw"
block|,
name|CMD_ENDRAW
block|,
literal|0
block|}
block|,
block|{
literal|"endsection1"
block|,
name|CMD_ENDSECTION1
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"endsection2"
block|,
name|CMD_ENDSECTION2
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"endsection3"
block|,
name|CMD_ENDSECTION3
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"endsection4"
block|,
name|CMD_ENDSECTION4
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"endsidebar"
block|,
name|CMD_ENDSIDEBAR
block|,
literal|0
block|}
block|,
block|{
literal|"endtable"
block|,
name|CMD_ENDTABLE
block|,
literal|0
block|}
block|,
block|{
literal|"endtopicref"
block|,
name|CMD_ENDTOPICREF
block|,
literal|0
block|}
block|,
block|{
literal|"footnote"
block|,
name|CMD_FOOTNOTE
block|,
literal|0
block|}
block|,
block|{
literal|"generatelist"
block|,
name|CMD_GENERATELIST
block|,
literal|0
block|}
block|,
block|{
literal|"granularity"
block|,
name|CMD_GRANULARITY
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"header"
block|,
name|CMD_HEADER
block|,
literal|0
block|}
block|,
block|{
literal|"hr"
block|,
name|CMD_HR
block|,
literal|0
block|}
block|,
block|{
literal|"i"
block|,
name|CMD_I
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|CMD_IF
block|,
literal|0
block|}
block|,
block|{
literal|"image"
block|,
name|CMD_IMAGE
block|,
literal|0
block|}
block|,
block|{
literal|"important"
block|,
name|CMD_IMPORTANT
block|,
literal|0
block|}
block|,
block|{
literal|"include"
block|,
name|CMD_INCLUDE
block|,
literal|0
block|}
block|,
block|{
literal|"inlineimage"
block|,
name|CMD_INLINEIMAGE
block|,
literal|0
block|}
block|,
block|{
literal|"index"
block|,
name|CMD_INDEX
block|,
literal|0
block|}
block|,
comment|// ### don't document for now
block|{
literal|"keyword"
block|,
name|CMD_KEYWORD
block|,
literal|0
block|}
block|,
block|{
literal|"l"
block|,
name|CMD_L
block|,
literal|0
block|}
block|,
block|{
literal|"legalese"
block|,
name|CMD_LEGALESE
block|,
literal|0
block|}
block|,
block|{
literal|"li"
block|,
name|CMD_LI
block|,
literal|0
block|}
block|,
block|{
literal|"link"
block|,
name|CMD_LINK
block|,
literal|0
block|}
block|,
block|{
literal|"list"
block|,
name|CMD_LIST
block|,
literal|0
block|}
block|,
block|{
literal|"mapref"
block|,
name|CMD_MAPREF
block|,
literal|0
block|}
block|,
block|{
literal|"meta"
block|,
name|CMD_META
block|,
literal|0
block|}
block|,
block|{
literal|"newcode"
block|,
name|CMD_NEWCODE
block|,
literal|0
block|}
block|,
block|{
literal|"note"
block|,
name|CMD_NOTE
block|,
literal|0
block|}
block|,
block|{
literal|"o"
block|,
name|CMD_O
block|,
literal|0
block|}
block|,
block|{
literal|"oldcode"
block|,
name|CMD_OLDCODE
block|,
literal|0
block|}
block|,
block|{
literal|"omit"
block|,
name|CMD_OMIT
block|,
literal|0
block|}
block|,
block|{
literal|"omitvalue"
block|,
name|CMD_OMITVALUE
block|,
literal|0
block|}
block|,
block|{
literal|"overload"
block|,
name|CMD_OVERLOAD
block|,
literal|0
block|}
block|,
block|{
literal|"part"
block|,
name|CMD_PART
block|,
literal|0
block|}
block|,
block|{
literal|"printline"
block|,
name|CMD_PRINTLINE
block|,
literal|0
block|}
block|,
block|{
literal|"printto"
block|,
name|CMD_PRINTTO
block|,
literal|0
block|}
block|,
block|{
literal|"printuntil"
block|,
name|CMD_PRINTUNTIL
block|,
literal|0
block|}
block|,
block|{
literal|"quotation"
block|,
name|CMD_QUOTATION
block|,
literal|0
block|}
block|,
block|{
literal|"quotefile"
block|,
name|CMD_QUOTEFILE
block|,
literal|0
block|}
block|,
block|{
literal|"quotefromfile"
block|,
name|CMD_QUOTEFROMFILE
block|,
literal|0
block|}
block|,
block|{
literal|"quotefunction"
block|,
name|CMD_QUOTEFUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"raw"
block|,
name|CMD_RAW
block|,
literal|0
block|}
block|,
block|{
literal|"row"
block|,
name|CMD_ROW
block|,
literal|0
block|}
block|,
block|{
literal|"sa"
block|,
name|CMD_SA
block|,
literal|0
block|}
block|,
block|{
literal|"section1"
block|,
name|CMD_SECTION1
block|,
literal|0
block|}
block|,
block|{
literal|"section2"
block|,
name|CMD_SECTION2
block|,
literal|0
block|}
block|,
block|{
literal|"section3"
block|,
name|CMD_SECTION3
block|,
literal|0
block|}
block|,
block|{
literal|"section4"
block|,
name|CMD_SECTION4
block|,
literal|0
block|}
block|,
block|{
literal|"sidebar"
block|,
name|CMD_SIDEBAR
block|,
literal|0
block|}
block|,
block|{
literal|"sincelist"
block|,
name|CMD_SINCELIST
block|,
literal|0
block|}
block|,
block|{
literal|"skipline"
block|,
name|CMD_SKIPLINE
block|,
literal|0
block|}
block|,
block|{
literal|"skipto"
block|,
name|CMD_SKIPTO
block|,
literal|0
block|}
block|,
block|{
literal|"skipuntil"
block|,
name|CMD_SKIPUNTIL
block|,
literal|0
block|}
block|,
block|{
literal|"snippet"
block|,
name|CMD_SNIPPET
block|,
literal|0
block|}
block|,
block|{
literal|"span"
block|,
name|CMD_SPAN
block|,
literal|0
block|}
block|,
block|{
literal|"sub"
block|,
name|CMD_SUB
block|,
literal|0
block|}
block|,
block|{
literal|"sup"
block|,
name|CMD_SUP
block|,
literal|0
block|}
block|,
block|{
literal|"table"
block|,
name|CMD_TABLE
block|,
literal|0
block|}
block|,
block|{
literal|"tableofcontents"
block|,
name|CMD_TABLEOFCONTENTS
block|,
literal|0
block|}
block|,
block|{
literal|"target"
block|,
name|CMD_TARGET
block|,
literal|0
block|}
block|,
block|{
literal|"topicref"
block|,
name|CMD_TOPICREF
block|,
literal|0
block|}
block|,
block|{
literal|"tt"
block|,
name|CMD_TT
block|,
literal|0
block|}
block|,
block|{
literal|"uicontrol"
block|,
name|CMD_UICONTROL
block|,
literal|0
block|}
block|,
block|{
literal|"underline"
block|,
name|CMD_UNDERLINE
block|,
literal|0
block|}
block|,
block|{
literal|"unicode"
block|,
name|CMD_UNICODE
block|,
literal|0
block|}
block|,
block|{
literal|"value"
block|,
name|CMD_VALUE
block|,
literal|0
block|}
block|,
block|{
literal|"warning"
block|,
name|CMD_WARNING
block|,
literal|0
block|}
block|,
block|{
literal|"qml"
block|,
name|CMD_QML
block|,
literal|0
block|}
block|,
block|{
literal|"endqml"
block|,
name|CMD_ENDQML
block|,
literal|0
block|}
block|,
block|{
literal|"cpp"
block|,
name|CMD_CPP
block|,
literal|0
block|}
block|,
block|{
literal|"endcpp"
block|,
name|CMD_ENDCPP
block|,
literal|0
block|}
block|,
block|{
literal|"qmltext"
block|,
name|CMD_QMLTEXT
block|,
literal|0
block|}
block|,
block|{
literal|"endqmltext"
block|,
name|CMD_ENDQMLTEXT
block|,
literal|0
block|}
block|,
block|{
literal|"cpptext"
block|,
name|CMD_CPPTEXT
block|,
literal|0
block|}
block|,
block|{
literal|"endcpptext"
block|,
name|CMD_ENDCPPTEXT
block|,
literal|0
block|}
block|,
block|{
literal|"js"
block|,
name|CMD_JS
block|,
literal|0
block|}
block|,
block|{
literal|"endjs"
block|,
name|CMD_ENDJS
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|QHash_QString_int
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|QHash_QString_int
typedef|;
end_typedef
begin_typedef
DECL|typedef|QHash_QString_Macro
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|Macro
argument_list|>
name|QHash_QString_Macro
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QStringMap
argument_list|,
argument|aliasMap
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QHash_QString_int
argument_list|,
argument|cmdHash
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QHash_QString_Macro
argument_list|,
argument|macroHash
argument_list|)
end_macro
begin_class
DECL|class|DocPrivateExtra
class|class
name|DocPrivateExtra
block|{
public|public:
DECL|member|baseName
name|QString
name|baseName
decl_stmt|;
DECL|member|granularity
name|Doc
operator|::
name|Sections
name|granularity
decl_stmt|;
DECL|member|section
name|Doc
operator|::
name|Sections
name|section
decl_stmt|;
comment|// ###
DECL|member|tableOfContents
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|tableOfContents
decl_stmt|;
DECL|member|tableOfContentsLevels
name|QList
argument_list|<
name|int
argument_list|>
name|tableOfContentsLevels
decl_stmt|;
DECL|member|keywords
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|keywords
decl_stmt|;
DECL|member|targets
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
name|targets
decl_stmt|;
DECL|member|metaMap
name|QStringMultiMap
name|metaMap
decl_stmt|;
DECL|function|DocPrivateExtra
name|DocPrivateExtra
parameter_list|()
member_init_list|:
name|granularity
argument_list|(
name|Doc
operator|::
name|Part
argument_list|)
block|{ }
block|}
class|;
end_class
begin_struct
DECL|struct|Shared
struct|struct
name|Shared
comment|// ### get rid of
block|{
DECL|function|Shared
name|Shared
parameter_list|()
member_init_list|:
name|count
argument_list|(
literal|1
argument_list|)
block|{ }
DECL|function|ref
name|void
name|ref
parameter_list|()
block|{
operator|++
name|count
expr_stmt|;
block|}
DECL|function|deref
name|bool
name|deref
parameter_list|()
block|{
return|return
operator|(
operator|--
name|count
operator|==
literal|0
operator|)
return|;
block|}
DECL|member|count
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|cleanLink
specifier|static
name|QString
name|cleanLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|link
parameter_list|)
block|{
name|int
name|colonPos
init|=
name|link
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|colonPos
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
operator|&&
operator|!
name|link
operator|.
name|startsWith
argument_list|(
literal|"mailto:"
argument_list|)
operator|)
condition|)
return|return
name|link
return|;
return|return
name|link
operator|.
name|mid
argument_list|(
name|colonPos
operator|+
literal|1
argument_list|)
operator|.
name|simplified
argument_list|()
return|;
block|}
end_function
begin_typedef
DECL|typedef|CommandMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|ArgList
argument_list|>
name|CommandMap
typedef|;
end_typedef
begin_class
DECL|class|DocPrivate
class|class
name|DocPrivate
super|:
specifier|public
name|Shared
block|{
public|public:
name|DocPrivate
parameter_list|(
specifier|const
name|Location
modifier|&
name|start
init|=
name|Location
operator|::
name|null
parameter_list|,
specifier|const
name|Location
modifier|&
name|end
init|=
name|Location
operator|::
name|null
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
init|=
name|QString
argument_list|()
parameter_list|)
constructor_decl|;
name|~
name|DocPrivate
parameter_list|()
destructor_decl|;
name|void
name|addAlso
parameter_list|(
specifier|const
name|Text
modifier|&
name|also
parameter_list|)
function_decl|;
name|void
name|constructExtra
parameter_list|()
function_decl|;
name|bool
name|isEnumDocSimplifiable
parameter_list|()
specifier|const
function_decl|;
comment|// ### move some of this in DocPrivateExtra
DECL|member|start_loc
name|Location
name|start_loc
decl_stmt|;
DECL|member|end_loc
name|Location
name|end_loc
decl_stmt|;
DECL|member|src
name|QString
name|src
decl_stmt|;
DECL|member|text
name|Text
name|text
decl_stmt|;
DECL|member|params
name|QSet
argument_list|<
name|QString
argument_list|>
name|params
decl_stmt|;
DECL|member|alsoList
name|QList
argument_list|<
name|Text
argument_list|>
name|alsoList
decl_stmt|;
DECL|member|enumItemList
name|QStringList
name|enumItemList
decl_stmt|;
DECL|member|omitEnumItemList
name|QStringList
name|omitEnumItemList
decl_stmt|;
DECL|member|metacommandsUsed
name|QSet
argument_list|<
name|QString
argument_list|>
name|metacommandsUsed
decl_stmt|;
DECL|member|metaCommandMap
name|CommandMap
name|metaCommandMap
decl_stmt|;
name|bool
name|hasLegalese
range|:
literal|1
decl_stmt|;
name|bool
name|hasSectioningUnits
range|:
literal|1
decl_stmt|;
DECL|member|extra
name|DocPrivateExtra
modifier|*
name|extra
decl_stmt|;
DECL|member|topics
name|TopicList
name|topics
decl_stmt|;
DECL|member|ditamap_
name|DitaRefList
name|ditamap_
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|DocPrivate
name|DocPrivate
operator|::
name|DocPrivate
parameter_list|(
specifier|const
name|Location
modifier|&
name|start
parameter_list|,
specifier|const
name|Location
modifier|&
name|end
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|)
member_init_list|:
name|start_loc
argument_list|(
name|start
argument_list|)
member_init_list|,
name|end_loc
argument_list|(
name|end
argument_list|)
member_init_list|,
name|src
argument_list|(
name|source
argument_list|)
member_init_list|,
name|hasLegalese
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|hasSectioningUnits
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|extra
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   If the doc is a ditamap, the destructor deletes each element   in the ditamap structure. These were allocated as needed.  */
end_comment
begin_destructor
DECL|function|~DocPrivate
name|DocPrivate
operator|::
name|~
name|DocPrivate
parameter_list|()
block|{
operator|delete
name|extra
expr_stmt|;
foreach|foreach
control|(
name|DitaRef
modifier|*
name|t
decl|,
name|ditamap_
control|)
block|{
operator|delete
name|t
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|addAlso
name|void
name|DocPrivate
operator|::
name|addAlso
parameter_list|(
specifier|const
name|Text
modifier|&
name|also
parameter_list|)
block|{
name|alsoList
operator|.
name|append
argument_list|(
name|also
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|constructExtra
name|void
name|DocPrivate
operator|::
name|constructExtra
parameter_list|()
block|{
if|if
condition|(
name|extra
operator|==
literal|0
condition|)
name|extra
operator|=
operator|new
name|DocPrivateExtra
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isEnumDocSimplifiable
name|bool
name|DocPrivate
operator|::
name|isEnumDocSimplifiable
parameter_list|()
specifier|const
block|{
name|bool
name|justMetColon
init|=
literal|false
decl_stmt|;
name|int
name|numValueTables
init|=
literal|0
decl_stmt|;
specifier|const
name|Atom
modifier|*
name|atom
init|=
name|text
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|AutoLink
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
block|{
name|justMetColon
operator|=
name|atom
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListLeft
operator|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
operator|)
condition|)
block|{
if|if
condition|(
name|justMetColon
operator|||
name|numValueTables
operator|>
literal|0
condition|)
return|return
literal|false
return|;
operator|++
name|numValueTables
expr_stmt|;
block|}
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_class
DECL|class|DocParser
class|class
name|DocParser
block|{
public|public:
name|void
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|DocPrivate
modifier|*
name|docPrivate
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|possibleTopics
parameter_list|)
function_decl|;
specifier|static
name|int
name|endCmdFor
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
specifier|static
name|QString
name|cmdName
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
specifier|static
name|QString
name|endCmdName
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
specifier|static
name|QString
name|untabifyEtc
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
function_decl|;
specifier|static
name|int
name|indentLevel
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
function_decl|;
specifier|static
name|QString
name|unindent
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
function_decl|;
specifier|static
name|QString
name|slashed
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
function_decl|;
DECL|member|tabSize
specifier|static
name|int
name|tabSize
decl_stmt|;
DECL|member|exampleFiles
specifier|static
name|QStringList
name|exampleFiles
decl_stmt|;
DECL|member|exampleDirs
specifier|static
name|QStringList
name|exampleDirs
decl_stmt|;
DECL|member|sourceFiles
specifier|static
name|QStringList
name|sourceFiles
decl_stmt|;
DECL|member|sourceDirs
specifier|static
name|QStringList
name|sourceDirs
decl_stmt|;
DECL|member|quoting
specifier|static
name|bool
name|quoting
decl_stmt|;
private|private:
name|Location
modifier|&
name|location
parameter_list|()
function_decl|;
name|QString
name|detailsUnknownCommand
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
function_decl|;
name|void
name|insertBaseName
parameter_list|(
specifier|const
name|QString
modifier|&
name|baseName
parameter_list|)
function_decl|;
name|void
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|bool
name|keyword
parameter_list|)
function_decl|;
name|void
name|include
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|)
function_decl|;
name|void
name|startFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
name|bool
name|openCommand
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
name|bool
name|closeCommand
parameter_list|(
name|int
name|endCmd
parameter_list|)
function_decl|;
name|void
name|startSection
parameter_list|(
name|Doc
operator|::
name|Sections
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
name|void
name|endSection
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|endCmd
parameter_list|)
function_decl|;
name|void
name|parseAlso
parameter_list|()
function_decl|;
name|void
name|append
parameter_list|(
name|Atom
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
init|=
name|QString
argument_list|()
parameter_list|)
function_decl|;
name|void
name|append
parameter_list|(
name|Atom
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|p1
parameter_list|,
specifier|const
name|QString
modifier|&
name|p2
parameter_list|)
function_decl|;
name|void
name|appendChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
function_decl|;
name|void
name|appendWord
parameter_list|(
specifier|const
name|QString
modifier|&
name|word
parameter_list|)
function_decl|;
name|void
name|appendToCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|code
parameter_list|)
function_decl|;
name|void
name|appendToCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|code
parameter_list|,
name|Atom
operator|::
name|Type
name|defaultType
parameter_list|)
function_decl|;
name|void
name|startNewPara
parameter_list|()
function_decl|;
name|void
name|enterPara
parameter_list|(
name|Atom
operator|::
name|Type
name|leftType
init|=
name|Atom
operator|::
name|ParaLeft
parameter_list|,
name|Atom
operator|::
name|Type
name|rightType
init|=
name|Atom
operator|::
name|ParaRight
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
init|=
name|QString
argument_list|()
parameter_list|)
function_decl|;
name|void
name|leavePara
parameter_list|()
function_decl|;
name|void
name|leaveValue
parameter_list|()
function_decl|;
name|void
name|leaveValueList
parameter_list|()
function_decl|;
name|void
name|leaveTableRow
parameter_list|()
function_decl|;
name|CodeMarker
modifier|*
name|quoteFromFile
parameter_list|()
function_decl|;
name|void
name|expandMacro
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|def
parameter_list|,
name|int
name|numParams
parameter_list|)
function_decl|;
name|QString
name|expandMacroToString
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|def
parameter_list|,
name|int
name|numParams
parameter_list|)
function_decl|;
name|Doc
operator|::
name|Sections
name|getSectioningUnit
parameter_list|()
function_decl|;
name|QString
name|getArgument
parameter_list|(
name|bool
name|verbatim
init|=
literal|false
parameter_list|)
function_decl|;
name|QString
name|getBracedArgument
parameter_list|(
name|bool
name|verbatim
parameter_list|)
function_decl|;
name|QString
name|getOptionalArgument
parameter_list|()
function_decl|;
name|QString
name|getRestOfLine
parameter_list|()
function_decl|;
name|QString
name|getMetaCommandArgument
parameter_list|(
specifier|const
name|QString
modifier|&
name|cmdStr
parameter_list|)
function_decl|;
name|QString
name|getUntilEnd
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
name|QString
name|getCode
parameter_list|(
name|int
name|cmd
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
function_decl|;
name|QString
name|getUnmarkedCode
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
name|bool
name|isBlankLine
parameter_list|()
function_decl|;
name|bool
name|isLeftBraceAhead
parameter_list|()
function_decl|;
name|void
name|skipSpacesOnLine
parameter_list|()
function_decl|;
name|void
name|skipSpacesOrOneEndl
parameter_list|()
function_decl|;
name|void
name|skipAllSpaces
parameter_list|()
function_decl|;
name|void
name|skipToNextPreprocessorCommand
parameter_list|()
function_decl|;
DECL|member|openedInputs
name|QStack
argument_list|<
name|int
argument_list|>
name|openedInputs
decl_stmt|;
DECL|member|in
name|QString
name|in
decl_stmt|;
DECL|member|pos
name|int
name|pos
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|cachedLoc
name|Location
name|cachedLoc
decl_stmt|;
DECL|member|cachedPos
name|int
name|cachedPos
decl_stmt|;
DECL|member|priv
name|DocPrivate
modifier|*
name|priv
decl_stmt|;
DECL|enum|ParagraphState
enum|enum
name|ParagraphState
block|{
DECL|enumerator|OutsideParagraph
name|OutsideParagraph
block|,
DECL|enumerator|InSingleLineParagraph
name|InSingleLineParagraph
block|,
DECL|enumerator|InMultiLineParagraph
name|InMultiLineParagraph
block|}
enum|;
DECL|member|paraState
name|ParagraphState
name|paraState
decl_stmt|;
DECL|member|inTableHeader
name|bool
name|inTableHeader
decl_stmt|;
DECL|member|inTableRow
name|bool
name|inTableRow
decl_stmt|;
DECL|member|inTableItem
name|bool
name|inTableItem
decl_stmt|;
DECL|member|indexStartedPara
name|bool
name|indexStartedPara
decl_stmt|;
comment|// ### rename
DECL|member|pendingParaLeftType
name|Atom
operator|::
name|Type
name|pendingParaLeftType
decl_stmt|;
DECL|member|pendingParaRightType
name|Atom
operator|::
name|Type
name|pendingParaRightType
decl_stmt|;
DECL|member|pendingParaString
name|QString
name|pendingParaString
decl_stmt|;
DECL|member|braceDepth
name|int
name|braceDepth
decl_stmt|;
DECL|member|minIndent
name|int
name|minIndent
decl_stmt|;
DECL|member|currentSection
name|Doc
operator|::
name|Sections
name|currentSection
decl_stmt|;
DECL|member|targetMap
name|QMap
argument_list|<
name|QString
argument_list|,
name|Location
argument_list|>
name|targetMap
decl_stmt|;
DECL|member|pendingFormats
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|pendingFormats
decl_stmt|;
DECL|member|openedCommands
name|QStack
argument_list|<
name|int
argument_list|>
name|openedCommands
decl_stmt|;
DECL|member|openedLists
name|QStack
argument_list|<
name|OpenedList
argument_list|>
name|openedLists
decl_stmt|;
DECL|member|quoter
name|Quoter
name|quoter
decl_stmt|;
DECL|member|ditarefs_
name|QStack
argument_list|<
name|DitaRef
modifier|*
argument_list|>
name|ditarefs_
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|tabSize
name|int
name|DocParser
operator|::
name|tabSize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleFiles
name|QStringList
name|DocParser
operator|::
name|exampleFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleDirs
name|QStringList
name|DocParser
operator|::
name|exampleDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|sourceFiles
name|QStringList
name|DocParser
operator|::
name|sourceFiles
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|sourceDirs
name|QStringList
name|DocParser
operator|::
name|sourceDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|quoting
name|bool
name|DocParser
operator|::
name|quoting
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Parse the \a source string to build a Text data structure   in \a docPrivate. The Text data structure is a linked list   of Atoms.    \a metaCommandSet is the set of metacommands that may be   found in \a source. These metacommands are not markup text   commands. They are topic commands and related metacommands.  */
end_comment
begin_function
DECL|function|parse
name|void
name|DocParser
operator|::
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|DocPrivate
modifier|*
name|docPrivate
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|possibleTopics
parameter_list|)
block|{
name|in
operator|=
name|source
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
name|cachedLoc
operator|=
name|docPrivate
operator|->
name|start_loc
expr_stmt|;
name|cachedPos
operator|=
literal|0
expr_stmt|;
name|priv
operator|=
name|docPrivate
expr_stmt|;
name|priv
operator|->
name|text
operator|<<
name|Atom
operator|::
name|Nop
expr_stmt|;
name|priv
operator|->
name|topics
operator|.
name|clear
argument_list|()
expr_stmt|;
name|paraState
operator|=
name|OutsideParagraph
expr_stmt|;
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableRow
operator|=
literal|false
expr_stmt|;
name|inTableItem
operator|=
literal|false
expr_stmt|;
name|indexStartedPara
operator|=
literal|false
expr_stmt|;
name|pendingParaLeftType
operator|=
name|Atom
operator|::
name|Nop
expr_stmt|;
name|pendingParaRightType
operator|=
name|Atom
operator|::
name|Nop
expr_stmt|;
name|braceDepth
operator|=
literal|0
expr_stmt|;
name|minIndent
operator|=
name|INT_MAX
expr_stmt|;
name|currentSection
operator|=
name|Doc
operator|::
name|NoSection
expr_stmt|;
name|openedCommands
operator|.
name|push
argument_list|(
name|CMD_OMIT
argument_list|)
expr_stmt|;
name|quoter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|CodeMarker
modifier|*
name|marker
init|=
literal|0
decl_stmt|;
name|Atom
modifier|*
name|currentLinkAtom
init|=
literal|0
decl_stmt|;
name|QString
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|QStack
argument_list|<
name|bool
argument_list|>
name|preprocessorSkipping
decl_stmt|;
name|int
name|numPreprocessorSkipping
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
condition|)
block|{
name|QChar
name|ch
init|=
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'\\'
case|:
block|{
name|QString
name|cmdStr
decl_stmt|;
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
condition|)
block|{
name|ch
operator|=
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
block|{
name|cmdStr
operator|+=
name|ch
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cmdStr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|len
condition|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|skipAllSpaces
argument_list|()
expr_stmt|;
name|appendChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendChar
argument_list|(
name|in
operator|.
name|at
argument_list|(
name|pos
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|cmd
init|=
name|cmdHash
argument_list|()
operator|->
name|value
argument_list|(
name|cmdStr
argument_list|,
name|NOT_A_CMD
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_A
case|:
name|enterPara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_PARAMETER
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_PARAMETER
argument_list|)
expr_stmt|;
name|priv
operator|->
name|params
operator|.
name|insert
argument_list|(
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ABSTRACT
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|AbstractLeft
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_BADCODE
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeBad
argument_list|,
name|getCode
argument_list|(
name|CMD_BADCODE
argument_list|,
name|marker
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BASENAME
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|insertBaseName
argument_list|(
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BR
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|BR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BOLD
case|:
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"'\\bold' is deprecated. Use '\\b'"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CMD_B
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_BOLD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BRIEF
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|(
name|Atom
operator|::
name|BriefLeft
argument_list|,
name|Atom
operator|::
name|BriefRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_C
case|:
name|enterPara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|untabifyEtc
argument_list|(
name|getArgument
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForCode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|C
argument_list|,
name|marker
operator|->
name|markedUpCode
argument_list|(
name|p1
argument_list|,
literal|0
argument_list|,
name|location
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_CAPTION
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|(
name|Atom
operator|::
name|CaptionLeft
argument_list|,
name|Atom
operator|::
name|CaptionRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_CHAPTER
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Chapter
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_CODE
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Code
argument_list|,
name|getCode
argument_list|(
name|CMD_CODE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_QML
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Qml
argument_list|,
name|getCode
argument_list|(
name|CMD_QML
argument_list|,
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_QMLTEXT
case|:
name|append
argument_list|(
name|Atom
operator|::
name|QmlText
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_JS
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|JavaScript
argument_list|,
name|getCode
argument_list|(
name|CMD_JS
argument_list|,
name|CodeMarker
operator|::
name|markerForLanguage
argument_list|(
name|QLatin1String
argument_list|(
literal|"JavaScript"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_DIV
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getArgument
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|DivLeft
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|openedCommands
operator|.
name|push
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDDIV
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|DivRight
argument_list|)
expr_stmt|;
name|closeCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_CODELINE
case|:
block|{
if|if
condition|(
operator|!
name|quoting
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Code
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"\n\n"
argument_list|)
condition|)
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
name|appendToCode
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_DOTS
case|:
block|{
if|if
condition|(
operator|!
name|quoting
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Code
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"\n\n"
argument_list|)
condition|)
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
name|QString
name|arg
init|=
name|getOptionalArgument
argument_list|()
decl_stmt|;
name|int
name|indent
init|=
literal|4
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|.
name|isEmpty
argument_list|()
condition|)
name|indent
operator|=
name|arg
operator|.
name|toInt
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|appendToCode
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|appendToCode
argument_list|(
literal|"...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|QString
name|arg
init|=
name|getOptionalArgument
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|isEmpty
argument_list|()
condition|)
name|arg
operator|=
literal|"4"
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_ELSE
case|:
if|if
condition|(
name|preprocessorSkipping
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|preprocessorSkipping
operator|.
name|top
argument_list|()
condition|)
block|{
operator|--
name|numPreprocessorSkipping
expr_stmt|;
block|}
else|else
block|{
operator|++
name|numPreprocessorSkipping
expr_stmt|;
block|}
name|preprocessorSkipping
operator|.
name|top
argument_list|()
operator|=
operator|!
name|preprocessorSkipping
operator|.
name|top
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getRestOfLine
argument_list|()
expr_stmt|;
comment|// ### should ensure that it's empty
if|if
condition|(
name|numPreprocessorSkipping
condition|)
name|skipToNextPreprocessorCommand
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ELSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDABSTRACT
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|AbstractRight
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDCHAPTER
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Chapter
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDCODE
case|:
name|closeCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDQML
case|:
name|closeCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDQMLTEXT
case|:
name|append
argument_list|(
name|Atom
operator|::
name|EndQmlText
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDJS
case|:
name|closeCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDFOOTNOTE
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FootnoteRight
argument_list|)
expr_stmt|;
name|paraState
operator|=
name|InMultiLineParagraph
expr_stmt|;
comment|// ###
block|}
break|break;
case|case
name|CMD_ENDIF
case|:
if|if
condition|(
name|preprocessorSkipping
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|preprocessorSkipping
operator|.
name|pop
argument_list|()
condition|)
operator|--
name|numPreprocessorSkipping
expr_stmt|;
operator|(
name|void
operator|)
name|getRestOfLine
argument_list|()
expr_stmt|;
comment|// ### should ensure that it's empty
if|if
condition|(
name|numPreprocessorSkipping
condition|)
name|skipToNextPreprocessorCommand
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ENDIF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDLEGALESE
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|LegaleseRight
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDLINK
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDLIST
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListRight
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|openedLists
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDMAPREF
case|:
case|case
name|CMD_ENDTOPICREF
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|ditarefs_
operator|.
name|pop
argument_list|()
expr_stmt|;
comment|// zzz
block|}
break|break;
case|case
name|CMD_ENDOMIT
case|:
name|closeCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDPART
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Part
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDQUOTATION
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|QuotationRight
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDRAW
case|:
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ENDRAW
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDSECTION1
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Section1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDSECTION2
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Section2
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDSECTION3
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Section3
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDSECTION4
case|:
name|endSection
argument_list|(
name|Doc
operator|::
name|Section4
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ENDSIDEBAR
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SidebarRight
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ENDTABLE
case|:
if|if
condition|(
name|closeCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leaveTableRow
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableRight
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_FOOTNOTE
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FootnoteLeft
argument_list|)
expr_stmt|;
name|paraState
operator|=
name|OutsideParagraph
expr_stmt|;
comment|// ###
block|}
break|break;
case|case
name|CMD_ANNOTATEDLIST
case|:
name|append
argument_list|(
name|Atom
operator|::
name|AnnotatedList
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SINCELIST
case|:
name|append
argument_list|(
name|Atom
operator|::
name|SinceList
argument_list|,
name|getRestOfLine
argument_list|()
operator|.
name|simplified
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_GENERATELIST
case|:
name|append
argument_list|(
name|Atom
operator|::
name|GeneratedList
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_GRANULARITY
case|:
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
name|priv
operator|->
name|extra
operator|->
name|granularity
operator|=
name|getSectioningUnit
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_HEADER
case|:
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|==
name|CMD_TABLE
condition|)
block|{
name|leaveTableRow
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableHeaderLeft
argument_list|)
expr_stmt|;
name|inTableHeader
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|openedCommands
operator|.
name|contains
argument_list|(
name|CMD_TABLE
argument_list|)
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot use '\\%1' within '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_HEADER
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot use '\\%1' outside of '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_HEADER
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_TABLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_I
case|:
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"'\\i' is deprecated. Use '\\e' for italic or '\\li' for list item"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CMD_E
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_ITALIC
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_HR
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|HR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_IF
case|:
name|preprocessorSkipping
operator|.
name|push
argument_list|(
operator|!
name|Tokenizer
operator|::
name|isTrue
argument_list|(
name|getRestOfLine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preprocessorSkipping
operator|.
name|top
argument_list|()
condition|)
operator|++
name|numPreprocessorSkipping
expr_stmt|;
if|if
condition|(
name|numPreprocessorSkipping
condition|)
name|skipToNextPreprocessorCommand
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_IMAGE
case|:
name|leaveValueList
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Image
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ImageText
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_IMPORTANT
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|(
name|Atom
operator|::
name|ImportantLeft
argument_list|,
name|Atom
operator|::
name|ImportantRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_INCLUDE
case|:
block|{
name|QString
name|fileName
init|=
name|getArgument
argument_list|()
decl_stmt|;
name|QString
name|identifier
init|=
name|getRestOfLine
argument_list|()
decl_stmt|;
name|include
argument_list|(
name|fileName
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_INLINEIMAGE
case|:
name|enterPara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|InlineImage
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ImageText
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_INDEX
case|:
if|if
condition|(
name|paraState
operator|==
name|OutsideParagraph
condition|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|indexStartedPara
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|Atom
modifier|*
name|last
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexStartedPara
operator|&&
operator|(
name|last
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|FormattingRight
operator|||
name|last
operator|->
name|string
argument_list|()
operator|!=
name|ATOM_FORMATTING_INDEX
operator|)
condition|)
name|indexStartedPara
operator|=
literal|false
expr_stmt|;
block|}
name|startFormat
argument_list|(
name|ATOM_FORMATTING_INDEX
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_KEYWORD
case|:
name|insertTarget
argument_list|(
name|getRestOfLine
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_L
case|:
name|enterPara
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|currentLinkAtom
operator|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
expr_stmt|;
name|startFormat
argument_list|(
name|ATOM_FORMATTING_LINK
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cleanLink
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|cleanLink
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_LEGALESE
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|LegaleseLeft
argument_list|)
expr_stmt|;
name|docPrivate
operator|->
name|hasLegalese
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|CMD_LINK
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CMD_LIST
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|openedLists
operator|.
name|push
argument_list|(
name|OpenedList
argument_list|(
name|location
argument_list|()
argument_list|,
name|getOptionalArgument
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_TOPICREF
case|:
case|case
name|CMD_MAPREF
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|DitaRef
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_MAPREF
condition|)
name|t
operator|=
operator|new
name|MapRef
argument_list|()
expr_stmt|;
else|else
name|t
operator|=
operator|new
name|TopicRef
argument_list|()
expr_stmt|;
name|t
operator|->
name|setNavtitle
argument_list|(
name|getArgument
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_MAPREF
condition|)
name|t
operator|->
name|setHref
argument_list|(
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|setHref
argument_list|(
name|getOptionalArgument
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ditarefs_
operator|.
name|isEmpty
argument_list|()
condition|)
name|priv
operator|->
name|ditamap_
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|ditarefs_
operator|.
name|top
argument_list|()
operator|->
name|appendSubref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ditarefs_
operator|.
name|push
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_META
case|:
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|priv
operator|->
name|extra
operator|->
name|metaMap
operator|.
name|insert
argument_list|(
name|p1
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_NEWCODE
case|:
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_NEWCODE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_NOTE
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|(
name|Atom
operator|::
name|NoteLeft
argument_list|,
name|Atom
operator|::
name|NoteRight
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_O
case|:
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"'\\o' is deprecated. Use '\\li'"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CMD_LI
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|==
name|CMD_LIST
condition|)
block|{
if|if
condition|(
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|ListLeft
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListItemNumber
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|numberString
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|,
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|styleString
argument_list|()
argument_list|)
expr_stmt|;
name|enterPara
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|==
name|CMD_TABLE
condition|)
block|{
name|p1
operator|=
literal|"1,1"
expr_stmt|;
name|p2
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|p2
operator|=
name|getArgument
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inTableHeader
operator|&&
operator|!
name|inTableRow
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '\\%1' or '\\%1' before '\\%3'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_HEADER
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ROW
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_LI
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableRowLeft
argument_list|)
expr_stmt|;
name|inTableRow
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inTableItem
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|TableItemRight
argument_list|)
expr_stmt|;
name|inTableItem
operator|=
literal|false
expr_stmt|;
block|}
name|append
argument_list|(
name|Atom
operator|::
name|TableItemLeft
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|inTableItem
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Command '\\%1' outside of '\\%2' and '\\%3'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_LIST
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_TABLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_OLDCODE
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeOld
argument_list|,
name|getCode
argument_list|(
name|CMD_OLDCODE
argument_list|,
name|marker
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeNew
argument_list|,
name|getCode
argument_list|(
name|CMD_NEWCODE
argument_list|,
name|marker
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_OMIT
case|:
name|getUntilEnd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_OMITVALUE
case|:
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|enumItemList
operator|.
name|contains
argument_list|(
name|p1
argument_list|)
condition|)
name|priv
operator|->
name|enumItemList
operator|.
name|append
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|omitEnumItemList
operator|.
name|contains
argument_list|(
name|p1
argument_list|)
condition|)
name|priv
operator|->
name|omitEnumItemList
operator|.
name|append
argument_list|(
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_PART
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Part
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_PRINTLINE
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|appendToCode
argument_list|(
name|quoter
operator|.
name|quoteLine
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_PRINTTO
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|appendToCode
argument_list|(
name|quoter
operator|.
name|quoteTo
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_PRINTUNTIL
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|appendToCode
argument_list|(
name|quoter
operator|.
name|quoteUntil
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_QUOTATION
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|QuotationLeft
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_QUOTEFILE
case|:
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|QString
name|fileName
init|=
name|getArgument
argument_list|()
decl_stmt|;
name|Doc
operator|::
name|quoteFromFile
argument_list|(
name|location
argument_list|()
argument_list|,
name|quoter
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|Code
argument_list|,
name|quoter
operator|.
name|quoteTo
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|quoter
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CMD_QUOTEFROMFILE
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|quoteFromFile
argument_list|()
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_QUOTEFUNCTION
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|marker
operator|=
name|quoteFromFile
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getRestOfLine
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
block|{
name|quoter
operator|.
name|quoteTo
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|slashed
argument_list|(
name|marker
operator|->
name|functionBeginRegExp
argument_list|(
name|p1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Code
argument_list|,
name|quoter
operator|.
name|quoteUntil
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|slashed
argument_list|(
name|marker
operator|->
name|functionEndRegExp
argument_list|(
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quoter
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|slashed
argument_list|(
name|marker
operator|->
name|functionEndRegExp
argument_list|(
name|p1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_RAW
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getRestOfLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|p1
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing format name after '\\%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_RAW
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormatIf
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|RawString
argument_list|,
name|untabifyEtc
argument_list|(
name|getUntilEnd
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormatElse
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormatEndif
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_ROW
case|:
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|==
name|CMD_TABLE
condition|)
block|{
name|p1
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
name|p1
operator|=
name|getArgument
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|leaveTableRow
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableRowLeft
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|inTableRow
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|openedCommands
operator|.
name|contains
argument_list|(
name|CMD_TABLE
argument_list|)
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot use '\\%1' within '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ROW
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot use '\\%1' outside of '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ROW
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_TABLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_SA
case|:
name|parseAlso
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_SECTION1
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Section1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SECTION2
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Section2
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SECTION3
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Section3
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SECTION4
case|:
name|startSection
argument_list|(
name|Doc
operator|::
name|Section4
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SIDEBAR
case|:
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SidebarLeft
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_SKIPLINE
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|quoter
operator|.
name|quoteLine
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_SKIPTO
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|quoter
operator|.
name|quoteTo
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_SKIPUNTIL
case|:
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quoting
condition|)
name|quoter
operator|.
name|quoteUntil
argument_list|(
name|location
argument_list|()
argument_list|,
name|cmdStr
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|CodeQuoteArgument
argument_list|,
name|getRestOfLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_SPAN
case|:
name|p1
operator|=
name|ATOM_FORMATTING_SPAN
operator|+
name|getArgument
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|startFormat
argument_list|(
name|p1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SNIPPET
case|:
name|leavePara
argument_list|()
expr_stmt|;
block|{
name|QString
name|snippet
init|=
name|getArgument
argument_list|()
decl_stmt|;
name|QString
name|identifier
init|=
name|getRestOfLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|quoting
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|SnippetCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SnippetLocation
argument_list|,
name|snippet
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SnippetIdentifier
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|marker
operator|=
name|Doc
operator|::
name|quoteFromFile
argument_list|(
name|location
argument_list|()
argument_list|,
name|quoter
argument_list|,
name|snippet
argument_list|)
expr_stmt|;
name|appendToCode
argument_list|(
name|quoter
operator|.
name|quoteSnippet
argument_list|(
name|location
argument_list|()
argument_list|,
name|identifier
argument_list|)
argument_list|,
name|marker
operator|->
name|atomType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_SUB
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_SUBSCRIPT
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SUP
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_SUPERSCRIPT
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_TABLE
case|:
comment|//p1 = getRestOfLine();
name|p1
operator|=
name|getOptionalArgument
argument_list|()
expr_stmt|;
name|p2
operator|=
name|getOptionalArgument
argument_list|()
expr_stmt|;
if|if
condition|(
name|openCommand
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableLeft
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|inTableHeader
operator|=
literal|false
expr_stmt|;
name|inTableRow
operator|=
literal|false
expr_stmt|;
name|inTableItem
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|CMD_TABLEOFCONTENTS
case|:
name|p1
operator|=
literal|"1"
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|p1
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|getSectioningUnit
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableOfContents
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_TARGET
case|:
name|insertTarget
argument_list|(
name|getRestOfLine
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_TT
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_TELETYPE
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_UICONTROL
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_UICONTROL
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_UNDERLINE
case|:
name|startFormat
argument_list|(
name|ATOM_FORMATTING_UNDERLINE
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_UNICODE
case|:
name|enterPara
argument_list|()
expr_stmt|;
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
block|{
name|bool
name|ok
decl_stmt|;
name|uint
name|unicodeChar
init|=
name|p1
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
operator|(
name|unicodeChar
operator|==
literal|0x0000
operator|)
operator|||
operator|(
name|unicodeChar
operator|>
literal|0xFFFE
operator|)
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid Unicode character '%1' specified "
literal|"with '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|p1
argument_list|,
name|cmdName
argument_list|(
name|CMD_UNICODE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|QChar
argument_list|(
name|unicodeChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_VALUE
case|:
name|leaveValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|OpenedList
operator|::
name|Value
condition|)
block|{
name|p1
operator|=
name|getArgument
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|enumItemList
operator|.
name|contains
argument_list|(
name|p1
argument_list|)
condition|)
name|priv
operator|->
name|enumItemList
operator|.
name|append
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListTagLeft
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListTagRight
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListItemLeft
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
if|if
condition|(
name|isBlankLine
argument_list|()
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|Nop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ### problems
block|}
break|break;
case|case
name|CMD_WARNING
case|:
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"Warning:"
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_BOLD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_OVERLOAD
case|:
name|priv
operator|->
name|metacommandsUsed
operator|.
name|insert
argument_list|(
name|cmdStr
argument_list|)
expr_stmt|;
name|p1
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isBlankLine
argument_list|()
condition|)
name|p1
operator|=
name|getRestOfLine
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|ParaLeft
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"This function overloads "
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ParaRight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|ParaLeft
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
literal|"This is an overloaded function."
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ParaRight
argument_list|)
expr_stmt|;
name|p1
operator|=
name|getMetaCommandArgument
argument_list|(
name|cmdStr
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|metaCommandMap
index|[
name|cmdStr
index|]
operator|.
name|append
argument_list|(
name|ArgLocPair
argument_list|(
name|p1
argument_list|,
name|location
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT_A_CMD
case|:
if|if
condition|(
name|metaCommandSet
operator|.
name|contains
argument_list|(
name|cmdStr
argument_list|)
condition|)
block|{
name|priv
operator|->
name|metacommandsUsed
operator|.
name|insert
argument_list|(
name|cmdStr
argument_list|)
expr_stmt|;
name|QString
name|arg
init|=
name|getMetaCommandArgument
argument_list|(
name|cmdStr
argument_list|)
decl_stmt|;
name|priv
operator|->
name|metaCommandMap
index|[
name|cmdStr
index|]
operator|.
name|append
argument_list|(
name|ArgLocPair
argument_list|(
name|arg
argument_list|,
name|location
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|possibleTopics
operator|.
name|contains
argument_list|(
name|cmdStr
argument_list|)
condition|)
block|{
name|priv
operator|->
name|topics
operator|.
name|append
argument_list|(
name|Topic
argument_list|(
name|cmdStr
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|macroHash
argument_list|()
operator|->
name|contains
argument_list|(
name|cmdStr
argument_list|)
condition|)
block|{
specifier|const
name|Macro
modifier|&
name|macro
init|=
name|macroHash
argument_list|()
operator|->
name|value
argument_list|(
name|cmdStr
argument_list|)
decl_stmt|;
name|int
name|numPendingFi
init|=
literal|0
decl_stmt|;
name|QStringMap
operator|::
name|ConstIterator
name|d
decl_stmt|;
name|d
operator|=
name|macro
operator|.
name|otherDefs
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|d
operator|!=
name|macro
operator|.
name|otherDefs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|FormatIf
argument_list|,
name|d
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|expandMacro
argument_list|(
name|cmdStr
argument_list|,
operator|*
name|d
argument_list|,
name|macro
operator|.
name|numParams
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|macro
operator|.
name|otherDefs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|FormatEndif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|FormatElse
argument_list|)
expr_stmt|;
name|numPendingFi
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|numPendingFi
operator|--
operator|>
literal|0
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|FormatEndif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro
operator|.
name|defaultDef
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|macro
operator|.
name|otherDefs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|macro
operator|.
name|defaultDefLocation
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Macro cannot have both "
literal|"format-specific and qdoc- "
literal|"syntax definitions"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|push
argument_list|(
name|macro
operator|.
name|defaultDefLocation
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
name|in
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|expandMacroToString
argument_list|(
name|cmdStr
argument_list|,
name|macro
operator|.
name|defaultDef
argument_list|,
name|macro
operator|.
name|numParams
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
name|openedInputs
operator|.
name|push
argument_list|(
name|pos
operator|+
name|macro
operator|.
name|defaultDef
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unknown command '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdStr
argument_list|)
argument_list|,
name|detailsUnknownCommand
argument_list|(
name|metaCommandSet
argument_list|,
name|cmdStr
argument_list|)
argument_list|)
expr_stmt|;
name|enterPara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|UnknownCommand
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|'{'
case|:
name|enterPara
argument_list|()
expr_stmt|;
name|appendChar
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|braceDepth
operator|++
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
block|{
name|braceDepth
operator|--
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
operator|::
name|Iterator
name|f
init|=
name|pendingFormats
operator|.
name|find
argument_list|(
name|braceDepth
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|pendingFormats
operator|.
name|end
argument_list|()
condition|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|appendChar
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
name|ATOM_FORMATTING_INDEX
condition|)
block|{
if|if
condition|(
name|indexStartedPara
condition|)
name|skipAllSpaces
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|f
operator|==
name|ATOM_FORMATTING_LINK
condition|)
block|{
comment|// hack for C++ to support links like
comment|// \l{QString::}{count()}
if|if
condition|(
name|currentLinkAtom
operator|&&
name|currentLinkAtom
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|QString
name|suffix
init|=
name|Text
operator|::
name|subText
argument_list|(
name|currentLinkAtom
argument_list|,
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|currentLinkAtom
operator|->
name|appendString
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
name|currentLinkAtom
operator|=
literal|0
expr_stmt|;
block|}
name|pendingFormats
operator|.
name|erase
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
block|{
name|bool
name|newWord
decl_stmt|;
switch|switch
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Atom
operator|::
name|ParaLeft
case|:
name|newWord
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|newWord
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|paraState
operator|==
name|OutsideParagraph
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
operator|++
name|pos
expr_stmt|;
name|newWord
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|newWord
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|paraState
operator|==
name|InSingleLineParagraph
operator|||
name|isBlankLine
argument_list|()
operator|)
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|newWord
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|appendChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|newWord
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|newWord
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newWord
condition|)
block|{
name|int
name|startPos
init|=
name|pos
decl_stmt|;
name|int
name|numInternalUppercase
init|=
literal|0
decl_stmt|;
name|int
name|numLowercase
init|=
literal|0
decl_stmt|;
name|int
name|numStrangeSymbols
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
condition|)
block|{
name|unsigned
name|char
name|latin1Ch
init|=
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|latin1Ch
argument_list|)
condition|)
block|{
operator|++
name|numLowercase
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|latin1Ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|startPos
condition|)
operator|++
name|numInternalUppercase
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|latin1Ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|startPos
condition|)
block|{
operator|++
name|pos
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|latin1Ch
operator|==
literal|'_'
operator|||
name|latin1Ch
operator|==
literal|'@'
condition|)
block|{
operator|++
name|numStrangeSymbols
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|latin1Ch
operator|==
literal|':'
operator|&&
name|pos
operator|<
name|len
operator|-
literal|1
operator|&&
name|in
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
operator|++
name|numStrangeSymbols
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|latin1Ch
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|startPos
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|len
operator|-
literal|1
operator|&&
name|in
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
operator|++
name|numStrangeSymbols
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// ### handle functions with signatures
comment|// and function calls
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|pos
operator|==
name|startPos
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|appendChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
else|else
block|{
name|QString
name|word
init|=
name|in
operator|.
name|mid
argument_list|(
name|startPos
argument_list|,
name|pos
operator|-
name|startPos
argument_list|)
decl_stmt|;
comment|// is word a C++ symbol or an English word?
if|if
condition|(
operator|(
name|numInternalUppercase
operator|>=
literal|1
operator|&&
name|numLowercase
operator|>=
literal|2
operator|)
operator|||
name|numStrangeSymbols
operator|>=
literal|1
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|AutoLink
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendWord
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|leaveValueList
argument_list|()
expr_stmt|;
comment|// for compatibility
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|==
name|CMD_LEGALESE
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|LegaleseRight
argument_list|)
expr_stmt|;
name|openedCommands
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|openedCommands
operator|.
name|top
argument_list|()
operator|!=
name|CMD_OMIT
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|endCmdName
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|preprocessorSkipping
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_ENDIF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentSection
operator|>
name|Doc
operator|::
name|NoSection
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|SectionRight
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|currentSection
argument_list|)
argument_list|)
expr_stmt|;
name|currentSection
operator|=
name|Doc
operator|::
name|NoSection
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|->
name|extra
operator|&&
name|priv
operator|->
name|extra
operator|->
name|granularity
operator|<
name|priv
operator|->
name|extra
operator|->
name|section
condition|)
name|priv
operator|->
name|extra
operator|->
name|granularity
operator|=
name|priv
operator|->
name|extra
operator|->
name|section
expr_stmt|;
name|priv
operator|->
name|text
operator|.
name|stripFirstAtom
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the current location.  */
end_comment
begin_function
DECL|function|location
name|Location
modifier|&
name|DocParser
operator|::
name|location
parameter_list|()
block|{
while|while
condition|(
operator|!
name|openedInputs
operator|.
name|isEmpty
argument_list|()
operator|&&
name|openedInputs
operator|.
name|top
argument_list|()
operator|<=
name|pos
condition|)
block|{
name|cachedLoc
operator|.
name|pop
argument_list|()
expr_stmt|;
name|cachedPos
operator|=
name|openedInputs
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|cachedPos
operator|<
name|pos
condition|)
name|cachedLoc
operator|.
name|advance
argument_list|(
name|in
operator|.
name|at
argument_list|(
name|cachedPos
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cachedLoc
return|;
block|}
end_function
begin_function
DECL|function|detailsUnknownCommand
name|QString
name|DocParser
operator|::
name|detailsUnknownCommand
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|commandSet
init|=
name|metaCommandSet
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cmds
index|[
name|i
index|]
operator|.
name|english
operator|!=
literal|0
condition|)
block|{
name|commandSet
operator|.
name|insert
argument_list|(
operator|*
name|cmds
index|[
name|i
index|]
operator|.
name|alias
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|aliasMap
argument_list|()
operator|->
name|contains
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|tr
argument_list|(
literal|"The command '\\%1' was renamed '\\%2' by the configuration"
literal|" file. Use the new name."
argument_list|)
operator|.
name|arg
argument_list|(
name|str
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
operator|*
name|aliasMap
argument_list|()
operator|)
index|[
name|str
index|]
argument_list|)
return|;
name|QString
name|best
init|=
name|nearestName
argument_list|(
name|str
argument_list|,
name|commandSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|best
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|tr
argument_list|(
literal|"Maybe you meant '\\%1'?"
argument_list|)
operator|.
name|arg
argument_list|(
name|best
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|insertBaseName
name|void
name|DocParser
operator|::
name|insertBaseName
parameter_list|(
specifier|const
name|QString
modifier|&
name|baseName
parameter_list|)
block|{
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentSection
operator|==
name|priv
operator|->
name|extra
operator|->
name|section
condition|)
block|{
name|priv
operator|->
name|extra
operator|->
name|baseName
operator|=
name|baseName
expr_stmt|;
block|}
else|else
block|{
name|Atom
modifier|*
name|atom
init|=
name|priv
operator|->
name|text
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
name|Atom
modifier|*
name|sectionLeft
init|=
literal|0
decl_stmt|;
name|int
name|delta
init|=
name|currentSection
operator|-
name|priv
operator|->
name|extra
operator|->
name|section
decl_stmt|;
while|while
condition|(
name|atom
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
operator|&&
name|atom
operator|->
name|string
argument_list|()
operator|.
name|toInt
argument_list|()
operator|==
name|delta
condition|)
name|sectionLeft
operator|=
name|atom
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sectionLeft
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
operator|new
name|Atom
argument_list|(
name|sectionLeft
argument_list|,
name|Atom
operator|::
name|BaseName
argument_list|,
name|baseName
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|insertTarget
name|void
name|DocParser
operator|::
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|bool
name|keyword
parameter_list|)
block|{
if|if
condition|(
name|targetMap
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Duplicate target name '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|targetMap
index|[
name|target
index|]
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"(The previous occurrence is here)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targetMap
operator|.
name|insert
argument_list|(
name|target
argument_list|,
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|keyword
condition|)
name|priv
operator|->
name|extra
operator|->
name|keywords
operator|.
name|append
argument_list|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|priv
operator|->
name|extra
operator|->
name|targets
operator|.
name|append
argument_list|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|include
name|void
name|DocParser
operator|::
name|include
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|)
block|{
if|if
condition|(
name|location
argument_list|()
operator|.
name|depth
argument_list|()
operator|>
literal|16
condition|)
name|location
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Too many nested '\\%1's"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_INCLUDE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|userFriendlyFilePath
decl_stmt|;
comment|// ### use current directory?
name|QString
name|filePath
init|=
name|Config
operator|::
name|findFile
argument_list|(
name|location
argument_list|()
argument_list|,
name|sourceFiles
argument_list|,
name|sourceDirs
argument_list|,
name|fileName
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find qdoc include file '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QFile
name|inFile
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot open qdoc include file '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|userFriendlyFilePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|push
argument_list|(
name|userFriendlyFilePath
argument_list|)
expr_stmt|;
name|QTextStream
name|inStream
argument_list|(
operator|&
name|inFile
argument_list|)
decl_stmt|;
name|QString
name|includedStuff
init|=
name|inStream
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|inFile
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|identifier
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|in
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|includedStuff
argument_list|)
expr_stmt|;
name|len
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
name|openedInputs
operator|.
name|push
argument_list|(
name|pos
operator|+
name|includedStuff
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|lineBuffer
init|=
name|includedStuff
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|startLine
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|lineBuffer
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|lineBuffer
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
literal|"//!"
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineBuffer
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|identifier
argument_list|)
condition|)
block|{
name|startLine
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|startLine
operator|<
literal|0
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find '%1' in '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|identifier
argument_list|)
operator|.
name|arg
argument_list|(
name|userFriendlyFilePath
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|result
decl_stmt|;
name|i
operator|=
name|startLine
expr_stmt|;
do|do
block|{
if|if
condition|(
name|lineBuffer
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
literal|"//!"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|lineBuffer
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|lineBuffer
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|identifier
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
else|else
name|result
operator|+=
name|lineBuffer
index|[
name|i
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|lineBuffer
operator|.
name|size
argument_list|()
condition|)
do|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Empty qdoc snippet '%1' in '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|identifier
argument_list|)
operator|.
name|arg
argument_list|(
name|userFriendlyFilePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|len
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
name|openedInputs
operator|.
name|push
argument_list|(
name|pos
operator|+
name|result
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|startFormat
name|void
name|DocParser
operator|::
name|startFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|enterPara
argument_list|()
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|pendingFormats
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|pendingFormats
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
name|format
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot nest '\\%1' commands"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|f
expr_stmt|;
block|}
name|append
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
name|pendingFormats
operator|.
name|insert
argument_list|(
name|braceDepth
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|++
name|braceDepth
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
else|else
block|{
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|ATOM_FORMATTING_INDEX
operator|&&
name|indexStartedPara
condition|)
block|{
name|skipAllSpaces
argument_list|()
expr_stmt|;
name|indexStartedPara
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|openCommand
name|bool
name|DocParser
operator|::
name|openCommand
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
name|int
name|outer
init|=
name|openedCommands
operator|.
name|top
argument_list|()
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|CMD_LINK
condition|)
block|{
if|if
condition|(
name|outer
operator|==
name|CMD_LIST
condition|)
block|{
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_FOOTNOTE
operator|||
name|cmd
operator|==
name|CMD_LIST
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_ABSTRACT
condition|)
block|{
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_LIST
operator|||
name|cmd
operator|==
name|CMD_QUOTATION
operator|||
name|cmd
operator|==
name|CMD_TABLE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_SIDEBAR
condition|)
block|{
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_LIST
operator|||
name|cmd
operator|==
name|CMD_QUOTATION
operator|||
name|cmd
operator|==
name|CMD_SIDEBAR
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_QUOTATION
condition|)
block|{
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_LIST
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_TABLE
condition|)
block|{
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_LIST
operator|||
name|cmd
operator|==
name|CMD_FOOTNOTE
operator|||
name|cmd
operator|==
name|CMD_QUOTATION
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_FOOTNOTE
operator|||
name|outer
operator|==
name|CMD_LINK
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_TOPICREF
condition|)
name|ok
operator|=
operator|(
name|cmd
operator|==
name|CMD_TOPICREF
operator|||
name|cmd
operator|==
name|CMD_MAPREF
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|CMD_MAPREF
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|openedCommands
operator|.
name|push
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Can't use '\\%1' in '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|closeCommand
name|bool
name|DocParser
operator|::
name|closeCommand
parameter_list|(
name|int
name|endCmd
parameter_list|)
block|{
if|if
condition|(
name|endCmdFor
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
operator|==
name|endCmd
operator|&&
name|openedCommands
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|openedCommands
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|bool
name|contains
init|=
literal|false
decl_stmt|;
name|QStack
argument_list|<
name|int
argument_list|>
name|opened2
init|=
name|openedCommands
decl_stmt|;
while|while
condition|(
name|opened2
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|endCmdFor
argument_list|(
name|opened2
operator|.
name|top
argument_list|()
argument_list|)
operator|==
name|endCmd
condition|)
block|{
name|contains
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|opened2
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|contains
condition|)
block|{
while|while
condition|(
name|endCmdFor
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
operator|!=
name|endCmd
operator|&&
name|openedCommands
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '\\%1' before '\\%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|endCmdName
argument_list|(
name|openedCommands
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|endCmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|openedCommands
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|endCmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|startSection
name|void
name|DocParser
operator|::
name|startSection
parameter_list|(
name|Doc
operator|::
name|Sections
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|leaveValueList
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentSection
operator|==
name|Doc
operator|::
name|NoSection
condition|)
block|{
name|currentSection
operator|=
call|(
name|Doc
operator|::
name|Sections
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
name|priv
operator|->
name|extra
operator|->
name|section
operator|=
name|currentSection
expr_stmt|;
block|}
else|else
name|endSection
argument_list|(
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SectionLeft
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
name|priv
operator|->
name|extra
operator|->
name|tableOfContents
operator|.
name|append
argument_list|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
argument_list|)
expr_stmt|;
name|priv
operator|->
name|extra
operator|->
name|tableOfContentsLevels
operator|.
name|append
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|enterPara
argument_list|(
name|Atom
operator|::
name|SectionHeadingLeft
argument_list|,
name|Atom
operator|::
name|SectionHeadingRight
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|currentSection
operator|=
name|unit
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endSection
name|void
name|DocParser
operator|::
name|endSection
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
comment|// (int unit, int endCmd)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|SectionRight
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|currentSection
argument_list|)
argument_list|)
expr_stmt|;
name|currentSection
operator|=
operator|(
name|Doc
operator|::
name|NoSection
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseAlso
name|void
name|DocParser
operator|::
name|parseAlso
parameter_list|()
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
operator|&&
name|in
index|[
name|pos
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|QString
name|target
decl_stmt|;
name|QString
name|str
decl_stmt|;
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|==
literal|'{'
condition|)
block|{
name|target
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|==
literal|'{'
condition|)
block|{
name|str
operator|=
name|getArgument
argument_list|()
expr_stmt|;
comment|// hack for C++ to support links like \l{QString::}{count()}
if|if
condition|(
name|target
operator|.
name|endsWith
argument_list|(
literal|"::"
argument_list|)
condition|)
name|target
operator|+=
name|str
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|target
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QDOC2_COMPAT
block|}
elseif|else
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|==
literal|'\\'
operator|&&
name|in
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
literal|5
argument_list|)
operator|==
literal|"\\link"
condition|)
block|{
name|pos
operator|+=
literal|6
expr_stmt|;
name|target
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|int
name|endPos
init|=
name|in
operator|.
name|indexOf
argument_list|(
literal|"\\endlink"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|endPos
operator|!=
operator|-
literal|1
condition|)
block|{
name|str
operator|=
name|in
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|endPos
operator|-
name|pos
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|pos
operator|=
name|endPos
operator|+
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|target
operator|=
name|getArgument
argument_list|()
expr_stmt|;
name|str
operator|=
name|cleanLink
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|Text
name|also
decl_stmt|;
name|also
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|Link
argument_list|,
name|target
argument_list|)
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingLeft
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
operator|<<
name|str
operator|<<
name|Atom
argument_list|(
name|Atom
operator|::
name|FormattingRight
argument_list|,
name|ATOM_FORMATTING_LINK
argument_list|)
expr_stmt|;
name|priv
operator|->
name|addAlso
argument_list|(
name|also
argument_list|)
expr_stmt|;
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|len
operator|&&
name|in
index|[
name|pos
index|]
operator|==
literal|','
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing comma in '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|CMD_SA
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|append
name|void
name|DocParser
operator|::
name|append
parameter_list|(
name|Atom
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|Atom
operator|::
name|Type
name|lastType
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lastType
operator|==
name|Atom
operator|::
name|Code
operator|)
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
condition|)
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
name|priv
operator|->
name|text
operator|<<
name|Atom
argument_list|(
name|type
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append
name|void
name|DocParser
operator|::
name|append
parameter_list|(
name|Atom
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|p1
parameter_list|,
specifier|const
name|QString
modifier|&
name|p2
parameter_list|)
block|{
name|Atom
operator|::
name|Type
name|lastType
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lastType
operator|==
name|Atom
operator|::
name|Code
operator|)
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
condition|)
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
name|priv
operator|->
name|text
operator|<<
name|Atom
argument_list|(
name|type
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendChar
name|void
name|DocParser
operator|::
name|appendChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|String
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|)
expr_stmt|;
name|Atom
modifier|*
name|atom
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|atom
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|atom
operator|->
name|appendChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|atom
operator|->
name|appendChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendWord
name|void
name|DocParser
operator|::
name|appendWord
parameter_list|(
specifier|const
name|QString
modifier|&
name|word
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|String
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|appendString
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendToCode
name|void
name|DocParser
operator|::
name|appendToCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|)
block|{
name|Atom
operator|::
name|Type
name|lastType
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastType
operator|!=
name|Atom
operator|::
name|Qml
operator|&&
name|lastType
operator|!=
name|Atom
operator|::
name|Code
operator|&&
name|lastType
operator|!=
name|Atom
operator|::
name|JavaScript
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|Qml
argument_list|)
expr_stmt|;
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|appendString
argument_list|(
name|markedCode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendToCode
name|void
name|DocParser
operator|::
name|appendToCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|markedCode
parameter_list|,
name|Atom
operator|::
name|Type
name|defaultType
parameter_list|)
block|{
name|Atom
operator|::
name|Type
name|lastType
init|=
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastType
operator|!=
name|Atom
operator|::
name|Qml
operator|&&
name|lastType
operator|!=
name|Atom
operator|::
name|Code
operator|&&
name|lastType
operator|!=
name|Atom
operator|::
name|JavaScript
condition|)
name|append
argument_list|(
name|defaultType
argument_list|,
name|markedCode
argument_list|)
expr_stmt|;
else|else
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|appendString
argument_list|(
name|markedCode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startNewPara
name|void
name|DocParser
operator|::
name|startNewPara
parameter_list|()
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|enterPara
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|enterPara
name|void
name|DocParser
operator|::
name|enterPara
parameter_list|(
name|Atom
operator|::
name|Type
name|leftType
parameter_list|,
name|Atom
operator|::
name|Type
name|rightType
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
if|if
condition|(
name|paraState
operator|==
name|OutsideParagraph
condition|)
block|{
if|if
condition|(
operator|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|ListItemLeft
operator|)
operator|&&
operator|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|DivLeft
operator|)
condition|)
block|{
name|leaveValueList
argument_list|()
expr_stmt|;
block|}
name|append
argument_list|(
name|leftType
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|indexStartedPara
operator|=
literal|false
expr_stmt|;
name|pendingParaLeftType
operator|=
name|leftType
expr_stmt|;
name|pendingParaRightType
operator|=
name|rightType
expr_stmt|;
name|pendingParaString
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|leftType
operator|==
name|Atom
operator|::
name|SectionHeadingLeft
condition|)
block|{
name|paraState
operator|=
name|InSingleLineParagraph
expr_stmt|;
block|}
else|else
block|{
name|paraState
operator|=
name|InMultiLineParagraph
expr_stmt|;
block|}
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|leavePara
name|void
name|DocParser
operator|::
name|leavePara
parameter_list|()
block|{
if|if
condition|(
name|paraState
operator|!=
name|OutsideParagraph
condition|)
block|{
if|if
condition|(
operator|!
name|pendingFormats
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '}'"
argument_list|)
argument_list|)
expr_stmt|;
name|pendingFormats
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|pendingParaLeftType
condition|)
block|{
name|priv
operator|->
name|text
operator|.
name|stripLastAtom
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
operator|&&
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|string
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
block|{
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|chopString
argument_list|()
expr_stmt|;
block|}
name|append
argument_list|(
name|pendingParaRightType
argument_list|,
name|pendingParaString
argument_list|)
expr_stmt|;
block|}
name|paraState
operator|=
name|OutsideParagraph
expr_stmt|;
name|indexStartedPara
operator|=
literal|false
expr_stmt|;
name|pendingParaRightType
operator|=
name|Atom
operator|::
name|Nop
expr_stmt|;
name|pendingParaString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|leaveValue
name|void
name|DocParser
operator|::
name|leaveValue
parameter_list|()
block|{
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
name|openedLists
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|openedLists
operator|.
name|push
argument_list|(
name|OpenedList
argument_list|(
name|OpenedList
operator|::
name|Value
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListLeft
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Nop
condition|)
name|priv
operator|->
name|text
operator|.
name|stripLastAtom
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|leaveValueList
name|void
name|DocParser
operator|::
name|leaveValueList
parameter_list|()
block|{
name|leavePara
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|openedLists
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|openedLists
operator|.
name|top
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|OpenedList
operator|::
name|Value
operator|)
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|text
operator|.
name|lastAtom
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Nop
condition|)
name|priv
operator|->
name|text
operator|.
name|stripLastAtom
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListItemRight
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|ListRight
argument_list|,
name|ATOM_LIST_VALUE
argument_list|)
expr_stmt|;
name|openedLists
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|leaveTableRow
name|void
name|DocParser
operator|::
name|leaveTableRow
parameter_list|()
block|{
if|if
condition|(
name|inTableItem
condition|)
block|{
name|leavePara
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|Atom
operator|::
name|TableItemRight
argument_list|)
expr_stmt|;
name|inTableItem
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|inTableHeader
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|TableHeaderRight
argument_list|)
expr_stmt|;
name|inTableHeader
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|inTableRow
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|TableRowRight
argument_list|)
expr_stmt|;
name|inTableRow
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|quoteFromFile
name|CodeMarker
modifier|*
name|DocParser
operator|::
name|quoteFromFile
parameter_list|()
block|{
return|return
name|Doc
operator|::
name|quoteFromFile
argument_list|(
name|location
argument_list|()
argument_list|,
name|quoter
argument_list|,
name|getArgument
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|expandMacro
name|void
name|DocParser
operator|::
name|expandMacro
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|def
parameter_list|,
name|int
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|RawString
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|args
decl_stmt|;
name|QString
name|rawString
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|numParams
operator|==
literal|1
operator|||
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|args
operator|<<
name|getArgument
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Macro '\\%1' invoked with too few"
literal|" arguments (expected %2, got %3)"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
operator|.
name|arg
argument_list|(
name|numParams
argument_list|)
operator|.
name|arg
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|def
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|paramNo
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|paramNo
operator|=
name|def
index|[
name|j
index|]
operator|.
name|unicode
argument_list|()
operator|)
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|paramNo
operator|<=
name|numParams
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rawString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|Atom
operator|::
name|RawString
argument_list|,
name|rawString
argument_list|)
expr_stmt|;
name|rawString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|append
argument_list|(
name|Atom
operator|::
name|String
argument_list|,
name|args
index|[
name|paramNo
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rawString
operator|+=
name|def
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rawString
operator|.
name|isEmpty
argument_list|()
condition|)
name|append
argument_list|(
name|Atom
operator|::
name|RawString
argument_list|,
name|rawString
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|expandMacroToString
name|QString
name|DocParser
operator|::
name|expandMacroToString
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|def
parameter_list|,
name|int
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
return|return
name|def
return|;
block|}
else|else
block|{
name|QStringList
name|args
decl_stmt|;
name|QString
name|rawString
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|numParams
operator|==
literal|1
operator|||
name|isLeftBraceAhead
argument_list|()
condition|)
block|{
name|args
operator|<<
name|getArgument
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Macro '\\%1' invoked with too few"
literal|" arguments (expected %2, got %3)"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
operator|.
name|arg
argument_list|(
name|numParams
argument_list|)
operator|.
name|arg
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|def
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|paramNo
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|paramNo
operator|=
name|def
index|[
name|j
index|]
operator|.
name|unicode
argument_list|()
operator|)
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|paramNo
operator|<=
name|numParams
operator|)
condition|)
block|{
name|rawString
operator|+=
name|args
index|[
name|paramNo
operator|-
literal|1
index|]
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rawString
operator|+=
name|def
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
block|}
return|return
name|rawString
return|;
block|}
block|}
end_function
begin_function
DECL|function|getSectioningUnit
name|Doc
operator|::
name|Sections
name|DocParser
operator|::
name|getSectioningUnit
parameter_list|()
block|{
name|QString
name|name
init|=
name|getOptionalArgument
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|"part"
condition|)
block|{
return|return
name|Doc
operator|::
name|Part
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"chapter"
condition|)
block|{
return|return
name|Doc
operator|::
name|Chapter
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"section1"
condition|)
block|{
return|return
name|Doc
operator|::
name|Section1
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"section2"
condition|)
block|{
return|return
name|Doc
operator|::
name|Section2
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"section3"
condition|)
block|{
return|return
name|Doc
operator|::
name|Section3
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
literal|"section4"
condition|)
block|{
return|return
name|Doc
operator|::
name|Section4
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Doc
operator|::
name|NoSection
return|;
block|}
else|else
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Invalid section '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Doc
operator|::
name|NoSection
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Gets an argument that is enclosed in braces and returns it   without the enclosing braces. On entry, the current character   is the left brace. On exit, the current character is the one   that comes afterr the right brace.    If \a verbatim is true, extra whitespace is retained in the   returned string. Otherwise, extr whitespace is removed.  */
end_comment
begin_function
DECL|function|getBracedArgument
name|QString
name|DocParser
operator|::
name|getBracedArgument
parameter_list|(
name|bool
name|verbatim
parameter_list|)
block|{
name|QString
name|arg
decl_stmt|;
name|int
name|delimDepth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pos
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
operator|&&
name|in
index|[
name|pos
index|]
operator|==
literal|'{'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|pos
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
operator|&&
name|delimDepth
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'{'
case|:
name|delimDepth
operator|++
expr_stmt|;
name|arg
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|delimDepth
operator|--
expr_stmt|;
if|if
condition|(
name|delimDepth
operator|>=
literal|0
condition|)
name|arg
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|verbatim
condition|)
block|{
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
break|break;
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|skipAllSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delimDepth
operator|>
literal|0
condition|)
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '}'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function
begin_comment
comment|/*!   Typically, an argument ends at the next white-space. However,   braces can be used to group words:    {a few words}    Also, opening and closing parentheses have to match. Thus,    printf("%d\n", x)    is an argument too, although it contains spaces. Finally,   trailing punctuation is not included in an argument, nor is 's. */
end_comment
begin_function
DECL|function|getArgument
name|QString
name|DocParser
operator|::
name|getArgument
parameter_list|(
name|bool
name|verbatim
parameter_list|)
block|{
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
name|int
name|delimDepth
init|=
literal|0
decl_stmt|;
name|int
name|startPos
init|=
name|pos
decl_stmt|;
name|QString
name|arg
init|=
name|getBracedArgument
argument_list|(
name|verbatim
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
while|while
condition|(
operator|(
name|pos
operator|<
name|in
operator|.
name|length
argument_list|()
operator|)
operator|&&
operator|(
operator|(
name|delimDepth
operator|>
literal|0
operator|)
operator|||
operator|(
operator|(
name|delimDepth
operator|==
literal|0
operator|)
operator|&&
operator|!
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|'['
case|:
case|case
literal|'{'
case|:
name|delimDepth
operator|++
expr_stmt|;
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
case|case
literal|']'
case|:
case|case
literal|'}'
case|:
name|delimDepth
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|startPos
operator|||
name|delimDepth
operator|>=
literal|0
condition|)
block|{
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|verbatim
condition|)
block|{
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
break|break;
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|skipAllSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
name|arg
operator|+=
name|in
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|)
operator|&&
operator|(
name|QString
argument_list|(
literal|".,:;!?"
argument_list|)
operator|.
name|indexOf
argument_list|(
name|in
index|[
name|pos
operator|-
literal|1
index|]
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|!
name|arg
operator|.
name|endsWith
argument_list|(
literal|"..."
argument_list|)
condition|)
block|{
name|arg
operator|.
name|truncate
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|in
operator|.
name|mid
argument_list|(
name|pos
operator|-
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|"'s"
condition|)
block|{
name|arg
operator|.
name|truncate
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|-=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|arg
operator|.
name|simplified
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|getOptionalArgument
name|QString
name|DocParser
operator|::
name|getOptionalArgument
parameter_list|()
block|{
name|skipSpacesOrOneEndl
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
operator|&&
name|in
index|[
name|pos
index|]
operator|==
literal|'\\'
operator|&&
name|in
index|[
name|pos
operator|+
literal|1
index|]
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|getArgument
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|getRestOfLine
name|QString
name|DocParser
operator|::
name|getRestOfLine
parameter_list|()
block|{
name|QString
name|t
decl_stmt|;
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
name|bool
name|trailingSlash
init|=
literal|false
decl_stmt|;
do|do
block|{
name|int
name|begin
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|in
operator|.
name|size
argument_list|()
operator|&&
name|in
index|[
name|pos
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|in
index|[
name|pos
index|]
operator|==
literal|'\\'
operator|&&
operator|!
name|trailingSlash
condition|)
block|{
name|trailingSlash
operator|=
literal|true
expr_stmt|;
operator|++
name|pos
expr_stmt|;
while|while
condition|(
operator|(
name|pos
operator|<
name|in
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
operator|&&
operator|(
name|in
index|[
name|pos
index|]
operator|!=
literal|'\n'
operator|)
condition|)
operator|++
name|pos
expr_stmt|;
block|}
else|else
block|{
name|trailingSlash
operator|=
literal|false
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
name|t
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|t
operator|+=
name|in
operator|.
name|mid
argument_list|(
name|begin
argument_list|,
name|pos
operator|-
name|begin
argument_list|)
operator|.
name|simplified
argument_list|()
expr_stmt|;
if|if
condition|(
name|trailingSlash
condition|)
block|{
name|t
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|in
operator|.
name|size
argument_list|()
condition|)
operator|++
name|pos
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|<
name|in
operator|.
name|size
argument_list|()
operator|&&
name|trailingSlash
condition|)
do|;
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   The metacommand argument is normally the remaining text to   the right of the metacommand itself. The extra blanks are   stripped and the argument string is returned.  */
end_comment
begin_function
DECL|function|getMetaCommandArgument
name|QString
name|DocParser
operator|::
name|getMetaCommandArgument
parameter_list|(
specifier|const
name|QString
modifier|&
name|cmdStr
parameter_list|)
block|{
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
name|int
name|begin
init|=
name|pos
decl_stmt|;
name|int
name|parenDepth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|in
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|in
index|[
name|pos
index|]
operator|!=
literal|'\n'
operator|||
name|parenDepth
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'('
condition|)
operator|++
name|parenDepth
expr_stmt|;
elseif|else
if|if
condition|(
name|in
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|')'
condition|)
operator|--
name|parenDepth
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|in
operator|.
name|size
argument_list|()
operator|&&
name|parenDepth
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|begin
expr_stmt|;
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Unbalanced parentheses in '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QString
name|t
init|=
name|in
operator|.
name|mid
argument_list|(
name|begin
argument_list|,
name|pos
operator|-
name|begin
argument_list|)
operator|.
name|simplified
argument_list|()
decl_stmt|;
name|skipSpacesOnLine
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|getUntilEnd
name|QString
name|DocParser
operator|::
name|getUntilEnd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
name|int
name|endCmd
init|=
name|endCmdFor
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|QRegExp
name|rx
argument_list|(
literal|"\\\\"
operator|+
name|cmdName
argument_list|(
name|endCmd
argument_list|)
operator|+
literal|"\\b"
argument_list|)
decl_stmt|;
name|QString
name|t
decl_stmt|;
name|int
name|end
init|=
name|rx
operator|.
name|indexIn
argument_list|(
name|in
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
block|{
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Missing '\\%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmdName
argument_list|(
name|endCmd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|in
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
name|end
operator|+
name|rx
operator|.
name|matchedLength
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|getCode
name|QString
name|DocParser
operator|::
name|getCode
parameter_list|(
name|int
name|cmd
parameter_list|,
name|CodeMarker
modifier|*
name|marker
parameter_list|)
block|{
name|QString
name|code
init|=
name|untabifyEtc
argument_list|(
name|getUntilEnd
argument_list|(
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|indent
init|=
name|indentLevel
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|indent
operator|<
name|minIndent
condition|)
name|minIndent
operator|=
name|indent
expr_stmt|;
name|code
operator|=
name|unindent
argument_list|(
name|minIndent
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|marker
condition|)
name|marker
operator|=
name|CodeMarker
operator|::
name|markerForCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|marker
operator|->
name|markedUpCode
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|location
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Was used only for generating doxygen output.  */
end_comment
begin_function
DECL|function|getUnmarkedCode
name|QString
name|DocParser
operator|::
name|getUnmarkedCode
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
name|QString
name|code
init|=
name|getUntilEnd
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_function
DECL|function|isBlankLine
name|bool
name|DocParser
operator|::
name|isBlankLine
parameter_list|()
block|{
name|int
name|i
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|in
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|in
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
return|return
literal|true
return|;
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isLeftBraceAhead
name|bool
name|DocParser
operator|::
name|isLeftBraceAhead
parameter_list|()
block|{
name|int
name|numEndl
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|in
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
operator|&&
name|numEndl
operator|<
literal|2
condition|)
block|{
comment|// ### bug with '\\'
if|if
condition|(
name|in
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|numEndl
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|numEndl
operator|<
literal|2
operator|&&
name|i
operator|<
name|len
operator|&&
name|in
index|[
name|i
index|]
operator|==
literal|'{'
return|;
block|}
end_function
begin_comment
comment|/*!   Skips to the next non-space character or EOL.  */
end_comment
begin_function
DECL|function|skipSpacesOnLine
name|void
name|DocParser
operator|::
name|skipSpacesOnLine
parameter_list|()
block|{
while|while
condition|(
operator|(
name|pos
operator|<
name|in
operator|.
name|length
argument_list|()
operator|)
operator|&&
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
operator|&&
operator|(
name|in
index|[
name|pos
index|]
operator|.
name|unicode
argument_list|()
operator|!=
literal|'\n'
operator|)
condition|)
operator|++
name|pos
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Skips spaces and on EOL.  */
end_comment
begin_function
DECL|function|skipSpacesOrOneEndl
name|void
name|DocParser
operator|::
name|skipSpacesOrOneEndl
parameter_list|()
block|{
name|int
name|firstEndl
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|pos
operator|<
operator|(
name|int
operator|)
name|in
operator|.
name|length
argument_list|()
operator|&&
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|QChar
name|ch
init|=
name|in
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|firstEndl
operator|==
operator|-
literal|1
condition|)
block|{
name|firstEndl
operator|=
name|pos
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|firstEndl
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|skipAllSpaces
name|void
name|DocParser
operator|::
name|skipAllSpaces
parameter_list|()
block|{
while|while
condition|(
name|pos
operator|<
name|len
operator|&&
name|in
index|[
name|pos
index|]
operator|.
name|isSpace
argument_list|()
condition|)
name|pos
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|skipToNextPreprocessorCommand
name|void
name|DocParser
operator|::
name|skipToNextPreprocessorCommand
parameter_list|()
block|{
name|QRegExp
name|rx
argument_list|(
literal|"\\\\(?:"
operator|+
name|cmdName
argument_list|(
name|CMD_IF
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|+
name|cmdName
argument_list|(
name|CMD_ELSE
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|+
name|cmdName
argument_list|(
name|CMD_ENDIF
argument_list|)
operator|+
literal|")\\b"
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|rx
operator|.
name|indexIn
argument_list|(
name|in
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// ### + 1 necessary?
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
name|pos
operator|=
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
else|else
name|pos
operator|=
name|end
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endCmdFor
name|int
name|DocParser
operator|::
name|endCmdFor
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_ABSTRACT
case|:
return|return
name|CMD_ENDABSTRACT
return|;
case|case
name|CMD_BADCODE
case|:
return|return
name|CMD_ENDCODE
return|;
case|case
name|CMD_CHAPTER
case|:
return|return
name|CMD_ENDCHAPTER
return|;
case|case
name|CMD_CODE
case|:
return|return
name|CMD_ENDCODE
return|;
case|case
name|CMD_DIV
case|:
return|return
name|CMD_ENDDIV
return|;
case|case
name|CMD_QML
case|:
return|return
name|CMD_ENDQML
return|;
case|case
name|CMD_QMLTEXT
case|:
return|return
name|CMD_ENDQMLTEXT
return|;
case|case
name|CMD_JS
case|:
return|return
name|CMD_ENDJS
return|;
case|case
name|CMD_FOOTNOTE
case|:
return|return
name|CMD_ENDFOOTNOTE
return|;
case|case
name|CMD_LEGALESE
case|:
return|return
name|CMD_ENDLEGALESE
return|;
case|case
name|CMD_LINK
case|:
return|return
name|CMD_ENDLINK
return|;
case|case
name|CMD_LIST
case|:
return|return
name|CMD_ENDLIST
return|;
case|case
name|CMD_NEWCODE
case|:
return|return
name|CMD_ENDCODE
return|;
case|case
name|CMD_OLDCODE
case|:
return|return
name|CMD_NEWCODE
return|;
case|case
name|CMD_OMIT
case|:
return|return
name|CMD_ENDOMIT
return|;
case|case
name|CMD_PART
case|:
return|return
name|CMD_ENDPART
return|;
case|case
name|CMD_QUOTATION
case|:
return|return
name|CMD_ENDQUOTATION
return|;
case|case
name|CMD_RAW
case|:
return|return
name|CMD_ENDRAW
return|;
case|case
name|CMD_SECTION1
case|:
return|return
name|CMD_ENDSECTION1
return|;
case|case
name|CMD_SECTION2
case|:
return|return
name|CMD_ENDSECTION2
return|;
case|case
name|CMD_SECTION3
case|:
return|return
name|CMD_ENDSECTION3
return|;
case|case
name|CMD_SECTION4
case|:
return|return
name|CMD_ENDSECTION4
return|;
case|case
name|CMD_SIDEBAR
case|:
return|return
name|CMD_ENDSIDEBAR
return|;
case|case
name|CMD_TABLE
case|:
return|return
name|CMD_ENDTABLE
return|;
case|case
name|CMD_TOPICREF
case|:
return|return
name|CMD_ENDTOPICREF
return|;
case|case
name|CMD_MAPREF
case|:
return|return
name|CMD_ENDMAPREF
return|;
default|default:
return|return
name|cmd
return|;
block|}
block|}
end_function
begin_function
DECL|function|cmdName
name|QString
name|DocParser
operator|::
name|cmdName
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|*
name|cmds
index|[
name|cmd
index|]
operator|.
name|alias
return|;
block|}
end_function
begin_function
DECL|function|endCmdName
name|QString
name|DocParser
operator|::
name|endCmdName
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
name|cmdName
argument_list|(
name|endCmdFor
argument_list|(
name|cmd
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|untabifyEtc
name|QString
name|DocParser
operator|::
name|untabifyEtc
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
condition|)
block|{
name|result
operator|+=
literal|"        "
operator|+
operator|(
name|column
operator|%
name|tabSize
operator|)
expr_stmt|;
name|column
operator|=
operator|(
operator|(
name|column
operator|/
name|tabSize
operator|)
operator|+
literal|1
operator|)
operator|*
name|tabSize
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
while|while
condition|(
name|result
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|result
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|result
operator|+=
name|c
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|result
operator|+=
name|c
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|endsWith
argument_list|(
literal|"\n\n"
argument_list|)
condition|)
name|result
operator|.
name|truncate
argument_list|(
name|result
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|result
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|indentLevel
name|int
name|DocParser
operator|::
name|indentLevel
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|int
name|minIndent
init|=
name|INT_MAX
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|!=
literal|' '
operator|&&
name|column
operator|<
name|minIndent
condition|)
name|minIndent
operator|=
name|column
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
return|return
name|minIndent
return|;
block|}
end_function
begin_function
DECL|function|unindent
name|QString
name|DocParser
operator|::
name|unindent
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
name|str
return|;
name|QString
name|t
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|t
operator|+=
literal|'\n'
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|column
operator|>=
name|level
condition|)
name|t
operator|+=
name|str
index|[
name|i
index|]
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|slashed
name|QString
name|DocParser
operator|::
name|slashed
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|result
init|=
name|str
decl_stmt|;
name|result
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|"\\/"
argument_list|)
expr_stmt|;
return|return
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|result
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|COMMAND_BRIEF
define|#
directive|define
name|COMMAND_BRIEF
value|Doc::alias("brief")
end_define
begin_define
DECL|macro|COMMAND_QMLBRIEF
define|#
directive|define
name|COMMAND_QMLBRIEF
value|Doc::alias("qmlbrief")
end_define
begin_constructor
DECL|function|Doc
name|Doc
operator|::
name|Doc
parameter_list|(
specifier|const
name|Location
modifier|&
name|start_loc
parameter_list|,
specifier|const
name|Location
modifier|&
name|end_loc
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|)
block|{
name|priv
operator|=
operator|new
name|DocPrivate
argument_list|(
name|start_loc
argument_list|,
name|end_loc
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|DocParser
name|parser
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|(
name|source
argument_list|,
name|priv
argument_list|,
name|metaCommandSet
argument_list|,
name|QSet
argument_list|<
name|QString
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Parse the qdoc comment \a source. Build up a list of all the topic   commands found including their arguments.  This constructor is used   when there can be more than one topic command in theqdoc comment.   Normally, there is only one topic command in a qdoc comment, but in   QML documentation, there is the case where the qdoc \e{qmlproperty}   command can appear multiple times in a qdoc comment.  */
end_comment
begin_constructor
DECL|function|Doc
name|Doc
operator|::
name|Doc
parameter_list|(
specifier|const
name|Location
modifier|&
name|start_loc
parameter_list|,
specifier|const
name|Location
modifier|&
name|end_loc
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|metaCommandSet
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|topics
parameter_list|)
block|{
name|priv
operator|=
operator|new
name|DocPrivate
argument_list|(
name|start_loc
argument_list|,
name|end_loc
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|DocParser
name|parser
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|(
name|source
argument_list|,
name|priv
argument_list|,
name|metaCommandSet
argument_list|,
name|topics
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|Doc
name|Doc
operator|::
name|Doc
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|)
member_init_list|:
name|priv
argument_list|(
literal|0
argument_list|)
block|{
name|operator
name|=
parameter_list|(
name|doc
parameter_list|)
function_decl|;
block|}
end_constructor
begin_destructor
DECL|function|~Doc
name|Doc
operator|::
name|~
name|Doc
parameter_list|()
block|{
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|deref
argument_list|()
condition|)
operator|delete
name|priv
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|operator =
name|Doc
modifier|&
name|Doc
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|.
name|priv
condition|)
name|doc
operator|.
name|priv
operator|->
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|deref
argument_list|()
condition|)
operator|delete
name|priv
expr_stmt|;
name|priv
operator|=
name|doc
operator|.
name|priv
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_function
DECL|function|renameParameters
name|void
name|Doc
operator|::
name|renameParameters
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|oldNames
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|newNames
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|&&
name|oldNames
operator|!=
name|newNames
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|->
name|params
operator|=
name|newNames
operator|.
name|toSet
argument_list|()
expr_stmt|;
name|Atom
modifier|*
name|atom
init|=
name|priv
operator|->
name|text
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|FormattingLeft
operator|&&
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_FORMATTING_PARAMETER
condition|)
block|{
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|atom
condition|)
return|return;
name|int
name|index
init|=
name|oldNames
operator|.
name|indexOf
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
operator|&&
name|index
operator|<
name|newNames
operator|.
name|count
argument_list|()
condition|)
name|atom
operator|->
name|setString
argument_list|(
name|newNames
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|simplifyEnumDoc
name|void
name|Doc
operator|::
name|simplifyEnumDoc
parameter_list|()
block|{
if|if
condition|(
name|priv
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|isEnumDocSimplifiable
argument_list|()
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|Text
name|newText
decl_stmt|;
name|Atom
modifier|*
name|atom
init|=
name|priv
operator|->
name|text
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|ListLeft
operator|)
operator|&&
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|==
name|ATOM_LIST_VALUE
operator|)
condition|)
block|{
while|while
condition|(
name|atom
operator|&&
operator|(
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|!=
name|Atom
operator|::
name|ListRight
operator|)
operator|||
operator|(
name|atom
operator|->
name|string
argument_list|()
operator|!=
name|ATOM_LIST_VALUE
operator|)
operator|)
condition|)
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|atom
condition|)
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newText
operator|<<
operator|*
name|atom
expr_stmt|;
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
block|}
name|priv
operator|->
name|text
operator|=
name|newText
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|setBody
name|void
name|Doc
operator|::
name|setBody
parameter_list|(
specifier|const
name|Text
modifier|&
name|text
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|->
name|text
operator|=
name|text
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the starting location of a qdoc comment.  */
end_comment
begin_function
DECL|function|location
specifier|const
name|Location
modifier|&
name|Doc
operator|::
name|location
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
name|Location
name|dummy
decl_stmt|;
return|return
name|priv
operator|==
literal|0
condition|?
name|dummy
else|:
name|priv
operator|->
name|start_loc
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the starting location of a qdoc comment.  */
end_comment
begin_function
DECL|function|startLocation
specifier|const
name|Location
modifier|&
name|Doc
operator|::
name|startLocation
parameter_list|()
specifier|const
block|{
return|return
name|location
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the ending location of a qdoc comment.  */
end_comment
begin_function
DECL|function|endLocation
specifier|const
name|Location
modifier|&
name|Doc
operator|::
name|endLocation
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
name|Location
name|dummy
decl_stmt|;
return|return
name|priv
operator|==
literal|0
condition|?
name|dummy
else|:
name|priv
operator|->
name|end_loc
return|;
block|}
end_function
begin_function
DECL|function|source
specifier|const
name|QString
modifier|&
name|Doc
operator|::
name|source
parameter_list|()
specifier|const
block|{
specifier|static
name|QString
name|null
decl_stmt|;
return|return
name|priv
operator|==
literal|0
condition|?
name|null
else|:
name|priv
operator|->
name|src
return|;
block|}
end_function
begin_function
DECL|function|isEmpty
name|bool
name|Doc
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
operator|||
name|priv
operator|->
name|src
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|body
specifier|const
name|Text
modifier|&
name|Doc
operator|::
name|body
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
name|Text
name|dummy
decl_stmt|;
return|return
name|priv
operator|==
literal|0
condition|?
name|dummy
else|:
name|priv
operator|->
name|text
return|;
block|}
end_function
begin_function
DECL|function|briefText
name|Text
name|Doc
operator|::
name|briefText
parameter_list|(
name|bool
name|inclusive
parameter_list|)
specifier|const
block|{
return|return
name|body
argument_list|()
operator|.
name|subText
argument_list|(
name|Atom
operator|::
name|BriefLeft
argument_list|,
name|Atom
operator|::
name|BriefRight
argument_list|,
literal|0
argument_list|,
name|inclusive
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|trimmedBriefText
name|Text
name|Doc
operator|::
name|trimmedBriefText
parameter_list|(
specifier|const
name|QString
modifier|&
name|className
parameter_list|)
specifier|const
block|{
name|QString
name|classNameOnly
init|=
name|className
decl_stmt|;
if|if
condition|(
name|className
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
name|classNameOnly
operator|=
name|className
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
operator|.
name|last
argument_list|()
expr_stmt|;
name|Text
name|originalText
init|=
name|briefText
argument_list|()
decl_stmt|;
name|Text
name|resultText
decl_stmt|;
specifier|const
name|Atom
modifier|*
name|atom
init|=
name|originalText
operator|.
name|firstAtom
argument_list|()
decl_stmt|;
if|if
condition|(
name|atom
condition|)
block|{
name|QString
name|briefStr
decl_stmt|;
name|QString
name|whats
decl_stmt|;
comment|/*           This code is really ugly. The entire \brief business           should be rethought.         */
while|while
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|AutoLink
operator|||
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|String
condition|)
block|{
name|briefStr
operator|+=
name|atom
operator|->
name|string
argument_list|()
expr_stmt|;
block|}
name|atom
operator|=
name|atom
operator|->
name|next
argument_list|()
expr_stmt|;
block|}
name|QStringList
name|w
init|=
name|briefStr
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"Returns"
condition|)
block|{         }
else|else
block|{
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"The"
condition|)
name|w
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
name|className
operator|||
name|w
operator|.
name|first
argument_list|()
operator|==
name|classNameOnly
operator|)
condition|)
name|w
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"class"
operator|)
operator|||
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"function"
operator|)
operator|||
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"macro"
operator|)
operator|||
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"widget"
operator|)
operator|||
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"namespace"
operator|)
operator|||
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"header"
operator|)
operator|)
condition|)
name|w
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"is"
operator|||
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"provides"
operator|)
condition|)
name|w
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"a"
operator|||
name|w
operator|.
name|first
argument_list|()
operator|==
literal|"an"
operator|)
condition|)
name|w
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
name|whats
operator|=
name|w
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|whats
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|whats
operator|.
name|truncate
argument_list|(
name|whats
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|whats
operator|.
name|isEmpty
argument_list|()
condition|)
name|whats
index|[
literal|0
index|]
operator|=
name|whats
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
comment|// ### move this once \brief is abolished for properties
name|resultText
operator|<<
name|whats
expr_stmt|;
block|}
return|return
name|resultText
return|;
block|}
end_function
begin_function
DECL|function|legaleseText
name|Text
name|Doc
operator|::
name|legaleseText
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|priv
operator|==
literal|0
operator|||
operator|!
name|priv
operator|->
name|hasLegalese
condition|)
return|return
name|Text
argument_list|()
return|;
else|else
return|return
name|body
argument_list|()
operator|.
name|subText
argument_list|(
name|Atom
operator|::
name|LegaleseLeft
argument_list|,
name|Atom
operator|::
name|LegaleseRight
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|baseName
specifier|const
name|QString
modifier|&
name|Doc
operator|::
name|baseName
parameter_list|()
specifier|const
block|{
specifier|static
name|QString
name|null
decl_stmt|;
if|if
condition|(
name|priv
operator|==
literal|0
operator|||
name|priv
operator|->
name|extra
operator|==
literal|0
condition|)
block|{
return|return
name|null
return|;
block|}
else|else
block|{
return|return
name|priv
operator|->
name|extra
operator|->
name|baseName
return|;
block|}
block|}
end_function
begin_function
DECL|function|granularity
name|Doc
operator|::
name|Sections
name|Doc
operator|::
name|granularity
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|priv
operator|==
literal|0
operator|||
name|priv
operator|->
name|extra
operator|==
literal|0
condition|)
block|{
return|return
name|DocPrivateExtra
argument_list|()
operator|.
name|granularity
return|;
block|}
else|else
block|{
return|return
name|priv
operator|->
name|extra
operator|->
name|granularity
return|;
block|}
block|}
end_function
begin_function
DECL|function|parameterNames
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|Doc
operator|::
name|parameterNames
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|null_Set_QString
argument_list|()
else|:
name|priv
operator|->
name|params
return|;
block|}
end_function
begin_function
DECL|function|enumItemNames
specifier|const
name|QStringList
modifier|&
name|Doc
operator|::
name|enumItemNames
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|null_QStringList
argument_list|()
else|:
name|priv
operator|->
name|enumItemList
return|;
block|}
end_function
begin_function
DECL|function|omitEnumItemNames
specifier|const
name|QStringList
modifier|&
name|Doc
operator|::
name|omitEnumItemNames
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|null_QStringList
argument_list|()
else|:
name|priv
operator|->
name|omitEnumItemList
return|;
block|}
end_function
begin_function
DECL|function|metaCommandsUsed
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|Doc
operator|::
name|metaCommandsUsed
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|null_Set_QString
argument_list|()
else|:
name|priv
operator|->
name|metacommandsUsed
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a reference to the list of topic commands used in the   current qdoc comment. Normally there is only one, but there   can be multiple \e{qmlproperty} commands, for example.  */
end_comment
begin_function
DECL|function|topicsUsed
specifier|const
name|TopicList
modifier|&
name|Doc
operator|::
name|topicsUsed
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|nullTopicList
argument_list|()
else|:
name|priv
operator|->
name|topics
return|;
block|}
end_function
begin_function
DECL|function|metaCommandArgs
name|ArgList
name|Doc
operator|::
name|metaCommandArgs
parameter_list|(
specifier|const
name|QString
modifier|&
name|metacommand
parameter_list|)
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
name|ArgList
argument_list|()
else|:
name|priv
operator|->
name|metaCommandMap
operator|.
name|value
argument_list|(
name|metacommand
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|alsoList
specifier|const
name|QList
argument_list|<
name|Text
argument_list|>
modifier|&
name|Doc
operator|::
name|alsoList
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|==
literal|0
condition|?
operator|*
name|null_QList_Text
argument_list|()
else|:
name|priv
operator|->
name|alsoList
return|;
block|}
end_function
begin_function
DECL|function|hasTableOfContents
name|bool
name|Doc
operator|::
name|hasTableOfContents
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|&&
name|priv
operator|->
name|extra
operator|&&
operator|!
name|priv
operator|->
name|extra
operator|->
name|tableOfContents
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasKeywords
name|bool
name|Doc
operator|::
name|hasKeywords
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|&&
name|priv
operator|->
name|extra
operator|&&
operator|!
name|priv
operator|->
name|extra
operator|->
name|keywords
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasTargets
name|bool
name|Doc
operator|::
name|hasTargets
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|&&
name|priv
operator|->
name|extra
operator|&&
operator|!
name|priv
operator|->
name|extra
operator|->
name|targets
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|tableOfContents
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|Doc
operator|::
name|tableOfContents
parameter_list|()
specifier|const
block|{
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
return|return
name|priv
operator|->
name|extra
operator|->
name|tableOfContents
return|;
block|}
end_function
begin_function
DECL|function|tableOfContentsLevels
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|Doc
operator|::
name|tableOfContentsLevels
parameter_list|()
specifier|const
block|{
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
return|return
name|priv
operator|->
name|extra
operator|->
name|tableOfContentsLevels
return|;
block|}
end_function
begin_function
DECL|function|keywords
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|Doc
operator|::
name|keywords
parameter_list|()
specifier|const
block|{
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
return|return
name|priv
operator|->
name|extra
operator|->
name|keywords
return|;
block|}
end_function
begin_function
DECL|function|targets
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|Doc
operator|::
name|targets
parameter_list|()
specifier|const
block|{
name|priv
operator|->
name|constructExtra
argument_list|()
expr_stmt|;
return|return
name|priv
operator|->
name|extra
operator|->
name|targets
return|;
block|}
end_function
begin_function
DECL|function|metaTagMap
specifier|const
name|QStringMultiMap
modifier|&
name|Doc
operator|::
name|metaTagMap
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|&&
name|priv
operator|->
name|extra
condition|?
name|priv
operator|->
name|extra
operator|->
name|metaMap
else|:
operator|*
name|null_QStringMultiMap
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|initialize
name|void
name|Doc
operator|::
name|initialize
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|DocParser
operator|::
name|tabSize
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|CONFIG_TABSIZE
argument_list|)
expr_stmt|;
name|DocParser
operator|::
name|exampleFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_EXAMPLES
argument_list|)
expr_stmt|;
name|DocParser
operator|::
name|exampleDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_EXAMPLEDIRS
argument_list|)
expr_stmt|;
name|DocParser
operator|::
name|sourceFiles
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_SOURCES
argument_list|)
expr_stmt|;
name|DocParser
operator|::
name|sourceDirs
operator|=
name|config
operator|.
name|getCleanPathList
argument_list|(
name|CONFIG_SOURCEDIRS
argument_list|)
expr_stmt|;
name|DocParser
operator|::
name|quoting
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|CONFIG_QUOTINGINFORMATION
argument_list|)
expr_stmt|;
name|QmlClassNode
operator|::
name|qmlOnly
operator|=
name|config
operator|.
name|getBool
argument_list|(
name|CONFIG_QMLONLY
argument_list|)
expr_stmt|;
name|QStringMap
name|reverseAliasMap
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|commands
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_ALIAS
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|c
init|=
name|commands
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|commands
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|alias
init|=
name|config
operator|.
name|getString
argument_list|(
name|CONFIG_ALIAS
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|reverseAliasMap
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Command name '\\%1' cannot stand"
literal|" for both '\\%2' and '\\%3'"
argument_list|)
operator|.
name|arg
argument_list|(
name|alias
argument_list|)
operator|.
name|arg
argument_list|(
name|reverseAliasMap
index|[
name|alias
index|]
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reverseAliasMap
operator|.
name|insert
argument_list|(
name|alias
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
name|aliasMap
argument_list|()
operator|->
name|insert
argument_list|(
operator|*
name|c
argument_list|,
name|alias
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cmds
index|[
name|i
index|]
operator|.
name|english
condition|)
block|{
name|cmds
index|[
name|i
index|]
operator|.
name|alias
operator|=
operator|new
name|QString
argument_list|(
name|alias
argument_list|(
name|cmds
index|[
name|i
index|]
operator|.
name|english
argument_list|)
argument_list|)
expr_stmt|;
name|cmdHash
argument_list|()
operator|->
name|insert
argument_list|(
operator|*
name|cmds
index|[
name|i
index|]
operator|.
name|alias
argument_list|,
name|cmds
index|[
name|i
index|]
operator|.
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmds
index|[
name|i
index|]
operator|.
name|no
operator|!=
name|i
condition|)
name|Location
operator|::
name|internalError
argument_list|(
name|tr
argument_list|(
literal|"command %1 missing"
argument_list|)
operator|.
name|arg
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|QSet
argument_list|<
name|QString
argument_list|>
name|macroNames
init|=
name|config
operator|.
name|subVars
argument_list|(
name|CONFIG_MACRO
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|n
init|=
name|macroNames
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|macroNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|macroDotName
init|=
name|CONFIG_MACRO
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|n
decl_stmt|;
name|Macro
name|macro
decl_stmt|;
name|macro
operator|.
name|numParams
operator|=
operator|-
literal|1
expr_stmt|;
name|macro
operator|.
name|defaultDef
operator|=
name|config
operator|.
name|getString
argument_list|(
name|macroDotName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro
operator|.
name|defaultDef
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|macro
operator|.
name|defaultDefLocation
operator|=
name|config
operator|.
name|lastLocation
argument_list|()
expr_stmt|;
name|macro
operator|.
name|numParams
operator|=
name|Config
operator|::
name|numParams
argument_list|(
name|macro
operator|.
name|defaultDef
argument_list|)
expr_stmt|;
block|}
name|bool
name|silent
init|=
literal|false
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|formats
init|=
name|config
operator|.
name|subVars
argument_list|(
name|macroDotName
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|ConstIterator
name|f
init|=
name|formats
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|formats
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|def
init|=
name|config
operator|.
name|getString
argument_list|(
name|macroDotName
operator|+
name|Config
operator|::
name|dot
operator|+
operator|*
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|macro
operator|.
name|otherDefs
operator|.
name|insert
argument_list|(
operator|*
name|f
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|int
name|m
init|=
name|Config
operator|::
name|numParams
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|macro
operator|.
name|numParams
operator|==
operator|-
literal|1
condition|)
block|{
name|macro
operator|.
name|numParams
operator|=
name|m
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macro
operator|.
name|numParams
operator|!=
name|m
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|QString
name|other
init|=
name|tr
argument_list|(
literal|"default"
argument_list|)
decl_stmt|;
if|if
condition|(
name|macro
operator|.
name|defaultDef
operator|.
name|isEmpty
argument_list|()
condition|)
name|other
operator|=
name|macro
operator|.
name|otherDefs
operator|.
name|constBegin
argument_list|()
operator|.
name|key
argument_list|()
expr_stmt|;
name|config
operator|.
name|lastLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Macro '\\%1' takes"
literal|" inconsistent number"
literal|" of arguments (%2"
literal|" %3, %4 %5)"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|n
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|f
argument_list|)
operator|.
name|arg
argument_list|(
name|m
argument_list|)
operator|.
name|arg
argument_list|(
name|other
argument_list|)
operator|.
name|arg
argument_list|(
name|macro
operator|.
name|numParams
argument_list|)
argument_list|)
expr_stmt|;
name|silent
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|macro
operator|.
name|numParams
operator|<
name|m
condition|)
name|macro
operator|.
name|numParams
operator|=
name|m
expr_stmt|;
block|}
block|}
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|macro
operator|.
name|numParams
operator|!=
operator|-
literal|1
condition|)
name|macroHash
argument_list|()
operator|->
name|insert
argument_list|(
operator|*
name|n
argument_list|,
name|macro
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|terminate
name|void
name|Doc
operator|::
name|terminate
parameter_list|()
block|{
name|DocParser
operator|::
name|exampleFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DocParser
operator|::
name|exampleDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DocParser
operator|::
name|sourceFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DocParser
operator|::
name|sourceDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|aliasMap
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|cmdHash
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|macroHash
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cmds
index|[
name|i
index|]
operator|.
name|english
condition|)
block|{
operator|delete
name|cmds
index|[
name|i
index|]
operator|.
name|alias
expr_stmt|;
name|cmds
index|[
name|i
index|]
operator|.
name|alias
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|alias
name|QString
name|Doc
operator|::
name|alias
parameter_list|(
specifier|const
name|QString
modifier|&
name|english
parameter_list|)
block|{
return|return
name|aliasMap
argument_list|()
operator|->
name|value
argument_list|(
name|english
argument_list|,
name|english
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Trims the deadwood out of \a str. i.e., this function   cleans up \a str.  */
end_comment
begin_function
DECL|function|trimCStyleComment
name|void
name|Doc
operator|::
name|trimCStyleComment
parameter_list|(
name|Location
modifier|&
name|location
parameter_list|,
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|cleaned
decl_stmt|;
name|Location
name|m
init|=
name|location
decl_stmt|;
name|bool
name|metAsterColumn
init|=
literal|true
decl_stmt|;
name|int
name|asterColumn
init|=
name|location
operator|.
name|columnNo
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|.
name|columnNo
argument_list|()
operator|==
name|asterColumn
condition|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|!=
literal|'*'
condition|)
break|break;
name|cleaned
operator|+=
literal|' '
expr_stmt|;
name|metAsterColumn
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|metAsterColumn
condition|)
break|break;
name|metAsterColumn
operator|=
literal|false
expr_stmt|;
block|}
name|cleaned
operator|+=
name|str
index|[
name|i
index|]
expr_stmt|;
block|}
name|m
operator|.
name|advance
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleaned
operator|.
name|length
argument_list|()
operator|==
name|str
operator|.
name|length
argument_list|()
condition|)
name|str
operator|=
name|cleaned
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|location
operator|.
name|advance
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|str
operator|.
name|mid
argument_list|(
literal|3
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|quoteFromFile
name|CodeMarker
modifier|*
name|Doc
operator|::
name|quoteFromFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
name|Quoter
modifier|&
name|quoter
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|quoter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|QString
name|code
decl_stmt|;
name|QString
name|userFriendlyFilePath
decl_stmt|;
name|QString
name|filePath
init|=
name|Config
operator|::
name|findFile
argument_list|(
name|location
argument_list|,
name|DocParser
operator|::
name|exampleFiles
argument_list|,
name|DocParser
operator|::
name|exampleDirs
argument_list|,
name|fileName
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot find file to quote from: '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QFile
name|inFile
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot open file to quote from: '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|userFriendlyFilePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTextStream
name|inStream
argument_list|(
operator|&
name|inFile
argument_list|)
decl_stmt|;
name|code
operator|=
name|DocParser
operator|::
name|untabifyEtc
argument_list|(
name|inStream
operator|.
name|readAll
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|QString
name|dirPath
init|=
name|QFileInfo
argument_list|(
name|filePath
argument_list|)
operator|.
name|path
argument_list|()
decl_stmt|;
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|quoter
operator|.
name|quoteFromFile
argument_list|(
name|userFriendlyFilePath
argument_list|,
name|code
argument_list|,
name|marker
operator|->
name|markedUpCode
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|location
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|marker
return|;
block|}
end_function
begin_function
DECL|function|canonicalTitle
name|QString
name|Doc
operator|::
name|canonicalTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
comment|// The code below is equivalent to the following chunk, but _much_
comment|// faster (accounts for ~10% of total running time)
comment|//
comment|//  QRegExp attributeExpr("[^A-Za-z0-9]+");
comment|//  QString result = title.toLower();
comment|//  result.replace(attributeExpr, " ");
comment|//  result = result.simplified();
comment|//  result.replace(QLatin1Char(' '), QLatin1Char('-'));
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|title
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|dashAppended
init|=
literal|false
decl_stmt|;
name|bool
name|begun
init|=
literal|false
decl_stmt|;
name|int
name|lastAlnum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|title
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|c
init|=
name|title
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
name|bool
name|alnum
init|=
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
decl_stmt|;
if|if
condition|(
name|alnum
condition|)
block|{
name|result
operator|+=
name|QLatin1Char
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|begun
operator|=
literal|true
expr_stmt|;
name|dashAppended
operator|=
literal|false
expr_stmt|;
name|lastAlnum
operator|=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dashAppended
condition|)
block|{
if|if
condition|(
name|begun
condition|)
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|dashAppended
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|lastAlnum
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|detach
name|void
name|Doc
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|priv
operator|=
operator|new
name|DocPrivate
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|priv
operator|->
name|count
operator|==
literal|1
condition|)
return|return;
operator|--
name|priv
operator|->
name|count
expr_stmt|;
name|DocPrivate
modifier|*
name|newPriv
init|=
operator|new
name|DocPrivate
argument_list|(
operator|*
name|priv
argument_list|)
decl_stmt|;
name|newPriv
operator|->
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|extra
condition|)
name|newPriv
operator|->
name|extra
operator|=
operator|new
name|DocPrivateExtra
argument_list|(
operator|*
name|priv
operator|->
name|extra
argument_list|)
expr_stmt|;
name|priv
operator|=
name|newPriv
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   The destructor deletes all the sub-TopicRefs.  */
end_comment
begin_destructor
DECL|function|~TopicRef
name|TopicRef
operator|::
name|~
name|TopicRef
parameter_list|()
block|{
foreach|foreach
control|(
name|DitaRef
modifier|*
name|t
decl|,
name|subrefs_
control|)
block|{
operator|delete
name|t
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!   Returns a reference to the structure that will be used   for generating a DITA mao.  */
end_comment
begin_function
DECL|function|ditamap
specifier|const
name|DitaRefList
modifier|&
name|Doc
operator|::
name|ditamap
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|ditamap_
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
