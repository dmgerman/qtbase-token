begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   tree.cpp */
end_comment
begin_include
include|#
directive|include
file|<QDomDocument>
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"location.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_struct
DECL|struct|InheritanceBound
struct|struct
name|InheritanceBound
block|{
DECL|member|access
name|Node
operator|::
name|Access
name|access
decl_stmt|;
DECL|member|basePath
name|QStringList
name|basePath
decl_stmt|;
DECL|member|dataTypeWithTemplateArgs
name|QString
name|dataTypeWithTemplateArgs
decl_stmt|;
DECL|member|parent
name|InnerNode
modifier|*
name|parent
decl_stmt|;
DECL|function|InheritanceBound
name|InheritanceBound
parameter_list|()
member_init_list|:
name|access
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
block|{ }
DECL|function|InheritanceBound
name|InheritanceBound
parameter_list|(
name|Node
operator|::
name|Access
name|access0
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|basePath0
parameter_list|,
specifier|const
name|QString
modifier|&
name|dataTypeWithTemplateArgs0
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|access
argument_list|(
name|access0
argument_list|)
member_init_list|,
name|basePath
argument_list|(
name|basePath0
argument_list|)
member_init_list|,
name|dataTypeWithTemplateArgs
argument_list|(
name|dataTypeWithTemplateArgs0
argument_list|)
member_init_list|,
name|parent
argument_list|(
name|parent
argument_list|)
block|{ }
block|}
struct|;
end_struct
begin_struct
DECL|struct|Target
struct|struct
name|Target
block|{
DECL|member|node
name|Node
modifier|*
name|node
decl_stmt|;
DECL|member|atom
name|Atom
modifier|*
name|atom
decl_stmt|;
DECL|member|priority
name|int
name|priority
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|RoleMap
typedef|typedef
name|QMap
argument_list|<
name|PropertyNode
operator|::
name|FunctionRole
argument_list|,
name|QString
argument_list|>
name|RoleMap
typedef|;
end_typedef
begin_typedef
DECL|typedef|PropertyMap
typedef|typedef
name|QMap
argument_list|<
name|PropertyNode
modifier|*
argument_list|,
name|RoleMap
argument_list|>
name|PropertyMap
typedef|;
end_typedef
begin_typedef
DECL|typedef|FakeNodeHash
typedef|typedef
name|QMultiHash
argument_list|<
name|QString
argument_list|,
name|FakeNode
modifier|*
argument_list|>
name|FakeNodeHash
typedef|;
end_typedef
begin_typedef
DECL|typedef|TargetHash
typedef|typedef
name|QMultiHash
argument_list|<
name|QString
argument_list|,
name|Target
argument_list|>
name|TargetHash
typedef|;
end_typedef
begin_class
DECL|class|TreePrivate
class|class
name|TreePrivate
block|{
public|public:
DECL|member|unresolvedInheritanceMap
name|QMap
argument_list|<
name|ClassNode
modifier|*
argument_list|,
name|QList
argument_list|<
name|InheritanceBound
argument_list|>
argument_list|>
name|unresolvedInheritanceMap
decl_stmt|;
DECL|member|unresolvedPropertyMap
name|PropertyMap
name|unresolvedPropertyMap
decl_stmt|;
DECL|member|groupMap
name|NodeMultiMap
name|groupMap
decl_stmt|;
DECL|member|publicGroupMap
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|publicGroupMap
decl_stmt|;
DECL|member|fakeNodesByTitle
name|FakeNodeHash
name|fakeNodesByTitle
decl_stmt|;
DECL|member|targetHash
name|TargetHash
name|targetHash
decl_stmt|;
DECL|member|basesList
name|QList
argument_list|<
name|QPair
argument_list|<
name|ClassNode
modifier|*
argument_list|,
name|QString
argument_list|>
argument_list|>
name|basesList
decl_stmt|;
DECL|member|relatedList
name|QList
argument_list|<
name|QPair
argument_list|<
name|FunctionNode
modifier|*
argument_list|,
name|QString
argument_list|>
argument_list|>
name|relatedList
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!   \class Tree    This class constructs and maintains a tree of instances of   Node and its many subclasses.  */
end_comment
begin_comment
comment|/*!   The default constructor is the only constructor.  */
end_comment
begin_constructor
DECL|function|Tree
name|Tree
operator|::
name|Tree
parameter_list|()
member_init_list|:
name|roo
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|)
block|{
name|priv
operator|=
operator|new
name|TreePrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   The destructor deletes the internal, private tree.  */
end_comment
begin_destructor
DECL|function|~Tree
name|Tree
operator|::
name|~
name|Tree
parameter_list|()
block|{
operator|delete
name|priv
expr_stmt|;
block|}
end_destructor
begin_comment
comment|// 1 calls 2
end_comment
begin_comment
comment|/*!   Searches the tree for a node that matches the \a path. The   search begins at \a start but can move up the parent chain   recursively if no match is found.  */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       First, search for a node assuming we don't want a QML node.       If that search fails, search again assuming we do want a       QML node.      */
specifier|const
name|Node
modifier|*
name|n
init|=
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
name|self
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
name|self
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|// 2 is private; it is only called by 1.
end_comment
begin_comment
comment|/*!   This overload function was extracted from the one above that has the   same signature without the last bool parameter, \a qml. This version   is called only by that other one. It is therefore private.  It can   be called a second time by that other version, if the first call   returns null. If \a qml is false, the search will only match a node   that is not a QML node.  If \a qml is true, the search will only   match a node that is a QML node. */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|,
name|bool
name|qml
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|current
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_idx
init|=
literal|0
decl_stmt|;
comment|/*           If the path contains one or two double colons ("::"),           check first to see if the first two path strings refer           to a QML element. If they do, path[0] will be the QML           module identifier, and path[1] will be the QML type.           If the anser is yes, the reference identifies a QML           class node.         */
if|if
condition|(
name|qml
operator|&&
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|QmlClassNode
operator|::
name|lookupQmlTypeNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
name|node
operator|=
name|qcn
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|node
return|;
name|start_idx
operator|=
literal|2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|qml
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|!
name|qml
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|!
operator|(
name|findFlags
operator|&
name|NonFunction
operator|)
operator|||
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Function
operator|||
operator|(
operator|(
name|FunctionNode
operator|*
operator|)
name|node
operator|)
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithoutParams
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|!=
name|self
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|applyModuleIdentifier
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
block|}
name|current
operator|=
name|current
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|current
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the QML class node for the specified \a module and \a name   identifiers. The \a module identifier may be empty. If the module   identifier is empty, then begin by finding the FakeNode that has   the specified \a name. If that FakeNode is a QML class, return it.   If it is a collision node, return its current child, if the current   child is a QML class. If the collision node does not have a child   that is a QML class node, return 0.  */
end_comment
begin_function
DECL|function|findQmlClassNode
name|QmlClassNode
modifier|*
name|Tree
operator|::
name|findQmlClassNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|module
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|findQmlClassNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
decl_stmt|;
name|ncn
operator|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|ncn
operator|->
name|findAny
argument_list|(
name|Node
operator|::
name|Fake
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
return|return
name|QmlClassNode
operator|::
name|lookupQmlTypeNode
argument_list|(
name|module
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   First, search for a node with the specified \a name. If a matching   node is found, if it is a collision node, another collision with   this name has been found, so return the collision node. If the   matching node is not a collision node, the first collision for this   name has been found, so create a NameCollisionNode with the matching   node as its first child, and return a pointer to the new   NameCollisionNode. Otherwise return 0.  */
end_comment
begin_function
DECL|function|checkForCollision
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|checkForCollision
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
if|if
condition|(
name|n
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
operator|new
name|NameCollisionNode
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function is like checkForCollision() in that it searches   for a collision node with the specified \a name. But it doesn't   create anything. If it finds a match, it returns the pointer.   Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|findCollisionNode
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|findCollisionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function just calls the const version of the same function   and returns the function node.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function begins searching the tree at \a relative for   the \l {FunctionNode} {function node} identified by \a path.   The \a findFlags are used to restrict the search. If a node   that matches the \a path is found, it is returned. Otherwise,   0 is returned. If \a relative is 0, the root of the tree is   used as the starting point.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|relative
condition|)
name|relative
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       If the path contains two double colons ("::"), check       first to see if it is a reference to a QML method. If       it is a reference to a QML method, first look up the       QML class node in the QML module map.      */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|QmlClassNode
operator|::
name|lookupQmlTypeNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|findFunctionNode
argument_list|(
name|path
index|[
literal|2
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
name|node
operator|->
name|isFunction
argument_list|()
condition|)
block|{
comment|// CppCodeParser::processOtherMetaCommand ensures that reimplemented
comment|// functions are private.
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
return|return
name|from
return|;
else|else
name|func
operator|=
name|from
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|func
return|;
block|}
name|relative
operator|=
name|relative
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|relative
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function just calls the const version of itself and   returns the result.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|,
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|parentPath
argument_list|,
name|clone
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function first ignores the \a clone node and searches   for the node having the \a parentPath by calling the main   findFunction(\a {parentPath}, \a {relative}, \a {findFlags}).   If that search is successful, then it searches for the \a clone   in the found parent node.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|parent
init|=
name|findNode
argument_list|(
name|parentPath
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
operator|||
operator|!
name|parent
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|parent
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|//findNode(parameter.leftType().split("::"), 0, SearchBaseClasses|NonFunction);
end_comment
begin_decl_stmt
DECL|variable|NumSuffixes
specifier|static
specifier|const
name|int
name|NumSuffixes
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|suffixes
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suffixes
index|[
name|NumSuffixes
index|]
init|=
block|{
literal|""
block|,
literal|"s"
block|,
literal|"es"
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   This function searches for a node with the specified \a title.   If \a relative node is provided, it is used to disambiguate if   it has a QML module identifier.  */
end_comment
begin_function
DECL|function|findFakeNodeByTitle
specifier|const
name|FakeNode
modifier|*
name|Tree
operator|::
name|findFakeNodeByTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
name|NumSuffixes
condition|;
operator|++
name|pass
control|)
block|{
name|FakeNodeHash
operator|::
name|const_iterator
name|i
init|=
name|priv
operator|->
name|fakeNodesByTitle
operator|.
name|find
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
operator|+
name|suffixes
index|[
name|pass
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|priv
operator|->
name|fakeNodesByTitle
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fn
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|fn
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|parent
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|nl
init|=
name|parent
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|it
init|=
name|nl
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|nl
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
condition|)
block|{
comment|/*                               By returning here, we avoid printing all the duplicate                               header warnings, which are not really duplicates now,                               because of the QML module identifier being used as a                               namespace qualifier.                              */
name|fn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
comment|/*               Reporting all these duplicate section titles is probably               overkill. We should report the duplicate file and let               that suffice.              */
name|FakeNodeHash
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|priv
operator|->
name|fakeNodesByTitle
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Location
argument_list|>
name|internalLocations
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|priv
operator|->
name|fakeNodesByTitle
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
operator|&&
name|j
operator|.
name|value
argument_list|()
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|internalLocations
operator|.
name|append
argument_list|(
name|j
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|internalLocations
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|i
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"This page exists in more than one file: \"%1\""
argument_list|)
operator|.
name|arg
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Location
modifier|&
name|location
decl|,
name|internalLocations
control|)
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"[It also exists here]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a \a target anchor node. If it   finds one, it sets \a atom from the found node and returns   the found node.  */
end_comment
begin_function
specifier|const
name|Node
modifier|*
DECL|function|findUnambiguousTarget
name|Tree
operator|::
name|findUnambiguousTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|Atom
modifier|*
modifier|&
name|atom
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
name|Target
name|bestTarget
init|=
block|{
literal|0
block|,
literal|0
block|,
name|INT_MAX
block|}
decl_stmt|;
name|int
name|numBestTargets
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|Target
argument_list|>
name|bestTargetList
decl_stmt|;
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
name|NumSuffixes
condition|;
operator|++
name|pass
control|)
block|{
name|TargetHash
operator|::
name|const_iterator
name|i
init|=
name|priv
operator|->
name|targetHash
operator|.
name|find
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
operator|+
name|suffixes
index|[
name|pass
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|priv
operator|->
name|targetHash
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|TargetHash
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
do|do
block|{
specifier|const
name|Target
modifier|&
name|candidate
init|=
name|j
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|candidate
operator|.
name|priority
operator|<
name|bestTarget
operator|.
name|priority
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|.
name|priority
operator|==
name|bestTarget
operator|.
name|priority
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|!=
name|priv
operator|->
name|targetHash
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
do|;
if|if
condition|(
name|numBestTargets
operator|==
literal|1
condition|)
block|{
name|atom
operator|=
name|bestTarget
operator|.
name|atom
expr_stmt|;
return|return
name|bestTarget
operator|.
name|node
return|;
block|}
elseif|else
if|if
condition|(
name|bestTargetList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|relative
operator|&&
operator|!
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bestTargetList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Node
modifier|*
name|n
init|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|relative
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
condition|)
block|{
name|atom
operator|=
name|bestTargetList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atom
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with a canonical title   constructed from \a target and each of the possible suffixes.   If the node it finds is \a node, it returns the Atom from that   node. Otherwise it returns null.  */
end_comment
begin_function
DECL|function|findTarget
name|Atom
modifier|*
name|Tree
operator|::
name|findTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
name|NumSuffixes
condition|;
operator|++
name|pass
control|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
operator|+
name|suffixes
index|[
name|pass
index|]
argument_list|)
decl_stmt|;
name|TargetHash
operator|::
name|const_iterator
name|i
init|=
name|priv
operator|->
name|targetHash
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|priv
operator|->
name|targetHash
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|node
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|.
name|atom
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|priv
operator|->
name|targetHash
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
do|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addBaseClass
name|void
name|Tree
operator|::
name|addBaseClass
parameter_list|(
name|ClassNode
modifier|*
name|subclass
parameter_list|,
name|Node
operator|::
name|Access
name|access
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|basePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|dataTypeWithTemplateArgs
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|priv
operator|->
name|unresolvedInheritanceMap
index|[
name|subclass
index|]
operator|.
name|append
argument_list|(
name|InheritanceBound
argument_list|(
name|access
argument_list|,
name|basePath
argument_list|,
name|dataTypeWithTemplateArgs
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addPropertyFunction
name|void
name|Tree
operator|::
name|addPropertyFunction
parameter_list|(
name|PropertyNode
modifier|*
name|property
parameter_list|,
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|,
name|PropertyNode
operator|::
name|FunctionRole
name|funcRole
parameter_list|)
block|{
name|priv
operator|->
name|unresolvedPropertyMap
index|[
name|property
index|]
operator|.
name|insert
argument_list|(
name|funcRole
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function adds the \a node to the \a group. The group   can be listed anywhere using the \e{annotated list} command.  */
end_comment
begin_function
DECL|function|addToGroup
name|void
name|Tree
operator|::
name|addToGroup
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|group
parameter_list|)
block|{
name|priv
operator|->
name|groupMap
operator|.
name|insert
argument_list|(
name|group
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the group map.  */
end_comment
begin_function
DECL|function|groups
name|NodeMultiMap
name|Tree
operator|::
name|groups
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|groupMap
return|;
block|}
end_function
begin_comment
comment|/*!   This function adds the \a group name to the list of groups   for the \a node name. It also adds the \a node to the \a group.  */
end_comment
begin_function
DECL|function|addToPublicGroup
name|void
name|Tree
operator|::
name|addToPublicGroup
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|group
parameter_list|)
block|{
name|priv
operator|->
name|publicGroupMap
operator|.
name|insert
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|addToGroup
argument_list|(
name|node
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the public group map.  */
end_comment
begin_function
DECL|function|publicGroups
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|Tree
operator|::
name|publicGroups
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|publicGroupMap
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|resolveInheritance
argument_list|(
name|pass
argument_list|,
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|resolveInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|rootNode
operator|==
name|root
argument_list|()
condition|)
name|priv
operator|->
name|unresolvedInheritanceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveProperties
name|void
name|Tree
operator|::
name|resolveProperties
parameter_list|()
block|{
name|PropertyMap
operator|::
name|ConstIterator
name|propEntry
decl_stmt|;
name|propEntry
operator|=
name|priv
operator|->
name|unresolvedPropertyMap
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|priv
operator|->
name|unresolvedPropertyMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|property
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QString
name|getterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Getter
index|]
decl_stmt|;
name|QString
name|setterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Setter
index|]
decl_stmt|;
name|QString
name|resetterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Resetter
index|]
decl_stmt|;
name|QString
name|notifierName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Notifier
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|access
argument_list|()
operator|==
name|property
operator|->
name|access
argument_list|()
operator|&&
operator|(
name|function
operator|->
name|status
argument_list|()
operator|==
name|property
operator|->
name|status
argument_list|()
operator|||
name|function
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|getterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Getter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|setterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Setter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|resetterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Resetter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|notifierName
condition|)
block|{
name|property
operator|->
name|addSignal
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Notifier
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
operator|++
name|propEntry
expr_stmt|;
block|}
name|propEntry
operator|=
name|priv
operator|->
name|unresolvedPropertyMap
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|priv
operator|->
name|unresolvedPropertyMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
comment|// redo it to set the property functions
if|if
condition|(
name|property
operator|->
name|overriddenFrom
argument_list|()
condition|)
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|property
operator|->
name|overriddenFrom
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|propEntry
expr_stmt|;
block|}
name|priv
operator|->
name|unresolvedPropertyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|int
name|pass
parameter_list|,
name|ClassNode
modifier|*
name|classe
parameter_list|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|QList
argument_list|<
name|InheritanceBound
argument_list|>
name|bounds
init|=
name|priv
operator|->
name|unresolvedInheritanceMap
index|[
name|classe
index|]
decl_stmt|;
name|QList
argument_list|<
name|InheritanceBound
argument_list|>
operator|::
name|ConstIterator
name|b
init|=
name|bounds
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|bounds
operator|.
name|end
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|basePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|&&
operator|(
operator|*
name|b
operator|)
operator|.
name|parent
condition|)
block|{
name|n
operator|=
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|basePath
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|classe
operator|->
name|addBaseClass
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|access
argument_list|,
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|.
name|dataTypeWithTemplateArgs
argument_list|)
expr_stmt|;
block|}
operator|++
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|classe
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classe
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
decl_stmt|;
name|FunctionNode
modifier|*
name|from
init|=
name|findVirtualFunctionInBaseClasses
argument_list|(
name|classe
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|func
operator|->
name|setVirtualness
argument_list|(
name|FunctionNode
operator|::
name|ImpureVirtual
argument_list|)
expr_stmt|;
name|func
operator|->
name|setReimplementedFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|fixPropertyUsingBaseClasses
argument_list|(
name|classe
argument_list|,
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   For each node in the group map, add the node to the appropriate   group node.  */
end_comment
begin_function
DECL|function|resolveGroups
name|void
name|Tree
operator|::
name|resolveGroups
parameter_list|()
block|{
name|NodeMultiMap
operator|::
name|const_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|groupMap
operator|.
name|constBegin
argument_list|()
init|;
name|i
operator|!=
name|priv
operator|->
name|groupMap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
continue|continue;
name|Node
modifier|*
name|n
init|=
name|findGroupNode
argument_list|(
name|QStringList
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|n
operator|->
name|addGroupMember
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveTargets
name|void
name|Tree
operator|::
name|resolveTargets
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// need recursion
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
name|FakeNode
modifier|*
name|node
init|=
cast|static_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|priv
operator|->
name|fakeNodesByTitle
operator|.
name|insert
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|resolveTargets
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|atom
operator|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|target
operator|.
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|keywords
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|atom
operator|=
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
operator|.
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
decl_stmt|;
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|atom
operator|=
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
operator|.
name|atom
operator|->
name|string
argument_list|()
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   For each QML class node that points to a C++ class node,   follow its C++ class node pointer and set the C++ class   node's QML class node pointer back to the QML class node.  */
end_comment
begin_function
DECL|function|resolveCppToQmlLinks
name|void
name|Tree
operator|::
name|resolveCppToQmlLinks
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|roo
operator|.
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
cast|const_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|classNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cn
condition|)
name|cn
operator|->
name|setQmlElement
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   For each QML class node in the tree, determine whether   it inherits a QML base class and, if so, which one, and   store that pointer in the QML class node's state.  */
end_comment
begin_function
DECL|function|resolveQmlInheritance
name|void
name|Tree
operator|::
name|resolveQmlInheritance
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|roo
operator|.
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|qcn
operator|->
name|resolveInheritance
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|ncn
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|qcn
operator|->
name|resolveInheritance
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixInheritance
name|void
name|Tree
operator|::
name|fixInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|->
name|fixBaseClasses
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|fixInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findVirtualFunctionInBaseClasses
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findVirtualFunctionInBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|func
operator|=
name|findVirtualFunctionInBaseClasses
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|,
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|func
operator|=
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
return|return
name|func
return|;
block|}
operator|++
name|r
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixPropertyUsingBaseClasses
name|void
name|Tree
operator|::
name|fixPropertyUsingBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|classe
parameter_list|,
name|PropertyNode
modifier|*
name|property
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|const_iterator
name|r
init|=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classe
operator|->
name|baseClasses
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|r
operator|->
name|node
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|property
operator|->
name|name
argument_list|()
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|PropertyNode
modifier|*
name|baseProperty
init|=
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|fixPropertyUsingBaseClasses
argument_list|(
name|r
operator|->
name|node
argument_list|,
name|baseProperty
argument_list|)
expr_stmt|;
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|baseProperty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixPropertyUsingBaseClasses
argument_list|(
name|r
operator|->
name|node
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|allBaseClasses
name|NodeList
name|Tree
operator|::
name|allBaseClasses
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classe
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|r
decl|,
name|classe
operator|->
name|baseClasses
argument_list|()
control|)
block|{
name|result
operator|+=
name|r
operator|.
name|node
expr_stmt|;
name|result
operator|+=
name|allBaseClasses
argument_list|(
name|r
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|readIndexes
name|void
name|Tree
operator|::
name|readIndexes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|indexFiles
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|indexFile
decl|,
name|indexFiles
control|)
name|readIndexFile
argument_list|(
name|indexFile
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Read the QDomDocument at \a path and get the index from it.  */
end_comment
begin_function
DECL|function|readIndexFile
name|void
name|Tree
operator|::
name|readIndexFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QDomDocument
name|document
decl_stmt|;
name|document
operator|.
name|setContent
argument_list|(
operator|&
name|file
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|QDomElement
name|indexElement
init|=
name|document
operator|.
name|documentElement
argument_list|()
decl_stmt|;
comment|// Generate a relative URL between the install dir and the index file
comment|// when the -installdir command line option is set.
name|QString
name|indexUrl
decl_stmt|;
if|if
condition|(
name|Config
operator|::
name|installDir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|indexUrl
operator|=
name|indexElement
operator|.
name|attribute
argument_list|(
literal|"url"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDir
name|installDir
argument_list|(
name|Config
operator|::
name|installDir
argument_list|)
decl_stmt|;
name|indexUrl
operator|=
name|installDir
operator|.
name|relativeFilePath
argument_list|(
name|path
argument_list|)
operator|.
name|section
argument_list|(
literal|'/'
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|basesList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|priv
operator|->
name|relatedList
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Scan all elements in the XML file, constructing a map that contains
comment|// base classes for each class found.
name|QDomElement
name|child
init|=
name|indexElement
operator|.
name|firstChildElement
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|root
argument_list|()
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|()
expr_stmt|;
block|}
comment|// Now that all the base classes have been found for this index,
comment|// arrange them into an inheritance hierarchy.
name|resolveIndex
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Read a<section> element from the index file and create the   appropriate node(s).  */
end_comment
begin_function
DECL|function|readIndexSection
name|void
name|Tree
operator|::
name|readIndexSection
parameter_list|(
specifier|const
name|QDomElement
modifier|&
name|element
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|indexUrl
parameter_list|)
block|{
name|QString
name|name
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|QString
name|href
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"href"
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|section
decl_stmt|;
name|Location
name|location
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"namespace"
condition|)
block|{
name|section
operator|=
operator|new
name|NamespaceNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"class"
condition|)
block|{
name|section
operator|=
operator|new
name|ClassNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|priv
operator|->
name|basesList
operator|.
name|append
argument_list|(
name|QPair
argument_list|<
name|ClassNode
operator|*
argument_list|,
name|QString
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|section
argument_list|)
argument_list|,
name|element
operator|.
name|attribute
argument_list|(
literal|"bases"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlclass"
operator|)
operator|||
operator|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
operator|)
operator|&&
operator|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlclass"
operator|)
operator|)
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
operator|new
name|QmlClassNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|qcn
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|section
operator|=
name|qcn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlbasictype"
condition|)
block|{
name|QmlBasicTypeNode
modifier|*
name|qbtn
init|=
operator|new
name|QmlBasicTypeNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|qbtn
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|section
operator|=
name|qbtn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
condition|)
block|{
name|Node
operator|::
name|SubType
name|subtype
decl_stmt|;
name|Node
operator|::
name|PageType
name|ptype
init|=
name|Node
operator|::
name|NoPageType
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"example"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Example
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ExamplePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"header"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|HeaderFile
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"file"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|File
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|NoPageType
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"group"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Group
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"module"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Module
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|OverviewPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"page"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|Page
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ArticlePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"externalpage"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|ExternalPage
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ArticlePage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlclass"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlClass
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlpropertygroup"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlPropertyGroup
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"subtype"
argument_list|)
operator|==
literal|"qmlbasictype"
condition|)
block|{
name|subtype
operator|=
name|Node
operator|::
name|QmlBasicType
expr_stmt|;
name|ptype
operator|=
name|Node
operator|::
name|ApiPage
expr_stmt|;
block|}
else|else
return|return;
name|FakeNode
modifier|*
name|fakeNode
init|=
operator|new
name|FakeNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|subtype
argument_list|,
name|ptype
argument_list|)
decl_stmt|;
name|fakeNode
operator|->
name|setTitle
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"location"
argument_list|)
condition|)
name|name
operator|=
name|element
operator|.
name|attribute
argument_list|(
literal|"location"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|section
operator|=
name|fakeNode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"enum"
condition|)
block|{
name|EnumNode
modifier|*
name|enumNode
init|=
operator|new
name|EnumNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|EnumItem
name|item
argument_list|(
name|child
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"value"
argument_list|)
argument_list|)
decl_stmt|;
name|enumNode
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|section
operator|=
name|enumNode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"typedef"
condition|)
block|{
name|section
operator|=
operator|new
name|TypedefNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"property"
condition|)
block|{
name|section
operator|=
operator|new
name|PropertyNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"function"
condition|)
block|{
name|FunctionNode
operator|::
name|Virtualness
name|virt
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"non"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|NonVirtual
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"impure"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|ImpureVirtual
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"virtual"
argument_list|)
operator|==
literal|"pure"
condition|)
name|virt
operator|=
name|FunctionNode
operator|::
name|PureVirtual
expr_stmt|;
else|else
return|return;
name|FunctionNode
operator|::
name|Metaness
name|meta
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"plain"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Plain
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"signal"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Signal
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"slot"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Slot
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"constructor"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Ctor
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"destructor"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|Dtor
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macro"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithParams
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macrowithparams"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithParams
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|attribute
argument_list|(
literal|"meta"
argument_list|)
operator|==
literal|"macrowithoutparams"
condition|)
name|meta
operator|=
name|FunctionNode
operator|::
name|MacroWithoutParams
expr_stmt|;
else|else
return|return;
name|FunctionNode
modifier|*
name|functionNode
init|=
operator|new
name|FunctionNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|functionNode
operator|->
name|setReturnType
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"return"
argument_list|)
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setVirtualness
argument_list|(
name|virt
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setMetaness
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setConst
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"const"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setStatic
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"static"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
name|functionNode
operator|->
name|setOverload
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"overload"
argument_list|)
operator|==
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|hasAttribute
argument_list|(
literal|"relates"
argument_list|)
operator|&&
name|element
operator|.
name|attribute
argument_list|(
literal|"relates"
argument_list|)
operator|!=
name|parent
operator|->
name|name
argument_list|()
condition|)
block|{
name|priv
operator|->
name|relatedList
operator|.
name|append
argument_list|(
name|QPair
argument_list|<
name|FunctionNode
operator|*
argument_list|,
name|QString
argument_list|>
argument_list|(
name|functionNode
argument_list|,
name|element
operator|.
name|attribute
argument_list|(
literal|"relates"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|(
literal|"parameter"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Do not use the default value for the parameter; it is not
comment|// required, and has been known to cause problems.
name|Parameter
name|parameter
argument_list|(
name|child
operator|.
name|attribute
argument_list|(
literal|"left"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"right"
argument_list|)
argument_list|,
name|child
operator|.
name|attribute
argument_list|(
literal|"name"
argument_list|)
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// child.attribute("default")
name|functionNode
operator|->
name|addParameter
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|(
literal|"parameter"
argument_list|)
expr_stmt|;
block|}
name|section
operator|=
name|functionNode
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"variable"
condition|)
block|{
name|section
operator|=
operator|new
name|VariableNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isNull
argument_list|()
condition|)
name|location
operator|=
name|Location
argument_list|(
name|parent
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|".html"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"keyword"
condition|)
block|{
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|parent
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|target
operator|.
name|atom
operator|=
operator|new
name|Atom
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"target"
condition|)
block|{
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|parent
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|2
expr_stmt|;
name|target
operator|.
name|atom
operator|=
operator|new
name|Atom
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"contents"
condition|)
block|{
name|Target
name|target
decl_stmt|;
name|target
operator|.
name|node
operator|=
name|parent
expr_stmt|;
name|target
operator|.
name|priority
operator|=
literal|3
expr_stmt|;
name|target
operator|.
name|atom
operator|=
operator|new
name|Atom
argument_list|(
name|Atom
operator|::
name|Target
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|priv
operator|->
name|targetHash
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
return|return;
name|QString
name|access
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"access"
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
operator|==
literal|"public"
condition|)
name|section
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|"protected"
condition|)
name|section
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|"private"
condition|)
name|section
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Private
argument_list|)
expr_stmt|;
else|else
name|section
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"page"
operator|)
operator|&&
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"qmlclass"
operator|)
operator|&&
operator|(
name|element
operator|.
name|nodeName
argument_list|()
operator|!=
literal|"qmlbasictype"
operator|)
condition|)
block|{
name|QString
name|threadSafety
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"threadsafety"
argument_list|)
decl_stmt|;
if|if
condition|(
name|threadSafety
operator|==
literal|"non-reentrant"
condition|)
name|section
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|NonReentrant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|threadSafety
operator|==
literal|"reentrant"
condition|)
name|section
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|Reentrant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|threadSafety
operator|==
literal|"thread safe"
condition|)
name|section
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|ThreadSafe
argument_list|)
expr_stmt|;
else|else
name|section
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|UnspecifiedSafeness
argument_list|)
expr_stmt|;
block|}
else|else
name|section
operator|->
name|setThreadSafeness
argument_list|(
name|Node
operator|::
name|UnspecifiedSafeness
argument_list|)
expr_stmt|;
name|QString
name|status
init|=
name|element
operator|.
name|attribute
argument_list|(
literal|"status"
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|"compat"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Compat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"obsolete"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"deprecated"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Deprecated
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"preliminary"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Preliminary
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"commendable"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Commendable
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"internal"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Internal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|"main"
condition|)
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Main
argument_list|)
expr_stmt|;
else|else
name|section
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Commendable
argument_list|)
expr_stmt|;
name|section
operator|->
name|setModuleName
argument_list|(
name|element
operator|.
name|attribute
argument_list|(
literal|"module"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexUrl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|indexUrl
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|section
operator|->
name|setUrl
argument_list|(
name|href
argument_list|)
expr_stmt|;
else|else
name|section
operator|->
name|setUrl
argument_list|(
name|indexUrl
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|href
argument_list|)
expr_stmt|;
block|}
comment|// Create some content for the node.
name|QSet
argument_list|<
name|QString
argument_list|>
name|emptySet
decl_stmt|;
name|Doc
name|doc
argument_list|(
name|location
argument_list|,
name|location
argument_list|,
literal|" "
argument_list|,
name|emptySet
argument_list|)
decl_stmt|;
comment|// placeholder
name|section
operator|->
name|setDoc
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|section
operator|->
name|setIndexNodeFlag
argument_list|()
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|QDomElement
name|child
init|=
name|element
operator|.
name|firstChildElement
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"class"
condition|)
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"qmlclass"
condition|)
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"page"
condition|)
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|.
name|nodeName
argument_list|()
operator|==
literal|"namespace"
operator|&&
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// The root node in the index is a namespace with an empty name.
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|inner
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
else|else
name|readIndexSection
argument_list|(
name|child
argument_list|,
name|parent
argument_list|,
name|indexUrl
argument_list|)
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSiblingElement
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|readIndexText
name|QString
name|Tree
operator|::
name|readIndexText
parameter_list|(
specifier|const
name|QDomElement
modifier|&
name|element
parameter_list|)
block|{
name|QString
name|text
decl_stmt|;
name|QDomNode
name|child
init|=
name|element
operator|.
name|firstChild
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|child
operator|.
name|isText
argument_list|()
condition|)
name|text
operator|+=
name|child
operator|.
name|toText
argument_list|()
operator|.
name|nodeValue
argument_list|()
expr_stmt|;
name|child
operator|=
name|child
operator|.
name|nextSibling
argument_list|()
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveIndex
name|void
name|Tree
operator|::
name|resolveIndex
parameter_list|()
block|{
name|QPair
argument_list|<
name|ClassNode
modifier|*
argument_list|,
name|QString
argument_list|>
name|pair
decl_stmt|;
foreach|foreach
control|(
name|pair
init|,
name|priv
operator|->
name|basesList
control|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|base
decl|,
name|pair
operator|.
name|second
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|root
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|base
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|pair
operator|.
name|first
operator|->
name|addBaseClass
argument_list|(
name|Node
operator|::
name|Public
argument_list|,
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QPair
argument_list|<
name|FunctionNode
modifier|*
argument_list|,
name|QString
argument_list|>
name|relatedPair
decl_stmt|;
foreach|foreach
control|(
name|relatedPair
init|,
name|priv
operator|->
name|relatedList
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|root
argument_list|()
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|relatedPair
operator|.
name|second
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|relatedPair
operator|.
name|first
operator|->
name|setRelates
argument_list|(
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Generate the index section with the given \a writer for the \a node   specified, returning true if an element was written; otherwise returns   false.  */
end_comment
begin_function
DECL|function|generateIndexSection
name|bool
name|Tree
operator|::
name|generateIndexSection
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|nodeName
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|nodeName
operator|=
literal|"namespace"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|nodeName
operator|=
literal|"class"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Fake
case|:
name|nodeName
operator|=
literal|"page"
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
name|nodeName
operator|=
literal|"qmlclass"
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
condition|)
name|nodeName
operator|=
literal|"qmlbasictype"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|nodeName
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|nodeName
operator|=
literal|"typedef"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|nodeName
operator|=
literal|"property"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|nodeName
operator|=
literal|"function"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|nodeName
operator|=
literal|"variable"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|nodeName
operator|=
literal|"qmlproperty"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|nodeName
operator|=
literal|"qmlsignal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|nodeName
operator|=
literal|"qmlsignalhandler"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|nodeName
operator|=
literal|"qmlmethod"
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
name|QString
name|access
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|access
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Public
case|:
name|access
operator|=
literal|"public"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Protected
case|:
name|access
operator|=
literal|"protected"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Private
case|:
comment|// Do not include private non-internal nodes in the index.
comment|// (Internal public and protected nodes are marked as private
comment|// by qdoc. We can check their internal status to determine
comment|// whether they were really private to begin with.)
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Internal
operator|&&
name|generateInternalNodes
condition|)
name|access
operator|=
literal|"internal"
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
name|QString
name|objName
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
comment|// Special case: only the root node should have an empty name.
if|if
condition|(
name|objName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|node
operator|!=
name|root
argument_list|()
condition|)
return|return
literal|false
return|;
name|writer
operator|.
name|writeStartElement
argument_list|(
name|nodeName
argument_list|)
expr_stmt|;
name|QXmlStreamAttributes
name|attributes
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"access"
argument_list|,
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Fake
condition|)
block|{
name|QString
name|threadSafety
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|threadSafeness
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|NonReentrant
case|:
name|threadSafety
operator|=
literal|"non-reentrant"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Reentrant
case|:
name|threadSafety
operator|=
literal|"reentrant"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ThreadSafe
case|:
name|threadSafety
operator|=
literal|"thread safe"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|UnspecifiedSafeness
case|:
default|default:
name|threadSafety
operator|=
literal|"unspecified"
expr_stmt|;
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"threadsafety"
argument_list|,
name|threadSafety
argument_list|)
expr_stmt|;
block|}
name|QString
name|status
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Compat
case|:
name|status
operator|=
literal|"compat"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Obsolete
case|:
name|status
operator|=
literal|"obsolete"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Deprecated
case|:
name|status
operator|=
literal|"deprecated"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Preliminary
case|:
name|status
operator|=
literal|"preliminary"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Commendable
case|:
name|status
operator|=
literal|"commendable"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Internal
case|:
name|status
operator|=
literal|"internal"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Main
case|:
default|default:
name|status
operator|=
literal|"main"
expr_stmt|;
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
name|QString
name|fullName
init|=
name|node
operator|->
name|fullDocumentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullName
operator|!=
name|objName
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"fullname"
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
name|QString
name|href
init|=
name|node
operator|->
name|outputSubdirectory
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|href
operator|.
name|isEmpty
argument_list|()
condition|)
name|href
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|href
operator|.
name|append
argument_list|(
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"href"
argument_list|,
name|href
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|isQmlNode
argument_list|()
operator|)
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"location"
argument_list|,
name|node
operator|->
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Class
case|:
block|{
comment|// Classes contain information about their base classes.
specifier|const
name|ClassNode
modifier|*
name|classNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
name|bases
init|=
name|classNode
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|baseStrings
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|related
decl|,
name|bases
control|)
block|{
name|ClassNode
modifier|*
name|baseClassNode
init|=
name|related
operator|.
name|node
decl_stmt|;
name|baseStrings
operator|.
name|insert
argument_list|(
name|baseClassNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"bases"
argument_list|,
name|QStringList
argument_list|(
name|baseStrings
operator|.
name|toList
argument_list|()
argument_list|)
operator|.
name|join
argument_list|(
literal|","
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|node
operator|->
name|moduleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"module"
argument_list|,
name|node
operator|->
name|moduleName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Fake
case|:
block|{
comment|/*               Fake nodes (such as manual pages) contain subtypes,               titles and other attributes.             */
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Example
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"example"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|HeaderFile
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|File
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Group
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Module
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"module"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Page
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"page"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|ExternalPage
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtype"
argument_list|,
literal|"externalpage"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlClass
case|:
comment|//writer.writeAttribute("subtype", "qmlclass");
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
comment|//writer.writeAttribute("subtype", "qmlbasictype");
break|break;
default|default:
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|fakeNode
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"fulltitle"
argument_list|,
name|fakeNode
operator|->
name|fullTitle
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"subtitle"
argument_list|,
name|fakeNode
operator|->
name|subTitle
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"location"
argument_list|,
name|fakeNode
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
comment|/*               Function nodes contain information about the type of               function being described.             */
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|functionNode
operator|->
name|virtualness
argument_list|()
condition|)
block|{
case|case
name|FunctionNode
operator|::
name|NonVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"non"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|ImpureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"impure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|PureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"pure"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|functionNode
operator|->
name|metaness
argument_list|()
condition|)
block|{
case|case
name|FunctionNode
operator|::
name|Plain
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"plain"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Signal
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Slot
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Ctor
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|Dtor
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"destructor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|MacroWithParams
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"macrowithparams"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|MacroWithoutParams
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"meta"
argument_list|,
literal|"macrowithoutparams"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"const"
argument_list|,
name|functionNode
operator|->
name|isConst
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"static"
argument_list|,
name|functionNode
operator|->
name|isStatic
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"overload"
argument_list|,
name|functionNode
operator|->
name|isOverload
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|isOverload
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"overload-number"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|functionNode
operator|->
name|overloadNumber
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|relates
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"relates"
argument_list|,
name|functionNode
operator|->
name|relates
argument_list|()
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|PropertyNode
modifier|*
name|propertyNode
init|=
name|functionNode
operator|->
name|associatedProperty
argument_list|()
decl_stmt|;
if|if
condition|(
name|propertyNode
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"associated-property"
argument_list|,
name|propertyNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|functionNode
operator|->
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|qpn
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"attached"
argument_list|,
name|qpn
operator|->
name|isAttached
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"writable"
argument_list|,
name|qpn
operator|->
name|isWritable
argument_list|(
name|this
argument_list|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Property
case|:
block|{
specifier|const
name|PropertyNode
modifier|*
name|propertyNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|propertyNode
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|getters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"getter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// getter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|setters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"setter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// setter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|resetters
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"resetter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// resetter
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|fnNode
decl|,
name|propertyNode
operator|->
name|notifiers
argument_list|()
control|)
block|{
if|if
condition|(
name|fnNode
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fnNode
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"notifier"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|functionNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// notifier
block|}
block|}
block|}
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
block|{
specifier|const
name|VariableNode
modifier|*
name|variableNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|VariableNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|variableNode
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"static"
argument_list|,
name|variableNode
operator|->
name|isStatic
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// Inner nodes and function nodes contain child nodes of some sort, either
comment|// actual child nodes or function parameters. For these, we close the
comment|// opening tag, create child elements, then add a closing tag for the
comment|// element. Elements for all other nodes are closed in the opening tag.
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// For internal pages, we canonicalize the target, keyword and content
comment|// item names so that they can be used by qdoc for other sets of
comment|// documentation.
comment|// The reason we do this here is that we don't want to ruin
comment|// externally composed indexes, containing non-qdoc-style target names
comment|// when reading in indexes.
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
name|bool
name|external
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|inner
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
name|external
operator|=
literal|true
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|Atom
modifier|*
name|target
decl|,
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
control|)
block|{
name|QString
name|targetName
init|=
name|target
operator|->
name|string
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
name|targetName
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|targetName
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"target"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|targetName
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// target
block|}
block|}
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|Atom
modifier|*
name|keyword
decl|,
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"keyword"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|keyword
operator|->
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// keyword
block|}
block|}
if|if
condition|(
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Atom
modifier|*
name|item
init|=
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|int
name|level
init|=
name|inner
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContentsLevels
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|item
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"contents"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"level"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// contents
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// Write a signature attribute for convenience.
name|QStringList
name|signatureList
decl_stmt|;
name|QStringList
name|resolvedParameters
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|parameter
decl|,
name|functionNode
operator|->
name|parameters
argument_list|()
control|)
block|{
name|QString
name|leftType
init|=
name|parameter
operator|.
name|leftType
argument_list|()
decl_stmt|;
specifier|const
name|Node
modifier|*
name|leftNode
init|=
cast|const_cast
argument_list|<
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|leftNode
operator|||
name|leftNode
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Typedef
condition|)
block|{
name|leftNode
operator|=
cast|const_cast
argument_list|<
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
name|node
operator|->
name|parent
argument_list|()
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftNode
operator|&&
name|leftNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
if|if
condition|(
name|leftNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|leftNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|leftType
operator|=
literal|"QFlags<"
operator|+
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|leftType
operator|=
name|leftNode
operator|->
name|fullDocumentName
argument_list|()
expr_stmt|;
block|}
name|resolvedParameters
operator|.
name|append
argument_list|(
name|leftType
argument_list|)
expr_stmt|;
name|signatureList
operator|.
name|append
argument_list|(
name|leftType
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|parameter
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|signature
init|=
name|functionNode
operator|->
name|name
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
operator|+
name|signatureList
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|isConst
argument_list|()
condition|)
name|signature
operator|+=
literal|" const"
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"signature"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|functionNode
operator|->
name|parameters
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Parameter
name|parameter
init|=
name|functionNode
operator|->
name|parameters
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"parameter"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"left"
argument_list|,
name|resolvedParameters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"right"
argument_list|,
name|parameter
operator|.
name|rightType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|parameter
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"default"
argument_list|,
name|parameter
operator|.
name|defaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// parameter
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
condition|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enumNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|enumNode
operator|->
name|flagsType
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"typedef"
argument_list|,
name|enumNode
operator|->
name|flagsType
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|enumNode
operator|->
name|items
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|item
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"value"
argument_list|,
name|item
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// value
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"enum"
argument_list|,
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node \a n1 is less than node \a n2.     The comparison is performed by comparing properties of the nodes in order     of increasing complexity. */
end_comment
begin_function
DECL|function|compareNodes
name|bool
name|compareNodes
parameter_list|(
specifier|const
name|Node
modifier|*
name|n1
parameter_list|,
specifier|const
name|Node
modifier|*
name|n2
parameter_list|)
block|{
comment|// Private nodes can occur in any order since they won't normally be
comment|// written to the index.
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|&&
name|n2
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|n1
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
operator|<
name|n2
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
operator|>
name|n2
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|<
name|n2
operator|->
name|type
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|>
name|n2
operator|->
name|type
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|name
argument_list|()
operator|<
name|n2
operator|->
name|name
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|name
argument_list|()
operator|>
name|n2
operator|->
name|name
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|<
name|n2
operator|->
name|access
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|n1
operator|->
name|access
argument_list|()
operator|>
name|n2
operator|->
name|access
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
operator|&&
name|n2
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|f1
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|n1
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|f2
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|n2
argument_list|)
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|<
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|>
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|f1
operator|->
name|signature
argument_list|()
operator|<
name|f2
operator|->
name|signature
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|signature
argument_list|()
operator|>
name|f2
operator|->
name|signature
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|n1
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|&&
name|n2
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|f1
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|n1
argument_list|)
decl_stmt|;
specifier|const
name|FakeNode
modifier|*
name|f2
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|n2
argument_list|)
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|fullTitle
argument_list|()
operator|<
name|f2
operator|->
name|fullTitle
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|f1
operator|->
name|fullTitle
argument_list|()
operator|>
name|f2
operator|->
name|fullTitle
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Generate index sections for the child nodes of the given \a node     using the \a writer specified. If \a generateInternalNodes is true,     nodes marked as internal will be included in the index; otherwise,     they will be omitted. */
end_comment
begin_function
DECL|function|generateIndexSections
name|void
name|Tree
operator|::
name|generateIndexSections
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
if|if
condition|(
name|generateIndexSection
argument_list|(
name|writer
argument_list|,
name|node
argument_list|,
name|generateInternalNodes
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|inner
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeList
name|cnodes
init|=
name|inner
operator|->
name|childNodes
argument_list|()
decl_stmt|;
name|qSort
argument_list|(
name|cnodes
operator|.
name|begin
argument_list|()
argument_list|,
name|cnodes
operator|.
name|end
argument_list|()
argument_list|,
name|compareNodes
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|cnodes
control|)
block|{
comment|/*                   Don't generate anything for a QML property group node.                   It is just a place holder for a collection of QML property                   nodes. Recurse to its children, which are the QML property                   nodes.                  */
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
specifier|const
name|InnerNode
modifier|*
name|pgn
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|c
decl|,
name|pgn
operator|->
name|childNodes
argument_list|()
control|)
block|{
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|c
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|child
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
block|}
comment|/*             foreach (const Node* child, inner->relatedNodes()) {                 QDomElement childElement = generateIndexSections(document, child);                 element.appendChild(childElement);             } */
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Outputs an index file.  */
end_comment
begin_function
DECL|function|generateIndex
name|void
name|Tree
operator|::
name|generateIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|bool
name|generateInternalNodes
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
return|return ;
name|QXmlStreamWriter
name|writer
argument_list|(
operator|&
name|file
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartDocument
argument_list|()
expr_stmt|;
name|writer
operator|.
name|writeDTD
argument_list|(
literal|"<!DOCTYPE QDOCINDEX>"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"INDEX"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"url"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"title"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"version"
argument_list|,
name|version
argument_list|()
argument_list|)
expr_stmt|;
name|generateIndexSections
argument_list|(
name|writer
argument_list|,
name|root
argument_list|()
argument_list|,
name|generateInternalNodes
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// INDEX
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// QDOCINDEX
name|writer
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Generate the tag file section with the given \a writer for the \a node   specified, returning true if an element was written; otherwise returns   false.  */
end_comment
begin_function
DECL|function|generateTagFileCompounds
name|void
name|Tree
operator|::
name|generateTagFileCompounds
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|inner
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QString
name|kind
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|kind
operator|=
literal|"namespace"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|kind
operator|=
literal|"class"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
case|case
name|Node
operator|::
name|Typedef
case|:
case|case
name|Node
operator|::
name|Property
case|:
case|case
name|Node
operator|::
name|Function
case|:
case|case
name|Node
operator|::
name|Variable
case|:
default|default:
continue|continue;
block|}
name|QString
name|access
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|access
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Public
case|:
name|access
operator|=
literal|"public"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Protected
case|:
name|access
operator|=
literal|"protected"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Private
case|:
default|default:
continue|continue;
block|}
name|QString
name|objName
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
comment|// Special case: only the root node should have an empty name.
if|if
condition|(
name|objName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|node
operator|!=
name|root
argument_list|()
condition|)
continue|continue;
comment|// *** Write the starting tag for the element here. ***
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"compound"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"kind"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|node
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"filename"
argument_list|,
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Classes contain information about their base classes.
specifier|const
name|ClassNode
modifier|*
name|classNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
name|bases
init|=
name|classNode
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|related
decl|,
name|bases
control|)
block|{
name|ClassNode
modifier|*
name|baseClassNode
init|=
name|related
operator|.
name|node
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"base"
argument_list|,
name|baseClassNode
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Recurse to write all members.
name|generateTagFileMembers
argument_list|(
name|writer
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// Recurse to write all compounds.
name|generateTagFileCompounds
argument_list|(
name|writer
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|node
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"filename"
argument_list|,
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Recurse to write all members.
name|generateTagFileMembers
argument_list|(
name|writer
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// Recurse to write all compounds.
name|generateTagFileCompounds
argument_list|(
name|writer
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|generateTagFileMembers
name|void
name|Tree
operator|::
name|generateTagFileMembers
parameter_list|(
name|QXmlStreamWriter
modifier|&
name|writer
parameter_list|,
specifier|const
name|InnerNode
modifier|*
name|inner
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|inner
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QString
name|nodeName
decl_stmt|;
name|QString
name|kind
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Enum
case|:
name|nodeName
operator|=
literal|"member"
expr_stmt|;
name|kind
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|nodeName
operator|=
literal|"member"
expr_stmt|;
name|kind
operator|=
literal|"typedef"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|nodeName
operator|=
literal|"member"
expr_stmt|;
name|kind
operator|=
literal|"property"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|nodeName
operator|=
literal|"member"
expr_stmt|;
name|kind
operator|=
literal|"function"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|nodeName
operator|=
literal|"namespace"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|nodeName
operator|=
literal|"class"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
default|default:
continue|continue;
block|}
name|QString
name|access
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|access
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Public
case|:
name|access
operator|=
literal|"public"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Protected
case|:
name|access
operator|=
literal|"protected"
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Private
case|:
default|default:
continue|continue;
block|}
name|QString
name|objName
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
comment|// Special case: only the root node should have an empty name.
if|if
condition|(
name|objName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|node
operator|!=
name|root
argument_list|()
condition|)
continue|continue;
comment|// *** Write the starting tag for the element here. ***
name|writer
operator|.
name|writeStartElement
argument_list|(
name|nodeName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kind
operator|.
name|isEmpty
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"kind"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Class
case|:
name|writer
operator|.
name|writeCharacters
argument_list|(
name|node
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Namespace
case|:
name|writer
operator|.
name|writeCharacters
argument_list|(
name|node
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
comment|/*                   Function nodes contain information about                   the type of function being described.                 */
specifier|const
name|FunctionNode
modifier|*
name|functionNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"protection"
argument_list|,
name|access
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|functionNode
operator|->
name|virtualness
argument_list|()
condition|)
block|{
case|case
name|FunctionNode
operator|::
name|NonVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtualness"
argument_list|,
literal|"non"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|ImpureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtualness"
argument_list|,
literal|"virtual"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FunctionNode
operator|::
name|PureVirtual
case|:
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"virtual"
argument_list|,
literal|"pure"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"static"
argument_list|,
name|functionNode
operator|->
name|isStatic
argument_list|()
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"type"
argument_list|,
name|functionNode
operator|->
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"type"
argument_list|,
literal|"virtual "
operator|+
name|functionNode
operator|->
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
init|=
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchorfile"
argument_list|,
name|pieces
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchor"
argument_list|,
name|pieces
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// Write a signature attribute for convenience.
name|QStringList
name|signatureList
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|parameter
decl|,
name|functionNode
operator|->
name|parameters
argument_list|()
control|)
block|{
name|QString
name|leftType
init|=
name|parameter
operator|.
name|leftType
argument_list|()
decl_stmt|;
specifier|const
name|Node
modifier|*
name|leftNode
init|=
cast|const_cast
argument_list|<
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|leftNode
operator|||
name|leftNode
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Typedef
condition|)
block|{
name|leftNode
operator|=
cast|const_cast
argument_list|<
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findNode
argument_list|(
name|parameter
operator|.
name|leftType
argument_list|()
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|,
name|node
operator|->
name|parent
argument_list|()
argument_list|,
name|SearchBaseClasses
operator||
name|NonFunction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftNode
operator|&&
name|leftNode
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|leftNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
name|leftType
operator|=
literal|"QFlags<"
operator|+
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
name|signatureList
operator|.
name|append
argument_list|(
name|leftType
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|parameter
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|signature
init|=
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
operator|+
name|signatureList
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|isConst
argument_list|()
condition|)
name|signature
operator|+=
literal|" const"
expr_stmt|;
if|if
condition|(
name|functionNode
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|PureVirtual
condition|)
name|signature
operator|+=
literal|" = 0"
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"arglist"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// member
break|break;
case|case
name|Node
operator|::
name|Property
case|:
block|{
specifier|const
name|PropertyNode
modifier|*
name|propertyNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|propertyNode
operator|->
name|dataType
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
init|=
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchorfile"
argument_list|,
name|pieces
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchor"
argument_list|,
name|pieces
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"arglist"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// member
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
block|{
specifier|const
name|EnumNode
modifier|*
name|enumNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
init|=
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchor"
argument_list|,
name|pieces
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"arglist"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// member
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumNode
operator|->
name|items
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|EnumItem
name|item
init|=
name|enumNode
operator|->
name|items
argument_list|()
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"member"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"name"
argument_list|,
name|item
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchor"
argument_list|,
name|pieces
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"arglist"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// member
block|}
block|}
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedefNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
condition|)
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
name|typedefNode
operator|->
name|associatedEnum
argument_list|()
operator|->
name|fullDocumentName
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writer
operator|.
name|writeAttribute
argument_list|(
literal|"type"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"name"
argument_list|,
name|objName
argument_list|)
expr_stmt|;
name|QStringList
name|pieces
init|=
name|Generator
operator|::
name|fullDocumentLocation
argument_list|(
name|node
argument_list|,
literal|true
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchorfile"
argument_list|,
name|pieces
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"anchor"
argument_list|,
name|pieces
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeTextElement
argument_list|(
literal|"arglist"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// member
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Writes a tag file named \a fileName.  */
end_comment
begin_function
DECL|function|generateTagFile
name|void
name|Tree
operator|::
name|generateTagFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
return|return ;
name|QXmlStreamWriter
name|writer
argument_list|(
operator|&
name|file
argument_list|)
decl_stmt|;
name|writer
operator|.
name|setAutoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeStartDocument
argument_list|()
expr_stmt|;
name|writer
operator|.
name|writeStartElement
argument_list|(
literal|"tagfile"
argument_list|)
expr_stmt|;
name|generateTagFileCompounds
argument_list|(
name|writer
argument_list|,
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeEndElement
argument_list|()
expr_stmt|;
comment|// tagfile
name|writer
operator|.
name|writeEndDocument
argument_list|()
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addExternalLink
name|void
name|Tree
operator|::
name|addExternalLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|FakeNode
modifier|*
name|fakeNode
init|=
operator|new
name|FakeNode
argument_list|(
name|root
argument_list|()
argument_list|,
name|url
argument_list|,
name|Node
operator|::
name|ExternalPage
argument_list|,
name|Node
operator|::
name|ArticlePage
argument_list|)
decl_stmt|;
name|fakeNode
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Public
argument_list|)
expr_stmt|;
comment|// Create some content for the node.
name|QSet
argument_list|<
name|QString
argument_list|>
name|emptySet
decl_stmt|;
name|Location
name|location
argument_list|(
name|relative
operator|->
name|doc
argument_list|()
operator|.
name|location
argument_list|()
argument_list|)
decl_stmt|;
name|Doc
name|doc
argument_list|(
name|location
argument_list|,
name|location
argument_list|,
literal|" "
argument_list|,
name|emptySet
argument_list|)
decl_stmt|;
comment|// placeholder
name|fakeNode
operator|->
name|setDoc
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Find the node with the specified \a path name that is of   the specified \a type and \a subtype. Begin the search at   the \a start node. If the \a start node is 0, begin the   search at the tree root. \a subtype is not used unless   \a type is \c{Fake}.  */
end_comment
begin_function
DECL|function|findNodeByNameAndType
name|Node
modifier|*
name|Tree
operator|::
name|findNodeByNameAndType
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
name|bool
name|acceptCollision
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|Node
modifier|*
name|result
init|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|,
name|acceptCollision
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), the \a type   must match the type of the last matching node, and if the   type is \e{Fake}, the \a subtype must match as well.    If the algorithm is successful, the pointer to the final   node is returned. Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|,
name|bool
name|acceptCollision
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no place to start, or nothing to search for.
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
name|start
return|;
comment|// found a match.
return|return
literal|0
return|;
comment|// premature leaf
block|}
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// end of search path.
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|subtype
condition|)
return|return
name|n
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|&&
name|acceptCollision
condition|)
return|return
name|n
return|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|Node
operator|::
name|NoSubType
condition|)
return|return
name|n
return|;
comment|// don't care what subtype is.
return|return
literal|0
return|;
block|}
else|else
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|isCollisionNode
argument_list|()
condition|)
block|{
if|if
condition|(
name|acceptCollision
condition|)
return|return
name|n
return|;
return|return
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|// Not at the end of the path.
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Enum type node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only an Enum type node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findEnumNode
name|EnumNode
modifier|*
name|Tree
operator|::
name|findEnumNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Enum
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the C++ class node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a C++ class node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findClassNode
name|ClassNode
modifier|*
name|Tree
operator|::
name|findClassNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Class
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Qml class node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Qml class node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlClassNode
name|QmlClassNode
modifier|*
name|Tree
operator|::
name|findQmlClassNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
comment|/*       If the path contains one or two double colons ("::"),       check first to see if the first two path strings refer       to a QML element. If they do, path[0] will be the QML       module identifier, and path[1] will be the QML type.       If the anser is yes, the reference identifies a QML       class node.     */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|QmlClassNode
operator|::
name|lookupQmlTypeNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Fake
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Namespace node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Namespace node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findNamespaceNode
name|NamespaceNode
modifier|*
name|Tree
operator|::
name|findNamespaceNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Group node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Group node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findGroupNode
name|FakeNode
modifier|*
name|Tree
operator|::
name|findGroupNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Fake
argument_list|,
name|Node
operator|::
name|Group
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Qml module node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Qml module node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlModuleNode
name|FakeNode
modifier|*
name|Tree
operator|::
name|findQmlModuleNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Fake
argument_list|,
name|Node
operator|::
name|QmlModule
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
