begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"location.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class Tree    This class constructs and maintains a tree of instances of   the subclasses of Node.    This class is now private. Only class QDocDatabase has access.   Please don't change this. If you must access class Tree, do it   though the pointer to the singleton QDocDatabase.    Tree is being converted to a forest. A static member provides a   map of Tree* values with the module names as the keys. There is   one Tree in the map for each index file read, and there is one   tree that is not in the map for the module whose documentation   is being generated.  */
end_comment
begin_comment
comment|/*!   Constructs a Tree. \a qdb is the pointer to the singleton   qdoc database that is constructing the tree. This might not   be necessary, and it might be removed later.  */
end_comment
begin_constructor
DECL|function|Tree
name|Tree
operator|::
name|Tree
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|,
name|QDocDatabase
modifier|*
name|qdb
parameter_list|)
member_init_list|:
name|module_
argument_list|(
name|module
argument_list|)
member_init_list|,
name|qdb_
argument_list|(
name|qdb
argument_list|)
member_init_list|,
name|root_
argument_list|(
literal|0
argument_list|,
name|QString
argument_list|()
argument_list|)
block|{
name|root_
operator|.
name|setModuleName
argument_list|(
name|module_
argument_list|)
expr_stmt|;
name|root_
operator|.
name|setTree
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the Tree. The root node is a data member   of this object, so its destructor is called. The   destructor of each child node is called, and these   destructors are recursive. Thus the entire tree is   destroyed.  */
end_comment
begin_destructor
DECL|function|~Tree
name|Tree
operator|::
name|~
name|Tree
parameter_list|()
block|{
comment|// nothing
block|}
end_destructor
begin_comment
comment|/* API members */
end_comment
begin_comment
comment|/*!   Find the C++ class node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a C++ class node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findClassNode
name|ClassNode
modifier|*
name|Tree
operator|::
name|findClassNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Namespace node named \a path. Begin the search at   the root of the tree. Only a Namespace node named \a path   is acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findNamespaceNode
name|NamespaceNode
modifier|*
name|Tree
operator|::
name|findNamespaceNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|start
init|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function first ignores the \a clone node and searches   for the parent node with \a parentPath. If that search is   successful, it searches for a child node of the parent that   matches the \a clone node. If it finds a node that is just   like the \a clone, it returns a pointer to the found node.    There should be a way to avoid creating the clone in the   first place. Investigate when time allows.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|parent
init|=
name|findNamespaceNode
argument_list|(
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findClassNode
argument_list|(
name|parentPath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findNode
argument_list|(
name|parentPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
operator|||
operator|!
name|parent
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|parent
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Qml type node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Qml type node named<\a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlTypeNode
name|QmlClassNode
modifier|*
name|Tree
operator|::
name|findQmlTypeNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
block|{
comment|/*       If the path contains one or two double colons ("::"),       check first to see if the first two path strings refer       to a QML element. If they do, path[0] will be the QML       module identifier, and path[1] will be the QML type.       If the anser is yes, the reference identifies a QML       class node.     */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   First, search for a node with the specified \a name. If a matching   node is found, if it is a collision node, another collision with   this name has been found, so return the collision node. If the   matching node is not a collision node, the first collision for this   name has been found, so create a NameCollisionNode with the matching   node as its first child, and return a pointer to the new   NameCollisionNode. Otherwise return 0.  */
end_comment
begin_function
DECL|function|checkForCollision
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|checkForCollision
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
if|if
condition|(
name|n
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
operator|new
name|NameCollisionNode
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function is like checkForCollision() in that it searches   for a collision node with the specified \a name. But it doesn't   create anything. If it finds a match, it returns the pointer.   Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|findCollisionNode
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|findCollisionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function begins searching the tree at \a relative for   the \l {FunctionNode} {function node} identified by \a path.   The \a findFlags are used to restrict the search. If a node   that matches the \a path is found, it is returned. Otherwise,   0 is returned. If \a relative is 0, the root of the tree is   used as the starting point.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|relative
condition|)
name|relative
operator|=
name|root
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|lookupQmlType
argument_list|(
name|QString
argument_list|(
name|path
index|[
literal|0
index|]
operator|+
literal|"::"
operator|+
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qcn
condition|)
block|{
name|QStringList
name|p
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|findNodeByNameAndType
argument_list|(
name|p
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|isQmlType
argument_list|()
condition|)
name|qcn
operator|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
decl_stmt|;
name|ncn
operator|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|qcn
operator|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|ncn
operator|->
name|findAny
argument_list|(
name|Node
operator|::
name|QmlType
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|qcn
condition|)
return|return
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|findFunctionNode
argument_list|(
name|path
index|[
literal|2
index|]
argument_list|)
argument_list|)
return|;
block|}
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
name|node
operator|->
name|isFunction
argument_list|()
condition|)
block|{
comment|// CppCodeParser::processOtherMetaCommand ensures that reimplemented
comment|// functions are private.
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
return|return
name|from
return|;
else|else
name|func
operator|=
name|from
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|func
return|;
block|}
name|relative
operator|=
name|relative
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|relative
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|t
specifier|static
name|NodeTypeList
name|t
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|relatesTypes
specifier|static
specifier|const
name|NodeTypeList
modifier|&
name|relatesTypes
parameter_list|()
block|{
if|if
condition|(
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Class
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Namespace
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|HeaderFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for the node specified by \a path.   The matching node can be one of several different types   including a C++ class, a C++ namespace, or a C++ header   file.    I'm not sure if it can be a QML type, but if that is a   possibility, the code can easily accommodate it.    If a matching node is found, a pointer to it is returned.   Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findRelatesNode
name|InnerNode
modifier|*
name|Tree
operator|::
name|findRelatesNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|relatesTypes
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|n
operator|&&
name|n
operator|->
name|isInnerNode
argument_list|()
operator|)
condition|?
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addPropertyFunction
name|void
name|Tree
operator|::
name|addPropertyFunction
parameter_list|(
name|PropertyNode
modifier|*
name|property
parameter_list|,
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|,
name|PropertyNode
operator|::
name|FunctionRole
name|funcRole
parameter_list|)
block|{
name|unresolvedPropertyMap
index|[
name|property
index|]
operator|.
name|insert
argument_list|(
name|funcRole
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function resolves C++ inheritance and reimplementation   settings for each C++ class node found in the tree beginning   at \a n. It also calls itself recursively for each C++ class   node or namespace node it encounters. For each child of \a n   that is a class node, it calls resolveInheritanceHelper().    This function does not resolve QML inheritance.  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|InnerNode
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|root
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|resolveInheritanceHelper
argument_list|(
name|pass
argument_list|,
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
name|resolveInheritance
argument_list|(
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|resolveInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function is run twice for eachclass node \a cn in the   tree. First it is run with \a pass set to 0 for each  class node \a cn. Then it is run with \a pass set to 1 for   eachclass node \a cn.    In \a pass 0, all the base classes ofclass node \a cn are   found and added to the base class list forclass node \a cn.    In \a pass 1, each child ofclass node \a cn that is a function   that is reimplemented from one of the base classes is marked   as being reimplemented from that class.    Some property node fixing up is also done in \a pass 1.  */
end_comment
begin_function
DECL|function|resolveInheritanceHelper
name|void
name|Tree
operator|::
name|resolveInheritanceHelper
parameter_list|(
name|int
name|pass
parameter_list|,
name|ClassNode
modifier|*
name|cn
parameter_list|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|cn
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|iterator
name|b
init|=
name|bases
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|bases
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|b
operator|)
operator|.
name|node_
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|path_
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/*                   If the node for the base class was not found,                   the reason might be that the subclass is in a                   namespace and the base class is in the same                   namespace, but the base class name was not                   qualified with the namespace name. That is the                   case most of the time. Then restart the search                   at the parent of the subclass node (the namespace                   node) using the unqualified base class name.                  */
block|if (!n) {                     InnerNode* parent = cn->parent();                     n = findClassNode((*b).path_, parent);                 }
endif|#
directive|endif
if|if
condition|(
name|n
condition|)
block|{
name|ClassNode
modifier|*
name|bcn
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
operator|(
operator|*
name|b
operator|)
operator|.
name|node_
operator|=
name|bcn
expr_stmt|;
name|bcn
operator|->
name|addDerivedClass
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|access_
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|cn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|cn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
decl_stmt|;
name|FunctionNode
modifier|*
name|from
init|=
name|findVirtualFunctionInBaseClasses
argument_list|(
name|cn
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|func
operator|->
name|setVirtualness
argument_list|(
name|FunctionNode
operator|::
name|ImpureVirtual
argument_list|)
expr_stmt|;
name|func
operator|->
name|setReimplementedFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
name|cn
operator|->
name|fixPropertyUsingBaseClasses
argument_list|(
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveProperties
name|void
name|Tree
operator|::
name|resolveProperties
parameter_list|()
block|{
name|PropertyMap
operator|::
name|ConstIterator
name|propEntry
decl_stmt|;
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|property
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QString
name|getterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Getter
index|]
decl_stmt|;
name|QString
name|setterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Setter
index|]
decl_stmt|;
name|QString
name|resetterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Resetter
index|]
decl_stmt|;
name|QString
name|notifierName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Notifier
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|access
argument_list|()
operator|==
name|property
operator|->
name|access
argument_list|()
operator|&&
operator|(
name|function
operator|->
name|status
argument_list|()
operator|==
name|property
operator|->
name|status
argument_list|()
operator|||
name|function
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|getterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Getter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|setterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Setter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|resetterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Resetter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|notifierName
condition|)
block|{
name|property
operator|->
name|addSignal
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Notifier
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
operator|++
name|propEntry
expr_stmt|;
block|}
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
comment|// redo it to set the property functions
if|if
condition|(
name|property
operator|->
name|overriddenFrom
argument_list|()
condition|)
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|property
operator|->
name|overriddenFrom
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|propEntry
expr_stmt|;
block|}
name|unresolvedPropertyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   For each QML class node that points to a C++ class node,   follow its C++ class node pointer and set the C++ class   node's QML class node pointer back to the QML class node.  */
end_comment
begin_function
DECL|function|resolveCppToQmlLinks
name|void
name|Tree
operator|::
name|resolveCppToQmlLinks
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root_
operator|.
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
cast|const_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|classNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cn
condition|)
name|cn
operator|->
name|setQmlElement
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixInheritance
name|void
name|Tree
operator|::
name|fixInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|->
name|fixBaseClasses
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|fixInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findVirtualFunctionInBaseClasses
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findVirtualFunctionInBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|rc
init|=
name|cn
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|rc
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|rc
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|func
operator|=
name|findVirtualFunctionInBaseClasses
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
argument_list|,
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|func
operator|=
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
return|return
name|func
return|;
block|}
block|}
operator|++
name|r
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|allBaseClasses
name|NodeList
name|Tree
operator|::
name|allBaseClasses
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classNode
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|r
decl|,
name|classNode
operator|->
name|baseClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|node_
condition|)
block|{
name|result
operator|+=
name|r
operator|.
name|node_
expr_stmt|;
name|result
operator|+=
name|allBaseClasses
argument_list|(
name|r
operator|.
name|node_
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Find the node with the specified \a path name that is of   the specified \a type and \a subtype. Begin the search at   the \a start node. If the \a start node is 0, begin the   search at the tree root. \a subtype is not used unless   \a type is \c{Document}.  */
end_comment
begin_function
DECL|function|findNodeByNameAndType
name|Node
modifier|*
name|Tree
operator|::
name|findNodeByNameAndType
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
specifier|const
block|{
return|return
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*!   Find the node with the specified \a path name that is of   the specified \a type and \a subtype. Begin the search at   the \a start node. If the \a start node is 0, begin the   search at the tree root. \a subtype is not used unless   \a type is \c{Document}.  */
end_comment
begin_endif
unit|Node* Tree::findHtmlFileNode(const QStringList& path) const {     return findNodeRecursive(path, 0, root()); }
endif|#
directive|endif
end_endif
begin_comment
comment|/* internal members */
end_comment
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), the \a type   must match the type of the last matching node, and if the   type is \e{Document}, the \a subtype must match as well.    If the algorithm is successful, the pointer to the final   node is returned. Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no place to start, or nothing to search for.
name|Node
modifier|*
name|node
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
name|node
return|;
comment|// found a match.
return|return
literal|0
return|;
comment|// premature leaf
block|}
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
return|return
name|n
return|;
continue|continue;
block|}
else|else
block|{
comment|// Search the children of n for the next name in the path.
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a name match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), test the   matching node's type and subtype values against the ones   listed in \a types. If a match is found there, return the   pointer to the final node. Otherwise return 0.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
specifier|const
name|NodeTypeList
modifier|&
name|types
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
return|return
operator|(
operator|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
operator|)
condition|?
name|start
else|:
literal|0
operator|)
return|;
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|name
argument_list|()
operator|==
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|match
argument_list|(
name|types
argument_list|)
condition|)
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|n
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Searches the tree for a node that matches the \a path. The   search begins at \a start but can move up the parent chain   recursively if no match is found.    This findNode() callse the other findNode(), which is not   called anywhere else.  */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       First, search for a node assuming we don't want a QML node.       If that search fails, search again assuming we do want a       QML node.      */
specifier|const
name|Node
modifier|*
name|n
init|=
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
return|return
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This overload function was extracted from the one above that has the   same signature without the last bool parameter, \a qml. This version   is called only by that other one. It is therefore private.  It can   be called a second time by that other version, if the first call   returns null. If \a qml is false, the search will only match a node   that is not a QML node.  If \a qml is true, the search will only   match a node that is a QML node.    This findNode() is only called by the other findNode(). */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
name|bool
name|qml
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|current
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_idx
init|=
literal|0
decl_stmt|;
comment|/*           If the path contains one or two double colons ("::"),           check first to see if the first two path strings refer           to a QML element. If they do, path[0] will be the QML           module identifier, and path[1] will be the QML type.           If the anser is yes, the reference identifies a QML           class node.         */
if|if
condition|(
name|qml
operator|&&
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|lookupQmlType
argument_list|(
name|QString
argument_list|(
name|path
index|[
literal|0
index|]
operator|+
literal|"::"
operator|+
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
name|node
operator|=
name|qcn
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|node
return|;
name|start_idx
operator|=
literal|2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|qml
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|next
operator|&&
operator|!
name|qml
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
break|break;
block|}
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|!
operator|(
name|findFlags
operator|&
name|NonFunction
operator|)
operator|||
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Function
operator|||
operator|(
operator|(
name|FunctionNode
operator|*
operator|)
name|node
operator|)
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithoutParams
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|isCollisionNode
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|applyModuleName
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|current
operator|=
name|current
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|current
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with a canonical title   constructed from \a target. If the node it finds is \a node,   it returns the ref from that node. Otherwise it returns an   empty string.  */
end_comment
begin_function
DECL|function|findTarget
name|QString
name|Tree
operator|::
name|findTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetMap
operator|::
name|const_iterator
name|i
init|=
name|nodesByTarget_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|nodesByTarget_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|node_
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|.
name|ref_
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|nodesByTarget_
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
do|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Inserts a new target into the target table. \a name is the   key. The target record contains the \a type, a pointer to   the \a node, the \a priority. and a canonicalized form of   the \a name, which is later used.  */
end_comment
begin_function
DECL|function|insertTarget
name|void
name|Tree
operator|::
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|TargetRec
operator|::
name|Type
name|type
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|type_
operator|=
name|type
expr_stmt|;
name|target
operator|.
name|node_
operator|=
name|node
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
name|priority
expr_stmt|;
name|target
operator|.
name|ref_
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nodesByTarget_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveTargets
name|void
name|Tree
operator|::
name|resolveTargets
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// need recursion
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|DocNode
modifier|*
name|node
init|=
cast|static_cast
argument_list|<
name|DocNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|node
operator|->
name|title
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|DocNode
modifier|*
argument_list|>
name|nodes
init|=
name|docNodesByTitle_
operator|.
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|bool
name|alreadyThere
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|empty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|==
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|()
condition|)
block|{
name|alreadyThere
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|alreadyThere
condition|)
block|{
name|docNodesByTitle_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|resolveTargets
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|nodesByTarget_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|keywords
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|nodesByTarget_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
decl_stmt|;
name|TargetRec
name|target
decl_stmt|;
name|target
operator|.
name|node_
operator|=
name|child
expr_stmt|;
name|target
operator|.
name|priority_
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|target
operator|.
name|ref_
operator|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
argument_list|)
decl_stmt|;
name|nodesByTarget_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function searches for a \a target anchor node. If it   finds one, it sets \a ref and returns the found node.  */
end_comment
begin_function
specifier|const
name|Node
modifier|*
DECL|function|findUnambiguousTarget
name|Tree
operator|::
name|findUnambiguousTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
block|{
name|TargetRec
name|bestTarget
decl_stmt|;
name|int
name|numBestTargets
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|TargetRec
argument_list|>
name|bestTargetList
decl_stmt|;
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|TargetMap
operator|::
name|iterator
name|i
init|=
name|nodesByTarget_
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|nodesByTarget_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|!=
name|key
condition|)
break|break;
specifier|const
name|TargetRec
modifier|&
name|candidate
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|<
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|.
name|priority_
operator|==
name|bestTarget
operator|.
name|priority_
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|numBestTargets
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numBestTargets
operator|==
literal|1
condition|)
block|{
name|ref
operator|=
name|bestTarget
operator|.
name|ref_
expr_stmt|;
return|return
name|bestTarget
operator|.
name|node_
return|;
block|}
elseif|else
if|if
condition|(
name|bestTargetList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|#
directive|if
literal|0
block|qDebug()<< "TARGET:"<< target<< numBestTargets;             for (int i=0; i<bestTargetList.size(); ++i) {                 const Node* n = bestTargetList.at(i).node_;                 qDebug()<< "  "<< n->name()<< n->title();             }
endif|#
directive|endif
name|ref
operator|=
name|bestTargetList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|ref_
expr_stmt|;
return|return
name|bestTargetList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|node_
return|;
block|}
block|}
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with the specified \a title.  */
end_comment
begin_function
DECL|function|findDocNodeByTitle
specifier|const
name|DocNode
modifier|*
name|Tree
operator|::
name|findDocNodeByTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
specifier|const
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|DocNodeMultiMap
operator|::
name|const_iterator
name|i
init|=
name|docNodesByTitle_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|/*           Reporting all these duplicate section titles is probably           overkill. We should report the duplicate file and let           that suffice.         */
name|DocNodeMultiMap
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Location
argument_list|>
name|internalLocations
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
operator|&&
name|j
operator|.
name|value
argument_list|()
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|internalLocations
operator|.
name|append
argument_list|(
name|j
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|// Just report one duplicate for now.
block|}
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|internalLocations
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|i
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
literal|"This page title exists in more than one file: "
operator|+
name|title
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Location
modifier|&
name|location
decl|,
name|internalLocations
control|)
name|location
operator|.
name|warning
argument_list|(
literal|"[It also exists here]"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a canonical title for the \a atom, if the \a atom   is a SectionLeft or a Target.  */
end_comment
begin_function
DECL|function|refForAtom
name|QString
name|Tree
operator|::
name|refForAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Target
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \fn const CNMap& Tree::groups() const   Returns a const reference to the collection of all   group nodes. */
end_comment
begin_comment
comment|/*!   \fn const ModuleMap& Tree::modules() const   Returns a const reference to the collection of all   module nodes. */
end_comment
begin_comment
comment|/*!   \fn const QmlModuleMap& Tree::qmlModules() const   Returns a const reference to the collection of all   QML module nodes. */
end_comment
begin_comment
comment|/*!   Returns the collection node in this tree that has the same   name and type as \a cn. Returns 0 if no match is found.    If the matching node is \a cn, return 0.  */
end_comment
begin_function
DECL|function|getCorrespondingCollection
name|CollectionNode
modifier|*
name|Tree
operator|::
name|getCorrespondingCollection
parameter_list|(
name|CollectionNode
modifier|*
name|cn
parameter_list|)
block|{
name|CollectionNode
modifier|*
name|ccn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cn
operator|->
name|isGroup
argument_list|()
condition|)
name|ccn
operator|=
name|getGroup
argument_list|(
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cn
operator|->
name|isModule
argument_list|()
condition|)
name|ccn
operator|=
name|getModule
argument_list|(
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cn
operator|->
name|isQmlModule
argument_list|()
condition|)
name|ccn
operator|=
name|getQmlModule
argument_list|(
name|cn
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccn
operator|==
name|cn
condition|)
name|ccn
operator|=
literal|0
expr_stmt|;
return|return
name|ccn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the group node named \a name and return a pointer   to it. If a matching node is not found, return 0.  */
end_comment
begin_function
DECL|function|getGroup
name|GroupNode
modifier|*
name|Tree
operator|::
name|getGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|groups_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|groups_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|GroupNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the module node named \a name and return a pointer   to it. If a matching node is not found, return 0.  */
end_comment
begin_function
DECL|function|getModule
name|ModuleNode
modifier|*
name|Tree
operator|::
name|getModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|ModuleNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, return 0.  */
end_comment
begin_function
DECL|function|getQmlModule
name|QmlModuleNode
modifier|*
name|Tree
operator|::
name|getQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|qmlModules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|qmlModules_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlModuleNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the group node named \a name and return a pointer   to it. If the group node is not found, add a new group   node named \a name and return a pointer to the new one.    If a new group node is added, its parent is the tree root,   and the new group node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findGroup
name|GroupNode
modifier|*
name|Tree
operator|::
name|findGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|groups_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|groups_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|GroupNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
empty_stmt|;
name|GroupNode
modifier|*
name|gn
init|=
operator|new
name|GroupNode
argument_list|(
name|root
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|gn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|groups_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
return|return
name|gn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the module node named \a name and return a pointer   to it. If a matching node is not found, add a new module   node named \a name and return a pointer to that one.    If a new module node is added, its parent is the tree root,   and the new module node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findModule
name|ModuleNode
modifier|*
name|Tree
operator|::
name|findModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|modules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|modules_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|ModuleNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
name|ModuleNode
modifier|*
name|mn
init|=
operator|new
name|ModuleNode
argument_list|(
name|root
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|mn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|modules_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|mn
argument_list|)
expr_stmt|;
return|return
name|mn
return|;
block|}
end_function
begin_comment
comment|/*!   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, add a new QML module   node named \a name and return a pointer to that one.    If a new QML module node is added, its parent is the tree root,   and the new QML module node is marked \e{not seen}.  */
end_comment
begin_function
DECL|function|findQmlModule
name|QmlModuleNode
modifier|*
name|Tree
operator|::
name|findQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|qmlModules_
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|qmlModules_
operator|.
name|end
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlModuleNode
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|)
return|;
name|QmlModuleNode
modifier|*
name|qmn
init|=
operator|new
name|QmlModuleNode
argument_list|(
name|root
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|qmn
operator|->
name|setQmlModuleInfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|qmlModules_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|qmn
argument_list|)
expr_stmt|;
return|return
name|qmn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the group node named \a name in the collection   of all group nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new group node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_function
DECL|function|addGroup
name|GroupNode
modifier|*
name|Tree
operator|::
name|addGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|GroupNode
modifier|*
name|group
init|=
name|findGroup
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|group
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_function
DECL|function|addModule
name|ModuleNode
modifier|*
name|Tree
operator|::
name|addModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ModuleNode
modifier|*
name|module
init|=
name|findModule
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|module
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module node named \a name in the collection   of all QML module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new QML module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_function
DECL|function|addQmlModule
name|QmlModuleNode
modifier|*
name|Tree
operator|::
name|addQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|QmlModuleNode
modifier|*
name|qmn
init|=
name|findQmlModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|setQmlModuleInfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|qmn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the group node named \a name in the collection   of all group nodes. If a match is not found, a new group   node named \a name is created and inserted into the collection.   Then append \a node to the group's members list, and append the   group name to the list of group names in \a node. The parent of   \a node is not changed by this function. Returns a pointer to   the group node.  */
end_comment
begin_function
DECL|function|addToGroup
name|GroupNode
modifier|*
name|Tree
operator|::
name|addToGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|GroupNode
modifier|*
name|gn
init|=
name|findGroup
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInternal
argument_list|()
condition|)
block|{
name|gn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendGroupName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|gn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is not found, a new module   node named \a name is created and inserted into the collection.   Then append \a node to the module's members list. The parent of   \a node is not changed by this function. Returns the module node.  */
end_comment
begin_function
DECL|function|addToModule
name|ModuleNode
modifier|*
name|Tree
operator|::
name|addToModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|ModuleNode
modifier|*
name|mn
init|=
name|findModule
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|mn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setModuleName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|mn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.   Returns the pointer to the QML module node.  */
end_comment
begin_function
DECL|function|addToQmlModule
name|QmlModuleNode
modifier|*
name|Tree
operator|::
name|addToQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QStringList
name|qmid
decl_stmt|;
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|blankSplit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|QmlModuleNode
modifier|*
name|qmn
init|=
name|findQmlModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|qmn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setQmlModule
argument_list|(
name|qmn
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmid
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|key
init|=
name|qmid
index|[
name|i
index|]
operator|+
literal|"::"
operator|+
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
name|insertQmlType
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|qmn
return|;
block|}
end_function
begin_comment
comment|/*!   If the QML type map does not contain \a key, insert node   \a n with the specified \a key.  */
end_comment
begin_function
DECL|function|insertQmlType
name|void
name|Tree
operator|::
name|insertQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QmlClassNode
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qmlTypeMap_
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
name|qmlTypeMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Split \a target on "::" and find the function node with that   path.  */
end_comment
begin_function
DECL|function|resolveFunctionTarget
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|resolveFunctionTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
block|{
name|QString
name|t
init|=
name|target
decl_stmt|;
name|t
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|QStringList
name|path
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|SearchBaseClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|&&
name|fn
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
return|return
name|fn
return|;
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
