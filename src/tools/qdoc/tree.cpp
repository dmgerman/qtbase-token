begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"location.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class Tree    This class constructs and maintains a tree of instances of   the subclasses of Node.    This class is now private. Only class QDocDatabase has access.   Please don't change this. If you must access class Tree, do it   though the pointer to the singleton QDocDatabase.  */
end_comment
begin_comment
comment|/*!   Constructs the singleton tree. \a qdb is the pointer to the   qdoc database that is constructing the tree. This might not   be necessary, and it might be removed later.  */
end_comment
begin_constructor
DECL|function|Tree
name|Tree
operator|::
name|Tree
parameter_list|(
name|QDocDatabase
modifier|*
name|qdb
parameter_list|)
member_init_list|:
name|qdb_
argument_list|(
name|qdb
argument_list|)
member_init_list|,
name|root_
argument_list|(
literal|0
argument_list|,
name|QString
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys the singleton Tree.  */
end_comment
begin_destructor
DECL|function|~Tree
name|Tree
operator|::
name|~
name|Tree
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|// 1 calls 2
end_comment
begin_comment
comment|/*!   Searches the tree for a node that matches the \a path. The   search begins at \a start but can move up the parent chain   recursively if no match is found.  */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       First, search for a node assuming we don't want a QML node.       If that search fails, search again assuming we do want a       QML node.      */
specifier|const
name|Node
modifier|*
name|n
init|=
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
name|self
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
name|findNode
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|findFlags
argument_list|,
name|self
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|// 2 is private; it is only called by 1.
end_comment
begin_comment
comment|/*!   This overload function was extracted from the one above that has the   same signature without the last bool parameter, \a qml. This version   is called only by that other one. It is therefore private.  It can   be called a second time by that other version, if the first call   returns null. If \a qml is false, the search will only match a node   that is not a QML node.  If \a qml is true, the search will only   match a node that is a QML node. */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
specifier|const
name|Node
modifier|*
name|self
parameter_list|,
name|bool
name|qml
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|current
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_idx
init|=
literal|0
decl_stmt|;
comment|/*           If the path contains one or two double colons ("::"),           check first to see if the first two path strings refer           to a QML element. If they do, path[0] will be the QML           module identifier, and path[1] will be the QML type.           If the anser is yes, the reference identifies a QML           class node.         */
if|if
condition|(
name|qml
operator|&&
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
name|node
operator|=
name|qcn
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|node
return|;
name|start_idx
operator|=
literal|2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|qml
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|!
name|qml
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|!
operator|(
name|findFlags
operator|&
name|NonFunction
operator|)
operator|||
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Function
operator|||
operator|(
operator|(
name|FunctionNode
operator|*
operator|)
name|node
operator|)
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithoutParams
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|!=
name|self
operator|)
operator|&&
operator|(
name|node
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|applyModuleName
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
block|}
name|current
operator|=
name|current
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|current
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Qml type node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Qml type node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlTypeNode
name|QmlClassNode
modifier|*
name|Tree
operator|::
name|findQmlTypeNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
block|{
comment|/*       If the path contains one or two double colons ("::"),       check first to see if the first two path strings refer       to a QML element. If they do, path[0] will be the QML       module identifier, and path[1] will be the QML type.       If the anser is yes, the reference identifies a QML       class node.     */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|QmlClass
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   First, search for a node with the specified \a name. If a matching   node is found, if it is a collision node, another collision with   this name has been found, so return the collision node. If the   matching node is not a collision node, the first collision for this   name has been found, so create a NameCollisionNode with the matching   node as its first child, and return a pointer to the new   NameCollisionNode. Otherwise return 0.  */
end_comment
begin_function
DECL|function|checkForCollision
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|checkForCollision
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
if|if
condition|(
name|n
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
operator|new
name|NameCollisionNode
argument_list|(
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function is like checkForCollision() in that it searches   for a collision node with the specified \a name. But it doesn't   create anything. If it finds a match, it returns the pointer.   Otherwise it returns 0.  */
end_comment
begin_function
DECL|function|findCollisionNode
name|NameCollisionNode
modifier|*
name|Tree
operator|::
name|findCollisionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|ncn
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function just calls the const version of the same function   and returns the function node.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function begins searching the tree at \a relative for   the \l {FunctionNode} {function node} identified by \a path.   The \a findFlags are used to restrict the search. If a node   that matches the \a path is found, it is returned. Otherwise,   0 is returned. If \a relative is 0, the root of the tree is   used as the starting point.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|relative
condition|)
name|relative
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       If the path contains two double colons ("::"), check       first to see if it is a reference to a QML method. If       it is a reference to a QML method, first look up the       QML class node in the QML module map.      */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|findFunctionNode
argument_list|(
name|path
index|[
literal|2
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
name|node
operator|->
name|isFunction
argument_list|()
condition|)
block|{
comment|// CppCodeParser::processOtherMetaCommand ensures that reimplemented
comment|// functions are private.
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
return|return
name|from
return|;
else|else
name|func
operator|=
name|from
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|func
return|;
block|}
name|relative
operator|=
name|relative
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|relative
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function just calls the const version of itself and   returns the result.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|,
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|Tree
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|parentPath
argument_list|,
name|clone
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function first ignores the \a clone node and searches   for the node having the \a parentPath by calling the main   findFunction(\a {parentPath}, \a {relative}, \a {findFlags}).   If that search is successful, then it searches for the \a clone   in the found parent node.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|parent
init|=
name|findNamespaceNode
argument_list|(
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findClassNode
argument_list|(
name|parentPath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findNode
argument_list|(
name|parentPath
argument_list|,
name|relative
argument_list|,
name|findFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
operator|||
operator|!
name|parent
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|parent
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addBaseClass
name|void
name|Tree
operator|::
name|addBaseClass
parameter_list|(
name|ClassNode
modifier|*
name|subclass
parameter_list|,
name|Node
operator|::
name|Access
name|access
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|basePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|dataTypeWithTemplateArgs
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|)
block|{
name|unresolvedInheritanceMap
index|[
name|subclass
index|]
operator|.
name|append
argument_list|(
name|InheritanceBound
argument_list|(
name|access
argument_list|,
name|basePath
argument_list|,
name|dataTypeWithTemplateArgs
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addPropertyFunction
name|void
name|Tree
operator|::
name|addPropertyFunction
parameter_list|(
name|PropertyNode
modifier|*
name|property
parameter_list|,
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|,
name|PropertyNode
operator|::
name|FunctionRole
name|funcRole
parameter_list|)
block|{
name|unresolvedPropertyMap
index|[
name|property
index|]
operator|.
name|insert
argument_list|(
name|funcRole
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function resolves inheritance and reimplementation settings   for each C++ class node found in the namspace beginning at \a rootNode.   If it finds another namespace node in the child list of \a rootNode,   it calls itself recursively. For each child of \a rootNode that is a   class node, it calls the other resolveInheritance() function.    This function does not resolve QML inheritance.  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|resolveInheritance
argument_list|(
name|pass
argument_list|,
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|resolveInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|rootNode
operator|==
name|root
argument_list|()
condition|)
name|unresolvedInheritanceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveProperties
name|void
name|Tree
operator|::
name|resolveProperties
parameter_list|()
block|{
name|PropertyMap
operator|::
name|ConstIterator
name|propEntry
decl_stmt|;
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|property
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QString
name|getterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Getter
index|]
decl_stmt|;
name|QString
name|setterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Setter
index|]
decl_stmt|;
name|QString
name|resetterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Resetter
index|]
decl_stmt|;
name|QString
name|notifierName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Notifier
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|access
argument_list|()
operator|==
name|property
operator|->
name|access
argument_list|()
operator|&&
operator|(
name|function
operator|->
name|status
argument_list|()
operator|==
name|property
operator|->
name|status
argument_list|()
operator|||
name|function
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|getterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Getter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|setterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Setter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|resetterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Resetter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|notifierName
condition|)
block|{
name|property
operator|->
name|addSignal
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Notifier
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
operator|++
name|propEntry
expr_stmt|;
block|}
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
comment|// redo it to set the property functions
if|if
condition|(
name|property
operator|->
name|overriddenFrom
argument_list|()
condition|)
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|property
operator|->
name|overriddenFrom
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|propEntry
expr_stmt|;
block|}
name|unresolvedPropertyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is run twice for each \a classNode in the   tree. First it is run with \a pass set to 0 for each   \a classNode. Then it is run with \a pass set to 1 for   each \a classNode.    In \a pass 0, all the base classes of \a classNode are   found and added to the base class list for \a classNode.    In \a pass 1, each child of \a classNode that is a function   that is reimplemented from one of the base classes is marked   as being reimplemented from that class.    Some property node fixing up is also done in \a pass 1.  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|int
name|pass
parameter_list|,
name|ClassNode
modifier|*
name|classNode
parameter_list|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|QList
argument_list|<
name|InheritanceBound
argument_list|>
name|bounds
init|=
name|unresolvedInheritanceMap
index|[
name|classNode
index|]
decl_stmt|;
name|QList
argument_list|<
name|InheritanceBound
argument_list|>
operator|::
name|ConstIterator
name|b
init|=
name|bounds
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|bounds
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|basePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|&&
operator|(
operator|*
name|b
operator|)
operator|.
name|parent
condition|)
block|{
name|n
operator|=
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|basePath
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|classNode
operator|->
name|addBaseClass
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|access
argument_list|,
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|.
name|dataTypeWithTemplateArgs
argument_list|)
expr_stmt|;
block|}
operator|++
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|classNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|classNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
decl_stmt|;
name|FunctionNode
modifier|*
name|from
init|=
name|findVirtualFunctionInBaseClasses
argument_list|(
name|classNode
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|func
operator|->
name|setVirtualness
argument_list|(
name|FunctionNode
operator|::
name|ImpureVirtual
argument_list|)
expr_stmt|;
name|func
operator|->
name|setReimplementedFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
block|{
name|fixPropertyUsingBaseClasses
argument_list|(
name|classNode
argument_list|,
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   For each QML class node that points to a C++ class node,   follow its C++ class node pointer and set the C++ class   node's QML class node pointer back to the QML class node.  */
end_comment
begin_function
DECL|function|resolveCppToQmlLinks
name|void
name|Tree
operator|::
name|resolveCppToQmlLinks
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root_
operator|.
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
cast|const_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|classNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cn
condition|)
name|cn
operator|->
name|setQmlElement
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixInheritance
name|void
name|Tree
operator|::
name|fixInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|->
name|fixBaseClasses
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|fixInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findVirtualFunctionInBaseClasses
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findVirtualFunctionInBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|classNode
parameter_list|,
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|classNode
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classNode
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|func
operator|=
name|findVirtualFunctionInBaseClasses
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node
argument_list|,
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|func
operator|=
operator|(
operator|*
name|r
operator|)
operator|.
name|node
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
return|return
name|func
return|;
block|}
operator|++
name|r
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixPropertyUsingBaseClasses
name|void
name|Tree
operator|::
name|fixPropertyUsingBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|classNode
parameter_list|,
name|PropertyNode
modifier|*
name|property
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|const_iterator
name|r
init|=
name|classNode
operator|->
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|classNode
operator|->
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|r
operator|->
name|node
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|property
operator|->
name|name
argument_list|()
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|PropertyNode
modifier|*
name|baseProperty
init|=
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|fixPropertyUsingBaseClasses
argument_list|(
name|r
operator|->
name|node
argument_list|,
name|baseProperty
argument_list|)
expr_stmt|;
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|baseProperty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixPropertyUsingBaseClasses
argument_list|(
name|r
operator|->
name|node
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
operator|++
name|r
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|allBaseClasses
name|NodeList
name|Tree
operator|::
name|allBaseClasses
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classNode
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|r
decl|,
name|classNode
operator|->
name|baseClasses
argument_list|()
control|)
block|{
name|result
operator|+=
name|r
operator|.
name|node
expr_stmt|;
name|result
operator|+=
name|allBaseClasses
argument_list|(
name|r
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Find the node with the specified \a path name that is of   the specified \a type and \a subtype. Begin the search at   the \a start node. If the \a start node is 0, begin the   search at the tree root. \a subtype is not used unless   \a type is \c{Document}.  */
end_comment
begin_function
DECL|function|findNodeByNameAndType
name|Node
modifier|*
name|Tree
operator|::
name|findNodeByNameAndType
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
name|bool
name|acceptCollision
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|Node
modifier|*
name|result
init|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|,
name|acceptCollision
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), the \a type   must match the type of the last matching node, and if the   type is \e{Document}, the \a subtype must match as well.    If the algorithm is successful, the pointer to the final   node is returned. Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|,
name|Node
operator|::
name|SubType
name|subtype
parameter_list|,
name|bool
name|acceptCollision
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no place to start, or nothing to search for.
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
name|start
return|;
comment|// found a match.
return|return
literal|0
return|;
comment|// premature leaf
block|}
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// end of search path.
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|subtype
condition|)
return|return
name|n
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|&&
name|acceptCollision
condition|)
return|return
name|n
return|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|Node
operator|::
name|NoSubType
condition|)
return|return
name|n
return|;
comment|// don't care what subtype is.
return|return
literal|0
return|;
block|}
else|else
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|isCollisionNode
argument_list|()
condition|)
block|{
if|if
condition|(
name|acceptCollision
condition|)
return|return
name|n
return|;
return|return
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|// Not at the end of the path.
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Enum type node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only an Enum type node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findEnumNode
name|EnumNode
modifier|*
name|Tree
operator|::
name|findEnumNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Enum
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the C++ class node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a C++ class node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findClassNode
name|ClassNode
modifier|*
name|Tree
operator|::
name|findClassNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Class
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Namespace node named \a path. Begin the search at   the root of the tree. Only a Namespace node named \a path   is acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findNamespaceNode
name|NamespaceNode
modifier|*
name|Tree
operator|::
name|findNamespaceNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|start
init|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
