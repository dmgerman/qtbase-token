begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"doc.h"
end_include
begin_include
include|#
directive|include
file|"htmlgenerator.h"
end_include
begin_include
include|#
directive|include
file|"location.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class Tree    This class constructs and maintains a tree of instances of   the subclasses of Node.    This class is now private. Only class QDocDatabase has access.   Please don't change this. If you must access class Tree, do it   though the pointer to the singleton QDocDatabase.    Tree is being converted to a forest. A static member provides a   map of Tree* values with the module names as the keys. There is   one Tree in the map for each index file read, and there is one   tree that is not in the map for the module whose documentation   is being generated.  */
end_comment
begin_comment
comment|/*!   Constructs a Tree. \a qdb is the pointer to the singleton   qdoc database that is constructing the tree. This might not   be necessary, and it might be removed later.  */
end_comment
begin_constructor
DECL|function|Tree
name|Tree
operator|::
name|Tree
parameter_list|(
specifier|const
name|QString
modifier|&
name|physicalModuleName
parameter_list|,
name|QDocDatabase
modifier|*
name|qdb
parameter_list|)
member_init_list|:
name|treeHasBeenAnalyzed_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|docsHaveBeenGenerated_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|linkCount_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|physicalModuleName_
argument_list|(
name|physicalModuleName
argument_list|)
member_init_list|,
name|qdb_
argument_list|(
name|qdb
argument_list|)
member_init_list|,
name|root_
argument_list|(
literal|0
argument_list|,
name|QString
argument_list|()
argument_list|)
member_init_list|,
name|targetListMap_
argument_list|(
literal|0
argument_list|)
block|{
name|root_
operator|.
name|setPhysicalModuleName
argument_list|(
name|physicalModuleName_
argument_list|)
expr_stmt|;
name|root_
operator|.
name|setTree
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|Generator
operator|::
name|writeQaPages
argument_list|()
condition|)
block|{
name|targetListMap_
operator|=
operator|new
name|TargetListMap
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Destroys the Tree. The root node is a data member   of this object, so its destructor is called. The   destructor of each child node is called, and these   destructors are recursive. Thus the entire tree is   destroyed.    There are two maps of targets, keywords, and contents.   One map is indexed by ref, the other by title. The ref   is just the canonical form of the title. Both maps   use the same set of TargetRec objects as the values,   so the destructor only deletes the values from one of   the maps. Then it clears both maps.  */
end_comment
begin_destructor
DECL|function|~Tree
name|Tree
operator|::
name|~
name|Tree
parameter_list|()
block|{
name|TargetMap
operator|::
name|iterator
name|i
init|=
name|nodesByTargetRef_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|nodesByTargetRef_
operator|.
name|end
argument_list|()
condition|)
block|{
operator|delete
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|nodesByTargetRef_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodesByTargetTitle_
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|Generator
operator|::
name|writeQaPages
argument_list|()
operator|&&
name|targetListMap_
condition|)
block|{
name|TargetListMap
operator|::
name|iterator
name|i
init|=
name|targetListMap_
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|targetListMap_
operator|->
name|end
argument_list|()
condition|)
block|{
name|TargetList
modifier|*
name|tlist
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlist
condition|)
block|{
foreach|foreach
control|(
name|TargetLoc
modifier|*
name|tloc
decl|,
operator|*
name|tlist
control|)
operator|delete
name|tloc
expr_stmt|;
block|}
operator|delete
name|tlist
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_destructor
begin_comment
comment|/* API members */
end_comment
begin_comment
comment|/*!   Calls findClassNode() first with \a path and \a start. If   it finds a node, the node is returned. If not, it calls   findNamespaceNode() with the same parameters. The result   is returned.  */
end_comment
begin_function
DECL|function|findNodeForInclude
name|Node
modifier|*
name|Tree
operator|::
name|findNodeForInclude
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|n
init|=
name|findClassNode
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|findNamespaceNode
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!   Find the C++ class node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a C++ class node named \a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findClassNode
name|ClassNode
modifier|*
name|Tree
operator|::
name|findClassNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Namespace node named \a path. Begin the search at   the root of the tree. Only a Namespace node named \a path   is acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findNamespaceNode
name|NamespaceNode
modifier|*
name|Tree
operator|::
name|findNamespaceNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|start
init|=
cast|const_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|root
argument_list|()
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function first ignores the \a clone node and searches   for the parent node with \a parentPath. If that search is   successful, it searches for a child node of the parent that   matches the \a clone node. If it finds a node that is just   like the \a clone, it returns a pointer to the found node.    Apparently the search order is important here. Don't change   it unless you know what you are doing, or you will introduce   qdoc warnings.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parentPath
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
specifier|const
name|Node
modifier|*
name|parent
init|=
name|findNamespaceNode
argument_list|(
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findClassNode
argument_list|(
name|parentPath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
name|parent
operator|=
name|findNode
argument_list|(
name|parentPath
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Node
operator|::
name|DontCare
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|0
operator|||
operator|!
name|parent
operator|->
name|isInnerNode
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|parent
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the Qml type node named \a path. Begin the search at the   \a start node. If the \a start node is 0, begin the search   at the root of the tree. Only a Qml type node named<\a path is   acceptible. If one is not found, 0 is returned.  */
end_comment
begin_function
DECL|function|findQmlTypeNode
name|QmlTypeNode
modifier|*
name|Tree
operator|::
name|findQmlTypeNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
block|{
comment|/*       If the path contains one or two double colons ("::"),       check first to see if the first two path strings refer       to a QML element. If they do, path[0] will be the QML       module identifier, and path[1] will be the QML type.       If the anser is yes, the reference identifies a QML       class node.     */
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|qdb_
operator|->
name|findQmlType
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
return|;
block|}
return|return
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function begins searching the tree at \a relative for   the \l {FunctionNode} {function node} identified by \a path.   The \a findFlags are used to restrict the search. If a node   that matches the \a path is found, it is returned. Otherwise,   0 is returned. If \a relative is 0, the root of the tree is   used as the starting point.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|int
name|findFlags
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|3
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|QML
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|)
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|lookupQmlType
argument_list|(
name|QString
argument_list|(
name|path
index|[
literal|0
index|]
operator|+
literal|"::"
operator|+
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qcn
condition|)
block|{
name|QStringList
name|p
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|findNodeByNameAndType
argument_list|(
name|p
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
condition|)
name|qcn
operator|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qcn
condition|)
return|return
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|findFunctionNode
argument_list|(
name|path
index|[
literal|2
index|]
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|relative
condition|)
name|relative
operator|=
name|root
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|genus
operator|!=
name|Node
operator|::
name|DontCare
condition|)
block|{
if|if
condition|(
name|genus
operator|!=
name|relative
operator|->
name|genus
argument_list|()
condition|)
name|relative
operator|=
name|root
argument_list|()
expr_stmt|;
block|}
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|relative
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
operator|(
operator|(
name|InnerNode
operator|*
operator|)
name|node
operator|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|genus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
name|node
operator|->
name|isClass
argument_list|()
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
if|if
condition|(
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findFunctionNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|genus
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|&&
name|node
operator|->
name|isFunction
argument_list|()
condition|)
block|{
comment|// CppCodeParser::processOtherMetaCommand ensures that reimplemented
comment|// functions are private.
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|func
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|from
init|=
name|func
operator|->
name|reimplementedFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|from
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
return|return
name|from
return|;
else|else
name|func
operator|=
name|from
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|func
return|;
block|}
name|relative
operator|=
name|relative
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|relative
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|t
specifier|static
name|NodeTypeList
name|t
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|relatesTypes
specifier|static
specifier|const
name|NodeTypeList
modifier|&
name|relatesTypes
parameter_list|()
block|{
if|if
condition|(
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Class
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Namespace
argument_list|,
name|Node
operator|::
name|NoSubType
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|NodeTypePair
argument_list|(
name|Node
operator|::
name|Document
argument_list|,
name|Node
operator|::
name|HeaderFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for the node specified by \a path.   The matching node can be one of several different types   including a C++ class, a C++ namespace, or a C++ header   file.    I'm not sure if it can be a QML type, but if that is a   possibility, the code can easily accommodate it.    If a matching node is found, a pointer to it is returned.   Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findRelatesNode
name|InnerNode
modifier|*
name|Tree
operator|::
name|findRelatesNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|relatesTypes
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|n
operator|&&
name|n
operator|->
name|isInnerNode
argument_list|()
operator|)
condition|?
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addPropertyFunction
name|void
name|Tree
operator|::
name|addPropertyFunction
parameter_list|(
name|PropertyNode
modifier|*
name|property
parameter_list|,
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|,
name|PropertyNode
operator|::
name|FunctionRole
name|funcRole
parameter_list|)
block|{
name|unresolvedPropertyMap
index|[
name|property
index|]
operator|.
name|insert
argument_list|(
name|funcRole
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function resolves C++ inheritance and reimplementation   settings for each C++ class node found in the tree beginning   at \a n. It also calls itself recursively for each C++ class   node or namespace node it encounters. For each child of \a n   that is a class node, it calls resolveInheritanceHelper().    This function does not resolve QML inheritance.  */
end_comment
begin_function
DECL|function|resolveInheritance
name|void
name|Tree
operator|::
name|resolveInheritance
parameter_list|(
name|InnerNode
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|root
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|n
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|resolveInheritanceHelper
argument_list|(
name|pass
argument_list|,
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
name|resolveInheritance
argument_list|(
operator|(
name|ClassNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|resolveInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function is run twice for eachclass node \a cn in the   tree. First it is run with \a pass set to 0 for each  class node \a cn. Then it is run with \a pass set to 1 for   eachclass node \a cn.    In \a pass 0, all the base classes ofclass node \a cn are   found and added to the base class list forclass node \a cn.    In \a pass 1, each child ofclass node \a cn that is a function   that is reimplemented from one of the base classes is marked   as being reimplemented from that class.    Some property node fixing up is also done in \a pass 1.  */
end_comment
begin_function
DECL|function|resolveInheritanceHelper
name|void
name|Tree
operator|::
name|resolveInheritanceHelper
parameter_list|(
name|int
name|pass
parameter_list|,
name|ClassNode
modifier|*
name|cn
parameter_list|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|cn
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|iterator
name|b
init|=
name|bases
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|bases
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|b
operator|)
operator|.
name|node_
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|qdb_
operator|->
name|findClassNode
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|path_
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/*                   If the node for the base class was not found,                   the reason might be that the subclass is in a                   namespace and the base class is in the same                   namespace, but the base class name was not                   qualified with the namespace name. That is the                   case most of the time. Then restart the search                   at the parent of the subclass node (the namespace                   node) using the unqualified base class name.                  */
block|if (!n) {                     InnerNode* parent = cn->parent();                     n = findClassNode((*b).path_, parent);                 }
endif|#
directive|endif
if|if
condition|(
name|n
condition|)
block|{
name|ClassNode
modifier|*
name|bcn
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
operator|(
operator|*
name|b
operator|)
operator|.
name|node_
operator|=
name|bcn
expr_stmt|;
name|bcn
operator|->
name|addDerivedClass
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|.
name|access_
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|cn
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|cn
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
decl_stmt|;
name|FunctionNode
modifier|*
name|from
init|=
name|findVirtualFunctionInBaseClasses
argument_list|(
name|cn
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|NonVirtual
condition|)
name|func
operator|->
name|setVirtualness
argument_list|(
name|FunctionNode
operator|::
name|ImpureVirtual
argument_list|)
expr_stmt|;
name|func
operator|->
name|setReimplementedFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
condition|)
name|cn
operator|->
name|fixPropertyUsingBaseClasses
argument_list|(
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveProperties
name|void
name|Tree
operator|::
name|resolveProperties
parameter_list|()
block|{
name|PropertyMap
operator|::
name|ConstIterator
name|propEntry
decl_stmt|;
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|property
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QString
name|getterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Getter
index|]
decl_stmt|;
name|QString
name|setterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Setter
index|]
decl_stmt|;
name|QString
name|resetterName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Resetter
index|]
decl_stmt|;
name|QString
name|notifierName
init|=
operator|(
operator|*
name|propEntry
operator|)
index|[
name|PropertyNode
operator|::
name|Notifier
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|parent
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|function
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|->
name|access
argument_list|()
operator|==
name|property
operator|->
name|access
argument_list|()
operator|&&
operator|(
name|function
operator|->
name|status
argument_list|()
operator|==
name|property
operator|->
name|status
argument_list|()
operator|||
name|function
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|getterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Getter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|setterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Setter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|resetterName
condition|)
block|{
name|property
operator|->
name|addFunction
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Resetter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|->
name|name
argument_list|()
operator|==
name|notifierName
condition|)
block|{
name|property
operator|->
name|addSignal
argument_list|(
name|function
argument_list|,
name|PropertyNode
operator|::
name|Notifier
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|++
name|c
expr_stmt|;
block|}
operator|++
name|propEntry
expr_stmt|;
block|}
name|propEntry
operator|=
name|unresolvedPropertyMap
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|propEntry
operator|!=
name|unresolvedPropertyMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|property
init|=
name|propEntry
operator|.
name|key
argument_list|()
decl_stmt|;
comment|// redo it to set the property functions
if|if
condition|(
name|property
operator|->
name|overriddenFrom
argument_list|()
condition|)
name|property
operator|->
name|setOverriddenFrom
argument_list|(
name|property
operator|->
name|overriddenFrom
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|propEntry
expr_stmt|;
block|}
name|unresolvedPropertyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   For each QML class node that points to a C++ class node,   follow its C++ class node pointer and set the C++ class   node's QML class node pointer back to the QML class node.  */
end_comment
begin_function
DECL|function|resolveCppToQmlLinks
name|void
name|Tree
operator|::
name|resolveCppToQmlLinks
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root_
operator|.
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|isQmlType
argument_list|()
operator|||
name|child
operator|->
name|isJsType
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
cast|const_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|qcn
operator|->
name|classNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cn
condition|)
name|cn
operator|->
name|setQmlElement
argument_list|(
name|qcn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixInheritance
name|void
name|Tree
operator|::
name|fixInheritance
parameter_list|(
name|NamespaceNode
modifier|*
name|rootNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
condition|)
name|rootNode
operator|=
name|root
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|rootNode
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
operator|->
name|fixBaseClasses
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|NamespaceNode
modifier|*
name|ns
init|=
cast|static_cast
argument_list|<
name|NamespaceNode
operator|*
argument_list|>
argument_list|(
operator|*
name|c
argument_list|)
decl_stmt|;
name|fixInheritance
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findVirtualFunctionInBaseClasses
name|FunctionNode
modifier|*
name|Tree
operator|::
name|findVirtualFunctionInBaseClasses
parameter_list|(
name|ClassNode
modifier|*
name|cn
parameter_list|,
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|rc
init|=
name|cn
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|ConstIterator
name|r
init|=
name|rc
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|rc
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|func
operator|=
name|findVirtualFunctionInBaseClasses
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
argument_list|,
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|func
operator|=
operator|(
operator|*
name|r
operator|)
operator|.
name|node_
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|func
operator|->
name|virtualness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|NonVirtual
condition|)
return|return
name|func
return|;
block|}
block|}
operator|++
name|r
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|allBaseClasses
name|NodeList
name|Tree
operator|::
name|allBaseClasses
parameter_list|(
specifier|const
name|ClassNode
modifier|*
name|classNode
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|RelatedClass
modifier|&
name|r
decl|,
name|classNode
operator|->
name|baseClasses
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|node_
condition|)
block|{
name|result
operator|+=
name|r
operator|.
name|node_
expr_stmt|;
name|result
operator|+=
name|allBaseClasses
argument_list|(
name|r
operator|.
name|node_
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Find the node with the specified \a path name that is of   the specified \a type and \a subtype. Begin the search at   the \a start node. If the \a start node is 0, begin the   search at the tree root. \a subtype is not used unless   \a type is \c{Document}.  */
end_comment
begin_function
DECL|function|findNodeByNameAndType
name|Node
modifier|*
name|Tree
operator|::
name|findNodeByNameAndType
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
specifier|const
block|{
return|return
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|root
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), the \a type   must match the type of the last matching node, and if the   type is \e{Document}, the \a subtype must match as well.    If the algorithm is successful, the pointer to the final   node is returned. Otherwise 0 is returned.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|Node
operator|::
name|Type
name|type
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no place to start, or nothing to search for.
name|Node
modifier|*
name|node
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
name|node
return|;
comment|// found a match.
return|return
literal|0
return|;
comment|// premature leaf
block|}
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
argument_list|,
name|n
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|type
operator|)
operator|||
operator|(
name|type
operator|==
name|Node
operator|::
name|NoType
operator|)
condition|)
return|return
name|n
return|;
continue|continue;
block|}
else|else
block|{
comment|// Search the children of n for the next name in the path.
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive search for a node identified by \a path. Each   path element is a name. \a pathIndex specifies the index   of the name in \a path to try to match. \a start is the   node whose children shoulod be searched for one that has   that name. Each time a name match is found, increment the   \a pathIndex and call this function recursively.    If the end of the path is reached (i.e. if a matching   node is found for each name in the \a path), test the   matching node's type and subtype values against the ones   listed in \a types. If a match is found there, return the   pointer to the final node. Otherwise return 0.  */
end_comment
begin_function
DECL|function|findNodeRecursive
name|Node
modifier|*
name|Tree
operator|::
name|findNodeRecursive
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|pathIndex
parameter_list|,
name|Node
modifier|*
name|start
parameter_list|,
specifier|const
name|NodeTypeList
modifier|&
name|types
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|start
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|start
operator|->
name|isLeaf
argument_list|()
condition|)
return|return
operator|(
operator|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
operator|)
condition|?
name|start
else|:
literal|0
operator|)
return|;
if|if
condition|(
name|pathIndex
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
name|InnerNode
modifier|*
name|current
init|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|start
argument_list|)
decl_stmt|;
specifier|const
name|NodeList
modifier|&
name|children
init|=
name|current
operator|->
name|childNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|name
argument_list|()
operator|==
name|path
operator|.
name|at
argument_list|(
name|pathIndex
argument_list|)
condition|)
block|{
if|if
condition|(
name|pathIndex
operator|+
literal|1
operator|>=
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|match
argument_list|(
name|types
argument_list|)
condition|)
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|n
operator|->
name|isLeaf
argument_list|()
condition|)
block|{
name|n
operator|=
name|findNodeRecursive
argument_list|(
name|path
argument_list|,
name|pathIndex
operator|+
literal|1
argument_list|,
name|n
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Searches the tree for a node that matches the \a path plus   the \a target. The search begins at \a start and moves up   the parent chain from there, or, if \a start is 0, the search   begins at the root.    The \a flags can indicate whether to search base classes and/or   the enum values in enum types. \a genus can be a further restriction   on what kind of node is an acceptible match, i.e. CPP or QML.    If a matching node is found, \a ref is an output parameter that   is set to the HTML reference to use for the link.  */
end_comment
begin_function
DECL|function|findNodeForTarget
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNodeForTarget
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|flags
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QString
name|p
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|p
operator|=
name|path
operator|.
name|join
argument_list|(
name|QString
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DOC
operator|)
condition|)
block|{
name|p
operator|=
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|node
operator|=
name|findDocumentNodeByTitle
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|getRef
argument_list|(
name|target
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
block|}
name|node
operator|=
name|findUnambiguousTarget
argument_list|(
name|p
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|getRef
argument_list|(
name|target
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
name|node
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|root
argument_list|()
expr_stmt|;
comment|/*       If the path contains one or two double colons ("::"),       check first to see if the first two path strings refer       to a QML element. If they do, path[0] will be the QML       module identifier, and path[1] will be the QML type.       If the answer is yes, the reference identifies a QML       type node.     */
name|int
name|path_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|QML
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|)
operator|&&
operator|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|)
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|lookupQmlType
argument_list|(
name|QString
argument_list|(
name|path
index|[
literal|0
index|]
operator|+
literal|"::"
operator|+
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
name|current
operator|=
name|qcn
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|getRef
argument_list|(
name|target
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|current
return|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|current
return|;
block|}
name|path_idx
operator|=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|isInnerNode
argument_list|()
condition|)
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|matchPathAndTarget
argument_list|(
name|path
argument_list|,
name|path_idx
argument_list|,
name|target
argument_list|,
name|current
argument_list|,
name|flags
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
name|current
operator|=
name|current
operator|->
name|parent
argument_list|()
expr_stmt|;
name|path_idx
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   First, the \a path is used to find a node. The \a path   matches some part of the node's fully quallified name.   If the \a target is not empty, it must match a target   in the matching node. If the matching of the \a path   and the \a target (if present) is successful, \a ref   is set from the \a target, and the pointer to the   matching node is returned. \a idx is the index into the   \a path where to begin the matching. The function is   recursive with idx being incremented for each recursive   call.    The matching node must be of the correct \a genus, i.e.   either QML or C++, but \a genus can be set to \c DontCare.   \a flags indicates whether to search base classes and   whether to search for an enum value. \a node points to   the node where the search should begin, assuming the   \a path is a not a fully-qualified name. \a node is   most often the root of this Tree.  */
end_comment
begin_function
DECL|function|matchPathAndTarget
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|matchPathAndTarget
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
name|int
name|flags
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
specifier|const
block|{
comment|/*       If the path has been matched, then if there is a target,       try to match the target. If there is a target, but you       can't match it at the end of the path, give up; return 0.      */
if|if
condition|(
name|idx
operator|==
name|path
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ref
operator|=
name|getRef
argument_list|(
name|target
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|->
name|isFunction
argument_list|()
operator|&&
name|node
operator|->
name|name
argument_list|()
operator|==
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|const
name|Node
modifier|*
name|t
init|=
literal|0
decl_stmt|;
name|QString
name|name
init|=
name|path
operator|.
name|at
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|nodes
decl_stmt|;
name|node
operator|->
name|findChildren
argument_list|(
name|name
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|n
decl|,
name|nodes
control|)
block|{
if|if
condition|(
name|genus
operator|!=
name|Node
operator|::
name|DontCare
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|genus
argument_list|()
operator|!=
name|genus
condition|)
continue|continue;
block|}
name|t
operator|=
name|matchPathAndTarget
argument_list|(
name|path
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|target
argument_list|,
name|n
argument_list|,
name|flags
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|!
name|t
operator|->
name|isPrivate
argument_list|()
condition|)
return|return
name|t
return|;
block|}
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|idx
operator|)
operator|==
operator|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|&&
name|node
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
name|flags
operator|&
name|SearchEnumValues
operator|)
condition|)
block|{
name|t
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|CPP
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|)
operator|&&
name|node
operator|->
name|isClass
argument_list|()
operator|&&
operator|(
name|flags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|bc
decl|,
name|baseClasses
control|)
block|{
name|t
operator|=
name|matchPathAndTarget
argument_list|(
name|path
argument_list|,
name|idx
argument_list|,
name|target
argument_list|,
name|bc
argument_list|,
name|flags
argument_list|,
name|genus
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|!
name|t
operator|->
name|isPrivate
argument_list|()
condition|)
return|return
name|t
return|;
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|idx
operator|)
operator|==
operator|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SearchEnumValues
operator|)
condition|)
block|{
name|t
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|bc
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Searches the tree for a node that matches the \a path. The   search begins at \a start but can move up the parent chain   recursively if no match is found.    This findNode() callse the other findNode(), which is not   called anywhere else.  */
end_comment
begin_function
DECL|function|findNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findNode
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|Node
modifier|*
name|start
parameter_list|,
name|int
name|findFlags
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
specifier|const
block|{
specifier|const
name|Node
modifier|*
name|current
init|=
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
name|current
operator|=
name|root
argument_list|()
expr_stmt|;
do|do
block|{
specifier|const
name|Node
modifier|*
name|node
init|=
name|current
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_idx
init|=
literal|0
decl_stmt|;
comment|/*           If the path contains one or two double colons ("::"),           check first to see if the first two path strings refer           to a QML element. If they do, path[0] will be the QML           module identifier, and path[1] will be the QML type.           If the answer is yes, the reference identifies a QML           type node.         */
if|if
condition|(
operator|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|QML
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|)
operator|&&
operator|(
name|path
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|)
operator|&&
operator|!
name|path
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|lookupQmlType
argument_list|(
name|QString
argument_list|(
name|path
index|[
literal|0
index|]
operator|+
literal|"::"
operator|+
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
name|node
operator|=
name|qcn
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|node
return|;
name|start_idx
operator|=
literal|2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
name|path
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
break|break;
specifier|const
name|Node
modifier|*
name|next
init|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|genus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
operator|(
name|genus
operator|==
name|Node
operator|::
name|CPP
operator|)
operator|||
operator|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
operator|)
operator|)
operator|&&
name|node
operator|->
name|isClass
argument_list|()
operator|&&
operator|(
name|findFlags
operator|&
name|SearchBaseClasses
operator|)
condition|)
block|{
name|NodeList
name|baseClasses
init|=
name|allBaseClasses
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|baseClass
decl|,
name|baseClasses
control|)
block|{
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|genus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|(
name|findFlags
operator|&
name|SearchEnumValues
operator|)
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|next
operator|=
cast|static_cast
argument_list|<
specifier|const
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|baseClass
argument_list|)
operator|->
name|findEnumNodeForValue
argument_list|(
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
break|break;
block|}
block|}
block|}
name|node
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|&&
name|i
operator|==
name|path
operator|.
name|size
argument_list|()
condition|)
return|return
name|node
return|;
name|current
operator|=
name|current
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|current
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with a canonical title   constructed from \a target. If the node it finds is \a node,   it returns the ref from that node. Otherwise it returns an   empty string.  */
end_comment
begin_function
DECL|function|getRef
name|QString
name|Tree
operator|::
name|getRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
name|TargetMap
operator|::
name|const_iterator
name|i
init|=
name|nodesByTargetTitle_
operator|.
name|constFind
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|nodesByTargetTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|->
name|node_
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|->
name|ref_
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|nodesByTargetTitle_
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|target
condition|)
do|;
block|}
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|i
operator|=
name|nodesByTargetRef_
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|nodesByTargetRef_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|->
name|node_
operator|==
name|node
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
operator|->
name|ref_
return|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|nodesByTargetRef_
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
do|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Inserts a new target into the target table. \a name is the   key. The target record contains the \a type, a pointer to   the \a node, the \a priority. and a canonicalized form of   the \a name, which is later used.  */
end_comment
begin_function
DECL|function|insertTarget
name|void
name|Tree
operator|::
name|insertTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|TargetRec
operator|::
name|Type
name|type
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|TargetRec
modifier|*
name|target
init|=
operator|new
name|TargetRec
argument_list|(
name|name
argument_list|,
name|title
argument_list|,
name|type
argument_list|,
name|node
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|nodesByTargetRef_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|nodesByTargetTitle_
operator|.
name|insert
argument_list|(
name|title
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|resolveTargets
name|void
name|Tree
operator|::
name|resolveTargets
parameter_list|(
name|InnerNode
modifier|*
name|root
parameter_list|)
block|{
comment|// need recursion
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|root
operator|->
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|DocumentNode
modifier|*
name|node
init|=
cast|static_cast
argument_list|<
name|DocumentNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|QString
name|key
init|=
name|node
operator|->
name|title
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|contains
argument_list|(
name|QChar
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|key
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|DocumentNode
modifier|*
argument_list|>
name|nodes
init|=
name|docNodesByTitle_
operator|.
name|values
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|bool
name|alreadyThere
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|empty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|==
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|()
condition|)
block|{
name|alreadyThere
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|alreadyThere
condition|)
name|docNodesByTitle_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTableOfContents
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|toc
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|tableOfContents
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toc
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|ref
init|=
name|refForAtom
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|title
init|=
name|Text
operator|::
name|sectionHeading
argument_list|(
name|toc
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|TargetRec
modifier|*
name|target
init|=
operator|new
name|TargetRec
argument_list|(
name|ref
argument_list|,
name|title
argument_list|,
name|TargetRec
operator|::
name|Contents
argument_list|,
name|child
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|nodesByTargetRef_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|nodesByTargetTitle_
operator|.
name|insert
argument_list|(
name|title
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasKeywords
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|keywords
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|keywords
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywords
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|ref
init|=
name|refForAtom
argument_list|(
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|title
init|=
name|keywords
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|TargetRec
modifier|*
name|target
init|=
operator|new
name|TargetRec
argument_list|(
name|ref
argument_list|,
name|title
argument_list|,
name|TargetRec
operator|::
name|Keyword
argument_list|,
name|child
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|nodesByTargetRef_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|nodesByTargetTitle_
operator|.
name|insert
argument_list|(
name|title
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|hasTargets
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|Atom
modifier|*
argument_list|>
modifier|&
name|targets
init|=
name|child
operator|->
name|doc
argument_list|()
operator|.
name|targets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|ref
init|=
name|refForAtom
argument_list|(
name|targets
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|title
init|=
name|targets
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|string
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ref
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|key
init|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
decl_stmt|;
name|TargetRec
modifier|*
name|target
init|=
operator|new
name|TargetRec
argument_list|(
name|ref
argument_list|,
name|title
argument_list|,
name|TargetRec
operator|::
name|Target
argument_list|,
name|child
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|nodesByTargetRef_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|nodesByTargetTitle_
operator|.
name|insert
argument_list|(
name|title
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function searches for a \a target anchor node. If it   finds one, it sets \a ref and returns the found node.  */
end_comment
begin_function
specifier|const
name|Node
modifier|*
DECL|function|findUnambiguousTarget
name|Tree
operator|::
name|findUnambiguousTarget
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
name|QString
modifier|&
name|ref
parameter_list|)
specifier|const
block|{
name|int
name|numBestTargets
init|=
literal|0
decl_stmt|;
name|TargetRec
modifier|*
name|bestTarget
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|TargetRec
modifier|*
argument_list|>
name|bestTargetList
decl_stmt|;
name|QString
name|key
init|=
name|target
decl_stmt|;
name|TargetMap
operator|::
name|const_iterator
name|i
init|=
name|nodesByTargetTitle_
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|nodesByTargetTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|!=
name|key
condition|)
break|break;
name|TargetRec
modifier|*
name|candidate
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bestTarget
operator|||
operator|(
name|candidate
operator|->
name|priority_
operator|<
name|bestTarget
operator|->
name|priority_
operator|)
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|->
name|priority_
operator|==
name|bestTarget
operator|->
name|priority_
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bestTarget
condition|)
block|{
name|ref
operator|=
name|bestTarget
operator|->
name|ref_
expr_stmt|;
return|return
name|bestTarget
operator|->
name|node_
return|;
block|}
name|numBestTargets
operator|=
literal|0
expr_stmt|;
name|bestTarget
operator|=
literal|0
expr_stmt|;
name|key
operator|=
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|i
operator|=
name|nodesByTargetRef_
operator|.
name|find
argument_list|(
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|nodesByTargetRef_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|!=
name|key
condition|)
break|break;
name|TargetRec
modifier|*
name|candidate
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bestTarget
operator|||
operator|(
name|candidate
operator|->
name|priority_
operator|<
name|bestTarget
operator|->
name|priority_
operator|)
condition|)
block|{
name|bestTarget
operator|=
name|candidate
expr_stmt|;
name|bestTargetList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|numBestTargets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|->
name|priority_
operator|==
name|bestTarget
operator|->
name|priority_
condition|)
block|{
name|bestTargetList
operator|.
name|append
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
operator|++
name|numBestTargets
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bestTarget
condition|)
block|{
name|ref
operator|=
name|bestTarget
operator|->
name|ref_
expr_stmt|;
return|return
name|bestTarget
operator|->
name|node_
return|;
block|}
name|ref
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This function searches for a node with the specified \a title.  */
end_comment
begin_function
DECL|function|findDocumentNodeByTitle
specifier|const
name|DocumentNode
modifier|*
name|Tree
operator|::
name|findDocumentNodeByTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
specifier|const
block|{
name|DocumentNodeMultiMap
operator|::
name|const_iterator
name|i
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|contains
argument_list|(
name|QChar
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|i
operator|=
name|docNodesByTitle_
operator|.
name|constFind
argument_list|(
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|title
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|docNodesByTitle_
operator|.
name|constFind
argument_list|(
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|/*           Reporting all these duplicate section titles is probably           overkill. We should report the duplicate file and let           that suffice.         */
name|DocumentNodeMultiMap
operator|::
name|const_iterator
name|j
init|=
name|i
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|Location
argument_list|>
name|internalLocations
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|docNodesByTitle_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|j
operator|.
name|key
argument_list|()
operator|==
name|i
operator|.
name|key
argument_list|()
operator|&&
name|j
operator|.
name|value
argument_list|()
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|internalLocations
operator|.
name|append
argument_list|(
name|j
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|// Just report one duplicate for now.
block|}
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|internalLocations
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|i
operator|.
name|value
argument_list|()
operator|->
name|location
argument_list|()
operator|.
name|warning
argument_list|(
literal|"This page title exists in more than one file: "
operator|+
name|title
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Location
modifier|&
name|location
decl|,
name|internalLocations
control|)
name|location
operator|.
name|warning
argument_list|(
literal|"[It also exists here]"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a canonical title for the \a atom, if the \a atom   is a SectionLeft or a Target.  */
end_comment
begin_function
DECL|function|refForAtom
name|QString
name|Tree
operator|::
name|refForAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
condition|)
block|{
if|if
condition|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|SectionLeft
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|Text
operator|::
name|sectionHeading
argument_list|(
name|atom
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
if|if
condition|(
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Target
operator|)
operator|||
operator|(
name|atom
operator|->
name|type
argument_list|()
operator|==
name|Atom
operator|::
name|Keyword
operator|)
condition|)
return|return
name|Doc
operator|::
name|canonicalTitle
argument_list|(
name|atom
operator|->
name|string
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \fn const CNMap& Tree::groups() const   Returns a const reference to the collection of all   group nodes. */
end_comment
begin_comment
comment|/*!   \fn const ModuleMap& Tree::modules() const   Returns a const reference to the collection of all   module nodes. */
end_comment
begin_comment
comment|/*!   \fn const QmlModuleMap& Tree::qmlModules() const   Returns a const reference to the collection of all   QML module nodes. */
end_comment
begin_comment
comment|/*!   Returns a pointer to the collection map specified by \a genus.   Returns null if \a genus is not specified.  */
end_comment
begin_function
DECL|function|getCollectionMap
name|CNMap
modifier|*
name|Tree
operator|::
name|getCollectionMap
parameter_list|(
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
block|{
switch|switch
condition|(
name|genus
condition|)
block|{
case|case
name|Node
operator|::
name|DOC
case|:
return|return
operator|&
name|groups_
return|;
case|case
name|Node
operator|::
name|CPP
case|:
return|return
operator|&
name|modules_
return|;
case|case
name|Node
operator|::
name|QML
case|:
return|return
operator|&
name|qmlModules_
return|;
case|case
name|Node
operator|::
name|JS
case|:
return|return
operator|&
name|jsModules_
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pointer to the collection named \a name of the   specified \a genus in this tree. If there is no matching   collection in this tree, 0 is returned.  */
end_comment
begin_function
DECL|function|getCollection
name|CollectionNode
modifier|*
name|Tree
operator|::
name|getCollection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
block|{
name|CNMap
modifier|*
name|m
init|=
name|getCollectionMap
argument_list|(
name|genus
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|m
operator|->
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|m
operator|->
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find the group, module, QML module, or JavaScript module   named \a name and return a pointer to that collection node.   \a genus specifies which kind of collection node you want.   If a collection node with the specified \a name and \a genus   is not found, a new one is created, and the pointer to the   new one is returned.    If a new collection node is created, its parent is the tree   root, and the new collection node is marked \e{not seen}.    \a genus must be specified, i.e. it must not be \c{DontCare}.   If it is \c{DontCare}, 0 is returned, which is a programming   error.  */
end_comment
begin_function
DECL|function|findCollection
name|CollectionNode
modifier|*
name|Tree
operator|::
name|findCollection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
block|{
name|CNMap
modifier|*
name|m
init|=
name|getCollectionMap
argument_list|(
name|genus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
comment|// error
return|return
literal|0
return|;
name|CNMap
operator|::
name|const_iterator
name|i
init|=
name|m
operator|->
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|m
operator|->
name|end
argument_list|()
condition|)
return|return
name|i
operator|.
name|value
argument_list|()
return|;
name|Node
operator|::
name|Type
name|t
init|=
name|Node
operator|::
name|NoType
decl_stmt|;
switch|switch
condition|(
name|genus
condition|)
block|{
case|case
name|Node
operator|::
name|DOC
case|:
name|t
operator|=
name|Node
operator|::
name|Group
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|CPP
case|:
name|t
operator|=
name|Node
operator|::
name|Module
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QML
case|:
name|t
operator|=
name|Node
operator|::
name|QmlModule
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|JS
case|:
name|t
operator|=
name|Node
operator|::
name|QmlModule
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|CollectionNode
modifier|*
name|cn
init|=
operator|new
name|CollectionNode
argument_list|(
name|t
argument_list|,
name|root
argument_list|()
argument_list|,
name|name
argument_list|,
name|genus
argument_list|)
decl_stmt|;
name|cn
operator|->
name|markNotSeen
argument_list|()
expr_stmt|;
name|m
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cn
argument_list|)
expr_stmt|;
return|return
name|cn
return|;
block|}
end_function
begin_comment
comment|/*! \fn CollectionNode* Tree::findGroup(const QString& name)   Find the group node named \a name and return a pointer   to it. If the group node is not found, add a new group   node named \a name and return a pointer to the new one.    If a new group node is added, its parent is the tree root,   and the new group node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::findModule(const QString& name)   Find the module node named \a name and return a pointer   to it. If a matching node is not found, add a new module   node named \a name and return a pointer to that one.    If a new module node is added, its parent is the tree root,   and the new module node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::findQmlModule(const QString& name)   Find the QML module node named \a name and return a pointer   to it. If a matching node is not found, add a new QML module   node named \a name and return a pointer to that one.    If a new QML module node is added, its parent is the tree root,   and the new node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::findJsModule(const QString& name)   Find the JavaScript module named \a name and return a pointer   to it. If a matching node is not found, add a new JavaScript   module node named \a name and return a pointer to that one.    If a new JavaScript module node is added, its parent is the   tree root, and the new node is marked \e{not seen}.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::addGroup(const QString& name)   Looks up the group node named \a name in the collection   of all group nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new group node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::addModule(const QString& name)   Looks up the module node named \a name in the collection   of all module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::addQmlModule(const QString& name)   Looks up the QML module node named \a name in the collection   of all QML module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new QML module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_comment
comment|/*! \fn CollectionNode* Tree::addJsModule(const QString& name)   Looks up the JavaScript module node named \a name in the collection   of all JavaScript module nodes. If a match is found, a pointer to the   node is returned. Otherwise, a new JavaScrpt module node named \a name   is created and inserted into the collection, and the pointer   to that node is returned.  */
end_comment
begin_comment
comment|/*!   Looks up the group node named \a name in the collection   of all group nodes. If a match is not found, a new group   node named \a name is created and inserted into the collection.   Then append \a node to the group's members list, and append the   group name to the list of group names in \a node. The parent of   \a node is not changed by this function. Returns a pointer to   the group node.  */
end_comment
begin_function
DECL|function|addToGroup
name|CollectionNode
modifier|*
name|Tree
operator|::
name|addToGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|CollectionNode
modifier|*
name|cn
init|=
name|findGroup
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|isInternal
argument_list|()
condition|)
block|{
name|cn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendGroupName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|cn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the module node named \a name in the collection   of all module nodes. If a match is not found, a new module   node named \a name is created and inserted into the collection.   Then append \a node to the module's members list. The parent of   \a node is not changed by this function. Returns the module node.  */
end_comment
begin_function
DECL|function|addToModule
name|CollectionNode
modifier|*
name|Tree
operator|::
name|addToModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|CollectionNode
modifier|*
name|cn
init|=
name|findModule
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|cn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setPhysicalModuleName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|cn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.   Returns the pointer to the QML module node.  */
end_comment
begin_function
DECL|function|addToQmlModule
name|CollectionNode
modifier|*
name|Tree
operator|::
name|addToQmlModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QStringList
name|qmid
decl_stmt|;
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|blankSplit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|CollectionNode
modifier|*
name|cn
init|=
name|findQmlModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|cn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setQmlModule
argument_list|(
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isQmlType
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmid
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|key
init|=
name|qmid
index|[
name|i
index|]
operator|+
literal|"::"
operator|+
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
name|insertQmlType
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cn
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the QML module named \a name. If it isn't there,   create it. Then append \a node to the QML module's member   list. The parent of \a node is not changed by this function.   Returns the pointer to the QML module node.  */
end_comment
begin_function
DECL|function|addToJsModule
name|CollectionNode
modifier|*
name|Tree
operator|::
name|addToJsModule
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QStringList
name|qmid
decl_stmt|;
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|name
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|blankSplit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmid
operator|.
name|append
argument_list|(
name|blankSplit
index|[
literal|0
index|]
operator|+
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|CollectionNode
modifier|*
name|cn
init|=
name|findJsModule
argument_list|(
name|blankSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|cn
operator|->
name|addMember
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|setQmlModule
argument_list|(
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|isJsType
argument_list|()
condition|)
block|{
name|QmlTypeNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmid
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|key
init|=
name|qmid
index|[
name|i
index|]
operator|+
literal|"::"
operator|+
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
name|insertQmlType
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cn
return|;
block|}
end_function
begin_comment
comment|/*!   If the QML type map does not contain \a key, insert node   \a n with the specified \a key.  */
end_comment
begin_function
DECL|function|insertQmlType
name|void
name|Tree
operator|::
name|insertQmlType
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QmlTypeNode
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qmlTypeMap_
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
name|qmlTypeMap_
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Split \a target on "::" and find the function node with that   path.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|Node
modifier|*
name|relative
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
block|{
name|QString
name|t
init|=
name|target
decl_stmt|;
name|t
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|QStringList
name|path
init|=
name|t
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
name|findFunctionNode
argument_list|(
name|path
argument_list|,
name|relative
argument_list|,
name|SearchBaseClasses
argument_list|,
name|genus
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|&&
name|fn
operator|->
name|metaness
argument_list|()
operator|!=
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
return|return
name|fn
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Search for a node that is identified by \a name.   Return a pointer to a matching node, or 0. */
end_comment
begin_function
DECL|function|checkForCollision
specifier|const
name|Node
modifier|*
name|Tree
operator|::
name|checkForCollision
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
return|return
name|findNode
argument_list|(
name|QStringList
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Node
operator|::
name|DontCare
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Generate a target of the form link-nnn, where the nnn is   the current link count for this tree. This target string   is returned. It will be output as an HTML anchor just before   an HTML link to the node \a t.    The node \a t  */
end_comment
begin_function
DECL|function|getNewLinkTarget
name|QString
name|Tree
operator|::
name|getNewLinkTarget
parameter_list|(
specifier|const
name|Node
modifier|*
name|locNode
parameter_list|,
specifier|const
name|Node
modifier|*
name|t
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|&
name|text
parameter_list|,
name|bool
name|broken
parameter_list|)
block|{
name|QString
name|physicalModuleName
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|!
name|broken
condition|)
block|{
name|Tree
modifier|*
name|tree
init|=
name|t
operator|->
name|tree
argument_list|()
decl_stmt|;
if|if
condition|(
name|tree
operator|!=
name|this
condition|)
name|tree
operator|->
name|incrementLinkCount
argument_list|()
expr_stmt|;
name|physicalModuleName
operator|=
name|tree
operator|->
name|physicalModuleName
argument_list|()
expr_stmt|;
block|}
else|else
name|physicalModuleName
operator|=
literal|"broken"
expr_stmt|;
name|incrementLinkCount
argument_list|()
expr_stmt|;
name|QString
name|target
init|=
name|QString
argument_list|(
literal|"qa-target-%1"
argument_list|)
operator|.
name|arg
argument_list|(
operator|-
operator|(
name|linkCount
argument_list|()
operator|)
argument_list|)
decl_stmt|;
name|TargetLoc
modifier|*
name|tloc
init|=
operator|new
name|TargetLoc
argument_list|(
name|locNode
argument_list|,
name|target
argument_list|,
name|fileName
argument_list|,
name|text
argument_list|,
name|broken
argument_list|)
decl_stmt|;
name|TargetList
modifier|*
name|tList
init|=
literal|0
decl_stmt|;
name|TargetListMap
operator|::
name|iterator
name|i
init|=
name|targetListMap_
operator|->
name|find
argument_list|(
name|physicalModuleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|targetListMap_
operator|->
name|end
argument_list|()
condition|)
block|{
name|tList
operator|=
operator|new
name|TargetList
expr_stmt|;
name|i
operator|=
name|targetListMap_
operator|->
name|insert
argument_list|(
name|physicalModuleName
argument_list|,
name|tList
argument_list|)
expr_stmt|;
block|}
else|else
name|tList
operator|=
name|i
operator|.
name|value
argument_list|()
expr_stmt|;
name|tList
operator|->
name|append
argument_list|(
name|tloc
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function
begin_comment
comment|/*!   Look up the target list for the specified \a module   and return a pointer to it.  */
end_comment
begin_function
DECL|function|getTargetList
name|TargetList
modifier|*
name|Tree
operator|::
name|getTargetList
parameter_list|(
specifier|const
name|QString
modifier|&
name|module
parameter_list|)
block|{
return|return
name|targetListMap_
operator|->
name|value
argument_list|(
name|module
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
