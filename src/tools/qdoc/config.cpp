begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   config.cpp */
end_comment
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qtemporaryfile.h>
end_include
begin_include
include|#
directive|include
file|<qtextstream.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   An entry in a stack, where each entry is a list   of string values.  */
end_comment
begin_class
DECL|class|MetaStackEntry
class|class
name|MetaStackEntry
block|{
public|public:
name|void
name|open
parameter_list|()
function_decl|;
name|void
name|close
parameter_list|()
function_decl|;
DECL|member|accum
name|QStringList
name|accum
decl_stmt|;
DECL|member|next
name|QStringList
name|next
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!   Start accumulating values in a list by appending an empty   string to the list.  */
end_comment
begin_function
DECL|function|open
name|void
name|MetaStackEntry
operator|::
name|open
parameter_list|()
block|{
name|next
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Stop accumulating values and append the list of accumulated   values to the complete list of accumulated values.   */
end_comment
begin_function
DECL|function|close
name|void
name|MetaStackEntry
operator|::
name|close
parameter_list|()
block|{
name|accum
operator|+=
name|next
expr_stmt|;
name|next
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class MetaStack    This class maintains a stack of values of config file variables. */
end_comment
begin_class
DECL|class|MetaStack
class|class
name|MetaStack
super|:
specifier|private
name|QStack
argument_list|<
name|MetaStackEntry
argument_list|>
block|{
name|Q_DECLARE_TR_FUNCTIONS
parameter_list|(
name|QDoc
operator|::
name|MetaStack
parameter_list|)
specifier|public
private|:
name|MetaStack
parameter_list|()
constructor_decl|;
name|void
name|process
parameter_list|(
name|QChar
name|ch
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
function_decl|;
name|QStringList
name|getExpanded
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!   The default constructor pushes a new stack entry and   opens it.  */
end_comment
begin_constructor
DECL|function|MetaStack
name|MetaStack
operator|::
name|MetaStack
parameter_list|()
block|{
name|push
argument_list|(
name|MetaStackEntry
argument_list|()
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Processes the character \a ch using the \a location.   It really just builds up a name by appending \a ch to   it.  */
end_comment
begin_function
DECL|function|process
name|void
name|MetaStack
operator|::
name|process
parameter_list|(
name|QChar
name|ch
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|MetaStackEntry
argument_list|()
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
argument_list|()
operator|==
literal|1
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '}'"
argument_list|)
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|QStringList
name|suffixes
init|=
name|pop
argument_list|()
operator|.
name|accum
decl_stmt|;
name|QStringList
name|prefixes
init|=
name|top
argument_list|()
operator|.
name|next
decl_stmt|;
name|top
argument_list|()
operator|.
name|next
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|pre
init|=
name|prefixes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|pre
operator|!=
name|prefixes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|suf
init|=
name|suffixes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|suf
operator|!=
name|suffixes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|top
argument_list|()
operator|.
name|next
operator|<<
operator|(
operator|*
name|pre
operator|+
operator|*
name|suf
operator|)
expr_stmt|;
operator|++
name|suf
expr_stmt|;
block|}
operator|++
name|pre
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|&&
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*           This is where all the processing is done.          */
name|QStringList
operator|::
name|Iterator
name|pre
init|=
name|top
argument_list|()
operator|.
name|next
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|pre
operator|!=
name|top
argument_list|()
operator|.
name|next
operator|.
name|end
argument_list|()
condition|)
block|{
operator|*
name|pre
operator|+=
name|ch
expr_stmt|;
operator|++
name|pre
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Returns the accumulated string values.  */
end_comment
begin_function
DECL|function|getExpanded
name|QStringList
name|MetaStack
operator|::
name|getExpanded
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
block|{
if|if
condition|(
name|count
argument_list|()
operator|>
literal|1
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Missing '}'"
argument_list|)
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|top
argument_list|()
operator|.
name|accum
return|;
block|}
end_function
begin_decl_stmt
DECL|member|dot
name|QT_STATIC_CONST_IMPL
name|QString
name|Config
operator|::
name|dot
init|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|generateExamples
name|bool
name|Config
operator|::
name|generateExamples
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|overrideOutputDir
name|QString
name|Config
operator|::
name|overrideOutputDir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|installDir
name|QString
name|Config
operator|::
name|installDir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|overrideOutputFormats
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|overrideOutputFormats
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|extractedDirs
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|Config
operator|::
name|extractedDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|numInstances
name|int
name|Config
operator|::
name|numInstances
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|workingDirs_
name|QStack
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|workingDirs_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   \class Config   \brief The Config class contains the configuration variables   for controlling how qdoc produces documentation.    Its load() function, reads, parses, and processes a qdocconf file.  */
end_comment
begin_comment
comment|/*!   The constructor sets the \a programName and initializes all   internal state variables to empty values.  */
end_comment
begin_constructor
DECL|function|Config
name|Config
operator|::
name|Config
parameter_list|(
specifier|const
name|QString
modifier|&
name|programName
parameter_list|)
member_init_list|:
name|prog
argument_list|(
name|programName
argument_list|)
block|{
name|loc
operator|=
name|Location
operator|::
name|null
expr_stmt|;
name|lastLocation_
operator|=
name|Location
operator|::
name|null
expr_stmt|;
name|configVars_
operator|.
name|clear
argument_list|()
expr_stmt|;
name|numInstances
operator|++
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   The destructor has nothing special to do.  */
end_comment
begin_destructor
DECL|function|~Config
name|Config
operator|::
name|~
name|Config
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Loads and parses the qdoc configuration file \a fileName.   This function calls the other load() function, which does   the loading, parsing, and processing of the configuration   file.    Intializes the location variables returned by location()   and lastLocation().  */
end_comment
begin_function
DECL|function|load
name|void
name|Config
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|load
argument_list|(
name|Location
operator|::
name|null
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|loc
operator|=
name|Location
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loc
operator|.
name|setEtc
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|lastLocation_
operator|=
name|Location
operator|::
name|null
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Joins all the strings in \a values into a single string with the   individual \a values separated by ' '. Then it inserts the result   into the string list map with \a var as the key.    It also inserts the \a values string list into a separate map,   also with \a var as the key.  */
end_comment
begin_function
DECL|function|setStringList
name|void
name|Config
operator|::
name|setStringList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|values
parameter_list|)
block|{
name|configVars_
operator|.
name|insert
argument_list|(
name|var
argument_list|,
name|ConfigVar
argument_list|(
name|var
argument_list|,
name|values
argument_list|,
name|QDir
operator|::
name|currentPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuarion variable \a var in the string   map and returns the boolean value.  */
end_comment
begin_function
DECL|function|getBool
name|bool
name|Config
operator|::
name|getBool
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|getString
argument_list|(
name|var
argument_list|)
argument_list|)
operator|.
name|toBool
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string list   map. Iterates through the string list found, interpreting each   string in the list as an integer and adding it to a total sum.   Returns the sum.  */
end_comment
begin_function
DECL|function|getInt
name|int
name|Config
operator|::
name|getInt
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|strs
init|=
name|getStringList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|s
init|=
name|strs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|strs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|sum
operator|+=
operator|(
operator|*
name|s
operator|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function
begin_comment
comment|/*!   Function to return the correct outputdir.   outputdir can be set using the qdocconf or the command-line   variable -outputdir.   */
end_comment
begin_function
DECL|function|getOutputDir
name|QString
name|Config
operator|::
name|getOutputDir
parameter_list|()
specifier|const
block|{
name|QString
name|t
decl_stmt|;
if|if
condition|(
name|overrideOutputDir
operator|.
name|isNull
argument_list|()
condition|)
name|t
operator|=
name|getString
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OUTPUTDIR
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|overrideOutputDir
expr_stmt|;
if|if
condition|(
operator|!
name|Generator
operator|::
name|useOutputSubdirs
argument_list|()
condition|)
block|{
name|t
operator|=
name|t
operator|.
name|left
argument_list|(
name|t
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|getString
argument_list|(
literal|"HTML.outputsubdir"
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Function to return the correct outputformats.   outputformats can be set using the qdocconf or the command-line   variable -outputformat.   */
end_comment
begin_function
DECL|function|getOutputFormats
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|getOutputFormats
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|overrideOutputFormats
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|getStringSet
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OUTPUTFORMATS
argument_list|)
argument_list|)
return|;
else|else
return|return
name|overrideOutputFormats
return|;
block|}
end_function
begin_comment
comment|/*!   First, this function looks up the configuration variable \a var   in the location map and, if found, sets the internal variable   \c{lastLocation_} to the Location that \a var maps to.    Then it looks up the configuration variable \a var in the string   map and returns the string that \a var maps to.  */
end_comment
begin_function
DECL|function|getString
name|QString
name|Config
operator|::
name|getString
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|ConfigVar
argument_list|>
name|configVars
init|=
name|configVars_
operator|.
name|values
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QString
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|configVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|configVars
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|ConfigVar
modifier|&
name|cv
init|=
name|configVars
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|location_
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLocation_
operator|=
name|cv
operator|.
name|location_
expr_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|values_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|cv
operator|.
name|plus_
condition|)
name|value
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cv
operator|.
name|values_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
condition|)
name|value
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|.
name|append
argument_list|(
name|cv
operator|.
name|values_
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string   list map, converts the string list it maps to into a set   of strings, and returns the set.  */
end_comment
begin_function
DECL|function|getStringSet
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|getStringSet
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
return|return
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|fromList
argument_list|(
name|getStringList
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   First, this function looks up the configuration variable \a var   in the location map. If found, it sets the internal variable   \c{lastLocation_} to the Location that \a var maps to.    Then it looks up the configuration variable \a var in the map of   configuration variable records. If found, it gets a list of all   the records for \a var. Then it appends all the values for \a var   to a list and returns the list. As it appends the values from each   record, if the \a var used '=' instead of '+=' the list is cleared   before the values are appended. \note '+=' should always be used.   The final list is returned.  */
end_comment
begin_function
DECL|function|getStringList
name|QStringList
name|Config
operator|::
name|getStringList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|ConfigVar
argument_list|>
name|configVars
init|=
name|configVars_
operator|.
name|values
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QStringList
name|values
decl_stmt|;
if|if
condition|(
operator|!
name|configVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|configVars
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|configVars
index|[
name|i
index|]
operator|.
name|location_
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLocation_
operator|=
name|configVars
index|[
name|i
index|]
operator|.
name|location_
expr_stmt|;
if|if
condition|(
name|configVars
index|[
name|i
index|]
operator|.
name|plus_
condition|)
name|values
operator|.
name|append
argument_list|(
name|configVars
index|[
name|i
index|]
operator|.
name|values_
argument_list|)
expr_stmt|;
else|else
name|values
operator|=
name|configVars
index|[
name|i
index|]
operator|.
name|values_
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
name|values
return|;
block|}
end_function
begin_comment
comment|/*!    \brief Returns the a path list where all paths are canonicalized, then           made relative to the config file.    \param var The variable containing the list of paths.    \see   Location::canonicalRelativePath()  */
end_comment
begin_function
DECL|function|getCanonicalPathList
name|QStringList
name|Config
operator|::
name|getCanonicalPathList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|t
decl_stmt|;
name|QList
argument_list|<
name|ConfigVar
argument_list|>
name|configVars
init|=
name|configVars_
operator|.
name|values
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|configVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|configVars
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|ConfigVar
modifier|&
name|cv
init|=
name|configVars
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|location_
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLocation_
operator|=
name|cv
operator|.
name|location_
expr_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|plus_
condition|)
block|{
name|t
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|const
name|QString
name|d
init|=
name|cv
operator|.
name|currentPath_
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|sl
init|=
name|cv
operator|.
name|values_
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
name|t
operator|.
name|size
argument_list|()
operator|+
name|sl
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QDir
name|dir
argument_list|(
name|d
operator|+
literal|"/"
operator|+
name|sl
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|t
operator|.
name|append
argument_list|(
name|dir
operator|.
name|canonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   This function should only be called when the configuration   variable \a var maps to string lists that contain file paths.   It cleans the paths with QDir::cleanPath() before returning   them.  */
end_comment
begin_function
DECL|function|getCleanPathList
name|QStringList
name|Config
operator|::
name|getCleanPathList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|t
decl_stmt|;
name|QList
argument_list|<
name|ConfigVar
argument_list|>
name|configVars
init|=
name|configVars_
operator|.
name|values
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|configVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|configVars
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|ConfigVar
modifier|&
name|cv
init|=
name|configVars
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|plus_
condition|)
name|t
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|location_
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLocation_
operator|=
name|cv
operator|.
name|location_
expr_stmt|;
specifier|const
name|QStringList
modifier|&
name|sl
init|=
name|cv
operator|.
name|values_
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
name|t
operator|.
name|size
argument_list|()
operator|+
name|sl
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|.
name|append
argument_list|(
name|QDir
operator|::
name|cleanPath
argument_list|(
name|sl
index|[
name|i
index|]
operator|.
name|simplified
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   This function should only be called when the configuration   variable \a var maps to string lists that contain file paths.   It cleans the paths with QDir::cleanPath() before returning   them.    First, this function looks up the configuration variable \a var   in the location map and, if found, sets the internal variable   \c{lastLocation_} the Location that \a var maps to.    Then it looks up the configuration variable \a var in the string   list map, which maps to one or more records that each contains a   list of file paths.    These paths might not be clean, so QDir::cleanPath() is called   for each one. The string list returned contains cleaned paths.  */
end_comment
begin_function
DECL|function|getPathList
name|QStringList
name|Config
operator|::
name|getPathList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|t
decl_stmt|;
name|QList
argument_list|<
name|ConfigVar
argument_list|>
name|configVars
init|=
name|configVars_
operator|.
name|values
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|configVars
operator|.
name|empty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|configVars
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|ConfigVar
modifier|&
name|cv
init|=
name|configVars
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|plus_
condition|)
name|t
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cv
operator|.
name|location_
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLocation_
operator|=
name|cv
operator|.
name|location_
expr_stmt|;
specifier|const
name|QString
name|d
init|=
name|cv
operator|.
name|currentPath_
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|sl
init|=
name|cv
operator|.
name|values_
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
name|t
operator|.
name|size
argument_list|()
operator|+
name|sl
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QFileInfo
name|fileInfo
decl_stmt|;
name|QString
name|path
init|=
name|d
operator|+
literal|"/"
operator|+
name|QDir
operator|::
name|cleanPath
argument_list|(
name|sl
index|[
name|i
index|]
operator|.
name|simplified
argument_list|()
argument_list|)
decl_stmt|;
name|fileInfo
operator|.
name|setFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
name|lastLocation_
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"File '%1' does not exist"
argument_list|)
operator|.
name|arg
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Calls getRegExpList() with the control variable \a var and   iterates through the resulting list of regular expressions,   concatening them with some extras characters to form a single   QRegExp, which is returned/    \sa getRegExpList()  */
end_comment
begin_function
DECL|function|getRegExp
name|QRegExp
name|Config
operator|::
name|getRegExp
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QString
name|pattern
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|subRegExps
init|=
name|getRegExpList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|subRegExps
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|subRegExps
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|isValid
argument_list|()
condition|)
return|return
operator|*
name|s
return|;
if|if
condition|(
operator|!
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
name|pattern
operator|+=
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|pattern
operator|+=
name|QLatin1String
argument_list|(
literal|"(?:"
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|pattern
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
name|pattern
operator|=
name|QLatin1String
argument_list|(
literal|"$x"
argument_list|)
expr_stmt|;
comment|// cannot match
return|return
name|QRegExp
argument_list|(
name|pattern
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string list   map, converts the string list to a list of regular expressions,   and returns it.  */
end_comment
begin_function
DECL|function|getRegExpList
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|Config
operator|::
name|getRegExpList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|strs
init|=
name|getStringList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|s
init|=
name|strs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|regExps
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|strs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|regExps
operator|+=
name|QRegExp
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|regExps
return|;
block|}
end_function
begin_comment
comment|/*!   This function is slower than it could be. What it does is   find all the keys that begin with \a var + dot and return   the matching keys in a set, stripped of the matching prefix   and dot.  */
end_comment
begin_function
DECL|function|subVars
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|subVars
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|result
decl_stmt|;
name|QString
name|varDot
init|=
name|var
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|ConfigVarMultimap
operator|::
name|ConstIterator
name|i
init|=
name|configVars_
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|configVars_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|varDot
argument_list|)
condition|)
block|{
name|QString
name|subVar
init|=
name|i
operator|.
name|key
argument_list|()
operator|.
name|mid
argument_list|(
name|varDot
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
name|subVar
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|-
literal|1
condition|)
name|subVar
operator|.
name|truncate
argument_list|(
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|contains
argument_list|(
name|subVar
argument_list|)
condition|)
name|result
operator|.
name|insert
argument_list|(
name|subVar
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Same as subVars(), but in this case we return a config var   multimap with the matching keys (stripped of the prefix \a var   and mapped to their values. The pairs are inserted into \a t  */
end_comment
begin_function
DECL|function|subVarsAndValues
name|void
name|Config
operator|::
name|subVarsAndValues
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|,
name|ConfigVarMultimap
modifier|&
name|t
parameter_list|)
specifier|const
block|{
name|QString
name|varDot
init|=
name|var
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|ConfigVarMultimap
operator|::
name|ConstIterator
name|v
init|=
name|configVars_
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|v
operator|!=
name|configVars_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|v
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|varDot
argument_list|)
condition|)
block|{
name|QString
name|subVar
init|=
name|v
operator|.
name|key
argument_list|()
operator|.
name|mid
argument_list|(
name|varDot
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
name|subVar
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|-
literal|1
condition|)
name|subVar
operator|.
name|truncate
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|t
operator|.
name|insert
argument_list|(
name|subVar
argument_list|,
name|v
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|v
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Builds and returns a list of file pathnames for the file   type specified by \a filesVar (e.g. "headers" or "sources").   The files are found in the directories specified by   \a dirsVar, and they are filtered by \a defaultNameFilter   if a better filter can't be constructed from \a filesVar.   The directories in \a excludedDirs are avoided. The files   in \a excludedFiles are not included in the return list.  */
end_comment
begin_function
DECL|function|getAllFiles
name|QStringList
name|Config
operator|::
name|getAllFiles
parameter_list|(
specifier|const
name|QString
modifier|&
name|filesVar
parameter_list|,
specifier|const
name|QString
modifier|&
name|dirsVar
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QStringList
name|result
init|=
name|getStringList
argument_list|(
name|filesVar
argument_list|)
decl_stmt|;
name|QStringList
name|dirs
init|=
name|getCanonicalPathList
argument_list|(
name|dirsVar
argument_list|)
decl_stmt|;
name|QString
name|nameFilter
init|=
name|getString
argument_list|(
name|filesVar
operator|+
name|dot
operator|+
name|QLatin1String
argument_list|(
name|CONFIG_FILEEXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
operator|*
name|d
argument_list|,
name|nameFilter
argument_list|,
name|location
argument_list|()
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|getExampleQdocFiles
name|QStringList
name|Config
operator|::
name|getExampleQdocFiles
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QStringList
name|result
decl_stmt|;
name|QStringList
name|dirs
init|=
name|getCanonicalPathList
argument_list|(
literal|"exampledirs"
argument_list|)
decl_stmt|;
name|QString
name|nameFilter
init|=
literal|" *.qdoc"
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
operator|*
name|d
argument_list|,
name|nameFilter
argument_list|,
name|location
argument_list|()
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|getExampleImageFiles
name|QStringList
name|Config
operator|::
name|getExampleImageFiles
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QStringList
name|result
decl_stmt|;
name|QStringList
name|dirs
init|=
name|getCanonicalPathList
argument_list|(
literal|"exampledirs"
argument_list|)
decl_stmt|;
name|QString
name|nameFilter
init|=
name|getString
argument_list|(
name|CONFIG_EXAMPLES
operator|+
name|dot
operator|+
name|QLatin1String
argument_list|(
name|CONFIG_IMAGEEXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
operator|*
name|d
argument_list|,
name|nameFilter
argument_list|,
name|location
argument_list|()
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \a fileName is the path of the file to find.    \a files and \a dirs are the lists where we must find the   components of \a fileName.    \a location is used for obtaining the file and line numbers   for report qdoc errors.  */
end_comment
begin_function
DECL|function|findFile
name|QString
name|Config
operator|::
name|findFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|files
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|dirs
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|&
name|userFriendlyFilePath
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
name|userFriendlyFilePath
operator|=
name|fileName
expr_stmt|;
return|return
name|fileName
return|;
block|}
name|QFileInfo
name|fileInfo
decl_stmt|;
name|QStringList
name|components
init|=
name|fileName
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|firstComponent
init|=
name|components
operator|.
name|first
argument_list|()
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|f
init|=
name|files
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|files
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
name|firstComponent
operator|||
operator|(
operator|*
name|f
operator|)
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|firstComponent
argument_list|)
condition|)
block|{
name|fileInfo
operator|.
name|setFile
argument_list|(
operator|*
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"File '%1' does not exist"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|fileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|fileInfo
operator|.
name|setFile
argument_list|(
name|QDir
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|firstComponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
break|break;
block|}
operator|++
name|d
expr_stmt|;
block|}
block|}
name|userFriendlyFilePath
operator|=
name|QString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QStringList
operator|::
name|ConstIterator
name|c
init|=
name|components
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|isArchive
init|=
operator|(
name|c
operator|!=
name|components
operator|.
name|constEnd
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|QString
name|userFriendly
init|=
operator|*
name|c
decl_stmt|;
name|userFriendlyFilePath
operator|+=
name|userFriendly
expr_stmt|;
if|if
condition|(
name|isArchive
condition|)
block|{
name|QString
name|extracted
init|=
name|extractedDirs
index|[
name|fileInfo
operator|.
name|filePath
argument_list|()
index|]
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|fileInfo
operator|.
name|setFile
argument_list|(
name|QDir
argument_list|(
name|extracted
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|userFriendlyFilePath
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
return|return
name|fileInfo
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findFile
name|QString
name|Config
operator|::
name|findFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|files
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|dirs
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileBase
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|fileExtensions
parameter_list|,
name|QString
modifier|&
name|userFriendlyFilePath
parameter_list|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|e
init|=
name|fileExtensions
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|fileExtensions
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
name|findFile
argument_list|(
name|location
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fileBase
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
operator|*
name|e
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|filePath
return|;
operator|++
name|e
expr_stmt|;
block|}
return|return
name|findFile
argument_list|(
name|location
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fileBase
argument_list|,
name|userFriendlyFilePath
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Copies the \a sourceFilePath to the file name constructed by   concatenating \a targetDirPath and the file name from the   \a userFriendlySourceFilePath. \a location is for identifying   the file and line number where a qdoc error occurred. The   constructed output file name is returned.  */
end_comment
begin_function
DECL|function|copyFile
name|QString
name|Config
operator|::
name|copyFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|sourceFilePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|userFriendlySourceFilePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|targetDirPath
parameter_list|)
block|{
name|QFile
name|inFile
argument_list|(
name|sourceFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot open input file for copy: '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|sourceFilePath
argument_list|)
operator|.
name|arg
argument_list|(
name|inFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|outFileName
init|=
name|userFriendlySourceFilePath
decl_stmt|;
name|int
name|slash
init|=
name|outFileName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
name|outFileName
operator|=
name|outFileName
operator|.
name|mid
argument_list|(
name|slash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outFileName
operator|.
name|size
argument_list|()
operator|)
operator|>
literal|0
operator|&&
operator|(
name|outFileName
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
condition|)
name|outFileName
operator|=
name|targetDirPath
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|outFileName
expr_stmt|;
else|else
name|outFileName
operator|=
name|targetDirPath
operator|+
name|outFileName
expr_stmt|;
name|QFile
name|outFile
argument_list|(
name|outFileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Cannot open output file for copy: '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|outFileName
argument_list|)
operator|.
name|arg
argument_list|(
name|outFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|inFile
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|outFile
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|outFileName
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the largest unicode digit in \a value in the range   1..7 and returns it.  */
end_comment
begin_function
DECL|function|numParams
name|int
name|Config
operator|::
name|numParams
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|uint
name|c
init|=
name|value
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
literal|8
condition|)
name|max
operator|=
name|qMax
argument_list|(
name|max
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
end_function
begin_comment
comment|/*!   Removes everything from \a dir. This function is recursive.   It doesn't remove \a dir itself, but if it was called   recursively, then the caller will remove \a dir.  */
end_comment
begin_function
DECL|function|removeDirContents
name|bool
name|Config
operator|::
name|removeDirContents
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|QDir
name|dirInfo
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|QFileInfoList
name|entries
init|=
name|dirInfo
operator|.
name|entryInfoList
argument_list|()
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|QFileInfoList
operator|::
name|Iterator
name|it
init|=
name|entries
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|entries
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|remove
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|removeDirContents
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|rmdir
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
operator|++
name|it
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if \a ch is a letter, number, '_', '.',   '{', '}', or ','.  */
end_comment
begin_function
DECL|function|isMetaKeyChar
name|bool
name|Config
operator|::
name|isMetaKeyChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Load, parse, and process a qdoc configuration file. This   function is only called by the other load() function, but   this one is recursive, i.e., it calls itself when it sees   an \c{include} statement in the qdoc configuration file.  */
end_comment
begin_function
DECL|function|load
name|void
name|Config
operator|::
name|load
parameter_list|(
name|Location
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|pushWorkingDir
argument_list|(
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
expr_stmt|;
name|QDir
operator|::
name|setCurrent
argument_list|(
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
expr_stmt|;
name|QRegExp
name|keySyntax
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\w+(?:\\.\\w+)*"
argument_list|)
argument_list|)
decl_stmt|;
DECL|macro|SKIP_CHAR
define|#
directive|define
name|SKIP_CHAR
parameter_list|()
define|\
value|do { \     location.advance(c); \     ++i; \     c = text.at(i); \     cc = c.unicode(); \ } while (0)
DECL|macro|SKIP_SPACES
define|#
directive|define
name|SKIP_SPACES
parameter_list|()
define|\
value|while (c.isSpace()&& cc != '\n') \     SKIP_CHAR()
DECL|macro|PUT_CHAR
define|#
directive|define
name|PUT_CHAR
parameter_list|()
define|\
value|word += c; \     SKIP_CHAR();
if|if
condition|(
name|location
operator|.
name|depth
argument_list|()
operator|>
literal|16
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Too many nested includes"
argument_list|)
argument_list|)
expr_stmt|;
name|QFile
name|fin
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fin
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Config
operator|::
name|installDir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|prefix
init|=
name|location
operator|.
name|filePath
argument_list|()
operator|.
name|length
argument_list|()
operator|-
name|location
operator|.
name|fileName
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|fin
operator|.
name|setFileName
argument_list|(
name|Config
operator|::
name|installDir
operator|+
literal|"/"
operator|+
name|fileName
operator|.
name|right
argument_list|(
name|fileName
operator|.
name|length
argument_list|()
operator|-
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fin
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open file '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
operator|.
name|arg
argument_list|(
name|fin
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QTextStream
name|stream
argument_list|(
operator|&
name|fin
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|stream
operator|.
name|setCodec
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|text
init|=
name|stream
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|text
operator|+=
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|text
operator|+=
name|QLatin1Char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|fin
operator|.
name|close
argument_list|()
expr_stmt|;
name|location
operator|.
name|push
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|location
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QChar
name|c
init|=
name|text
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|uint
name|cc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
block|{
do|do
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|!=
literal|'\n'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|isMetaKeyChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|Location
name|keyLoc
init|=
name|location
decl_stmt|;
name|bool
name|plus
init|=
literal|false
decl_stmt|;
name|QString
name|stringValue
decl_stmt|;
name|QStringList
name|rhsValues
decl_stmt|;
name|QString
name|word
decl_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
name|bool
name|prevWordQuoted
init|=
literal|true
decl_stmt|;
name|bool
name|metWord
init|=
literal|false
decl_stmt|;
name|MetaStack
name|stack
decl_stmt|;
do|do
block|{
name|stack
operator|.
name|process
argument_list|(
name|c
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isMetaKeyChar
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|QStringList
name|keys
init|=
name|stack
operator|.
name|getExpanded
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|count
argument_list|()
operator|==
literal|1
operator|&&
name|keys
operator|.
name|first
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"include"
argument_list|)
condition|)
block|{
name|QString
name|includeFile
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|'('
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Bad include syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|c
operator|.
name|isSpace
argument_list|()
operator|&&
name|cc
operator|!=
literal|'#'
operator|&&
name|cc
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'$'
condition|)
block|{
name|QString
name|var
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|cc
operator|==
literal|'_'
condition|)
block|{
name|var
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
modifier|*
name|val
init|=
name|getenv
argument_list|(
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Environment variable '%1' undefined"
argument_list|)
operator|.
name|arg
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|includeFile
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|includeFile
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|')'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Bad include syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|'#'
operator|&&
name|cc
operator|!=
literal|'\n'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Trailing garbage"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                   Here is the recursive call.                  */
name|load
argument_list|(
name|location
argument_list|,
name|QFileInfo
argument_list|(
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|dir
argument_list|()
argument_list|,
name|includeFile
argument_list|)
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                   It wasn't an include statement, so it's something else.                   We must see either '=' or '+=' next. If not, fatal error.                  */
if|if
condition|(
name|cc
operator|==
literal|'+'
condition|)
block|{
name|plus
operator|=
literal|true
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|!=
literal|'='
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Expected '=' or '+=' after key"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'\\'
condition|)
block|{
name|int
name|metaCharPos
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\n'
condition|)
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|>
literal|'0'
operator|&&
name|cc
operator|<
literal|'8'
condition|)
block|{
name|word
operator|+=
name|QChar
argument_list|(
name|c
operator|.
name|digitValue
argument_list|()
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|metaCharPos
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"abfnrtv"
argument_list|)
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|word
operator|+=
name|QLatin1Char
argument_list|(
literal|"\a\b\f\n\r\t\v"
index|[
name|metaCharPos
index|]
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
operator|||
name|cc
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|inQuote
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'\n'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|metWord
condition|)
name|stringValue
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|stringValue
operator|+=
name|word
expr_stmt|;
if|#
directive|if
literal|0
block|if (metWord)                                     rhsValues<< QString(" " + word);                                 else
endif|#
directive|endif
name|rhsValues
operator|<<
name|word
expr_stmt|;
name|metWord
operator|=
literal|true
expr_stmt|;
name|word
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prevWordQuoted
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|'\n'
operator|||
name|cc
operator|==
literal|'#'
condition|)
break|break;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|inQuote
condition|)
block|{
if|if
condition|(
operator|!
name|prevWordQuoted
condition|)
name|stringValue
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|stringValue
operator|+=
name|word
expr_stmt|;
if|if
condition|(
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
condition|)
name|rhsValues
operator|<<
name|word
expr_stmt|;
name|metWord
operator|=
literal|true
expr_stmt|;
name|word
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prevWordQuoted
operator|=
literal|true
expr_stmt|;
block|}
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'$'
condition|)
block|{
name|QString
name|var
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|cc
operator|==
literal|'_'
condition|)
block|{
name|var
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
modifier|*
name|val
init|=
name|getenv
argument_list|(
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Environment variable '%1' undefined"
argument_list|)
operator|.
name|arg
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|word
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|inQuote
operator|&&
name|cc
operator|==
literal|'='
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '='"
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
name|QStringList
operator|::
name|ConstIterator
name|key
init|=
name|keys
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|key
operator|!=
name|keys
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|keySyntax
operator|.
name|exactMatch
argument_list|(
operator|*
name|key
argument_list|)
condition|)
name|keyLoc
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Invalid key '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|ConfigVarMultimap
operator|::
name|Iterator
name|i
decl_stmt|;
name|i
operator|=
name|configVars_
operator|.
name|insert
argument_list|(
operator|*
name|key
argument_list|,
name|ConfigVar
argument_list|(
operator|*
name|key
argument_list|,
name|rhsValues
argument_list|,
name|QDir
operator|::
name|currentPath
argument_list|()
argument_list|,
name|keyLoc
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|value
argument_list|()
operator|.
name|plus_
operator|=
operator|(
name|plus
condition|?
literal|true
else|:
literal|false
operator|)
expr_stmt|;
operator|++
name|key
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected character '%1' at beginning of line"
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|popWorkingDir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|workingDirs_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDir
operator|::
name|setCurrent
argument_list|(
name|workingDirs_
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getFilesHere
name|QStringList
name|Config
operator|::
name|getFilesHere
parameter_list|(
specifier|const
name|QString
modifier|&
name|uncleanDir
parameter_list|,
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QString
name|dir
init|=
name|location
operator|.
name|isEmpty
argument_list|()
condition|?
name|QDir
operator|::
name|cleanPath
argument_list|(
name|uncleanDir
argument_list|)
else|:
name|QDir
argument_list|(
name|uncleanDir
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
name|QStringList
name|result
decl_stmt|;
if|if
condition|(
name|excludedDirs
operator|.
name|contains
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|result
return|;
name|QDir
name|dirInfo
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|QStringList
name|fileNames
decl_stmt|;
name|QStringList
operator|::
name|const_iterator
name|fn
decl_stmt|;
name|dirInfo
operator|.
name|setNameFilters
argument_list|(
name|nameFilter
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setSorting
argument_list|(
name|QDir
operator|::
name|Name
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setFilter
argument_list|(
name|QDir
operator|::
name|Files
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|dirInfo
operator|.
name|entryList
argument_list|()
expr_stmt|;
name|fn
operator|=
name|fileNames
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|fn
operator|!=
name|fileNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fn
operator|->
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'~'
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|s
init|=
name|dirInfo
operator|.
name|filePath
argument_list|(
operator|*
name|fn
argument_list|)
decl_stmt|;
name|QString
name|c
init|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|excludedFiles
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|fn
expr_stmt|;
block|}
name|dirInfo
operator|.
name|setNameFilters
argument_list|(
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setFilter
argument_list|(
name|QDir
operator|::
name|Dirs
operator||
name|QDir
operator|::
name|NoDotAndDotDot
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|dirInfo
operator|.
name|entryList
argument_list|()
expr_stmt|;
name|fn
operator|=
name|fileNames
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|fn
operator|!=
name|fileNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
name|dirInfo
operator|.
name|filePath
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|,
name|nameFilter
argument_list|,
name|location
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|fn
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Push \a dir onto the stack of working directories.  */
end_comment
begin_function
DECL|function|pushWorkingDir
name|void
name|Config
operator|::
name|pushWorkingDir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|workingDirs_
operator|.
name|push
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   If the stack of working directories is not empty, pop the   top entry and return it. Otherwise return an empty string.  */
end_comment
begin_function
DECL|function|popWorkingDir
name|QString
name|Config
operator|::
name|popWorkingDir
parameter_list|()
block|{
if|if
condition|(
operator|!
name|workingDirs_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|workingDirs_
operator|.
name|pop
argument_list|()
return|;
block|}
name|qDebug
argument_list|()
operator|<<
literal|"RETURNED EMPTY WORKING DIR"
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
