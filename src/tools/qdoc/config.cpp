begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   config.cpp */
end_comment
begin_include
include|#
directive|include
file|<QDir>
end_include
begin_include
include|#
directive|include
file|<QVariant>
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QTemporaryFile>
end_include
begin_include
include|#
directive|include
file|<QTextStream>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*   An entry on the MetaStack.  */
end_comment
begin_class
DECL|class|MetaStackEntry
class|class
name|MetaStackEntry
block|{
public|public:
name|void
name|open
parameter_list|()
function_decl|;
name|void
name|close
parameter_list|()
function_decl|;
DECL|member|accum
name|QStringList
name|accum
decl_stmt|;
DECL|member|next
name|QStringList
name|next
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*  */
end_comment
begin_function
DECL|function|open
name|void
name|MetaStackEntry
operator|::
name|open
parameter_list|()
block|{
name|next
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  */
end_comment
begin_function
DECL|function|close
name|void
name|MetaStackEntry
operator|::
name|close
parameter_list|()
block|{
name|accum
operator|+=
name|next
expr_stmt|;
name|next
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   ### */
end_comment
begin_class
DECL|class|MetaStack
class|class
name|MetaStack
super|:
specifier|private
name|QStack
argument_list|<
name|MetaStackEntry
argument_list|>
block|{
public|public:
name|MetaStack
parameter_list|()
constructor_decl|;
name|void
name|process
parameter_list|(
name|QChar
name|ch
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
function_decl|;
name|QStringList
name|getExpanded
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|MetaStack
name|MetaStack
operator|::
name|MetaStack
parameter_list|()
block|{
name|push
argument_list|(
name|MetaStackEntry
argument_list|()
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|process
name|void
name|MetaStack
operator|::
name|process
parameter_list|(
name|QChar
name|ch
parameter_list|,
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|MetaStackEntry
argument_list|()
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
argument_list|()
operator|==
literal|1
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '}'"
argument_list|)
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|QStringList
name|suffixes
init|=
name|pop
argument_list|()
operator|.
name|accum
decl_stmt|;
name|QStringList
name|prefixes
init|=
name|top
argument_list|()
operator|.
name|next
decl_stmt|;
name|top
argument_list|()
operator|.
name|next
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|pre
init|=
name|prefixes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|pre
operator|!=
name|prefixes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|suf
init|=
name|suffixes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|suf
operator|!=
name|suffixes
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|top
argument_list|()
operator|.
name|next
operator|<<
operator|(
operator|*
name|pre
operator|+
operator|*
name|suf
operator|)
expr_stmt|;
operator|++
name|suf
expr_stmt|;
block|}
operator|++
name|pre
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|&&
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|top
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QStringList
operator|::
name|Iterator
name|pre
init|=
name|top
argument_list|()
operator|.
name|next
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|pre
operator|!=
name|top
argument_list|()
operator|.
name|next
operator|.
name|end
argument_list|()
condition|)
block|{
operator|*
name|pre
operator|+=
name|ch
expr_stmt|;
operator|++
name|pre
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|getExpanded
name|QStringList
name|MetaStack
operator|::
name|getExpanded
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|)
block|{
if|if
condition|(
name|count
argument_list|()
operator|>
literal|1
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Missing '}'"
argument_list|)
argument_list|)
expr_stmt|;
name|top
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|top
argument_list|()
operator|.
name|accum
return|;
block|}
end_function
begin_decl_stmt
DECL|member|dot
name|QT_STATIC_CONST_IMPL
name|QString
name|Config
operator|::
name|dot
init|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|generateExamples
name|bool
name|Config
operator|::
name|generateExamples
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|overrideOutputDir
name|QString
name|Config
operator|::
name|overrideOutputDir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|installDir
name|QString
name|Config
operator|::
name|installDir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|overrideOutputFormats
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|overrideOutputFormats
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|extractedDirs
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|Config
operator|::
name|extractedDirs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|numInstances
name|int
name|Config
operator|::
name|numInstances
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   \class Config   \brief The Config class contains the configuration variables   for controlling how qdoc produces documentation.    Its load() function, reads, parses, and processes a qdocconf file.  */
end_comment
begin_comment
comment|/*!   The constructor sets the \a programName and initializes all   internal state variables to empty values.  */
end_comment
begin_constructor
DECL|function|Config
name|Config
operator|::
name|Config
parameter_list|(
specifier|const
name|QString
modifier|&
name|programName
parameter_list|)
member_init_list|:
name|prog
argument_list|(
name|programName
argument_list|)
block|{
name|loc
operator|=
name|Location
operator|::
name|null
expr_stmt|;
name|lastLoc
operator|=
name|Location
operator|::
name|null
expr_stmt|;
name|locMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stringValueMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stringListValueMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|numInstances
operator|++
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   The destructor has nothing special to do.  */
end_comment
begin_destructor
DECL|function|~Config
name|Config
operator|::
name|~
name|Config
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Loads and parses the qdoc configuration file \a fileName.   This function calls the other load() function, which does   the loading, parsing, and processing of the configuration   file.    Intializes the location variables returned by location()   and lastLocation().  */
end_comment
begin_function
DECL|function|load
name|void
name|Config
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|load
argument_list|(
name|Location
operator|::
name|null
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|loc
operator|=
name|Location
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loc
operator|.
name|setEtc
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|lastLoc
operator|=
name|Location
operator|::
name|null
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Writes the qdoc configuration data to the named file.   The previous contents of the file are overwritten.  */
end_comment
begin_function
DECL|function|unload
name|void
name|Config
operator|::
name|unload
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QStringMultiMap
operator|::
name|ConstIterator
name|v
init|=
name|stringValueMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|v
operator|!=
name|stringValueMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
name|v
operator|.
name|key
argument_list|()
operator|<<
literal|" = "
operator|<<
name|v
operator|.
name|value
argument_list|()
expr_stmt|;
operator|++
name|v
expr_stmt|;
block|}
name|qDebug
argument_list|()
operator|<<
literal|"fileName:"
operator|<<
name|fileName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Joins all the strings in \a values into a single string with the   individual \a values separated by ' '. Then it inserts the result   into the string list map with \a var as the key.    It also inserts the \a values string list into a separate map,   also with \a var as the key.  */
end_comment
begin_function
DECL|function|setStringList
name|void
name|Config
operator|::
name|setStringList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|values
parameter_list|)
block|{
name|stringValueMap
index|[
name|var
index|]
operator|=
name|values
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|stringListValueMap
index|[
name|var
index|]
operator|=
name|values
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuarion variable \a var in the string   map and returns the boolean value.  */
end_comment
begin_function
DECL|function|getBool
name|bool
name|Config
operator|::
name|getBool
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|getString
argument_list|(
name|var
argument_list|)
argument_list|)
operator|.
name|toBool
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string list   map. Iterates through the string list found, interpreting each   string in the list as an integer and adding it to a total sum.   Returns the sum.  */
end_comment
begin_function
DECL|function|getInt
name|int
name|Config
operator|::
name|getInt
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|strs
init|=
name|getStringList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|s
init|=
name|strs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|strs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|sum
operator|+=
operator|(
operator|*
name|s
operator|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function
begin_comment
comment|/*!   Function to return the correct outputdir.   outputdir can be set using the qdocconf or the command-line   variable -outputdir.   */
end_comment
begin_function
DECL|function|getOutputDir
name|QString
name|Config
operator|::
name|getOutputDir
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|overrideOutputDir
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|getString
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OUTPUTDIR
argument_list|)
argument_list|)
return|;
else|else
return|return
name|overrideOutputDir
return|;
block|}
end_function
begin_comment
comment|/*!   Function to return the correct outputformats.   outputformats can be set using the qdocconf or the command-line   variable -outputformat.   */
end_comment
begin_function
DECL|function|getOutputFormats
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|getOutputFormats
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|overrideOutputFormats
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|getStringSet
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_OUTPUTFORMATS
argument_list|)
argument_list|)
return|;
else|else
return|return
name|overrideOutputFormats
return|;
block|}
end_function
begin_comment
comment|/*!   First, this function looks up the configuration variable \a var   in the location map and, if found, sets the internal variable   \c{lastLoc} to the Location that \a var maps to.    Then it looks up the configuration variable \a var in the string   map, and returns the string that \a var maps to.  */
end_comment
begin_function
DECL|function|getString
name|QString
name|Config
operator|::
name|getString
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|locMap
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLoc
operator|=
name|locMap
index|[
name|var
index|]
expr_stmt|;
return|return
name|stringValueMap
index|[
name|var
index|]
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string   list map, converts the string list it maps to into a set   of strings, and returns the set.  */
end_comment
begin_function
DECL|function|getStringSet
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|getStringSet
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
return|return
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|fromList
argument_list|(
name|getStringList
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   First, this function looks up the configuration variable \a var   in the location map and, if found, sets the internal variable   \c{lastLoc} the Location that \a var maps to.    Then it looks up the configuration variable \a var in the string   list map, and returns the string list that \a var maps to.  */
end_comment
begin_function
DECL|function|getStringList
name|QStringList
name|Config
operator|::
name|getStringList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|locMap
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLoc
operator|=
name|locMap
index|[
name|var
index|]
expr_stmt|;
return|return
name|stringListValueMap
index|[
name|var
index|]
return|;
block|}
end_function
begin_comment
comment|/*!   This function should only be called when the configuration   variable \a var maps to a string list that contains file paths.   It cleans the paths with QDir::cleanPath() before returning   them.    First, this function looks up the configuration variable \a var   in the location map and, if found, sets the internal variable   \c{lastLoc} the Location that \a var maps to.    Then it looks up the configuration variable \a var in the string   list map, which maps to a string list that contains file paths.   These paths might not be clean, so QDir::cleanPath() is called   for each one. The string list returned contains cleaned paths.  */
end_comment
begin_function
DECL|function|getCleanPathList
name|QStringList
name|Config
operator|::
name|getCleanPathList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|locMap
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
name|Location
operator|&
operator|)
name|lastLoc
operator|=
name|locMap
index|[
name|var
index|]
expr_stmt|;
name|QStringList
name|t
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|stringListValueMap
operator|.
name|constFind
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|stringListValueMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|QStringList
modifier|&
name|sl
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|reserve
argument_list|(
name|sl
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|.
name|append
argument_list|(
name|QDir
operator|::
name|cleanPath
argument_list|(
name|sl
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Calls getRegExpList() with the control variable \a var and   iterates through the resulting list of regular expressions,   concatening them with some extras characters to form a single   QRegExp, which is returned/    \sa getRegExpList()  */
end_comment
begin_function
DECL|function|getRegExp
name|QRegExp
name|Config
operator|::
name|getRegExp
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QString
name|pattern
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|subRegExps
init|=
name|getRegExpList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|subRegExps
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|subRegExps
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|isValid
argument_list|()
condition|)
return|return
operator|*
name|s
return|;
if|if
condition|(
operator|!
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
name|pattern
operator|+=
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|pattern
operator|+=
name|QLatin1String
argument_list|(
literal|"(?:"
argument_list|)
operator|+
operator|(
operator|*
name|s
operator|)
operator|.
name|pattern
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
name|pattern
operator|=
name|QLatin1String
argument_list|(
literal|"$x"
argument_list|)
expr_stmt|;
comment|// cannot match
return|return
name|QRegExp
argument_list|(
name|pattern
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Looks up the configuration variable \a var in the string list   map, converts the string list to a list of regular expressions,   and returns it.  */
end_comment
begin_function
DECL|function|getRegExpList
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|Config
operator|::
name|getRegExpList
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QStringList
name|strs
init|=
name|getStringList
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|s
init|=
name|strs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QRegExp
argument_list|>
name|regExps
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|strs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|regExps
operator|+=
name|QRegExp
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|regExps
return|;
block|}
end_function
begin_comment
comment|/*!   This function is slower than it could be. What it does is   find all the keys that begin with \a var + dot and return   the matching keys in a set, stripped of the matching prefix   and dot.  */
end_comment
begin_function
DECL|function|subVars
name|QSet
argument_list|<
name|QString
argument_list|>
name|Config
operator|::
name|subVars
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|)
specifier|const
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|result
decl_stmt|;
name|QString
name|varDot
init|=
name|var
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|QStringMultiMap
operator|::
name|ConstIterator
name|v
init|=
name|stringValueMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|v
operator|!=
name|stringValueMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|v
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|varDot
argument_list|)
condition|)
block|{
name|QString
name|subVar
init|=
name|v
operator|.
name|key
argument_list|()
operator|.
name|mid
argument_list|(
name|varDot
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
name|subVar
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|-
literal|1
condition|)
name|subVar
operator|.
name|truncate
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|result
operator|.
name|insert
argument_list|(
name|subVar
argument_list|)
expr_stmt|;
block|}
operator|++
name|v
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Same as subVars(), but in this case we return a string map   with the matching keys (stripped of the prefix \a var and   mapped to their values. The pairs are inserted into \a t  */
end_comment
begin_function
DECL|function|subVarsAndValues
name|void
name|Config
operator|::
name|subVarsAndValues
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|,
name|QStringMultiMap
modifier|&
name|t
parameter_list|)
specifier|const
block|{
name|QString
name|varDot
init|=
name|var
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|QStringMultiMap
operator|::
name|ConstIterator
name|v
init|=
name|stringValueMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|v
operator|!=
name|stringValueMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|v
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|varDot
argument_list|)
condition|)
block|{
name|QString
name|subVar
init|=
name|v
operator|.
name|key
argument_list|()
operator|.
name|mid
argument_list|(
name|varDot
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
name|subVar
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|-
literal|1
condition|)
name|subVar
operator|.
name|truncate
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|t
operator|.
name|insert
argument_list|(
name|subVar
argument_list|,
name|v
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|v
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Builds and returns a list of file pathnames for the file   type specified by \a filesVar (e.g. "headers" or "sources").   The files are found in the directories specified by   \a dirsVar, and they are filtered by \a defaultNameFilter   if a better filter can't be constructed from \a filesVar.   The directories in \a excludedDirs are avoided. The files   in \a excludedFiles are not included in the return list.  */
end_comment
begin_function
DECL|function|getAllFiles
name|QStringList
name|Config
operator|::
name|getAllFiles
parameter_list|(
specifier|const
name|QString
modifier|&
name|filesVar
parameter_list|,
specifier|const
name|QString
modifier|&
name|dirsVar
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QStringList
name|result
init|=
name|getStringList
argument_list|(
name|filesVar
argument_list|)
decl_stmt|;
name|QStringList
name|dirs
init|=
name|getStringList
argument_list|(
name|dirsVar
argument_list|)
decl_stmt|;
name|QString
name|nameFilter
init|=
name|getString
argument_list|(
name|filesVar
operator|+
name|dot
operator|+
name|QLatin1String
argument_list|(
name|CONFIG_FILEEXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
operator|*
name|d
argument_list|,
name|nameFilter
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \a fileName is the path of the file to find.    \a files and \a dirs are the lists where we must find the   components of \a fileName.    \a location is used for obtaining the file and line numbers   for report qdoc errors.  */
end_comment
begin_function
DECL|function|findFile
name|QString
name|Config
operator|::
name|findFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|files
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|dirs
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|&
name|userFriendlyFilePath
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
name|userFriendlyFilePath
operator|=
name|fileName
expr_stmt|;
return|return
name|fileName
return|;
block|}
name|QFileInfo
name|fileInfo
decl_stmt|;
name|QStringList
name|components
init|=
name|fileName
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|firstComponent
init|=
name|components
operator|.
name|first
argument_list|()
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|f
init|=
name|files
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|files
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
name|firstComponent
operator|||
operator|(
operator|*
name|f
operator|)
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|firstComponent
argument_list|)
condition|)
block|{
name|fileInfo
operator|.
name|setFile
argument_list|(
operator|*
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"File '%1' does not exist"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|fileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|d
init|=
name|dirs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|!=
name|dirs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|fileInfo
operator|.
name|setFile
argument_list|(
name|QDir
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|firstComponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
break|break;
block|}
operator|++
name|d
expr_stmt|;
block|}
block|}
name|userFriendlyFilePath
operator|=
name|QString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QStringList
operator|::
name|ConstIterator
name|c
init|=
name|components
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|isArchive
init|=
operator|(
name|c
operator|!=
name|components
operator|.
name|constEnd
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|QString
name|userFriendly
init|=
operator|*
name|c
decl_stmt|;
name|userFriendlyFilePath
operator|+=
name|userFriendly
expr_stmt|;
if|if
condition|(
name|isArchive
condition|)
block|{
name|QString
name|extracted
init|=
name|extractedDirs
index|[
name|fileInfo
operator|.
name|filePath
argument_list|()
index|]
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|fileInfo
operator|.
name|setFile
argument_list|(
name|QDir
argument_list|(
name|extracted
argument_list|)
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|userFriendlyFilePath
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
return|return
name|fileInfo
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findFile
name|QString
name|Config
operator|::
name|findFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|files
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|dirs
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileBase
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|fileExtensions
parameter_list|,
name|QString
modifier|&
name|userFriendlyFilePath
parameter_list|)
block|{
name|QStringList
operator|::
name|ConstIterator
name|e
init|=
name|fileExtensions
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|fileExtensions
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
name|findFile
argument_list|(
name|location
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fileBase
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
operator|*
name|e
argument_list|,
name|userFriendlyFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|filePath
return|;
operator|++
name|e
expr_stmt|;
block|}
return|return
name|findFile
argument_list|(
name|location
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fileBase
argument_list|,
name|userFriendlyFilePath
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Copies the \a sourceFilePath to the file name constructed by   concatenating \a targetDirPath and \a userFriendlySourceFilePath.   \a location is for identifying the file and line number where   a qdoc error occurred. The constructed output file name is   returned.  */
end_comment
begin_function
DECL|function|copyFile
name|QString
name|Config
operator|::
name|copyFile
parameter_list|(
specifier|const
name|Location
modifier|&
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|sourceFilePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|userFriendlySourceFilePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|targetDirPath
parameter_list|)
block|{
name|QFile
name|inFile
argument_list|(
name|sourceFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open input file '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|sourceFilePath
argument_list|)
operator|.
name|arg
argument_list|(
name|inFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|outFileName
init|=
name|userFriendlySourceFilePath
decl_stmt|;
name|int
name|slash
init|=
name|outFileName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
name|outFileName
operator|=
name|outFileName
operator|.
name|mid
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|QFile
name|outFile
argument_list|(
name|targetDirPath
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|outFileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outFile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open output file '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|outFile
operator|.
name|fileName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|outFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|inFile
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|outFile
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|outFileName
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the largest unicode digit in \a value in the range   1..7 and returns it.  */
end_comment
begin_function
DECL|function|numParams
name|int
name|Config
operator|::
name|numParams
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|uint
name|c
init|=
name|value
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
literal|8
condition|)
name|max
operator|=
name|qMax
argument_list|(
name|max
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
end_function
begin_comment
comment|/*!   Removes everything from \a dir. This function is recursive.   It doesn't remove \a dir itself, but if it was called   recursively, then the caller will remove \a dir.  */
end_comment
begin_function
DECL|function|removeDirContents
name|bool
name|Config
operator|::
name|removeDirContents
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|QDir
name|dirInfo
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|QFileInfoList
name|entries
init|=
name|dirInfo
operator|.
name|entryInfoList
argument_list|()
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|QFileInfoList
operator|::
name|Iterator
name|it
init|=
name|entries
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|entries
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|remove
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|removeDirContents
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dirInfo
operator|.
name|rmdir
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|fileName
argument_list|()
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
operator|++
name|it
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if \a ch is a letter, number, '_', '.',   '{', '}', or ','.  */
end_comment
begin_function
DECL|function|isMetaKeyChar
name|bool
name|Config
operator|::
name|isMetaKeyChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Load, parse, and process a qdoc configuration file. This   function is only called by the other load() function, but   this one is recursive, i.e., it calls itself when it sees   an \c{include} statement in the qdoc configuration file.  */
end_comment
begin_function
DECL|function|load
name|void
name|Config
operator|::
name|load
parameter_list|(
name|Location
name|location
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QRegExp
name|keySyntax
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\w+(?:\\.\\w+)*"
argument_list|)
argument_list|)
decl_stmt|;
DECL|macro|SKIP_CHAR
define|#
directive|define
name|SKIP_CHAR
parameter_list|()
define|\
value|do { \     location.advance(c); \     ++i; \     c = text.at(i); \     cc = c.unicode(); \ } while (0)
DECL|macro|SKIP_SPACES
define|#
directive|define
name|SKIP_SPACES
parameter_list|()
define|\
value|while (c.isSpace()&& cc != '\n') \     SKIP_CHAR()
DECL|macro|PUT_CHAR
define|#
directive|define
name|PUT_CHAR
parameter_list|()
define|\
value|word += c; \     SKIP_CHAR();
if|if
condition|(
name|location
operator|.
name|depth
argument_list|()
operator|>
literal|16
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Too many nested includes"
argument_list|)
argument_list|)
expr_stmt|;
name|QFile
name|fin
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fin
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Config
operator|::
name|installDir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|prefix
init|=
name|location
operator|.
name|filePath
argument_list|()
operator|.
name|length
argument_list|()
operator|-
name|location
operator|.
name|fileName
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|fin
operator|.
name|setFileName
argument_list|(
name|Config
operator|::
name|installDir
operator|+
literal|"/"
operator|+
name|fileName
operator|.
name|right
argument_list|(
name|fileName
operator|.
name|length
argument_list|()
operator|-
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fin
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Text
argument_list|)
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open file '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
operator|.
name|arg
argument_list|(
name|fin
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QTextStream
name|stream
argument_list|(
operator|&
name|fin
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setCodec
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|QString
name|text
init|=
name|stream
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|text
operator|+=
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|text
operator|+=
name|QLatin1Char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|fin
operator|.
name|close
argument_list|()
expr_stmt|;
name|location
operator|.
name|push
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|location
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QChar
name|c
init|=
name|text
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|uint
name|cc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
block|{
do|do
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|!=
literal|'\n'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|isMetaKeyChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|Location
name|keyLoc
init|=
name|location
decl_stmt|;
name|bool
name|plus
init|=
literal|false
decl_stmt|;
name|QString
name|stringValue
decl_stmt|;
name|QStringList
name|stringListValue
decl_stmt|;
name|QString
name|word
decl_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
name|bool
name|prevWordQuoted
init|=
literal|true
decl_stmt|;
name|bool
name|metWord
init|=
literal|false
decl_stmt|;
name|MetaStack
name|stack
decl_stmt|;
do|do
block|{
name|stack
operator|.
name|process
argument_list|(
name|c
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isMetaKeyChar
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|QStringList
name|keys
init|=
name|stack
operator|.
name|getExpanded
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|keys
operator|.
name|count
argument_list|()
operator|==
literal|1
operator|&&
name|keys
operator|.
name|first
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"include"
argument_list|)
condition|)
block|{
name|QString
name|includeFile
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|'('
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Bad include syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|c
operator|.
name|isSpace
argument_list|()
operator|&&
name|cc
operator|!=
literal|'#'
operator|&&
name|cc
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'$'
condition|)
block|{
name|QString
name|var
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|cc
operator|==
literal|'_'
condition|)
block|{
name|var
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
modifier|*
name|val
init|=
name|getenv
argument_list|(
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Environment variable '%1' undefined"
argument_list|)
operator|.
name|arg
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|includeFile
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|includeFile
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|')'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Bad include syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|'#'
operator|&&
name|cc
operator|!=
literal|'\n'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Trailing garbage"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                   Here is the recursive call.                  */
name|load
argument_list|(
name|location
argument_list|,
name|QFileInfo
argument_list|(
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|dir
argument_list|()
argument_list|,
name|includeFile
argument_list|)
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                   It wasn't an include statement, so it's something else.                  */
if|if
condition|(
name|cc
operator|==
literal|'+'
condition|)
block|{
name|plus
operator|=
literal|true
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|!=
literal|'='
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Expected '=' or '+=' after key"
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'\\'
condition|)
block|{
name|int
name|metaCharPos
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\n'
condition|)
block|{
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|>
literal|'0'
operator|&&
name|cc
operator|<
literal|'8'
condition|)
block|{
name|word
operator|+=
name|QChar
argument_list|(
name|c
operator|.
name|digitValue
argument_list|()
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|metaCharPos
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"abfnrtv"
argument_list|)
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|word
operator|+=
name|QLatin1Char
argument_list|(
literal|"\a\b\f\n\r\t\v"
index|[
name|metaCharPos
index|]
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
operator|||
name|cc
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|inQuote
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|'\n'
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|metWord
condition|)
name|stringValue
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|stringValue
operator|+=
name|word
expr_stmt|;
name|stringListValue
operator|<<
name|word
expr_stmt|;
name|metWord
operator|=
literal|true
expr_stmt|;
name|word
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prevWordQuoted
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|'\n'
operator|||
name|cc
operator|==
literal|'#'
condition|)
break|break;
name|SKIP_SPACES
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|inQuote
condition|)
block|{
if|if
condition|(
operator|!
name|prevWordQuoted
condition|)
name|stringValue
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|stringValue
operator|+=
name|word
expr_stmt|;
if|if
condition|(
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
condition|)
name|stringListValue
operator|<<
name|word
expr_stmt|;
name|metWord
operator|=
literal|true
expr_stmt|;
name|word
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prevWordQuoted
operator|=
literal|true
expr_stmt|;
block|}
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'$'
condition|)
block|{
name|QString
name|var
decl_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|cc
operator|==
literal|'_'
condition|)
block|{
name|var
operator|+=
name|c
expr_stmt|;
name|SKIP_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|char
modifier|*
name|val
init|=
name|getenv
argument_list|(
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Environment variable '%1' undefined"
argument_list|)
operator|.
name|arg
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|word
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|inQuote
operator|&&
name|cc
operator|==
literal|'='
condition|)
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected '='"
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|()
expr_stmt|;
block|}
block|}
name|QStringList
operator|::
name|ConstIterator
name|key
init|=
name|keys
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|key
operator|!=
name|keys
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|keySyntax
operator|.
name|exactMatch
argument_list|(
operator|*
name|key
argument_list|)
condition|)
name|keyLoc
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Invalid key '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plus
condition|)
block|{
if|if
condition|(
name|locMap
index|[
operator|*
name|key
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|locMap
index|[
operator|*
name|key
index|]
operator|=
name|keyLoc
expr_stmt|;
block|}
else|else
block|{
name|locMap
index|[
operator|*
name|key
index|]
operator|.
name|setEtc
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stringValueMap
index|[
operator|*
name|key
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stringValueMap
index|[
operator|*
name|key
index|]
operator|=
name|stringValue
expr_stmt|;
block|}
else|else
block|{
name|stringValueMap
index|[
operator|*
name|key
index|]
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|stringValue
expr_stmt|;
block|}
name|stringListValueMap
index|[
operator|*
name|key
index|]
operator|+=
name|stringListValue
expr_stmt|;
block|}
else|else
block|{
name|locMap
index|[
operator|*
name|key
index|]
operator|=
name|keyLoc
expr_stmt|;
name|stringValueMap
index|[
operator|*
name|key
index|]
operator|=
name|stringValue
expr_stmt|;
name|stringListValueMap
index|[
operator|*
name|key
index|]
operator|=
name|stringListValue
expr_stmt|;
block|}
operator|++
name|key
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|location
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Unexpected character '%1' at beginning of line"
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|getFilesHere
name|QStringList
name|Config
operator|::
name|getFilesHere
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|,
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedDirs
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|excludedFiles
parameter_list|)
block|{
name|QStringList
name|result
decl_stmt|;
if|if
condition|(
name|excludedDirs
operator|.
name|contains
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|result
return|;
name|QDir
name|dirInfo
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|QStringList
name|fileNames
decl_stmt|;
name|QStringList
operator|::
name|const_iterator
name|fn
decl_stmt|;
name|dirInfo
operator|.
name|setNameFilters
argument_list|(
name|nameFilter
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setSorting
argument_list|(
name|QDir
operator|::
name|Name
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setFilter
argument_list|(
name|QDir
operator|::
name|Files
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|dirInfo
operator|.
name|entryList
argument_list|()
expr_stmt|;
name|fn
operator|=
name|fileNames
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|fn
operator|!=
name|fileNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fn
operator|->
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'~'
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|s
init|=
name|dirInfo
operator|.
name|filePath
argument_list|(
operator|*
name|fn
argument_list|)
decl_stmt|;
name|QString
name|c
init|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|excludedFiles
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|fn
expr_stmt|;
block|}
name|dirInfo
operator|.
name|setNameFilters
argument_list|(
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dirInfo
operator|.
name|setFilter
argument_list|(
name|QDir
operator|::
name|Dirs
operator||
name|QDir
operator|::
name|NoDotAndDotDot
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|dirInfo
operator|.
name|entryList
argument_list|()
expr_stmt|;
name|fn
operator|=
name|fileNames
operator|.
name|constBegin
argument_list|()
expr_stmt|;
while|while
condition|(
name|fn
operator|!=
name|fileNames
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|result
operator|+=
name|getFilesHere
argument_list|(
name|dirInfo
operator|.
name|filePath
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|,
name|nameFilter
argument_list|,
name|excludedDirs
argument_list|,
name|excludedFiles
argument_list|)
expr_stmt|;
operator|++
name|fn
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
