begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*   pagegenerator.cpp */
end_comment
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"pagegenerator.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   Nothing to do in the constructor.  */
end_comment
begin_constructor
DECL|function|PageGenerator
name|PageGenerator
operator|::
name|PageGenerator
parameter_list|()
member_init_list|:
name|outputCodec
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   The destructor  */
end_comment
begin_destructor
DECL|function|~PageGenerator
name|PageGenerator
operator|::
name|~
name|PageGenerator
parameter_list|()
block|{
while|while
condition|(
operator|!
name|outStreamStack
operator|.
name|isEmpty
argument_list|()
condition|)
name|endSubPage
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|parseArg
name|bool
name|PageGenerator
operator|::
name|parseArg
parameter_list|(
specifier|const
name|QString
modifier|&
name|src
parameter_list|,
specifier|const
name|QString
modifier|&
name|tag
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
name|n
parameter_list|,
name|QStringRef
modifier|*
name|contents
parameter_list|,
name|QStringRef
modifier|*
name|par1
parameter_list|,
name|bool
name|debug
parameter_list|)
block|{
DECL|macro|SKIP_CHAR
define|#
directive|define
name|SKIP_CHAR
parameter_list|(
name|c
parameter_list|)
define|\
value|if (debug) \     qDebug()<< "looking for "<< c<< " at "<< QString(src.data() + i, n - i); \     if (i>= n || src[i] != c) { \     if (debug) \     qDebug()<< " char '"<< c<< "' not found"; \     return false; \ } \     ++i;
DECL|macro|SKIP_SPACE
define|#
directive|define
name|SKIP_SPACE
define|\
value|while (i< n&& src[i] == ' ') \     ++i;
name|int
name|i
init|=
operator|*
name|pos
decl_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// assume "<@" has been parsed outside
comment|//SKIP_CHAR('<');
comment|//SKIP_CHAR('@');
if|if
condition|(
name|tag
operator|!=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|&&
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"tag "
operator|<<
name|tag
operator|<<
literal|" not found at "
operator|<<
name|i
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"haystack:"
operator|<<
name|src
operator|<<
literal|"needle:"
operator|<<
name|tag
operator|<<
literal|"i:"
operator|<<
name|i
expr_stmt|;
comment|// skip tag
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// parse stuff like:  linkTag("(<@link node=\"([^\"]+)\">).*(</@link>)");
if|if
condition|(
name|par1
condition|)
block|{
name|SKIP_SPACE
expr_stmt|;
comment|// read parameter name
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
index|[
name|i
index|]
operator|.
name|isLetter
argument_list|()
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"read parameter"
operator|<<
name|QString
argument_list|(
name|src
operator|.
name|data
argument_list|()
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|// skip parameter name
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|src
index|[
name|i
index|]
operator|!=
literal|'"'
condition|)
operator|++
name|i
expr_stmt|;
operator|*
name|par1
operator|=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|SKIP_SPACE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"no optional parameter found"
expr_stmt|;
block|}
block|}
name|SKIP_SPACE
expr_stmt|;
name|SKIP_CHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
comment|// find contents up to closing "</@tag>
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
literal|true
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|4
operator|+
name|tag
operator|.
name|length
argument_list|()
operator|>
name|n
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|!=
literal|'<'
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|'@'
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|!=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|i
operator|+
literal|3
argument_list|,
name|tag
operator|.
name|length
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|src
index|[
name|i
operator|+
literal|3
operator|+
name|tag
operator|.
name|length
argument_list|()
index|]
operator|!=
literal|'>'
condition|)
continue|continue;
break|break;
block|}
operator|*
name|contents
operator|=
name|QStringRef
argument_list|(
operator|&
name|src
argument_list|,
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|i
operator|+=
name|tag
operator|.
name|length
argument_list|()
operator|+
literal|4
expr_stmt|;
operator|*
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|" tag "
operator|<<
name|tag
operator|<<
literal|" found: pos now: "
operator|<<
name|i
expr_stmt|;
return|return
literal|true
return|;
DECL|macro|SKIP_CHAR
undef|#
directive|undef
name|SKIP_CHAR
block|}
end_function
begin_comment
comment|/*!   This function is recursive.  */
end_comment
begin_function
DECL|function|generateTree
name|void
name|PageGenerator
operator|::
name|generateTree
parameter_list|(
specifier|const
name|Tree
modifier|*
name|tree
parameter_list|)
block|{
name|generateInnerNode
argument_list|(
name|tree
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fileBase
name|QString
name|PageGenerator
operator|::
name|fileBase
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|node
operator|->
name|relates
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|relates
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|isInnerNode
argument_list|()
condition|)
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
name|QString
name|base
init|=
name|node
operator|->
name|doc
argument_list|()
operator|.
name|baseName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|base
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|base
return|;
specifier|const
name|Node
modifier|*
name|p
init|=
name|node
decl_stmt|;
forever|forever
block|{
specifier|const
name|Node
modifier|*
name|pp
init|=
name|p
operator|->
name|parent
argument_list|()
decl_stmt|;
name|base
operator|.
name|prepend
argument_list|(
name|p
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|base
operator|.
name|prepend
argument_list|(
name|p
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
name|QChar
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
comment|/*           To avoid file name conflicts in the html directory,           we prepend a prefix (by default, "qml-") to the file name of QML           element doc files.          */
if|if
condition|(
operator|(
name|p
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
operator|||
operator|(
name|p
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlBasicType
operator|)
condition|)
block|{
name|base
operator|.
name|prepend
argument_list|(
name|outputPrefix
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pp
operator|||
name|pp
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|pp
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
break|break;
name|base
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
block|{
specifier|const
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncn
operator|->
name|currentChild
argument_list|()
condition|)
return|return
name|fileBase
argument_list|(
name|ncn
operator|->
name|currentChild
argument_list|()
argument_list|)
return|;
name|base
operator|.
name|prepend
argument_list|(
literal|"collision-"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QDOC2_COMPAT
if|if
condition|(
name|base
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|base
operator|.
name|truncate
argument_list|(
name|base
operator|.
name|length
argument_list|()
operator|-
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// the code below is effectively equivalent to:
comment|//   base.replace(QRegExp("[^A-Za-z0-9]+"), " ");
comment|//   base = base.trimmed();
comment|//   base.replace(QLatin1Char(' '), QLatin1Char('-'));
comment|//   base = base.toLower();
comment|// as this function accounted for ~8% of total running time
comment|// we optimize a bit...
name|QString
name|res
decl_stmt|;
comment|// +5 prevents realloc in fileName() below
name|res
operator|.
name|reserve
argument_list|(
name|base
operator|.
name|size
argument_list|()
operator|+
literal|5
argument_list|)
expr_stmt|;
name|bool
name|begun
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|base
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|c
init|=
name|base
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
condition|)
name|u
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|res
operator|+=
name|QLatin1Char
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|begun
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begun
condition|)
block|{
name|res
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|begun
operator|=
literal|false
expr_stmt|;
block|}
block|}
while|while
condition|(
name|res
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|)
name|res
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!   If the \a node has a URL, return the URL as the file name.   Otherwise, construct the file name from the fileBase() and   the fileExtension(), and return the constructed name.  */
end_comment
begin_function
DECL|function|fileName
name|QString
name|PageGenerator
operator|::
name|fileName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|node
operator|->
name|url
argument_list|()
return|;
name|QString
name|name
init|=
name|fileBase
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|name
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|name
operator|+=
name|fileExtension
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_comment
comment|/*!   Return the current output file name.  */
end_comment
begin_function
DECL|function|outFileName
name|QString
name|PageGenerator
operator|::
name|outFileName
parameter_list|()
block|{
return|return
name|QFileInfo
argument_list|(
cast|static_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|out
argument_list|()
operator|.
name|device
argument_list|()
argument_list|)
operator|->
name|fileName
argument_list|()
argument_list|)
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Creates the file named \a fileName in the output directory.   Attaches a QTextStream to the created file, which is written   to all over the place using out().  */
end_comment
begin_function
DECL|function|beginSubPage
name|void
name|PageGenerator
operator|::
name|beginSubPage
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QString
name|path
init|=
name|outputDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|path
operator|+=
name|node
operator|->
name|outputSubdirectory
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|path
operator|+=
name|fileName
expr_stmt|;
name|QFile
modifier|*
name|outFile
init|=
operator|new
name|QFile
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outFile
operator|->
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
condition|)
name|node
operator|->
name|location
argument_list|()
operator|.
name|fatal
argument_list|(
name|tr
argument_list|(
literal|"Cannot open output file '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|outFile
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTextStream
modifier|*
name|out
init|=
operator|new
name|QTextStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputCodec
condition|)
name|out
operator|->
name|setCodec
argument_list|(
name|outputCodec
argument_list|)
expr_stmt|;
name|outStreamStack
operator|.
name|push
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Flush the text stream associated with the subpage, and   then pop it off the text stream stack and delete it.   This terminates output of the subpage.  */
end_comment
begin_function
DECL|function|endSubPage
name|void
name|PageGenerator
operator|::
name|endSubPage
parameter_list|()
block|{
name|outStreamStack
operator|.
name|top
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
operator|delete
name|outStreamStack
operator|.
name|top
argument_list|()
operator|->
name|device
argument_list|()
expr_stmt|;
operator|delete
name|outStreamStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Used for writing to the current output stream. Returns a   reference to the crrent output stream, which is then used   with the \c {<<} operator for writing.  */
end_comment
begin_function
DECL|function|out
name|QTextStream
modifier|&
name|PageGenerator
operator|::
name|out
parameter_list|()
block|{
return|return
operator|*
name|outStreamStack
operator|.
name|top
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Recursive writing of HTML files from the root \a node.    \note NameCollisionNodes are skipped here and processed   later. See HtmlGenerator::generateDisambiguationPages()   for more on this.  */
end_comment
begin_function
name|void
DECL|function|generateInnerNode
name|PageGenerator
operator|::
name|generateInnerNode
parameter_list|(
specifier|const
name|InnerNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|url
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
specifier|const
name|FakeNode
modifier|*
name|fakeNode
init|=
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|ExternalPage
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Image
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
return|return;
if|if
condition|(
name|fakeNode
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Page
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|count
argument_list|()
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"PAGE %s HAS CHILDREN"
argument_list|,
name|qPrintable
argument_list|(
name|fakeNode
operator|->
name|title
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*       Obtain a code marker for the source file.      */
name|CodeMarker
modifier|*
name|marker
init|=
name|CodeMarker
operator|::
name|markerForFileName
argument_list|(
name|node
operator|->
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/*           Skip name collision nodes here and process them           later in generateDisambiguationPages(). Each one           is appended to a list for later.          */
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|)
condition|)
block|{
specifier|const
name|NameCollisionNode
modifier|*
name|ncn
init|=
cast|static_cast
argument_list|<
specifier|const
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|collisionNodes
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|NameCollisionNode
operator|*
argument_list|>
argument_list|(
name|ncn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beginSubPage
argument_list|(
name|node
argument_list|,
name|fileName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
name|generateClassLikeNode
argument_list|(
name|node
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Fake
condition|)
block|{
name|generateFakeNode
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|FakeNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
name|endSubPage
argument_list|()
expr_stmt|;
block|}
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|node
operator|->
name|childNodes
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
operator|&&
operator|(
operator|*
name|c
operator|)
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
condition|)
block|{
name|generateInnerNode
argument_list|(
operator|(
specifier|const
name|InnerNode
operator|*
operator|)
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
