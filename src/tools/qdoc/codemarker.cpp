begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qobjectdefs.h>
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|member|defaultLang
name|QString
name|CodeMarker
operator|::
name|defaultLang
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|markers
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
name|CodeMarker
operator|::
name|markers
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   When a code marker constructs itself, it puts itself into   the static list of code markers. All the code markers in   the static list get initialized in initialize(), which is   not called until after the qdoc configuration file has   been read.  */
end_comment
begin_constructor
DECL|function|CodeMarker
name|CodeMarker
operator|::
name|CodeMarker
parameter_list|()
block|{
name|markers
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   When a code marker destroys itself, it removes itself from   the static list of code markers.  */
end_comment
begin_destructor
DECL|function|~CodeMarker
name|CodeMarker
operator|::
name|~
name|CodeMarker
parameter_list|()
block|{
name|markers
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   A code market performs no initialization by default. Marker-specific   initialization is performed in subclasses.  */
end_comment
begin_function
DECL|function|initializeMarker
name|void
name|CodeMarker
operator|::
name|initializeMarker
parameter_list|(
specifier|const
name|Config
modifier|&
parameter_list|)
comment|// config
block|{ }
end_function
begin_comment
comment|/*!   Terminating a code marker is trivial.  */
end_comment
begin_function
DECL|function|terminateMarker
name|void
name|CodeMarker
operator|::
name|terminateMarker
parameter_list|()
block|{
comment|// nothing.
block|}
end_function
begin_comment
comment|/*!   All the code markers in the static list are initialized   here, after the qdoc configuration file has been loaded.  */
end_comment
begin_function
DECL|function|initialize
name|void
name|CodeMarker
operator|::
name|initialize
parameter_list|(
specifier|const
name|Config
modifier|&
name|config
parameter_list|)
block|{
name|defaultLang
operator|=
name|config
operator|.
name|getString
argument_list|(
name|QLatin1String
argument_list|(
name|CONFIG_LANGUAGE
argument_list|)
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|m
init|=
name|markers
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|markers
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|(
operator|*
name|m
operator|)
operator|->
name|initializeMarker
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   All the code markers in the static list are terminated here.  */
end_comment
begin_function
DECL|function|terminate
name|void
name|CodeMarker
operator|::
name|terminate
parameter_list|()
block|{
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|m
init|=
name|markers
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|markers
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|(
operator|*
name|m
operator|)
operator|->
name|terminateMarker
argument_list|()
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|markerForCode
name|CodeMarker
modifier|*
name|CodeMarker
operator|::
name|markerForCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|code
parameter_list|)
block|{
name|CodeMarker
modifier|*
name|defaultMarker
init|=
name|markerForLanguage
argument_list|(
name|defaultLang
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultMarker
operator|!=
literal|0
operator|&&
name|defaultMarker
operator|->
name|recognizeCode
argument_list|(
name|code
argument_list|)
condition|)
return|return
name|defaultMarker
return|;
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|m
init|=
name|markers
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|markers
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|recognizeCode
argument_list|(
name|code
argument_list|)
condition|)
return|return
operator|*
name|m
return|;
operator|++
name|m
expr_stmt|;
block|}
return|return
name|defaultMarker
return|;
block|}
end_function
begin_function
DECL|function|markerForFileName
name|CodeMarker
modifier|*
name|CodeMarker
operator|::
name|markerForFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|CodeMarker
modifier|*
name|defaultMarker
init|=
name|markerForLanguage
argument_list|(
name|defaultLang
argument_list|)
decl_stmt|;
name|int
name|dot
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|dot
operator|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|dot
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|ext
init|=
name|fileName
operator|.
name|mid
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultMarker
operator|!=
literal|0
operator|&&
name|defaultMarker
operator|->
name|recognizeExtension
argument_list|(
name|ext
argument_list|)
condition|)
return|return
name|defaultMarker
return|;
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|m
init|=
name|markers
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|markers
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|recognizeExtension
argument_list|(
name|ext
argument_list|)
condition|)
return|return
operator|*
name|m
return|;
operator|++
name|m
expr_stmt|;
block|}
operator|--
name|dot
expr_stmt|;
block|}
return|return
name|defaultMarker
return|;
block|}
end_function
begin_function
DECL|function|markerForLanguage
name|CodeMarker
modifier|*
name|CodeMarker
operator|::
name|markerForLanguage
parameter_list|(
specifier|const
name|QString
modifier|&
name|lang
parameter_list|)
block|{
name|QList
argument_list|<
name|CodeMarker
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|m
init|=
name|markers
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|markers
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|recognizeLanguage
argument_list|(
name|lang
argument_list|)
condition|)
return|return
operator|*
name|m
return|;
operator|++
name|m
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|nodeForString
specifier|const
name|Node
modifier|*
name|CodeMarker
operator|::
name|nodeForString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
specifier|const
name|Node
operator|*
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
condition|)
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|Node
operator|*
argument_list|>
argument_list|(
name|string
operator|.
name|toUInt
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|Node
operator|*
argument_list|>
argument_list|(
name|string
operator|.
name|toULongLong
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|stringForNode
name|QString
name|CodeMarker
operator|::
name|stringForNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
specifier|const
name|Node
operator|*
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
condition|)
block|{
return|return
name|QString
operator|::
name|number
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quintptr
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QString
operator|::
name|number
argument_list|(
cast|reinterpret_cast
argument_list|<
name|qulonglong
argument_list|>
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|samp
specifier|static
specifier|const
name|QString
name|samp
init|=
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|slt
specifier|static
specifier|const
name|QString
name|slt
init|=
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sgt
specifier|static
specifier|const
name|QString
name|sgt
init|=
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|squot
specifier|static
specifier|const
name|QString
name|squot
init|=
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|protect
name|QString
name|CodeMarker
operator|::
name|protect
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|int
name|n
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|QString
name|marked
decl_stmt|;
name|marked
operator|.
name|reserve
argument_list|(
name|n
operator|*
literal|2
operator|+
literal|30
argument_list|)
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|data
init|=
name|str
operator|.
name|constData
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'&'
case|:
name|marked
operator|+=
name|samp
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|marked
operator|+=
name|slt
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|marked
operator|+=
name|sgt
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|marked
operator|+=
name|squot
expr_stmt|;
break|break;
default|default :
name|marked
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|marked
return|;
block|}
end_function
begin_function
DECL|function|typified
name|QString
name|CodeMarker
operator|::
name|typified
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
name|QString
name|pendingWord
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|string
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|string
operator|.
name|size
argument_list|()
condition|)
name|ch
operator|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QChar
name|lower
init|=
name|ch
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lower
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|lower
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
operator|)
operator|||
name|ch
operator|.
name|digitValue
argument_list|()
operator|>=
literal|0
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|pendingWord
operator|+=
name|ch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pendingWord
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|isProbablyType
init|=
operator|(
name|pendingWord
operator|!=
name|QLatin1String
argument_list|(
literal|"const"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|isProbablyType
condition|)
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"<@type>"
argument_list|)
expr_stmt|;
name|result
operator|+=
name|pendingWord
expr_stmt|;
if|if
condition|(
name|isProbablyType
condition|)
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"</@type>"
argument_list|)
expr_stmt|;
block|}
name|pendingWord
operator|.
name|clear
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'&'
case|:
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|+=
name|ch
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|taggedNode
name|QString
name|CodeMarker
operator|::
name|taggedNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|tag
decl_stmt|;
name|QString
name|name
init|=
name|node
operator|->
name|name
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@namespace"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@class"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@enum"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@function"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Document
case|:
comment|/*           Remove the "QML:" prefix, if present.           There shouldn't be any of these "QML:"           prefixes in the documentation sources           after the switch to using QML module           qualifiers, but this code is kept to           be backward compatible.         */
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QML:"
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
case|case
name|Node
operator|::
name|QmlSignal
case|:
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@function"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
operator|+
name|tag
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
operator|+
name|protect
argument_list|(
name|name
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"</"
argument_list|)
operator|+
name|tag
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|taggedQmlNode
name|QString
name|CodeMarker
operator|::
name|taggedQmlNode
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|tag
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@property"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@signal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@signalhandler"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@method"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tag
operator|=
name|QLatin1String
argument_list|(
literal|"@unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
operator|+
name|tag
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
operator|+
name|protect
argument_list|(
name|node
operator|->
name|name
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"</"
argument_list|)
operator|+
name|tag
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|linkTag
name|QString
name|CodeMarker
operator|::
name|linkTag
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|body
parameter_list|)
block|{
return|return
name|QLatin1String
argument_list|(
literal|"<@link node=\""
argument_list|)
operator|+
name|stringForNode
argument_list|(
name|node
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\">"
argument_list|)
operator|+
name|body
operator|+
name|QLatin1String
argument_list|(
literal|"</@link>"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sortName
name|QString
name|CodeMarker
operator|::
name|sortName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|*
name|name
parameter_list|)
block|{
name|QString
name|nodeName
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|nodeName
operator|=
operator|*
name|name
expr_stmt|;
else|else
name|nodeName
operator|=
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
name|int
name|numDigits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nodeName
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|nodeName
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|digitValue
argument_list|()
operator|==
operator|-
literal|1
condition|)
break|break;
operator|++
name|numDigits
expr_stmt|;
block|}
comment|// we want 'qint8' to appear before 'qint16'
if|if
condition|(
name|numDigits
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
operator|-
name|numDigits
condition|;
operator|++
name|i
control|)
name|nodeName
operator|.
name|insert
argument_list|(
name|nodeName
operator|.
name|size
argument_list|()
operator|-
name|numDigits
operator|-
literal|1
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|QString
name|sortNo
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Ctor
condition|)
block|{
name|sortNo
operator|=
name|QLatin1String
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
condition|)
block|{
name|sortNo
operator|=
name|QLatin1String
argument_list|(
literal|"D"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nodeName
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"operator"
argument_list|)
argument_list|)
operator|&&
name|nodeName
operator|.
name|length
argument_list|()
operator|>
literal|8
operator|&&
operator|!
name|nodeName
index|[
literal|8
index|]
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
name|sortNo
operator|=
name|QLatin1String
argument_list|(
literal|"F"
argument_list|)
expr_stmt|;
else|else
name|sortNo
operator|=
name|QLatin1String
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
block|}
return|return
name|sortNo
operator|+
name|nodeName
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|,
literal|36
argument_list|)
return|;
block|}
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
return|return
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
operator|+
name|nodeName
return|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Property
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Variable
condition|)
return|return
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
operator|+
name|nodeName
return|;
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlMethod
operator|)
operator|||
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignal
operator|)
operator|||
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlSignalHandler
operator|)
condition|)
block|{
comment|//const FunctionNode* func = static_cast<const FunctionNode *>(node);
comment|//return QLatin1Char('E') + func->name();
return|return
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
operator|+
name|nodeName
return|;
block|}
return|return
name|QLatin1Char
argument_list|(
literal|'B'
argument_list|)
operator|+
name|nodeName
return|;
block|}
end_function
begin_function
DECL|function|insert
name|void
name|CodeMarker
operator|::
name|insert
parameter_list|(
name|FastSection
modifier|&
name|fastSection
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|SynopsisStyle
name|style
parameter_list|,
name|Status
name|status
parameter_list|)
block|{
name|bool
name|irrelevant
init|=
literal|false
decl_stmt|;
name|bool
name|inheritedMember
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|relates
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|!=
name|fastSection
operator|.
name|parent_
condition|)
block|{
comment|//&& !node->parent()->isAbstract()) {
if|if
condition|(
operator|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlClass
operator|)
operator|||
operator|!
name|node
operator|->
name|parent
argument_list|()
operator|->
name|isAbstract
argument_list|()
condition|)
block|{
comment|//if (node->type() != Node::QmlProperty) {
name|inheritedMember
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|node
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|irrelevant
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
name|node
decl_stmt|;
name|irrelevant
operator|=
operator|(
name|inheritedMember
operator|&&
operator|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Ctor
operator|||
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|Dtor
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Enum
operator|||
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
name|irrelevant
operator|=
operator|(
name|inheritedMember
operator|&&
name|style
operator|!=
name|Subpage
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|irrelevant
operator|&&
name|style
operator|==
name|Detailed
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Typedef
condition|)
block|{
specifier|const
name|TypedefNode
modifier|*
name|typedeffe
init|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedeffe
operator|->
name|associatedEnum
argument_list|()
condition|)
name|irrelevant
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|irrelevant
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|Compat
condition|)
block|{
name|irrelevant
operator|=
operator|(
name|node
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Compat
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|Obsolete
condition|)
block|{
name|irrelevant
operator|=
operator|(
name|node
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Obsolete
operator|)
expr_stmt|;
block|}
else|else
block|{
name|irrelevant
operator|=
operator|(
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Compat
operator|||
name|node
operator|->
name|status
argument_list|()
operator|==
name|Node
operator|::
name|Obsolete
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|irrelevant
condition|)
block|{
if|if
condition|(
operator|!
name|inheritedMember
operator|||
name|style
operator|==
name|Subpage
condition|)
block|{
name|QString
name|key
init|=
name|sortName
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|fastSection
operator|.
name|memberMap
operator|.
name|insertMulti
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
if|if
condition|(
name|fastSection
operator|.
name|inherited
operator|.
name|isEmpty
argument_list|()
operator|||
name|fastSection
operator|.
name|inherited
operator|.
name|last
argument_list|()
operator|.
name|first
operator|!=
name|node
operator|->
name|parent
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|InnerNode
modifier|*
argument_list|,
name|int
argument_list|>
name|p
argument_list|(
name|node
operator|->
name|parent
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fastSection
operator|.
name|inherited
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|fastSection
operator|.
name|inherited
operator|.
name|last
argument_list|()
operator|.
name|second
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Returns true if \a node represents a reimplemented member   function in the class of the FastSection \a fs. If it is   a reimplemented function, then it is inserted into the   reimplemented member map in \a fs. The test is performed   only if \a status is \e OK. True is returned if \a node   is inserted into the map. Otherwise, false is returned.  */
end_comment
begin_function
DECL|function|insertReimpFunc
name|bool
name|CodeMarker
operator|::
name|insertReimpFunc
parameter_list|(
name|FastSection
modifier|&
name|fs
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|Status
name|status
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|access
argument_list|()
operator|!=
name|Node
operator|::
name|Private
operator|)
operator|&&
operator|(
name|node
operator|->
name|relates
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fn
operator|->
name|reimplementedFrom
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|status
operator|==
name|Okay
operator|)
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|parent
argument_list|()
operator|==
name|fs
operator|.
name|parent_
condition|)
block|{
name|QString
name|key
init|=
name|sortName
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|reimpMemberMap
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|fs
operator|.
name|reimpMemberMap
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   If \a fs is not empty, convert it to a Section and append   the new Section to \a sectionList.  */
end_comment
begin_function
DECL|function|append
name|void
name|CodeMarker
operator|::
name|append
parameter_list|(
name|QList
argument_list|<
name|Section
argument_list|>
modifier|&
name|sectionList
parameter_list|,
specifier|const
name|FastSection
modifier|&
name|fs
parameter_list|,
name|bool
name|includeKeys
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|fs
operator|.
name|classMapList_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Section
name|section
argument_list|(
name|fs
operator|.
name|name
argument_list|,
name|fs
operator|.
name|divClass
argument_list|,
name|fs
operator|.
name|singularMember
argument_list|,
name|fs
operator|.
name|pluralMember
argument_list|)
decl_stmt|;
if|if
condition|(
name|includeKeys
condition|)
block|{
name|section
operator|.
name|keys
operator|=
name|fs
operator|.
name|memberMap
operator|.
name|keys
argument_list|()
expr_stmt|;
block|}
name|section
operator|.
name|members
operator|=
name|fs
operator|.
name|memberMap
operator|.
name|values
argument_list|()
expr_stmt|;
name|section
operator|.
name|reimpMembers
operator|=
name|fs
operator|.
name|reimpMemberMap
operator|.
name|values
argument_list|()
expr_stmt|;
name|section
operator|.
name|inherited
operator|=
name|fs
operator|.
name|inherited
expr_stmt|;
name|sectionList
operator|.
name|append
argument_list|(
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Section
name|section
argument_list|(
name|fs
operator|.
name|name
argument_list|,
name|fs
operator|.
name|divClass
argument_list|,
name|fs
operator|.
name|singularMember
argument_list|,
name|fs
operator|.
name|pluralMember
argument_list|)
decl_stmt|;
name|sectionList
operator|.
name|append
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|Section
modifier|*
name|s
init|=
operator|&
name|sectionList
index|[
name|sectionList
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fs
operator|.
name|classMapList_
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ClassMap
modifier|*
name|classMap
init|=
name|fs
operator|.
name|classMapList_
index|[
name|i
index|]
decl_stmt|;
name|ClassKeysNodes
modifier|*
name|ckn
init|=
operator|new
name|ClassKeysNodes
decl_stmt|;
name|ckn
operator|->
name|first
operator|=
name|classMap
operator|->
name|first
expr_stmt|;
name|ckn
operator|->
name|second
operator|.
name|second
operator|=
name|classMap
operator|->
name|second
operator|.
name|values
argument_list|()
expr_stmt|;
name|ckn
operator|->
name|second
operator|.
name|first
operator|=
name|classMap
operator|->
name|second
operator|.
name|keys
argument_list|()
expr_stmt|;
name|s
operator|->
name|classKeysNodesList_
operator|.
name|append
argument_list|(
name|ckn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   The destructor must delete each member of the   list of QML class lists, if it is not empty;  */
end_comment
begin_destructor
DECL|function|~Section
name|Section
operator|::
name|~
name|Section
parameter_list|()
block|{
if|if
condition|(
operator|!
name|classKeysNodesList_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classKeysNodesList_
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ClassKeysNodes
modifier|*
name|classKeysNodes
init|=
name|classKeysNodesList_
index|[
name|i
index|]
decl_stmt|;
name|classKeysNodesList_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|delete
name|classKeysNodes
expr_stmt|;
block|}
block|}
block|}
end_destructor
begin_comment
comment|/*!   The destructor must delete the QML class maps in the class   map list, if the class map list is not empty.  */
end_comment
begin_destructor
DECL|function|~FastSection
name|FastSection
operator|::
name|~
name|FastSection
parameter_list|()
block|{
if|if
condition|(
operator|!
name|classMapList_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classMapList_
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ClassMap
modifier|*
name|classMap
init|=
name|classMapList_
index|[
name|i
index|]
decl_stmt|;
name|classMapList_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|delete
name|classMap
expr_stmt|;
block|}
block|}
block|}
end_destructor
begin_function
DECL|function|encode
specifier|static
name|QString
name|encode
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
return|return
name|string
return|;
block|}
end_function
begin_function
DECL|function|macRefsForNode
name|QStringList
name|CodeMarker
operator|::
name|macRefsForNode
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QString
name|result
init|=
name|QLatin1String
argument_list|(
literal|"cpp/"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Class
case|:
block|{
specifier|const
name|ClassNode
modifier|*
name|classe
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
block|{
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"cl/"
argument_list|)
expr_stmt|;
block|}
name|result
operator|+=
name|macName
argument_list|(
name|classe
argument_list|)
expr_stmt|;
comment|// ### Maybe plainName?
block|}
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
block|{
name|QStringList
name|stringList
decl_stmt|;
name|stringList
operator|<<
name|encode
argument_list|(
name|result
operator|+
name|QLatin1String
argument_list|(
literal|"tag/"
argument_list|)
operator|+
name|macName
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|enumName
decl|,
name|node
operator|->
name|doc
argument_list|()
operator|.
name|enumItemNames
argument_list|()
control|)
block|{
comment|// ### Write a plainEnumValue() and use it here
name|stringList
operator|<<
name|encode
argument_list|(
name|result
operator|+
name|QLatin1String
argument_list|(
literal|"econst/"
argument_list|)
operator|+
name|macName
argument_list|(
name|node
operator|->
name|parent
argument_list|()
argument_list|,
name|enumName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|stringList
return|;
block|}
case|case
name|Node
operator|::
name|Typedef
case|:
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"tdef/"
argument_list|)
operator|+
name|macName
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Function
case|:
block|{
name|bool
name|isMacro
init|=
literal|false
decl_stmt|;
name|Q_UNUSED
argument_list|(
argument|isMacro
argument_list|)
specifier|const
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// overloads are too clever for the Xcode documentation browser
if|if
condition|(
name|func
operator|->
name|isOverload
argument_list|()
condition|)
return|return
name|QStringList
argument_list|()
return|;
if|if
condition|(
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithParams
operator|||
name|func
operator|->
name|metaness
argument_list|()
operator|==
name|FunctionNode
operator|::
name|MacroWithoutParams
condition|)
block|{
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"macro/"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|->
name|isStatic
argument_list|()
condition|)
block|{
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"clm/"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|func
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"instm/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"func/"
argument_list|)
expr_stmt|;
block|}
name|result
operator|+=
name|macName
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"()"
argument_list|)
argument_list|)
condition|)
name|result
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"data/"
argument_list|)
operator|+
name|macName
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
block|{
name|NodeList
name|list
init|=
cast|static_cast
argument_list|<
specifier|const
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|functions
argument_list|()
decl_stmt|;
name|QStringList
name|stringList
decl_stmt|;
foreach|foreach
control|(
name|Node
modifier|*
name|node
decl|,
name|list
control|)
block|{
name|stringList
operator|+=
name|macRefsForNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|stringList
return|;
block|}
case|case
name|Node
operator|::
name|Namespace
case|:
case|case
name|Node
operator|::
name|Document
case|:
default|default:
return|return
name|QStringList
argument_list|()
return|;
block|}
return|return
name|QStringList
argument_list|(
name|encode
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|macName
name|QString
name|CodeMarker
operator|::
name|macName
parameter_list|(
specifier|const
name|Node
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QString
name|myName
init|=
name|name
decl_stmt|;
if|if
condition|(
name|myName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|myName
operator|=
name|node
operator|->
name|name
argument_list|()
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|protect
argument_list|(
name|myName
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|node
operator|->
name|plainFullName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|protect
argument_list|(
name|myName
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns an empty list of documentation sections.  */
end_comment
begin_function
DECL|function|qmlSections
name|QList
argument_list|<
name|Section
argument_list|>
name|CodeMarker
operator|::
name|qmlSections
parameter_list|(
specifier|const
name|QmlClassNode
modifier|*
parameter_list|,
name|SynopsisStyle
parameter_list|)
block|{
return|return
name|QList
argument_list|<
name|Section
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
