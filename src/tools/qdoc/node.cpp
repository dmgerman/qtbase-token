begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"cppcodeparser.h"
end_include
begin_include
include|#
directive|include
file|<quuid.h>
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"tokenizer.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|member|propertyGroupCount_
name|int
name|Node
operator|::
name|propertyGroupCount_
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|operators_
name|QStringMap
name|Node
operator|::
name|operators_
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|goals_
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
operator|::
name|NodeType
argument_list|>
name|Node
operator|::
name|goals_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Initialize the map of search goals. This is called once   by QDocDatabase::initializeDB(). The map key is a string   representing a value in the enum Node::NodeType. The map value   is the enum value.    There should be an entry in the map for each value in the   NodeType enum.  */
end_comment
begin_function
DECL|function|initialize
name|void
name|Node
operator|::
name|initialize
parameter_list|()
block|{
name|goals_
operator|.
name|insert
argument_list|(
literal|"class"
argument_list|,
name|Node
operator|::
name|Class
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmltype"
argument_list|,
name|Node
operator|::
name|QmlType
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"page"
argument_list|,
name|Node
operator|::
name|Document
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"function"
argument_list|,
name|Node
operator|::
name|Function
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"property"
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"variable"
argument_list|,
name|Node
operator|::
name|Variable
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"group"
argument_list|,
name|Node
operator|::
name|Group
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"module"
argument_list|,
name|Node
operator|::
name|Module
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlmodule"
argument_list|,
name|Node
operator|::
name|QmlModule
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmppropertygroup"
argument_list|,
name|Node
operator|::
name|QmlPropertyGroup
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlproperty"
argument_list|,
name|Node
operator|::
name|QmlProperty
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlsignal"
argument_list|,
name|Node
operator|::
name|QmlSignal
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlsignalhandler"
argument_list|,
name|Node
operator|::
name|QmlSignalHandler
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlmethod"
argument_list|,
name|Node
operator|::
name|QmlMethod
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"qmlbasictype"
argument_list|,
name|Node
operator|::
name|QmlBasicType
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"enum"
argument_list|,
name|Node
operator|::
name|Enum
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"typedef"
argument_list|,
name|Node
operator|::
name|Typedef
argument_list|)
expr_stmt|;
name|goals_
operator|.
name|insert
argument_list|(
literal|"namespace"
argument_list|,
name|Node
operator|::
name|Namespace
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Increment the number of property groups seen in the current   file, and return the new value.  */
end_comment
begin_function
DECL|function|incPropertyGroupCount
name|int
name|Node
operator|::
name|incPropertyGroupCount
parameter_list|()
block|{
return|return
operator|++
name|propertyGroupCount_
return|;
block|}
end_function
begin_comment
comment|/*!   Reset the number of property groups seen in the current file   to 0, because we are starting a new file.  */
end_comment
begin_function
DECL|function|clearPropertyGroupCount
name|void
name|Node
operator|::
name|clearPropertyGroupCount
parameter_list|()
block|{
name|propertyGroupCount_
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class Node   \brief The Node class is a node in the Tree.    A Node represents a class or function or something else   from the source code..  */
end_comment
begin_comment
comment|/*!   When this Node is destroyed, if it has a parent Node, it   removes itself from the parent node's child list.  */
end_comment
begin_destructor
DECL|function|~Node
name|Node
operator|::
name|~
name|Node
parameter_list|()
block|{
if|if
condition|(
name|parent_
condition|)
name|parent_
operator|->
name|removeChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|relatesTo_
condition|)
name|removeRelates
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Removes this node from the aggregate's list of related     nodes, or if this node has created a dummy "relates"     aggregate, deletes it. */
end_comment
begin_function
DECL|function|removeRelates
name|void
name|Node
operator|::
name|removeRelates
parameter_list|()
block|{
if|if
condition|(
operator|!
name|relatesTo_
condition|)
return|return;
if|if
condition|(
name|relatesTo_
operator|->
name|isDocumentNode
argument_list|()
operator|&&
operator|!
name|relatesTo_
operator|->
name|parent
argument_list|()
condition|)
operator|delete
name|relatesTo_
expr_stmt|;
else|else
name|relatesTo_
operator|->
name|removeRelated
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns this node's name member. Appends "()" to the returned   name, if this node is a function node.  */
end_comment
begin_function
DECL|function|plainName
name|QString
name|Node
operator|::
name|plainName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
return|return
name|name_
operator|+
name|QLatin1String
argument_list|(
literal|"()"
argument_list|)
return|;
return|return
name|name_
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs and returns the node's fully qualified name by   recursively ascending the parent links and prepending each   parent name + "::". Breaks out when the parent pointer is   \a relative. Almost all calls to this function pass 0 for   \a relative.  */
end_comment
begin_function
DECL|function|plainFullName
name|QString
name|Node
operator|::
name|plainFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"global"
argument_list|)
return|;
name|QString
name|fullName
decl_stmt|;
specifier|const
name|Node
modifier|*
name|node
init|=
name|this
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|fullName
operator|.
name|prepend
argument_list|(
name|node
operator|->
name|plainName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|==
name|relative
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|fullName
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
name|fullName
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs and returns this node's full name.  */
end_comment
begin_function
DECL|function|fullName
name|QString
name|Node
operator|::
name|fullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|isDocumentNode
argument_list|()
operator|||
name|isGroup
argument_list|()
operator|)
operator|&&
operator|!
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|title
argument_list|()
return|;
return|return
name|plainFullName
argument_list|(
name|relative
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Try to match this node's type and subtype with one of the   pairs in \a types. If a match is found, return true. If no   match is found, return false.    \a types is a list of type/subtype pairs, where the first   value in the pair is a Node::NodeType, and the second value is   a Node::DocSubtype. The second value is used in the match if   this node's type is Node::Document.  */
end_comment
begin_function
DECL|function|match
name|bool
name|Node
operator|::
name|match
parameter_list|(
specifier|const
name|NodeTypeList
modifier|&
name|types
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|type
argument_list|()
operator|==
name|types
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
condition|)
block|{
if|if
condition|(
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
if|if
condition|(
name|docSubtype
argument_list|()
operator|==
name|types
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
condition|)
return|return
literal|true
return|;
block|}
else|else
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Sets this Node's Doc to \a doc. If \a replace is false and   this Node already has a Doc, a warning is reported that the   Doc is being overridden, and it reports where the previous   Doc was found. If \a replace is true, the Doc is replaced   silently.  */
end_comment
begin_function
DECL|function|setDoc
name|void
name|Node
operator|::
name|setDoc
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
name|bool
name|replace
parameter_list|)
block|{
if|if
condition|(
operator|!
name|doc_
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|replace
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Overrides a previous doc"
argument_list|)
argument_list|)
expr_stmt|;
name|doc_
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"(The previous doc is here)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|doc_
operator|=
name|doc
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Construct a node with the given \a type and having the   given \a parent and \a name. The new node is added to the   parent's child list.  */
end_comment
begin_constructor
DECL|function|Node
name|Node
operator|::
name|Node
parameter_list|(
name|NodeType
name|type
parameter_list|,
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|nodeType_
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
member_init_list|,
name|access_
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|Public
argument_list|)
member_init_list|,
name|safeness_
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|UnspecifiedSafeness
argument_list|)
member_init_list|,
name|pageType_
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|NoPageType
argument_list|)
member_init_list|,
name|status_
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|Active
argument_list|)
member_init_list|,
name|indexNodeFlag_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|parent_
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|relatesTo_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|name_
argument_list|(
name|name
argument_list|)
block|{
if|if
condition|(
name|parent_
condition|)
name|parent_
operator|->
name|addChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|outSubDir_
operator|=
name|Generator
operator|::
name|outputSubdir
argument_list|()
expr_stmt|;
if|if
condition|(
name|operators_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|operators_
operator|.
name|insert
argument_list|(
literal|"++"
argument_list|,
literal|"inc"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"--"
argument_list|,
literal|"dec"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"=="
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"!="
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<<"
argument_list|,
literal|"lt-lt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">>"
argument_list|,
literal|"gt-gt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"+="
argument_list|,
literal|"plus-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"-="
argument_list|,
literal|"minus-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"*="
argument_list|,
literal|"mult-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"/="
argument_list|,
literal|"div-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"%="
argument_list|,
literal|"mod-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&="
argument_list|,
literal|"bitwise-and-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"|="
argument_list|,
literal|"bitwise-or-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"^="
argument_list|,
literal|"bitwise-xor-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<<="
argument_list|,
literal|"bitwise-left-shift-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">>="
argument_list|,
literal|"bitwise-right-shift-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"||"
argument_list|,
literal|"logical-or"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&&"
argument_list|,
literal|"logical-and"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"()"
argument_list|,
literal|"call"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"[]"
argument_list|,
literal|"subscript"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"->"
argument_list|,
literal|"pointer"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"->*"
argument_list|,
literal|"pointer-star"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"+"
argument_list|,
literal|"plus"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"-"
argument_list|,
literal|"minus"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"*"
argument_list|,
literal|"mult"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"/"
argument_list|,
literal|"div"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"%"
argument_list|,
literal|"mod"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"|"
argument_list|,
literal|"bitwise-or"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&"
argument_list|,
literal|"bitwise-and"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"^"
argument_list|,
literal|"bitwise-xor"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"!"
argument_list|,
literal|"not"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"~"
argument_list|,
literal|"bitwise-not"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<="
argument_list|,
literal|"lt-eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">="
argument_list|,
literal|"gt-eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<"
argument_list|,
literal|"lt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">"
argument_list|,
literal|"gt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"="
argument_list|,
literal|"assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|","
argument_list|,
literal|"comma"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"delete[]"
argument_list|,
literal|"delete-array"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"delete"
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"new[]"
argument_list|,
literal|"new-array"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"new"
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*! \fn QString Node::url() const   Returns the node's URL.  */
end_comment
begin_comment
comment|/*! \fn void Node::setUrl(const QString&url)   Sets the node's URL to \a url  */
end_comment
begin_comment
comment|/*!   Returns this node's page type as a string, for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|pageTypeString
name|QString
name|Node
operator|::
name|pageTypeString
parameter_list|()
specifier|const
block|{
return|return
name|pageTypeString
argument_list|(
operator|(
name|PageType
operator|)
name|pageType_
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the page type \a t as a string, for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|pageTypeString
name|QString
name|Node
operator|::
name|pageTypeString
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|PageType
operator|)
name|t
condition|)
block|{
case|case
name|Node
operator|::
name|ApiPage
case|:
return|return
literal|"api"
return|;
case|case
name|Node
operator|::
name|ArticlePage
case|:
return|return
literal|"article"
return|;
case|case
name|Node
operator|::
name|ExamplePage
case|:
return|return
literal|"example"
return|;
case|case
name|Node
operator|::
name|HowToPage
case|:
return|return
literal|"howto"
return|;
case|case
name|Node
operator|::
name|OverviewPage
case|:
return|return
literal|"overview"
return|;
case|case
name|Node
operator|::
name|TutorialPage
case|:
return|return
literal|"tutorial"
return|;
case|case
name|Node
operator|::
name|FAQPage
case|:
return|return
literal|"faq"
return|;
case|case
name|Node
operator|::
name|DitaMapPage
case|:
return|return
literal|"ditamap"
return|;
default|default:
return|return
literal|"article"
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns this node's type as a string for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|nodeTypeString
name|QString
name|Node
operator|::
name|nodeTypeString
parameter_list|()
specifier|const
block|{
return|return
name|nodeTypeString
argument_list|(
name|type
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the node type \a t as a string for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|nodeTypeString
name|QString
name|Node
operator|::
name|nodeTypeString
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|NodeType
operator|)
name|t
condition|)
block|{
case|case
name|Namespace
case|:
return|return
literal|"namespace"
return|;
case|case
name|Class
case|:
return|return
literal|"class"
return|;
case|case
name|Document
case|:
return|return
literal|"document"
return|;
case|case
name|Enum
case|:
return|return
literal|"enum"
return|;
case|case
name|Typedef
case|:
return|return
literal|"typedef"
return|;
case|case
name|Function
case|:
return|return
literal|"function"
return|;
case|case
name|Property
case|:
return|return
literal|"property"
return|;
case|case
name|Variable
case|:
return|return
literal|"variable"
return|;
case|case
name|Group
case|:
return|return
literal|"group"
return|;
case|case
name|Module
case|:
return|return
literal|"module"
return|;
case|case
name|QmlType
case|:
return|return
literal|"QML type"
return|;
case|case
name|QmlBasicType
case|:
return|return
literal|"QML basic type"
return|;
case|case
name|QmlModule
case|:
return|return
literal|"QML module"
return|;
case|case
name|QmlProperty
case|:
return|return
literal|"QML property"
return|;
case|case
name|QmlPropertyGroup
case|:
return|return
literal|"QML property group"
return|;
case|case
name|QmlSignal
case|:
return|return
literal|"QML signal"
return|;
case|case
name|QmlSignalHandler
case|:
return|return
literal|"QML signal handler"
return|;
case|case
name|QmlMethod
case|:
return|return
literal|"QML method"
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns this node's subtype as a string for use as an   attribute value in XML or HTML. This is only useful   in the case where the node type is Document.  */
end_comment
begin_function
DECL|function|nodeSubtypeString
name|QString
name|Node
operator|::
name|nodeSubtypeString
parameter_list|()
specifier|const
block|{
return|return
name|nodeSubtypeString
argument_list|(
name|docSubtype
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the node subtype \a t as a string for use as an   attribute value in XML or HTML. This is only useful   in the case where the node type is Document.  */
end_comment
begin_function
DECL|function|nodeSubtypeString
name|QString
name|Node
operator|::
name|nodeSubtypeString
parameter_list|(
name|unsigned
name|char
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|DocSubtype
operator|)
name|t
condition|)
block|{
case|case
name|Example
case|:
return|return
literal|"example"
return|;
case|case
name|HeaderFile
case|:
return|return
literal|"header file"
return|;
case|case
name|File
case|:
return|return
literal|"file"
return|;
case|case
name|Image
case|:
return|return
literal|"image"
return|;
case|case
name|Page
case|:
return|return
literal|"page"
return|;
case|case
name|ExternalPage
case|:
return|return
literal|"external page"
return|;
case|case
name|DitaMap
case|:
return|return
literal|"ditamap"
return|;
case|case
name|NoSubtype
case|:
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Set the page type according to the string \a t.  */
end_comment
begin_function
DECL|function|setPageType
name|void
name|Node
operator|::
name|setPageType
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|t
operator|==
literal|"API"
operator|)
operator|||
operator|(
name|t
operator|==
literal|"api"
operator|)
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ApiPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"howto"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|HowToPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"overview"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|OverviewPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"tutorial"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|TutorialPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"faq"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|FAQPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"article"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ArticlePage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"example"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ExamplePage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"ditamap"
condition|)
name|pageType_
operator|=
operator|(
name|unsigned
name|char
operator|)
name|DitaMapPage
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Converts the boolean value \a b to an enum representation   of the boolean type, which includes an enum value for the   \e {default value} of the item, i.e. true, false, or default.  */
end_comment
begin_function
DECL|function|toFlagValue
name|Node
operator|::
name|FlagValue
name|Node
operator|::
name|toFlagValue
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
return|return
name|b
condition|?
name|FlagValueTrue
else|:
name|FlagValueFalse
return|;
block|}
end_function
begin_comment
comment|/*!   Converts the enum \a fv back to a boolean value.   If \a fv is neither the true enum value nor the   false enum value, the boolean value returned is   \a defaultValue.    Note that runtimeDesignabilityFunction() should be called   first. If that function returns the name of a function, it   means the function must be called at runtime to determine   whether the property is Designable.  */
end_comment
begin_function
DECL|function|fromFlagValue
name|bool
name|Node
operator|::
name|fromFlagValue
parameter_list|(
name|FlagValue
name|fv
parameter_list|,
name|bool
name|defaultValue
parameter_list|)
block|{
switch|switch
condition|(
name|fv
condition|)
block|{
case|case
name|FlagValueTrue
case|:
return|return
literal|true
return|;
case|case
name|FlagValueFalse
case|:
return|return
literal|false
return|;
default|default:
return|return
name|defaultValue
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Sets the pointer to the node that this node relates to.  */
end_comment
begin_function
DECL|function|setRelates
name|void
name|Node
operator|::
name|setRelates
parameter_list|(
name|Aggregate
modifier|*
name|pseudoParent
parameter_list|)
block|{
if|if
condition|(
name|pseudoParent
operator|==
name|parent
argument_list|()
condition|)
return|return;
name|removeRelates
argument_list|()
expr_stmt|;
name|relatesTo_
operator|=
name|pseudoParent
expr_stmt|;
name|pseudoParent
operator|->
name|addRelated
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the (unresolved) entity \a name that this node relates to.  */
end_comment
begin_function
DECL|function|setRelates
name|void
name|Node
operator|::
name|setRelates
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|removeRelates
argument_list|()
expr_stmt|;
comment|// Create a dummy aggregate for writing the name into the index
name|relatesTo_
operator|=
operator|new
name|DocumentNode
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|NoSubtype
argument_list|,
name|Node
operator|::
name|NoPageType
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function creates a pair that describes a link.   The pair is composed from \a link and \a desc. The   \a linkType is the map index the pair is filed under.  */
end_comment
begin_function
DECL|function|setLink
name|void
name|Node
operator|::
name|setLink
parameter_list|(
name|LinkType
name|linkType
parameter_list|,
specifier|const
name|QString
modifier|&
name|link
parameter_list|,
specifier|const
name|QString
modifier|&
name|desc
parameter_list|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|linkPair
decl_stmt|;
name|linkPair
operator|.
name|first
operator|=
name|link
expr_stmt|;
name|linkPair
operator|.
name|second
operator|=
name|desc
expr_stmt|;
name|linkMap_
index|[
name|linkType
index|]
operator|=
name|linkPair
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the information about the project and version a node was introduced     in. The string is simplified, removing excess whitespace before being     stored. */
end_comment
begin_function
DECL|function|setSince
name|void
name|Node
operator|::
name|setSince
parameter_list|(
specifier|const
name|QString
modifier|&
name|since
parameter_list|)
block|{
name|since_
operator|=
name|since
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns a string representing the access specifier.  */
end_comment
begin_function
DECL|function|accessString
name|QString
name|Node
operator|::
name|accessString
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
operator|(
name|Access
operator|)
name|access_
condition|)
block|{
case|case
name|Protected
case|:
return|return
literal|"protected"
return|;
case|case
name|Private
case|:
return|return
literal|"private"
return|;
case|case
name|Public
case|:
default|default:
break|break;
block|}
return|return
literal|"public"
return|;
block|}
end_function
begin_comment
comment|/*!   Extract a class name from the type \a string and return it.  */
end_comment
begin_function
DECL|function|extractClassName
name|QString
name|Node
operator|::
name|extractClassName
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|string
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|string
operator|.
name|size
argument_list|()
condition|)
name|ch
operator|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QChar
name|lower
init|=
name|ch
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lower
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|lower
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
operator|)
operator|||
name|ch
operator|.
name|digitValue
argument_list|()
operator|>=
literal|0
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|result
operator|+=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|QLatin1String
argument_list|(
literal|"const"
argument_list|)
condition|)
return|return
name|result
return|;
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a string representing the access specifier.  */
end_comment
begin_function
DECL|function|accessString
name|QString
name|RelatedClass
operator|::
name|accessString
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|access_
condition|)
block|{
case|case
name|Node
operator|::
name|Protected
case|:
return|return
literal|"protected"
return|;
case|case
name|Node
operator|::
name|Private
case|:
return|return
literal|"private"
return|;
case|case
name|Node
operator|::
name|Public
case|:
default|default:
break|break;
block|}
return|return
literal|"public"
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the inheritance status.  */
end_comment
begin_function
DECL|function|inheritedStatus
name|Node
operator|::
name|Status
name|Node
operator|::
name|inheritedStatus
parameter_list|()
specifier|const
block|{
name|Status
name|parentStatus
init|=
name|Active
decl_stmt|;
if|if
condition|(
name|parent_
condition|)
name|parentStatus
operator|=
name|parent_
operator|->
name|inheritedStatus
argument_list|()
expr_stmt|;
return|return
operator|(
name|Status
operator|)
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|status_
argument_list|,
operator|(
name|int
operator|)
name|parentStatus
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the thread safeness value for whatever this node   represents. But if this node has a parent and the thread   safeness value of the parent is the same as the thread   safeness value of this node, what is returned is the   value \c{UnspecifiedSafeness}. Why?  */
end_comment
begin_function
DECL|function|threadSafeness
name|Node
operator|::
name|ThreadSafeness
name|Node
operator|::
name|threadSafeness
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|parent_
operator|&&
operator|(
name|ThreadSafeness
operator|)
name|safeness_
operator|==
name|parent_
operator|->
name|inheritedThreadSafeness
argument_list|()
condition|)
return|return
name|UnspecifiedSafeness
return|;
return|return
operator|(
name|ThreadSafeness
operator|)
name|safeness_
return|;
block|}
end_function
begin_comment
comment|/*!   If this node has a parent, the parent's thread safeness   value is returned. Otherwise, this node's thread safeness   value is returned. Why?  */
end_comment
begin_function
DECL|function|inheritedThreadSafeness
name|Node
operator|::
name|ThreadSafeness
name|Node
operator|::
name|inheritedThreadSafeness
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|parent_
operator|&&
operator|(
name|ThreadSafeness
operator|)
name|safeness_
operator|==
name|UnspecifiedSafeness
condition|)
return|return
name|parent_
operator|->
name|inheritedThreadSafeness
argument_list|()
return|;
return|return
operator|(
name|ThreadSafeness
operator|)
name|safeness_
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*!   Returns the sanitized file name without the path.   If the file is an html file, the html suffix   is removed. Why?  */
end_comment
begin_comment
unit|QString Node::fileBase() const {     QString base = name();     if (base.endsWith(".html"))         base.chop(5);     base.replace(QRegExp("[^A-Za-z0-9]+"), " ");     base = base.trimmed();     base.replace(QLatin1Char(' '), QLatin1Char('-'));     return base.toLower(); }
comment|/*!   Returns this node's Universally Unique IDentifier as a   QString. Creates the UUID first, if it has not been created.  */
end_comment
begin_endif
unit|QString Node::guid() const {     if (uuid_.isEmpty())         uuid_ = idForNode();     return uuid_; }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   If this node is a QML or JS type node, return a pointer to   it. If it is a child of a QML or JS type node, return the   pointer to its parent QMLor JS type node. Otherwise return   0;  */
end_comment
begin_function
DECL|function|qmlTypeNode
name|QmlTypeNode
modifier|*
name|Node
operator|::
name|qmlTypeNode
parameter_list|()
block|{
if|if
condition|(
name|isQmlNode
argument_list|()
operator|||
name|isJsNode
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|this
decl_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|&&
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   If this node is a QML node, find its QML class node,   and return a pointer to the C++ class node from the   QML class node. That pointer will be null if the QML   class node is a component. It will be non-null if   the QML class node is a QML element.  */
end_comment
begin_function
DECL|function|declarativeCppNode
name|ClassNode
modifier|*
name|Node
operator|::
name|declarativeCppNode
parameter_list|()
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|qmlTypeNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
operator|->
name|classNode
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the node's status is Internal, or if its   parent is a class with internal status.  */
end_comment
begin_function
DECL|function|isInternal
name|bool
name|Node
operator|::
name|isInternal
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|parent
argument_list|()
operator|&&
name|parent
argument_list|()
operator|->
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|relates
argument_list|()
operator|&&
name|relates
argument_list|()
operator|->
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pointer to the Tree this node is in.  */
end_comment
begin_function
DECL|function|tree
name|Tree
modifier|*
name|Node
operator|::
name|tree
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|parent
argument_list|()
condition|?
name|parent
argument_list|()
operator|->
name|tree
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pointer to the root of the Tree this node is in.  */
end_comment
begin_function
DECL|function|root
specifier|const
name|Node
modifier|*
name|Node
operator|::
name|root
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|parent
argument_list|()
condition|?
name|parent
argument_list|()
operator|->
name|root
argument_list|()
else|:
name|this
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the node's declaration location, its definition   location, or both, depending on the suffix of the file   name from the file path in location \a t.  */
end_comment
begin_function
DECL|function|setLocation
name|void
name|Node
operator|::
name|setLocation
parameter_list|(
specifier|const
name|Location
modifier|&
name|t
parameter_list|)
block|{
name|QString
name|suffix
init|=
name|t
operator|.
name|fileSuffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|suffix
operator|==
literal|"h"
condition|)
name|declLocation_
operator|=
name|t
expr_stmt|;
elseif|else
if|if
condition|(
name|suffix
operator|==
literal|"cpp"
condition|)
name|defLocation_
operator|=
name|t
expr_stmt|;
else|else
block|{
name|declLocation_
operator|=
name|t
expr_stmt|;
name|defLocation_
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \class Aggregate  */
end_comment
begin_comment
comment|/*!   The inner node destructor deletes the children and removes   this node from its related nodes.  */
end_comment
begin_destructor
DECL|function|~Aggregate
name|Aggregate
operator|::
name|~
name|Aggregate
parameter_list|()
block|{
name|deleteChildren
argument_list|()
expr_stmt|;
name|removeFromRelated
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   If \a genus is \c{Node::DontCare}, find the first node in   this node's child list that has the given \a name. If this   node is a QML type, be sure to also look in the children   of its property group nodes. Return the matching node or 0.    If \a genus is either \c{Node::CPP} or \c {Node::QML}, then   find all this node's children that have the given \a name,   and return the one that satisfies the \a genus requirement.  */
end_comment
begin_function
DECL|function|findChildNode
name|Node
modifier|*
name|Aggregate
operator|::
name|findChildNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Node
operator|::
name|Genus
name|genus
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|genus
operator|==
name|Node
operator|::
name|DontCare
condition|)
block|{
name|Node
modifier|*
name|node
init|=
name|childMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|node
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
comment|// mws asks: Why not property group?
return|return
name|node
return|;
if|if
condition|(
name|isQmlType
argument_list|()
operator|||
name|isJsType
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
operator|||
name|isJsPropertyGroup
argument_list|()
condition|)
block|{
name|node
operator|=
cast|static_cast
argument_list|<
name|Aggregate
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
operator|->
name|findChildNode
argument_list|(
name|name
argument_list|,
name|genus
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|NodeList
name|nodes
init|=
name|childMap_
operator|.
name|values
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|node
init|=
name|nodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|genus
operator|==
name|node
operator|->
name|genus
argument_list|()
condition|)
return|return
name|node
return|;
block|}
block|}
block|}
return|return
name|primaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find all the child nodes of this node that are named   \a name and return them in \a nodes.  */
end_comment
begin_function
DECL|function|findChildren
name|void
name|Aggregate
operator|::
name|findChildren
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|NodeList
modifier|&
name|nodes
parameter_list|)
specifier|const
block|{
name|nodes
operator|=
name|childMap_
operator|.
name|values
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Node
modifier|*
name|n
init|=
name|primaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|nodes
operator|.
name|append
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|NodeList
name|t
init|=
name|secondaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
name|nodes
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
operator|(
name|isQmlNode
argument_list|()
operator|||
name|isJsNode
argument_list|()
operator|)
condition|)
return|return;
name|int
name|i
init|=
name|name
operator|.
name|indexOf
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|QString
name|qmlPropGroup
init|=
name|name
operator|.
name|left
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NodeList
name|t
init|=
name|childMap_
operator|.
name|values
argument_list|(
name|qmlPropGroup
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
foreach|foreach
control|(
name|Node
modifier|*
name|n
decl|,
name|t
control|)
block|{
if|if
condition|(
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
operator|||
name|n
operator|->
name|isJsPropertyGroup
argument_list|()
condition|)
block|{
name|n
operator|->
name|findChildren
argument_list|(
name|name
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This function is like findChildNode(), but if a node   with the specified \a name is found but it is not of the   specified \a type, 0 is returned.  */
end_comment
begin_function
DECL|function|findChildNode
name|Node
modifier|*
name|Aggregate
operator|::
name|findChildNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|NodeType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|Function
condition|)
return|return
name|primaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
else|else
block|{
name|NodeList
name|nodes
init|=
name|childMap_
operator|.
name|values
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|node
init|=
name|nodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
return|return
name|node
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find a function node that is a child of this nose, such   that the function node has the specified \a name.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Aggregate
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|params
parameter_list|)
specifier|const
block|{
name|FunctionNode
modifier|*
name|pfn
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|primaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|FunctionNode
modifier|*
name|fn
init|=
name|pfn
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|Parameter
argument_list|>
modifier|*
name|funcParams
init|=
operator|&
operator|(
name|fn
operator|->
name|parameters
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|isEmpty
argument_list|()
operator|&&
name|funcParams
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
name|fn
return|;
name|bool
name|isQPrivateSignal
init|=
literal|false
decl_stmt|;
comment|// Not used in the search
name|QVector
argument_list|<
name|Parameter
argument_list|>
name|testParams
decl_stmt|;
if|if
condition|(
operator|!
name|params
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|CppCodeParser
modifier|*
name|cppParser
init|=
name|CppCodeParser
operator|::
name|cppParser
argument_list|()
decl_stmt|;
name|cppParser
operator|->
name|parseParameters
argument_list|(
name|params
argument_list|,
name|testParams
argument_list|,
name|isQPrivateSignal
argument_list|)
expr_stmt|;
block|}
name|NodeList
name|funcs
init|=
name|secondaryFunctionMap_
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|testParams
operator|.
name|size
argument_list|()
operator|==
name|funcParams
operator|->
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|testParams
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|fn
return|;
name|bool
name|different
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|testParams
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|testParams
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|dataType
argument_list|()
operator|!=
name|funcParams
operator|->
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|dataType
argument_list|()
condition|)
block|{
name|different
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|different
condition|)
return|return
name|fn
return|;
block|}
if|if
condition|(
operator|++
name|i
operator|<
name|funcs
operator|.
name|size
argument_list|()
condition|)
block|{
name|fn
operator|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|funcs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|funcParams
operator|=
operator|&
operator|(
name|fn
operator|->
name|parameters
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
name|fn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fn
operator|&&
operator|!
name|testParams
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
comment|/*       Most \l commands that link to functions don't include       the parameter declarations in the function signature,       so if the \l is meant to go to a function that does       have parameters, the algorithm above won't find it.       Therefore we must return the pointer to the function       in the primary function map in the cases where the       parameters should have been specified in the \l command.     */
return|return
operator|(
name|fn
condition|?
name|fn
else|:
name|pfn
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the function node that is a child of this node, such   that the function has the same name and signature as the   \a clone node.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|Aggregate
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
specifier|const
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|c
init|=
name|primaryFunctionMap_
operator|.
name|constFind
argument_list|(
name|clone
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|primaryFunctionMap_
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|isSameSignature
argument_list|(
name|clone
argument_list|,
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
return|;
block|}
elseif|else
if|if
condition|(
name|secondaryFunctionMap_
operator|.
name|contains
argument_list|(
name|clone
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap_
index|[
name|clone
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|secs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|secs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|isSameSignature
argument_list|(
name|clone
argument_list|,
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
return|;
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of keys from the primary function map.  */
end_comment
begin_function
DECL|function|primaryKeys
name|QStringList
name|Aggregate
operator|::
name|primaryKeys
parameter_list|()
block|{
name|QStringList
name|t
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|iterator
name|i
init|=
name|primaryFunctionMap_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|primaryFunctionMap_
operator|.
name|end
argument_list|()
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of keys from the secondary function map.  */
end_comment
begin_function
DECL|function|secondaryKeys
name|QStringList
name|Aggregate
operator|::
name|secondaryKeys
parameter_list|()
block|{
name|QStringList
name|t
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|NodeList
argument_list|>
operator|::
name|iterator
name|i
init|=
name|secondaryFunctionMap_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|secondaryFunctionMap_
operator|.
name|end
argument_list|()
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Mark all child nodes that have no documentation as having   private access and internal status. qdoc will then ignore   them for documentation purposes. Some nodes have an   Intermediate status, meaning that they should be ignored,   but not their children.  */
end_comment
begin_function
DECL|function|makeUndocumentedChildrenInternal
name|void
name|Aggregate
operator|::
name|makeUndocumentedChildrenInternal
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|child
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Intermediate
condition|)
block|{
name|child
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Private
argument_list|)
expr_stmt|;
name|child
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Internal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   This is where we set the overload numbers for function nodes.   \note Overload numbers for related non-members are handled   separately.  */
end_comment
begin_function
DECL|function|normalizeOverloads
name|void
name|Aggregate
operator|::
name|normalizeOverloads
parameter_list|()
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|p1
init|=
name|primaryFunctionMap_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|primaryFunctionMap_
operator|.
name|end
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|primaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|p1
decl_stmt|;
if|if
condition|(
name|primaryFunc
operator|->
name|status
argument_list|()
operator|!=
name|Active
operator|||
name|primaryFunc
operator|->
name|access
argument_list|()
operator|==
name|Private
condition|)
block|{
if|if
condition|(
name|secondaryFunctionMap_
operator|.
name|contains
argument_list|(
name|primaryFunc
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
comment|/*                   Either the primary function is not active or it is private.                   It therefore can't be the primary function. Search the list                   of overloads to find one that can be the primary function.                 */
name|NodeList
modifier|&
name|overloads
init|=
name|secondaryFunctionMap_
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|overloads
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|overloads
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|overloadFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
decl_stmt|;
comment|/*                       Any non-obsolete, non-private function (i.e., visible function)                       is preferable to the current primary function. Swap the primary                       and overload functions.                     */
if|if
condition|(
name|overloadFunc
operator|->
name|status
argument_list|()
operator|==
name|Active
operator|&&
name|overloadFunc
operator|->
name|access
argument_list|()
operator|!=
name|Private
condition|)
block|{
name|primaryFunc
operator|->
name|setOverloadNumber
argument_list|(
name|overloadFunc
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
name|overloads
operator|.
name|replace
argument_list|(
name|overloads
operator|.
name|indexOf
argument_list|(
name|overloadFunc
argument_list|)
argument_list|,
name|primaryFunc
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|=
name|overloadFunc
expr_stmt|;
name|overloadFunc
operator|->
name|setOverloadFlag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|overloadFunc
operator|->
name|setOverloadNumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
operator|++
name|p1
expr_stmt|;
block|}
comment|/*       Ensure that none of the primary functions is marked with \overload.      */
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|p
init|=
name|primaryFunctionMap_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|primaryFunctionMap_
operator|.
name|end
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|primaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|primaryFunc
operator|->
name|isOverload
argument_list|()
condition|)
block|{
if|if
condition|(
name|secondaryFunctionMap_
operator|.
name|contains
argument_list|(
name|primaryFunc
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
comment|/*                   The primary function is marked with \overload. Find an                   overload in the secondary function map that is not marked                   with \overload but that is active and not private. Then                   swap it with the primary function.                 */
name|NodeList
modifier|&
name|overloads
init|=
name|secondaryFunctionMap_
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|overloads
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|overloads
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|overloadFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|overloadFunc
operator|->
name|isOverload
argument_list|()
condition|)
block|{
if|if
condition|(
name|overloadFunc
operator|->
name|status
argument_list|()
operator|==
name|Active
operator|&&
name|overloadFunc
operator|->
name|access
argument_list|()
operator|!=
name|Private
condition|)
block|{
name|primaryFunc
operator|->
name|setOverloadNumber
argument_list|(
name|overloadFunc
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
name|overloads
operator|.
name|replace
argument_list|(
name|overloads
operator|.
name|indexOf
argument_list|(
name|overloadFunc
argument_list|)
argument_list|,
name|primaryFunc
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|overloadFunc
expr_stmt|;
name|overloadFunc
operator|->
name|setOverloadFlag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|overloadFunc
operator|->
name|setOverloadNumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
comment|/*       Recursive part.      */
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isAggregate
argument_list|()
condition|)
operator|(
operator|(
name|Aggregate
operator|*
operator|)
operator|*
name|c
operator|)
operator|->
name|normalizeOverloads
argument_list|()
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|removeFromRelated
name|void
name|Aggregate
operator|::
name|removeFromRelated
parameter_list|()
block|{
while|while
condition|(
operator|!
name|related_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|related_
operator|.
name|takeFirst
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|p
operator|->
name|relates
argument_list|()
operator|==
name|this
condition|)
name|p
operator|->
name|clearRelated
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Deletes all this node's children.  */
end_comment
begin_function
DECL|function|deleteChildren
name|void
name|Aggregate
operator|::
name|deleteChildren
parameter_list|()
block|{
name|NodeList
name|childrenCopy
init|=
name|children_
decl_stmt|;
comment|// `children_` will be changed in ~Node()
name|qDeleteAll
argument_list|(
name|childrenCopy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool Aggregate::isAggregate() const   Returns \c true because this is an inner node.  */
end_comment
begin_comment
comment|/*!   Returns \c true if the node is a class node or a QML type node   that is marked as being a wrapper class or QML type, or if   it is a member of a wrapper class or type.  */
end_comment
begin_function
DECL|function|isWrapper
name|bool
name|Node
operator|::
name|isWrapper
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|parent_
condition|?
name|parent_
operator|->
name|isWrapper
argument_list|()
else|:
literal|false
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Finds the enum type node that has \a enumValue as one of   its enum values and returns a pointer to it. Returns 0 if   no enum type node is found that has \a enumValue as one   of its values.  */
end_comment
begin_function
DECL|function|findEnumNodeForValue
specifier|const
name|EnumNode
modifier|*
name|Aggregate
operator|::
name|findEnumNodeForValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|enumValue
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|enumChildren_
control|)
block|{
specifier|const
name|EnumNode
modifier|*
name|en
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|en
operator|->
name|hasItem
argument_list|(
name|enumValue
argument_list|)
condition|)
return|return
name|en
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a node list containing all the member functions of   some class such that the functions overload the name \a funcName.  */
end_comment
begin_function
DECL|function|overloads
name|NodeList
name|Aggregate
operator|::
name|overloads
parameter_list|(
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
name|Node
modifier|*
name|primary
init|=
name|primaryFunctionMap_
operator|.
name|value
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
name|result
operator|<<
name|primary
expr_stmt|;
name|result
operator|+=
name|secondaryFunctionMap_
index|[
name|funcName
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Construct an inner node (i.e., not a leaf node) of the   given \a type and having the given \a parent and \a name.  */
end_comment
begin_constructor
DECL|function|Aggregate
name|Aggregate
operator|::
name|Aggregate
parameter_list|(
name|NodeType
name|type
parameter_list|,
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Class
case|:
case|case
name|QmlType
case|:
case|case
name|Namespace
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Appends an \a include file to the list of include files.  */
end_comment
begin_function
DECL|function|addInclude
name|void
name|Aggregate
operator|::
name|addInclude
parameter_list|(
specifier|const
name|QString
modifier|&
name|include
parameter_list|)
block|{
name|includes_
operator|.
name|append
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the list of include files to \a includes.  */
end_comment
begin_function
DECL|function|setIncludes
name|void
name|Aggregate
operator|::
name|setIncludes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|includes
parameter_list|)
block|{
name|includes_
operator|=
name|includes
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   f1 is always the clone  */
end_comment
begin_function
DECL|function|isSameSignature
name|bool
name|Aggregate
operator|::
name|isSameSignature
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|f1
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|f2
parameter_list|)
block|{
if|if
condition|(
name|f1
operator|->
name|parameters
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|!=
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|false
return|;
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p1
init|=
name|f1
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p2
init|=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p2
operator|!=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|)
operator|.
name|hasType
argument_list|()
operator|&&
operator|(
operator|*
name|p2
operator|)
operator|.
name|hasType
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|)
operator|.
name|rightType
argument_list|()
operator|!=
operator|(
operator|*
name|p2
operator|)
operator|.
name|rightType
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|t1
init|=
name|p1
operator|->
name|dataType
argument_list|()
decl_stmt|;
name|QString
name|t2
init|=
name|p2
operator|->
name|dataType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|.
name|length
argument_list|()
operator|<
name|t2
operator|.
name|length
argument_list|()
condition|)
name|qSwap
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/*               ### hack for C++ to handle superfluous               "Foo::" prefixes gracefully             */
if|if
condition|(
name|t1
operator|!=
name|t2
operator|&&
name|t1
operator|!=
operator|(
name|f2
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|t2
operator|)
condition|)
return|return
literal|false
return|;
block|}
operator|++
name|p1
expr_stmt|;
operator|++
name|p2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Adds the \a child to this node's child list. It might also   be necessary to update this node's internal collections and   the child's parent pointer and output subdirectory.  */
end_comment
begin_function
DECL|function|addChild
name|void
name|Aggregate
operator|::
name|addChild
parameter_list|(
name|Node
modifier|*
name|child
parameter_list|)
block|{
name|children_
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Function
operator|||
name|child
operator|->
name|type
argument_list|()
operator|==
name|QmlMethod
operator|||
name|child
operator|->
name|type
argument_list|()
operator|==
name|QmlSignal
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|func
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|primaryFunctionMap_
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|primaryFunctionMap_
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|func
operator|->
name|setOverloadNumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeList
modifier|&
name|overloads
init|=
name|secondaryFunctionMap_
index|[
name|name
index|]
decl_stmt|;
name|overloads
operator|.
name|append
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|func
operator|->
name|setOverloadNumber
argument_list|(
name|overloads
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Enum
condition|)
name|enumChildren_
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|childMap_
operator|.
name|insertMulti
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|->
name|parent
argument_list|()
operator|==
literal|0
condition|)
block|{
name|child
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|child
operator|->
name|setOutputSubdirectory
argument_list|(
name|this
operator|->
name|outputSubdirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Adds the \a child to this node's child map using \a title   as the key. The \a child is not added to the child list   again, because it is presumed to already be there. We just   want to be able to find the child by its \a title.  */
end_comment
begin_function
DECL|function|addChild
name|void
name|Aggregate
operator|::
name|addChild
parameter_list|(
name|Node
modifier|*
name|child
parameter_list|,
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|childMap_
operator|.
name|insertMulti
argument_list|(
name|title
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   The \a child is removed from this node's child list and   from this node's internal collections. The child's parent   pointer is set to 0, but its output subdirectory is not   changed.  */
end_comment
begin_function
DECL|function|removeChild
name|void
name|Aggregate
operator|::
name|removeChild
parameter_list|(
name|Node
modifier|*
name|child
parameter_list|)
block|{
name|children_
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|enumChildren_
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Function
operator|||
name|child
operator|->
name|type
argument_list|()
operator|==
name|QmlMethod
operator|||
name|child
operator|->
name|type
argument_list|()
operator|==
name|QmlSignal
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|primary
init|=
name|primaryFunctionMap_
operator|.
name|find
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|NodeList
modifier|&
name|overloads
init|=
name|secondaryFunctionMap_
index|[
name|child
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|primary
operator|!=
name|primaryFunctionMap_
operator|.
name|end
argument_list|()
operator|&&
operator|*
name|primary
operator|==
name|child
condition|)
block|{
name|primaryFunctionMap_
operator|.
name|erase
argument_list|(
name|primary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|overloads
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|overloads
operator|.
name|takeFirst
argument_list|()
argument_list|)
decl_stmt|;
name|fn
operator|->
name|setOverloadNumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|primaryFunctionMap_
operator|.
name|insert
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|overloads
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|ent
init|=
name|childMap_
operator|.
name|find
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|ent
operator|!=
name|childMap_
operator|.
name|end
argument_list|()
operator|&&
name|ent
operator|.
name|key
argument_list|()
operator|==
name|child
operator|->
name|name
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|ent
operator|==
name|child
condition|)
block|{
name|childMap_
operator|.
name|erase
argument_list|(
name|ent
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|ent
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|->
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|ent
operator|=
name|childMap_
operator|.
name|find
argument_list|(
name|child
operator|->
name|title
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|ent
operator|!=
name|childMap_
operator|.
name|end
argument_list|()
operator|&&
name|ent
operator|.
name|key
argument_list|()
operator|==
name|child
operator|->
name|title
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|ent
operator|==
name|child
condition|)
block|{
name|childMap_
operator|.
name|erase
argument_list|(
name|ent
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|ent
expr_stmt|;
block|}
name|child
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Recursively sets the output subdirectory for children  */
end_comment
begin_function
DECL|function|setOutputSubdirectory
name|void
name|Aggregate
operator|::
name|setOutputSubdirectory
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
name|Node
operator|::
name|setOutputSubdirectory
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNodes
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|childNodes
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|setOutputSubdirectory
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Find the module (Qt Core, Qt GUI, etc.) to which the class belongs.   We do this by obtaining the full path to the header file's location   and examine everything between "src/" and the filename.  This is   semi-dirty because we are assuming a particular directory structure.    This function is only really useful if the class's module has not   been defined in the header file with a QT_MODULE macro or with an   \inmodule command in the documentation. */
end_comment
begin_function
DECL|function|physicalModuleName
name|QString
name|Node
operator|::
name|physicalModuleName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|physicalModuleName_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|physicalModuleName_
return|;
name|QString
name|path
init|=
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
decl_stmt|;
name|QString
name|pattern
init|=
name|QString
argument_list|(
literal|"src"
argument_list|)
operator|+
name|QDir
operator|::
name|separator
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|moduleDir
init|=
name|path
operator|.
name|mid
argument_list|(
name|start
operator|+
name|pattern
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|finish
init|=
name|moduleDir
operator|.
name|indexOf
argument_list|(
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|finish
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|physicalModuleName
init|=
name|moduleDir
operator|.
name|left
argument_list|(
name|finish
argument_list|)
decl_stmt|;
if|if
condition|(
name|physicalModuleName
operator|==
literal|"corelib"
condition|)
return|return
literal|"QtCore"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"uitools"
condition|)
return|return
literal|"QtUiTools"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"gui"
condition|)
return|return
literal|"QtGui"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"network"
condition|)
return|return
literal|"QtNetwork"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"opengl"
condition|)
return|return
literal|"QtOpenGL"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"svg"
condition|)
return|return
literal|"QtSvg"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"sql"
condition|)
return|return
literal|"QtSql"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"qtestlib"
condition|)
return|return
literal|"QtTest"
return|;
elseif|else
if|if
condition|(
name|moduleDir
operator|.
name|contains
argument_list|(
literal|"webkit"
argument_list|)
condition|)
return|return
literal|"QtWebKit"
return|;
elseif|else
if|if
condition|(
name|physicalModuleName
operator|==
literal|"xml"
condition|)
return|return
literal|"QtXml"
return|;
else|else
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Removes a node from the list of nodes related to this one.   If it is a function node, also remove from the primary/   secondary function maps.  */
end_comment
begin_function
DECL|function|removeRelated
name|void
name|Aggregate
operator|::
name|removeRelated
parameter_list|(
name|Node
modifier|*
name|pseudoChild
parameter_list|)
block|{
name|related_
operator|.
name|removeAll
argument_list|(
name|pseudoChild
argument_list|)
expr_stmt|;
if|if
condition|(
name|pseudoChild
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|p
init|=
name|primaryFunctionMap_
operator|.
name|find
argument_list|(
name|pseudoChild
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|primaryFunctionMap_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|value
argument_list|()
operator|==
name|pseudoChild
condition|)
block|{
name|primaryFunctionMap_
operator|.
name|erase
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|NodeList
modifier|&
name|overloads
init|=
name|secondaryFunctionMap_
index|[
name|pseudoChild
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|overloads
operator|.
name|removeAll
argument_list|(
name|pseudoChild
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Adds \a pseudoChild to the list of nodes related to this one. Resolve a correct   overload number for a related non-member function.  */
end_comment
begin_function
DECL|function|addRelated
name|void
name|Aggregate
operator|::
name|addRelated
parameter_list|(
name|Node
modifier|*
name|pseudoChild
parameter_list|)
block|{
name|related_
operator|.
name|append
argument_list|(
name|pseudoChild
argument_list|)
expr_stmt|;
if|if
condition|(
name|pseudoChild
operator|->
name|isFunction
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|fn
init|=
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|pseudoChild
argument_list|)
decl_stmt|;
if|if
condition|(
name|primaryFunctionMap_
operator|.
name|contains
argument_list|(
name|pseudoChild
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|secondaryFunctionMap_
index|[
name|pseudoChild
operator|->
name|name
argument_list|()
index|]
operator|.
name|append
argument_list|(
name|pseudoChild
argument_list|)
expr_stmt|;
name|fn
operator|->
name|setOverloadNumber
argument_list|(
name|secondaryFunctionMap_
index|[
name|pseudoChild
operator|->
name|name
argument_list|()
index|]
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fn
operator|->
name|setOverloadFlag
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primaryFunctionMap_
operator|.
name|insert
argument_list|(
name|pseudoChild
operator|->
name|name
argument_list|()
argument_list|,
name|pseudoChild
argument_list|)
expr_stmt|;
name|fn
operator|->
name|setOverloadNumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fn
operator|->
name|setOverloadFlag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   If this node has a child that is a QML property named \a n,   return the pointer to that child.  */
end_comment
begin_function
DECL|function|hasQmlProperty
name|QmlPropertyNode
modifier|*
name|Aggregate
operator|::
name|hasQmlProperty
parameter_list|(
specifier|const
name|QString
modifier|&
name|n
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|name
argument_list|()
operator|==
name|n
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|t
init|=
name|child
operator|->
name|hasQmlProperty
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   If this node has a child that is a QML property named \a n   whose type (attached or normal property) matches \a attached,   return the pointer to that child.  */
end_comment
begin_function
DECL|function|hasQmlProperty
name|QmlPropertyNode
modifier|*
name|Aggregate
operator|::
name|hasQmlProperty
parameter_list|(
specifier|const
name|QString
modifier|&
name|n
parameter_list|,
name|bool
name|attached
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|name
argument_list|()
operator|==
name|n
operator|&&
name|child
operator|->
name|isAttached
argument_list|()
operator|==
name|attached
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|t
init|=
name|child
operator|->
name|hasQmlProperty
argument_list|(
name|n
argument_list|,
name|attached
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \class LeafNode  */
end_comment
begin_comment
comment|/*! \fn bool LeafNode::isAggregate() const   Returns \c false because this is a LeafNode.  */
end_comment
begin_comment
comment|/*!   Constructs a leaf node named \a name of the specified   \a type. The new leaf node becomes a child of \a parent.  */
end_comment
begin_constructor
DECL|function|LeafNode
name|LeafNode
operator|::
name|LeafNode
parameter_list|(
name|NodeType
name|type
parameter_list|,
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Enum
case|:
case|case
name|Function
case|:
case|case
name|Typedef
case|:
case|case
name|Variable
case|:
case|case
name|QmlProperty
case|:
case|case
name|QmlSignal
case|:
case|case
name|QmlSignalHandler
case|:
case|case
name|QmlMethod
case|:
case|case
name|QmlBasicType
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   This constructor should only be used when this node's parent   is meant to be \a parent, but this node is not to be listed   as a child of \a parent. It is currently only used for the   documentation case where a \e{qmlproperty} command is used   to override the QML definition of a QML property.  */
end_comment
begin_constructor
DECL|function|LeafNode
name|LeafNode
operator|::
name|LeafNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
name|NodeType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
block|{
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Enum
case|:
case|case
name|Function
case|:
case|case
name|Typedef
case|:
case|case
name|Variable
case|:
case|case
name|QmlProperty
case|:
case|case
name|QmlSignal
case|:
case|case
name|QmlSignalHandler
case|:
case|case
name|QmlMethod
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   \class NamespaceNode  */
end_comment
begin_comment
comment|/*!   Constructs a namespace node.  */
end_comment
begin_constructor
DECL|function|NamespaceNode
name|NamespaceNode
operator|::
name|NamespaceNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|Namespace
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|seen_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|tree_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \class ClassNode   \brief This class represents a C++ class.  */
end_comment
begin_comment
comment|/*!   Constructs a class node. A class node will generate an API page.  */
end_comment
begin_constructor
DECL|function|ClassNode
name|ClassNode
operator|::
name|ClassNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|Class
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
name|abstract_
operator|=
literal|false
expr_stmt|;
name|wrapper_
operator|=
literal|false
expr_stmt|;
name|qmlelement
operator|=
literal|0
expr_stmt|;
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Adds the base class \a node to this class's list of base   classes. The base class has the specified \a access. This   is a resolved base class.  */
end_comment
begin_function
DECL|function|addResolvedBaseClass
name|void
name|ClassNode
operator|::
name|addResolvedBaseClass
parameter_list|(
name|Access
name|access
parameter_list|,
name|ClassNode
modifier|*
name|node
parameter_list|)
block|{
name|bases_
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|derived_
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds the derived class \a node to this class's list of derived   classes. The derived class inherits this class with \a access.  */
end_comment
begin_function
DECL|function|addDerivedClass
name|void
name|ClassNode
operator|::
name|addDerivedClass
parameter_list|(
name|Access
name|access
parameter_list|,
name|ClassNode
modifier|*
name|node
parameter_list|)
block|{
name|derived_
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Add an unresolved base class to this class node's list of   base classes. The unresolved base class will be resolved   before the generate phase of qdoc. In an unresolved base   class, the pointer to the base class node is 0.  */
end_comment
begin_function
DECL|function|addUnresolvedBaseClass
name|void
name|ClassNode
operator|::
name|addUnresolvedBaseClass
parameter_list|(
name|Access
name|access
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|)
block|{
name|bases_
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|path
argument_list|,
name|signature
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Add an unresolved \c using clause to this class node's list   of \c using clauses. The unresolved \c using clause will be   resolved before the generate phase of qdoc. In an unresolved   \c using clause, the pointer to the function node is 0.  */
end_comment
begin_function
DECL|function|addUnresolvedUsingClause
name|void
name|ClassNode
operator|::
name|addUnresolvedUsingClause
parameter_list|(
specifier|const
name|QString
modifier|&
name|signature
parameter_list|)
block|{
name|usingClauses_
operator|.
name|append
argument_list|(
name|UsingClause
argument_list|(
name|signature
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixBaseClasses
name|void
name|ClassNode
operator|::
name|fixBaseClasses
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|QSet
argument_list|<
name|ClassNode
modifier|*
argument_list|>
name|found
decl_stmt|;
comment|// Remove private and duplicate base classes.
while|while
condition|(
name|i
operator|<
name|bases_
operator|.
name|size
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|bc
init|=
name|bases_
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|bc
operator|&&
operator|(
name|bc
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|found
operator|.
name|contains
argument_list|(
name|bc
argument_list|)
operator|)
condition|)
block|{
name|RelatedClass
name|rc
init|=
name|bases_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bases_
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ignoredBases_
operator|.
name|append
argument_list|(
name|rc
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bb
init|=
name|bc
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|bb
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|bases_
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|bb
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
name|found
operator|.
name|insert
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|derived_
operator|.
name|size
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|dc
init|=
name|derived_
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|dc
operator|&&
name|dc
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|derived_
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|dd
init|=
name|dc
operator|->
name|derivedClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|dd
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|derived_
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|dd
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Not sure why this is needed.  */
end_comment
begin_function
DECL|function|fixPropertyUsingBaseClasses
name|void
name|ClassNode
operator|::
name|fixPropertyUsingBaseClasses
parameter_list|(
name|PropertyNode
modifier|*
name|pn
parameter_list|)
block|{
name|QList
argument_list|<
name|RelatedClass
argument_list|>
operator|::
name|const_iterator
name|bc
init|=
name|baseClasses
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|bc
operator|!=
name|baseClasses
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bc
operator|->
name|node_
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|cn
operator|->
name|findChildNode
argument_list|(
name|pn
operator|->
name|name
argument_list|()
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|PropertyNode
modifier|*
name|baseProperty
init|=
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|cn
operator|->
name|fixPropertyUsingBaseClasses
argument_list|(
name|baseProperty
argument_list|)
expr_stmt|;
name|pn
operator|->
name|setOverriddenFrom
argument_list|(
name|baseProperty
argument_list|)
expr_stmt|;
block|}
else|else
name|cn
operator|->
name|fixPropertyUsingBaseClasses
argument_list|(
name|pn
argument_list|)
expr_stmt|;
block|}
operator|++
name|bc
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Search the child list to find the property node with the   specified \a name.  */
end_comment
begin_function
DECL|function|findPropertyNode
name|PropertyNode
modifier|*
name|ClassNode
operator|::
name|findPropertyNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|findChildNode
argument_list|(
name|name
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
name|PropertyNode
modifier|*
name|pn
init|=
literal|0
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|baseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
break|break;
block|}
block|}
block|}
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|ignoredBases
init|=
name|ignoredBaseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ignoredBases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ignoredBases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|ignoredBases
index|[
name|i
index|]
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
break|break;
block|}
block|}
block|}
return|return
name|pn
return|;
block|}
end_function
begin_comment
comment|/*!   This function does a recursive search of this class node's   base classes looking for one that has a QML element. If it   finds one, it returns the pointer to that QML element. If   it doesn't find one, it returns null.  */
end_comment
begin_function
DECL|function|findQmlBaseNode
name|QmlTypeNode
modifier|*
name|ClassNode
operator|::
name|findQmlBaseNode
parameter_list|()
block|{
name|QmlTypeNode
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|baseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|qmlElement
argument_list|()
condition|)
block|{
return|return
name|cn
operator|->
name|qmlElement
argument_list|()
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node_
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|result
operator|=
name|cn
operator|->
name|findQmlBaseNode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \class DocumentNode  */
end_comment
begin_comment
comment|/*!   The type of a DocumentNode is Document, and it has a \a subtype,   which specifies the type of DocumentNode. The page type for   the page index is set here.  */
end_comment
begin_constructor
DECL|function|DocumentNode
name|DocumentNode
operator|::
name|DocumentNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|DocSubtype
name|subtype
parameter_list|,
name|Node
operator|::
name|PageType
name|ptype
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|Document
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|nodeSubtype_
argument_list|(
name|subtype
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|DOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|Page
case|:
name|setPageType
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
name|DitaMap
case|:
name|setPageType
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
name|Example
case|:
name|setPageType
argument_list|(
name|ExamplePage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*! \fn QString DocumentNode::title() const   Returns the document node's title. This is used for the page title. */
end_comment
begin_comment
comment|/*!   Sets the document node's \a title. This is used for the page title.  */
end_comment
begin_function
DECL|function|setTitle
name|void
name|DocumentNode
operator|::
name|setTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|title_
operator|=
name|title
expr_stmt|;
name|parent
argument_list|()
operator|->
name|addChild
argument_list|(
name|this
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the document node's full title, which is usually   just title(), but for some DocSubtype values is different   from title()  */
end_comment
begin_function
DECL|function|fullTitle
name|QString
name|DocumentNode
operator|::
name|fullTitle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|nodeSubtype_
operator|==
name|File
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
literal|" Example File"
return|;
else|else
return|return
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nodeSubtype_
operator|==
name|Image
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
literal|" Image File"
return|;
else|else
return|return
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nodeSubtype_
operator|==
name|HeaderFile
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
return|;
else|else
return|return
name|name
argument_list|()
operator|+
literal|" - "
operator|+
name|title
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|title
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns the subtitle.  */
end_comment
begin_function
DECL|function|subTitle
name|QString
name|DocumentNode
operator|::
name|subTitle
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|subtitle_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|subtitle_
return|;
if|if
condition|(
operator|(
name|nodeSubtype_
operator|==
name|File
operator|)
operator|||
operator|(
name|nodeSubtype_
operator|==
name|Image
operator|)
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
return|return
name|name
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \class EnumNode  */
end_comment
begin_comment
comment|/*!   The constructor for the node representing an enum type   has a \a parent class and an enum type \a name.  */
end_comment
begin_constructor
DECL|function|EnumNode
name|EnumNode
operator|::
name|EnumNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Enum
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|flagsType_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Add \a item to the enum type's item list.  */
end_comment
begin_function
DECL|function|addItem
name|void
name|EnumNode
operator|::
name|addItem
parameter_list|(
specifier|const
name|EnumItem
modifier|&
name|item
parameter_list|)
block|{
name|items_
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|names_
operator|.
name|insert
argument_list|(
name|item
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the access level of the enumeration item named \a name.   Apparently it is private if it has been omitted by qdoc's   omitvalue command. Otherwise it is public.  */
end_comment
begin_function
DECL|function|itemAccess
name|Node
operator|::
name|Access
name|EnumNode
operator|::
name|itemAccess
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|doc
argument_list|()
operator|.
name|omitEnumItemNames
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|Private
return|;
return|return
name|Public
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the enum value associated with the enum \a name.  */
end_comment
begin_function
DECL|function|itemValue
name|QString
name|EnumNode
operator|::
name|itemValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|items_
control|)
block|{
if|if
condition|(
name|item
operator|.
name|name
argument_list|()
operator|==
name|name
condition|)
return|return
name|item
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \class TypedefNode  */
end_comment
begin_comment
comment|/*!  */
end_comment
begin_constructor
DECL|function|TypedefNode
name|TypedefNode
operator|::
name|TypedefNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Typedef
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|associatedEnum_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|setAssociatedEnum
name|void
name|TypedefNode
operator|::
name|setAssociatedEnum
parameter_list|(
specifier|const
name|EnumNode
modifier|*
name|enume
parameter_list|)
block|{
name|associatedEnum_
operator|=
name|enume
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class Parameter   \brief The class Parameter contains one parameter.    A parameter can be a function parameter or a macro   parameter.  */
end_comment
begin_comment
comment|/*!   Constructs this parameter from the left and right types   \a dataType and rightType, the parameter \a name, and the   \a defaultValue. In practice, \a rightType is not used,   and I don't know what is was meant for.  */
end_comment
begin_constructor
DECL|function|Parameter
name|Parameter
operator|::
name|Parameter
parameter_list|(
specifier|const
name|QString
modifier|&
name|dataType
parameter_list|,
specifier|const
name|QString
modifier|&
name|rightType
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defaultValue
parameter_list|)
member_init_list|:
name|dataType_
argument_list|(
name|dataType
argument_list|)
member_init_list|,
name|rightType_
argument_list|(
name|rightType
argument_list|)
member_init_list|,
name|name_
argument_list|(
name|name
argument_list|)
member_init_list|,
name|defaultValue_
argument_list|(
name|defaultValue
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   Standard copy constructor copies \p.  */
end_comment
begin_constructor
DECL|function|Parameter
name|Parameter
operator|::
name|Parameter
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|p
parameter_list|)
member_init_list|:
name|dataType_
argument_list|(
name|p
operator|.
name|dataType_
argument_list|)
member_init_list|,
name|rightType_
argument_list|(
name|p
operator|.
name|rightType_
argument_list|)
member_init_list|,
name|name_
argument_list|(
name|p
operator|.
name|name_
argument_list|)
member_init_list|,
name|defaultValue_
argument_list|(
name|p
operator|.
name|defaultValue_
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   standard assignment operator assigns \p.  */
end_comment
begin_function
DECL|function|operator =
name|Parameter
modifier|&
name|Parameter
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|p
parameter_list|)
block|{
name|dataType_
operator|=
name|p
operator|.
name|dataType_
expr_stmt|;
name|rightType_
operator|=
name|p
operator|.
name|rightType_
expr_stmt|;
name|name_
operator|=
name|p
operator|.
name|name_
expr_stmt|;
name|defaultValue_
operator|=
name|p
operator|.
name|defaultValue_
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Reconstructs the text describing the parameter and   returns it. If \a value is true, the default value   will be included, if there is one.  */
end_comment
begin_function
DECL|function|reconstruct
name|QString
name|Parameter
operator|::
name|reconstruct
parameter_list|(
name|bool
name|value
parameter_list|)
specifier|const
block|{
name|QString
name|p
init|=
name|dataType_
operator|+
name|rightType_
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|'&'
argument_list|)
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|+=
name|name_
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|defaultValue_
operator|.
name|isEmpty
argument_list|()
condition|)
name|p
operator|+=
literal|" = "
operator|+
name|defaultValue_
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!   \class FunctionNode  */
end_comment
begin_comment
comment|/*!   Construct a function node for a C++ function. It's parent   is \a parent, and it's name is \a name.    Do not set overloadNumber_ in the initializer list because it   is set by addChild() in the Node base class.  */
end_comment
begin_constructor
DECL|function|FunctionNode
name|FunctionNode
operator|::
name|FunctionNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Function
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|metaness_
argument_list|(
name|Plain
argument_list|)
member_init_list|,
name|virtualness_
argument_list|(
name|NonVirtual
argument_list|)
member_init_list|,
name|const_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|static_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimplemented_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|privateSignal_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|overload_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimplementedFrom_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Construct a function node for a QML method or signal, specified   by \a type. It's parent is \a parent, and it's name is \a name.   If \a attached is true, it is an attached method or signal.    Do not set overloadNumber_ in the initializer list because it   is set by addChild() in the Node base class.  */
end_comment
begin_constructor
DECL|function|FunctionNode
name|FunctionNode
operator|::
name|FunctionNode
parameter_list|(
name|NodeType
name|type
parameter_list|,
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|metaness_
argument_list|(
name|Plain
argument_list|)
member_init_list|,
name|virtualness_
argument_list|(
name|NonVirtual
argument_list|)
member_init_list|,
name|const_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|static_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimplemented_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|privateSignal_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|overload_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimplementedFrom_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|QML
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QmlMethod
operator|||
name|type
operator|==
name|QmlSignal
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
condition|)
name|setStatus
argument_list|(
name|Internal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Function
condition|)
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Sets the \a virtualness of this function. If the \a virtualness   is PureVirtual, and if the parent() is a ClassNode, set the parent's   \e abstract flag to true.  */
end_comment
begin_function
DECL|function|setVirtualness
name|void
name|FunctionNode
operator|::
name|setVirtualness
parameter_list|(
name|Virtualness
name|v
parameter_list|)
block|{
name|virtualness_
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|==
name|PureVirtual
operator|)
operator|&&
name|parent
argument_list|()
operator|&&
operator|(
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|)
condition|)
name|parent
argument_list|()
operator|->
name|setAbstract
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn void FunctionNode::setOverloadFlag(bool b)   Sets this function node's overload flag to \a b.   It does not set the overload number.  */
end_comment
begin_comment
comment|/*! \fn void FunctionNode::setOverloadNumber(unsigned char n)   Sets this function node's overload number to \a n.   It does not set the overload flag.  */
end_comment
begin_comment
comment|/*!   Sets the function node's reimplementation flag to \a b.   When \a b is true, it is supposed to mean that this function   is a reimplementation of a virtual function in a base class,   but it really just means the \e {\\reimp} command was seen in   the qdoc comment.  */
end_comment
begin_function
DECL|function|setReimplemented
name|void
name|FunctionNode
operator|::
name|setReimplemented
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|reimplemented_
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Append \a parameter to the parameter list.  */
end_comment
begin_function
DECL|function|addParameter
name|void
name|FunctionNode
operator|::
name|addParameter
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|parameter
parameter_list|)
block|{
name|parameters_
operator|.
name|append
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|borrowParameterNames
name|void
name|FunctionNode
operator|::
name|borrowParameterNames
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|source
parameter_list|)
block|{
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|Iterator
name|t
init|=
name|parameters_
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|source
operator|->
name|parameters_
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|source
operator|->
name|parameters_
operator|.
name|constEnd
argument_list|()
operator|&&
name|t
operator|!=
name|parameters_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
operator|*
name|t
operator|)
operator|.
name|setName
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   If this function is a reimplementation, \a from points   to the FunctionNode of the function being reimplemented.  */
end_comment
begin_function
DECL|function|setReimplementedFrom
name|void
name|FunctionNode
operator|::
name|setReimplementedFrom
parameter_list|(
name|FunctionNode
modifier|*
name|f
parameter_list|)
block|{
name|reimplementedFrom_
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|reimplementedBy_
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds the "associated" property \a p to this function node.   The function might be the setter or getter for a property,   for example.  */
end_comment
begin_function
DECL|function|addAssociatedProperty
name|void
name|FunctionNode
operator|::
name|addAssociatedProperty
parameter_list|(
name|PropertyNode
modifier|*
name|p
parameter_list|)
block|{
name|associatedProperties_
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this function has at least one property   that is active, i.e. at least one property that is not   obsolete.  */
end_comment
begin_function
DECL|function|hasActiveAssociatedProperty
name|bool
name|FunctionNode
operator|::
name|hasActiveAssociatedProperty
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|associatedProperties_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
foreach|foreach
control|(
specifier|const
name|PropertyNode
modifier|*
name|p
decl|,
name|associatedProperties_
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|isObsolete
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \fn unsigned char FunctionNode::overloadNumber() const   Returns the overload number for this function.  */
end_comment
begin_comment
comment|/*!   Returns the list of parameter names.  */
end_comment
begin_function
DECL|function|parameterNames
name|QStringList
name|FunctionNode
operator|::
name|parameterNames
parameter_list|()
specifier|const
block|{
name|QStringList
name|names
decl_stmt|;
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|names
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|names
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a raw list of parameters. If \a names is true, the   names are included. If \a values is true, the default values   are included, if any are present.  */
end_comment
begin_function
DECL|function|rawParameters
name|QString
name|FunctionNode
operator|::
name|rawParameters
parameter_list|(
name|bool
name|names
parameter_list|,
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QString
name|raw
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|parameter
decl|,
name|parameters
argument_list|()
control|)
block|{
name|raw
operator|+=
name|parameter
operator|.
name|dataType
argument_list|()
operator|+
name|parameter
operator|.
name|rightType
argument_list|()
expr_stmt|;
if|if
condition|(
name|names
condition|)
name|raw
operator|+=
name|parameter
operator|.
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|values
condition|)
name|raw
operator|+=
name|parameter
operator|.
name|defaultValue
argument_list|()
expr_stmt|;
block|}
return|return
name|raw
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of reconstructed parameters. If \a values   is true, the default values are included, if any are present.  */
end_comment
begin_function
DECL|function|reconstructParameters
name|QStringList
name|FunctionNode
operator|::
name|reconstructParameters
parameter_list|(
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QStringList
name|reconstructedParameters
decl_stmt|;
name|QVector
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|reconstructedParameters
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|reconstruct
argument_list|(
name|values
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|reconstructedParameters
return|;
block|}
end_function
begin_comment
comment|/*!   Reconstructs and returns the function's signature. If \a values   is true, the default values of the parameters are included, if   present.  */
end_comment
begin_function
DECL|function|signature
name|QString
name|FunctionNode
operator|::
name|signature
parameter_list|(
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QString
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|returnType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|=
name|returnType
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|+=
name|name
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|QStringList
name|reconstructedParameters
init|=
name|reconstructParameters
argument_list|(
name|values
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|reconstructedParameters
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|+=
name|reconstructedParameters
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|p
operator|-
literal|1
operator|)
condition|)
name|s
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
name|s
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if function \a fn has role \a r for this   property.  */
end_comment
begin_function
DECL|function|role
name|PropertyNode
operator|::
name|FunctionRole
name|PropertyNode
operator|::
name|role
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|fn
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|functions_
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
cast|const_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FunctionRole
operator|)
name|i
return|;
block|}
return|return
name|Notifier
return|;
block|}
end_function
begin_comment
comment|/*!   Print some debugging stuff.  */
end_comment
begin_function
DECL|function|debug
name|void
name|FunctionNode
operator|::
name|debug
parameter_list|()
specifier|const
block|{
name|qDebug
argument_list|(
literal|"QML METHOD %s returnType_ %s parentPath_ %s"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|returnType_
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|parentPath_
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class PropertyNode    This class describes one instance of using the Q_PROPERTY macro.  */
end_comment
begin_comment
comment|/*!   The constructor sets the \a parent and the \a name, but   everything else is set to default values.  */
end_comment
begin_constructor
DECL|function|PropertyNode
name|PropertyNode
operator|::
name|PropertyNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Property
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|scriptable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|writable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|user_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|const_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|final_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|revision_
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|overrides_
argument_list|(
literal|0
argument_list|)
block|{
name|setGenus
argument_list|(
name|Node
operator|::
name|CPP
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Sets this property's \e {overridden from} property to   \a baseProperty, which indicates that this property   overrides \a baseProperty. To begin with, all the values   in this property are set to the corresponding values in   \a baseProperty.    We probably should ensure that the constant and final   attributes are not being overridden improperly.  */
end_comment
begin_function
DECL|function|setOverriddenFrom
name|void
name|PropertyNode
operator|::
name|setOverriddenFrom
parameter_list|(
specifier|const
name|PropertyNode
modifier|*
name|baseProperty
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumFunctionRoles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|functions_
index|[
name|i
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|functions_
index|[
name|i
index|]
operator|=
name|baseProperty
operator|->
name|functions_
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|stored_
operator|==
name|FlagValueDefault
condition|)
name|stored_
operator|=
name|baseProperty
operator|->
name|stored_
expr_stmt|;
if|if
condition|(
name|designable_
operator|==
name|FlagValueDefault
condition|)
name|designable_
operator|=
name|baseProperty
operator|->
name|designable_
expr_stmt|;
if|if
condition|(
name|scriptable_
operator|==
name|FlagValueDefault
condition|)
name|scriptable_
operator|=
name|baseProperty
operator|->
name|scriptable_
expr_stmt|;
if|if
condition|(
name|writable_
operator|==
name|FlagValueDefault
condition|)
name|writable_
operator|=
name|baseProperty
operator|->
name|writable_
expr_stmt|;
if|if
condition|(
name|user_
operator|==
name|FlagValueDefault
condition|)
name|user_
operator|=
name|baseProperty
operator|->
name|user_
expr_stmt|;
name|overrides_
operator|=
name|baseProperty
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|qualifiedDataType
name|QString
name|PropertyNode
operator|::
name|qualifiedDataType
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|setters
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|resetters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|type_
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|||
name|type_
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
condition|)
block|{
comment|// 'QWidget *' becomes 'QWidget *' const
return|return
name|type_
operator|+
literal|" const"
return|;
block|}
else|else
block|{
comment|/*               'int' becomes 'const int' ('int const' is               correct C++, but looks wrong)             */
return|return
literal|"const "
operator|+
name|type_
return|;
block|}
block|}
else|else
block|{
return|return
name|type_
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|member|qmlOnly
name|bool
name|QmlTypeNode
operator|::
name|qmlOnly
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|inheritedBy
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
name|QmlTypeNode
operator|::
name|inheritedBy
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs a Qml class node. The new node has the given   \a parent and \a name.  */
end_comment
begin_constructor
DECL|function|QmlTypeNode
name|QmlTypeNode
operator|::
name|QmlTypeNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|QmlType
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|abstract_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cnodeRequired_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|wrapper_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cnode_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|logicalModule_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|qmlBaseNode_
argument_list|(
literal|0
argument_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"QML:"
argument_list|)
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"BOGUS QML qualifier:"
operator|<<
name|name
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
block|}
name|setTitle
argument_list|(
name|name
operator|.
name|mid
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|setPageType
argument_list|(
name|Node
operator|::
name|ApiPage
argument_list|)
expr_stmt|;
name|setGenus
argument_list|(
name|Node
operator|::
name|QML
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Needed for printing a debug messages.  */
end_comment
begin_destructor
DECL|function|~QmlTypeNode
name|QmlTypeNode
operator|::
name|~
name|QmlTypeNode
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Clear the static maps so that subsequent runs don't try to use   contents from a previous run.  */
end_comment
begin_function
DECL|function|terminate
name|void
name|QmlTypeNode
operator|::
name|terminate
parameter_list|()
block|{
name|inheritedBy
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Record the fact that QML class \a base is inherited by   QML class \a sub.  */
end_comment
begin_function
DECL|function|addInheritedBy
name|void
name|QmlTypeNode
operator|::
name|addInheritedBy
parameter_list|(
specifier|const
name|QString
modifier|&
name|base
parameter_list|,
name|Node
modifier|*
name|sub
parameter_list|)
block|{
if|if
condition|(
name|sub
operator|->
name|isInternal
argument_list|()
condition|)
return|return;
if|if
condition|(
name|inheritedBy
operator|.
name|constFind
argument_list|(
name|base
argument_list|,
name|sub
argument_list|)
operator|==
name|inheritedBy
operator|.
name|constEnd
argument_list|()
condition|)
name|inheritedBy
operator|.
name|insert
argument_list|(
name|base
argument_list|,
name|sub
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Loads the list \a subs with the nodes of all the subclasses of \a base.  */
end_comment
begin_function
DECL|function|subclasses
name|void
name|QmlTypeNode
operator|::
name|subclasses
parameter_list|(
specifier|const
name|QString
modifier|&
name|base
parameter_list|,
name|NodeList
modifier|&
name|subs
parameter_list|)
block|{
name|subs
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|inheritedBy
operator|.
name|count
argument_list|(
name|base
argument_list|)
operator|>
literal|0
condition|)
block|{
name|subs
operator|=
name|inheritedBy
operator|.
name|values
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qmlBaseNode
name|QmlTypeNode
modifier|*
name|QmlTypeNode
operator|::
name|qmlBaseNode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qmlBaseNode_
operator|&&
operator|!
name|qmlBaseName_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qmlBaseNode_
operator|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
operator|->
name|findQmlType
argument_list|(
name|qmlBaseName_
argument_list|)
expr_stmt|;
block|}
return|return
name|qmlBaseNode_
return|;
block|}
end_function
begin_comment
comment|/*!   If this QML type node has a base type node,   return the fully qualified name of that QML   type, i.e.<QML-module-name>::<QML-type-name>.  */
end_comment
begin_function
DECL|function|qmlFullBaseName
name|QString
name|QmlTypeNode
operator|::
name|qmlFullBaseName
parameter_list|()
specifier|const
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|qmlBaseNode_
condition|)
block|{
name|result
operator|=
name|qmlBaseNode_
operator|->
name|logicalModuleName
argument_list|()
operator|+
literal|"::"
operator|+
name|qmlBaseNode_
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   If the QML type's QML module pointer is set, return the QML   module name from the QML module node. Otherwise, return the   empty string.  */
end_comment
begin_function
DECL|function|logicalModuleName
name|QString
name|QmlTypeNode
operator|::
name|logicalModuleName
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|logicalModule_
condition|?
name|logicalModule_
operator|->
name|logicalModuleName
argument_list|()
else|:
name|QString
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   If the QML type's QML module pointer is set, return the QML   module version from the QML module node. Otherwise, return   the empty string.  */
end_comment
begin_function
DECL|function|logicalModuleVersion
name|QString
name|QmlTypeNode
operator|::
name|logicalModuleVersion
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|logicalModule_
condition|?
name|logicalModule_
operator|->
name|logicalModuleVersion
argument_list|()
else|:
name|QString
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   If the QML type's QML module pointer is set, return the QML   module identifier from the QML module node. Otherwise, return   the empty string.  */
end_comment
begin_function
DECL|function|logicalModuleIdentifier
name|QString
name|QmlTypeNode
operator|::
name|logicalModuleIdentifier
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|logicalModule_
condition|?
name|logicalModule_
operator|->
name|logicalModuleIdentifier
argument_list|()
else|:
name|QString
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs a Qml basic type node. The new node has the given   \a parent and \a name.  */
end_comment
begin_constructor
DECL|function|QmlBasicTypeNode
name|QmlBasicTypeNode
operator|::
name|QmlBasicTypeNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|QmlBasicType
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
name|setTitle
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|setGenus
argument_list|(
name|Node
operator|::
name|QML
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructor for the Qml property group node. \a parent is   always a QmlTypeNode.  */
end_comment
begin_constructor
DECL|function|QmlPropertyGroupNode
name|QmlPropertyGroupNode
operator|::
name|QmlPropertyGroupNode
parameter_list|(
name|QmlTypeNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Aggregate
argument_list|(
name|QmlPropertyGroup
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
name|idNumber_
operator|=
operator|-
literal|1
expr_stmt|;
name|setGenus
argument_list|(
name|Node
operator|::
name|QML
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Return the property group node's id number for use in   constructing an id attribute for the property group.   If the id number is currently -1, increment the global   property group count and set the id number to the new   value.  */
end_comment
begin_function
DECL|function|idNumber
name|QString
name|QmlPropertyGroupNode
operator|::
name|idNumber
parameter_list|()
block|{
if|if
condition|(
name|idNumber_
operator|==
operator|-
literal|1
condition|)
name|idNumber_
operator|=
name|incPropertyGroupCount
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
operator|.
name|setNum
argument_list|(
name|idNumber_
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Constructor for the QML property node.  */
end_comment
begin_constructor
DECL|function|QmlPropertyNode
name|QmlPropertyNode
operator|::
name|QmlPropertyNode
parameter_list|(
name|Aggregate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|QmlProperty
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|type_
argument_list|(
name|type
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|isAlias_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isdefault_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|readOnly_
argument_list|(
name|FlagValueDefault
argument_list|)
block|{
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_
operator|==
name|QString
argument_list|(
literal|"alias"
argument_list|)
condition|)
name|isAlias_
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
condition|)
name|setStatus
argument_list|(
name|Internal
argument_list|)
expr_stmt|;
name|setGenus
argument_list|(
name|Node
operator|::
name|QML
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Returns \c true if a QML property or attached property is   not read-only. The algorithm for figuring this out is long   amd tedious and almost certainly will break. It currently   doesn't work for the qmlproperty:    \code       bool PropertyChanges::explicit,   \endcode    ...because the tokenizer gets confused on \e{explicit}.  */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QmlPropertyNode
operator|::
name|isWritable
parameter_list|()
block|{
if|if
condition|(
name|readOnly_
operator|!=
name|FlagValueDefault
condition|)
return|return
operator|!
name|fromFlagValue
argument_list|(
name|readOnly_
argument_list|,
literal|false
argument_list|)
return|;
name|QmlTypeNode
modifier|*
name|qcn
init|=
name|qmlTypeNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
if|if
condition|(
name|qcn
operator|->
name|cppClassRequired
argument_list|()
condition|)
block|{
if|if
condition|(
name|qcn
operator|->
name|classNode
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|pn
init|=
name|findCorrespondingCppProperty
argument_list|()
decl_stmt|;
if|if
condition|(
name|pn
condition|)
return|return
name|pn
operator|->
name|isWritable
argument_list|()
return|;
else|else
name|defLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No Q_PROPERTY for QML property %1::%2::%3 "
literal|"in C++ class documented as QML type: "
literal|"(property not found in the C++ class or its base classes)"
argument_list|)
operator|.
name|arg
argument_list|(
name|logicalModuleName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlTypeName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|defLocation
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No Q_PROPERTY for QML property %1::%2::%3 "
literal|"in C++ class documented as QML type: "
literal|"(C++ class not specified or not found)."
argument_list|)
operator|.
name|arg
argument_list|(
name|logicalModuleName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlTypeName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pointer this QML property's corresponding C++   property, if it has one.  */
end_comment
begin_function
DECL|function|findCorrespondingCppProperty
name|PropertyNode
modifier|*
name|QmlPropertyNode
operator|::
name|findCorrespondingCppProperty
parameter_list|()
block|{
name|PropertyNode
modifier|*
name|pn
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|parent
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|QmlTypeNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlTypeNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
comment|/*               If there is a dot in the property name, first               find the C++ property corresponding to the QML               property group.              */
name|QStringList
name|dotSplit
init|=
name|name
argument_list|()
operator|.
name|split
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
block|{
comment|/*                   Now find the C++ property corresponding to                   the QML property in the QML property group,<group>.<property>.                 */
if|if
condition|(
name|dotSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QStringList
name|path
argument_list|(
name|extractClassName
argument_list|(
name|pn
operator|->
name|qualifiedDataType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|nn
init|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
operator|->
name|findClassNode
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|nn
condition|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|nn
argument_list|)
decl_stmt|;
name|PropertyNode
modifier|*
name|pn2
init|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|dotSplit
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/*                           If found, return the C++ property                           corresponding to the QML property.                           Otherwise, return the C++ property                           corresponding to the QML property                           group.                         */
return|return
operator|(
name|pn2
condition|?
name|pn2
else|:
name|pn
operator|)
return|;
block|}
block|}
else|else
return|return
name|pn
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This returns the name of the owning QML type.  */
end_comment
begin_function
DECL|function|element
name|QString
name|QmlPropertyNode
operator|::
name|element
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|parent
argument_list|()
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
return|return
name|parent
argument_list|()
operator|->
name|element
argument_list|()
return|;
return|return
name|parent
argument_list|()
operator|->
name|name
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the full document name for this node and return it.  */
end_comment
begin_function
DECL|function|fullDocumentName
name|QString
name|Node
operator|::
name|fullDocumentName
parameter_list|()
specifier|const
block|{
name|QStringList
name|pieces
decl_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|this
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|n
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|n
operator|->
name|isQmlPropertyGroup
argument_list|()
condition|)
name|pieces
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
operator|)
operator|&&
operator|!
name|n
operator|->
name|logicalModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pieces
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|logicalModuleName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|->
name|isDocumentNode
argument_list|()
condition|)
break|break;
comment|// Examine the parent node if one exists.
if|if
condition|(
name|n
operator|->
name|parent
argument_list|()
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|true
condition|)
do|;
comment|// Create a name based on the type of the ancestor node.
name|QString
name|concatenator
init|=
literal|"::"
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|isQmlType
argument_list|()
operator|||
name|n
operator|->
name|isJsType
argument_list|()
condition|)
name|concatenator
operator|=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|isDocumentNode
argument_list|()
condition|)
name|concatenator
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
return|return
name|pieces
operator|.
name|join
argument_list|(
name|concatenator
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the \a str as an NCName, which means the name can   be used as the value of an \e id attribute. Search for NCName   on the internet for details of what can be an NCName.  */
end_comment
begin_function
DECL|function|cleanId
name|QString
name|Node
operator|::
name|cleanId
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|clean
decl_stmt|;
name|QString
name|name
init|=
name|str
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clean
return|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
literal|"::"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
literal|"()"
argument_list|,
literal|"-call"
argument_list|)
expr_stmt|;
name|clean
operator|.
name|reserve
argument_list|(
name|name
operator|.
name|size
argument_list|()
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|startsWith
argument_list|(
literal|"id-"
argument_list|)
condition|)
name|clean
operator|=
literal|"id-"
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|name
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'~'
condition|)
block|{
name|clean
operator|+=
literal|"dtor."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'_'
condition|)
block|{
name|clean
operator|+=
literal|"underscore."
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|name
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
name|u
operator|==
literal|'-'
operator|||
name|u
operator|==
literal|'_'
operator|||
name|u
operator|==
literal|'.'
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
operator|||
name|u
operator|==
literal|':'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'!'
condition|)
block|{
name|clean
operator|+=
literal|"-not"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'&'
condition|)
block|{
name|clean
operator|+=
literal|"-and"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'<'
condition|)
block|{
name|clean
operator|+=
literal|"-lt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'='
condition|)
block|{
name|clean
operator|+=
literal|"-eq"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'>'
condition|)
block|{
name|clean
operator|+=
literal|"-gt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'#'
condition|)
block|{
name|clean
operator|+=
literal|"-hash"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'('
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|')'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|clean
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clean
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*!   Creates a string that can be used as a UUID for the node,   depending on the type and subtype of the node. Uniquenss   is not guaranteed, but it is expected that strings created   here will be unique within an XML document. Hence, the   returned string can be used as the value of an \e id   attribute.  */
end_comment
begin_comment
unit|QString Node::idForNode() const {     const FunctionNode* func;     const TypedefNode* tdn;     QString str;      switch (type()) {     case Node::Namespace:         str = "namespace-" + fullDocumentName();         break;     case Node::Class:         str = "class-" + fullDocumentName();         break;     case Node::Enum:         str = "enum-" + name();         break;     case Node::Typedef:         tdn = static_cast<const TypedefNode*>(this);         if (tdn->associatedEnum()) {             return tdn->associatedEnum()->idForNode();         }         else {             str = "typedef-" + name();         }         break;     case Node::Function:         func = static_cast<const FunctionNode*>(this);         if (func->associatedProperty()) {             return func->associatedProperty()->idForNode();         }         else {             if (func->name().startsWith("operator")) {                 str.clear();
comment|/*                   The test below should probably apply to all                   functions, but for now, overloaded operators                   are the only ones that produce duplicate id                   attributes in the DITA XML files.                  */
end_comment
begin_endif
unit|if (relatesTo_)                     str = "nonmember-";                 QString op = func->name().mid(8);                 if (!op.isEmpty()) {                     int i = 0;                     while (i<op.size()&& op.at(i) == ' ')                         ++i;                     if (i>0&& i<op.size()) {                         op = op.mid(i);                     }                     if (!op.isEmpty()) {                         i = 0;                         while (i< op.size()) {                             const QChar c = op.at(i);                             const uint u = c.unicode();                             if ((u>= 'a'&& u<= 'z') ||                                     (u>= 'A'&& u<= 'Z') ||                                     (u>= '0'&& u<= '9'))                                 break;                             ++i;                         }                         str += "operator-";                         if (i>0) {                             QString tail = op.mid(i);                             op = op.left(i);                             if (operators_.contains(op)) {                                 str += operators_.value(op);                                 if (!tail.isEmpty())                                     str += QLatin1Char('-') + tail;                             }                             else                                 qDebug()<< "qdoc internal error: Operator missing from operators_ map:"<< op;                         }                         else {                             str += op;                         }                     }                 }             }             else if (parent_) {                 if (parent_->isClass())                     str = "class-member-" + func->name();                 else if (parent_->isNamespace())                     str = "namespace-member-" + func->name();                 else if (parent_->isQmlType())                     str = "qml-method-" + parent_->name().toLower() + "-" + func->name();                 else if (parent_->isJsType())                     str = "js-method-" + parent_->name().toLower() + "-" + func->name();                 else if (parent_->type() == Document) {                     qDebug()<< "qdoc internal error: Node subtype not handled:"<< parent_->docSubtype()<< func->name();                 }                 else                     qDebug()<< "qdoc internal error: Node type not handled:"<< parent_->type()<< func->name();              }             if (func->overloadNumber() != 0)                 str += QLatin1Char('-') + QString::number(func->overloadNumber());         }         break;     case Node::QmlType:         if (genus() == QML)             str = "qml-class-" + name();         else             str = "js-type-" + name();         break;     case Node::QmlBasicType:         if (genus() == QML)             str = "qml-basic-type-" + name();         else             str = "js-basic-type-" + name();         break;     case Node::Document:         {             switch (docSubtype()) {             case Node::Page:             case Node::HeaderFile:                 str = title();                 if (str.isEmpty()) {                     str = name();                     if (str.endsWith(".html"))                         str.remove(str.size()-5,5);                 }                 str.replace(QLatin1Char('/'), QLatin1Char('-'));                 break;             case Node::File:                 str = name();                 str.replace(QLatin1Char('/'), QLatin1Char('-'));                 break;             case Node::Example:                 str = name();                 str.replace(QLatin1Char('/'), QLatin1Char('-'));                 break;             default:                 qDebug()<< "ERROR: A case was not handled in Node::idForNode():"<< "docSubtype():"<< docSubtype()<< "type():"<< type();                 break;             }         }         break;     case Node::Group:     case Node::Module:         str = title();         if (str.isEmpty()) {             str = name();             if (str.endsWith(".html"))                 str.remove(str.size()-5,5);         }         str.replace(QLatin1Char('/'), QLatin1Char('-'));         break;     case Node::QmlModule:         if (genus() == QML)             str = "qml-module-" + name();         else             str = "js-module-" + name();         break;     case Node::QmlProperty:         if (genus() == QML)             str = "qml-";         else             str = "js-";         if (isAttached())             str += "attached-property-" + name();         else             str += "property-" + name();         break;     case Node::QmlPropertyGroup:         {             Node* n = const_cast<Node*>(this);             if (genus() == QML)                 str = "qml-propertygroup-" + n->name();             else                 str = "js-propertygroup-" + n->name();         }         break;     case Node::Property:         str = "property-" + name();         break;     case Node::QmlSignal:         if (genus() == QML)             str = "qml-signal-" + name();         else             str = "js-signal-" + name();         break;     case Node::QmlSignalHandler:         if (genus() == QML)             str = "qml-signal-handler-" + name();         else             str = "js-signal-handler-" + name();         break;     case Node::QmlMethod:         func = static_cast<const FunctionNode*>(this);         if (genus() == QML)             str = "qml-method-";         else             str = "js-method-";         str += parent_->name().toLower() + "-" + func->name();         if (func->overloadNumber() != 0)             str += QLatin1Char('-') + QString::number(func->overloadNumber());         break;     case Node::Variable:         str = "var-" + name();         break;     default:         qDebug()<< "ERROR: A case was not handled in Node::idForNode():"<< "type():"<< type()<< "docSubtype():"<< docSubtype();         break;     }     if (str.isEmpty()) {         qDebug()<< "ERROR: A link text was empty in Node::idForNode():"<< "type():"<< type()<< "docSubtype():"<< docSubtype()<< "name():"<< name()<< "title():"<< title();     }     else {         str = cleanId(str);     }     return str; }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Prints the inner node's list of children.   For debugging only.  */
end_comment
begin_function
DECL|function|printChildren
name|void
name|Aggregate
operator|::
name|printChildren
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|qDebug
argument_list|()
operator|<<
name|title
operator|<<
name|name
argument_list|()
operator|<<
name|children_
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|children_
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"  CHILD:"
operator|<<
name|n
operator|->
name|name
argument_list|()
operator|<<
name|n
operator|->
name|nodeTypeString
argument_list|()
operator|<<
name|n
operator|->
name|nodeSubtypeString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the collection node's member list is   not empty.  */
end_comment
begin_function
DECL|function|hasMembers
name|bool
name|CollectionNode
operator|::
name|hasMembers
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Appends \a node to the collection node's member list, if   and only if it isn't already in the member list.  */
end_comment
begin_function
DECL|function|addMember
name|void
name|CollectionNode
operator|::
name|addMember
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|members_
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
name|members_
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if this collection node contains at least   one namespace node.  */
end_comment
begin_function
DECL|function|hasNamespaces
name|bool
name|CollectionNode
operator|::
name|hasNamespaces
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if this collection node contains at least   one class node.  */
end_comment
begin_function
DECL|function|hasClasses
name|bool
name|CollectionNode
operator|::
name|hasClasses
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|cbegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|cend
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isClass
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Loads \a out with all this collection node's members that   are namespace nodes.  */
end_comment
begin_function
DECL|function|getMemberNamespaces
name|void
name|CollectionNode
operator|::
name|getMemberNamespaces
parameter_list|(
name|NodeMap
modifier|&
name|out
parameter_list|)
block|{
name|out
operator|.
name|clear
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|cbegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|cend
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
name|out
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Loads \a out with all this collection node's members that   are class nodes.  */
end_comment
begin_function
DECL|function|getMemberClasses
name|void
name|CollectionNode
operator|::
name|getMemberClasses
parameter_list|(
name|NodeMap
modifier|&
name|out
parameter_list|)
specifier|const
block|{
name|out
operator|.
name|clear
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|cbegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|cend
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isClass
argument_list|()
condition|)
name|out
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Prints the collection node's list of members.   For debugging only.  */
end_comment
begin_function
DECL|function|printMembers
name|void
name|CollectionNode
operator|::
name|printMembers
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|qDebug
argument_list|()
operator|<<
name|title
operator|<<
name|name
argument_list|()
operator|<<
name|members_
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|members_
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|members_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|members_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"  MEMBER:"
operator|<<
name|n
operator|->
name|name
argument_list|()
operator|<<
name|n
operator|->
name|nodeTypeString
argument_list|()
operator|<<
name|n
operator|->
name|nodeSubtypeString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Sets the document node's \a title. This is used for the page title.  */
end_comment
begin_function
DECL|function|setTitle
name|void
name|CollectionNode
operator|::
name|setTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|title_
operator|=
name|title
expr_stmt|;
name|parent
argument_list|()
operator|->
name|addChild
argument_list|(
name|this
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function splits \a arg on the blank character to get a   logical module name and version number. If the version number   is present, it spilts the version number on the '.' character   to get a major version number and a minor vrsion number. If   the version number is present, both the major and minor version   numbers should be there, but the minor version number is not   absolutely necessary.  */
end_comment
begin_function
DECL|function|setLogicalModuleInfo
name|void
name|CollectionNode
operator|::
name|setLogicalModuleInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
name|QStringList
name|blankSplit
init|=
name|arg
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|logicalModuleName_
operator|=
name|blankSplit
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QStringList
name|dotSplit
init|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|logicalModuleVersionMajor_
operator|=
name|dotSplit
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dotSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|logicalModuleVersionMinor_
operator|=
name|dotSplit
index|[
literal|1
index|]
expr_stmt|;
else|else
name|logicalModuleVersionMinor_
operator|=
literal|"0"
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   This function accepts the logical module \a info as a string   list. If the logical module info contains the version number,   it spilts the version number on the '.' character to get the   major and minor vrsion numbers. Both major and minor version   numbers should be provided, but the minor version number is   not strictly necessary.  */
end_comment
begin_function
DECL|function|setLogicalModuleInfo
name|void
name|CollectionNode
operator|::
name|setLogicalModuleInfo
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|info
parameter_list|)
block|{
name|logicalModuleName_
operator|=
name|info
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QStringList
name|dotSplit
init|=
name|info
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|logicalModuleVersionMajor_
operator|=
name|dotSplit
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dotSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|logicalModuleVersionMinor_
operator|=
name|dotSplit
index|[
literal|1
index|]
expr_stmt|;
else|else
name|logicalModuleVersionMinor_
operator|=
literal|"0"
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
