begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"codemarker.h"
end_include
begin_include
include|#
directive|include
file|"codeparser.h"
end_include
begin_include
include|#
directive|include
file|<quuid.h>
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|member|propertyGroupCount_
name|int
name|Node
operator|::
name|propertyGroupCount_
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|exampleNodeMap
name|ExampleNodeMap
name|ExampleNode
operator|::
name|exampleNodeMap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|operators_
name|QStringMap
name|Node
operator|::
name|operators_
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Increment the number of property groups seen in the current   file, and return the new value.  */
end_comment
begin_function
DECL|function|incPropertyGroupCount
name|int
name|Node
operator|::
name|incPropertyGroupCount
parameter_list|()
block|{
return|return
operator|++
name|propertyGroupCount_
return|;
block|}
end_function
begin_comment
comment|/*!   Reset the number of property groups seen in the current file   to 0, because we are starting a new file.  */
end_comment
begin_function
DECL|function|clearPropertyGroupCount
name|void
name|Node
operator|::
name|clearPropertyGroupCount
parameter_list|()
block|{
name|propertyGroupCount_
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class Node   \brief The Node class is a node in the Tree.    A Node represents a class or function or something else   from the source code..  */
end_comment
begin_comment
comment|/*!   When this Node is destroyed, if it has a parent Node, it   removes itself from the parent node's child list.  */
end_comment
begin_destructor
DECL|function|~Node
name|Node
operator|::
name|~
name|Node
parameter_list|()
block|{
if|if
condition|(
name|parent_
condition|)
name|parent_
operator|->
name|removeChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|relatesTo_
condition|)
name|relatesTo_
operator|->
name|removeRelated
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Returns this node's name member. Appends "()" to the returned   name, if this node is a function node.  */
end_comment
begin_function
DECL|function|plainName
name|QString
name|Node
operator|::
name|plainName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Function
condition|)
return|return
name|name_
operator|+
name|QLatin1String
argument_list|(
literal|"()"
argument_list|)
return|;
return|return
name|name_
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs and returns the node's fully qualified name by   recursively ascending the parent links and prepending each   parent name + "::". Breaks out when the parent pointer is   \a relative. Almost all calls to this function pass 0 for   \a relative.  */
end_comment
begin_function
DECL|function|plainFullName
name|QString
name|Node
operator|::
name|plainFullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"global"
argument_list|)
return|;
name|QString
name|fullName
decl_stmt|;
specifier|const
name|Node
modifier|*
name|node
init|=
name|this
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|fullName
operator|.
name|prepend
argument_list|(
name|node
operator|->
name|plainName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
argument_list|()
operator|==
name|relative
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
operator|||
name|node
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|fullName
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
name|fullName
return|;
block|}
end_function
begin_comment
comment|/*!   Constructs and returns this node's full name. The \a relative   node is either null or is a collision node.  */
end_comment
begin_function
DECL|function|fullName
name|QString
name|Node
operator|::
name|fullName
parameter_list|(
specifier|const
name|Node
modifier|*
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
specifier|const
name|DocNode
modifier|*
name|dn
init|=
cast|static_cast
argument_list|<
specifier|const
name|DocNode
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// Only print modulename::type on collision pages.
if|if
condition|(
operator|!
name|dn
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|relative
operator|!=
literal|0
operator|&&
name|relative
operator|->
name|isCollisionNode
argument_list|()
condition|)
return|return
name|dn
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|+
literal|"::"
operator|+
name|dn
operator|->
name|title
argument_list|()
return|;
return|return
name|dn
operator|->
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
condition|)
block|{
specifier|const
name|ClassNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
specifier|const
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cn
operator|->
name|serviceName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|cn
operator|->
name|serviceName
argument_list|()
return|;
block|}
return|return
name|plainFullName
argument_list|(
name|relative
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Sets this Node's Doc to \a doc. If \a replace is false and   this Node already has a Doc, a warning is reported that the   Doc is being overridden, and it reports where the previous   Doc was found. If \a replace is true, the Doc is replaced   silently.  */
end_comment
begin_function
DECL|function|setDoc
name|void
name|Node
operator|::
name|setDoc
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
name|bool
name|replace
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|replace
condition|)
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"Overrides a previous doc"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"(The previous doc is here)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|doc
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Construct a node with the given \a type and having the   given \a parent and \a name. The new node is added to the   parent's child list.  */
end_comment
begin_constructor
DECL|function|Node
name|Node
operator|::
name|Node
parameter_list|(
name|Type
name|type
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|nodeType_
argument_list|(
name|type
argument_list|)
member_init_list|,
name|access_
argument_list|(
name|Public
argument_list|)
member_init_list|,
name|safeness_
argument_list|(
name|UnspecifiedSafeness
argument_list|)
member_init_list|,
name|pageType_
argument_list|(
name|NoPageType
argument_list|)
member_init_list|,
name|status_
argument_list|(
name|Commendable
argument_list|)
member_init_list|,
name|indexNodeFlag_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|seen_
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|parent_
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|relatesTo_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|name_
argument_list|(
name|name
argument_list|)
block|{
if|if
condition|(
name|parent_
condition|)
name|parent_
operator|->
name|addChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|outSubDir_
operator|=
name|CodeParser
operator|::
name|currentOutputSubdirectory
argument_list|()
expr_stmt|;
if|if
condition|(
name|operators_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|operators_
operator|.
name|insert
argument_list|(
literal|"++"
argument_list|,
literal|"inc"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"--"
argument_list|,
literal|"dec"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"=="
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"!="
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<<"
argument_list|,
literal|"lt-lt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">>"
argument_list|,
literal|"gt-gt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"+="
argument_list|,
literal|"plus-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"-="
argument_list|,
literal|"minus-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"*="
argument_list|,
literal|"mult-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"/="
argument_list|,
literal|"div-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"%="
argument_list|,
literal|"mod-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&="
argument_list|,
literal|"bitwise-and-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"|="
argument_list|,
literal|"bitwise-or-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"^="
argument_list|,
literal|"bitwise-xor-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<<="
argument_list|,
literal|"bitwise-left-shift-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">>="
argument_list|,
literal|"bitwise-right-shift-assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"||"
argument_list|,
literal|"logical-or"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&&"
argument_list|,
literal|"logical-and"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"()"
argument_list|,
literal|"call"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"[]"
argument_list|,
literal|"subscript"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"->"
argument_list|,
literal|"pointer"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"->*"
argument_list|,
literal|"pointer-star"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"+"
argument_list|,
literal|"plus"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"-"
argument_list|,
literal|"minus"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"*"
argument_list|,
literal|"mult"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"/"
argument_list|,
literal|"div"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"%"
argument_list|,
literal|"mod"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"|"
argument_list|,
literal|"bitwise-or"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"&"
argument_list|,
literal|"bitwise-and"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"^"
argument_list|,
literal|"bitwise-xor"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"!"
argument_list|,
literal|"not"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"~"
argument_list|,
literal|"bitwise-not"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<="
argument_list|,
literal|"lt-eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">="
argument_list|,
literal|"gt-eq"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"<"
argument_list|,
literal|"lt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|">"
argument_list|,
literal|"gt"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"="
argument_list|,
literal|"assign"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|","
argument_list|,
literal|"comma"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"delete[]"
argument_list|,
literal|"delete-array"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"delete"
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"new[]"
argument_list|,
literal|"new-array"
argument_list|)
expr_stmt|;
name|operators_
operator|.
name|insert
argument_list|(
literal|"new"
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Returns the node's URL.  */
end_comment
begin_function
DECL|function|url
name|QString
name|Node
operator|::
name|url
parameter_list|()
specifier|const
block|{
return|return
name|url_
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the node's URL to \a url  */
end_comment
begin_function
DECL|function|setUrl
name|void
name|Node
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
block|{
name|url_
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns this node's page type as a string, for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|pageTypeString
name|QString
name|Node
operator|::
name|pageTypeString
parameter_list|()
specifier|const
block|{
return|return
name|pageTypeString
argument_list|(
name|pageType_
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the page type \a t as a string, for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|pageTypeString
name|QString
name|Node
operator|::
name|pageTypeString
parameter_list|(
name|unsigned
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|PageType
operator|)
name|t
condition|)
block|{
case|case
name|Node
operator|::
name|ApiPage
case|:
return|return
literal|"api"
return|;
case|case
name|Node
operator|::
name|ArticlePage
case|:
return|return
literal|"article"
return|;
case|case
name|Node
operator|::
name|ExamplePage
case|:
return|return
literal|"example"
return|;
case|case
name|Node
operator|::
name|HowToPage
case|:
return|return
literal|"howto"
return|;
case|case
name|Node
operator|::
name|OverviewPage
case|:
return|return
literal|"overview"
return|;
case|case
name|Node
operator|::
name|TutorialPage
case|:
return|return
literal|"tutorial"
return|;
case|case
name|Node
operator|::
name|FAQPage
case|:
return|return
literal|"faq"
return|;
case|case
name|Node
operator|::
name|DitaMapPage
case|:
return|return
literal|"ditamap"
return|;
default|default:
return|return
literal|"article"
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns this node's type as a string for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|nodeTypeString
name|QString
name|Node
operator|::
name|nodeTypeString
parameter_list|()
specifier|const
block|{
return|return
name|nodeTypeString
argument_list|(
name|type
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the node type \a t as a string for use as an   attribute value in XML or HTML.  */
end_comment
begin_function
DECL|function|nodeTypeString
name|QString
name|Node
operator|::
name|nodeTypeString
parameter_list|(
name|unsigned
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|Type
operator|)
name|t
condition|)
block|{
case|case
name|Namespace
case|:
return|return
literal|"namespace"
return|;
case|case
name|Class
case|:
return|return
literal|"class"
return|;
case|case
name|Document
case|:
return|return
literal|"document"
return|;
case|case
name|Enum
case|:
return|return
literal|"enum"
return|;
case|case
name|Typedef
case|:
return|return
literal|"typedef"
return|;
case|case
name|Function
case|:
return|return
literal|"function"
return|;
case|case
name|Property
case|:
return|return
literal|"property"
return|;
case|case
name|Variable
case|:
return|return
literal|"variable"
return|;
case|case
name|QmlProperty
case|:
return|return
literal|"QML property"
return|;
case|case
name|QmlSignal
case|:
return|return
literal|"QML signal"
return|;
case|case
name|QmlSignalHandler
case|:
return|return
literal|"QML signal handler"
return|;
case|case
name|QmlMethod
case|:
return|return
literal|"QML method"
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns this node's subtype as a string for use as an   attribute value in XML or HTML. This is only useful   in the case where the node type is Document.  */
end_comment
begin_function
DECL|function|nodeSubtypeString
name|QString
name|Node
operator|::
name|nodeSubtypeString
parameter_list|()
specifier|const
block|{
return|return
name|nodeSubtypeString
argument_list|(
name|subType
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the node subtype \a t as a string for use as an   attribute value in XML or HTML. This is only useful   in the case where the node type is Document.  */
end_comment
begin_function
DECL|function|nodeSubtypeString
name|QString
name|Node
operator|::
name|nodeSubtypeString
parameter_list|(
name|unsigned
name|t
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|SubType
operator|)
name|t
condition|)
block|{
case|case
name|Example
case|:
return|return
literal|"example"
return|;
case|case
name|HeaderFile
case|:
return|return
literal|"header file"
return|;
case|case
name|File
case|:
return|return
literal|"file"
return|;
case|case
name|Image
case|:
return|return
literal|"image"
return|;
case|case
name|Group
case|:
return|return
literal|"group"
return|;
case|case
name|Module
case|:
return|return
literal|"module"
return|;
case|case
name|Page
case|:
return|return
literal|"page"
return|;
case|case
name|ExternalPage
case|:
return|return
literal|"external page"
return|;
case|case
name|QmlClass
case|:
return|return
literal|"QML type"
return|;
case|case
name|QmlPropertyGroup
case|:
return|return
literal|"QML property group"
return|;
case|case
name|QmlBasicType
case|:
return|return
literal|"QML basic type"
return|;
case|case
name|QmlModule
case|:
return|return
literal|"QML module"
return|;
case|case
name|DitaMap
case|:
return|return
literal|"ditamap"
return|;
case|case
name|Collision
case|:
return|return
literal|"collision"
return|;
case|case
name|NoSubType
case|:
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Set the page type according to the string \a t.  */
end_comment
begin_function
DECL|function|setPageType
name|void
name|Node
operator|::
name|setPageType
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|t
operator|==
literal|"API"
operator|)
operator|||
operator|(
name|t
operator|==
literal|"api"
operator|)
condition|)
name|pageType_
operator|=
name|ApiPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"howto"
condition|)
name|pageType_
operator|=
name|HowToPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"overview"
condition|)
name|pageType_
operator|=
name|OverviewPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"tutorial"
condition|)
name|pageType_
operator|=
name|TutorialPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"howto"
condition|)
name|pageType_
operator|=
name|HowToPage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"article"
condition|)
name|pageType_
operator|=
name|ArticlePage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"example"
condition|)
name|pageType_
operator|=
name|ExamplePage
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|"ditamap"
condition|)
name|pageType_
operator|=
name|DitaMapPage
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Converts the boolean value \a b to an enum representation   of the boolean type, which includes an enum value for the   \e {default value} of the item, i.e. true, false, or default.  */
end_comment
begin_function
DECL|function|toFlagValue
name|Node
operator|::
name|FlagValue
name|Node
operator|::
name|toFlagValue
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
return|return
name|b
condition|?
name|FlagValueTrue
else|:
name|FlagValueFalse
return|;
block|}
end_function
begin_comment
comment|/*!   Converts the enum \a fv back to a boolean value.   If \a fv is neither the true enum value nor the   false enum value, the boolean value returned is   \a defaultValue.    Note that runtimeDesignabilityFunction() should be called   first. If that function returns the name of a function, it   means the function must be called at runtime to determine   whether the property is Designable.  */
end_comment
begin_function
DECL|function|fromFlagValue
name|bool
name|Node
operator|::
name|fromFlagValue
parameter_list|(
name|FlagValue
name|fv
parameter_list|,
name|bool
name|defaultValue
parameter_list|)
block|{
switch|switch
condition|(
name|fv
condition|)
block|{
case|case
name|FlagValueTrue
case|:
return|return
literal|true
return|;
case|case
name|FlagValueFalse
case|:
return|return
literal|false
return|;
default|default:
return|return
name|defaultValue
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Sets the pointer to the node that this node relates to.  */
end_comment
begin_function
DECL|function|setRelates
name|void
name|Node
operator|::
name|setRelates
parameter_list|(
name|InnerNode
modifier|*
name|pseudoParent
parameter_list|)
block|{
if|if
condition|(
name|relatesTo_
condition|)
block|{
name|relatesTo_
operator|->
name|removeRelated
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|relatesTo_
operator|=
name|pseudoParent
expr_stmt|;
name|pseudoParent
operator|->
name|related_
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function creates a pair that describes a link.   The pair is composed from \a link and \a desc. The   \a linkType is the map index the pair is filed under.  */
end_comment
begin_function
DECL|function|setLink
name|void
name|Node
operator|::
name|setLink
parameter_list|(
name|LinkType
name|linkType
parameter_list|,
specifier|const
name|QString
modifier|&
name|link
parameter_list|,
specifier|const
name|QString
modifier|&
name|desc
parameter_list|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|linkPair
decl_stmt|;
name|linkPair
operator|.
name|first
operator|=
name|link
expr_stmt|;
name|linkPair
operator|.
name|second
operator|=
name|desc
expr_stmt|;
name|linkMap_
index|[
name|linkType
index|]
operator|=
name|linkPair
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the information about the project and version a node was introduced     in. The string is simplified, removing excess whitespace before being     stored. */
end_comment
begin_function
DECL|function|setSince
name|void
name|Node
operator|::
name|setSince
parameter_list|(
specifier|const
name|QString
modifier|&
name|since
parameter_list|)
block|{
name|since_
operator|=
name|since
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns a string representing the access specifier.  */
end_comment
begin_function
DECL|function|accessString
name|QString
name|Node
operator|::
name|accessString
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|access_
condition|)
block|{
case|case
name|Protected
case|:
return|return
literal|"protected"
return|;
case|case
name|Private
case|:
return|return
literal|"private"
return|;
case|case
name|Public
case|:
default|default:
break|break;
block|}
return|return
literal|"public"
return|;
block|}
end_function
begin_comment
comment|/*!   Extract a class name from the type \a string and return it.  */
end_comment
begin_function
DECL|function|extractClassName
name|QString
name|Node
operator|::
name|extractClassName
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|string
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|string
operator|.
name|size
argument_list|()
condition|)
name|ch
operator|=
name|string
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QChar
name|lower
init|=
name|ch
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lower
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|lower
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
operator|)
operator|||
name|ch
operator|.
name|digitValue
argument_list|()
operator|>=
literal|0
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|result
operator|+=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|QLatin1String
argument_list|(
literal|"const"
argument_list|)
condition|)
return|return
name|result
return|;
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a string representing the access specifier.  */
end_comment
begin_function
DECL|function|accessString
name|QString
name|RelatedClass
operator|::
name|accessString
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|access
condition|)
block|{
case|case
name|Node
operator|::
name|Protected
case|:
return|return
literal|"protected"
return|;
case|case
name|Node
operator|::
name|Private
case|:
return|return
literal|"private"
return|;
case|case
name|Node
operator|::
name|Public
case|:
default|default:
break|break;
block|}
return|return
literal|"public"
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the inheritance status.  */
end_comment
begin_function
DECL|function|inheritedStatus
name|Node
operator|::
name|Status
name|Node
operator|::
name|inheritedStatus
parameter_list|()
specifier|const
block|{
name|Status
name|parentStatus
init|=
name|Commendable
decl_stmt|;
if|if
condition|(
name|parent_
condition|)
name|parentStatus
operator|=
name|parent_
operator|->
name|inheritedStatus
argument_list|()
expr_stmt|;
return|return
operator|(
name|Status
operator|)
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|status_
argument_list|,
operator|(
name|int
operator|)
name|parentStatus
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the thread safeness value for whatever this node   represents. But if this node has a parent and the thread   safeness value of the parent is the same as the thread   safeness value of this node, what is returned is the   value \c{UnspecifiedSafeness}. Why?  */
end_comment
begin_function
DECL|function|threadSafeness
name|Node
operator|::
name|ThreadSafeness
name|Node
operator|::
name|threadSafeness
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|parent_
operator|&&
name|safeness_
operator|==
name|parent_
operator|->
name|inheritedThreadSafeness
argument_list|()
condition|)
return|return
name|UnspecifiedSafeness
return|;
return|return
name|safeness_
return|;
block|}
end_function
begin_comment
comment|/*!   If this node has a parent, the parent's thread safeness   value is returned. Otherwise, this node's thread safeness   value is returned. Why?  */
end_comment
begin_function
DECL|function|inheritedThreadSafeness
name|Node
operator|::
name|ThreadSafeness
name|Node
operator|::
name|inheritedThreadSafeness
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|parent_
operator|&&
name|safeness_
operator|==
name|UnspecifiedSafeness
condition|)
return|return
name|parent_
operator|->
name|inheritedThreadSafeness
argument_list|()
return|;
return|return
name|safeness_
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*!   Returns the sanitized file name without the path.   If the file is an html file, the html suffix   is removed. Why?  */
end_comment
begin_endif
unit|QString Node::fileBase() const {     QString base = name();     if (base.endsWith(".html"))         base.chop(5);     base.replace(QRegExp("[^A-Za-z0-9]+"), " ");     base = base.trimmed();     base.replace(QLatin1Char(' '), QLatin1Char('-'));     return base.toLower(); }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Returns this node's Universally Unique IDentifier as a   QString. Creates the UUID first, if it has not been created.  */
end_comment
begin_function
DECL|function|guid
name|QString
name|Node
operator|::
name|guid
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|uuid_
operator|.
name|isEmpty
argument_list|()
condition|)
name|uuid_
operator|=
name|idForNode
argument_list|()
expr_stmt|;
return|return
name|uuid_
return|;
block|}
end_function
begin_comment
comment|/*!   If this node is a QML class node, return a pointer to it.   If it is a child of a QML class node, return a pointer to   the QML class node. Otherwise, return 0;  */
end_comment
begin_function
DECL|function|qmlClassNode
name|QmlClassNode
modifier|*
name|Node
operator|::
name|qmlClassNode
parameter_list|()
block|{
if|if
condition|(
name|isQmlNode
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|this
decl_stmt|;
while|while
condition|(
name|n
operator|&&
name|n
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlClass
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
return|return
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   If this node is a QML node, find its QML class node,   and return a pointer to the C++ class node from the   QML class node. That pointer will be null if the QML   class node is a component. It will be non-null if   the QML class node is a QML element.  */
end_comment
begin_function
DECL|function|declarativeCppNode
name|ClassNode
modifier|*
name|Node
operator|::
name|declarativeCppNode
parameter_list|()
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qmlClassNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
return|return
name|qcn
operator|->
name|classNode
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the node's status is Internal, or if its   parent is a class with internal status.  */
end_comment
begin_function
DECL|function|isInternal
name|bool
name|Node
operator|::
name|isInternal
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|parent
argument_list|()
operator|&&
name|parent
argument_list|()
operator|->
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|relates
argument_list|()
operator|&&
name|relates
argument_list|()
operator|->
name|status
argument_list|()
operator|==
name|Internal
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \class InnerNode  */
end_comment
begin_comment
comment|/*!   The inner node destructor deletes the children and removes   this node from its related nodes.  */
end_comment
begin_destructor
DECL|function|~InnerNode
name|InnerNode
operator|::
name|~
name|InnerNode
parameter_list|()
block|{
name|deleteChildren
argument_list|()
expr_stmt|;
name|removeFromRelated
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Returns true if this node's members coolection is not empty.  */
end_comment
begin_function
DECL|function|hasMembers
name|bool
name|InnerNode
operator|::
name|hasMembers
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this node's members collection contains at   least one namespace node.  */
end_comment
begin_function
DECL|function|hasNamespaces
name|bool
name|InnerNode
operator|::
name|hasNamespaces
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this node's members collection contains at   least one class node.  */
end_comment
begin_function
DECL|function|hasClasses
name|bool
name|InnerNode
operator|::
name|hasClasses
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|members_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isClass
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Loads \a out with all this node's member nodes that are namespace nodes.  */
end_comment
begin_function
DECL|function|getMemberNamespaces
name|void
name|InnerNode
operator|::
name|getMemberNamespaces
parameter_list|(
name|NodeMap
modifier|&
name|out
parameter_list|)
block|{
name|out
operator|.
name|clear
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isNamespace
argument_list|()
condition|)
name|out
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Loads \a out with all this node's member nodes that are class nodes.  */
end_comment
begin_function
DECL|function|getMemberClasses
name|void
name|InnerNode
operator|::
name|getMemberClasses
parameter_list|(
name|NodeMap
modifier|&
name|out
parameter_list|)
block|{
name|out
operator|.
name|clear
argument_list|()
expr_stmt|;
name|NodeList
operator|::
name|const_iterator
name|i
init|=
name|members_
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|members_
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|isClass
argument_list|()
condition|)
name|out
operator|.
name|insert
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|name
argument_list|()
argument_list|,
operator|(
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the node in this node's children that has the   given \a name. If this node is a QML class node, be   sure to also look in the children of its property   group nodes. Return the matching node or 0.  */
end_comment
begin_function
DECL|function|findChildNodeByName
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Node
modifier|*
name|node
init|=
name|childMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|QmlPropertyGroup
condition|)
return|return
name|node
return|;
if|if
condition|(
operator|(
name|type
argument_list|()
operator|==
name|Document
operator|)
operator|&&
operator|(
name|subType
argument_list|()
operator|==
name|QmlClass
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|QmlPropertyGroup
condition|)
block|{
name|node
operator|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
block|}
block|}
return|return
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findNodes
name|void
name|InnerNode
operator|::
name|findNodes
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
modifier|&
name|n
parameter_list|)
block|{
name|n
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Node
modifier|*
name|node
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|nodes
init|=
name|childMap
operator|.
name|values
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/*<sigh> If this node's child map contains no nodes named       name, then if this node is a QML class, seach each of its       property group nodes for a node named name. If a match is       found, append it to the output list and return immediately.      */
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|type
argument_list|()
operator|==
name|Document
operator|)
operator|&&
operator|(
name|subType
argument_list|()
operator|==
name|QmlClass
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|QmlPropertyGroup
condition|)
block|{
name|node
operator|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|n
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/*           If the childMap does contain one or more nodes named           name, traverse the list of matching nodes. Append each           matching node that is not a property group node to the           output list. Search each property group node for a node           named name and append that node to the output list.           This is overkill, I think, but should produce a useful           list.          */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|nodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|QmlPropertyGroup
condition|)
name|n
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|n
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|n
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|node
operator|=
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|n
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Find the node in this node's children that has the given \a name. If   this node is a QML class node, be sure to also look in the children   of its property group nodes. Return the matching node or 0. This is   not a recearsive search.    If \a qml is true, only match a node for which node->isQmlNode()   returns true. If \a qml is false, only match a node for which   node->isQmlNode() returns false.  */
end_comment
begin_function
DECL|function|findChildNodeByName
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|qml
parameter_list|)
block|{
name|QList
argument_list|<
name|Node
modifier|*
argument_list|>
name|nodes
init|=
name|childMap
operator|.
name|values
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|node
init|=
name|nodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qml
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|isQmlNode
argument_list|()
condition|)
return|return
name|node
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|isQmlNode
argument_list|()
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|!=
name|QmlPropertyGroup
operator|)
condition|)
return|return
name|node
return|;
block|}
block|}
if|if
condition|(
name|qml
operator|&&
operator|(
name|type
argument_list|()
operator|==
name|Document
operator|)
operator|&&
operator|(
name|subType
argument_list|()
operator|==
name|QmlClass
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|node
init|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|QmlPropertyGroup
condition|)
block|{
name|node
operator|=
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
return|return
name|node
return|;
block|}
block|}
block|}
return|return
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   This function is like findChildNodeByName(), but if a node   with the specified \a name is found but it is not of the   specified \a type, 0 is returned.    This function is not recursive and therefore can't handle   collisions. If it finds a collision node named \a name, it   will return that node. But it might not find the collision   node because it looks up \a name in the child map, not the   list.  */
end_comment
begin_function
DECL|function|findChildNodeByNameAndType
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByNameAndType
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|Function
condition|)
return|return
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
else|else
block|{
name|Node
modifier|*
name|node
init|=
name|childMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
return|return
name|node
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Find a function node that is a child of this nose, such   that the function node has the specified \a name.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|InnerNode
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the function node that is a child of this node, such   that the function has the same name and signature as the   \a clone node.  */
end_comment
begin_function
DECL|function|findFunctionNode
name|FunctionNode
modifier|*
name|InnerNode
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|c
init|=
name|primaryFunctionMap
operator|.
name|constFind
argument_list|(
name|clone
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|primaryFunctionMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|isSameSignature
argument_list|(
name|clone
argument_list|,
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|c
return|;
block|}
elseif|else
if|if
condition|(
name|secondaryFunctionMap
operator|.
name|contains
argument_list|(
name|clone
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|clone
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|secs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|secs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|isSameSignature
argument_list|(
name|clone
argument_list|,
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
return|;
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of keys from the primary function map.  */
end_comment
begin_function
DECL|function|primaryKeys
name|QStringList
name|InnerNode
operator|::
name|primaryKeys
parameter_list|()
block|{
name|QStringList
name|t
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|iterator
name|i
init|=
name|primaryFunctionMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|primaryFunctionMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of keys from the secondary function map.  */
end_comment
begin_function
DECL|function|secondaryKeys
name|QStringList
name|InnerNode
operator|::
name|secondaryKeys
parameter_list|()
block|{
name|QStringList
name|t
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|NodeList
argument_list|>
operator|::
name|iterator
name|i
init|=
name|secondaryFunctionMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|secondaryFunctionMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|setOverload
name|void
name|InnerNode
operator|::
name|setOverload
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|func
parameter_list|,
name|bool
name|overlode
parameter_list|)
block|{
name|Node
modifier|*
name|node
init|=
operator|(
name|Node
operator|*
operator|)
name|func
decl_stmt|;
name|Node
modifier|*
modifier|&
name|primary
init|=
name|primaryFunctionMap
index|[
name|func
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|secondaryFunctionMap
operator|.
name|contains
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|func
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|overlode
condition|)
block|{
if|if
condition|(
name|primary
operator|==
name|node
condition|)
block|{
name|primary
operator|=
name|secs
operator|.
name|first
argument_list|()
expr_stmt|;
name|secs
operator|.
name|erase
argument_list|(
name|secs
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|secs
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|secs
operator|.
name|removeAll
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|secs
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|primary
operator|!=
name|node
condition|)
block|{
name|secs
operator|.
name|removeAll
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|secs
operator|.
name|prepend
argument_list|(
name|primary
argument_list|)
expr_stmt|;
name|primary
operator|=
name|node
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Mark all child nodes that have no documentation as having   private access and internal status. qdoc will then ignore   them for documentation purposes.    \note Exception: Name collision nodes are not marked   private/internal.  */
end_comment
begin_function
DECL|function|makeUndocumentedChildrenInternal
name|void
name|InnerNode
operator|::
name|makeUndocumentedChildrenInternal
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|doc
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|Collision
condition|)
block|{
name|child
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Private
argument_list|)
expr_stmt|;
name|child
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Internal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   In each child node that is a collision node,   clear the current child pointer.  */
end_comment
begin_function
DECL|function|clearCurrentChildPointers
name|void
name|InnerNode
operator|::
name|clearCurrentChildPointers
parameter_list|()
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Collision
condition|)
block|{
name|child
operator|->
name|clearCurrentChild
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|normalizeOverloads
name|void
name|InnerNode
operator|::
name|normalizeOverloads
parameter_list|()
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|p1
init|=
name|primaryFunctionMap
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|primaryFunctionMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|primaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|p1
decl_stmt|;
if|if
condition|(
name|secondaryFunctionMap
operator|.
name|contains
argument_list|(
name|primaryFunc
operator|->
name|name
argument_list|()
argument_list|)
operator|&&
operator|(
name|primaryFunc
operator|->
name|status
argument_list|()
operator|!=
name|Commendable
operator|||
name|primaryFunc
operator|->
name|access
argument_list|()
operator|==
name|Private
operator|)
condition|)
block|{
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|secs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|secs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|secondaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
decl_stmt|;
comment|// Any non-obsolete, non-compatibility, non-private functions
comment|// (i.e, visible functions) are preferable to the primary
comment|// function.
if|if
condition|(
name|secondaryFunc
operator|->
name|status
argument_list|()
operator|==
name|Commendable
operator|&&
name|secondaryFunc
operator|->
name|access
argument_list|()
operator|!=
name|Private
condition|)
block|{
operator|*
name|p1
operator|=
name|secondaryFunc
expr_stmt|;
name|int
name|index
init|=
name|secondaryFunctionMap
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
operator|.
name|indexOf
argument_list|(
name|secondaryFunc
argument_list|)
decl_stmt|;
name|secondaryFunctionMap
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|primaryFunc
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
block|}
block|}
operator|++
name|p1
expr_stmt|;
block|}
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|primaryFunctionMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|primaryFunctionMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|primaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|primaryFunc
operator|->
name|isOverload
argument_list|()
condition|)
name|primaryFunc
operator|->
name|ove
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|secondaryFunctionMap
operator|.
name|contains
argument_list|(
name|primaryFunc
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|primaryFunc
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|s
init|=
name|secs
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|secs
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|FunctionNode
modifier|*
name|secondaryFunc
init|=
operator|(
name|FunctionNode
operator|*
operator|)
operator|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|secondaryFunc
operator|->
name|isOverload
argument_list|()
condition|)
name|secondaryFunc
operator|->
name|ove
operator|=
literal|true
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
name|NodeList
operator|::
name|ConstIterator
name|c
init|=
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|->
name|isInnerNode
argument_list|()
condition|)
operator|(
operator|(
name|InnerNode
operator|*
operator|)
operator|*
name|c
operator|)
operator|->
name|normalizeOverloads
argument_list|()
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|removeFromRelated
name|void
name|InnerNode
operator|::
name|removeFromRelated
parameter_list|()
block|{
while|while
condition|(
operator|!
name|related_
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|related_
operator|.
name|takeFirst
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|p
operator|->
name|relates
argument_list|()
operator|==
name|this
condition|)
name|p
operator|->
name|clearRelated
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Deletes all this node's children.  */
end_comment
begin_function
DECL|function|deleteChildren
name|void
name|InnerNode
operator|::
name|deleteChildren
parameter_list|()
block|{
name|NodeList
name|childrenCopy
init|=
name|children_
decl_stmt|;
comment|// `children_` will be changed in ~Node()
name|qDeleteAll
argument_list|(
name|childrenCopy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool InnerNode::isInnerNode() const   Returns true because this is an inner node.  */
end_comment
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findChildNodeByName
specifier|const
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|InnerNode
modifier|*
name|that
init|=
operator|(
name|InnerNode
operator|*
operator|)
name|this
decl_stmt|;
return|return
name|that
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   If \a qml is true, only match a node for which node->isQmlNode()   returns true. If \a qml is false, only match a node for which   node->isQmlNode() returns false.  */
end_comment
begin_function
DECL|function|findChildNodeByName
specifier|const
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|qml
parameter_list|)
specifier|const
block|{
name|InnerNode
modifier|*
name|that
init|=
operator|(
name|InnerNode
operator|*
operator|)
name|this
decl_stmt|;
return|return
name|that
operator|->
name|findChildNodeByName
argument_list|(
name|name
argument_list|,
name|qml
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Searches this node's children for a child named \a name   with the specified node \a type.  */
end_comment
begin_function
DECL|function|findChildNodeByNameAndType
specifier|const
name|Node
modifier|*
name|InnerNode
operator|::
name|findChildNodeByNameAndType
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|Type
name|type
parameter_list|)
specifier|const
block|{
name|InnerNode
modifier|*
name|that
init|=
operator|(
name|InnerNode
operator|*
operator|)
name|this
decl_stmt|;
return|return
name|that
operator|->
name|findChildNodeByNameAndType
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find a function node that is a child of this nose, such   that the function node has the specified \a name. This   function calls the non-const version of itself.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|InnerNode
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|InnerNode
modifier|*
name|that
init|=
operator|(
name|InnerNode
operator|*
operator|)
name|this
decl_stmt|;
return|return
name|that
operator|->
name|findFunctionNode
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Find the function node that is a child of this node, such   that the function has the same name and signature as the   \a clone node. This function calls the non-const version.  */
end_comment
begin_function
DECL|function|findFunctionNode
specifier|const
name|FunctionNode
modifier|*
name|InnerNode
operator|::
name|findFunctionNode
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|clone
parameter_list|)
specifier|const
block|{
name|InnerNode
modifier|*
name|that
init|=
operator|(
name|InnerNode
operator|*
operator|)
name|this
decl_stmt|;
return|return
name|that
operator|->
name|findFunctionNode
argument_list|(
name|clone
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|findEnumNodeForValue
specifier|const
name|EnumNode
modifier|*
name|InnerNode
operator|::
name|findEnumNodeForValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|enumValue
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|Node
modifier|*
name|node
decl|,
name|enumChildren_
control|)
block|{
specifier|const
name|EnumNode
modifier|*
name|enume
init|=
cast|static_cast
argument_list|<
specifier|const
name|EnumNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|enume
operator|->
name|hasItem
argument_list|(
name|enumValue
argument_list|)
condition|)
return|return
name|enume
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returnds the sequence number of the function node \a func   in the list of overloaded functions for a class, such that   all the functions have the same name as the \a func.  */
end_comment
begin_function
DECL|function|overloadNumber
name|int
name|InnerNode
operator|::
name|overloadNumber
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|func
parameter_list|)
specifier|const
block|{
name|Node
modifier|*
name|node
init|=
operator|(
name|Node
operator|*
operator|)
name|func
decl_stmt|;
if|if
condition|(
name|primaryFunctionMap
index|[
name|func
operator|->
name|name
argument_list|()
index|]
operator|==
name|node
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|secondaryFunctionMap
index|[
name|func
operator|->
name|name
argument_list|()
index|]
operator|.
name|indexOf
argument_list|(
name|node
argument_list|)
operator|+
literal|2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns a node list containing all the member functions of   some class such that the functions overload the name \a funcName.  */
end_comment
begin_function
DECL|function|overloads
name|NodeList
name|InnerNode
operator|::
name|overloads
parameter_list|(
specifier|const
name|QString
modifier|&
name|funcName
parameter_list|)
specifier|const
block|{
name|NodeList
name|result
decl_stmt|;
name|Node
modifier|*
name|primary
init|=
name|primaryFunctionMap
operator|.
name|value
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
name|result
operator|<<
name|primary
expr_stmt|;
name|result
operator|+=
name|secondaryFunctionMap
index|[
name|funcName
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Construct an inner node (i.e., not a leaf node) of the   given \a type and having the given \a parent and \a name.  */
end_comment
begin_constructor
DECL|function|InnerNode
name|InnerNode
operator|::
name|InnerNode
parameter_list|(
name|Type
name|type
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Class
case|:
case|case
name|Namespace
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Appends an \a include file to the list of include files.  */
end_comment
begin_function
DECL|function|addInclude
name|void
name|InnerNode
operator|::
name|addInclude
parameter_list|(
specifier|const
name|QString
modifier|&
name|include
parameter_list|)
block|{
name|includes_
operator|.
name|append
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the list of include files to \a includes.  */
end_comment
begin_function
DECL|function|setIncludes
name|void
name|InnerNode
operator|::
name|setIncludes
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|includes
parameter_list|)
block|{
name|includes_
operator|=
name|includes
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   f1 is always the clone  */
end_comment
begin_function
DECL|function|isSameSignature
name|bool
name|InnerNode
operator|::
name|isSameSignature
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|f1
parameter_list|,
specifier|const
name|FunctionNode
modifier|*
name|f2
parameter_list|)
block|{
if|if
condition|(
name|f1
operator|->
name|parameters
argument_list|()
operator|.
name|count
argument_list|()
operator|!=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|f1
operator|->
name|isConst
argument_list|()
operator|!=
name|f2
operator|->
name|isConst
argument_list|()
condition|)
return|return
literal|false
return|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p1
init|=
name|f1
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p2
init|=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p2
operator|!=
name|f2
operator|->
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|)
operator|.
name|hasType
argument_list|()
operator|&&
operator|(
operator|*
name|p2
operator|)
operator|.
name|hasType
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|)
operator|.
name|rightType
argument_list|()
operator|!=
operator|(
operator|*
name|p2
operator|)
operator|.
name|rightType
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|t1
init|=
name|p1
operator|->
name|leftType
argument_list|()
decl_stmt|;
name|QString
name|t2
init|=
name|p2
operator|->
name|leftType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|.
name|length
argument_list|()
operator|<
name|t2
operator|.
name|length
argument_list|()
condition|)
name|qSwap
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/*               ### hack for C++ to handle superfluous               "Foo::" prefixes gracefully             */
if|if
condition|(
name|t1
operator|!=
name|t2
operator|&&
name|t1
operator|!=
operator|(
name|f2
operator|->
name|parent
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"::"
operator|+
name|t2
operator|)
condition|)
return|return
literal|false
return|;
block|}
operator|++
name|p1
expr_stmt|;
operator|++
name|p2
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Adds the \a child to this node's child list.  */
end_comment
begin_function
DECL|function|addChild
name|void
name|InnerNode
operator|::
name|addChild
parameter_list|(
name|Node
modifier|*
name|child
parameter_list|)
block|{
name|children_
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Function
operator|)
operator|||
operator|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|QmlMethod
operator|)
condition|)
block|{
name|FunctionNode
modifier|*
name|func
init|=
operator|(
name|FunctionNode
operator|*
operator|)
name|child
decl_stmt|;
if|if
condition|(
operator|!
name|primaryFunctionMap
operator|.
name|contains
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|primaryFunctionMap
operator|.
name|insert
argument_list|(
name|func
operator|->
name|name
argument_list|()
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|func
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
name|secs
operator|.
name|append
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Enum
condition|)
name|enumChildren_
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|childMap
operator|.
name|insertMulti
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|removeChild
name|void
name|InnerNode
operator|::
name|removeChild
parameter_list|(
name|Node
modifier|*
name|child
parameter_list|)
block|{
name|children_
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|enumChildren_
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Function
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|prim
init|=
name|primaryFunctionMap
operator|.
name|find
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|NodeList
modifier|&
name|secs
init|=
name|secondaryFunctionMap
index|[
name|child
operator|->
name|name
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|prim
operator|!=
name|primaryFunctionMap
operator|.
name|end
argument_list|()
operator|&&
operator|*
name|prim
operator|==
name|child
condition|)
block|{
if|if
condition|(
name|secs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|primaryFunctionMap
operator|.
name|remove
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primaryFunctionMap
operator|.
name|insert
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|secs
operator|.
name|takeFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|secs
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
name|QMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
operator|::
name|Iterator
name|ent
init|=
name|childMap
operator|.
name|find
argument_list|(
name|child
operator|->
name|name
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|ent
operator|!=
name|childMap
operator|.
name|end
argument_list|()
operator|&&
name|ent
operator|.
name|key
argument_list|()
operator|==
name|child
operator|->
name|name
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|ent
operator|==
name|child
condition|)
block|{
name|childMap
operator|.
name|erase
argument_list|(
name|ent
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|ent
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Find the module (Qt Core, Qt GUI, etc.) to which the class belongs.   We do this by obtaining the full path to the header file's location   and examine everything between "src/" and the filename.  This is   semi-dirty because we are assuming a particular directory structure.    This function is only really useful if the class's module has not   been defined in the header file with a QT_MODULE macro or with an   \inmodule command in the documentation. */
end_comment
begin_function
DECL|function|moduleName
name|QString
name|Node
operator|::
name|moduleName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|moduleName_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|moduleName_
return|;
name|QString
name|path
init|=
name|location
argument_list|()
operator|.
name|filePath
argument_list|()
decl_stmt|;
name|QString
name|pattern
init|=
name|QString
argument_list|(
literal|"src"
argument_list|)
operator|+
name|QDir
operator|::
name|separator
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|moduleDir
init|=
name|path
operator|.
name|mid
argument_list|(
name|start
operator|+
name|pattern
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|finish
init|=
name|moduleDir
operator|.
name|indexOf
argument_list|(
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|finish
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|moduleName
init|=
name|moduleDir
operator|.
name|left
argument_list|(
name|finish
argument_list|)
decl_stmt|;
if|if
condition|(
name|moduleName
operator|==
literal|"corelib"
condition|)
return|return
literal|"QtCore"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"uitools"
condition|)
return|return
literal|"QtUiTools"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"gui"
condition|)
return|return
literal|"QtGui"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"network"
condition|)
return|return
literal|"QtNetwork"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"opengl"
condition|)
return|return
literal|"QtOpenGL"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"svg"
condition|)
return|return
literal|"QtSvg"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"sql"
condition|)
return|return
literal|"QtSql"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"qtestlib"
condition|)
return|return
literal|"QtTest"
return|;
elseif|else
if|if
condition|(
name|moduleDir
operator|.
name|contains
argument_list|(
literal|"webkit"
argument_list|)
condition|)
return|return
literal|"QtWebKit"
return|;
elseif|else
if|if
condition|(
name|moduleName
operator|==
literal|"xml"
condition|)
return|return
literal|"QtXml"
return|;
else|else
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|removeRelated
name|void
name|InnerNode
operator|::
name|removeRelated
parameter_list|(
name|Node
modifier|*
name|pseudoChild
parameter_list|)
block|{
name|related_
operator|.
name|removeAll
argument_list|(
name|pseudoChild
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class LeafNode  */
end_comment
begin_comment
comment|/*! \fn bool LeafNode::isInnerNode() const   Returns false because this is a LeafNode.  */
end_comment
begin_comment
comment|/*!   Constructs a leaf node named \a name of the specified   \a type. The new leaf node becomes a child of \a parent.  */
end_comment
begin_constructor
DECL|function|LeafNode
name|LeafNode
operator|::
name|LeafNode
parameter_list|(
name|Type
name|type
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Enum
case|:
case|case
name|Function
case|:
case|case
name|Typedef
case|:
case|case
name|Variable
case|:
case|case
name|QmlProperty
case|:
case|case
name|QmlSignal
case|:
case|case
name|QmlSignalHandler
case|:
case|case
name|QmlMethod
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   This constructor should only be used when this node's parent   is meant to be \a parent, but this node is not to be listed   as a child of \a parent. It is currently only used for the   documentation case where a \e{qmlproperty} command is used   to override the QML definition of a QML property.  */
end_comment
begin_constructor
DECL|function|LeafNode
name|LeafNode
operator|::
name|LeafNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
name|Type
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|Node
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
block|{
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Enum
case|:
case|case
name|Function
case|:
case|case
name|Typedef
case|:
case|case
name|Variable
case|:
case|case
name|QmlProperty
case|:
case|case
name|QmlSignal
case|:
case|case
name|QmlSignalHandler
case|:
case|case
name|QmlMethod
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   \class NamespaceNode  */
end_comment
begin_comment
comment|/*!   Constructs a namespace node.  */
end_comment
begin_constructor
DECL|function|NamespaceNode
name|NamespaceNode
operator|::
name|NamespaceNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|InnerNode
argument_list|(
name|Namespace
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \class ClassNode   \brief This class represents a C++ class.  */
end_comment
begin_comment
comment|/*!   Constructs a class node. A class node will generate an API page.  */
end_comment
begin_constructor
DECL|function|ClassNode
name|ClassNode
operator|::
name|ClassNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|InnerNode
argument_list|(
name|Class
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
block|{
name|hidden
operator|=
literal|false
expr_stmt|;
name|abstract_
operator|=
literal|false
expr_stmt|;
name|qmlelement
operator|=
literal|0
expr_stmt|;
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addBaseClass
name|void
name|ClassNode
operator|::
name|addBaseClass
parameter_list|(
name|Access
name|access
parameter_list|,
name|ClassNode
modifier|*
name|node
parameter_list|,
specifier|const
name|QString
modifier|&
name|dataTypeWithTemplateArgs
parameter_list|)
block|{
name|bases
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|node
argument_list|,
name|dataTypeWithTemplateArgs
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|derived
operator|.
name|append
argument_list|(
name|RelatedClass
argument_list|(
name|access
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|fixBaseClasses
name|void
name|ClassNode
operator|::
name|fixBaseClasses
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|QSet
argument_list|<
name|ClassNode
modifier|*
argument_list|>
name|found
decl_stmt|;
comment|// Remove private and duplicate base classes.
while|while
condition|(
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|bc
init|=
name|bases
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|bc
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
operator|||
name|found
operator|.
name|contains
argument_list|(
name|bc
argument_list|)
condition|)
block|{
name|RelatedClass
name|rc
init|=
name|bases
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bases
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ignoredBases
operator|.
name|append
argument_list|(
name|rc
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bb
init|=
name|bc
operator|->
name|baseClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|bb
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|bases
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|bb
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
name|found
operator|.
name|insert
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|derived
operator|.
name|size
argument_list|()
condition|)
block|{
name|ClassNode
modifier|*
name|dc
init|=
name|derived
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|dc
operator|->
name|access
argument_list|()
operator|==
name|Node
operator|::
name|Private
condition|)
block|{
name|derived
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|dd
init|=
name|dc
operator|->
name|derivedClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|dd
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|derived
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|dd
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Search the child list to find the property node with the   specified \a name.  */
end_comment
begin_function
DECL|function|findPropertyNode
name|PropertyNode
modifier|*
name|ClassNode
operator|::
name|findPropertyNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|findChildNodeByNameAndType
argument_list|(
name|name
argument_list|,
name|Node
operator|::
name|Property
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
cast|static_cast
argument_list|<
name|PropertyNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
return|;
name|PropertyNode
modifier|*
name|pn
init|=
literal|0
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|baseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node
decl_stmt|;
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
break|break;
block|}
block|}
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|ignoredBases
init|=
name|ignoredBaseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ignoredBases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ignoredBases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|ignoredBases
index|[
name|i
index|]
operator|.
name|node
decl_stmt|;
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
break|break;
block|}
block|}
return|return
name|pn
return|;
block|}
end_function
begin_comment
comment|/*!   This function does a recursive search of this class node's   base classes looking for one that has a QML element. If it   finds one, it returns the pointer to that QML element. If   it doesn't find one, it returns null.  */
end_comment
begin_function
DECL|function|findQmlBaseNode
name|QmlClassNode
modifier|*
name|ClassNode
operator|::
name|findQmlBaseNode
parameter_list|()
block|{
name|QmlClassNode
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|RelatedClass
argument_list|>
modifier|&
name|bases
init|=
name|baseClasses
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|qmlElement
argument_list|()
condition|)
block|{
return|return
name|cn
operator|->
name|qmlElement
argument_list|()
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
name|bases
index|[
name|i
index|]
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|result
operator|=
name|cn
operator|->
name|findQmlBaseNode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \class DocNode  */
end_comment
begin_comment
comment|/*!   The type of a DocNode is Document, and it has a \a subtype,   which specifies the type of DocNode. The page type for   the page index is set here.  */
end_comment
begin_constructor
DECL|function|DocNode
name|DocNode
operator|::
name|DocNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|SubType
name|subtype
parameter_list|,
name|Node
operator|::
name|PageType
name|ptype
parameter_list|)
member_init_list|:
name|InnerNode
argument_list|(
name|Document
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|nodeSubtype_
argument_list|(
name|subtype
argument_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|Page
case|:
name|setPageType
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
name|DitaMap
case|:
name|setPageType
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
name|Module
case|:
case|case
name|Group
case|:
name|setPageType
argument_list|(
name|OverviewPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|QmlModule
case|:
name|setPageType
argument_list|(
name|OverviewPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|QmlClass
case|:
case|case
name|QmlBasicType
case|:
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|Example
case|:
name|setPageType
argument_list|(
name|ExamplePage
argument_list|)
expr_stmt|;
break|break;
case|case
name|Collision
case|:
name|setPageType
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Returns the document node's title. This is used for the page title. */
end_comment
begin_function
DECL|function|title
name|QString
name|DocNode
operator|::
name|title
parameter_list|()
specifier|const
block|{
return|return
name|title_
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the document node's full title, which is usually   just title(), but for some SubType values is different   from title()  */
end_comment
begin_function
DECL|function|fullTitle
name|QString
name|DocNode
operator|::
name|fullTitle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|nodeSubtype_
operator|==
name|File
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
literal|" Example File"
return|;
else|else
return|return
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nodeSubtype_
operator|==
name|Image
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
operator|.
name|mid
argument_list|(
name|name
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
literal|" Image File"
return|;
else|else
return|return
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nodeSubtype_
operator|==
name|HeaderFile
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|name
argument_list|()
return|;
else|else
return|return
name|name
argument_list|()
operator|+
literal|" - "
operator|+
name|title
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nodeSubtype_
operator|==
name|Collision
condition|)
block|{
return|return
name|title
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|title
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns the subtitle.  */
end_comment
begin_function
DECL|function|subTitle
name|QString
name|DocNode
operator|::
name|subTitle
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|subtitle_
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|subtitle_
return|;
if|if
condition|(
operator|(
name|nodeSubtype_
operator|==
name|File
operator|)
operator|||
operator|(
name|nodeSubtype_
operator|==
name|Image
operator|)
condition|)
block|{
if|if
condition|(
name|title
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
return|return
name|name
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this QML type or property group contains a   property named \a name.  */
end_comment
begin_function
DECL|function|hasProperty
name|bool
name|DocNode
operator|::
name|hasProperty
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|childNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
name|child
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlPropertyGroup
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|hasProperty
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|hasProperty
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   The constructor calls the DocNode constructor with   \a parent, \a name, and Node::Example.  */
end_comment
begin_constructor
DECL|function|ExampleNode
name|ExampleNode
operator|::
name|ExampleNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|DocNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|Node
operator|::
name|Example
argument_list|,
name|Node
operator|::
name|ExamplePage
argument_list|)
block|{
comment|// nothing
block|}
end_constructor
begin_comment
comment|/*!   \class EnumNode  */
end_comment
begin_comment
comment|/*!   The constructor for the node representing an enum type   has a \a parent class and an enum type \a name.  */
end_comment
begin_constructor
DECL|function|EnumNode
name|EnumNode
operator|::
name|EnumNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Enum
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|ft
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   Add \a item to the enum type's item list.  */
end_comment
begin_function
DECL|function|addItem
name|void
name|EnumNode
operator|::
name|addItem
parameter_list|(
specifier|const
name|EnumItem
modifier|&
name|item
parameter_list|)
block|{
name|itms
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|names
operator|.
name|insert
argument_list|(
name|item
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the access level of the enumeration item named \a name.   Apparently it is private if it has been omitted by qdoc's   omitvalue command. Otherwise it is public.  */
end_comment
begin_function
DECL|function|itemAccess
name|Node
operator|::
name|Access
name|EnumNode
operator|::
name|itemAccess
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|doc
argument_list|()
operator|.
name|omitEnumItemNames
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|Private
return|;
return|return
name|Public
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the enum value associated with the enum \a name.  */
end_comment
begin_function
DECL|function|itemValue
name|QString
name|EnumNode
operator|::
name|itemValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|EnumItem
modifier|&
name|item
decl|,
name|itms
control|)
block|{
if|if
condition|(
name|item
operator|.
name|name
argument_list|()
operator|==
name|name
condition|)
return|return
name|item
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \class TypedefNode  */
end_comment
begin_comment
comment|/*!  */
end_comment
begin_constructor
DECL|function|TypedefNode
name|TypedefNode
operator|::
name|TypedefNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Typedef
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|ae
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|setAssociatedEnum
name|void
name|TypedefNode
operator|::
name|setAssociatedEnum
parameter_list|(
specifier|const
name|EnumNode
modifier|*
name|enume
parameter_list|)
block|{
name|ae
operator|=
name|enume
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class Parameter   \brief The class Parameter contains one parameter.    A parameter can be a function parameter or a macro   parameter.  */
end_comment
begin_comment
comment|/*!   Constructs this parameter from the left and right types   \a leftType and rightType, the parameter \a name, and the   \a defaultValue. In practice, \a rightType is not used,   and I don't know what is was meant for.  */
end_comment
begin_constructor
DECL|function|Parameter
name|Parameter
operator|::
name|Parameter
parameter_list|(
specifier|const
name|QString
modifier|&
name|leftType
parameter_list|,
specifier|const
name|QString
modifier|&
name|rightType
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defaultValue
parameter_list|)
member_init_list|:
name|lef
argument_list|(
name|leftType
argument_list|)
member_init_list|,
name|rig
argument_list|(
name|rightType
argument_list|)
member_init_list|,
name|nam
argument_list|(
name|name
argument_list|)
member_init_list|,
name|def
argument_list|(
name|defaultValue
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   The standard copy constructor copies the strings from \a p.  */
end_comment
begin_constructor
DECL|function|Parameter
name|Parameter
operator|::
name|Parameter
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|p
parameter_list|)
member_init_list|:
name|lef
argument_list|(
name|p
operator|.
name|lef
argument_list|)
member_init_list|,
name|rig
argument_list|(
name|p
operator|.
name|rig
argument_list|)
member_init_list|,
name|nam
argument_list|(
name|p
operator|.
name|nam
argument_list|)
member_init_list|,
name|def
argument_list|(
name|p
operator|.
name|def
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Assigning Parameter \a p to this Parameter copies the   strings across.  */
end_comment
begin_function
DECL|function|operator =
name|Parameter
modifier|&
name|Parameter
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|p
parameter_list|)
block|{
name|lef
operator|=
name|p
operator|.
name|lef
expr_stmt|;
name|rig
operator|=
name|p
operator|.
name|rig
expr_stmt|;
name|nam
operator|=
name|p
operator|.
name|nam
expr_stmt|;
name|def
operator|=
name|p
operator|.
name|def
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Reconstructs the text describing the parameter and   returns it. If \a value is true, the default value   will be included, if there is one.  */
end_comment
begin_function
DECL|function|reconstruct
name|QString
name|Parameter
operator|::
name|reconstruct
parameter_list|(
name|bool
name|value
parameter_list|)
specifier|const
block|{
name|QString
name|p
init|=
name|lef
operator|+
name|rig
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|'&'
argument_list|)
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|endsWith
argument_list|(
name|QChar
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nam
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|def
operator|.
name|isEmpty
argument_list|()
condition|)
name|p
operator|+=
literal|" = "
operator|+
name|def
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!   \class FunctionNode  */
end_comment
begin_comment
comment|/*!   Construct a function node for a C++ function. It's parent   is \a parent, and it's name is \a name.  */
end_comment
begin_constructor
DECL|function|FunctionNode
name|FunctionNode
operator|::
name|FunctionNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Function
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|met
argument_list|(
name|Plain
argument_list|)
member_init_list|,
name|vir
argument_list|(
name|NonVirtual
argument_list|)
member_init_list|,
name|con
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|sta
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|ove
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimp
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|rf
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ap
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   Construct a function node for a QML method or signal, specified   by \a type. It's parent is \a parent, and it's name is \a name.   If \a attached is true, it is an attached method or signal.  */
end_comment
begin_constructor
DECL|function|FunctionNode
name|FunctionNode
operator|::
name|FunctionNode
parameter_list|(
name|Type
name|type
parameter_list|,
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|type
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|met
argument_list|(
name|Plain
argument_list|)
member_init_list|,
name|vir
argument_list|(
name|NonVirtual
argument_list|)
member_init_list|,
name|con
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|sta
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|ove
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reimp
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|rf
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ap
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   Sets the \a virtualness of this function. If the \a virtualness   is PureVirtual, and if the parent() is a ClassNode, set the parent's   \e abstract flag to true.  */
end_comment
begin_function
DECL|function|setVirtualness
name|void
name|FunctionNode
operator|::
name|setVirtualness
parameter_list|(
name|Virtualness
name|virtualness
parameter_list|)
block|{
name|vir
operator|=
name|virtualness
expr_stmt|;
if|if
condition|(
operator|(
name|virtualness
operator|==
name|PureVirtual
operator|)
operator|&&
name|parent
argument_list|()
operator|&&
operator|(
name|parent
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Class
operator|)
condition|)
name|parent
argument_list|()
operator|->
name|setAbstract
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|setOverload
name|void
name|FunctionNode
operator|::
name|setOverload
parameter_list|(
name|bool
name|overlode
parameter_list|)
block|{
name|parent
argument_list|()
operator|->
name|setOverload
argument_list|(
name|this
argument_list|,
name|overlode
argument_list|)
expr_stmt|;
name|ove
operator|=
name|overlode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the function node's reimplementation flag to \a r.   When \a r is true, it is supposed to mean that this function   is a reimplementation of a virtual function in a base class,   but it really just means the \e reimp command was seen in the   qdoc comment.  */
end_comment
begin_function
DECL|function|setReimp
name|void
name|FunctionNode
operator|::
name|setReimp
parameter_list|(
name|bool
name|r
parameter_list|)
block|{
name|reimp
operator|=
name|r
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|addParameter
name|void
name|FunctionNode
operator|::
name|addParameter
parameter_list|(
specifier|const
name|Parameter
modifier|&
name|parameter
parameter_list|)
block|{
name|params
operator|.
name|append
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|borrowParameterNames
name|void
name|FunctionNode
operator|::
name|borrowParameterNames
parameter_list|(
specifier|const
name|FunctionNode
modifier|*
name|source
parameter_list|)
block|{
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|Iterator
name|t
init|=
name|params
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|s
init|=
name|source
operator|->
name|params
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|source
operator|->
name|params
operator|.
name|constEnd
argument_list|()
operator|&&
name|t
operator|!=
name|params
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
operator|(
operator|*
name|t
operator|)
operator|.
name|setName
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   If this function is a reimplementation, \a from points   to the FunctionNode of the function being reimplemented.  */
end_comment
begin_function
DECL|function|setReimplementedFrom
name|void
name|FunctionNode
operator|::
name|setReimplementedFrom
parameter_list|(
name|FunctionNode
modifier|*
name|from
parameter_list|)
block|{
name|rf
operator|=
name|from
expr_stmt|;
name|from
operator|->
name|rb
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets the "associated" property to \a property. The function   might be the setter or getter for a property, for example.  */
end_comment
begin_function
DECL|function|setAssociatedProperty
name|void
name|FunctionNode
operator|::
name|setAssociatedProperty
parameter_list|(
name|PropertyNode
modifier|*
name|property
parameter_list|)
block|{
name|ap
operator|=
name|property
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the overload number for this function obtained   from the parent.  */
end_comment
begin_function
DECL|function|overloadNumber
name|int
name|FunctionNode
operator|::
name|overloadNumber
parameter_list|()
specifier|const
block|{
return|return
name|parent
argument_list|()
operator|->
name|overloadNumber
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of parameter names.  */
end_comment
begin_function
DECL|function|parameterNames
name|QStringList
name|FunctionNode
operator|::
name|parameterNames
parameter_list|()
specifier|const
block|{
name|QStringList
name|names
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|names
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|name
argument_list|()
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|names
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a raw list of parameters. If \a names is true, the   names are included. If \a values is true, the default values   are included, if any are present.  */
end_comment
begin_function
DECL|function|rawParameters
name|QString
name|FunctionNode
operator|::
name|rawParameters
parameter_list|(
name|bool
name|names
parameter_list|,
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QString
name|raw
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Parameter
modifier|&
name|parameter
decl|,
name|parameters
argument_list|()
control|)
block|{
name|raw
operator|+=
name|parameter
operator|.
name|leftType
argument_list|()
operator|+
name|parameter
operator|.
name|rightType
argument_list|()
expr_stmt|;
if|if
condition|(
name|names
condition|)
name|raw
operator|+=
name|parameter
operator|.
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|values
condition|)
name|raw
operator|+=
name|parameter
operator|.
name|defaultValue
argument_list|()
expr_stmt|;
block|}
return|return
name|raw
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the list of reconstructed parameters. If \a values   is true, the default values are included, if any are present.  */
end_comment
begin_function
DECL|function|reconstructParams
name|QStringList
name|FunctionNode
operator|::
name|reconstructParams
parameter_list|(
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QStringList
name|params
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
operator|::
name|ConstIterator
name|p
init|=
name|parameters
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|parameters
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|params
operator|<<
operator|(
operator|*
name|p
operator|)
operator|.
name|reconstruct
argument_list|(
name|values
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|params
return|;
block|}
end_function
begin_comment
comment|/*!   Reconstructs and returns the function's signature. If \a values   is true, the default values of the parameters are included, if   present.  */
end_comment
begin_function
DECL|function|signature
name|QString
name|FunctionNode
operator|::
name|signature
parameter_list|(
name|bool
name|values
parameter_list|)
specifier|const
block|{
name|QString
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|returnType
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|=
name|returnType
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|+=
name|name
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|QStringList
name|params
init|=
name|reconstructParams
argument_list|(
name|values
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|params
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|+=
name|params
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|p
operator|-
literal|1
operator|)
condition|)
name|s
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
name|s
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   Print some debugging stuff.  */
end_comment
begin_function
DECL|function|debug
name|void
name|FunctionNode
operator|::
name|debug
parameter_list|()
specifier|const
block|{
name|qDebug
argument_list|(
literal|"QML METHOD %s rt %s pp %s"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|rt
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|pp
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class PropertyNode    This class describes one instance of using the Q_PROPERTY macro.  */
end_comment
begin_comment
comment|/*!   The constructor sets the \a parent and the \a name, but   everything else is set to default values.  */
end_comment
begin_constructor
DECL|function|PropertyNode
name|PropertyNode
operator|::
name|PropertyNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|Property
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|scriptable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|writable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|user_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|cst
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|fnl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|rev
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|overrides
argument_list|(
literal|0
argument_list|)
block|{
comment|// nothing.
block|}
end_constructor
begin_comment
comment|/*!   Sets this property's \e {overridden from} property to   \a baseProperty, which indicates that this property   overrides \a baseProperty. To begin with, all the values   in this property are set to the corresponding values in   \a baseProperty.    We probably should ensure that the constant and final   attributes are not being overridden improperly.  */
end_comment
begin_function
DECL|function|setOverriddenFrom
name|void
name|PropertyNode
operator|::
name|setOverriddenFrom
parameter_list|(
specifier|const
name|PropertyNode
modifier|*
name|baseProperty
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumFunctionRoles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|funcs
index|[
name|i
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|funcs
index|[
name|i
index|]
operator|=
name|baseProperty
operator|->
name|funcs
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|stored_
operator|==
name|FlagValueDefault
condition|)
name|stored_
operator|=
name|baseProperty
operator|->
name|stored_
expr_stmt|;
if|if
condition|(
name|designable_
operator|==
name|FlagValueDefault
condition|)
name|designable_
operator|=
name|baseProperty
operator|->
name|designable_
expr_stmt|;
if|if
condition|(
name|scriptable_
operator|==
name|FlagValueDefault
condition|)
name|scriptable_
operator|=
name|baseProperty
operator|->
name|scriptable_
expr_stmt|;
if|if
condition|(
name|writable_
operator|==
name|FlagValueDefault
condition|)
name|writable_
operator|=
name|baseProperty
operator|->
name|writable_
expr_stmt|;
if|if
condition|(
name|user_
operator|==
name|FlagValueDefault
condition|)
name|user_
operator|=
name|baseProperty
operator|->
name|user_
expr_stmt|;
name|overrides
operator|=
name|baseProperty
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|qualifiedDataType
name|QString
name|PropertyNode
operator|::
name|qualifiedDataType
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|setters
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|resetters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|type_
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|||
name|type_
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
condition|)
block|{
comment|// 'QWidget *' becomes 'QWidget *' const
return|return
name|type_
operator|+
literal|" const"
return|;
block|}
else|else
block|{
comment|/*               'int' becomes 'const int' ('int const' is               correct C++, but looks wrong)             */
return|return
literal|"const "
operator|+
name|type_
return|;
block|}
block|}
else|else
block|{
return|return
name|type_
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|member|qmlOnly
name|bool
name|QmlClassNode
operator|::
name|qmlOnly
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|inheritedBy
name|QMultiMap
argument_list|<
name|QString
argument_list|,
name|Node
modifier|*
argument_list|>
name|QmlClassNode
operator|::
name|inheritedBy
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   Constructs a Qml class node (i.e. a Document node with the   subtype QmlClass. The new node has the given \a parent   and \a name.  */
end_comment
begin_constructor
DECL|function|QmlClassNode
name|QmlClassNode
operator|::
name|QmlClassNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|DocNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|QmlClass
argument_list|,
name|Node
operator|::
name|ApiPage
argument_list|)
member_init_list|,
name|abstract_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cnodeRequired_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cnode_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|baseNode_
argument_list|(
literal|0
argument_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"QML:"
argument_list|)
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"BOGUS QML qualifier:"
operator|<<
name|name
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
block|}
name|setTitle
argument_list|(
name|name
operator|.
name|mid
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Needed for printing a debug messages.  */
end_comment
begin_destructor
DECL|function|~QmlClassNode
name|QmlClassNode
operator|::
name|~
name|QmlClassNode
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Clear the static maps so that subsequent runs don't try to use   contents from a previous run.  */
end_comment
begin_function
DECL|function|terminate
name|void
name|QmlClassNode
operator|::
name|terminate
parameter_list|()
block|{
name|inheritedBy
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Record the fact that QML class \a base is inherited by   QML class \a sub.  */
end_comment
begin_function
DECL|function|addInheritedBy
name|void
name|QmlClassNode
operator|::
name|addInheritedBy
parameter_list|(
specifier|const
name|QString
modifier|&
name|base
parameter_list|,
name|Node
modifier|*
name|sub
parameter_list|)
block|{
if|if
condition|(
name|inheritedBy
operator|.
name|constFind
argument_list|(
name|base
argument_list|,
name|sub
argument_list|)
operator|==
name|inheritedBy
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|inheritedBy
operator|.
name|insert
argument_list|(
name|base
argument_list|,
name|sub
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Loads the list \a subs with the nodes of all the subclasses of \a base.  */
end_comment
begin_function
DECL|function|subclasses
name|void
name|QmlClassNode
operator|::
name|subclasses
parameter_list|(
specifier|const
name|QString
modifier|&
name|base
parameter_list|,
name|NodeList
modifier|&
name|subs
parameter_list|)
block|{
name|subs
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|inheritedBy
operator|.
name|count
argument_list|(
name|base
argument_list|)
operator|>
literal|0
condition|)
block|{
name|subs
operator|=
name|inheritedBy
operator|.
name|values
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \fn QString QmlClassNode::qmlModuleIdentifier() const   This function is called to get a string that is used either   as a prefix for the file name to use for QML element or   component reference page, or as a qualifier to prefix a   reference to a QML element or comnponent. The string that   is returned is the concatenation of the QML module name   and its version number. e.g., if an element or component   is defined to be in the QML module QtQuick 1, its module   identifier is "QtQuick1". See setQmlModuleInfo().  */
end_comment
begin_comment
comment|/*!   This function splits \a arg on the blank character to get a   QML module name and version number. It then spilts the version   number on the '.' character to get a major version number and   a minor vrsion number. Both version numbers must be present.   It stores these components separately. If all three are found,   true is returned. If any of the three is not found or is not   correct, false is returned.  */
end_comment
begin_function
DECL|function|setQmlModuleInfo
name|bool
name|Node
operator|::
name|setQmlModuleInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
name|QStringList
name|dotSplit
decl_stmt|;
name|QStringList
name|blankSplit
init|=
name|arg
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
name|qmlModuleName_
operator|=
name|blankSplit
index|[
literal|0
index|]
expr_stmt|;
name|qmlModuleVersionMajor_
operator|=
literal|"1"
expr_stmt|;
name|qmlModuleVersionMinor_
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|dotSplit
operator|=
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|qmlModuleVersionMajor_
operator|=
name|dotSplit
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dotSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qmlModuleVersionMinor_
operator|=
name|dotSplit
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   The name of this QML class node might be the same as the   name of some other QML class node. If so, then this node's   parent will be a NameCollisionNode.This function sets the   NameCollisionNode's current child to this node. This is   important when outputting the documentation for this node,   when, for example, the documentation contains a link to   the page being output. We don't want to generate a link   to the disambiguation page if we can avoid it, and to be   able to avoid it, the NameCollisionNode must maintain the   current child pointer. That's the purpose of this function.  */
end_comment
begin_function
DECL|function|setCurrentChild
name|void
name|QmlClassNode
operator|::
name|setCurrentChild
parameter_list|()
block|{
if|if
condition|(
name|parent
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
name|n
operator|->
name|setCurrentChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  */
end_comment
begin_function
DECL|function|clearCurrentChild
name|void
name|QmlClassNode
operator|::
name|clearCurrentChild
parameter_list|()
block|{
if|if
condition|(
name|parent
argument_list|()
condition|)
block|{
name|InnerNode
modifier|*
name|n
init|=
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|Collision
condition|)
name|n
operator|->
name|clearCurrentChild
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Constructs a Qml basic type node (i.e. a Document node with   the subtype QmlBasicType. The new node has the given   \a parent and \a name.  */
end_comment
begin_constructor
DECL|function|QmlBasicTypeNode
name|QmlBasicTypeNode
operator|::
name|QmlBasicTypeNode
parameter_list|(
name|InnerNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|DocNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|QmlBasicType
argument_list|,
name|Node
operator|::
name|ApiPage
argument_list|)
block|{
name|setTitle
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructor for the Qml property group node. \a parent is   always a QmlClassNode.  */
end_comment
begin_constructor
DECL|function|QmlPropGroupNode
name|QmlPropGroupNode
operator|::
name|QmlPropGroupNode
parameter_list|(
name|QmlClassNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|DocNode
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|QmlPropertyGroup
argument_list|,
name|Node
operator|::
name|ApiPage
argument_list|)
block|{
name|idNumber_
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Return the property group node's id number for use in   constructing an id attribute for the property group.   If the id number is currently -1, increment the global   property group count and set the id number to the new   value.  */
end_comment
begin_function
DECL|function|idNumber
name|QString
name|QmlPropGroupNode
operator|::
name|idNumber
parameter_list|()
block|{
if|if
condition|(
name|idNumber_
operator|==
operator|-
literal|1
condition|)
name|idNumber_
operator|=
name|incPropertyGroupCount
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
operator|.
name|setNum
argument_list|(
name|idNumber_
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Constructor for the QML property node, when the \a parent   is QML property group node. This constructor is only used   for creating QML property nodes for QML elements, i.e.   not for creating QML property nodes for QML components.   Hopefully, this constructor will become obsolete, so don't   use it unless one of the other two constructors can't be   used.  */
end_comment
begin_constructor
DECL|function|QmlPropertyNode
name|QmlPropertyNode
operator|::
name|QmlPropertyNode
parameter_list|(
name|QmlPropGroupNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|QmlProperty
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|type_
argument_list|(
name|type
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|isdefault_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|readOnly_
argument_list|(
name|FlagValueDefault
argument_list|)
block|{
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructor for the QML property node, when the \a parent   is a QML class node.  */
end_comment
begin_constructor
DECL|function|QmlPropertyNode
name|QmlPropertyNode
operator|::
name|QmlPropertyNode
parameter_list|(
name|QmlClassNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|QmlProperty
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
member_init_list|,
name|type_
argument_list|(
name|type
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|isdefault_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|readOnly_
argument_list|(
name|FlagValueDefault
argument_list|)
block|{
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructor for the QML property node, when the \a parent   is a QML property node. Strictly speaking, this is not the   way QML property nodes were originally meant to be built,   because this constructor has another QML property node as   its parent. But this constructor is useful for documenting   QML properties in QML components, i.e., when you override   the definition of a property with the \e{qmlproperty}   command. It actually uses the parent of \a parent as the   parent.  */
end_comment
begin_constructor
DECL|function|QmlPropertyNode
name|QmlPropertyNode
operator|::
name|QmlPropertyNode
parameter_list|(
name|QmlPropertyNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
name|bool
name|attached
parameter_list|)
member_init_list|:
name|LeafNode
argument_list|(
name|parent
operator|->
name|parent
argument_list|()
argument_list|,
name|QmlProperty
argument_list|,
name|name
argument_list|)
member_init_list|,
name|type_
argument_list|(
name|type
argument_list|)
member_init_list|,
name|stored_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|designable_
argument_list|(
name|FlagValueDefault
argument_list|)
member_init_list|,
name|isdefault_
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|attached_
argument_list|(
name|attached
argument_list|)
member_init_list|,
name|readOnly_
argument_list|(
name|FlagValueDefault
argument_list|)
block|{
name|setPageType
argument_list|(
name|ApiPage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Returns true if a QML property or attached property is   not read-only. The algorithm for figuring this out is long   amd tedious and almost certainly will break. It currently   doesn't work for the qmlproperty:    \code       bool PropertyChanges::explicit,   \endcode    ...because the tokenizer gets confused on \e{explicit}.  */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QmlPropertyNode
operator|::
name|isWritable
parameter_list|(
name|QDocDatabase
modifier|*
name|qdb
parameter_list|)
block|{
if|if
condition|(
name|readOnly_
operator|!=
name|FlagValueDefault
condition|)
return|return
operator|!
name|fromFlagValue
argument_list|(
name|readOnly_
argument_list|,
literal|false
argument_list|)
return|;
name|QmlClassNode
modifier|*
name|qcn
init|=
name|qmlClassNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|qcn
condition|)
block|{
if|if
condition|(
name|qcn
operator|->
name|cppClassRequired
argument_list|()
condition|)
block|{
if|if
condition|(
name|qcn
operator|->
name|classNode
argument_list|()
condition|)
block|{
name|PropertyNode
modifier|*
name|pn
init|=
name|correspondingProperty
argument_list|(
name|qdb
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
condition|)
return|return
name|pn
operator|->
name|isWritable
argument_list|()
return|;
else|else
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No Q_PROPERTY for QML property %1::%2::%3 "
literal|"in C++ class documented as QML type: "
literal|"(property not found in the C++ class or its base classes)"
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlModuleIdentifier
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlTypeName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"No Q_PROPERTY for QML property %1::%2::%3 "
literal|"in C++ class documented as QML type: "
literal|"(C++ class not specified or not found)."
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlModuleIdentifier
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|qmlTypeName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pointer this QML property's corresponding C++   property, if it has one.  */
end_comment
begin_function
DECL|function|correspondingProperty
name|PropertyNode
modifier|*
name|QmlPropertyNode
operator|::
name|correspondingProperty
parameter_list|(
name|QDocDatabase
modifier|*
name|qdb
parameter_list|)
block|{
name|PropertyNode
modifier|*
name|pn
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|parent
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|&&
name|n
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlClass
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|QmlClassNode
modifier|*
name|qcn
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|ClassNode
modifier|*
name|cn
init|=
name|qcn
operator|->
name|classNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cn
condition|)
block|{
name|QStringList
name|dotSplit
init|=
name|name
argument_list|()
operator|.
name|split
argument_list|(
name|QChar
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
block|{
if|if
condition|(
name|dotSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// Find the C++ property corresponding to the QML property in
comment|// the property group,<group>.<property>.
name|QStringList
name|path
argument_list|(
name|extractClassName
argument_list|(
name|pn
operator|->
name|qualifiedDataType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|nn
init|=
name|qdb
operator|->
name|findClassNode
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|nn
condition|)
block|{
name|ClassNode
modifier|*
name|cn
init|=
cast|static_cast
argument_list|<
name|ClassNode
operator|*
argument_list|>
argument_list|(
name|nn
argument_list|)
decl_stmt|;
name|PropertyNode
modifier|*
name|pn2
init|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|dotSplit
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn2
condition|)
return|return
name|pn2
return|;
comment|// Return the property for the QML property.
else|else
return|return
name|pn
return|;
comment|// Return the property for the QML group.
block|}
block|}
else|else
return|return
name|pn
return|;
block|}
else|else
block|{
name|pn
operator|=
name|cn
operator|->
name|findPropertyNode
argument_list|(
name|dotSplit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
return|return
name|pn
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this QML type or property group contains a   property named \a name.  */
end_comment
begin_function
DECL|function|hasProperty
name|bool
name|QmlPropertyNode
operator|::
name|hasProperty
parameter_list|(
specifier|const
name|QString
modifier|&
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
argument_list|()
operator|==
name|n
condition|)
return|return
literal|true
return|;
foreach|foreach
control|(
name|Node
modifier|*
name|child
decl|,
name|qmlPropNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|name
argument_list|()
operator|==
name|n
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \class NameCollisionNode    An instance of this node is inserted in the tree   whenever qdoc discovers that two nodes have the   same name.  */
end_comment
begin_comment
comment|/*!   Constructs a name collision node containing \a child   as its first child. The parent of \a child becomes   this node's parent.  */
end_comment
begin_constructor
DECL|function|NameCollisionNode
name|NameCollisionNode
operator|::
name|NameCollisionNode
parameter_list|(
name|InnerNode
modifier|*
name|child
parameter_list|)
member_init_list|:
name|DocNode
argument_list|(
name|child
operator|->
name|parent
argument_list|()
argument_list|,
name|child
operator|->
name|name
argument_list|()
argument_list|,
name|Collision
argument_list|,
name|Node
operator|::
name|NoPageType
argument_list|)
block|{
name|setTitle
argument_list|(
literal|"Name Collision: "
operator|+
name|child
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|addCollision
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Add a collision to this collision node. \a child has   the same name as the other children in this collision   node. \a child becomes the current child.  */
end_comment
begin_function
DECL|function|addCollision
name|void
name|NameCollisionNode
operator|::
name|addCollision
parameter_list|(
name|InnerNode
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
name|child
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|parent
argument_list|()
condition|)
name|child
operator|->
name|parent
argument_list|()
operator|->
name|removeChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|->
name|setParent
argument_list|(
operator|(
name|InnerNode
operator|*
operator|)
name|this
argument_list|)
expr_stmt|;
name|children_
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   The destructor does nothing.  */
end_comment
begin_destructor
DECL|function|~NameCollisionNode
name|NameCollisionNode
operator|::
name|~
name|NameCollisionNode
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*! \fn const InnerNode* NameCollisionNode::currentChild() const   Returns a pointer to the current child, which may be 0.  */
end_comment
begin_comment
comment|/*! \fn void NameCollisionNode::setCurrentChild(InnerNode* child)   Sets the current child to \a child. The current child is   valid only within the file where it is defined.  */
end_comment
begin_comment
comment|/*! \fn void NameCollisionNode::clearCurrentChild()   Sets the current child to 0. This should be called at the   end of each file, because the current child is only valid   within the file where the child is defined.  */
end_comment
begin_comment
comment|/*!   Returns true if this collision node's current node is a QML node.  */
end_comment
begin_function
DECL|function|isQmlNode
name|bool
name|NameCollisionNode
operator|::
name|isQmlNode
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|current
condition|)
return|return
name|current
operator|->
name|isQmlNode
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Find any of this collision node's children that has type \a t   and subtype \a st and return a pointer to it. */
end_comment
begin_function
DECL|function|findAny
name|InnerNode
modifier|*
name|NameCollisionNode
operator|::
name|findAny
parameter_list|(
name|Node
operator|::
name|Type
name|t
parameter_list|,
name|Node
operator|::
name|SubType
name|st
parameter_list|)
block|{
if|if
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|type
argument_list|()
operator|==
name|t
operator|&&
name|current
operator|->
name|subType
argument_list|()
operator|==
name|st
condition|)
return|return
name|current
return|;
block|}
specifier|const
name|NodeList
modifier|&
name|cn
init|=
name|childNodes
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|i
init|=
name|cn
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|cn
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|type
argument_list|()
operator|==
name|t
operator|&&
operator|(
operator|*
name|i
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|st
condition|)
return|return
cast|static_cast
argument_list|<
name|InnerNode
operator|*
argument_list|>
argument_list|(
operator|*
name|i
argument_list|)
return|;
operator|++
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This node is a name collision node. Find a child of this node   such that the child's QML module identifier matches origin's   QML module identifier. Return the matching node, or return this   node if there is no matching node.  */
end_comment
begin_function
DECL|function|applyModuleIdentifier
specifier|const
name|Node
modifier|*
name|NameCollisionNode
operator|::
name|applyModuleIdentifier
parameter_list|(
specifier|const
name|Node
modifier|*
name|origin
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|origin
operator|&&
operator|!
name|origin
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|NodeList
modifier|&
name|cn
init|=
name|childNodes
argument_list|()
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|i
init|=
name|cn
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|cn
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|&&
operator|(
operator|*
name|i
operator|)
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|qmlModuleIdentifier
argument_list|()
operator|==
operator|(
operator|*
name|i
operator|)
operator|->
name|qmlModuleIdentifier
argument_list|()
condition|)
return|return
operator|(
operator|*
name|i
operator|)
return|;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Construct the full document name for this node and return it.  */
end_comment
begin_function
DECL|function|fullDocumentName
name|QString
name|Node
operator|::
name|fullDocumentName
parameter_list|()
specifier|const
block|{
name|QStringList
name|pieces
decl_stmt|;
specifier|const
name|Node
modifier|*
name|n
init|=
name|this
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|n
operator|->
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|n
operator|->
name|type
argument_list|()
operator|!=
name|Node
operator|::
name|Document
operator|)
operator|||
operator|(
name|n
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
operator|)
operator|)
condition|)
name|pieces
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|n
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlPropertyGroup
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
operator|&&
operator|!
name|n
operator|->
name|qmlModuleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|pieces
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|n
operator|->
name|qmlModuleIdentifier
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Examine the parent node if one exists.
if|if
condition|(
name|n
operator|->
name|parent
argument_list|()
condition|)
name|n
operator|=
name|n
operator|->
name|parent
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|true
condition|)
do|;
comment|// Create a name based on the type of the ancestor node.
name|QString
name|concatenator
init|=
literal|"::"
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|n
operator|->
name|subType
argument_list|()
operator|!=
name|Node
operator|::
name|QmlClass
operator|)
condition|)
name|concatenator
operator|=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
return|return
name|pieces
operator|.
name|join
argument_list|(
name|concatenator
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the \a str as an NCName, which means the name can   be used as the value of an \e id attribute. Search for NCName   on the internet for details of what can be an NCName.  */
end_comment
begin_function
DECL|function|cleanId
name|QString
name|Node
operator|::
name|cleanId
parameter_list|(
name|QString
name|str
parameter_list|)
block|{
name|QString
name|clean
decl_stmt|;
name|QString
name|name
init|=
name|str
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clean
return|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
literal|"::"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|.
name|replace
argument_list|(
literal|"()"
argument_list|,
literal|"-call"
argument_list|)
expr_stmt|;
name|clean
operator|.
name|reserve
argument_list|(
name|name
operator|.
name|size
argument_list|()
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|startsWith
argument_list|(
literal|"id-"
argument_list|)
condition|)
name|clean
operator|=
literal|"id-"
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|name
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'~'
condition|)
block|{
name|clean
operator|+=
literal|"dtor."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'_'
condition|)
block|{
name|clean
operator|+=
literal|"underscore."
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|name
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
name|u
operator|==
literal|'-'
operator|||
name|u
operator|==
literal|'_'
operator|||
name|u
operator|==
literal|'.'
condition|)
block|{
name|clean
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
operator|||
name|u
operator|==
literal|':'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'!'
condition|)
block|{
name|clean
operator|+=
literal|"-not"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'&'
condition|)
block|{
name|clean
operator|+=
literal|"-and"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'<'
condition|)
block|{
name|clean
operator|+=
literal|"-lt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'='
condition|)
block|{
name|clean
operator|+=
literal|"-eq"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'>'
condition|)
block|{
name|clean
operator|+=
literal|"-gt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'#'
condition|)
block|{
name|clean
operator|+=
literal|"-hash"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|'('
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
literal|')'
condition|)
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|clean
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clean
return|;
block|}
end_function
begin_comment
comment|/*!   Creates a string that can be used as a UUID for the node,   depending on the type and subtype of the node. Uniquenss   is not guaranteed, but it is expected that strings created   here will be unique within an XML document. Hence, the   returned string can be used as the value of an \e id   attribute.  */
end_comment
begin_function
DECL|function|idForNode
name|QString
name|Node
operator|::
name|idForNode
parameter_list|()
specifier|const
block|{
specifier|const
name|FunctionNode
modifier|*
name|func
decl_stmt|;
specifier|const
name|TypedefNode
modifier|*
name|tdn
decl_stmt|;
name|QString
name|str
decl_stmt|;
switch|switch
condition|(
name|type
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|Namespace
case|:
name|str
operator|=
literal|"namespace-"
operator|+
name|fullDocumentName
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Class
case|:
name|str
operator|=
literal|"class-"
operator|+
name|fullDocumentName
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Enum
case|:
name|str
operator|=
literal|"enum-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Typedef
case|:
name|tdn
operator|=
cast|static_cast
argument_list|<
specifier|const
name|TypedefNode
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdn
operator|->
name|associatedEnum
argument_list|()
condition|)
block|{
return|return
name|tdn
operator|->
name|associatedEnum
argument_list|()
operator|->
name|idForNode
argument_list|()
return|;
block|}
else|else
block|{
name|str
operator|=
literal|"typedef-"
operator|+
name|name
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Function
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|associatedProperty
argument_list|()
condition|)
block|{
return|return
name|func
operator|->
name|associatedProperty
argument_list|()
operator|->
name|idForNode
argument_list|()
return|;
block|}
else|else
block|{
if|if
condition|(
name|func
operator|->
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"operator"
argument_list|)
condition|)
block|{
name|str
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|/*                   The test below should probably apply to all                   functions, but for now, overloaded operators                   are the only ones that produce duplicate id                   attributes in the DITA XML files.                  */
if|if
condition|(
name|relatesTo_
condition|)
name|str
operator|=
literal|"nonmember-"
expr_stmt|;
name|QString
name|op
init|=
name|func
operator|->
name|name
argument_list|()
operator|.
name|mid
argument_list|(
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|op
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|op
operator|.
name|size
argument_list|()
operator|&&
name|op
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|' '
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
name|op
operator|.
name|size
argument_list|()
condition|)
block|{
name|op
operator|=
name|op
operator|.
name|mid
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|op
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|op
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|const
name|QChar
name|c
init|=
name|op
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
condition|)
break|break;
operator|++
name|i
expr_stmt|;
block|}
name|str
operator|+=
literal|"operator-"
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|QString
name|tail
init|=
name|op
operator|.
name|mid
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|op
operator|=
name|op
operator|.
name|left
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operators_
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|str
operator|+=
name|operators_
operator|.
name|value
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tail
operator|.
name|isEmpty
argument_list|()
condition|)
name|str
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|tail
expr_stmt|;
block|}
else|else
name|qDebug
argument_list|()
operator|<<
literal|"qdoc internal error: Operator missing from operators_ map:"
operator|<<
name|op
expr_stmt|;
block|}
else|else
block|{
name|str
operator|+=
name|op
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|parent_
condition|)
block|{
if|if
condition|(
name|parent_
operator|->
name|type
argument_list|()
operator|==
name|Class
condition|)
name|str
operator|=
literal|"class-member-"
operator|+
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parent_
operator|->
name|type
argument_list|()
operator|==
name|Namespace
condition|)
name|str
operator|=
literal|"namespace-member-"
operator|+
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parent_
operator|->
name|type
argument_list|()
operator|==
name|Document
condition|)
block|{
if|if
condition|(
name|parent_
operator|->
name|subType
argument_list|()
operator|==
name|QmlClass
condition|)
name|str
operator|=
literal|"qml-method-"
operator|+
name|parent_
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|"-"
operator|+
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"qdoc internal error: Node subtype not handled:"
operator|<<
name|parent_
operator|->
name|subType
argument_list|()
operator|<<
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
else|else
name|qDebug
argument_list|()
operator|<<
literal|"qdoc internal error: Node type not handled:"
operator|<<
name|parent_
operator|->
name|type
argument_list|()
operator|<<
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|str
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Document
case|:
block|{
switch|switch
condition|(
name|subType
argument_list|()
condition|)
block|{
case|case
name|Node
operator|::
name|QmlClass
case|:
name|str
operator|=
literal|"qml-class-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlPropertyGroup
case|:
block|{
name|Node
modifier|*
name|n
init|=
cast|const_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|str
operator|=
literal|"qml-propertygroup-"
operator|+
name|n
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Node
operator|::
name|Page
case|:
case|case
name|Node
operator|::
name|Group
case|:
case|case
name|Node
operator|::
name|Module
case|:
case|case
name|Node
operator|::
name|HeaderFile
case|:
name|str
operator|=
name|title
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|str
operator|=
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
literal|".html"
argument_list|)
condition|)
name|str
operator|.
name|remove
argument_list|(
name|str
operator|.
name|size
argument_list|()
operator|-
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|str
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|File
case|:
name|str
operator|=
name|name
argument_list|()
expr_stmt|;
name|str
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Example
case|:
name|str
operator|=
name|name
argument_list|()
expr_stmt|;
name|str
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlBasicType
case|:
name|str
operator|=
literal|"qml-basic-type-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlModule
case|:
name|str
operator|=
literal|"qml-module-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Collision
case|:
name|str
operator|=
name|title
argument_list|()
expr_stmt|;
name|str
operator|.
name|replace
argument_list|(
literal|": "
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qDebug
argument_list|()
operator|<<
literal|"ERROR: A case was not handled in Node::idForNode():"
operator|<<
literal|"subType():"
operator|<<
name|subType
argument_list|()
operator|<<
literal|"type():"
operator|<<
name|type
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|Node
operator|::
name|QmlProperty
case|:
name|str
operator|=
literal|"qml-property-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Property
case|:
name|str
operator|=
literal|"property-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignal
case|:
name|str
operator|=
literal|"qml-signal-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlSignalHandler
case|:
name|str
operator|=
literal|"qml-signal-handler-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|QmlMethod
case|:
name|func
operator|=
cast|static_cast
argument_list|<
specifier|const
name|FunctionNode
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"qml-method-"
operator|+
name|parent_
operator|->
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|+
literal|"-"
operator|+
name|func
operator|->
name|name
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|overloadNumber
argument_list|()
operator|!=
literal|1
condition|)
name|str
operator|+=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|func
operator|->
name|overloadNumber
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node
operator|::
name|Variable
case|:
name|str
operator|=
literal|"var-"
operator|+
name|name
argument_list|()
expr_stmt|;
break|break;
default|default:
name|qDebug
argument_list|()
operator|<<
literal|"ERROR: A case was not handled in Node::idForNode():"
operator|<<
literal|"type():"
operator|<<
name|type
argument_list|()
operator|<<
literal|"subType():"
operator|<<
name|subType
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"ERROR: A link text was empty in Node::idForNode():"
operator|<<
literal|"type():"
operator|<<
name|type
argument_list|()
operator|<<
literal|"subType():"
operator|<<
name|subType
argument_list|()
operator|<<
literal|"name():"
operator|<<
name|name
argument_list|()
operator|<<
literal|"title():"
operator|<<
name|title
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|cleanId
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!   Prints the inner node's list of children.   For debugging only.  */
end_comment
begin_function
DECL|function|printChildren
name|void
name|InnerNode
operator|::
name|printChildren
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|qDebug
argument_list|()
operator|<<
name|title
operator|<<
name|name
argument_list|()
operator|<<
name|children_
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|children_
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|children_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"  CHILD:"
operator|<<
name|n
operator|->
name|name
argument_list|()
operator|<<
name|n
operator|->
name|nodeTypeString
argument_list|()
operator|<<
name|n
operator|->
name|nodeSubtypeString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Prints the inner node's list of members.   For debugging only.  */
end_comment
begin_function
DECL|function|printMembers
name|void
name|InnerNode
operator|::
name|printMembers
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|qDebug
argument_list|()
operator|<<
name|title
operator|<<
name|name
argument_list|()
operator|<<
name|members_
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|members_
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|members_
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|members_
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"  MEMBER:"
operator|<<
name|n
operator|->
name|name
argument_list|()
operator|<<
name|n
operator|->
name|nodeTypeString
argument_list|()
operator|<<
name|n
operator|->
name|nodeSubtypeString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
