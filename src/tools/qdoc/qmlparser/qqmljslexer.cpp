begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtQml module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qqmljslexer_p.h"
end_include
begin_include
include|#
directive|include
file|"qqmljsengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qqmljsmemorypool_p.h"
end_include
begin_include
include|#
directive|include
file|"qqmljskeywords_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_CORE_EXPORT
name|double
name|qstrtod
parameter_list|(
specifier|const
name|char
modifier|*
name|s00
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|se
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
function_decl|;
end_function_decl
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_using
using|using
namespace|namespace
name|QQmlJS
namespace|;
end_using
begin_function
DECL|function|regExpFlagFromChar
specifier|static
specifier|inline
name|int
name|regExpFlagFromChar
parameter_list|(
specifier|const
name|QChar
modifier|&
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'g'
case|:
return|return
name|Lexer
operator|::
name|RegExp_Global
return|;
case|case
literal|'i'
case|:
return|return
name|Lexer
operator|::
name|RegExp_IgnoreCase
return|;
case|case
literal|'m'
case|:
return|return
name|Lexer
operator|::
name|RegExp_Multiline
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|convertHex
specifier|static
specifier|inline
name|unsigned
name|char
name|convertHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
else|else
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
block|}
end_function
begin_function
DECL|function|convertHex
specifier|static
specifier|inline
name|QChar
name|convertHex
parameter_list|(
name|QChar
name|c1
parameter_list|,
name|QChar
name|c2
parameter_list|)
block|{
return|return
name|QChar
argument_list|(
operator|(
name|convertHex
argument_list|(
name|c1
operator|.
name|unicode
argument_list|()
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|convertHex
argument_list|(
name|c2
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertUnicode
specifier|static
specifier|inline
name|QChar
name|convertUnicode
parameter_list|(
name|QChar
name|c1
parameter_list|,
name|QChar
name|c2
parameter_list|,
name|QChar
name|c3
parameter_list|,
name|QChar
name|c4
parameter_list|)
block|{
return|return
name|QChar
argument_list|(
operator|(
name|convertHex
argument_list|(
name|c3
operator|.
name|unicode
argument_list|()
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|convertHex
argument_list|(
name|c4
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|,
operator|(
name|convertHex
argument_list|(
name|c1
operator|.
name|unicode
argument_list|()
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|convertHex
argument_list|(
name|c2
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|Lexer
name|Lexer
operator|::
name|Lexer
parameter_list|(
name|Engine
modifier|*
name|engine
parameter_list|)
member_init_list|:
name|_engine
argument_list|(
name|engine
argument_list|)
member_init_list|,
name|_codePtr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_lastLinePtr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenLinePtr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenStartPtr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_char
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
member_init_list|,
name|_errorCode
argument_list|(
name|NoError
argument_list|)
member_init_list|,
name|_currentLineNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenValue
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_parenthesesState
argument_list|(
name|IgnoreParentheses
argument_list|)
member_init_list|,
name|_parenthesesCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_stackToken
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|_patternFlags
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenKind
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_tokenLine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|_validTokenText
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_prohibitAutomaticSemicolon
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_restrictedKeyword
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_terminator
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_followsClosingBrace
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_delimited
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|_qmlMode
argument_list|(
literal|true
argument_list|)
block|{
if|if
condition|(
name|engine
condition|)
name|engine
operator|->
name|setLexer
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|qmlMode
name|bool
name|Lexer
operator|::
name|qmlMode
parameter_list|()
specifier|const
block|{
return|return
name|_qmlMode
return|;
block|}
end_function
begin_function
DECL|function|code
name|QString
name|Lexer
operator|::
name|code
parameter_list|()
specifier|const
block|{
return|return
name|_code
return|;
block|}
end_function
begin_function
DECL|function|setCode
name|void
name|Lexer
operator|::
name|setCode
parameter_list|(
specifier|const
name|QString
modifier|&
name|code
parameter_list|,
name|int
name|lineno
parameter_list|,
name|bool
name|qmlMode
parameter_list|)
block|{
if|if
condition|(
name|_engine
condition|)
name|_engine
operator|->
name|setCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|_qmlMode
operator|=
name|qmlMode
expr_stmt|;
name|_code
operator|=
name|code
expr_stmt|;
name|_tokenText
operator|.
name|clear
argument_list|()
expr_stmt|;
name|_tokenText
operator|.
name|reserve
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|_errorMessage
operator|.
name|clear
argument_list|()
expr_stmt|;
name|_tokenSpell
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
name|_codePtr
operator|=
name|code
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|_endPtr
operator|=
name|_codePtr
operator|+
name|code
operator|.
name|length
argument_list|()
expr_stmt|;
name|_lastLinePtr
operator|=
name|_codePtr
expr_stmt|;
name|_tokenLinePtr
operator|=
name|_codePtr
expr_stmt|;
name|_tokenStartPtr
operator|=
name|_codePtr
expr_stmt|;
name|_char
operator|=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|_errorCode
operator|=
name|NoError
expr_stmt|;
name|_currentLineNumber
operator|=
name|lineno
expr_stmt|;
name|_tokenValue
operator|=
literal|0
expr_stmt|;
comment|// parentheses state
name|_parenthesesState
operator|=
name|IgnoreParentheses
expr_stmt|;
name|_parenthesesCount
operator|=
literal|0
expr_stmt|;
name|_stackToken
operator|=
operator|-
literal|1
expr_stmt|;
name|_patternFlags
operator|=
literal|0
expr_stmt|;
name|_tokenLength
operator|=
literal|0
expr_stmt|;
name|_tokenLine
operator|=
name|lineno
expr_stmt|;
name|_validTokenText
operator|=
literal|false
expr_stmt|;
name|_prohibitAutomaticSemicolon
operator|=
literal|false
expr_stmt|;
name|_restrictedKeyword
operator|=
literal|false
expr_stmt|;
name|_terminator
operator|=
literal|false
expr_stmt|;
name|_followsClosingBrace
operator|=
literal|false
expr_stmt|;
name|_delimited
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|scanChar
name|void
name|Lexer
operator|::
name|scanChar
parameter_list|()
block|{
name|unsigned
name|sequenceLength
init|=
name|isLineTerminatorSequence
argument_list|()
decl_stmt|;
name|_char
operator|=
operator|*
name|_codePtr
operator|++
expr_stmt|;
if|if
condition|(
name|sequenceLength
operator|==
literal|2
condition|)
name|_char
operator|=
operator|*
name|_codePtr
operator|++
expr_stmt|;
if|if
condition|(
name|unsigned
name|sequenceLength
init|=
name|isLineTerminatorSequence
argument_list|()
condition|)
block|{
name|_lastLinePtr
operator|=
name|_codePtr
operator|+
name|sequenceLength
operator|-
literal|1
expr_stmt|;
comment|// points to the first character after the newline
operator|++
name|_currentLineNumber
expr_stmt|;
block|}
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|isBinop
specifier|inline
name|bool
name|isBinop
parameter_list|(
name|int
name|tok
parameter_list|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|Lexer
operator|::
name|T_AND
case|:
case|case
name|Lexer
operator|::
name|T_AND_AND
case|:
case|case
name|Lexer
operator|::
name|T_AND_EQ
case|:
case|case
name|Lexer
operator|::
name|T_DIVIDE_
case|:
case|case
name|Lexer
operator|::
name|T_DIVIDE_EQ
case|:
case|case
name|Lexer
operator|::
name|T_EQ
case|:
case|case
name|Lexer
operator|::
name|T_EQ_EQ
case|:
case|case
name|Lexer
operator|::
name|T_EQ_EQ_EQ
case|:
case|case
name|Lexer
operator|::
name|T_GE
case|:
case|case
name|Lexer
operator|::
name|T_GT
case|:
case|case
name|Lexer
operator|::
name|T_GT_GT
case|:
case|case
name|Lexer
operator|::
name|T_GT_GT_EQ
case|:
case|case
name|Lexer
operator|::
name|T_GT_GT_GT
case|:
case|case
name|Lexer
operator|::
name|T_GT_GT_GT_EQ
case|:
case|case
name|Lexer
operator|::
name|T_LE
case|:
case|case
name|Lexer
operator|::
name|T_LT
case|:
case|case
name|Lexer
operator|::
name|T_LT_LT
case|:
case|case
name|Lexer
operator|::
name|T_LT_LT_EQ
case|:
case|case
name|Lexer
operator|::
name|T_MINUS
case|:
case|case
name|Lexer
operator|::
name|T_MINUS_EQ
case|:
case|case
name|Lexer
operator|::
name|T_NOT_EQ
case|:
case|case
name|Lexer
operator|::
name|T_NOT_EQ_EQ
case|:
case|case
name|Lexer
operator|::
name|T_OR
case|:
case|case
name|Lexer
operator|::
name|T_OR_EQ
case|:
case|case
name|Lexer
operator|::
name|T_OR_OR
case|:
case|case
name|Lexer
operator|::
name|T_PLUS
case|:
case|case
name|Lexer
operator|::
name|T_PLUS_EQ
case|:
case|case
name|Lexer
operator|::
name|T_REMAINDER
case|:
case|case
name|Lexer
operator|::
name|T_REMAINDER_EQ
case|:
case|case
name|Lexer
operator|::
name|T_RETURN
case|:
case|case
name|Lexer
operator|::
name|T_STAR
case|:
case|case
name|Lexer
operator|::
name|T_STAR_EQ
case|:
case|case
name|Lexer
operator|::
name|T_XOR
case|:
case|case
name|Lexer
operator|::
name|T_XOR_EQ
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
block|}
end_namespace
begin_comment
comment|// anonymous namespace
end_comment
begin_function
DECL|function|lex
name|int
name|Lexer
operator|::
name|lex
parameter_list|()
block|{
specifier|const
name|int
name|previousTokenKind
init|=
name|_tokenKind
decl_stmt|;
name|_tokenSpell
operator|=
name|QStringRef
argument_list|()
expr_stmt|;
name|_tokenKind
operator|=
name|scanToken
argument_list|()
expr_stmt|;
name|_tokenLength
operator|=
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
expr_stmt|;
name|_delimited
operator|=
literal|false
expr_stmt|;
name|_restrictedKeyword
operator|=
literal|false
expr_stmt|;
name|_followsClosingBrace
operator|=
operator|(
name|previousTokenKind
operator|==
name|T_RBRACE
operator|)
expr_stmt|;
comment|// update the flags
switch|switch
condition|(
name|_tokenKind
condition|)
block|{
case|case
name|T_LBRACE
case|:
case|case
name|T_SEMICOLON
case|:
case|case
name|T_QUESTION
case|:
case|case
name|T_COLON
case|:
case|case
name|T_TILDE
case|:
name|_delimited
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isBinop
argument_list|(
name|_tokenKind
argument_list|)
condition|)
name|_delimited
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|T_IF
case|:
case|case
name|T_FOR
case|:
case|case
name|T_WHILE
case|:
case|case
name|T_WITH
case|:
name|_parenthesesState
operator|=
name|CountParentheses
expr_stmt|;
name|_parenthesesCount
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_DO
case|:
name|_parenthesesState
operator|=
name|BalancedParentheses
expr_stmt|;
break|break;
case|case
name|T_CONTINUE
case|:
case|case
name|T_BREAK
case|:
case|case
name|T_RETURN
case|:
case|case
name|T_THROW
case|:
name|_restrictedKeyword
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// switch
comment|// update the parentheses state
switch|switch
condition|(
name|_parenthesesState
condition|)
block|{
case|case
name|IgnoreParentheses
case|:
break|break;
case|case
name|CountParentheses
case|:
if|if
condition|(
name|_tokenKind
operator|==
name|T_RPAREN
condition|)
block|{
operator|--
name|_parenthesesCount
expr_stmt|;
if|if
condition|(
name|_parenthesesCount
operator|==
literal|0
condition|)
name|_parenthesesState
operator|=
name|BalancedParentheses
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_tokenKind
operator|==
name|T_LPAREN
condition|)
block|{
operator|++
name|_parenthesesCount
expr_stmt|;
block|}
break|break;
case|case
name|BalancedParentheses
case|:
if|if
condition|(
name|_tokenKind
operator|!=
name|T_DO
operator|&&
name|_tokenKind
operator|!=
name|T_ELSE
condition|)
name|_parenthesesState
operator|=
name|IgnoreParentheses
expr_stmt|;
break|break;
block|}
comment|// switch
return|return
name|_tokenKind
return|;
block|}
end_function
begin_function
DECL|function|isUnicodeEscapeSequence
name|bool
name|Lexer
operator|::
name|isUnicodeEscapeSequence
parameter_list|(
specifier|const
name|QChar
modifier|*
name|chars
parameter_list|)
block|{
if|if
condition|(
name|isHexDigit
argument_list|(
name|chars
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|chars
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|chars
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|chars
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|decodeUnicodeEscapeCharacter
name|QChar
name|Lexer
operator|::
name|decodeUnicodeEscapeCharacter
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'u'
argument_list|)
operator|&&
name|isUnicodeEscapeSequence
argument_list|(
operator|&
name|_codePtr
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
comment|// skip u
specifier|const
name|QChar
name|c1
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
specifier|const
name|QChar
name|c2
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
specifier|const
name|QChar
name|c3
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
specifier|const
name|QChar
name|c4
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|convertUnicode
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c3
argument_list|,
name|c4
argument_list|)
return|;
block|}
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QChar
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|decodeHexEscapeCharacter
name|QChar
name|Lexer
operator|::
name|decodeHexEscapeCharacter
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|isHexDigit
argument_list|(
name|_codePtr
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|_codePtr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
specifier|const
name|QChar
name|c1
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
specifier|const
name|QChar
name|c2
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|convertHex
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
block|}
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QChar
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isIdentifierStart
specifier|static
specifier|inline
name|bool
name|isIdentifierStart
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
comment|// fast path for ascii
if|if
condition|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|<=
literal|'Z'
operator|)
operator|||
name|ch
operator|==
literal|'$'
operator|||
name|ch
operator|==
literal|'_'
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|ch
operator|.
name|category
argument_list|()
condition|)
block|{
case|case
name|QChar
operator|::
name|Number_Letter
case|:
case|case
name|QChar
operator|::
name|Letter_Uppercase
case|:
case|case
name|QChar
operator|::
name|Letter_Lowercase
case|:
case|case
name|QChar
operator|::
name|Letter_Titlecase
case|:
case|case
name|QChar
operator|::
name|Letter_Modifier
case|:
case|case
name|QChar
operator|::
name|Letter_Other
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isIdentifierPart
specifier|static
name|bool
name|isIdentifierPart
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
comment|// fast path for ascii
if|if
condition|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>=
literal|'0'
operator|&&
name|ch
operator|.
name|unicode
argument_list|()
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'$'
operator|||
name|ch
operator|==
literal|'_'
operator|||
name|ch
operator|.
name|unicode
argument_list|()
operator|==
literal|0x200c
comment|/* ZWNJ */
operator|||
name|ch
operator|.
name|unicode
argument_list|()
operator|==
literal|0x200d
comment|/* ZWJ */
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|ch
operator|.
name|category
argument_list|()
condition|)
block|{
case|case
name|QChar
operator|::
name|Mark_NonSpacing
case|:
case|case
name|QChar
operator|::
name|Mark_SpacingCombining
case|:
case|case
name|QChar
operator|::
name|Number_DecimalDigit
case|:
case|case
name|QChar
operator|::
name|Number_Letter
case|:
case|case
name|QChar
operator|::
name|Letter_Uppercase
case|:
case|case
name|QChar
operator|::
name|Letter_Lowercase
case|:
case|case
name|QChar
operator|::
name|Letter_Titlecase
case|:
case|case
name|QChar
operator|::
name|Letter_Modifier
case|:
case|case
name|QChar
operator|::
name|Letter_Other
case|:
case|case
name|QChar
operator|::
name|Punctuation_Connector
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanToken
name|int
name|Lexer
operator|::
name|scanToken
parameter_list|()
block|{
if|if
condition|(
name|_stackToken
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|tk
init|=
name|_stackToken
decl_stmt|;
name|_stackToken
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|tk
return|;
block|}
name|_terminator
operator|=
literal|false
expr_stmt|;
name|again
label|:
name|_validTokenText
operator|=
literal|false
expr_stmt|;
name|_tokenLinePtr
operator|=
name|_lastLinePtr
expr_stmt|;
while|while
condition|(
name|_char
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|unsigned
name|sequenceLength
init|=
name|isLineTerminatorSequence
argument_list|()
condition|)
block|{
name|_tokenLinePtr
operator|=
name|_codePtr
operator|+
name|sequenceLength
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|_restrictedKeyword
condition|)
block|{
comment|// automatic semicolon insertion
name|_tokenLine
operator|=
name|_currentLineNumber
expr_stmt|;
name|_tokenStartPtr
operator|=
name|_codePtr
operator|-
literal|1
expr_stmt|;
return|return
name|T_SEMICOLON
return|;
block|}
else|else
block|{
name|_terminator
operator|=
literal|true
expr_stmt|;
name|syncProhibitAutomaticSemicolon
argument_list|()
expr_stmt|;
block|}
block|}
name|scanChar
argument_list|()
expr_stmt|;
block|}
name|_tokenStartPtr
operator|=
name|_codePtr
operator|-
literal|1
expr_stmt|;
name|_tokenLine
operator|=
name|_currentLineNumber
expr_stmt|;
if|if
condition|(
name|_codePtr
operator|>
name|_endPtr
condition|)
return|return
name|EOF_SYMBOL
return|;
specifier|const
name|QChar
name|ch
init|=
name|_char
decl_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'~'
case|:
return|return
name|T_TILDE
return|;
case|case
literal|'}'
case|:
return|return
name|T_RBRACE
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_OR_OR
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_OR_EQ
return|;
block|}
return|return
name|T_OR
return|;
case|case
literal|'{'
case|:
return|return
name|T_LBRACE
return|;
case|case
literal|'^'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_XOR_EQ
return|;
block|}
return|return
name|T_XOR
return|;
case|case
literal|']'
case|:
return|return
name|T_RBRACKET
return|;
case|case
literal|'['
case|:
return|return
name|T_LBRACKET
return|;
case|case
literal|'?'
case|:
return|return
name|T_QUESTION
return|;
case|case
literal|'>'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_GT_GT_GT_EQ
return|;
block|}
return|return
name|T_GT_GT_GT
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_GT_GT_EQ
return|;
block|}
return|return
name|T_GT_GT
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_GE
return|;
block|}
return|return
name|T_GT
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_EQ_EQ_EQ
return|;
block|}
return|return
name|T_EQ_EQ
return|;
block|}
return|return
name|T_EQ
return|;
case|case
literal|'<'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_LE
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_LT_LT_EQ
return|;
block|}
return|return
name|T_LT_LT
return|;
block|}
return|return
name|T_LT
return|;
case|case
literal|';'
case|:
return|return
name|T_SEMICOLON
return|;
case|case
literal|':'
case|:
return|return
name|T_COLON
return|;
case|case
literal|'/'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|_codePtr
operator|<=
name|_endPtr
condition|)
block|{
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_engine
condition|)
block|{
name|_engine
operator|->
name|addComment
argument_list|(
name|tokenOffset
argument_list|()
operator|+
literal|2
argument_list|,
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
operator|-
literal|4
argument_list|,
name|tokenStartLine
argument_list|()
argument_list|,
name|tokenStartColumn
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
goto|goto
name|again
goto|;
block|}
block|}
else|else
block|{
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
while|while
condition|(
name|_codePtr
operator|<=
name|_endPtr
operator|&&
operator|!
name|isLineTerminator
argument_list|()
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_engine
condition|)
block|{
name|_engine
operator|->
name|addComment
argument_list|(
name|tokenOffset
argument_list|()
operator|+
literal|2
argument_list|,
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
operator|-
literal|2
argument_list|,
name|tokenStartLine
argument_list|()
argument_list|,
name|tokenStartColumn
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_DIVIDE_EQ
return|;
block|}
return|return
name|T_DIVIDE_
return|;
case|case
literal|'.'
case|:
if|if
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|32
argument_list|>
name|chars
decl_stmt|;
name|chars
operator|.
name|append
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
comment|// append the `.'
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_codePtr
index|[
literal|0
index|]
operator|.
name|isDigit
argument_list|()
operator|||
operator|(
operator|(
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|)
operator|&&
name|_codePtr
index|[
literal|1
index|]
operator|.
name|isDigit
argument_list|()
operator|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume `e'
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume the sign
block|}
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|chars
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|begin
init|=
name|chars
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
literal|0
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|_tokenValue
operator|=
name|qstrtod
argument_list|(
name|begin
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|begin
operator|!=
name|chars
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|_errorCode
operator|=
name|IllegalExponentIndicator
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal syntax for exponential number"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
return|return
name|T_NUMERIC_LITERAL
return|;
block|}
return|return
name|T_DOT
return|;
case|case
literal|'-'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_MINUS_EQ
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_terminator
operator|&&
operator|!
name|_delimited
operator|&&
operator|!
name|_prohibitAutomaticSemicolon
condition|)
block|{
name|_stackToken
operator|=
name|T_MINUS_MINUS
expr_stmt|;
return|return
name|T_SEMICOLON
return|;
block|}
return|return
name|T_MINUS_MINUS
return|;
block|}
return|return
name|T_MINUS
return|;
case|case
literal|','
case|:
return|return
name|T_COMMA
return|;
case|case
literal|'+'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_PLUS_EQ
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_terminator
operator|&&
operator|!
name|_delimited
operator|&&
operator|!
name|_prohibitAutomaticSemicolon
condition|)
block|{
name|_stackToken
operator|=
name|T_PLUS_PLUS
expr_stmt|;
return|return
name|T_SEMICOLON
return|;
block|}
return|return
name|T_PLUS_PLUS
return|;
block|}
return|return
name|T_PLUS
return|;
case|case
literal|'*'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_STAR_EQ
return|;
block|}
return|return
name|T_STAR
return|;
case|case
literal|')'
case|:
return|return
name|T_RPAREN
return|;
case|case
literal|'('
case|:
return|return
name|T_LPAREN
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_AND_EQ
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_AND_AND
return|;
block|}
return|return
name|T_AND
return|;
case|case
literal|'%'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_REMAINDER_EQ
return|;
block|}
return|return
name|T_REMAINDER
return|;
case|case
literal|'!'
case|:
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_NOT_EQ_EQ
return|;
block|}
return|return
name|T_NOT_EQ
return|;
block|}
return|return
name|T_NOT
return|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
specifier|const
name|QChar
name|quote
init|=
name|ch
decl_stmt|;
name|bool
name|multilineStringLiteral
init|=
literal|false
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|startCode
init|=
name|_codePtr
decl_stmt|;
if|if
condition|(
name|_engine
condition|)
block|{
while|while
condition|(
name|_codePtr
operator|<=
name|_endPtr
condition|)
block|{
if|if
condition|(
name|isLineTerminator
argument_list|()
condition|)
block|{
if|if
condition|(
name|qmlMode
argument_list|()
condition|)
break|break;
name|_errorCode
operator|=
name|IllegalCharacter
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Stray newline in string literal"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|quote
condition|)
block|{
name|_tokenSpell
operator|=
name|_engine
operator|->
name|midRef
argument_list|(
name|startCode
operator|-
name|_code
operator|.
name|unicode
argument_list|()
operator|-
literal|1
argument_list|,
name|_codePtr
operator|-
name|startCode
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
return|return
name|T_STRING_LITERAL
return|;
block|}
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
name|_validTokenText
operator|=
literal|true
expr_stmt|;
name|_tokenText
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|startCode
operator|--
expr_stmt|;
while|while
condition|(
name|startCode
operator|!=
name|_codePtr
operator|-
literal|1
condition|)
name|_tokenText
operator|+=
operator|*
name|startCode
operator|++
expr_stmt|;
while|while
condition|(
name|_codePtr
operator|<=
name|_endPtr
condition|)
block|{
if|if
condition|(
name|unsigned
name|sequenceLength
init|=
name|isLineTerminatorSequence
argument_list|()
condition|)
block|{
name|multilineStringLiteral
operator|=
literal|true
expr_stmt|;
name|_tokenText
operator|+=
name|_char
expr_stmt|;
if|if
condition|(
name|sequenceLength
operator|==
literal|2
condition|)
name|_tokenText
operator|+=
operator|*
name|_codePtr
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|quote
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_engine
condition|)
name|_tokenSpell
operator|=
name|_engine
operator|->
name|newStringRef
argument_list|(
name|_tokenText
argument_list|)
expr_stmt|;
return|return
name|multilineStringLiteral
condition|?
name|T_MULTILINE_STRING_LITERAL
else|:
name|T_STRING_LITERAL
return|;
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
name|QChar
name|u
decl_stmt|;
switch|switch
condition|(
name|_char
operator|.
name|unicode
argument_list|()
condition|)
block|{
comment|// unicode escape sequence
case|case
literal|'u'
case|:
block|{
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|u
operator|=
name|decodeUnicodeEscapeCharacter
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|_errorCode
operator|=
name|IllegalUnicodeEscapeSequence
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal unicode escape sequence"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
block|}
break|break;
comment|// hex escape sequence
case|case
literal|'x'
case|:
block|{
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|u
operator|=
name|decodeHexEscapeCharacter
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|_errorCode
operator|=
name|IllegalHexadecimalEscapeSequence
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal hexadecimal escape sequence"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
block|}
break|break;
comment|// single character escape sequence
case|case
literal|'\\'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\v'
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
operator|!
name|_codePtr
operator|->
name|isDigit
argument_list|()
condition|)
block|{
name|scanChar
argument_list|()
expr_stmt|;
name|u
operator|=
name|QLatin1Char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// fall through
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|_errorCode
operator|=
name|IllegalEscapeSequence
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Octal escape sequences are not allowed"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|0x2028u
case|:
case|case
literal|0x2029u
case|:
name|scanChar
argument_list|()
expr_stmt|;
continue|continue;
default|default:
comment|// non escape character
name|u
operator|=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
name|_tokenText
operator|+=
name|u
expr_stmt|;
block|}
else|else
block|{
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
name|_errorCode
operator|=
name|UnclosedStringLiteral
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Unclosed string at end of line"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
return|return
name|scanNumber
argument_list|(
name|ch
argument_list|)
return|;
default|default:
block|{
name|QChar
name|c
init|=
name|ch
decl_stmt|;
name|bool
name|identifierWithEscapeChars
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|&&
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'u'
argument_list|)
condition|)
block|{
name|identifierWithEscapeChars
operator|=
literal|true
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|c
operator|=
name|decodeUnicodeEscapeCharacter
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|_errorCode
operator|=
name|IllegalUnicodeEscapeSequence
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal unicode escape sequence"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
block|}
if|if
condition|(
name|isIdentifierStart
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|identifierWithEscapeChars
condition|)
block|{
name|_tokenText
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_tokenText
operator|+=
name|c
expr_stmt|;
name|_validTokenText
operator|=
literal|true
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|_char
expr_stmt|;
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|&&
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'u'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|identifierWithEscapeChars
condition|)
block|{
name|identifierWithEscapeChars
operator|=
literal|true
expr_stmt|;
name|_tokenText
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_tokenText
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|_tokenStartPtr
argument_list|,
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_validTokenText
operator|=
literal|true
expr_stmt|;
block|}
name|scanChar
argument_list|()
expr_stmt|;
comment|// skip '\\'
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|c
operator|=
name|decodeUnicodeEscapeCharacter
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|_errorCode
operator|=
name|IllegalUnicodeEscapeSequence
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal unicode escape sequence"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
if|if
condition|(
name|isIdentifierPart
argument_list|(
name|c
argument_list|)
condition|)
name|_tokenText
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|isIdentifierPart
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|identifierWithEscapeChars
condition|)
name|_tokenText
operator|+=
name|c
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|_tokenLength
operator|=
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
expr_stmt|;
name|int
name|kind
init|=
name|T_IDENTIFIER
decl_stmt|;
if|if
condition|(
operator|!
name|identifierWithEscapeChars
condition|)
name|kind
operator|=
name|classify
argument_list|(
name|_tokenStartPtr
argument_list|,
name|_tokenLength
argument_list|,
name|_qmlMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|_engine
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|T_IDENTIFIER
operator|&&
name|identifierWithEscapeChars
condition|)
name|_tokenSpell
operator|=
name|_engine
operator|->
name|newStringRef
argument_list|(
name|_tokenText
argument_list|)
expr_stmt|;
else|else
name|_tokenSpell
operator|=
name|_engine
operator|->
name|midRef
argument_list|(
name|_tokenStartPtr
operator|-
name|_code
operator|.
name|unicode
argument_list|()
argument_list|,
name|_tokenLength
argument_list|)
expr_stmt|;
block|}
return|return
name|kind
return|;
block|}
block|}
block|}
break|break;
block|}
return|return
name|T_ERROR
return|;
block|}
end_function
begin_function
DECL|function|scanNumber
name|int
name|Lexer
operator|::
name|scanNumber
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|!=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
block|{
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|64
argument_list|>
name|buf
decl_stmt|;
name|buf
operator|+=
name|ch
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|QChar
name|n
init|=
name|_char
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|code
init|=
name|_codePtr
decl_stmt|;
while|while
condition|(
name|n
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|buf
operator|+=
name|n
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|n
operator|=
operator|*
name|code
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|n
operator|!=
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
operator|&&
name|n
operator|!=
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|_codePtr
condition|)
block|{
name|_codePtr
operator|=
name|code
operator|-
literal|1
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|_tokenValue
operator|=
name|strtod
argument_list|(
name|buf
operator|.
name|constData
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|T_NUMERIC_LITERAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
operator|&&
operator|!
name|qmlMode
argument_list|()
condition|)
block|{
name|_errorCode
operator|=
name|IllegalCharacter
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Decimal numbers can't start with '0'"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|32
argument_list|>
name|chars
decl_stmt|;
name|chars
operator|.
name|append
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
operator|&&
operator|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'X'
argument_list|)
operator|)
condition|)
block|{
name|ch
operator|=
name|_char
expr_stmt|;
comment|// remember the x or X to use it in the error message below.
comment|// parse hex integer literal
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume `x'
while|while
condition|(
name|isHexDigit
argument_list|(
name|_char
argument_list|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|chars
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
name|_errorCode
operator|=
name|IllegalHexNumber
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"At least one hexadecimal digit is required after '0%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
name|_tokenValue
operator|=
name|integerFromString
argument_list|(
name|chars
operator|.
name|constData
argument_list|()
argument_list|,
name|chars
operator|.
name|size
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
name|T_NUMERIC_LITERAL
return|;
block|}
comment|// decimal integer literal
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume the digit
block|}
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume `.'
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_codePtr
index|[
literal|0
index|]
operator|.
name|isDigit
argument_list|()
operator|||
operator|(
operator|(
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|)
operator|&&
name|_codePtr
index|[
literal|1
index|]
operator|.
name|isDigit
argument_list|()
operator|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume `e'
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume the sign
block|}
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_codePtr
index|[
literal|0
index|]
operator|.
name|isDigit
argument_list|()
operator|||
operator|(
operator|(
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_codePtr
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|)
operator|&&
name|_codePtr
index|[
literal|1
index|]
operator|.
name|isDigit
argument_list|()
operator|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume `e'
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// consume the sign
block|}
while|while
condition|(
name|_char
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|chars
operator|.
name|append
argument_list|(
name|_char
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|chars
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// if we ended up with a single digit, then it was a '0'
name|_tokenValue
operator|=
literal|0
expr_stmt|;
return|return
name|T_NUMERIC_LITERAL
return|;
block|}
name|chars
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|begin
init|=
name|chars
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
literal|0
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|_tokenValue
operator|=
name|qstrtod
argument_list|(
name|begin
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|begin
operator|!=
name|chars
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|_errorCode
operator|=
name|IllegalExponentIndicator
expr_stmt|;
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Illegal syntax for exponential number"
argument_list|)
expr_stmt|;
return|return
name|T_ERROR
return|;
block|}
return|return
name|T_NUMERIC_LITERAL
return|;
block|}
end_function
begin_function
DECL|function|scanRegExp
name|bool
name|Lexer
operator|::
name|scanRegExp
parameter_list|(
name|RegExpBodyPrefix
name|prefix
parameter_list|)
block|{
name|_tokenText
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_validTokenText
operator|=
literal|true
expr_stmt|;
name|_patternFlags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
name|EqualPrefix
condition|)
name|_tokenText
operator|+=
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
switch|switch
condition|(
name|_char
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'/'
case|:
name|scanChar
argument_list|()
expr_stmt|;
comment|// scan the flags
name|_patternFlags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isIdentLetter
argument_list|(
name|_char
argument_list|)
condition|)
block|{
name|int
name|flag
init|=
name|regExpFlagFromChar
argument_list|(
name|_char
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
operator|||
name|_patternFlags
operator|&
name|flag
condition|)
block|{
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Invalid regular expression flag '%0'"
argument_list|)
operator|.
name|arg
argument_list|(
name|QChar
argument_list|(
name|_char
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|_patternFlags
operator||=
name|flag
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
name|_tokenLength
operator|=
name|_codePtr
operator|-
name|_tokenStartPtr
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
case|case
literal|'\\'
case|:
comment|// regular expression backslash sequence
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_codePtr
operator|>
name|_endPtr
operator|||
name|isLineTerminator
argument_list|()
condition|)
block|{
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Unterminated regular expression backslash sequence"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|// regular expression class
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|_codePtr
operator|<=
name|_endPtr
operator|&&
operator|!
name|isLineTerminator
argument_list|()
condition|)
block|{
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|_char
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
comment|// regular expression backslash sequence
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|_codePtr
operator|>
name|_endPtr
operator|||
name|isLineTerminator
argument_list|()
condition|)
block|{
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Unterminated regular expression backslash sequence"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_char
operator|!=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Unterminated regular expression class"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
comment|// skip ]
break|break;
default|default:
if|if
condition|(
name|_codePtr
operator|>
name|_endPtr
operator|||
name|isLineTerminator
argument_list|()
condition|)
block|{
name|_errorMessage
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Unterminated regular expression literal"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|_tokenText
operator|+=
name|_char
expr_stmt|;
name|scanChar
argument_list|()
expr_stmt|;
block|}
block|}
comment|// switch
block|}
comment|// while
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isLineTerminator
name|bool
name|Lexer
operator|::
name|isLineTerminator
parameter_list|()
specifier|const
block|{
specifier|const
name|ushort
name|unicode
init|=
name|_char
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
name|unicode
operator|==
literal|0x000Au
operator|||
name|unicode
operator|==
literal|0x000Du
operator|||
name|unicode
operator|==
literal|0x2028u
operator|||
name|unicode
operator|==
literal|0x2029u
return|;
block|}
end_function
begin_function
DECL|function|isLineTerminatorSequence
name|unsigned
name|Lexer
operator|::
name|isLineTerminatorSequence
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|_char
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|0x000Au
case|:
case|case
literal|0x2028u
case|:
case|case
literal|0x2029u
case|:
return|return
literal|1
return|;
case|case
literal|0x000Du
case|:
if|if
condition|(
name|_codePtr
operator|->
name|unicode
argument_list|()
operator|==
literal|0x000Au
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|isIdentLetter
name|bool
name|Lexer
operator|::
name|isIdentLetter
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
comment|// ASCII-biased, since all reserved words are ASCII, aand hence the
comment|// bulk of content to be parsed.
if|if
condition|(
operator|(
name|ch
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|ch
operator|<=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
operator|)
operator|||
operator|(
name|ch
operator|>=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
operator|&&
name|ch
operator|<=
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
operator|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'$'
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|ch
operator|.
name|unicode
argument_list|()
operator|<
literal|128
condition|)
return|return
literal|false
return|;
return|return
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isDecimalDigit
name|bool
name|Lexer
operator|::
name|isDecimalDigit
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isHexDigit
name|bool
name|Lexer
operator|::
name|isHexDigit
parameter_list|(
name|QChar
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|c
operator|>=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
operator|&&
name|c
operator|<=
name|QLatin1Char
argument_list|(
literal|'9'
argument_list|)
operator|)
operator|||
operator|(
name|c
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|c
operator|<=
name|QLatin1Char
argument_list|(
literal|'f'
argument_list|)
operator|)
operator|||
operator|(
name|c
operator|>=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
operator|&&
name|c
operator|<=
name|QLatin1Char
argument_list|(
literal|'F'
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isOctalDigit
name|bool
name|Lexer
operator|::
name|isOctalDigit
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|tokenEndLine
name|int
name|Lexer
operator|::
name|tokenEndLine
parameter_list|()
specifier|const
block|{
return|return
name|_currentLineNumber
return|;
block|}
end_function
begin_function
DECL|function|tokenEndColumn
name|int
name|Lexer
operator|::
name|tokenEndColumn
parameter_list|()
specifier|const
block|{
return|return
name|_codePtr
operator|-
name|_lastLinePtr
return|;
block|}
end_function
begin_function
DECL|function|tokenText
name|QString
name|Lexer
operator|::
name|tokenText
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|_validTokenText
condition|)
return|return
name|_tokenText
return|;
if|if
condition|(
name|_tokenKind
operator|==
name|T_STRING_LITERAL
condition|)
return|return
name|QString
argument_list|(
name|_tokenStartPtr
operator|+
literal|1
argument_list|,
name|_tokenLength
operator|-
literal|2
argument_list|)
return|;
return|return
name|QString
argument_list|(
name|_tokenStartPtr
argument_list|,
name|_tokenLength
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|errorCode
name|Lexer
operator|::
name|Error
name|Lexer
operator|::
name|errorCode
parameter_list|()
specifier|const
block|{
return|return
name|_errorCode
return|;
block|}
end_function
begin_function
DECL|function|errorMessage
name|QString
name|Lexer
operator|::
name|errorMessage
parameter_list|()
specifier|const
block|{
return|return
name|_errorMessage
return|;
block|}
end_function
begin_function
DECL|function|syncProhibitAutomaticSemicolon
name|void
name|Lexer
operator|::
name|syncProhibitAutomaticSemicolon
parameter_list|()
block|{
if|if
condition|(
name|_parenthesesState
operator|==
name|BalancedParentheses
condition|)
block|{
comment|// we have seen something like "if (foo)", which means we should
comment|// never insert an automatic semicolon at this point, since it would
comment|// then be expanded into an empty statement (ECMA-262 7.9.1)
name|_prohibitAutomaticSemicolon
operator|=
literal|true
expr_stmt|;
name|_parenthesesState
operator|=
name|IgnoreParentheses
expr_stmt|;
block|}
else|else
block|{
name|_prohibitAutomaticSemicolon
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|prevTerminator
name|bool
name|Lexer
operator|::
name|prevTerminator
parameter_list|()
specifier|const
block|{
return|return
name|_terminator
return|;
block|}
end_function
begin_function
DECL|function|followsClosingBrace
name|bool
name|Lexer
operator|::
name|followsClosingBrace
parameter_list|()
specifier|const
block|{
return|return
name|_followsClosingBrace
return|;
block|}
end_function
begin_function
DECL|function|canInsertAutomaticSemicolon
name|bool
name|Lexer
operator|::
name|canInsertAutomaticSemicolon
parameter_list|(
name|int
name|token
parameter_list|)
specifier|const
block|{
return|return
name|token
operator|==
name|T_RBRACE
operator|||
name|token
operator|==
name|EOF_SYMBOL
operator|||
name|_terminator
operator|||
name|_followsClosingBrace
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|uriTokens
specifier|static
specifier|const
name|int
name|uriTokens
index|[]
init|=
block|{
name|QQmlJSGrammar
operator|::
name|T_IDENTIFIER
block|,
name|QQmlJSGrammar
operator|::
name|T_PROPERTY
block|,
name|QQmlJSGrammar
operator|::
name|T_SIGNAL
block|,
name|QQmlJSGrammar
operator|::
name|T_READONLY
block|,
name|QQmlJSGrammar
operator|::
name|T_ON
block|,
name|QQmlJSGrammar
operator|::
name|T_BREAK
block|,
name|QQmlJSGrammar
operator|::
name|T_CASE
block|,
name|QQmlJSGrammar
operator|::
name|T_CATCH
block|,
name|QQmlJSGrammar
operator|::
name|T_CONTINUE
block|,
name|QQmlJSGrammar
operator|::
name|T_DEFAULT
block|,
name|QQmlJSGrammar
operator|::
name|T_DELETE
block|,
name|QQmlJSGrammar
operator|::
name|T_DO
block|,
name|QQmlJSGrammar
operator|::
name|T_ELSE
block|,
name|QQmlJSGrammar
operator|::
name|T_FALSE
block|,
name|QQmlJSGrammar
operator|::
name|T_FINALLY
block|,
name|QQmlJSGrammar
operator|::
name|T_FOR
block|,
name|QQmlJSGrammar
operator|::
name|T_FUNCTION
block|,
name|QQmlJSGrammar
operator|::
name|T_IF
block|,
name|QQmlJSGrammar
operator|::
name|T_IN
block|,
name|QQmlJSGrammar
operator|::
name|T_INSTANCEOF
block|,
name|QQmlJSGrammar
operator|::
name|T_NEW
block|,
name|QQmlJSGrammar
operator|::
name|T_NULL
block|,
name|QQmlJSGrammar
operator|::
name|T_RETURN
block|,
name|QQmlJSGrammar
operator|::
name|T_SWITCH
block|,
name|QQmlJSGrammar
operator|::
name|T_THIS
block|,
name|QQmlJSGrammar
operator|::
name|T_THROW
block|,
name|QQmlJSGrammar
operator|::
name|T_TRUE
block|,
name|QQmlJSGrammar
operator|::
name|T_TRY
block|,
name|QQmlJSGrammar
operator|::
name|T_TYPEOF
block|,
name|QQmlJSGrammar
operator|::
name|T_VAR
block|,
name|QQmlJSGrammar
operator|::
name|T_VOID
block|,
name|QQmlJSGrammar
operator|::
name|T_WHILE
block|,
name|QQmlJSGrammar
operator|::
name|T_CONST
block|,
name|QQmlJSGrammar
operator|::
name|T_DEBUGGER
block|,
name|QQmlJSGrammar
operator|::
name|T_RESERVED_WORD
block|,
name|QQmlJSGrammar
operator|::
name|T_WITH
block|,
name|QQmlJSGrammar
operator|::
name|EOF_SYMBOL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isUriToken
specifier|static
specifier|inline
name|bool
name|isUriToken
parameter_list|(
name|int
name|token
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|current
init|=
name|uriTokens
decl_stmt|;
while|while
condition|(
operator|*
name|current
operator|!=
name|QQmlJSGrammar
operator|::
name|EOF_SYMBOL
condition|)
block|{
if|if
condition|(
operator|*
name|current
operator|==
name|token
condition|)
return|return
literal|true
return|;
operator|++
name|current
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanDirectives
name|bool
name|Lexer
operator|::
name|scanDirectives
parameter_list|(
name|Directives
modifier|*
name|directives
parameter_list|,
name|DiagnosticMessage
modifier|*
name|error
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|_qmlMode
argument_list|)
expr_stmt|;
name|lex
argument_list|()
expr_stmt|;
comment|// fetch the first token
if|if
condition|(
name|_tokenKind
operator|!=
name|T_DOT
condition|)
return|return
literal|true
return|;
do|do
block|{
specifier|const
name|int
name|lineNumber
init|=
name|tokenStartLine
argument_list|()
decl_stmt|;
specifier|const
name|int
name|column
init|=
name|tokenStartColumn
argument_list|()
decl_stmt|;
name|lex
argument_list|()
expr_stmt|;
comment|// skip T_DOT
if|if
condition|(
operator|!
operator|(
name|_tokenKind
operator|==
name|T_IDENTIFIER
operator|||
name|_tokenKind
operator|==
name|T_RESERVED_WORD
operator|)
condition|)
return|return
literal|true
return|;
comment|// expected a valid QML/JS directive
specifier|const
name|QString
name|directiveName
init|=
name|tokenText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|directiveName
operator|==
name|QLatin1String
argument_list|(
literal|"pragma"
argument_list|)
operator|||
name|directiveName
operator|==
name|QLatin1String
argument_list|(
literal|"import"
argument_list|)
operator|)
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Syntax error"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// not a valid directive name
block|}
comment|// it must be a pragma or an import directive.
if|if
condition|(
name|directiveName
operator|==
name|QLatin1String
argument_list|(
literal|"pragma"
argument_list|)
condition|)
block|{
comment|// .pragma library
if|if
condition|(
operator|!
operator|(
name|lex
argument_list|()
operator|==
name|T_IDENTIFIER
operator|&&
name|tokenText
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"library"
argument_list|)
operator|)
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Syntax error"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// expected `library
block|}
comment|// we found a .pragma library directive
name|directives
operator|->
name|pragmaLibrary
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|directiveName
operator|==
name|QLatin1String
argument_list|(
literal|"import"
argument_list|)
argument_list|)
expr_stmt|;
name|lex
argument_list|()
expr_stmt|;
comment|// skip .import
name|QString
name|pathOrUri
decl_stmt|;
name|QString
name|version
decl_stmt|;
name|bool
name|fileImport
init|=
literal|false
decl_stmt|;
comment|// file or uri import
if|if
condition|(
name|_tokenKind
operator|==
name|T_STRING_LITERAL
condition|)
block|{
comment|// .import T_STRING_LITERAL as T_IDENTIFIER
name|fileImport
operator|=
literal|true
expr_stmt|;
name|pathOrUri
operator|=
name|tokenText
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pathOrUri
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"js"
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Imported file must be a script"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|_tokenKind
operator|==
name|T_IDENTIFIER
condition|)
block|{
comment|// .import T_IDENTIFIER (. T_IDENTIFIER)* T_NUMERIC_LITERAL as T_IDENTIFIER
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|isUriToken
argument_list|(
name|_tokenKind
argument_list|)
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Invalid module URI"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|pathOrUri
operator|.
name|append
argument_list|(
name|tokenText
argument_list|()
argument_list|)
expr_stmt|;
name|lex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tokenStartLine
argument_list|()
operator|!=
name|lineNumber
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Invalid module URI"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|_tokenKind
operator|!=
name|QQmlJSGrammar
operator|::
name|T_DOT
condition|)
break|break;
name|pathOrUri
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|lex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tokenStartLine
argument_list|()
operator|!=
name|lineNumber
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Invalid module URI"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|_tokenKind
operator|!=
name|T_NUMERIC_LITERAL
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Module import requires a version"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// expected the module version number
block|}
name|version
operator|=
name|tokenText
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// recognize the mandatory `as' followed by the module name
comment|//
if|if
condition|(
operator|!
operator|(
name|lex
argument_list|()
operator|==
name|T_IDENTIFIER
operator|&&
name|tokenText
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"as"
argument_list|)
operator|&&
name|tokenStartLine
argument_list|()
operator|==
name|lineNumber
operator|)
condition|)
block|{
if|if
condition|(
name|fileImport
condition|)
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"File import requires a qualifier"
argument_list|)
expr_stmt|;
else|else
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Module import requires a qualifier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenStartLine
argument_list|()
operator|!=
name|lineNumber
condition|)
block|{
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|lineNumber
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|column
expr_stmt|;
block|}
else|else
block|{
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
comment|// expected `as'
block|}
if|if
condition|(
name|lex
argument_list|()
operator|!=
name|T_IDENTIFIER
operator|||
name|tokenStartLine
argument_list|()
operator|!=
name|lineNumber
condition|)
block|{
if|if
condition|(
name|fileImport
condition|)
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"File import requires a qualifier"
argument_list|)
expr_stmt|;
else|else
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Module import requires a qualifier"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// expected module name
block|}
specifier|const
name|QString
name|module
init|=
name|tokenText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|module
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isUpper
argument_list|()
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Invalid import qualifier"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fileImport
condition|)
name|directives
operator|->
name|importFile
argument_list|(
name|pathOrUri
argument_list|,
name|module
argument_list|,
name|lineNumber
argument_list|,
name|column
argument_list|)
expr_stmt|;
else|else
name|directives
operator|->
name|importModule
argument_list|(
name|pathOrUri
argument_list|,
name|version
argument_list|,
name|module
argument_list|,
name|lineNumber
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tokenStartLine
argument_list|()
operator|!=
name|lineNumber
condition|)
block|{
name|error
operator|->
name|message
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QQmlParser"
argument_list|,
literal|"Syntax error"
argument_list|)
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startLine
operator|=
name|tokenStartLine
argument_list|()
expr_stmt|;
name|error
operator|->
name|loc
operator|.
name|startColumn
operator|=
name|tokenStartColumn
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// the directives cannot span over multiple lines
block|}
comment|// fetch the first token after the .pragma/.import directive
name|lex
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|_tokenKind
operator|==
name|T_DOT
condition|)
do|;
return|return
literal|true
return|;
block|}
end_function
end_unit
