begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_include
include|#
directive|include
file|"qqmljsast_p.h"
end_include
begin_include
include|#
directive|include
file|"qqmljsastfwd_p.h"
end_include
begin_include
include|#
directive|include
file|"qqmljsengine_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"node.h"
end_include
begin_include
include|#
directive|include
file|"codeparser.h"
end_include
begin_include
include|#
directive|include
file|"qmlvisitor.h"
end_include
begin_include
include|#
directive|include
file|"qdocdatabase.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|COMMAND_DEPRECATED
define|#
directive|define
name|COMMAND_DEPRECATED
value|Doc::alias(QLatin1String("deprecated"))
end_define
begin_define
DECL|macro|COMMAND_INGROUP
define|#
directive|define
name|COMMAND_INGROUP
value|Doc::alias(QLatin1String("ingroup"))
end_define
begin_define
DECL|macro|COMMAND_INTERNAL
define|#
directive|define
name|COMMAND_INTERNAL
value|Doc::alias(QLatin1String("internal"))
end_define
begin_define
DECL|macro|COMMAND_OBSOLETE
define|#
directive|define
name|COMMAND_OBSOLETE
value|Doc::alias(QLatin1String("obsolete"))
end_define
begin_define
DECL|macro|COMMAND_PAGEKEYWORDS
define|#
directive|define
name|COMMAND_PAGEKEYWORDS
value|Doc::alias(QLatin1String("pagekeywords"))
end_define
begin_define
DECL|macro|COMMAND_PRELIMINARY
define|#
directive|define
name|COMMAND_PRELIMINARY
value|Doc::alias(QLatin1String("preliminary"))
end_define
begin_define
DECL|macro|COMMAND_SINCE
define|#
directive|define
name|COMMAND_SINCE
value|Doc::alias(QLatin1String("since"))
end_define
begin_define
DECL|macro|COMMAND_WRAPPER
define|#
directive|define
name|COMMAND_WRAPPER
value|Doc::alias(QLatin1String("wrapper"))
end_define
begin_define
DECL|macro|COMMAND_QMLABSTRACT
define|#
directive|define
name|COMMAND_QMLABSTRACT
value|Doc::alias(QLatin1String("qmlabstract"))
end_define
begin_define
DECL|macro|COMMAND_QMLCLASS
define|#
directive|define
name|COMMAND_QMLCLASS
value|Doc::alias(QLatin1String("qmlclass"))
end_define
begin_define
DECL|macro|COMMAND_QMLTYPE
define|#
directive|define
name|COMMAND_QMLTYPE
value|Doc::alias(QLatin1String("qmltype"))
end_define
begin_define
DECL|macro|COMMAND_QMLMODULE
define|#
directive|define
name|COMMAND_QMLMODULE
value|Doc::alias(QLatin1String("qmlmodule"))
end_define
begin_define
DECL|macro|COMMAND_QMLPROPERTY
define|#
directive|define
name|COMMAND_QMLPROPERTY
value|Doc::alias(QLatin1String("qmlproperty"))
end_define
begin_define
DECL|macro|COMMAND_QMLPROPERTYGROUP
define|#
directive|define
name|COMMAND_QMLPROPERTYGROUP
value|Doc::alias(QLatin1String("qmlpropertygroup"))
end_define
begin_define
DECL|macro|COMMAND_QMLATTACHEDPROPERTY
define|#
directive|define
name|COMMAND_QMLATTACHEDPROPERTY
value|Doc::alias(QLatin1String("qmlattachedproperty"))
end_define
begin_define
DECL|macro|COMMAND_QMLINHERITS
define|#
directive|define
name|COMMAND_QMLINHERITS
value|Doc::alias(QLatin1String("inherits"))
end_define
begin_define
DECL|macro|COMMAND_QMLINSTANTIATES
define|#
directive|define
name|COMMAND_QMLINSTANTIATES
value|Doc::alias(QLatin1String("instantiates"))
end_define
begin_define
DECL|macro|COMMAND_INQMLMODULE
define|#
directive|define
name|COMMAND_INQMLMODULE
value|Doc::alias(QLatin1String("inqmlmodule"))
end_define
begin_define
DECL|macro|COMMAND_QMLSIGNAL
define|#
directive|define
name|COMMAND_QMLSIGNAL
value|Doc::alias(QLatin1String("qmlsignal"))
end_define
begin_define
DECL|macro|COMMAND_QMLATTACHEDSIGNAL
define|#
directive|define
name|COMMAND_QMLATTACHEDSIGNAL
value|Doc::alias(QLatin1String("qmlattachedsignal"))
end_define
begin_define
DECL|macro|COMMAND_QMLMETHOD
define|#
directive|define
name|COMMAND_QMLMETHOD
value|Doc::alias(QLatin1String("qmlmethod"))
end_define
begin_define
DECL|macro|COMMAND_QMLATTACHEDMETHOD
define|#
directive|define
name|COMMAND_QMLATTACHEDMETHOD
value|Doc::alias(QLatin1String("qmlattachedmethod"))
end_define
begin_define
DECL|macro|COMMAND_QMLDEFAULT
define|#
directive|define
name|COMMAND_QMLDEFAULT
value|Doc::alias(QLatin1String("default"))
end_define
begin_define
DECL|macro|COMMAND_QMLREADONLY
define|#
directive|define
name|COMMAND_QMLREADONLY
value|Doc::alias(QLatin1String("readonly"))
end_define
begin_define
DECL|macro|COMMAND_QMLBASICTYPE
define|#
directive|define
name|COMMAND_QMLBASICTYPE
value|Doc::alias(QLatin1String("qmlbasictype"))
end_define
begin_comment
comment|/*!   The constructor stores all the parameters in local data members.  */
end_comment
begin_constructor
DECL|function|QmlDocVisitor
name|QmlDocVisitor
operator|::
name|QmlDocVisitor
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|,
specifier|const
name|QString
modifier|&
name|code
parameter_list|,
name|QQmlJS
operator|::
name|Engine
modifier|*
name|engine
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|commands
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|topics
parameter_list|)
member_init_list|:
name|nestingLevel
argument_list|(
literal|0
argument_list|)
block|{
name|lastEndOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|filePath_
operator|=
name|filePath
expr_stmt|;
name|this
operator|->
name|name
operator|=
name|QFileInfo
argument_list|(
name|filePath
argument_list|)
operator|.
name|baseName
argument_list|()
expr_stmt|;
name|document
operator|=
name|code
expr_stmt|;
name|this
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
name|this
operator|->
name|commands_
operator|=
name|commands
expr_stmt|;
name|this
operator|->
name|topics_
operator|=
name|topics
expr_stmt|;
name|current
operator|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
operator|->
name|treeRoot
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   The destructor does nothing.  */
end_comment
begin_destructor
DECL|function|~QmlDocVisitor
name|QmlDocVisitor
operator|::
name|~
name|QmlDocVisitor
parameter_list|()
block|{
comment|// nothing.
block|}
end_destructor
begin_comment
comment|/*!   Returns the location of the nearest comment above the \a offset.  */
end_comment
begin_function
DECL|function|precedingComment
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
name|QmlDocVisitor
operator|::
name|precedingComment
parameter_list|(
name|quint32
name|offset
parameter_list|)
specifier|const
block|{
name|QListIterator
argument_list|<
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
argument_list|>
name|it
argument_list|(
name|engine
operator|->
name|comments
argument_list|()
argument_list|)
decl_stmt|;
name|it
operator|.
name|toBack
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
name|loc
init|=
name|it
operator|.
name|previous
argument_list|()
decl_stmt|;
if|if
condition|(
name|loc
operator|.
name|begin
argument_list|()
operator|<=
name|lastEndOffset
condition|)
block|{
comment|// Return if we reach the end of the preceding structure.
break|break;
block|}
elseif|else
if|if
condition|(
name|usedComments
operator|.
name|contains
argument_list|(
name|loc
operator|.
name|begin
argument_list|()
argument_list|)
condition|)
block|{
comment|// Return if we encounter a previously used comment.
break|break;
block|}
elseif|else
if|if
condition|(
name|loc
operator|.
name|begin
argument_list|()
operator|>
name|lastEndOffset
operator|&&
name|loc
operator|.
name|end
argument_list|()
operator|<
name|offset
condition|)
block|{
comment|// Only examine multiline comments in order to avoid snippet markers.
if|if
condition|(
name|document
operator|.
name|at
argument_list|(
name|loc
operator|.
name|offset
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|QString
name|comment
init|=
name|document
operator|.
name|mid
argument_list|(
name|loc
operator|.
name|offset
argument_list|,
name|loc
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
argument_list|)
operator|||
name|comment
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|loc
return|;
block|}
block|}
block|}
block|}
return|return
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|ArgList args;         QSet<QString>::iterator i = metacommands.begin();         while (i != metacommands.end()) {             if (topics_.contains(*i)) {                 topic = *i;                 break;             }             ++i;         }         if (!topic.isEmpty()) {             args = doc.metaCommandArgs(topic);             if ((topic == COMMAND_QMLCLASS) || (topic == COMMAND_QMLTYPE)) {
comment|// do nothing.
end_comment
begin_comment
unit|}             else if (topic == COMMAND_QMLPROPERTY) {                 if (node->type() == Node::QmlProperty) {                     QmlPropertyNode* qpn = static_cast<QmlPropertyNode*>(node);                     qpn->setReadOnly(0);                     if (qpn->dataType() == "alias") {                         QStringList part = args[0].first.split(QLatin1Char(' '));                         qpn->setDataType(part[0]);                     }                 }             }             else if (topic == COMMAND_QMLPROPERTYGROUP) {
comment|// zzz ?
end_comment
begin_comment
unit|}             else if (topic == COMMAND_QMLMODULE) {             }             else if (topic == COMMAND_QMLATTACHEDPROPERTY) {                 if (node->type() == Node::QmlProperty) {                     QmlPropertyNode* qpn = static_cast<QmlPropertyNode*>(node);                     qpn->setReadOnly(0);                 }             }             else if (topic == COMMAND_QMLSIGNAL) {             }             else if (topic == COMMAND_QMLATTACHEDSIGNAL) {             }             else if (topic == COMMAND_QMLMETHOD) {             }             else if (topic == COMMAND_QMLATTACHEDMETHOD) {             }             else if (topic == COMMAND_QMLBASICTYPE) {             }         }              if (node->type() == Node::QmlProperty) {                 QmlPropertyNode* qpn = static_cast<QmlPropertyNode*>(node);                 for (int i=0; i<topicsUsed.size(); ++i) {                     if (topicsUsed.at(i).topic == "qmlproperty") {
comment|/*                           A \qmlproperty command would be used in a QML file                           to document the underlying property for a property                           alias.                         */
end_comment
begin_endif
unit|QmlPropArgs qpa;                         if (splitQmlPropertyArg(doc, topicsUsed.at(i).args, qpa)) {                             QmlPropertyNode* n = parent->hasQmlPropertyNode(qpa.name_);                             if (n == 0)                                 n = new QmlPropertyNode(qpn, qpa.name_, qpa.type_, false);                             n->setLocation(doc.location());                             n->setReadOnly(qpn->isReadOnly());                             if (qpn->isDefault())                                 n->setDefault();                         }                         else                             qDebug()<< "  FAILED TO PARSE QML PROPERTY:"<< topicsUsed.at(i).topic<< topicsUsed.at(i).args;                     }                 }             }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Finds the nearest unused qdoc comment above the QML entity   represented by the \a node and processes the qdoc commands   in that comment. The processed documentation is stored in   the \a node.    If a qdoc comment is found for \a location, true is returned.   If a comment is not found there, false is returned.  */
end_comment
begin_function
DECL|function|applyDocumentation
name|bool
name|QmlDocVisitor
operator|::
name|applyDocumentation
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
name|location
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
name|loc
init|=
name|precedingComment
argument_list|(
name|location
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QString
name|source
init|=
name|document
operator|.
name|mid
argument_list|(
name|loc
operator|.
name|offset
argument_list|,
name|loc
operator|.
name|length
argument_list|)
decl_stmt|;
name|Location
name|start
argument_list|(
name|filePath_
argument_list|)
decl_stmt|;
name|start
operator|.
name|setLineNo
argument_list|(
name|loc
operator|.
name|startLine
argument_list|)
expr_stmt|;
name|start
operator|.
name|setColumnNo
argument_list|(
name|loc
operator|.
name|startColumn
argument_list|)
expr_stmt|;
name|Location
name|finish
argument_list|(
name|filePath_
argument_list|)
decl_stmt|;
name|finish
operator|.
name|setLineNo
argument_list|(
name|loc
operator|.
name|startLine
argument_list|)
expr_stmt|;
name|finish
operator|.
name|setColumnNo
argument_list|(
name|loc
operator|.
name|startColumn
argument_list|)
expr_stmt|;
name|Doc
name|doc
argument_list|(
name|start
argument_list|,
name|finish
argument_list|,
name|source
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
argument_list|,
name|commands_
argument_list|,
name|topics_
argument_list|)
decl_stmt|;
specifier|const
name|TopicList
modifier|&
name|topicsUsed
init|=
name|doc
operator|.
name|topicsUsed
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
decl_stmt|;
name|Node
modifier|*
name|nodePassedIn
init|=
name|node
decl_stmt|;
name|InnerNode
modifier|*
name|parent
init|=
name|nodePassedIn
operator|->
name|parent
argument_list|()
decl_stmt|;
name|int
name|pgc_idx
init|=
operator|-
literal|1
decl_stmt|;
name|node
operator|->
name|setDoc
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|topicsUsed
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topicsUsed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|topicsUsed
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|topic
operator|==
name|QString
argument_list|(
literal|"qmlpropertygroup"
argument_list|)
condition|)
block|{
name|pgc_idx
operator|=
name|i
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"PROPERTY GROUP COMMAND SEEN:"
operator|<<
name|topicsUsed
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|args
operator|<<
name|filePath_
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topicsUsed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|topic
init|=
name|topicsUsed
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|topic
decl_stmt|;
name|QString
name|args
init|=
name|topicsUsed
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|args
decl_stmt|;
if|if
condition|(
operator|(
name|topic
operator|==
name|COMMAND_QMLPROPERTY
operator|)
operator|||
operator|(
name|topic
operator|==
name|COMMAND_QMLATTACHEDPROPERTY
operator|)
condition|)
block|{
name|QmlPropArgs
name|qpa
decl_stmt|;
if|if
condition|(
name|splitQmlPropertyArg
argument_list|(
name|doc
argument_list|,
name|args
argument_list|,
name|qpa
argument_list|)
condition|)
block|{
if|if
condition|(
name|qpa
operator|.
name|name_
operator|==
name|nodePassedIn
operator|->
name|name
argument_list|()
condition|)
block|{
if|if
condition|(
name|nodePassedIn
operator|->
name|isAlias
argument_list|()
condition|)
name|nodePassedIn
operator|->
name|setDataType
argument_list|(
name|qpa
operator|.
name|type_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|isAttached
init|=
operator|(
name|topic
operator|==
name|COMMAND_QMLATTACHEDPROPERTY
operator|)
decl_stmt|;
name|QmlPropertyNode
modifier|*
name|n
init|=
name|parent
operator|->
name|hasQmlProperty
argument_list|(
name|qpa
operator|.
name|name_
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
operator|new
name|QmlPropertyNode
argument_list|(
name|parent
argument_list|,
name|qpa
operator|.
name|name_
argument_list|,
name|qpa
operator|.
name|type_
argument_list|,
name|isAttached
argument_list|)
expr_stmt|;
name|n
operator|->
name|setLocation
argument_list|(
name|doc
operator|.
name|location
argument_list|()
argument_list|)
expr_stmt|;
name|n
operator|->
name|setDoc
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|n
operator|->
name|setReadOnly
argument_list|(
name|nodePassedIn
operator|->
name|isReadOnly
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodePassedIn
operator|->
name|isDefault
argument_list|()
condition|)
name|n
operator|->
name|setDefault
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAttached
condition|)
name|n
operator|->
name|setReadOnly
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|append
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|qDebug
argument_list|()
operator|<<
literal|"  FAILED TO PARSE QML PROPERTY:"
operator|<<
name|topic
operator|<<
name|args
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|applyMetacommands
argument_list|(
name|loc
argument_list|,
name|nodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|usedComments
operator|.
name|insert
argument_list|(
name|loc
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
name|Location
name|codeLoc
argument_list|(
name|filePath_
argument_list|)
decl_stmt|;
name|codeLoc
operator|.
name|setLineNo
argument_list|(
name|location
operator|.
name|startLine
argument_list|)
expr_stmt|;
name|node
operator|->
name|setLocation
argument_list|(
name|codeLoc
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   A QML property argument has the form...<type><component>::<name><type><QML-module>::<component>::<name>    This function splits the argument into one of those   two forms. The three part form is the old form, which   was used before the creation of QtQuick 2 and Qt   Components. A<QML-module> is the QML equivalent of a   C++ namespace. So this function splits \a arg on "::"   and stores the parts in the \e {type}, \e {module},   \e {component}, and \a {name}, fields of \a qpa. If it   is successful, it returns true. If not enough parts   are found, a qdoc warning is emitted and false is   returned.  */
end_comment
begin_function
DECL|function|splitQmlPropertyArg
name|bool
name|QmlDocVisitor
operator|::
name|splitQmlPropertyArg
parameter_list|(
specifier|const
name|Doc
modifier|&
name|doc
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|,
name|QmlPropArgs
modifier|&
name|qpa
parameter_list|)
block|{
name|qpa
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QStringList
name|blankSplit
init|=
name|arg
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|blankSplit
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|qpa
operator|.
name|type_
operator|=
name|blankSplit
index|[
literal|0
index|]
expr_stmt|;
name|QStringList
name|colonSplit
argument_list|(
name|blankSplit
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|qpa
operator|.
name|module_
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
name|qpa
operator|.
name|component_
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
name|qpa
operator|.
name|name_
operator|=
name|colonSplit
index|[
literal|2
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|qpa
operator|.
name|component_
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
name|qpa
operator|.
name|name_
operator|=
name|colonSplit
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|colonSplit
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|qpa
operator|.
name|name_
operator|=
name|colonSplit
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QString
name|msg
init|=
literal|"Unrecognizable QML module/component qualifier for "
operator|+
name|arg
decl_stmt|;
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|msg
init|=
literal|"Missing property type for "
operator|+
name|arg
decl_stmt|;
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Applies the metacommands found in the comment.  */
end_comment
begin_function
DECL|function|applyMetacommands
name|void
name|QmlDocVisitor
operator|::
name|applyMetacommands
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|SourceLocation
parameter_list|,
name|Node
modifier|*
name|node
parameter_list|,
name|Doc
modifier|&
name|doc
parameter_list|)
block|{
name|QDocDatabase
modifier|*
name|qdb
init|=
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|metacommands
init|=
name|doc
operator|.
name|metaCommandsUsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|metacommands
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|metacommands
operator|.
name|subtract
argument_list|(
name|topics_
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|iterator
name|i
init|=
name|metacommands
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|metacommands
operator|.
name|end
argument_list|()
condition|)
block|{
name|QString
name|command
init|=
operator|*
name|i
decl_stmt|;
name|ArgList
name|args
init|=
name|doc
operator|.
name|metaCommandArgs
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLABSTRACT
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
operator|)
operator|&&
operator|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
operator|)
condition|)
block|{
name|node
operator|->
name|setAbstract
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_DEPRECATED
condition|)
block|{
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_INQMLMODULE
condition|)
block|{
name|qdb
operator|->
name|addToQmlModule
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLINHERITS
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|name
argument_list|()
operator|==
name|args
index|[
literal|0
index|]
operator|.
name|first
condition|)
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"%1 tries to inherit itself"
argument_list|)
operator|.
name|arg
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|subType
argument_list|()
operator|==
name|Node
operator|::
name|QmlClass
condition|)
block|{
name|QmlClassNode
modifier|*
name|qmlClass
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|qmlClass
operator|->
name|setQmlBaseName
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|first
argument_list|)
expr_stmt|;
name|QmlClassNode
operator|::
name|addInheritedBy
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLDEFAULT
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setDefault
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_QMLREADONLY
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|QmlProperty
condition|)
block|{
name|QmlPropertyNode
modifier|*
name|qpn
init|=
cast|static_cast
argument_list|<
name|QmlPropertyNode
operator|*
argument_list|>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|qpn
operator|->
name|setReadOnly
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|command
operator|==
name|COMMAND_INGROUP
operator|)
operator|&&
operator|!
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ArgList
operator|::
name|ConstIterator
name|argsIter
init|=
name|args
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|argsIter
operator|!=
name|args
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QDocDatabase
operator|::
name|qdocDB
argument_list|()
operator|->
name|addToGroup
argument_list|(
name|argsIter
operator|->
name|first
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|++
name|argsIter
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_INTERNAL
condition|)
block|{
name|node
operator|->
name|setAccess
argument_list|(
name|Node
operator|::
name|Private
argument_list|)
expr_stmt|;
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Internal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_OBSOLETE
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|status
argument_list|()
operator|!=
name|Node
operator|::
name|Compat
condition|)
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Obsolete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_PAGEKEYWORDS
condition|)
block|{
comment|// Not done yet. Do we need this?
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_PRELIMINARY
condition|)
block|{
name|node
operator|->
name|setStatus
argument_list|(
name|Node
operator|::
name|Preliminary
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_SINCE
condition|)
block|{
name|QString
name|arg
init|=
name|args
index|[
literal|0
index|]
operator|.
name|first
decl_stmt|;
comment|//.join(' ');
name|node
operator|->
name|setSince
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
name|COMMAND_WRAPPER
condition|)
block|{
name|node
operator|->
name|setWrapper
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|location
argument_list|()
operator|.
name|warning
argument_list|(
name|tr
argument_list|(
literal|"The \\%1 command is ignored in QML files"
argument_list|)
operator|.
name|arg
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   Reconstruct the qualified \a id using dot notation   and return the fully qualified string.  */
end_comment
begin_function
DECL|function|getFullyQualifiedId
name|QString
name|QmlDocVisitor
operator|::
name|getFullyQualifiedId
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiQualifiedId
modifier|*
name|id
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|result
operator|=
name|id
operator|->
name|name
operator|.
name|toString
argument_list|()
expr_stmt|;
name|id
operator|=
name|id
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|id
operator|!=
literal|0
condition|)
block|{
name|result
operator|+=
name|QChar
argument_list|(
literal|'.'
argument_list|)
operator|+
name|id
operator|->
name|name
operator|.
name|toString
argument_list|()
expr_stmt|;
name|id
operator|=
name|id
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Begin the visit of the object \a definition, recording it in the   qdoc database. Increment the object nesting level, which is used   to test whether we are at the public API level. The public level   is level 1. */
end_comment
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiObjectDefinition
modifier|*
name|definition
parameter_list|)
block|{
name|QString
name|type
init|=
name|getFullyQualifiedId
argument_list|(
name|definition
operator|->
name|qualifiedTypeNameId
argument_list|)
decl_stmt|;
name|nestingLevel
operator|++
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Namespace
condition|)
block|{
name|QmlClassNode
modifier|*
name|component
init|=
operator|new
name|QmlClassNode
argument_list|(
name|current
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|component
operator|->
name|setTitle
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|component
operator|->
name|setImportList
argument_list|(
name|importList
argument_list|)
expr_stmt|;
if|if
condition|(
name|applyDocumentation
argument_list|(
name|definition
operator|->
name|firstSourceLocation
argument_list|()
argument_list|,
name|component
argument_list|)
condition|)
block|{
name|QmlClassNode
operator|::
name|addInheritedBy
argument_list|(
name|type
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|component
operator|->
name|setQmlBaseName
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
name|component
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   End the visit of the object \a definition. In particular,   decrement the object nesting level, which is used to test   whether we are at the public API level. The public API   level is level 1. It won't decrement below 0.  */
end_comment
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiObjectDefinition
modifier|*
name|definition
parameter_list|)
block|{
if|if
condition|(
name|nestingLevel
operator|>
literal|0
condition|)
block|{
operator|--
name|nestingLevel
expr_stmt|;
block|}
name|lastEndOffset
operator|=
name|definition
operator|->
name|lastSourceLocation
argument_list|()
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Note that the imports list can be traversed by iteration to obtain   all the imports in the document at once, having found just one:    *it = imports; it; it = it->next   */
end_comment
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiImportList
modifier|*
name|imports
parameter_list|)
block|{
while|while
condition|(
name|imports
operator|!=
literal|0
condition|)
block|{
name|QQmlJS
operator|::
name|AST
operator|::
name|UiImport
modifier|*
name|imp
init|=
name|imports
operator|->
name|import
decl_stmt|;
name|QString
name|name
init|=
name|document
operator|.
name|mid
argument_list|(
name|imp
operator|->
name|fileNameToken
operator|.
name|offset
argument_list|,
name|imp
operator|->
name|fileNameToken
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\"'
condition|)
name|name
operator|=
name|name
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|name
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
name|QString
name|version
init|=
name|document
operator|.
name|mid
argument_list|(
name|imp
operator|->
name|versionToken
operator|.
name|offset
argument_list|,
name|imp
operator|->
name|versionToken
operator|.
name|length
argument_list|)
decl_stmt|;
name|QString
name|importId
init|=
name|document
operator|.
name|mid
argument_list|(
name|imp
operator|->
name|importIdToken
operator|.
name|offset
argument_list|,
name|imp
operator|->
name|importIdToken
operator|.
name|length
argument_list|)
decl_stmt|;
name|QString
name|importUri
init|=
name|getFullyQualifiedId
argument_list|(
name|imp
operator|->
name|importUri
argument_list|)
decl_stmt|;
name|importList
operator|.
name|append
argument_list|(
name|ImportRec
argument_list|(
name|name
argument_list|,
name|version
argument_list|,
name|importId
argument_list|,
name|importUri
argument_list|)
argument_list|)
expr_stmt|;
name|imports
operator|=
name|imports
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   End the visit of the imports list.  */
end_comment
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiImportList
modifier|*
name|definition
parameter_list|)
block|{
name|lastEndOffset
operator|=
name|definition
operator|->
name|lastSourceLocation
argument_list|()
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiObjectBinding
modifier|*
parameter_list|)
block|{
operator|++
name|nestingLevel
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiObjectBinding
modifier|*
parameter_list|)
block|{
operator|--
name|nestingLevel
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiArrayBinding
modifier|*
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiArrayBinding
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     Visits the public \a member declaration, which can be a     signal or a property. It is a custom signal or property.     Only visit the \a member if the nestingLevel is 1. */
end_comment
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiPublicMember
modifier|*
name|member
parameter_list|)
block|{
if|if
condition|(
name|nestingLevel
operator|>
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
switch|switch
condition|(
name|member
operator|->
name|type
condition|)
block|{
case|case
name|QQmlJS
operator|::
name|AST
operator|::
name|UiPublicMember
operator|::
name|Signal
case|:
block|{
if|if
condition|(
name|current
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|QmlClassNode
modifier|*
name|qmlClass
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmlClass
condition|)
block|{
name|QString
name|name
init|=
name|member
operator|->
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|FunctionNode
modifier|*
name|qmlSignal
init|=
operator|new
name|FunctionNode
argument_list|(
name|Node
operator|::
name|QmlSignal
argument_list|,
name|current
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
name|parameters
decl_stmt|;
for|for
control|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiParameterList
modifier|*
name|it
init|=
name|member
operator|->
name|parameters
init|;
name|it
condition|;
name|it
operator|=
name|it
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|it
operator|->
name|type
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|it
operator|->
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|parameters
operator|.
name|append
argument_list|(
name|Parameter
argument_list|(
name|it
operator|->
name|type
operator|.
name|toString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|it
operator|->
name|name
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qmlSignal
operator|->
name|setParameters
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
name|applyDocumentation
argument_list|(
name|member
operator|->
name|firstSourceLocation
argument_list|()
argument_list|,
name|qmlSignal
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|QQmlJS
operator|::
name|AST
operator|::
name|UiPublicMember
operator|::
name|Property
case|:
block|{
name|QString
name|type
init|=
name|member
operator|->
name|memberType
operator|.
name|toString
argument_list|()
decl_stmt|;
name|QString
name|name
init|=
name|member
operator|->
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|QmlClassNode
modifier|*
name|qmlClass
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmlClass
condition|)
block|{
name|QString
name|name
init|=
name|member
operator|->
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|QmlPropertyNode
modifier|*
name|qmlPropNode
init|=
name|qmlClass
operator|->
name|hasQmlProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmlPropNode
operator|==
literal|0
condition|)
name|qmlPropNode
operator|=
operator|new
name|QmlPropertyNode
argument_list|(
name|qmlClass
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|qmlPropNode
operator|->
name|setReadOnly
argument_list|(
name|member
operator|->
name|isReadonlyMember
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|->
name|isDefaultMember
condition|)
name|qmlPropNode
operator|->
name|setDefault
argument_list|()
expr_stmt|;
name|applyDocumentation
argument_list|(
name|member
operator|->
name|firstSourceLocation
argument_list|()
argument_list|,
name|qmlPropNode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   End the visit of the \a member.  */
end_comment
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiPublicMember
modifier|*
name|member
parameter_list|)
block|{
name|lastEndOffset
operator|=
name|member
operator|->
name|lastSourceLocation
argument_list|()
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|IdentifierPropertyName
modifier|*
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Begin the visit of the function declaration \a fd, but only   if the nesting level is 1.  */
end_comment
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|FunctionDeclaration
modifier|*
name|fd
parameter_list|)
block|{
if|if
condition|(
name|nestingLevel
operator|>
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|current
operator|->
name|type
argument_list|()
operator|==
name|Node
operator|::
name|Document
condition|)
block|{
name|QmlClassNode
modifier|*
name|qmlClass
init|=
cast|static_cast
argument_list|<
name|QmlClassNode
operator|*
argument_list|>
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|qmlClass
condition|)
block|{
name|QString
name|name
init|=
name|fd
operator|->
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|FunctionNode
modifier|*
name|qmlMethod
init|=
operator|new
name|FunctionNode
argument_list|(
name|Node
operator|::
name|QmlMethod
argument_list|,
name|current
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|overloads
init|=
literal|0
decl_stmt|;
name|NodeList
operator|::
name|ConstIterator
name|overloadIterator
init|=
name|current
operator|->
name|childNodes
argument_list|()
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|overloadIterator
operator|!=
name|current
operator|->
name|childNodes
argument_list|()
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|overloadIterator
operator|)
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
name|overloads
operator|++
expr_stmt|;
name|overloadIterator
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|overloads
operator|>
literal|1
condition|)
name|qmlMethod
operator|->
name|setOverload
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|Parameter
argument_list|>
name|parameters
decl_stmt|;
name|QQmlJS
operator|::
name|AST
operator|::
name|FormalParameterList
modifier|*
name|formals
init|=
name|fd
operator|->
name|formals
decl_stmt|;
if|if
condition|(
name|formals
condition|)
block|{
name|QQmlJS
operator|::
name|AST
operator|::
name|FormalParameterList
modifier|*
name|fpl
init|=
name|formals
decl_stmt|;
do|do
block|{
name|parameters
operator|.
name|append
argument_list|(
name|Parameter
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|fpl
operator|->
name|name
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fpl
operator|=
name|fpl
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|fpl
operator|&&
name|fpl
operator|!=
name|formals
condition|)
do|;
name|qmlMethod
operator|->
name|setParameters
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
block|}
name|applyDocumentation
argument_list|(
name|fd
operator|->
name|firstSourceLocation
argument_list|()
argument_list|,
name|qmlMethod
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   End the visit of the function declaration, \a fd.  */
end_comment
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|FunctionDeclaration
modifier|*
name|fd
parameter_list|)
block|{
name|lastEndOffset
operator|=
name|fd
operator|->
name|lastSourceLocation
argument_list|()
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Begin the visit of the signal handler declaration \a sb, but only   if the nesting level is 1.    This visit is now deprecated. It has been decided to document   public signals. If a signal handler must be discussed in the   documentation, that discussion must take place in the comment   for the signal.  */
end_comment
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiScriptBinding
modifier|*
parameter_list|)
block|{
if|#
directive|if
literal|0
block|if (nestingLevel> 1) {         return true;     }     if (current->type() == Node::Document) {         QString handler = sb->qualifiedId->name.toString();         if (handler.length()> 2&& handler.startsWith("on")&& handler.at(2).isUpper()) {             QmlClassNode* qmlClass = static_cast<QmlClassNode*>(current);             if (qmlClass) {                 FunctionNode* qmlSH = new FunctionNode(Node::QmlSignalHandler,current,handler,false);                 applyDocumentation(sb->firstSourceLocation(), qmlSH);             }         }     }
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiScriptBinding
modifier|*
name|sb
parameter_list|)
block|{
name|lastEndOffset
operator|=
name|sb
operator|->
name|lastSourceLocation
argument_list|()
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visit
name|bool
name|QmlDocVisitor
operator|::
name|visit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiQualifiedId
modifier|*
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endVisit
name|void
name|QmlDocVisitor
operator|::
name|endVisit
parameter_list|(
name|QQmlJS
operator|::
name|AST
operator|::
name|UiQualifiedId
modifier|*
parameter_list|)
block|{
comment|// nothing.
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
