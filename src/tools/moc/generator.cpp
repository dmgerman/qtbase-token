begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"outputrevision.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qmetatype.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<private/qmetaobject_p.h>
end_include
begin_comment
comment|//for the flags.
end_comment
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qvariant_nameToType
name|uint
name|qvariant_nameToType
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"QVariant"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0xffffffff
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"QCString"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QMetaType
operator|::
name|QByteArray
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Q_LLONG"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QMetaType
operator|::
name|LongLong
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Q_ULLONG"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QMetaType
operator|::
name|ULongLong
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"QIconSet"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QMetaType
operator|::
name|QIcon
return|;
name|uint
name|tp
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|tp
operator|<
name|QMetaType
operator|::
name|User
condition|?
name|tp
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*   Returns true if the type is a QVariant types. */
end_comment
begin_function
DECL|function|isVariantType
name|bool
name|isVariantType
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
return|return
name|qvariant_nameToType
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the type is qreal. */
end_comment
begin_function
DECL|function|isQRealType
specifier|static
name|bool
name|isQRealType
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"qreal"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|Generator
name|Generator
operator|::
name|Generator
parameter_list|(
name|ClassDef
modifier|*
name|classDef
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
member_init_list|:
name|out
argument_list|(
name|outfile
argument_list|)
member_init_list|,
name|cdef
argument_list|(
name|classDef
argument_list|)
member_init_list|,
name|metaTypes
argument_list|(
name|metaTypes
argument_list|)
block|{
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|)
name|purestSuperClass
operator|=
name|cdef
operator|->
name|superclassList
operator|.
name|first
argument_list|()
operator|.
name|first
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|lengthOfEscapeSequence
specifier|static
specifier|inline
name|int
name|lengthOfEscapeSequence
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\\'
operator|||
name|i
operator|>=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
return|return
literal|1
return|;
specifier|const
name|int
name|startPos
init|=
name|i
decl_stmt|;
operator|++
name|i
expr_stmt|;
name|char
name|ch
init|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'x'
condition|)
block|{
operator|++
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|is_hex_char
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_octal_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|startPos
operator|+
literal|4
operator|&&
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|is_octal_char
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// single character escape sequence
name|i
operator|=
name|qMin
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|i
operator|-
name|startPos
return|;
block|}
end_function
begin_function
DECL|function|strreg
name|int
name|Generator
operator|::
name|strreg
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|str
init|=
name|strings
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|s
condition|)
return|return
name|idx
return|;
name|idx
operator|+=
name|str
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
name|int
name|cnt
init|=
name|lengthOfEscapeSequence
argument_list|(
name|str
argument_list|,
name|i
argument_list|)
operator|-
literal|1
decl_stmt|;
name|idx
operator|-=
name|cnt
expr_stmt|;
name|i
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
block|}
name|strings
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function
begin_function
DECL|function|generateCode
name|void
name|Generator
operator|::
name|generateCode
parameter_list|()
block|{
name|bool
name|isQt
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"Qt"
operator|)
decl_stmt|;
name|bool
name|isQObject
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"QObject"
operator|)
decl_stmt|;
name|bool
name|isConstructible
init|=
operator|!
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|//
comment|// build the data array
comment|//
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// filter out undeclared enumerators and sets
block|{
name|QList
argument_list|<
name|EnumDef
argument_list|>
name|enumList
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|EnumDef
name|def
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|contains
argument_list|(
name|def
operator|.
name|name
argument_list|)
condition|)
block|{
name|enumList
operator|+=
name|def
expr_stmt|;
block|}
name|QByteArray
name|alias
init|=
name|cdef
operator|->
name|flagAliases
operator|.
name|value
argument_list|(
name|def
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|def
operator|.
name|name
operator|=
name|alias
expr_stmt|;
name|enumList
operator|+=
name|def
expr_stmt|;
block|}
block|}
name|cdef
operator|->
name|enumList
operator|=
name|enumList
expr_stmt|;
block|}
name|QByteArray
name|qualifiedClassNameIdentifier
init|=
name|cdef
operator|->
name|qualified
decl_stmt|;
name|qualifiedClassNameIdentifier
operator|.
name|replace
argument_list|(
literal|':'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|int
name|index
init|=
literal|14
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const uint qt_meta_data_%s[] = {\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // content:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // revision\n"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // classname\n"
argument_list|,
name|strreg
argument_list|(
name|cdef
operator|->
name|qualified
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // classinfo\n"
argument_list|,
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
operator|*
literal|2
expr_stmt|;
name|int
name|methodCount
init|=
name|cdef
operator|->
name|signalList
operator|.
name|count
argument_list|()
operator|+
name|cdef
operator|->
name|slotList
operator|.
name|count
argument_list|()
operator|+
name|cdef
operator|->
name|methodList
operator|.
name|count
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // methods\n"
argument_list|,
name|methodCount
argument_list|,
name|methodCount
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|methodCount
operator|*
literal|5
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|revisionedMethods
condition|)
name|index
operator|+=
name|methodCount
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // properties\n"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|notifyableProperties
condition|)
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|revisionedProperties
condition|)
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // enums/sets\n"
argument_list|,
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|int
name|enumsIndex
init|=
name|index
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|index
operator|+=
literal|4
operator|+
operator|(
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|values
operator|.
name|count
argument_list|()
operator|*
literal|2
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // constructors\n"
argument_list|,
name|isConstructible
condition|?
name|cdef
operator|->
name|constructorList
operator|.
name|count
argument_list|()
else|:
literal|0
argument_list|,
name|isConstructible
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // flags\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // signalCount\n"
argument_list|,
name|cdef
operator|->
name|signalList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Build classinfo array
comment|//
name|generateClassInfos
argument_list|()
expr_stmt|;
comment|//
comment|// Build signals array first, otherwise the signal indices would be wrong
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|,
literal|"signal"
argument_list|,
name|MethodSignal
argument_list|)
expr_stmt|;
comment|//
comment|// Build slots array
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|,
literal|"slot"
argument_list|,
name|MethodSlot
argument_list|)
expr_stmt|;
comment|//
comment|// Build method array
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|,
literal|"method"
argument_list|,
name|MethodMethod
argument_list|)
expr_stmt|;
comment|//
comment|// Build method version arrays
comment|//
if|if
condition|(
name|cdef
operator|->
name|revisionedMethods
condition|)
block|{
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|,
literal|"method"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Build property array
comment|//
name|generateProperties
argument_list|()
expr_stmt|;
comment|//
comment|// Build enums array
comment|//
name|generateEnums
argument_list|(
name|enumsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Build constructors array
comment|//
if|if
condition|(
name|isConstructible
condition|)
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|constructorList
argument_list|,
literal|"constructor"
argument_list|,
name|MethodConstructor
argument_list|)
expr_stmt|;
comment|//
comment|// Terminate data array
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n       0        // eod\n};\n\n"
argument_list|)
expr_stmt|;
comment|//
comment|// Build stringdata array
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const char qt_meta_stringdata_%s[] = {\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    \""
argument_list|)
expr_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|s
init|=
name|strings
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|len
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|&&
name|col
operator|+
name|len
operator|>=
literal|72
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n    \""
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|&&
name|s
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'0'
operator|&&
name|s
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'9'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|col
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n    \""
argument_list|)
expr_stmt|;
block|}
name|int
name|spanLen
init|=
name|qMin
argument_list|(
literal|70
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
decl_stmt|;
comment|// don't cut escape sequences at the end of a line
name|int
name|backSlashPos
init|=
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'\\'
argument_list|,
name|idx
operator|+
name|spanLen
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|backSlashPos
operator|>=
name|idx
condition|)
block|{
name|int
name|escapeLen
init|=
name|lengthOfEscapeSequence
argument_list|(
name|s
argument_list|,
name|backSlashPos
argument_list|)
decl_stmt|;
name|spanLen
operator|=
name|qBound
argument_list|(
name|spanLen
argument_list|,
name|backSlashPos
operator|+
name|escapeLen
operator|-
name|idx
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|s
operator|.
name|constData
argument_list|()
operator|+
name|idx
argument_list|,
literal|1
argument_list|,
name|spanLen
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|spanLen
expr_stmt|;
name|col
operator|+=
name|spanLen
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\\0"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|col
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n};\n\n"
argument_list|)
expr_stmt|;
comment|//
comment|// Generate internal qt_static_metacall() function
comment|//
if|if
condition|(
name|cdef
operator|->
name|hasQObject
operator|&&
operator|!
name|isQt
condition|)
name|generateStaticMetacall
argument_list|()
expr_stmt|;
comment|//
comment|// Build extra array
comment|//
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|extraList
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isVariantType
argument_list|(
name|p
operator|.
name|type
argument_list|)
operator|&&
operator|!
name|metaTypes
operator|.
name|contains
argument_list|(
name|p
operator|.
name|type
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'*'
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|int
name|s
init|=
name|p
operator|.
name|type
operator|.
name|lastIndexOf
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|scope
init|=
name|p
operator|.
name|type
operator|.
name|left
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|"Qt"
operator|&&
name|scope
operator|!=
name|cdef
operator|->
name|classname
operator|&&
operator|!
name|extraList
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
condition|)
name|extraList
operator|+=
name|scope
expr_stmt|;
block|}
block|}
block|}
comment|// QTBUG-20639 - Accept non-local enums for QML signal/slot parameters.
comment|// Look for any scoped enum declarations, and add those to the list
comment|// of extra/related metaobjects for this object.
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|enumKeys
init|=
name|cdef
operator|->
name|enumDeclarations
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumKeys
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|enumKey
init|=
name|enumKeys
index|[
name|i
index|]
decl_stmt|;
name|int
name|s
init|=
name|enumKey
operator|.
name|lastIndexOf
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|scope
init|=
name|enumKey
operator|.
name|left
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|"Qt"
operator|&&
name|scope
operator|!=
name|cdef
operator|->
name|classname
operator|&&
operator|!
name|extraList
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
condition|)
name|extraList
operator|+=
name|scope
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|extraList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const QMetaObject *qt_meta_extradata_%s[] = {\n    "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&%s::staticMetaObject,\n"
argument_list|,
name|extraList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    0\n};\n\n"
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasExtraData
init|=
operator|(
name|cdef
operator|->
name|hasQObject
operator|&&
operator|!
name|isQt
operator|)
operator|||
operator|!
name|extraList
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasExtraData
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const QMetaObjectExtraData %s::staticMetaObjectExtraData = {\n    "
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraList
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0, "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"qt_meta_extradata_%s, "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|hasQObject
operator|&&
operator|!
name|isQt
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" qt_static_metacall"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" 0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" \n};\n\n"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Finally create and initialize the static meta object
comment|//
if|if
condition|(
name|isQt
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const QMetaObject QObject::staticQtMetaObject = {\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const QMetaObject %s::staticMetaObject = {\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isQObject
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    { 0, "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    {&%s::staticMetaObject, "
argument_list|,
name|purestSuperClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    { 0, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"qt_meta_stringdata_%s,\n      qt_meta_data_%s, "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasExtraData
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0 }\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&staticMetaObjectExtraData }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isQt
condition|)
return|return;
if|if
condition|(
operator|!
name|cdef
operator|->
name|hasQObject
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nconst QMetaObject *%s::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject :&staticMetaObject;\n}\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Generate smart cast function
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nvoid *%s::qt_metacast(const char *_clname)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!_clname) return 0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, qt_meta_stringdata_%s))\n"
literal|"        return static_cast<void*>(const_cast< %s*>(this));\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// for all superclasses but the first one
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
continue|continue;
specifier|const
name|char
modifier|*
name|cname
init|=
name|cdef
operator|->
name|superclassList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, \"%s\"))\n        return static_cast< %s*>(const_cast< %s*>(this));\n"
argument_list|,
name|cname
argument_list|,
name|cname
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|interfaceList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|ClassDef
operator|::
name|Interface
argument_list|>
modifier|&
name|iface
init|=
name|cdef
operator|->
name|interfaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iface
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, %s))\n        return "
argument_list|,
name|iface
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|interfaceId
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
name|j
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static_cast< %s*>("
argument_list|,
name|iface
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|className
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast< %s*>(this)%s;\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|QByteArray
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|')'
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|purestSuperClass
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isQObject
condition|)
block|{
name|QByteArray
name|superClass
init|=
name|purestSuperClass
decl_stmt|;
comment|// workaround for VC6
if|if
condition|(
name|superClass
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    typedef %s QMocSuperClass;\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|superClass
operator|=
literal|"QMocSuperClass"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return %s::qt_metacast(_clname);\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return 0;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
comment|//
comment|// Generate internal qt_metacall()  function
comment|//
name|generateMetacall
argument_list|()
expr_stmt|;
comment|//
comment|// Generate internal signal functions
comment|//
for|for
control|(
name|int
name|signalindex
init|=
literal|0
init|;
name|signalindex
operator|<
name|cdef
operator|->
name|signalList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|signalindex
control|)
name|generateSignal
argument_list|(
operator|&
name|cdef
operator|->
name|signalList
index|[
name|signalindex
index|]
argument_list|,
name|signalindex
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateClassInfos
name|void
name|Generator
operator|::
name|generateClassInfos
parameter_list|()
block|{
if|if
condition|(
name|cdef
operator|->
name|classInfoList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // classinfo: key, value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|classInfoList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ClassInfoDef
modifier|&
name|c
init|=
name|cdef
operator|->
name|classInfoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d,\n"
argument_list|,
name|strreg
argument_list|(
name|c
operator|.
name|name
argument_list|)
argument_list|,
name|strreg
argument_list|(
name|c
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFunctions
name|void
name|Generator
operator|::
name|generateFunctions
parameter_list|(
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|functype
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // %ss: signature, parameters, type, tag, flags\n"
argument_list|,
name|functype
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QByteArray
name|sig
init|=
name|f
operator|.
name|name
operator|+
literal|'('
decl_stmt|;
name|QByteArray
name|arguments
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
block|{
name|sig
operator|+=
literal|","
expr_stmt|;
name|arguments
operator|+=
literal|","
expr_stmt|;
block|}
name|sig
operator|+=
name|a
operator|.
name|normalizedType
expr_stmt|;
name|arguments
operator|+=
name|a
operator|.
name|name
expr_stmt|;
block|}
name|sig
operator|+=
literal|')'
expr_stmt|;
name|unsigned
name|char
name|flags
init|=
name|type
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
name|flags
operator||=
name|AccessPrivate
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Public
condition|)
name|flags
operator||=
name|AccessPublic
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Protected
condition|)
name|flags
operator||=
name|AccessProtected
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
name|flags
operator||=
name|AccessPrivate
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Public
condition|)
name|flags
operator||=
name|AccessPublic
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Protected
condition|)
name|flags
operator||=
name|AccessProtected
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isCompat
condition|)
name|flags
operator||=
name|MethodCompatibility
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|wasCloned
condition|)
name|flags
operator||=
name|MethodCloned
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isScriptable
condition|)
name|flags
operator||=
name|MethodScriptable
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|revision
operator|>
literal|0
condition|)
name|flags
operator||=
name|MethodRevisioned
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, %4d, %4d, 0x%02x,\n"
argument_list|,
name|strreg
argument_list|(
name|sig
argument_list|)
argument_list|,
name|strreg
argument_list|(
name|arguments
argument_list|)
argument_list|,
name|strreg
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
argument_list|,
name|strreg
argument_list|(
name|f
operator|.
name|tag
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFunctionRevisions
name|void
name|Generator
operator|::
name|generateFunctionRevisions
parameter_list|(
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|functype
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // %ss: revision\n"
argument_list|,
name|functype
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|f
operator|.
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateProperties
name|void
name|Generator
operator|::
name|generateProperties
parameter_list|()
block|{
comment|//
comment|// Create meta data
comment|//
if|if
condition|(
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: name, type, flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
name|flags
init|=
name|Invalid
decl_stmt|;
if|if
condition|(
operator|!
name|isVariantType
argument_list|(
name|p
operator|.
name|type
argument_list|)
condition|)
block|{
name|flags
operator||=
name|EnumOrFlag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isQRealType
argument_list|(
name|p
operator|.
name|type
argument_list|)
condition|)
block|{
name|flags
operator||=
name|qvariant_nameToType
argument_list|(
name|p
operator|.
name|type
argument_list|)
operator|<<
literal|24
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|Readable
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|flags
operator||=
name|Writable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|stdCppSet
argument_list|()
condition|)
name|flags
operator||=
name|StdCppSet
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|reset
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|Resettable
expr_stmt|;
comment|//         if (p.override)
comment|//             flags |= Override;
if|if
condition|(
name|p
operator|.
name|designable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveDesignable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|designable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Designable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|scriptable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveScriptable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|scriptable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Scriptable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|stored
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveStored
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|stored
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Stored
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|editable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveEditable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|editable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Editable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveUser
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|user
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|User
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|notifyId
operator|!=
operator|-
literal|1
condition|)
name|flags
operator||=
name|Notify
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|revision
operator|>
literal|0
condition|)
name|flags
operator||=
name|Revisioned
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|constant
condition|)
name|flags
operator||=
name|Constant
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|final
condition|)
name|flags
operator||=
name|Final
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, "
argument_list|,
name|strreg
argument_list|(
name|p
operator|.
name|name
argument_list|)
argument_list|,
name|strreg
argument_list|(
name|p
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|>>
literal|24
operator|)
operator|&&
name|isQRealType
argument_list|(
name|p
operator|.
name|type
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(QMetaType::QReal<< 24) | "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0x%.8x,\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|notifyableProperties
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: notify_signal_id\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|notifyId
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|p
operator|.
name|notifyId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cdef
operator|->
name|revisionedProperties
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: revision\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|p
operator|.
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateEnums
name|void
name|Generator
operator|::
name|generateEnums
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // enums: name, flags, count, data\n"
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|4
operator|*
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|EnumDef
modifier|&
name|e
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, 0x%.1x, %4d, %4d,\n"
argument_list|,
name|strreg
argument_list|(
name|e
operator|.
name|name
argument_list|)
argument_list|,
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|e
operator|.
name|name
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index
operator|+=
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
operator|*
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // enum data: key, value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|EnumDef
modifier|&
name|e
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|val
init|=
name|e
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QByteArray
name|code
init|=
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isEnumClass
condition|)
name|code
operator|+=
literal|"::"
operator|+
name|e
operator|.
name|name
expr_stmt|;
name|code
operator|+=
literal|"::"
operator|+
name|val
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, uint(%s),\n"
argument_list|,
name|strreg
argument_list|(
name|val
argument_list|)
argument_list|,
name|code
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateMetacall
name|void
name|Generator
operator|::
name|generateMetacall
parameter_list|()
block|{
name|bool
name|isQObject
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"QObject"
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nint %s::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|purestSuperClass
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isQObject
condition|)
block|{
name|QByteArray
name|superClass
init|=
name|purestSuperClass
decl_stmt|;
comment|// workaround for VC6
if|if
condition|(
name|superClass
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    typedef %s QMocSuperClass;\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|superClass
operator|=
literal|"QMocSuperClass"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    _id = %s::qt_metacall(_c, _id, _a);\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (_id< 0)\n        return _id;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|bool
name|needElse
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|FunctionDef
argument_list|>
name|methodList
decl_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|signalList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|slotList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|methodList
expr_stmt|;
if|if
condition|(
name|methodList
operator|.
name|size
argument_list|()
condition|)
block|{
name|needElse
operator|=
literal|true
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::InvokeMetaMethod) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        if (_id< %d)\n"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            qt_static_metacall(this, _c, _id, _a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n    }"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|)
block|{
name|bool
name|needGet
init|=
literal|false
decl_stmt|;
name|bool
name|needTempVarForGet
init|=
literal|false
decl_stmt|;
name|bool
name|needSet
init|=
literal|false
decl_stmt|;
name|bool
name|needReset
init|=
literal|false
decl_stmt|;
name|bool
name|needDesignable
init|=
literal|false
decl_stmt|;
name|bool
name|needScriptable
init|=
literal|false
decl_stmt|;
name|bool
name|needStored
init|=
literal|false
decl_stmt|;
name|bool
name|needEditable
init|=
literal|false
decl_stmt|;
name|bool
name|needUser
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|needGet
operator||=
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
condition|)
name|needTempVarForGet
operator||=
operator|(
name|p
operator|.
name|gspec
operator|!=
name|PropertyDef
operator|::
name|PointerSpec
operator|&&
name|p
operator|.
name|gspec
operator|!=
name|PropertyDef
operator|::
name|ReferenceSpec
operator|)
expr_stmt|;
name|needSet
operator||=
operator|!
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|needReset
operator||=
operator|!
name|p
operator|.
name|reset
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|needDesignable
operator||=
name|p
operator|.
name|designable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needScriptable
operator||=
name|p
operator|.
name|scriptable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needStored
operator||=
name|p
operator|.
name|stored
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needEditable
operator||=
name|p
operator|.
name|editable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needUser
operator||=
name|p
operator|.
name|user
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#ifndef QT_NO_PROPERTIES\n     "
argument_list|)
expr_stmt|;
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::ReadProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needGet
condition|)
block|{
if|if
condition|(
name|needTempVarForGet
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void *_v = _a[0];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|gspec
operator|==
name|PropertyDef
operator|::
name|PointerSpec
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: _a[0] = const_cast<void*>(reinterpret_cast<const void*>(%s%s())); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|gspec
operator|==
name|PropertyDef
operator|::
name|ReferenceSpec
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: _a[0] = const_cast<void*>(reinterpret_cast<const void*>(&%s%s())); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|p
operator|.
name|type
argument_list|,
literal|false
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *reinterpret_cast<int*>(_v) = QFlag(%s%s()); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *reinterpret_cast< %s*>(_v) = %s%s(); break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::WriteProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needSet
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void *_v = _a[0];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|p
operator|.
name|type
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s(QFlag(*reinterpret_cast<int*>(_v))); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|write
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s(*reinterpret_cast< %s*>(_v)); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|write
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::ResetProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needReset
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|reset
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|reset
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyDesignable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needDesignable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|designable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|designable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyScriptable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needScriptable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|scriptable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|scriptable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyStored) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needStored
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|stored
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|stored
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyEditable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needEditable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|editable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|editable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyUser) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needUser
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|user
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|user
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#endif // QT_NO_PROPERTIES"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methodList
operator|.
name|size
argument_list|()
operator|||
name|cdef
operator|->
name|signalList
operator|.
name|size
argument_list|()
operator|||
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"return _id;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateStaticMetacall
name|void
name|Generator
operator|::
name|generateStaticMetacall
parameter_list|()
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"void %s::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|needElse
init|=
literal|false
decl_stmt|;
name|bool
name|isUsed_a
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (_c == QMetaObject::CreateInstance) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ctorindex
init|=
literal|0
init|;
name|ctorindex
operator|<
name|cdef
operator|->
name|constructorList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|ctorindex
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: { %s *_r = new %s("
argument_list|,
name|ctorindex
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|constructorList
operator|.
name|at
argument_list|(
name|ctorindex
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(*reinterpret_cast< %s>(_a[%d]))"
argument_list|,
name|a
operator|.
name|typeNameForCast
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            if (_a[0]) *reinterpret_cast<QObject**>(_a[0]) = _r; } break;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
name|QList
argument_list|<
name|FunctionDef
argument_list|>
name|methodList
decl_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|signalList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|slotList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|methodList
expr_stmt|;
if|if
condition|(
operator|!
name|methodList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::InvokeMetaMethod) {\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        Q_ASSERT(staticMetaObject.cast(_o));\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        %s *_t = static_cast<%s *>(_o);\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|methodindex
init|=
literal|0
init|;
name|methodindex
operator|<
name|methodList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|methodindex
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|methodList
operator|.
name|at
argument_list|(
name|methodindex
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: "
argument_list|,
name|methodindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|normalizedType
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"{ %s _r = "
argument_list|,
name|noRef
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"_t->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s->"
argument_list|,
name|f
operator|.
name|inPrivateClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s("
argument_list|,
name|f
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(*reinterpret_cast< %s>(_a[%d]))"
argument_list|,
name|a
operator|.
name|typeNameForCast
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|normalizedType
operator|.
name|size
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n            if (_a[0]) *reinterpret_cast< %s*>(_a[0]) = _r; } "
argument_list|,
name|noRef
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" break;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        default: ;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    } else if (_c == QMetaObject::IndexOfMethod) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        int *result = reinterpret_cast<int *>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void **func = reinterpret_cast<void **>(_a[1]);\n"
argument_list|)
expr_stmt|;
name|bool
name|anythingUsed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|methodindex
init|=
literal|0
init|;
name|methodindex
operator|<
name|methodList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|methodindex
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|methodList
operator|.
name|at
argument_list|(
name|methodindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|wasCloned
operator|||
operator|!
name|f
operator|.
name|inPrivateClass
operator|.
name|isEmpty
argument_list|()
operator|||
name|f
operator|.
name|isStatic
condition|)
continue|continue;
name|anythingUsed
operator|=
literal|true
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            typedef %s (%s::*_t)("
argument_list|,
name|f
operator|.
name|type
operator|.
name|rawName
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|QByteArray
argument_list|(
name|a
operator|.
name|type
operator|.
name|name
operator|+
literal|' '
operator|+
name|a
operator|.
name|rightType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isConst
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|") const;\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            if (*reinterpret_cast<_t *>(func) == static_cast<_t>(&%s::%s)) {\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|f
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                *result = %d;\n"
argument_list|,
name|methodindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            }\n        }\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|anythingUsed
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        Q_UNUSED(result);\n        Q_UNUSED(func);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|methodList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_o);\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_id);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_c);\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isUsed_a
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateSignal
name|void
name|Generator
operator|::
name|generateSignal
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|def
operator|->
name|wasCloned
operator|||
name|def
operator|->
name|isAbstract
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n// SIGNAL %d\n%s %s::%s("
argument_list|,
name|index
argument_list|,
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|,
name|def
operator|->
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|thisPtr
init|=
literal|"this"
decl_stmt|;
specifier|const
name|char
modifier|*
name|constQualifier
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|isConst
condition|)
block|{
name|thisPtr
operator|=
literal|"const_cast< "
expr_stmt|;
name|thisPtr
operator|+=
name|cdef
operator|->
name|qualified
expr_stmt|;
name|thisPtr
operator|+=
literal|" *>(this)"
expr_stmt|;
name|constQualifier
operator|=
literal|"const"
expr_stmt|;
block|}
if|if
condition|(
name|def
operator|->
name|arguments
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|->
name|normalizedType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|")%s\n{\n"
literal|"    QMetaObject::activate(%s,&staticMetaObject, %d, 0);\n"
literal|"}\n"
argument_list|,
name|constQualifier
argument_list|,
name|thisPtr
operator|.
name|constData
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|offset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|def
operator|->
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|def
operator|->
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s _t%d%s"
argument_list|,
name|a
operator|.
name|type
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|,
name|a
operator|.
name|rightType
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|")%s\n{\n"
argument_list|,
name|constQualifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|size
argument_list|()
operator|&&
name|def
operator|->
name|normalizedType
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %s _t0 = %s();\n"
argument_list|,
name|noRef
argument_list|(
name|def
operator|->
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|noRef
argument_list|(
name|def
operator|->
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    void *_a[] = { "
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|normalizedType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|def
operator|->
name|returnTypeIsVolatile
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast<void*>(reinterpret_cast<const volatile void*>(&_t0))"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast<void*>(reinterpret_cast<const void*>(&_t0))"
argument_list|)
expr_stmt|;
block|}
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|offset
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|def
operator|->
name|arguments
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|type
operator|.
name|isVolatile
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", const_cast<void*>(reinterpret_cast<const volatile void*>(&_t%d))"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", const_cast<void*>(reinterpret_cast<const void*>(&_t%d))"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    QMetaObject::activate(%s,&staticMetaObject, %d, _a);\n"
argument_list|,
name|thisPtr
operator|.
name|constData
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|normalizedType
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return _t0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
