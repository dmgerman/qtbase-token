begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2013 Olivier Goffart<ogoffart@woboq.com> ** Contact: http://www.qt-project.org/ ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"outputrevision.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qmetatype.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qjsondocument.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qjsonobject.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qjsonvalue.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qjsonarray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qplugin.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<private/qmetaobject_p.h>
end_include
begin_comment
comment|//for the flags.
end_comment
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|nameToBuiltinType
name|uint
name|nameToBuiltinType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|uint
name|tp
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|tp
operator|<
name|uint
argument_list|(
name|QMetaType
operator|::
name|User
argument_list|)
condition|?
name|tp
else|:
name|uint
argument_list|(
name|QMetaType
operator|::
name|UnknownType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Returns true if the type is a built-in type. */
end_comment
begin_function
DECL|function|isBuiltinType
name|bool
name|isBuiltinType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|type
parameter_list|)
block|{
name|int
name|id
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|type
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|id
operator|<
name|QMetaType
operator|::
name|User
operator|)
return|;
block|}
end_function
begin_function
DECL|function|metaTypeEnumValueString
specifier|static
specifier|const
name|char
modifier|*
name|metaTypeEnumValueString
parameter_list|(
name|int
name|type
parameter_list|)
block|{
DECL|macro|RETURN_METATYPENAME_STRING
define|#
directive|define
name|RETURN_METATYPENAME_STRING
parameter_list|(
name|MetaTypeName
parameter_list|,
name|MetaTypeId
parameter_list|,
name|RealType
parameter_list|)
define|\
value|case QMetaType::MetaTypeName: return #MetaTypeName;
switch|switch
condition|(
name|type
condition|)
block|{
name|QT_FOR_EACH_STATIC_TYPE
argument_list|(
argument|RETURN_METATYPENAME_STRING
argument_list|)
block|}
DECL|macro|RETURN_METATYPENAME_STRING
undef|#
directive|undef
name|RETURN_METATYPENAME_STRING
return|return
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|Generator
name|Generator
operator|::
name|Generator
parameter_list|(
name|ClassDef
modifier|*
name|classDef
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|knownQObjectClasses
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
member_init_list|:
name|out
argument_list|(
name|outfile
argument_list|)
member_init_list|,
name|cdef
argument_list|(
name|classDef
argument_list|)
member_init_list|,
name|metaTypes
argument_list|(
name|metaTypes
argument_list|)
member_init_list|,
name|knownQObjectClasses
argument_list|(
name|knownQObjectClasses
argument_list|)
block|{
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|)
name|purestSuperClass
operator|=
name|cdef
operator|->
name|superclassList
operator|.
name|first
argument_list|()
operator|.
name|first
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|lengthOfEscapeSequence
specifier|static
specifier|inline
name|int
name|lengthOfEscapeSequence
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\\'
operator|||
name|i
operator|>=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
return|return
literal|1
return|;
specifier|const
name|int
name|startPos
init|=
name|i
decl_stmt|;
operator|++
name|i
expr_stmt|;
name|char
name|ch
init|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'x'
condition|)
block|{
operator|++
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|is_hex_char
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_octal_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|startPos
operator|+
literal|4
operator|&&
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|is_octal_char
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// single character escape sequence
name|i
operator|=
name|qMin
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|i
operator|-
name|startPos
return|;
block|}
end_function
begin_function
DECL|function|strreg
name|void
name|Generator
operator|::
name|strreg
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strings
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
name|strings
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stridx
name|int
name|Generator
operator|::
name|stridx
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
name|int
name|i
init|=
name|strings
operator|.
name|indexOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|i
operator|!=
operator|-
literal|1
argument_list|,
name|Q_FUNC_INFO
argument_list|,
literal|"We forgot to register some strings"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|// Returns the sum of all parameters (including return type) for the given
end_comment
begin_comment
comment|// \a list of methods. This is needed for calculating the size of the methods'
end_comment
begin_comment
comment|// parameter type/name meta-data.
end_comment
begin_function
DECL|function|aggregateParameterCount
specifier|static
name|int
name|aggregateParameterCount
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|arguments
operator|.
name|count
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// +1 for return type
return|return
name|sum
return|;
block|}
end_function
begin_function
DECL|function|registerableMetaType
name|bool
name|Generator
operator|::
name|registerableMetaType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|propertyType
parameter_list|)
block|{
if|if
condition|(
name|metaTypes
operator|.
name|contains
argument_list|(
name|propertyType
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|propertyType
operator|.
name|endsWith
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|QByteArray
name|objectPointerType
init|=
name|propertyType
decl_stmt|;
comment|// The objects container stores class names, such as 'QState', 'QLabel' etc,
comment|// not 'QState*', 'QLabel*'. The propertyType does contain the '*', so we need
comment|// to chop it to find the class type in the known QObjects list.
name|objectPointerType
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|knownQObjectClasses
operator|.
name|contains
argument_list|(
name|objectPointerType
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
specifier|static
specifier|const
name|QVector
argument_list|<
name|QByteArray
argument_list|>
name|smartPointers
init|=
name|QVector
operator|<
name|QByteArray
operator|>
operator|(
operator|)
DECL|macro|STREAM_SMART_POINTER
define|#
directive|define
name|STREAM_SMART_POINTER
parameter_list|(
name|SMART_POINTER
parameter_list|)
value|<< #SMART_POINTER
name|QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER
argument_list|(
name|STREAM_SMART_POINTER
argument_list|)
DECL|macro|STREAM_SMART_POINTER
undef|#
directive|undef
name|STREAM_SMART_POINTER
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|smartPointer
decl|,
name|smartPointers
control|)
if|if
condition|(
name|propertyType
operator|.
name|startsWith
argument_list|(
name|smartPointer
operator|+
literal|"<"
argument_list|)
operator|&&
operator|!
name|propertyType
operator|.
name|endsWith
argument_list|(
literal|"&"
argument_list|)
condition|)
return|return
name|knownQObjectClasses
operator|.
name|contains
argument_list|(
name|propertyType
operator|.
name|mid
argument_list|(
name|smartPointer
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|propertyType
operator|.
name|size
argument_list|()
operator|-
name|smartPointer
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|-
literal|1
argument_list|)
argument_list|)
return|;
specifier|static
specifier|const
name|QVector
argument_list|<
name|QByteArray
argument_list|>
name|oneArgTemplates
init|=
name|QVector
operator|<
name|QByteArray
operator|>
operator|(
operator|)
DECL|macro|STREAM_1ARG_TEMPLATE
define|#
directive|define
name|STREAM_1ARG_TEMPLATE
parameter_list|(
name|TEMPLATENAME
parameter_list|)
value|<< #TEMPLATENAME
name|QT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG
argument_list|(
name|STREAM_1ARG_TEMPLATE
argument_list|)
DECL|macro|STREAM_1ARG_TEMPLATE
undef|#
directive|undef
name|STREAM_1ARG_TEMPLATE
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|oneArgTemplateType
decl|,
name|oneArgTemplates
control|)
if|if
condition|(
name|propertyType
operator|.
name|startsWith
argument_list|(
name|oneArgTemplateType
operator|+
literal|"<"
argument_list|)
operator|&&
operator|!
name|propertyType
operator|.
name|endsWith
argument_list|(
literal|"&"
argument_list|)
condition|)
block|{
specifier|const
name|int
name|argumentSize
init|=
name|propertyType
operator|.
name|size
argument_list|()
operator|-
name|oneArgTemplateType
operator|.
name|size
argument_list|()
operator|-
literal|1
comment|// The closing '>'
operator|-
literal|1
comment|// templates inside templates have an extra whitespace char to strip.
operator|-
operator|(
name|propertyType
operator|.
name|at
argument_list|(
name|propertyType
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
operator|==
literal|'>'
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
specifier|const
name|QByteArray
name|templateArg
init|=
name|propertyType
operator|.
name|mid
argument_list|(
name|oneArgTemplateType
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|argumentSize
argument_list|)
decl_stmt|;
return|return
name|isBuiltinType
argument_list|(
name|templateArg
argument_list|)
operator|||
name|registerableMetaType
argument_list|(
name|templateArg
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|generateCode
name|void
name|Generator
operator|::
name|generateCode
parameter_list|()
block|{
name|bool
name|isQt
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"Qt"
operator|)
decl_stmt|;
name|bool
name|isQObject
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"QObject"
operator|)
decl_stmt|;
name|bool
name|isConstructible
init|=
operator|!
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// filter out undeclared enumerators and sets
block|{
name|QList
argument_list|<
name|EnumDef
argument_list|>
name|enumList
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|EnumDef
name|def
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|contains
argument_list|(
name|def
operator|.
name|name
argument_list|)
condition|)
block|{
name|enumList
operator|+=
name|def
expr_stmt|;
block|}
name|QByteArray
name|alias
init|=
name|cdef
operator|->
name|flagAliases
operator|.
name|value
argument_list|(
name|def
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|def
operator|.
name|name
operator|=
name|alias
expr_stmt|;
name|enumList
operator|+=
name|def
expr_stmt|;
block|}
block|}
name|cdef
operator|->
name|enumList
operator|=
name|enumList
expr_stmt|;
block|}
comment|//
comment|// Register all strings used in data section
comment|//
name|strreg
argument_list|(
name|cdef
operator|->
name|qualified
argument_list|)
expr_stmt|;
name|registerClassInfoStrings
argument_list|()
expr_stmt|;
name|registerFunctionStrings
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|)
expr_stmt|;
name|registerFunctionStrings
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|)
expr_stmt|;
name|registerFunctionStrings
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|)
expr_stmt|;
name|registerFunctionStrings
argument_list|(
name|cdef
operator|->
name|constructorList
argument_list|)
expr_stmt|;
name|registerPropertyStrings
argument_list|()
expr_stmt|;
name|registerEnumStrings
argument_list|()
expr_stmt|;
name|QByteArray
name|qualifiedClassNameIdentifier
init|=
name|cdef
operator|->
name|qualified
decl_stmt|;
name|qualifiedClassNameIdentifier
operator|.
name|replace
argument_list|(
literal|':'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
comment|//
comment|// Build stringdata struct
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"struct qt_meta_stringdata_%s_t {\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    QByteArrayData data[%d];\n"
argument_list|,
name|strings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|len
operator|+=
name|strings
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    char stringdata[%d];\n"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
comment|// Macro that expands into a QByteArrayData. The offset member is
comment|// calculated from 1) the offset of the actual characters in the
comment|// stringdata.stringdata member, and 2) the stringdata.data index of the
comment|// QByteArrayData being defined. This calculation relies on the
comment|// QByteArrayData::data() implementation returning simply "this + offset".
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#define QT_MOC_LITERAL(idx, ofs, len) \\\n"
literal|"    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n"
literal|"    offsetof(qt_meta_stringdata_%s_t, stringdata) + ofs \\\n"
literal|"        - idx * sizeof(QByteArrayData) \\\n"
literal|"    )\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const qt_meta_stringdata_%s_t qt_meta_stringdata_%s = {\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
modifier|&
name|str
init|=
name|strings
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QT_MOC_LITERAL(%d, %d, %d)"
argument_list|,
name|i
argument_list|,
name|idx
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|str
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
name|int
name|cnt
init|=
name|lengthOfEscapeSequence
argument_list|(
name|str
argument_list|,
name|j
argument_list|)
operator|-
literal|1
decl_stmt|;
name|idx
operator|-=
name|cnt
expr_stmt|;
name|j
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n    },\n"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Build stringdata array
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    \""
argument_list|)
expr_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|s
init|=
name|strings
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|len
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|&&
name|col
operator|+
name|len
operator|>=
literal|72
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n    \""
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|&&
name|s
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'0'
operator|&&
name|s
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'9'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|col
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n    \""
argument_list|)
expr_stmt|;
block|}
name|int
name|spanLen
init|=
name|qMin
argument_list|(
literal|70
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
decl_stmt|;
comment|// don't cut escape sequences at the end of a line
name|int
name|backSlashPos
init|=
name|s
operator|.
name|lastIndexOf
argument_list|(
literal|'\\'
argument_list|,
name|idx
operator|+
name|spanLen
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|backSlashPos
operator|>=
name|idx
condition|)
block|{
name|int
name|escapeLen
init|=
name|lengthOfEscapeSequence
argument_list|(
name|s
argument_list|,
name|backSlashPos
argument_list|)
decl_stmt|;
name|spanLen
operator|=
name|qBound
argument_list|(
name|spanLen
argument_list|,
name|backSlashPos
operator|+
name|escapeLen
operator|-
name|idx
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|idx
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|s
operator|.
name|constData
argument_list|()
operator|+
name|idx
argument_list|,
literal|1
argument_list|,
name|spanLen
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|spanLen
expr_stmt|;
name|col
operator|+=
name|spanLen
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\\0"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|col
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
block|}
comment|// Terminate stringdata struct
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\"\n};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#undef QT_MOC_LITERAL\n\n"
argument_list|)
expr_stmt|;
comment|//
comment|// build the data array
comment|//
name|int
name|index
init|=
name|MetaObjectPrivateFieldCount
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const uint qt_meta_data_%s[] = {\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // content:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // revision\n"
argument_list|,
name|int
argument_list|(
name|QMetaObjectPrivate
operator|::
name|OutputRevision
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // classname\n"
argument_list|,
name|stridx
argument_list|(
name|cdef
operator|->
name|qualified
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // classinfo\n"
argument_list|,
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|cdef
operator|->
name|classInfoList
operator|.
name|count
argument_list|()
operator|*
literal|2
expr_stmt|;
name|int
name|methodCount
init|=
name|cdef
operator|->
name|signalList
operator|.
name|count
argument_list|()
operator|+
name|cdef
operator|->
name|slotList
operator|.
name|count
argument_list|()
operator|+
name|cdef
operator|->
name|methodList
operator|.
name|count
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // methods\n"
argument_list|,
name|methodCount
argument_list|,
name|methodCount
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|methodCount
operator|*
literal|5
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|revisionedMethods
condition|)
name|index
operator|+=
name|methodCount
expr_stmt|;
name|int
name|paramsIndex
init|=
name|index
decl_stmt|;
name|int
name|totalParameterCount
init|=
name|aggregateParameterCount
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|)
operator|+
name|aggregateParameterCount
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|)
operator|+
name|aggregateParameterCount
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|)
operator|+
name|aggregateParameterCount
argument_list|(
name|cdef
operator|->
name|constructorList
argument_list|)
decl_stmt|;
name|index
operator|+=
name|totalParameterCount
operator|*
literal|2
comment|// types and parameter names
operator|-
name|methodCount
comment|// return "parameters" don't have names
operator|-
name|cdef
operator|->
name|constructorList
operator|.
name|count
argument_list|()
expr_stmt|;
comment|// "this" parameters don't have names
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // properties\n"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|notifyableProperties
condition|)
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|revisionedProperties
condition|)
name|index
operator|+=
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // enums/sets\n"
argument_list|,
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
argument_list|,
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|int
name|enumsIndex
init|=
name|index
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|index
operator|+=
literal|4
operator|+
operator|(
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|values
operator|.
name|count
argument_list|()
operator|*
literal|2
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, // constructors\n"
argument_list|,
name|isConstructible
condition|?
name|cdef
operator|->
name|constructorList
operator|.
name|count
argument_list|()
else|:
literal|0
argument_list|,
name|isConstructible
condition|?
name|index
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // flags\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,       // signalCount\n"
argument_list|,
name|cdef
operator|->
name|signalList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Build classinfo array
comment|//
name|generateClassInfos
argument_list|()
expr_stmt|;
comment|//
comment|// Build signals array first, otherwise the signal indices would be wrong
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|,
literal|"signal"
argument_list|,
name|MethodSignal
argument_list|,
name|paramsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Build slots array
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|,
literal|"slot"
argument_list|,
name|MethodSlot
argument_list|,
name|paramsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Build method array
comment|//
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|,
literal|"method"
argument_list|,
name|MethodMethod
argument_list|,
name|paramsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Build method version arrays
comment|//
if|if
condition|(
name|cdef
operator|->
name|revisionedMethods
condition|)
block|{
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
name|generateFunctionRevisions
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|,
literal|"method"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Build method parameters array
comment|//
name|generateFunctionParameters
argument_list|(
name|cdef
operator|->
name|signalList
argument_list|,
literal|"signal"
argument_list|)
expr_stmt|;
name|generateFunctionParameters
argument_list|(
name|cdef
operator|->
name|slotList
argument_list|,
literal|"slot"
argument_list|)
expr_stmt|;
name|generateFunctionParameters
argument_list|(
name|cdef
operator|->
name|methodList
argument_list|,
literal|"method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isConstructible
condition|)
name|generateFunctionParameters
argument_list|(
name|cdef
operator|->
name|constructorList
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
comment|//
comment|// Build property array
comment|//
name|generateProperties
argument_list|()
expr_stmt|;
comment|//
comment|// Build enums array
comment|//
name|generateEnums
argument_list|(
name|enumsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Build constructors array
comment|//
if|if
condition|(
name|isConstructible
condition|)
name|generateFunctions
argument_list|(
name|cdef
operator|->
name|constructorList
argument_list|,
literal|"constructor"
argument_list|,
name|MethodConstructor
argument_list|,
name|paramsIndex
argument_list|)
expr_stmt|;
comment|//
comment|// Terminate data array
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n       0        // eod\n};\n\n"
argument_list|)
expr_stmt|;
comment|//
comment|// Generate internal qt_static_metacall() function
comment|//
if|if
condition|(
name|cdef
operator|->
name|hasQObject
operator|&&
operator|!
name|isQt
condition|)
name|generateStaticMetacall
argument_list|()
expr_stmt|;
comment|//
comment|// Build extra array
comment|//
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|extraList
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isBuiltinType
argument_list|(
name|p
operator|.
name|type
argument_list|)
operator|&&
operator|!
name|metaTypes
operator|.
name|contains
argument_list|(
name|p
operator|.
name|type
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'*'
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|int
name|s
init|=
name|p
operator|.
name|type
operator|.
name|lastIndexOf
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|scope
init|=
name|p
operator|.
name|type
operator|.
name|left
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|"Qt"
operator|&&
name|scope
operator|!=
name|cdef
operator|->
name|classname
operator|&&
operator|!
name|extraList
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
condition|)
name|extraList
operator|+=
name|scope
expr_stmt|;
block|}
block|}
block|}
comment|// QTBUG-20639 - Accept non-local enums for QML signal/slot parameters.
comment|// Look for any scoped enum declarations, and add those to the list
comment|// of extra/related metaobjects for this object.
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|enumKeys
init|=
name|cdef
operator|->
name|enumDeclarations
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumKeys
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|enumKey
init|=
name|enumKeys
index|[
name|i
index|]
decl_stmt|;
name|int
name|s
init|=
name|enumKey
operator|.
name|lastIndexOf
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|scope
init|=
name|enumKey
operator|.
name|left
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|"Qt"
operator|&&
name|scope
operator|!=
name|cdef
operator|->
name|classname
operator|&&
operator|!
name|extraList
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
condition|)
name|extraList
operator|+=
name|scope
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|extraList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static const QMetaObject *qt_meta_extradata_%s[] = {\n    "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&%s::staticMetaObject,\n"
argument_list|,
name|extraList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    0\n};\n\n"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Finally create and initialize the static meta object
comment|//
if|if
condition|(
name|isQt
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const QMetaObject QObject::staticQtMetaObject = {\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const QMetaObject %s::staticMetaObject = {\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isQObject
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    { 0, "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    {&%s::staticMetaObject, "
argument_list|,
name|purestSuperClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    { 0, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"qt_meta_stringdata_%s.data,\n"
literal|"      qt_meta_data_%s, "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|hasQObject
operator|&&
operator|!
name|isQt
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" qt_static_metacall, "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" 0, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraList
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0, "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"qt_meta_extradata_%s, "
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0}\n};\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isQt
condition|)
return|return;
if|if
condition|(
operator|!
name|cdef
operator|->
name|hasQObject
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nconst QMetaObject *%s::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() :&staticMetaObject;\n}\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Generate smart cast function
comment|//
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nvoid *%s::qt_metacast(const char *_clname)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!_clname) return 0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, qt_meta_stringdata_%s.stringdata))\n"
literal|"        return static_cast<void*>(const_cast< %s*>(this));\n"
argument_list|,
name|qualifiedClassNameIdentifier
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|cdef
operator|->
name|superclassList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// for all superclasses but the first one
if|if
condition|(
name|cdef
operator|->
name|superclassList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
continue|continue;
specifier|const
name|char
modifier|*
name|cname
init|=
name|cdef
operator|->
name|superclassList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
operator|.
name|constData
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, \"%s\"))\n        return static_cast< %s*>(const_cast< %s*>(this));\n"
argument_list|,
name|cname
argument_list|,
name|cname
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|interfaceList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|ClassDef
operator|::
name|Interface
argument_list|>
modifier|&
name|iface
init|=
name|cdef
operator|->
name|interfaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iface
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (!strcmp(_clname, %s))\n        return "
argument_list|,
name|iface
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|interfaceId
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
name|j
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"static_cast< %s*>("
argument_list|,
name|iface
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|className
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast< %s*>(this)%s;\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|QByteArray
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|')'
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|purestSuperClass
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isQObject
condition|)
block|{
name|QByteArray
name|superClass
init|=
name|purestSuperClass
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return %s::qt_metacast(_clname);\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return 0;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
comment|//
comment|// Generate internal qt_metacall()  function
comment|//
name|generateMetacall
argument_list|()
expr_stmt|;
comment|//
comment|// Generate internal signal functions
comment|//
for|for
control|(
name|int
name|signalindex
init|=
literal|0
init|;
name|signalindex
operator|<
name|cdef
operator|->
name|signalList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|signalindex
control|)
name|generateSignal
argument_list|(
operator|&
name|cdef
operator|->
name|signalList
index|[
name|signalindex
index|]
argument_list|,
name|signalindex
argument_list|)
expr_stmt|;
comment|//
comment|// Generate plugin meta data
comment|//
name|generatePluginMetaData
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerClassInfoStrings
name|void
name|Generator
operator|::
name|registerClassInfoStrings
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|classInfoList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ClassInfoDef
modifier|&
name|c
init|=
name|cdef
operator|->
name|classInfoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|strreg
argument_list|(
name|c
operator|.
name|name
argument_list|)
expr_stmt|;
name|strreg
argument_list|(
name|c
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateClassInfos
name|void
name|Generator
operator|::
name|generateClassInfos
parameter_list|()
block|{
if|if
condition|(
name|cdef
operator|->
name|classInfoList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // classinfo: key, value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|classInfoList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ClassInfoDef
modifier|&
name|c
init|=
name|cdef
operator|->
name|classInfoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d,\n"
argument_list|,
name|stridx
argument_list|(
name|c
operator|.
name|name
argument_list|)
argument_list|,
name|stridx
argument_list|(
name|c
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerFunctionStrings
name|void
name|Generator
operator|::
name|registerFunctionStrings
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|strreg
argument_list|(
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isBuiltinType
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
condition|)
name|strreg
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
expr_stmt|;
name|strreg
argument_list|(
name|f
operator|.
name|tag
argument_list|)
expr_stmt|;
name|int
name|argsCount
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isBuiltinType
argument_list|(
name|a
operator|.
name|normalizedType
argument_list|)
condition|)
name|strreg
argument_list|(
name|a
operator|.
name|normalizedType
argument_list|)
expr_stmt|;
name|strreg
argument_list|(
name|a
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateFunctions
name|void
name|Generator
operator|::
name|generateFunctions
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|functype
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|&
name|paramsIndex
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // %ss: name, argc, parameters, tag, flags\n"
argument_list|,
name|functype
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|flags
init|=
name|type
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
name|flags
operator||=
name|AccessPrivate
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Public
condition|)
name|flags
operator||=
name|AccessPublic
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Protected
condition|)
name|flags
operator||=
name|AccessProtected
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Private
condition|)
name|flags
operator||=
name|AccessPrivate
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Public
condition|)
name|flags
operator||=
name|AccessPublic
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|access
operator|==
name|FunctionDef
operator|::
name|Protected
condition|)
name|flags
operator||=
name|AccessProtected
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isCompat
condition|)
name|flags
operator||=
name|MethodCompatibility
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|wasCloned
condition|)
name|flags
operator||=
name|MethodCloned
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isScriptable
condition|)
name|flags
operator||=
name|MethodScriptable
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|revision
operator|>
literal|0
condition|)
name|flags
operator||=
name|MethodRevisioned
expr_stmt|;
name|int
name|argc
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, %4d, %4d, %4d, 0x%02x,\n"
argument_list|,
name|stridx
argument_list|(
name|f
operator|.
name|name
argument_list|)
argument_list|,
name|argc
argument_list|,
name|paramsIndex
argument_list|,
name|stridx
argument_list|(
name|f
operator|.
name|tag
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|paramsIndex
operator|+=
literal|1
operator|+
name|argc
operator|*
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFunctionRevisions
name|void
name|Generator
operator|::
name|generateFunctionRevisions
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|functype
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // %ss: revision\n"
argument_list|,
name|functype
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|f
operator|.
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateFunctionParameters
name|void
name|Generator
operator|::
name|generateFunctionParameters
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|functype
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // %ss: parameters\n"
argument_list|,
name|functype
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
comment|// Types
name|int
name|argsCount
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
operator|-
literal|1
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|>
operator|-
literal|1
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
modifier|&
name|typeName
init|=
operator|(
name|j
operator|<
literal|0
operator|)
condition|?
name|f
operator|.
name|normalizedType
else|:
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|normalizedType
decl_stmt|;
name|generateTypeInfo
argument_list|(
name|typeName
argument_list|,
comment|/*allowEmptyName=*/
name|f
operator|.
name|isConstructor
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|// Parameter names
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|arg
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %4d,"
argument_list|,
name|stridx
argument_list|(
name|arg
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateTypeInfo
name|void
name|Generator
operator|::
name|generateTypeInfo
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|typeName
parameter_list|,
name|bool
name|allowEmptyName
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|allowEmptyName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBuiltinType
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|valueString
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|"qreal"
condition|)
block|{
name|type
operator|=
name|QMetaType
operator|::
name|UnknownType
expr_stmt|;
name|valueString
operator|=
literal|"QReal"
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|nameToBuiltinType
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
name|valueString
operator|=
name|metaTypeEnumValueString
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valueString
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QMetaType::%s"
argument_list|,
name|valueString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%4d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|typeName
operator|.
name|isEmpty
argument_list|()
operator|||
name|allowEmptyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0x%.8x | %d"
argument_list|,
name|IsUnresolvedType
argument_list|,
name|stridx
argument_list|(
name|typeName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerPropertyStrings
name|void
name|Generator
operator|::
name|registerPropertyStrings
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|strreg
argument_list|(
name|p
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isBuiltinType
argument_list|(
name|p
operator|.
name|type
argument_list|)
condition|)
name|strreg
argument_list|(
name|p
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateProperties
name|void
name|Generator
operator|::
name|generateProperties
parameter_list|()
block|{
comment|//
comment|// Create meta data
comment|//
if|if
condition|(
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: name, type, flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
name|flags
init|=
name|Invalid
decl_stmt|;
if|if
condition|(
operator|!
name|isBuiltinType
argument_list|(
name|p
operator|.
name|type
argument_list|)
condition|)
name|flags
operator||=
name|EnumOrFlag
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|p
operator|.
name|constant
condition|)
name|flags
operator||=
name|Writable
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|Readable
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|flags
operator||=
name|Writable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|stdCppSet
argument_list|()
condition|)
name|flags
operator||=
name|StdCppSet
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|reset
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|Resettable
expr_stmt|;
comment|//         if (p.override)
comment|//             flags |= Override;
if|if
condition|(
name|p
operator|.
name|designable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveDesignable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|designable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Designable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|scriptable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveScriptable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|scriptable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Scriptable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|stored
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveStored
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|stored
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Stored
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|editable
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveEditable
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|editable
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|Editable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
name|flags
operator||=
name|ResolveUser
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|user
operator|!=
literal|"false"
condition|)
name|flags
operator||=
name|User
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|notifyId
operator|!=
operator|-
literal|1
condition|)
name|flags
operator||=
name|Notify
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|revision
operator|>
literal|0
condition|)
name|flags
operator||=
name|Revisioned
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|constant
condition|)
name|flags
operator||=
name|Constant
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|final
condition|)
name|flags
operator||=
name|Final
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, "
argument_list|,
name|stridx
argument_list|(
name|p
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|generateTypeInfo
argument_list|(
name|p
operator|.
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", 0x%.8x,\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|notifyableProperties
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: notify_signal_id\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|notifyId
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|p
operator|.
name|notifyId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cdef
operator|->
name|revisionedProperties
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // properties: revision\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d,\n"
argument_list|,
name|p
operator|.
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|registerEnumStrings
name|void
name|Generator
operator|::
name|registerEnumStrings
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|EnumDef
modifier|&
name|e
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|strreg
argument_list|(
name|e
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
name|strreg
argument_list|(
name|e
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|generateEnums
name|void
name|Generator
operator|::
name|generateEnums
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // enums: name, flags, count, data\n"
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|4
operator|*
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|EnumDef
modifier|&
name|e
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, 0x%.1x, %4d, %4d,\n"
argument_list|,
name|stridx
argument_list|(
name|e
operator|.
name|name
argument_list|)
argument_list|,
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|e
operator|.
name|name
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index
operator|+=
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
operator|*
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n // enum data: key, value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|enumList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|EnumDef
modifier|&
name|e
init|=
name|cdef
operator|->
name|enumList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|e
operator|.
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|val
init|=
name|e
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QByteArray
name|code
init|=
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isEnumClass
condition|)
name|code
operator|+=
literal|"::"
operator|+
name|e
operator|.
name|name
expr_stmt|;
name|code
operator|+=
literal|"::"
operator|+
name|val
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %4d, uint(%s),\n"
argument_list|,
name|stridx
argument_list|(
name|val
argument_list|)
argument_list|,
name|code
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|generateMetacall
name|void
name|Generator
operator|::
name|generateMetacall
parameter_list|()
block|{
name|bool
name|isQObject
init|=
operator|(
name|cdef
operator|->
name|classname
operator|==
literal|"QObject"
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nint %s::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|purestSuperClass
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isQObject
condition|)
block|{
name|QByteArray
name|superClass
init|=
name|purestSuperClass
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    _id = %s::qt_metacall(_c, _id, _a);\n"
argument_list|,
name|superClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (_id< 0)\n        return _id;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|bool
name|needElse
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|FunctionDef
argument_list|>
name|methodList
decl_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|signalList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|slotList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|methodList
expr_stmt|;
if|if
condition|(
name|methodList
operator|.
name|size
argument_list|()
condition|)
block|{
name|needElse
operator|=
literal|true
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::InvokeMetaMethod) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        if (_id< %d)\n"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            qt_static_metacall(this, _c, _id, _a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n    }"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        if (_id< %d)\n"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|methodsWithAutomaticTypesHelper
argument_list|(
name|methodList
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            *reinterpret_cast<int*>(_a[0]) = -1;\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            qt_static_metacall(this, _c, _id, _a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n    }"
argument_list|,
name|methodList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|)
block|{
name|bool
name|needGet
init|=
literal|false
decl_stmt|;
name|bool
name|needTempVarForGet
init|=
literal|false
decl_stmt|;
name|bool
name|needSet
init|=
literal|false
decl_stmt|;
name|bool
name|needReset
init|=
literal|false
decl_stmt|;
name|bool
name|needDesignable
init|=
literal|false
decl_stmt|;
name|bool
name|needScriptable
init|=
literal|false
decl_stmt|;
name|bool
name|needStored
init|=
literal|false
decl_stmt|;
name|bool
name|needEditable
init|=
literal|false
decl_stmt|;
name|bool
name|needUser
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|needGet
operator||=
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
name|needTempVarForGet
operator||=
operator|(
name|p
operator|.
name|gspec
operator|!=
name|PropertyDef
operator|::
name|PointerSpec
operator|&&
name|p
operator|.
name|gspec
operator|!=
name|PropertyDef
operator|::
name|ReferenceSpec
operator|)
expr_stmt|;
name|needSet
operator||=
operator|!
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
operator|!
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|p
operator|.
name|constant
operator|)
expr_stmt|;
name|needReset
operator||=
operator|!
name|p
operator|.
name|reset
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|needDesignable
operator||=
name|p
operator|.
name|designable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needScriptable
operator||=
name|p
operator|.
name|scriptable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needStored
operator||=
name|p
operator|.
name|stored
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needEditable
operator||=
name|p
operator|.
name|editable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|needUser
operator||=
name|p
operator|.
name|user
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#ifndef QT_NO_PROPERTIES\n     "
argument_list|)
expr_stmt|;
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::ReadProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needGet
condition|)
block|{
if|if
condition|(
name|needTempVarForGet
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void *_v = _a[0];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
operator|&&
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|gspec
operator|==
name|PropertyDef
operator|::
name|PointerSpec
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: _a[0] = const_cast<void*>(reinterpret_cast<const void*>(%s%s())); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|gspec
operator|==
name|PropertyDef
operator|::
name|ReferenceSpec
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: _a[0] = const_cast<void*>(reinterpret_cast<const void*>(&%s%s())); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|p
operator|.
name|type
argument_list|,
literal|false
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *reinterpret_cast<int*>(_v) = QFlag(%s%s()); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *reinterpret_cast< %s*>(_v) = %s%s(); break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|read
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *reinterpret_cast< %s*>(_v) = %s%s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|member
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::WriteProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needSet
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void *_v = _a[0];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|constant
condition|)
continue|continue;
if|if
condition|(
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
operator|&&
name|p
operator|.
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdef
operator|->
name|enumDeclarations
operator|.
name|value
argument_list|(
name|p
operator|.
name|type
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s(QFlag(*reinterpret_cast<int*>(_v))); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|write
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p
operator|.
name|write
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s(*reinterpret_cast< %s*>(_v)); break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|write
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d:\n"
argument_list|,
name|propindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            if (%s%s != *reinterpret_cast< %s*>(_v)) {\n"
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|member
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                %s%s = *reinterpret_cast< %s*>(_v);\n"
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|member
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|type
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|notify
operator|.
name|isEmpty
argument_list|()
operator|&&
name|p
operator|.
name|notifyId
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|signalList
operator|.
name|at
argument_list|(
name|p
operator|.
name|notifyId
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                emit %s();\n"
argument_list|,
name|p
operator|.
name|notify
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|normalizedType
operator|==
name|p
operator|.
name|type
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                emit %s(%s%s);\n"
argument_list|,
name|p
operator|.
name|notify
operator|.
name|constData
argument_list|()
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|member
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            break;\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::ResetProperty) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needReset
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|reset
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|QByteArray
name|prefix
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|p
operator|.
name|inPrivateClass
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: %s%s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|prefix
operator|.
name|constData
argument_list|()
argument_list|,
name|p
operator|.
name|reset
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyDesignable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needDesignable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|designable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|designable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyScriptable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needScriptable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|scriptable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|scriptable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyStored) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needStored
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|stored
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|stored
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyEditable) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needEditable
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|editable
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|editable
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::QueryPropertyUser) {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needUser
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        bool *_b = reinterpret_cast<bool*>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|propindex
init|=
literal|0
init|;
name|propindex
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|propindex
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|propindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|user
operator|.
name|endsWith
argument_list|(
literal|')'
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: *_b = %s; break;\n"
argument_list|,
name|propindex
argument_list|,
name|p
operator|.
name|user
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n"
literal|"    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::RegisterPropertyMetaType) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        if (_id< %d)\n"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaticPropertyMetaTypesHelper
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            *reinterpret_cast<int*>(_a[0]) = -1;\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            qt_static_metacall(this, _c, _id, _a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        _id -= %d;\n    }"
argument_list|,
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#endif // QT_NO_PROPERTIES"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methodList
operator|.
name|size
argument_list|()
operator|||
name|cdef
operator|->
name|signalList
operator|.
name|size
argument_list|()
operator|||
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"return _id;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|automaticPropertyMetaTypesHelper
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
name|Generator
operator|::
name|automaticPropertyMetaTypesHelper
parameter_list|()
block|{
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
name|automaticPropertyMetaTypes
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
name|propertyType
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|registerableMetaType
argument_list|(
name|propertyType
argument_list|)
operator|&&
operator|!
name|isBuiltinType
argument_list|(
name|propertyType
argument_list|)
condition|)
name|automaticPropertyMetaTypes
operator|.
name|insert
argument_list|(
name|propertyType
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|automaticPropertyMetaTypes
return|;
block|}
end_function
begin_function
DECL|function|methodsWithAutomaticTypesHelper
name|QMap
argument_list|<
name|int
argument_list|,
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
argument_list|>
name|Generator
operator|::
name|methodsWithAutomaticTypesHelper
parameter_list|(
specifier|const
name|QList
argument_list|<
name|FunctionDef
argument_list|>
modifier|&
name|methodList
parameter_list|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
argument_list|>
name|methodsWithAutomaticTypes
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methodList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|methodList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QByteArray
name|argType
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|normalizedType
decl_stmt|;
if|if
condition|(
name|registerableMetaType
argument_list|(
name|argType
argument_list|)
operator|&&
operator|!
name|isBuiltinType
argument_list|(
name|argType
argument_list|)
condition|)
name|methodsWithAutomaticTypes
index|[
name|i
index|]
operator|.
name|insert
argument_list|(
name|argType
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|methodsWithAutomaticTypes
return|;
block|}
end_function
begin_function
DECL|function|generateStaticMetacall
name|void
name|Generator
operator|::
name|generateStaticMetacall
parameter_list|()
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"void %s::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|needElse
init|=
literal|false
decl_stmt|;
name|bool
name|isUsed_a
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    if (_c == QMetaObject::CreateInstance) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ctorindex
init|=
literal|0
init|;
name|ctorindex
operator|<
name|cdef
operator|->
name|constructorList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|ctorindex
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: { %s *_r = new %s("
argument_list|,
name|ctorindex
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|constructorList
operator|.
name|at
argument_list|(
name|ctorindex
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
name|int
name|argsCount
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(*reinterpret_cast< %s>(_a[%d]))"
argument_list|,
name|a
operator|.
name|typeNameForCast
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isPrivateSignal
condition|)
block|{
if|if
condition|(
name|argsCount
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|QByteArray
argument_list|(
literal|"QPrivateSignal()"
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            if (_a[0]) *reinterpret_cast<QObject**>(_a[0]) = _r; } break;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
name|QList
argument_list|<
name|FunctionDef
argument_list|>
name|methodList
decl_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|signalList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|slotList
expr_stmt|;
name|methodList
operator|+=
name|cdef
operator|->
name|methodList
expr_stmt|;
if|if
condition|(
operator|!
name|methodList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::InvokeMetaMethod) {\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        Q_ASSERT(staticMetaObject.cast(_o));\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        %s *_t = static_cast<%s *>(_o);\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|methodindex
init|=
literal|0
init|;
name|methodindex
operator|<
name|methodList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|methodindex
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|methodList
operator|.
name|at
argument_list|(
name|methodindex
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|f
operator|.
name|normalizedType
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d: "
argument_list|,
name|methodindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|normalizedType
operator|!=
literal|"void"
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"{ %s _r = "
argument_list|,
name|noRef
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"_t->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|inPrivateClass
operator|.
name|size
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s->"
argument_list|,
name|f
operator|.
name|inPrivateClass
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s("
argument_list|,
name|f
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
name|int
name|argsCount
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(*reinterpret_cast< %s>(_a[%d]))"
argument_list|,
name|a
operator|.
name|typeNameForCast
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isPrivateSignal
condition|)
block|{
if|if
condition|(
name|argsCount
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
literal|"QPrivateSignal()"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|normalizedType
operator|!=
literal|"void"
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n            if (_a[0]) *reinterpret_cast< %s*>(_a[0]) = _r; } "
argument_list|,
name|noRef
argument_list|(
name|f
operator|.
name|normalizedType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" break;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        default: ;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
argument_list|>
name|methodsWithAutomaticTypes
init|=
name|methodsWithAutomaticTypesHelper
argument_list|(
name|methodList
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|methodsWithAutomaticTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        default: *reinterpret_cast<int*>(_a[0]) = -1; break;\n"
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|methodsWithAutomaticTypes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QMap
argument_list|<
name|int
argument_list|,
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
argument_list|>
operator|::
name|const_iterator
name|end
init|=
name|methodsWithAutomaticTypes
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d:\n"
argument_list|,
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            switch (*reinterpret_cast<int*>(_a[1])) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            default: *reinterpret_cast<int*>(_a[0]) = -1; break;\n"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|key
decl|,
name|it
operator|->
name|uniqueKeys
argument_list|()
control|)
block|{
foreach|foreach
control|(
name|int
name|argumentID
decl|,
name|it
operator|->
name|values
argument_list|(
name|key
argument_list|)
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            case %d:\n"
argument_list|,
name|argumentID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< %s>(); break;\n"
argument_list|,
name|key
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            break;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cdef
operator|->
name|signalList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|needElse
argument_list|)
expr_stmt|;
comment|// if there is signal, there was method.
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else if (_c == QMetaObject::IndexOfMethod) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        int *result = reinterpret_cast<int *>(_a[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        void **func = reinterpret_cast<void **>(_a[1]);\n"
argument_list|)
expr_stmt|;
name|bool
name|anythingUsed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|methodindex
init|=
literal|0
init|;
name|methodindex
operator|<
name|cdef
operator|->
name|signalList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|methodindex
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|signalList
operator|.
name|at
argument_list|(
name|methodindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|wasCloned
operator|||
operator|!
name|f
operator|.
name|inPrivateClass
operator|.
name|isEmpty
argument_list|()
operator|||
name|f
operator|.
name|isStatic
condition|)
continue|continue;
name|anythingUsed
operator|=
literal|true
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            typedef %s (%s::*_t)("
argument_list|,
name|f
operator|.
name|type
operator|.
name|rawName
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|argsCount
init|=
name|f
operator|.
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|argsCount
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|f
operator|.
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|QByteArray
argument_list|(
name|a
operator|.
name|type
operator|.
name|name
operator|+
literal|' '
operator|+
name|a
operator|.
name|rightType
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isPrivateSignal
condition|)
block|{
if|if
condition|(
name|argsCount
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
literal|"QPrivateSignal"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isConst
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|") const;\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            if (*reinterpret_cast<_t *>(func) == static_cast<_t>(&%s::%s)) {\n"
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|,
name|f
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"                *result = %d;\n"
argument_list|,
name|methodindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            }\n        }\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|anythingUsed
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        Q_UNUSED(result);\n        Q_UNUSED(func);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }"
argument_list|)
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
block|}
name|QMultiMap
argument_list|<
name|QByteArray
argument_list|,
name|int
argument_list|>
name|automaticPropertyMetaTypes
init|=
name|automaticPropertyMetaTypesHelper
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|automaticPropertyMetaTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"if (_c == QMetaObject::RegisterPropertyMetaType) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        switch (_id) {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        default: *reinterpret_cast<int*>(_a[0]) = -1; break;\n"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|key
decl|,
name|automaticPropertyMetaTypes
operator|.
name|uniqueKeys
argument_list|()
control|)
block|{
foreach|foreach
control|(
name|int
name|propertyID
decl|,
name|automaticPropertyMetaTypes
operator|.
name|values
argument_list|(
name|key
argument_list|)
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        case %d:\n"
argument_list|,
name|propertyID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< %s>(); break;\n"
argument_list|,
name|key
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|isUsed_a
operator|=
literal|true
expr_stmt|;
name|needElse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|needElse
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|methodList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_o);\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdef
operator|->
name|constructorList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|automaticPropertyMetaTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|methodsWithAutomaticTypesHelper
argument_list|(
name|methodList
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_id);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_c);\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isUsed_a
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    Q_UNUSED(_a);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateSignal
name|void
name|Generator
operator|::
name|generateSignal
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|def
operator|->
name|wasCloned
operator|||
name|def
operator|->
name|isAbstract
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n// SIGNAL %d\n%s %s::%s("
argument_list|,
name|index
argument_list|,
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|,
name|def
operator|->
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|thisPtr
init|=
literal|"this"
decl_stmt|;
specifier|const
name|char
modifier|*
name|constQualifier
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|isConst
condition|)
block|{
name|thisPtr
operator|=
literal|"const_cast< "
expr_stmt|;
name|thisPtr
operator|+=
name|cdef
operator|->
name|qualified
expr_stmt|;
name|thisPtr
operator|+=
literal|" *>(this)"
expr_stmt|;
name|constQualifier
operator|=
literal|"const"
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|!
name|def
operator|->
name|normalizedType
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|arguments
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|->
name|normalizedType
operator|==
literal|"void"
condition|)
block|{
if|if
condition|(
name|def
operator|->
name|isPrivateSignal
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QPrivateSignal"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|")%s\n{\n"
literal|"    QMetaObject::activate(%s,&staticMetaObject, %d, 0);\n"
literal|"}\n"
argument_list|,
name|constQualifier
argument_list|,
name|thisPtr
operator|.
name|constData
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|offset
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|def
operator|->
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|ArgumentDef
modifier|&
name|a
init|=
name|def
operator|->
name|arguments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s _t%d%s"
argument_list|,
name|a
operator|.
name|type
operator|.
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|offset
operator|++
argument_list|,
name|a
operator|.
name|rightType
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|def
operator|->
name|isPrivateSignal
condition|)
block|{
if|if
condition|(
operator|!
name|def
operator|->
name|arguments
operator|.
name|isEmpty
argument_list|()
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QPrivateSignal"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|")%s\n{\n"
argument_list|,
name|constQualifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|size
argument_list|()
operator|&&
name|def
operator|->
name|normalizedType
operator|!=
literal|"void"
condition|)
block|{
name|QByteArray
name|returnType
init|=
name|noRef
argument_list|(
name|def
operator|->
name|normalizedType
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnType
operator|.
name|endsWith
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %s _t0 = 0;\n"
argument_list|,
name|returnType
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    %s _t0 = %s();\n"
argument_list|,
name|returnType
operator|.
name|constData
argument_list|()
argument_list|,
name|returnType
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    void *_a[] = { "
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|normalizedType
operator|==
literal|"void"
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|def
operator|->
name|returnTypeIsVolatile
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast<void*>(reinterpret_cast<const volatile void*>(&_t0))"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"const_cast<void*>(reinterpret_cast<const void*>(&_t0))"
argument_list|)
expr_stmt|;
block|}
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|offset
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|def
operator|->
name|arguments
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|type
operator|.
name|isVolatile
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", const_cast<void*>(reinterpret_cast<const volatile void*>(&_t%d))"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", const_cast<void*>(reinterpret_cast<const void*>(&_t%d))"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    QMetaObject::activate(%s,&staticMetaObject, %d, _a);\n"
argument_list|,
name|thisPtr
operator|.
name|constData
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|normalizedType
operator|!=
literal|"void"
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    return _t0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writePluginMetaData
specifier|static
name|void
name|writePluginMetaData
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|QJsonObject
modifier|&
name|data
parameter_list|)
block|{
specifier|const
name|QJsonDocument
name|doc
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
literal|"\nQT_PLUGIN_METADATA_SECTION\n"
literal|"static const unsigned char qt_pluginMetaData[] = {\n"
literal|"    'Q', 'T', 'M', 'E', 'T', 'A', 'D', 'A', 'T', 'A', ' ', ' ',\n   "
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(out, "\"%s\";\n", doc.toJson().constData());
else|#
directive|else
specifier|const
name|QByteArray
name|binary
init|=
name|doc
operator|.
name|toBinaryData
argument_list|()
decl_stmt|;
specifier|const
name|int
name|last
init|=
name|binary
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" 0x%02x,"
argument_list|,
operator|(
name|uchar
operator|)
name|binary
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|8
operator|)
condition|)
name|fputs
argument_list|(
literal|"\n   "
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" 0x%02x\n};\n"
argument_list|,
operator|(
name|uchar
operator|)
name|binary
operator|.
name|at
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|generatePluginMetaData
name|void
name|Generator
operator|::
name|generatePluginMetaData
parameter_list|()
block|{
if|if
condition|(
name|cdef
operator|->
name|pluginData
operator|.
name|iid
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Write plugin meta data #ifdefed QT_NO_DEBUG with debug=false,
comment|// true, respectively.
name|QJsonObject
name|data
decl_stmt|;
specifier|const
name|QString
name|debugKey
init|=
name|QStringLiteral
argument_list|(
literal|"debug"
argument_list|)
decl_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|QStringLiteral
argument_list|(
literal|"IID"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
name|cdef
operator|->
name|pluginData
operator|.
name|iid
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|QStringLiteral
argument_list|(
literal|"className"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|QStringLiteral
argument_list|(
literal|"version"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|QT_VERSION
argument_list|)
expr_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|debugKey
argument_list|,
name|QJsonValue
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|QStringLiteral
argument_list|(
literal|"MetaData"
argument_list|)
argument_list|,
name|cdef
operator|->
name|pluginData
operator|.
name|metaData
operator|.
name|object
argument_list|()
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nQT_PLUGIN_METADATA_SECTION const uint qt_section_alignment_dummy = 42;\n\n"
literal|"#ifdef QT_NO_DEBUG\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|writePluginMetaData
argument_list|(
name|out
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n#else // QT_NO_DEBUG\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|data
operator|.
name|remove
argument_list|(
name|debugKey
argument_list|)
expr_stmt|;
name|data
operator|.
name|insert
argument_list|(
name|debugKey
argument_list|,
name|QJsonValue
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|writePluginMetaData
argument_list|(
name|out
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#endif // QT_NO_DEBUG\n\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// 'Use' all namespaces.
name|int
name|pos
init|=
name|cdef
operator|->
name|qualified
operator|.
name|indexOf
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|pos
operator|!=
operator|-
literal|1
condition|;
name|pos
operator|=
name|cdef
operator|->
name|qualified
operator|.
name|indexOf
argument_list|(
literal|"::"
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"using namespace %s;\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|left
argument_list|(
name|pos
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QT_MOC_EXPORT_PLUGIN(%s, %s)\n\n"
argument_list|,
name|cdef
operator|->
name|qualified
operator|.
name|constData
argument_list|()
argument_list|,
name|cdef
operator|->
name|classname
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
