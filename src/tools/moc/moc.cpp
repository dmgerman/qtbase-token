begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"moc.h"
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"outputrevision.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_comment
comment|// for normalizeTypeInternal
end_comment
begin_include
include|#
directive|include
file|<private/qmetaobject_moc_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|// only moc needs this function
DECL|function|normalizeType
specifier|static
name|QByteArray
name|normalizeType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|bool
name|fixScope
init|=
literal|false
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|ba
operator|.
name|constData
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|ba
operator|.
name|size
argument_list|()
decl_stmt|;
name|char
name|stackbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|len
operator|>=
literal|64
condition|?
operator|new
name|char
index|[
name|len
operator|+
literal|1
index|]
else|:
name|stackbuf
operator|)
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|buf
decl_stmt|;
name|char
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|last
operator|=
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|(
operator|(
name|is_ident_char
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|is_ident_char
argument_list|(
name|last
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|last
operator|==
literal|'<'
operator|)
operator|)
operator|)
condition|)
block|{
name|last
operator|=
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|QByteArray
name|result
init|=
name|normalizeTypeInternal
argument_list|(
name|buf
argument_list|,
name|d
argument_list|,
name|fixScope
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
name|stackbuf
condition|)
operator|delete
index|[]
name|buf
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|parseClassHead
name|bool
name|Moc
operator|::
name|parseClassHead
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
comment|// figure out whether this is a class declaration, or only a
comment|// forward or variable declaration.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Token
name|token
decl_stmt|;
do|do
block|{
name|token
operator|=
name|lookup
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COLON
operator|||
name|token
operator|==
name|LBRACE
condition|)
break|break;
if|if
condition|(
name|token
operator|==
name|SEMIC
operator|||
name|token
operator|==
name|RANGLE
condition|)
return|return
literal|false
return|;
block|}
do|while
condition|(
name|token
condition|)
do|;
if|if
condition|(
operator|!
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
comment|// typedef struct { ... }
return|return
literal|false
return|;
name|QByteArray
name|name
init|=
name|lexem
argument_list|()
decl_stmt|;
comment|// support "class IDENT name" and "class IDENT(IDENT) name"
comment|// also support "class IDENT name (final|sealed|Q_DECL_FINAL)"
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|until
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
return|return
literal|false
return|;
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
specifier|const
name|QByteArray
name|lex
init|=
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|lex
operator|!=
literal|"final"
operator|&&
name|lex
operator|!=
literal|"sealed"
operator|&&
name|lex
operator|!=
literal|"Q_DECL_FINAL"
condition|)
name|name
operator|=
name|lex
expr_stmt|;
block|}
name|def
operator|->
name|qualified
operator|+=
name|name
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|def
operator|->
name|qualified
operator|+=
name|lexem
argument_list|()
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
name|def
operator|->
name|qualified
operator|+=
name|name
expr_stmt|;
block|}
block|}
name|def
operator|->
name|classname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
specifier|const
name|QByteArray
name|lex
init|=
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|lex
operator|!=
literal|"final"
operator|&&
name|lex
operator|!=
literal|"sealed"
operator|&&
name|lex
operator|!=
literal|"Q_DECL_FINAL"
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|test
argument_list|(
name|COLON
argument_list|)
condition|)
block|{
do|do
block|{
name|test
argument_list|(
name|VIRTUAL
argument_list|)
expr_stmt|;
name|FunctionDef
operator|::
name|Access
name|access
init|=
name|FunctionDef
operator|::
name|Public
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PRIVATE
argument_list|)
condition|)
name|access
operator|=
name|FunctionDef
operator|::
name|Private
expr_stmt|;
elseif|else
if|if
condition|(
name|test
argument_list|(
name|PROTECTED
argument_list|)
condition|)
name|access
operator|=
name|FunctionDef
operator|::
name|Protected
expr_stmt|;
else|else
name|test
argument_list|(
name|PUBLIC
argument_list|)
expr_stmt|;
name|test
argument_list|(
name|VIRTUAL
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
name|type
init|=
name|parseType
argument_list|()
operator|.
name|name
decl_stmt|;
comment|// ignore the 'class Foo : BAR(Baz)' case
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|until
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|def
operator|->
name|superclassList
operator|+=
name|qMakePair
argument_list|(
name|type
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|test
argument_list|(
name|COMMA
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|test
argument_list|(
name|LBRACE
argument_list|)
condition|)
return|return
literal|false
return|;
name|def
operator|->
name|begin
operator|=
name|index
operator|-
literal|1
expr_stmt|;
name|bool
name|foundRBrace
init|=
name|until
argument_list|(
name|RBRACE
argument_list|)
decl_stmt|;
name|def
operator|->
name|end
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|def
operator|->
name|begin
operator|+
literal|1
expr_stmt|;
return|return
name|foundRBrace
return|;
block|}
end_function
begin_function
DECL|function|parseType
name|Type
name|Moc
operator|::
name|parseType
parameter_list|()
block|{
name|Type
name|type
decl_stmt|;
name|bool
name|hasSignedOrUnsigned
init|=
literal|false
decl_stmt|;
name|bool
name|isVoid
init|=
literal|false
decl_stmt|;
name|type
operator|.
name|firstToken
operator|=
name|lookup
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|SIGNED
case|:
case|case
name|UNSIGNED
case|:
name|hasSignedOrUnsigned
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|CONST
case|:
case|case
name|VOLATILE
case|:
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|type
operator|.
name|name
operator|+=
literal|' '
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
literal|0
argument_list|)
operator|==
name|VOLATILE
condition|)
name|type
operator|.
name|isVolatile
operator|=
literal|true
expr_stmt|;
continue|continue;
case|case
name|Q_MOC_COMPAT_TOKEN
case|:
case|case
name|Q_INVOKABLE_TOKEN
case|:
case|case
name|Q_SCRIPTABLE_TOKEN
case|:
case|case
name|Q_SIGNALS_TOKEN
case|:
case|case
name|Q_SLOTS_TOKEN
case|:
case|case
name|Q_SIGNAL_TOKEN
case|:
case|case
name|Q_SLOT_TOKEN
case|:
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
return|return
name|type
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|test
argument_list|(
name|ENUM
argument_list|)
operator|||
name|test
argument_list|(
name|CLASS
argument_list|)
operator|||
name|test
argument_list|(
name|STRUCT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
comment|// void mySlot(unsigned myArg)
if|if
condition|(
name|hasSignedOrUnsigned
condition|)
block|{
name|prev
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|CHAR
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
comment|// preserve '[unsigned] long long', 'short int', 'long int', 'long double'
if|if
condition|(
name|test
argument_list|(
name|LONG
argument_list|)
operator|||
name|test
argument_list|(
name|INT
argument_list|)
operator|||
name|test
argument_list|(
name|DOUBLE
argument_list|)
condition|)
block|{
name|type
operator|.
name|name
operator|+=
literal|' '
expr_stmt|;
name|prev
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
case|case
name|VOID
case|:
case|case
name|BOOL
case|:
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|isVoid
operator||=
operator|(
name|lookup
argument_list|(
literal|0
argument_list|)
operator|==
name|VOID
operator|)
expr_stmt|;
break|break;
default|default:
name|prev
argument_list|()
expr_stmt|;
empty_stmt|;
block|}
if|if
condition|(
name|test
argument_list|(
name|LANGLE
argument_list|)
condition|)
block|{
name|QByteArray
name|templ
init|=
name|lexemUntil
argument_list|(
name|RANGLE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|templ
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|type
operator|.
name|name
operator|+=
name|templ
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|templ
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'<'
operator|&&
name|i
operator|+
literal|1
operator|<
name|templ
operator|.
name|size
argument_list|()
operator|&&
name|templ
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|':'
operator|)
operator|||
operator|(
name|templ
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'>'
operator|&&
name|i
operator|+
literal|1
operator|<
name|templ
operator|.
name|size
argument_list|()
operator|&&
name|templ
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'>'
operator|)
condition|)
block|{
name|type
operator|.
name|name
operator|+=
literal|' '
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|type
operator|.
name|isScoped
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
while|while
condition|(
name|test
argument_list|(
name|CONST
argument_list|)
operator|||
name|test
argument_list|(
name|VOLATILE
argument_list|)
operator|||
name|test
argument_list|(
name|SIGNED
argument_list|)
operator|||
name|test
argument_list|(
name|UNSIGNED
argument_list|)
operator|||
name|test
argument_list|(
name|STAR
argument_list|)
operator|||
name|test
argument_list|(
name|AND
argument_list|)
operator|||
name|test
argument_list|(
name|ANDAND
argument_list|)
condition|)
block|{
name|type
operator|.
name|name
operator|+=
literal|' '
expr_stmt|;
name|type
operator|.
name|name
operator|+=
name|lexem
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
literal|0
argument_list|)
operator|==
name|AND
condition|)
name|type
operator|.
name|referenceType
operator|=
name|Type
operator|::
name|Reference
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup
argument_list|(
literal|0
argument_list|)
operator|==
name|ANDAND
condition|)
name|type
operator|.
name|referenceType
operator|=
name|Type
operator|::
name|RValueReference
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup
argument_list|(
literal|0
argument_list|)
operator|==
name|STAR
condition|)
name|type
operator|.
name|referenceType
operator|=
name|Type
operator|::
name|Pointer
expr_stmt|;
block|}
name|type
operator|.
name|rawName
operator|=
name|type
operator|.
name|name
expr_stmt|;
comment|// transform stupid things like 'const void' or 'void const' into 'void'
if|if
condition|(
name|isVoid
operator|&&
name|type
operator|.
name|referenceType
operator|==
name|Type
operator|::
name|NoReference
condition|)
block|{
name|type
operator|.
name|name
operator|=
literal|"void"
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|parseEnum
name|bool
name|Moc
operator|::
name|parseEnum
parameter_list|(
name|EnumDef
modifier|*
name|def
parameter_list|)
block|{
name|bool
name|isTypdefEnum
init|=
literal|false
decl_stmt|;
comment|// typedef enum { ... } Foo;
if|if
condition|(
name|test
argument_list|(
name|CLASS
argument_list|)
condition|)
name|def
operator|->
name|isEnumClass
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|def
operator|->
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lookup
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
name|TYPEDEF
condition|)
return|return
literal|false
return|;
comment|// anonymous enum
name|isTypdefEnum
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|test
argument_list|(
name|COLON
argument_list|)
condition|)
block|{
comment|// C++11 strongly typed enum
comment|// enum Foo : unsigned long { ... };
name|parseType
argument_list|()
expr_stmt|;
comment|//ignore the result
block|}
if|if
condition|(
operator|!
name|test
argument_list|(
name|LBRACE
argument_list|)
condition|)
return|return
literal|false
return|;
do|do
block|{
if|if
condition|(
name|lookup
argument_list|()
operator|==
name|RBRACE
condition|)
comment|// accept trailing comma
break|break;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|def
operator|->
name|values
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|test
argument_list|(
name|EQ
argument_list|)
condition|?
name|until
argument_list|(
name|COMMA
argument_list|)
else|:
name|test
argument_list|(
name|COMMA
argument_list|)
condition|)
do|;
name|next
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTypdefEnum
condition|)
block|{
if|if
condition|(
operator|!
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
return|return
literal|false
return|;
name|def
operator|->
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parseFunctionArguments
name|void
name|Moc
operator|::
name|parseFunctionArguments
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|def
argument_list|)
expr_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|ArgumentDef
name|arg
decl_stmt|;
name|arg
operator|.
name|type
operator|=
name|parseType
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|type
operator|.
name|name
operator|==
literal|"void"
condition|)
break|break;
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
name|arg
operator|.
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|LBRACK
argument_list|)
condition|)
block|{
name|arg
operator|.
name|rightType
operator|+=
name|lexemUntil
argument_list|(
name|RBRACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|test
argument_list|(
name|CONST
argument_list|)
operator|||
name|test
argument_list|(
name|VOLATILE
argument_list|)
condition|)
block|{
name|arg
operator|.
name|rightType
operator|+=
literal|' '
expr_stmt|;
name|arg
operator|.
name|rightType
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
name|arg
operator|.
name|normalizedType
operator|=
name|normalizeType
argument_list|(
name|QByteArray
argument_list|(
name|arg
operator|.
name|type
operator|.
name|name
operator|+
literal|' '
operator|+
name|arg
operator|.
name|rightType
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|.
name|typeNameForCast
operator|=
name|normalizeType
argument_list|(
name|QByteArray
argument_list|(
name|noRef
argument_list|(
name|arg
operator|.
name|type
operator|.
name|name
argument_list|)
operator|+
literal|"(*)"
operator|+
name|arg
operator|.
name|rightType
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|EQ
argument_list|)
condition|)
name|arg
operator|.
name|isDefault
operator|=
literal|true
expr_stmt|;
name|def
operator|->
name|arguments
operator|+=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|until
argument_list|(
name|COMMA
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|def
operator|->
name|arguments
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|->
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|normalizedType
operator|==
literal|"QPrivateSignal"
condition|)
block|{
name|def
operator|->
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|->
name|isPrivateSignal
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|testFunctionAttribute
name|bool
name|Moc
operator|::
name|testFunctionAttribute
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|symbols
operator|.
name|size
argument_list|()
operator|&&
name|testFunctionAttribute
argument_list|(
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
argument_list|,
name|def
argument_list|)
condition|)
block|{
operator|++
name|index
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|testFunctionAttribute
name|bool
name|Moc
operator|::
name|testFunctionAttribute
parameter_list|(
name|Token
name|tok
parameter_list|,
name|FunctionDef
modifier|*
name|def
parameter_list|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|Q_MOC_COMPAT_TOKEN
case|:
name|def
operator|->
name|isCompat
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
case|case
name|Q_INVOKABLE_TOKEN
case|:
name|def
operator|->
name|isInvokable
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
case|case
name|Q_SIGNAL_TOKEN
case|:
name|def
operator|->
name|isSignal
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
case|case
name|Q_SLOT_TOKEN
case|:
name|def
operator|->
name|isSlot
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
case|case
name|Q_SCRIPTABLE_TOKEN
case|:
name|def
operator|->
name|isInvokable
operator|=
name|def
operator|->
name|isScriptable
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|testFunctionRevision
name|bool
name|Moc
operator|::
name|testFunctionRevision
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|)
block|{
if|if
condition|(
name|test
argument_list|(
name|Q_REVISION_TOKEN
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|revision
init|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
decl_stmt|;
name|revision
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|revision
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|def
operator|->
name|revision
operator|=
name|revision
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|def
operator|->
name|revision
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid revision"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// returns false if the function should be ignored
end_comment
begin_function
DECL|function|parseFunction
name|bool
name|Moc
operator|::
name|parseFunction
parameter_list|(
name|FunctionDef
modifier|*
name|def
parameter_list|,
name|bool
name|inMacro
parameter_list|)
block|{
name|def
operator|->
name|isVirtual
operator|=
literal|false
expr_stmt|;
name|def
operator|->
name|isStatic
operator|=
literal|false
expr_stmt|;
comment|//skip modifiers and attributes
while|while
condition|(
name|test
argument_list|(
name|INLINE
argument_list|)
operator|||
operator|(
name|test
argument_list|(
name|STATIC
argument_list|)
operator|&&
operator|(
name|def
operator|->
name|isStatic
operator|=
literal|true
operator|)
operator|)
operator|||
operator|(
name|test
argument_list|(
name|VIRTUAL
argument_list|)
operator|&&
operator|(
name|def
operator|->
name|isVirtual
operator|=
literal|true
operator|)
operator|)
comment|//mark as virtual
operator|||
name|testFunctionAttribute
argument_list|(
name|def
argument_list|)
operator|||
name|testFunctionRevision
argument_list|(
name|def
argument_list|)
condition|)
block|{}
name|bool
name|templateFunction
init|=
operator|(
name|lookup
argument_list|()
operator|==
name|TEMPLATE
operator|)
decl_stmt|;
name|def
operator|->
name|type
operator|=
name|parseType
argument_list|()
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|templateFunction
condition|)
name|error
argument_list|(
literal|"Template function as signal or slot"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|()
expr_stmt|;
block|}
name|bool
name|scopedFunctionName
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|def
operator|->
name|name
operator|=
name|def
operator|->
name|type
operator|.
name|name
expr_stmt|;
name|scopedFunctionName
operator|=
name|def
operator|->
name|type
operator|.
name|isScoped
expr_stmt|;
name|def
operator|->
name|type
operator|=
name|Type
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Type
name|tempType
init|=
name|parseType
argument_list|()
decl_stmt|;
empty_stmt|;
while|while
condition|(
operator|!
name|tempType
operator|.
name|name
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lookup
argument_list|()
operator|!=
name|LPAREN
condition|)
block|{
if|if
condition|(
name|testFunctionAttribute
argument_list|(
name|def
operator|->
name|type
operator|.
name|firstToken
argument_list|,
name|def
argument_list|)
condition|)
empty_stmt|;
comment|// fine
elseif|else
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|firstToken
operator|==
name|Q_SIGNALS_TOKEN
condition|)
name|error
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|firstToken
operator|==
name|Q_SLOTS_TOKEN
condition|)
name|error
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|def
operator|->
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
name|def
operator|->
name|tag
operator|+=
literal|' '
expr_stmt|;
name|def
operator|->
name|tag
operator|+=
name|def
operator|->
name|type
operator|.
name|name
expr_stmt|;
block|}
name|def
operator|->
name|type
operator|=
name|tempType
expr_stmt|;
name|tempType
operator|=
name|parseType
argument_list|()
expr_stmt|;
block|}
name|next
argument_list|(
name|LPAREN
argument_list|,
literal|"Not a signal or slot declaration"
argument_list|)
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|tempType
operator|.
name|name
expr_stmt|;
name|scopedFunctionName
operator|=
name|tempType
operator|.
name|isScoped
expr_stmt|;
block|}
comment|// we don't support references as return types, it's too dangerous
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|referenceType
operator|==
name|Type
operator|::
name|Reference
condition|)
block|{
name|QByteArray
name|rawName
init|=
name|def
operator|->
name|type
operator|.
name|rawName
decl_stmt|;
name|def
operator|->
name|type
operator|=
name|Type
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|def
operator|->
name|type
operator|.
name|rawName
operator|=
name|rawName
expr_stmt|;
block|}
name|def
operator|->
name|normalizedType
operator|=
name|normalizeType
argument_list|(
name|def
operator|->
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
argument_list|(
name|RPAREN
argument_list|)
condition|)
block|{
name|parseFunctionArguments
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
comment|// support optional macros with compiler specific options
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
empty_stmt|;
name|def
operator|->
name|isConst
operator|=
name|test
argument_list|(
name|CONST
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|inMacro
condition|)
block|{
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
name|prev
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|test
argument_list|(
name|THROW
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|until
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|test
argument_list|(
name|SEMIC
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|def
operator|->
name|inlineCode
operator|=
name|test
argument_list|(
name|LBRACE
argument_list|)
operator|)
condition|)
name|until
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|def
operator|->
name|isAbstract
operator|=
name|test
argument_list|(
name|EQ
argument_list|)
operator|)
condition|)
name|until
argument_list|(
name|SEMIC
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scopedFunctionName
condition|)
block|{
name|QByteArray
name|msg
argument_list|(
literal|"Function declaration "
argument_list|)
decl_stmt|;
name|msg
operator|+=
name|def
operator|->
name|name
expr_stmt|;
name|msg
operator|+=
literal|" contains extra qualification. Ignoring as signal or slot."
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// like parseFunction, but never aborts with an error
end_comment
begin_function
DECL|function|parseMaybeFunction
name|bool
name|Moc
operator|::
name|parseMaybeFunction
parameter_list|(
specifier|const
name|ClassDef
modifier|*
name|cdef
parameter_list|,
name|FunctionDef
modifier|*
name|def
parameter_list|)
block|{
name|def
operator|->
name|isVirtual
operator|=
literal|false
expr_stmt|;
name|def
operator|->
name|isStatic
operator|=
literal|false
expr_stmt|;
comment|//skip modifiers and attributes
while|while
condition|(
name|test
argument_list|(
name|EXPLICIT
argument_list|)
operator|||
name|test
argument_list|(
name|INLINE
argument_list|)
operator|||
operator|(
name|test
argument_list|(
name|STATIC
argument_list|)
operator|&&
operator|(
name|def
operator|->
name|isStatic
operator|=
literal|true
operator|)
operator|)
operator|||
operator|(
name|test
argument_list|(
name|VIRTUAL
argument_list|)
operator|&&
operator|(
name|def
operator|->
name|isVirtual
operator|=
literal|true
operator|)
operator|)
comment|//mark as virtual
operator|||
name|testFunctionAttribute
argument_list|(
name|def
argument_list|)
operator|||
name|testFunctionRevision
argument_list|(
name|def
argument_list|)
condition|)
block|{}
name|bool
name|tilde
init|=
name|test
argument_list|(
name|TILDE
argument_list|)
decl_stmt|;
name|def
operator|->
name|type
operator|=
name|parseType
argument_list|()
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|scopedFunctionName
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|def
operator|->
name|name
operator|=
name|def
operator|->
name|type
operator|.
name|name
expr_stmt|;
name|scopedFunctionName
operator|=
name|def
operator|->
name|type
operator|.
name|isScoped
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|name
operator|==
name|cdef
operator|->
name|classname
condition|)
block|{
name|def
operator|->
name|isDestructor
operator|=
name|tilde
expr_stmt|;
name|def
operator|->
name|isConstructor
operator|=
operator|!
name|tilde
expr_stmt|;
name|def
operator|->
name|type
operator|=
name|Type
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|def
operator|->
name|type
operator|=
name|Type
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Type
name|tempType
init|=
name|parseType
argument_list|()
decl_stmt|;
empty_stmt|;
while|while
condition|(
operator|!
name|tempType
operator|.
name|name
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lookup
argument_list|()
operator|!=
name|LPAREN
condition|)
block|{
if|if
condition|(
name|testFunctionAttribute
argument_list|(
name|def
operator|->
name|type
operator|.
name|firstToken
argument_list|,
name|def
argument_list|)
condition|)
empty_stmt|;
comment|// fine
elseif|else
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|==
literal|"Q_SIGNAL"
condition|)
name|def
operator|->
name|isSignal
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|name
operator|==
literal|"Q_SLOT"
condition|)
name|def
operator|->
name|isSlot
operator|=
literal|true
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|def
operator|->
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
name|def
operator|->
name|tag
operator|+=
literal|' '
expr_stmt|;
name|def
operator|->
name|tag
operator|+=
name|def
operator|->
name|type
operator|.
name|name
expr_stmt|;
block|}
name|def
operator|->
name|type
operator|=
name|tempType
expr_stmt|;
name|tempType
operator|=
name|parseType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
return|return
literal|false
return|;
name|def
operator|->
name|name
operator|=
name|tempType
operator|.
name|name
expr_stmt|;
name|scopedFunctionName
operator|=
name|tempType
operator|.
name|isScoped
expr_stmt|;
block|}
comment|// we don't support references as return types, it's too dangerous
if|if
condition|(
name|def
operator|->
name|type
operator|.
name|referenceType
operator|==
name|Type
operator|::
name|Reference
condition|)
block|{
name|QByteArray
name|rawName
init|=
name|def
operator|->
name|type
operator|.
name|rawName
decl_stmt|;
name|def
operator|->
name|type
operator|=
name|Type
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|def
operator|->
name|type
operator|.
name|rawName
operator|=
name|rawName
expr_stmt|;
block|}
name|def
operator|->
name|normalizedType
operator|=
name|normalizeType
argument_list|(
name|def
operator|->
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
argument_list|(
name|RPAREN
argument_list|)
condition|)
block|{
name|parseFunctionArguments
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
argument_list|(
name|RPAREN
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|def
operator|->
name|isConst
operator|=
name|test
argument_list|(
name|CONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|scopedFunctionName
operator|&&
operator|(
name|def
operator|->
name|isSignal
operator|||
name|def
operator|->
name|isSlot
operator|||
name|def
operator|->
name|isInvokable
operator|)
condition|)
block|{
name|QByteArray
name|msg
argument_list|(
literal|"parsemaybe: Function declaration "
argument_list|)
decl_stmt|;
name|msg
operator|+=
name|def
operator|->
name|name
expr_stmt|;
name|msg
operator|+=
literal|" contains extra qualification. Ignoring as signal or slot."
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parse
name|void
name|Moc
operator|::
name|parse
parameter_list|()
block|{
name|QList
argument_list|<
name|NamespaceDef
argument_list|>
name|namespaceList
decl_stmt|;
name|bool
name|templateClass
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|t
init|=
name|next
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|NAMESPACE
case|:
block|{
name|int
name|rewind
init|=
name|index
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
if|if
condition|(
name|test
argument_list|(
name|EQ
argument_list|)
condition|)
block|{
comment|// namespace Foo = Bar::Baz;
name|until
argument_list|(
name|SEMIC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|test
argument_list|(
name|SEMIC
argument_list|)
condition|)
block|{
name|NamespaceDef
name|def
decl_stmt|;
name|def
operator|.
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|LBRACE
argument_list|)
expr_stmt|;
name|def
operator|.
name|begin
operator|=
name|index
operator|-
literal|1
expr_stmt|;
name|until
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
name|def
operator|.
name|end
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|def
operator|.
name|begin
operator|+
literal|1
expr_stmt|;
name|namespaceList
operator|+=
name|def
expr_stmt|;
name|index
operator|=
name|rewind
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SEMIC
case|:
case|case
name|RBRACE
case|:
name|templateClass
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|TEMPLATE
case|:
name|templateClass
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|MOC_INCLUDE_BEGIN
case|:
name|currentFilenames
operator|.
name|push
argument_list|(
name|symbol
argument_list|()
operator|.
name|unquotedLexem
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOC_INCLUDE_END
case|:
name|currentFilenames
operator|.
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
name|Q_DECLARE_INTERFACE_TOKEN
case|:
name|parseDeclareInterface
argument_list|()
expr_stmt|;
break|break;
case|case
name|Q_DECLARE_METATYPE_TOKEN
case|:
name|parseDeclareMetatype
argument_list|()
expr_stmt|;
break|break;
case|case
name|USING
case|:
if|if
condition|(
name|test
argument_list|(
name|NAMESPACE
argument_list|)
condition|)
block|{
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
operator|||
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
empty_stmt|;
name|next
argument_list|(
name|SEMIC
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLASS
case|:
case|case
name|STRUCT
case|:
block|{
if|if
condition|(
name|currentFilenames
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
break|break;
name|ClassDef
name|def
decl_stmt|;
if|if
condition|(
operator|!
name|parseClassHead
argument_list|(
operator|&
name|def
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|inClass
argument_list|(
operator|&
name|def
argument_list|)
operator|&&
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|next
argument_list|()
operator|==
name|Q_OBJECT_TOKEN
condition|)
block|{
name|def
operator|.
name|hasQObject
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|def
operator|.
name|hasQObject
condition|)
continue|continue;
for|for
control|(
name|int
name|i
init|=
name|namespaceList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|inNamespace
argument_list|(
operator|&
name|namespaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|def
operator|.
name|qualified
operator|.
name|prepend
argument_list|(
name|namespaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
operator|+
literal|"::"
argument_list|)
expr_stmt|;
name|knownQObjectClasses
operator|.
name|insert
argument_list|(
name|def
operator|.
name|classname
argument_list|)
expr_stmt|;
name|knownQObjectClasses
operator|.
name|insert
argument_list|(
name|def
operator|.
name|qualified
argument_list|)
expr_stmt|;
continue|continue;
block|}
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|t
operator|!=
name|CLASS
operator|&&
name|t
operator|!=
name|STRUCT
operator|)
operator|||
name|currentFilenames
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
continue|continue;
name|ClassDef
name|def
decl_stmt|;
if|if
condition|(
name|parseClassHead
argument_list|(
operator|&
name|def
argument_list|)
condition|)
block|{
name|FunctionDef
operator|::
name|Access
name|access
init|=
name|FunctionDef
operator|::
name|Private
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|namespaceList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|inNamespace
argument_list|(
operator|&
name|namespaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|def
operator|.
name|qualified
operator|.
name|prepend
argument_list|(
name|namespaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
operator|+
literal|"::"
argument_list|)
expr_stmt|;
while|while
condition|(
name|inClass
argument_list|(
operator|&
name|def
argument_list|)
operator|&&
name|hasNext
argument_list|()
condition|)
block|{
switch|switch
condition|(
operator|(
name|t
operator|=
name|next
argument_list|()
operator|)
condition|)
block|{
case|case
name|PRIVATE
case|:
name|access
operator|=
name|FunctionDef
operator|::
name|Private
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|Q_SIGNALS_TOKEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Signals cannot have access specifier"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTECTED
case|:
name|access
operator|=
name|FunctionDef
operator|::
name|Protected
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|Q_SIGNALS_TOKEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Signals cannot have access specifier"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PUBLIC
case|:
name|access
operator|=
name|FunctionDef
operator|::
name|Public
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|Q_SIGNALS_TOKEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Signals cannot have access specifier"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLASS
case|:
block|{
name|ClassDef
name|nestedDef
decl_stmt|;
if|if
condition|(
name|parseClassHead
argument_list|(
operator|&
name|nestedDef
argument_list|)
condition|)
block|{
while|while
condition|(
name|inClass
argument_list|(
operator|&
name|nestedDef
argument_list|)
operator|&&
name|inClass
argument_list|(
operator|&
name|def
argument_list|)
condition|)
block|{
name|t
operator|=
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|>=
name|Q_META_TOKEN_BEGIN
operator|&&
name|t
operator|<
name|Q_META_TOKEN_END
condition|)
name|error
argument_list|(
literal|"Meta object features not supported for nested classes"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Q_SIGNALS_TOKEN
case|:
name|parseSignals
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_SLOTS_TOKEN
case|:
switch|switch
condition|(
name|lookup
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|PUBLIC
case|:
case|case
name|PROTECTED
case|:
case|case
name|PRIVATE
case|:
name|parseSlots
argument_list|(
operator|&
name|def
argument_list|,
name|access
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Missing access specifier for slots"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Q_OBJECT_TOKEN
case|:
name|def
operator|.
name|hasQObject
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|templateClass
condition|)
name|error
argument_list|(
literal|"Template classes not supported by Q_OBJECT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|.
name|classname
operator|!=
literal|"Qt"
operator|&&
name|def
operator|.
name|classname
operator|!=
literal|"QObject"
operator|&&
name|def
operator|.
name|superclassList
operator|.
name|isEmpty
argument_list|()
condition|)
name|error
argument_list|(
literal|"Class contains Q_OBJECT macro but does not inherit from QObject"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_GADGET_TOKEN
case|:
name|def
operator|.
name|hasQGadget
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|templateClass
condition|)
name|error
argument_list|(
literal|"Template classes not supported by Q_GADGET"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_PROPERTY_TOKEN
case|:
name|parseProperty
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_PLUGIN_METADATA_TOKEN
case|:
name|parsePluginData
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_ENUMS_TOKEN
case|:
name|parseEnumOrFlag
argument_list|(
operator|&
name|def
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_FLAGS_TOKEN
case|:
name|parseEnumOrFlag
argument_list|(
operator|&
name|def
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_DECLARE_FLAGS_TOKEN
case|:
name|parseFlag
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_CLASSINFO_TOKEN
case|:
name|parseClassInfo
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_INTERFACES_TOKEN
case|:
name|parseInterfaces
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_PRIVATE_SLOT_TOKEN
case|:
name|parseSlotInPrivate
argument_list|(
operator|&
name|def
argument_list|,
name|access
argument_list|)
expr_stmt|;
break|break;
case|case
name|Q_PRIVATE_PROPERTY_TOKEN
case|:
name|parsePrivateProperty
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
block|{
name|EnumDef
name|enumDef
decl_stmt|;
if|if
condition|(
name|parseEnum
argument_list|(
operator|&
name|enumDef
argument_list|)
condition|)
name|def
operator|.
name|enumList
operator|+=
name|enumDef
expr_stmt|;
block|}
break|break;
case|case
name|SEMIC
case|:
case|case
name|COLON
case|:
break|break;
default|default:
name|FunctionDef
name|funcDef
decl_stmt|;
name|funcDef
operator|.
name|access
operator|=
name|access
expr_stmt|;
name|int
name|rewind
init|=
name|index
operator|--
decl_stmt|;
if|if
condition|(
name|parseMaybeFunction
argument_list|(
operator|&
name|def
argument_list|,
operator|&
name|funcDef
argument_list|)
condition|)
block|{
if|if
condition|(
name|funcDef
operator|.
name|isConstructor
condition|)
block|{
if|if
condition|(
operator|(
name|access
operator|==
name|FunctionDef
operator|::
name|Public
operator|)
operator|&&
name|funcDef
operator|.
name|isInvokable
condition|)
block|{
name|def
operator|.
name|constructorList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|.
name|constructorList
operator|+=
name|funcDef
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|funcDef
operator|.
name|isDestructor
condition|)
block|{
comment|// don't care about destructors
block|}
else|else
block|{
if|if
condition|(
name|access
operator|==
name|FunctionDef
operator|::
name|Public
condition|)
name|def
operator|.
name|publicList
operator|+=
name|funcDef
expr_stmt|;
if|if
condition|(
name|funcDef
operator|.
name|isSlot
condition|)
block|{
name|def
operator|.
name|slotList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|.
name|slotList
operator|+=
name|funcDef
expr_stmt|;
block|}
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|.
name|revisionedMethods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|funcDef
operator|.
name|isSignal
condition|)
block|{
name|def
operator|.
name|signalList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|.
name|signalList
operator|+=
name|funcDef
expr_stmt|;
block|}
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|.
name|revisionedMethods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|funcDef
operator|.
name|isInvokable
condition|)
block|{
name|def
operator|.
name|methodList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|.
name|methodList
operator|+=
name|funcDef
expr_stmt|;
block|}
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|.
name|revisionedMethods
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|index
operator|=
name|rewind
expr_stmt|;
block|}
block|}
block|}
name|next
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|.
name|hasQObject
operator|&&
operator|!
name|def
operator|.
name|hasQGadget
operator|&&
name|def
operator|.
name|signalList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|.
name|slotList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|.
name|propertyList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|def
operator|.
name|enumDeclarations
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|// no meta object code required
if|if
condition|(
operator|!
name|def
operator|.
name|hasQObject
operator|&&
operator|!
name|def
operator|.
name|hasQGadget
condition|)
name|error
argument_list|(
literal|"Class declarations lacks Q_OBJECT macro."
argument_list|)
expr_stmt|;
name|checkSuperClasses
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|checkProperties
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|classList
operator|+=
name|def
expr_stmt|;
name|knownQObjectClasses
operator|.
name|insert
argument_list|(
name|def
operator|.
name|classname
argument_list|)
expr_stmt|;
name|knownQObjectClasses
operator|.
name|insert
argument_list|(
name|def
operator|.
name|qualified
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|findRequiredContainers
specifier|static
name|void
name|findRequiredContainers
parameter_list|(
name|ClassDef
modifier|*
name|cdef
parameter_list|,
name|QSet
argument_list|<
name|QByteArray
argument_list|>
modifier|*
name|requiredQtContainers
parameter_list|)
block|{
specifier|static
specifier|const
name|QVector
argument_list|<
name|QByteArray
argument_list|>
name|candidates
init|=
name|QVector
operator|<
name|QByteArray
operator|>
operator|(
operator|)
DECL|macro|STREAM_SMART_POINTER
define|#
directive|define
name|STREAM_SMART_POINTER
parameter_list|(
name|SMART_POINTER
parameter_list|)
value|<< #SMART_POINTER
name|QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER
argument_list|(
argument|STREAM_SMART_POINTER
argument_list|)
DECL|macro|STREAM_SMART_POINTER
undef|#
directive|undef
name|STREAM_SMART_POINTER
DECL|macro|STREAM_1ARG_TEMPLATE
define|#
directive|define
name|STREAM_1ARG_TEMPLATE
parameter_list|(
name|TEMPLATENAME
parameter_list|)
value|<< #TEMPLATENAME
name|QT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG
argument_list|(
name|STREAM_1ARG_TEMPLATE
argument_list|)
DECL|macro|STREAM_1ARG_TEMPLATE
undef|#
directive|undef
name|STREAM_1ARG_TEMPLATE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
name|candidate
decl|,
name|candidates
control|)
block|{
if|if
condition|(
name|p
operator|.
name|type
operator|.
name|contains
argument_list|(
name|candidate
operator|+
literal|"<"
argument_list|)
condition|)
name|requiredQtContainers
operator|->
name|insert
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
name|QList
argument_list|<
name|FunctionDef
argument_list|>
name|allFunctions
init|=
name|cdef
operator|->
name|slotList
operator|+
name|cdef
operator|->
name|signalList
operator|+
name|cdef
operator|->
name|methodList
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allFunctions
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|allFunctions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ArgumentDef
modifier|&
name|arg
decl|,
name|f
operator|.
name|arguments
control|)
block|{
foreach|foreach
control|(
specifier|const
name|QByteArray
name|candidate
decl|,
name|candidates
control|)
block|{
if|if
condition|(
name|arg
operator|.
name|normalizedType
operator|.
name|contains
argument_list|(
name|candidate
operator|+
literal|"<"
argument_list|)
condition|)
name|requiredQtContainers
operator|->
name|insert
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|generate
name|void
name|Moc
operator|::
name|generate
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|QByteArray
name|fn
init|=
name|filename
decl_stmt|;
name|int
name|i
init|=
name|filename
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|filename
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|filename
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
operator|--
name|i
expr_stmt|;
comment|// skip path
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|fn
operator|=
name|filename
operator|.
name|mid
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"/****************************************************************************\n"
literal|"** Meta object code from reading C++ file '%s'\n**\n"
argument_list|,
name|fn
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"** Created by: The Qt Meta Object Compiler version %d (Qt %s)\n**\n"
argument_list|,
name|mocOutputRevision
argument_list|,
name|QT_VERSION_STR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"** WARNING! All changes made in this file will be lost!\n"
literal|"*****************************************************************************/\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noInclude
condition|)
block|{
if|if
condition|(
name|includePath
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|includePath
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|includePath
operator|+=
literal|'/'
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|includeFiles
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|inc
init|=
name|includeFiles
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|inc
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|&&
name|inc
index|[
literal|0
index|]
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|includePath
operator|.
name|size
argument_list|()
operator|&&
name|includePath
operator|!=
literal|"./"
condition|)
name|inc
operator|.
name|prepend
argument_list|(
name|includePath
argument_list|)
expr_stmt|;
name|inc
operator|=
literal|'\"'
operator|+
name|inc
operator|+
literal|'\"'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include %s\n"
argument_list|,
name|inc
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|classList
operator|.
name|size
argument_list|()
operator|&&
name|classList
operator|.
name|first
argument_list|()
operator|.
name|classname
operator|==
literal|"Qt"
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<QtCore/qobject.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<QtCore/qbytearray.h>\n"
argument_list|)
expr_stmt|;
comment|// For QByteArrayData
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<QtCore/qmetatype.h>\n"
argument_list|)
expr_stmt|;
comment|// For QMetaType::Type
if|if
condition|(
name|mustIncludeQPluginH
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<QtCore/qplugin.h>\n"
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|requiredQtContainers
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|classList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|findRequiredContainers
argument_list|(
operator|&
name|classList
index|[
name|i
index|]
argument_list|,
operator|&
name|requiredQtContainers
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|qtContainer
decl|,
name|requiredQtContainers
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<QtCore/%s>\n"
argument_list|,
name|qtContainer
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#if !defined(Q_MOC_OUTPUT_REVISION)\n"
literal|"#error \"The header file '%s' doesn't include<QObject>.\"\n"
argument_list|,
name|fn
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#elif Q_MOC_OUTPUT_REVISION != %d\n"
argument_list|,
name|mocOutputRevision
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#error \"This file was generated using the moc from %s."
literal|" It\"\n#error \"cannot be used with the include files from"
literal|" this version of Qt.\"\n#error \"(The moc has changed too"
literal|" much.)\"\n"
argument_list|,
name|QT_VERSION_STR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QT_BEGIN_MOC_NAMESPACE\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|classList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Generator
name|generator
argument_list|(
operator|&
name|classList
index|[
name|i
index|]
argument_list|,
name|metaTypes
argument_list|,
name|knownQObjectClasses
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|generator
operator|.
name|generateCode
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"QT_END_MOC_NAMESPACE\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseSlots
name|void
name|Moc
operator|::
name|parseSlots
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|,
name|FunctionDef
operator|::
name|Access
name|access
parameter_list|)
block|{
name|int
name|defaultRevision
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|Q_REVISION_TOKEN
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|revision
init|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
decl_stmt|;
name|revision
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|revision
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|defaultRevision
operator|=
name|revision
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|defaultRevision
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid revision"
argument_list|)
expr_stmt|;
block|}
name|next
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
while|while
condition|(
name|inClass
argument_list|(
name|def
argument_list|)
operator|&&
name|hasNext
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PUBLIC
case|:
case|case
name|PROTECTED
case|:
case|case
name|PRIVATE
case|:
case|case
name|Q_SIGNALS_TOKEN
case|:
case|case
name|Q_SLOTS_TOKEN
case|:
name|prev
argument_list|()
expr_stmt|;
return|return;
case|case
name|SEMIC
case|:
continue|continue;
case|case
name|FRIEND
case|:
name|until
argument_list|(
name|SEMIC
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USING
case|:
name|error
argument_list|(
literal|"'using' directive not supported in 'slots' section"
argument_list|)
expr_stmt|;
default|default:
name|prev
argument_list|()
expr_stmt|;
block|}
name|FunctionDef
name|funcDef
decl_stmt|;
name|funcDef
operator|.
name|access
operator|=
name|access
expr_stmt|;
if|if
condition|(
operator|!
name|parseFunction
argument_list|(
operator|&
name|funcDef
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
block|{
operator|++
name|def
operator|->
name|revisionedMethods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultRevision
operator|!=
operator|-
literal|1
condition|)
block|{
name|funcDef
operator|.
name|revision
operator|=
name|defaultRevision
expr_stmt|;
operator|++
name|def
operator|->
name|revisionedMethods
expr_stmt|;
block|}
name|def
operator|->
name|slotList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|->
name|slotList
operator|+=
name|funcDef
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|parseSignals
name|void
name|Moc
operator|::
name|parseSignals
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|int
name|defaultRevision
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|Q_REVISION_TOKEN
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|revision
init|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
decl_stmt|;
name|revision
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|revision
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|defaultRevision
operator|=
name|revision
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|defaultRevision
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid revision"
argument_list|)
expr_stmt|;
block|}
name|next
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
while|while
condition|(
name|inClass
argument_list|(
name|def
argument_list|)
operator|&&
name|hasNext
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PUBLIC
case|:
case|case
name|PROTECTED
case|:
case|case
name|PRIVATE
case|:
case|case
name|Q_SIGNALS_TOKEN
case|:
case|case
name|Q_SLOTS_TOKEN
case|:
name|prev
argument_list|()
expr_stmt|;
return|return;
case|case
name|SEMIC
case|:
continue|continue;
case|case
name|FRIEND
case|:
name|until
argument_list|(
name|SEMIC
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USING
case|:
name|error
argument_list|(
literal|"'using' directive not supported in 'signals' section"
argument_list|)
expr_stmt|;
default|default:
name|prev
argument_list|()
expr_stmt|;
block|}
name|FunctionDef
name|funcDef
decl_stmt|;
name|funcDef
operator|.
name|access
operator|=
name|FunctionDef
operator|::
name|Protected
expr_stmt|;
name|parseFunction
argument_list|(
operator|&
name|funcDef
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcDef
operator|.
name|isVirtual
condition|)
name|warning
argument_list|(
literal|"Signals cannot be declared virtual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcDef
operator|.
name|inlineCode
condition|)
name|error
argument_list|(
literal|"Not a signal declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
block|{
operator|++
name|def
operator|->
name|revisionedMethods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultRevision
operator|!=
operator|-
literal|1
condition|)
block|{
name|funcDef
operator|.
name|revision
operator|=
name|defaultRevision
expr_stmt|;
operator|++
name|def
operator|->
name|revisionedMethods
expr_stmt|;
block|}
name|def
operator|->
name|signalList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|->
name|signalList
operator|+=
name|funcDef
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|createPropertyDef
name|void
name|Moc
operator|::
name|createPropertyDef
parameter_list|(
name|PropertyDef
modifier|&
name|propDef
parameter_list|)
block|{
name|QByteArray
name|type
init|=
name|parseType
argument_list|()
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isEmpty
argument_list|()
condition|)
name|error
argument_list|()
expr_stmt|;
name|propDef
operator|.
name|designable
operator|=
name|propDef
operator|.
name|scriptable
operator|=
name|propDef
operator|.
name|stored
operator|=
literal|"true"
expr_stmt|;
name|propDef
operator|.
name|user
operator|=
literal|"false"
expr_stmt|;
comment|/*       The Q_PROPERTY construct cannot contain any commas, since       commas separate macro arguments. We therefore expect users       to type "QMap" instead of "QMap<QString, QVariant>". For       coherence, we also expect the same for       QValueList<QVariant>, the other template class supported by       QVariant.     */
name|type
operator|=
name|normalizeType
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|"QMap"
condition|)
name|type
operator|=
literal|"QMap<QString,QVariant>"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"QValueList"
condition|)
name|type
operator|=
literal|"QValueList<QVariant>"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"LongLong"
condition|)
name|type
operator|=
literal|"qlonglong"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"ULongLong"
condition|)
name|type
operator|=
literal|"qulonglong"
expr_stmt|;
name|propDef
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
name|propDef
operator|.
name|name
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|QByteArray
name|l
init|=
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|l
operator|==
literal|"CONSTANT"
condition|)
block|{
name|propDef
operator|.
name|constant
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|l
operator|==
literal|"FINAL"
condition|)
block|{
name|propDef
operator|.
name|final
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|v
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|v
operator|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test
argument_list|(
name|INTEGER_LITERAL
argument_list|)
condition|)
block|{
name|v
operator|=
name|lexem
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|!=
literal|"REVISION"
condition|)
name|error
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|v
operator|=
name|lexem
argument_list|()
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
name|v2
operator|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|!=
literal|"true"
operator|&&
name|v
operator|!=
literal|"false"
condition|)
name|v2
operator|=
literal|"()"
expr_stmt|;
block|}
switch|switch
condition|(
name|l
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'R'
case|:
if|if
condition|(
name|l
operator|==
literal|"READ"
condition|)
name|propDef
operator|.
name|read
operator|=
name|v
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|"RESET"
condition|)
name|propDef
operator|.
name|reset
operator|=
name|v
operator|+
name|v2
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|"REVISION"
condition|)
block|{
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|propDef
operator|.
name|revision
operator|=
name|v
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|propDef
operator|.
name|revision
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|l
operator|==
literal|"SCRIPTABLE"
condition|)
name|propDef
operator|.
name|scriptable
operator|=
name|v
operator|+
name|v2
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|"STORED"
condition|)
name|propDef
operator|.
name|stored
operator|=
name|v
operator|+
name|v2
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|l
operator|!=
literal|"WRITE"
condition|)
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|write
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|l
operator|!=
literal|"DESIGNABLE"
condition|)
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|designable
operator|=
name|v
operator|+
name|v2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|l
operator|!=
literal|"EDITABLE"
condition|)
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|editable
operator|=
name|v
operator|+
name|v2
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|l
operator|!=
literal|"NOTIFY"
condition|)
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|notify
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|l
operator|!=
literal|"USER"
condition|)
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|user
operator|=
name|v
operator|+
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|propDef
operator|.
name|read
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Property declaration "
expr_stmt|;
name|msg
operator|+=
name|propDef
operator|.
name|name
expr_stmt|;
name|msg
operator|+=
literal|" has no READ accessor function. The property will be invalid."
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|propDef
operator|.
name|constant
operator|&&
operator|!
name|propDef
operator|.
name|write
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Property declaration "
expr_stmt|;
name|msg
operator|+=
name|propDef
operator|.
name|name
expr_stmt|;
name|msg
operator|+=
literal|" is both WRITEable and CONSTANT. CONSTANT will be ignored."
expr_stmt|;
name|propDef
operator|.
name|constant
operator|=
literal|false
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|propDef
operator|.
name|constant
operator|&&
operator|!
name|propDef
operator|.
name|notify
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Property declaration "
expr_stmt|;
name|msg
operator|+=
name|propDef
operator|.
name|name
expr_stmt|;
name|msg
operator|+=
literal|" is both NOTIFYable and CONSTANT. CONSTANT will be ignored."
expr_stmt|;
name|propDef
operator|.
name|constant
operator|=
literal|false
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parseProperty
name|void
name|Moc
operator|::
name|parseProperty
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|PropertyDef
name|propDef
decl_stmt|;
name|createPropertyDef
argument_list|(
name|propDef
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|propDef
operator|.
name|notify
operator|.
name|isEmpty
argument_list|()
condition|)
name|def
operator|->
name|notifyableProperties
operator|++
expr_stmt|;
if|if
condition|(
name|propDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|->
name|revisionedProperties
expr_stmt|;
name|def
operator|->
name|propertyList
operator|+=
name|propDef
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parsePluginData
name|void
name|Moc
operator|::
name|parsePluginData
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|metaData
decl_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|QByteArray
name|l
init|=
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|"IID"
condition|)
block|{
name|next
argument_list|(
name|STRING_LITERAL
argument_list|)
expr_stmt|;
name|def
operator|->
name|pluginData
operator|.
name|iid
operator|=
name|unquotedLexem
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
literal|"FILE"
condition|)
block|{
name|next
argument_list|(
name|STRING_LITERAL
argument_list|)
expr_stmt|;
name|QByteArray
name|metaDataFile
init|=
name|unquotedLexem
argument_list|()
decl_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|QFileInfo
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|currentFilenames
operator|.
name|top
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
operator|.
name|dir
argument_list|()
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|metaDataFile
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|includes
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|fi
operator|.
name|exists
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|IncludePath
modifier|&
name|p
init|=
name|includes
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isFrameworkPath
condition|)
continue|continue;
name|fi
operator|.
name|setFile
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|p
operator|.
name|path
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|metaDataFile
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// try again, maybe there's a file later in the include paths with the same name
if|if
condition|(
name|fi
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|fi
operator|=
name|QFileInfo
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Plugin Metadata file "
expr_stmt|;
name|msg
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|msg
operator|+=
literal|" does not exist. Declaration will be ignored"
expr_stmt|;
name|error
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|QFile
name|file
argument_list|(
name|fi
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
decl_stmt|;
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|metaData
operator|=
name|file
operator|.
name|readAll
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|metaData
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|def
operator|->
name|pluginData
operator|.
name|metaData
operator|=
name|QJsonDocument
operator|::
name|fromJson
argument_list|(
name|metaData
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|->
name|pluginData
operator|.
name|metaData
operator|.
name|isObject
argument_list|()
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Plugin Metadata file "
expr_stmt|;
name|msg
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|msg
operator|+=
literal|" does not contain a valid JSON object. Declaration will be ignored"
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|def
operator|->
name|pluginData
operator|.
name|iid
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|mustIncludeQPluginH
operator|=
literal|true
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parsePrivateProperty
name|void
name|Moc
operator|::
name|parsePrivateProperty
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|PropertyDef
name|propDef
decl_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|inPrivateClass
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|propDef
operator|.
name|inPrivateClass
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|inPrivateClass
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
comment|// also allow void functions
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
name|propDef
operator|.
name|inPrivateClass
operator|+=
literal|"()"
expr_stmt|;
block|}
name|next
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
name|createPropertyDef
argument_list|(
name|propDef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|propDef
operator|.
name|notify
operator|.
name|isEmpty
argument_list|()
condition|)
name|def
operator|->
name|notifyableProperties
operator|++
expr_stmt|;
if|if
condition|(
name|propDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|->
name|revisionedProperties
expr_stmt|;
name|def
operator|->
name|propertyList
operator|+=
name|propDef
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseEnumOrFlag
name|void
name|Moc
operator|::
name|parseEnumOrFlag
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|,
name|bool
name|isFlag
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|identifier
decl_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|identifier
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
operator|&&
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|identifier
operator|+=
literal|"::"
expr_stmt|;
name|identifier
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
name|def
operator|->
name|enumDeclarations
index|[
name|identifier
index|]
operator|=
name|isFlag
expr_stmt|;
block|}
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFlag
name|void
name|Moc
operator|::
name|parseFlag
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|flagName
decl_stmt|,
name|enumName
decl_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|flagName
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
operator|&&
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|flagName
operator|+=
literal|"::"
expr_stmt|;
name|flagName
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
block|}
name|next
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|enumName
operator|=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
operator|&&
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|enumName
operator|+=
literal|"::"
expr_stmt|;
name|enumName
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
block|}
name|def
operator|->
name|flagAliases
operator|.
name|insert
argument_list|(
name|enumName
argument_list|,
name|flagName
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseClassInfo
name|void
name|Moc
operator|::
name|parseClassInfo
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|ClassInfoDef
name|infoDef
decl_stmt|;
name|next
argument_list|(
name|STRING_LITERAL
argument_list|)
expr_stmt|;
name|infoDef
operator|.
name|name
operator|=
name|symbol
argument_list|()
operator|.
name|unquotedLexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
argument_list|(
name|STRING_LITERAL
argument_list|)
condition|)
block|{
name|infoDef
operator|.
name|value
operator|=
name|symbol
argument_list|()
operator|.
name|unquotedLexem
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// support Q_CLASSINFO("help", QT_TR_NOOP("blah"))
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|STRING_LITERAL
argument_list|)
expr_stmt|;
name|infoDef
operator|.
name|value
operator|=
name|symbol
argument_list|()
operator|.
name|unquotedLexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
name|def
operator|->
name|classInfoList
operator|+=
name|infoDef
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseInterfaces
name|void
name|Moc
operator|::
name|parseInterfaces
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|IDENTIFIER
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|ClassDef
operator|::
name|Interface
argument_list|>
name|iface
decl_stmt|;
name|iface
operator|+=
name|ClassDef
operator|::
name|Interface
argument_list|(
name|lexem
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|iface
operator|.
name|last
argument_list|()
operator|.
name|className
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|iface
operator|.
name|last
argument_list|()
operator|.
name|className
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|test
argument_list|(
name|COLON
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|iface
operator|+=
name|ClassDef
operator|::
name|Interface
argument_list|(
name|lexem
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|iface
operator|.
name|last
argument_list|()
operator|.
name|className
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|iface
operator|.
name|last
argument_list|()
operator|.
name|className
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
block|}
comment|// resolve from classnames to interface ids
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iface
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
name|iid
init|=
name|interface2IdMap
operator|.
name|value
argument_list|(
name|iface
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|iid
operator|.
name|isEmpty
argument_list|()
condition|)
name|error
argument_list|(
literal|"Undefined interface"
argument_list|)
expr_stmt|;
name|iface
index|[
name|i
index|]
operator|.
name|interfaceId
operator|=
name|iid
expr_stmt|;
block|}
name|def
operator|->
name|interfaceList
operator|+=
name|iface
expr_stmt|;
block|}
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseDeclareInterface
name|void
name|Moc
operator|::
name|parseDeclareInterface
parameter_list|()
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|interface
decl_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|interface
operator|+=
name|lexem
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|SCOPE
argument_list|)
condition|)
block|{
name|interface
operator|+=
name|lexem
argument_list|()
expr_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|interface
operator|+=
name|lexem
argument_list|()
expr_stmt|;
block|}
name|next
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
name|QByteArray
name|iid
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|STRING_LITERAL
argument_list|)
condition|)
block|{
name|iid
operator|=
name|lexem
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|iid
operator|=
name|lexem
argument_list|()
expr_stmt|;
block|}
name|interface2IdMap
operator|.
name|insert
argument_list|(
name|interface
argument_list|,
name|iid
argument_list|)
expr_stmt|;
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseDeclareMetatype
name|void
name|Moc
operator|::
name|parseDeclareMetatype
parameter_list|()
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|QByteArray
name|typeName
init|=
name|lexemUntil
argument_list|(
name|RPAREN
argument_list|)
decl_stmt|;
name|typeName
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|typeName
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|metaTypes
operator|.
name|append
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseSlotInPrivate
name|void
name|Moc
operator|::
name|parseSlotInPrivate
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|,
name|FunctionDef
operator|::
name|Access
name|access
parameter_list|)
block|{
name|next
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
name|FunctionDef
name|funcDef
decl_stmt|;
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|funcDef
operator|.
name|inPrivateClass
operator|=
name|lexem
argument_list|()
expr_stmt|;
comment|// also allow void functions
if|if
condition|(
name|test
argument_list|(
name|LPAREN
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
name|funcDef
operator|.
name|inPrivateClass
operator|+=
literal|"()"
expr_stmt|;
block|}
name|next
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
name|funcDef
operator|.
name|access
operator|=
name|access
expr_stmt|;
name|parseFunction
argument_list|(
operator|&
name|funcDef
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|def
operator|->
name|slotList
operator|+=
name|funcDef
expr_stmt|;
while|while
condition|(
name|funcDef
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|funcDef
operator|.
name|arguments
operator|.
name|last
argument_list|()
operator|.
name|isDefault
condition|)
block|{
name|funcDef
operator|.
name|wasCloned
operator|=
literal|true
expr_stmt|;
name|funcDef
operator|.
name|arguments
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|def
operator|->
name|slotList
operator|+=
name|funcDef
expr_stmt|;
block|}
if|if
condition|(
name|funcDef
operator|.
name|revision
operator|>
literal|0
condition|)
operator|++
name|def
operator|->
name|revisionedMethods
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lexemUntil
name|QByteArray
name|Moc
operator|::
name|lexemUntil
parameter_list|(
name|Token
name|target
parameter_list|)
block|{
name|int
name|from
init|=
name|index
decl_stmt|;
name|until
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|QByteArray
name|s
decl_stmt|;
while|while
condition|(
name|from
operator|<=
name|index
condition|)
block|{
name|QByteArray
name|n
init|=
name|symbols
operator|.
name|at
argument_list|(
name|from
operator|++
operator|-
literal|1
argument_list|)
operator|.
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|size
argument_list|()
operator|&&
name|n
operator|.
name|size
argument_list|()
operator|&&
name|is_ident_char
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|is_ident_char
argument_list|(
name|n
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
name|s
operator|+=
literal|' '
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|until
name|bool
name|Moc
operator|::
name|until
parameter_list|(
name|Token
name|target
parameter_list|)
block|{
name|int
name|braceCount
init|=
literal|0
decl_stmt|;
name|int
name|brackCount
init|=
literal|0
decl_stmt|;
name|int
name|parenCount
init|=
literal|0
decl_stmt|;
name|int
name|angleCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|index
condition|)
block|{
switch|switch
condition|(
name|symbols
operator|.
name|at
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|.
name|token
condition|)
block|{
case|case
name|LBRACE
case|:
operator|++
name|braceCount
expr_stmt|;
break|break;
case|case
name|LBRACK
case|:
operator|++
name|brackCount
expr_stmt|;
break|break;
case|case
name|LPAREN
case|:
operator|++
name|parenCount
expr_stmt|;
break|break;
case|case
name|LANGLE
case|:
operator|++
name|angleCount
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|//when searching commas within the default argument, we should take care of template depth (anglecount)
comment|// unfortunatelly, we do not have enough semantic information to know if '<' is the operator< or
comment|// the beginning of a template type. so we just use heuristics.
name|int
name|possible
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|symbols
operator|.
name|size
argument_list|()
condition|)
block|{
name|Token
name|t
init|=
name|symbols
operator|.
name|at
argument_list|(
name|index
operator|++
argument_list|)
operator|.
name|token
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|LBRACE
case|:
operator|++
name|braceCount
expr_stmt|;
break|break;
case|case
name|RBRACE
case|:
operator|--
name|braceCount
expr_stmt|;
break|break;
case|case
name|LBRACK
case|:
operator|++
name|brackCount
expr_stmt|;
break|break;
case|case
name|RBRACK
case|:
operator|--
name|brackCount
expr_stmt|;
break|break;
case|case
name|LPAREN
case|:
operator|++
name|parenCount
expr_stmt|;
break|break;
case|case
name|RPAREN
case|:
operator|--
name|parenCount
expr_stmt|;
break|break;
case|case
name|LANGLE
case|:
operator|++
name|angleCount
expr_stmt|;
break|break;
case|case
name|RANGLE
case|:
operator|--
name|angleCount
expr_stmt|;
break|break;
case|case
name|GTGT
case|:
name|angleCount
operator|-=
literal|2
expr_stmt|;
name|t
operator|=
name|RANGLE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|t
operator|==
name|target
operator|&&
name|braceCount
operator|<=
literal|0
operator|&&
name|brackCount
operator|<=
literal|0
operator|&&
name|parenCount
operator|<=
literal|0
operator|&&
operator|(
name|target
operator|!=
name|RANGLE
operator|||
name|angleCount
operator|<=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|COMMA
operator|||
name|angleCount
operator|<=
literal|0
condition|)
return|return
literal|true
return|;
name|possible
operator|=
name|index
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|COMMA
operator|&&
name|t
operator|==
name|EQ
operator|&&
name|possible
operator|!=
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|possible
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|braceCount
operator|<
literal|0
operator|||
name|brackCount
operator|<
literal|0
operator|||
name|parenCount
operator|<
literal|0
operator|||
operator|(
name|target
operator|==
name|RANGLE
operator|&&
name|angleCount
operator|<
literal|0
operator|)
condition|)
block|{
operator|--
name|index
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target
operator|==
name|COMMA
operator|&&
name|angleCount
operator|!=
literal|0
operator|&&
name|possible
operator|!=
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|possible
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|checkSuperClasses
name|void
name|Moc
operator|::
name|checkSuperClasses
parameter_list|(
name|ClassDef
modifier|*
name|def
parameter_list|)
block|{
specifier|const
name|QByteArray
name|firstSuperclass
init|=
name|def
operator|->
name|superclassList
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|knownQObjectClasses
operator|.
name|contains
argument_list|(
name|firstSuperclass
argument_list|)
condition|)
block|{
comment|// enable once we /require/ include paths
if|#
directive|if
literal|0
block|QByteArray msg;         msg += "Class ";         msg += def->className;         msg += " contains the Q_OBJECT macro and inherits from ";         msg += def->superclassList.value(0);         msg += " but that is not a known QObject subclass. You may get compilation errors.";         warning(msg.constData());
endif|#
directive|endif
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|def
operator|->
name|superclassList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
name|superClass
init|=
name|def
operator|->
name|superclassList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|knownQObjectClasses
operator|.
name|contains
argument_list|(
name|superClass
argument_list|)
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Class "
expr_stmt|;
name|msg
operator|+=
name|def
operator|->
name|classname
expr_stmt|;
name|msg
operator|+=
literal|" inherits from two QObject subclasses "
expr_stmt|;
name|msg
operator|+=
name|firstSuperclass
expr_stmt|;
name|msg
operator|+=
literal|" and "
expr_stmt|;
name|msg
operator|+=
name|superClass
expr_stmt|;
name|msg
operator|+=
literal|". This is not supported!"
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interface2IdMap
operator|.
name|contains
argument_list|(
name|superClass
argument_list|)
condition|)
block|{
name|bool
name|registeredInterface
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|def
operator|->
name|interfaceList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|def
operator|->
name|interfaceList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|className
operator|==
name|superClass
condition|)
block|{
name|registeredInterface
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|registeredInterface
condition|)
block|{
name|QByteArray
name|msg
decl_stmt|;
name|msg
operator|+=
literal|"Class "
expr_stmt|;
name|msg
operator|+=
name|def
operator|->
name|classname
expr_stmt|;
name|msg
operator|+=
literal|" implements the interface "
expr_stmt|;
name|msg
operator|+=
name|superClass
expr_stmt|;
name|msg
operator|+=
literal|" but does not list it in Q_INTERFACES. qobject_cast to "
expr_stmt|;
name|msg
operator|+=
name|superClass
expr_stmt|;
name|msg
operator|+=
literal|" will not work!"
expr_stmt|;
name|warning
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|checkProperties
name|void
name|Moc
operator|::
name|checkProperties
parameter_list|(
name|ClassDef
modifier|*
name|cdef
parameter_list|)
block|{
comment|//
comment|// specify get function, for compatibiliy we accept functions
comment|// returning pointers, or const char * for QByteArray.
comment|//
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cdef
operator|->
name|propertyList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PropertyDef
modifier|&
name|p
init|=
name|cdef
operator|->
name|propertyList
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|read
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cdef
operator|->
name|publicList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|publicList
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|name
operator|!=
name|p
operator|.
name|read
condition|)
continue|continue;
if|if
condition|(
operator|!
name|f
operator|.
name|isConst
condition|)
comment|// get  functions must be const
continue|continue;
if|if
condition|(
name|f
operator|.
name|arguments
operator|.
name|size
argument_list|()
condition|)
comment|// and must not take any arguments
continue|continue;
name|PropertyDef
operator|::
name|Specification
name|spec
init|=
name|PropertyDef
operator|::
name|ValueSpec
decl_stmt|;
name|QByteArray
name|tmp
init|=
name|f
operator|.
name|normalizedType
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|type
operator|==
literal|"QByteArray"
operator|&&
name|tmp
operator|==
literal|"const char *"
condition|)
name|tmp
operator|=
literal|"QByteArray"
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|left
argument_list|(
literal|6
argument_list|)
operator|==
literal|"const "
condition|)
name|tmp
operator|=
name|tmp
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|type
operator|!=
name|tmp
operator|&&
name|tmp
operator|.
name|endsWith
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|spec
operator|=
name|PropertyDef
operator|::
name|PointerSpec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|type
operator|.
name|name
operator|.
name|endsWith
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
comment|// raw type, not normalized type
name|spec
operator|=
name|PropertyDef
operator|::
name|ReferenceSpec
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|type
operator|!=
name|tmp
condition|)
continue|continue;
name|p
operator|.
name|gspec
operator|=
name|spec
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|notify
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|notifyId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cdef
operator|->
name|signalList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|FunctionDef
modifier|&
name|f
init|=
name|cdef
operator|->
name|signalList
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|name
operator|!=
name|p
operator|.
name|notify
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|notifyId
operator|=
name|j
comment|/* Signal indexes start from 0 */
expr_stmt|;
break|break;
block|}
block|}
name|p
operator|.
name|notifyId
operator|=
name|notifyId
expr_stmt|;
if|if
condition|(
name|notifyId
operator|==
operator|-
literal|1
condition|)
block|{
name|QByteArray
name|msg
init|=
literal|"NOTIFY signal '"
operator|+
name|p
operator|.
name|notify
operator|+
literal|"' of property '"
operator|+
name|p
operator|.
name|name
operator|+
literal|"' does not exist in class "
operator|+
name|cdef
operator|->
name|classname
operator|+
literal|"."
decl_stmt|;
name|error
argument_list|(
name|msg
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
