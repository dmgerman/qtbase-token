begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the tools applications of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"preprocessor.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
include|#
directive|include
file|"ppkeywords.cpp"
include|#
directive|include
file|"keywords.cpp"
comment|// transform \r\n into \n
comment|// \r into \n (os9 style)
comment|// backslash-newlines into newlines
DECL|function|cleaned
specifier|static
name|QByteArray
name|cleaned
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|)
block|{
name|QByteArray
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|input
operator|.
name|constData
argument_list|()
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|newlines
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|data
condition|)
block|{
while|while
condition|(
operator|*
name|data
operator|&&
name|is_space
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
name|bool
name|takeLine
init|=
operator|(
operator|*
name|data
operator|==
literal|'#'
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'%'
operator|&&
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|takeLine
operator|=
literal|true
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
if|if
condition|(
name|takeLine
condition|)
block|{
operator|*
name|output
operator|=
literal|'#'
expr_stmt|;
operator|++
name|output
expr_stmt|;
do|do
operator|++
name|data
expr_stmt|;
do|while
condition|(
operator|*
name|data
operator|&&
name|is_space
argument_list|(
operator|*
name|data
argument_list|)
condition|)
do|;
block|}
while|while
condition|(
operator|*
name|data
condition|)
block|{
comment|// handle \\\n, \\\r\n and \\\r
if|if
condition|(
operator|*
name|data
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|==
literal|'\r'
condition|)
block|{
operator|++
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|==
literal|'\n'
operator|||
operator|(
operator|*
name|data
operator|)
operator|==
literal|'\r'
operator|)
condition|)
block|{
operator|++
name|newlines
expr_stmt|;
name|data
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|!=
literal|'\r'
condition|)
name|data
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|data
operator|==
literal|'\r'
operator|&&
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
comment|// reduce \r\n to \n
operator|++
name|data
expr_stmt|;
block|}
name|char
name|ch
init|=
operator|*
name|data
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
comment|// os9: replace \r with \n
name|ch
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|output
operator|=
name|ch
expr_stmt|;
operator|++
name|output
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
block|{
comment|// output additional newlines to keep the correct line-numbering
comment|// for the lines following the backslash-newline sequence(s)
while|while
condition|(
name|newlines
condition|)
block|{
operator|*
name|output
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|output
expr_stmt|;
operator|--
name|newlines
expr_stmt|;
block|}
operator|++
name|data
expr_stmt|;
break|break;
block|}
operator|++
name|data
expr_stmt|;
block|}
block|}
name|result
operator|.
name|resize
argument_list|(
name|output
operator|-
name|result
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|member|preprocessOnly
name|bool
name|Preprocessor
operator|::
name|preprocessOnly
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|skipUntilEndif
name|void
name|Preprocessor
operator|::
name|skipUntilEndif
parameter_list|()
block|{
while|while
condition|(
name|index
operator|<
name|symbols
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
operator|!=
name|PP_ENDIF
condition|)
block|{
switch|switch
condition|(
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
condition|)
block|{
case|case
name|PP_IF
case|:
case|case
name|PP_IFDEF
case|:
case|case
name|PP_IFNDEF
case|:
operator|++
name|index
expr_stmt|;
name|skipUntilEndif
argument_list|()
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
operator|++
name|index
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|skipBranch
name|bool
name|Preprocessor
operator|::
name|skipBranch
parameter_list|()
block|{
while|while
condition|(
name|index
operator|<
name|symbols
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
operator|(
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
operator|!=
name|PP_ENDIF
operator|&&
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
operator|!=
name|PP_ELIF
operator|&&
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
operator|!=
name|PP_ELSE
operator|)
condition|)
block|{
switch|switch
condition|(
name|symbols
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|token
condition|)
block|{
case|case
name|PP_IF
case|:
case|case
name|PP_IFDEF
case|:
case|case
name|PP_IFNDEF
case|:
operator|++
name|index
expr_stmt|;
name|skipUntilEndif
argument_list|()
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
operator|++
name|index
expr_stmt|;
block|}
return|return
operator|(
name|index
operator|<
name|symbols
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_enum
DECL|enum|TokenizeMode
DECL|enumerator|TokenizeCpp
DECL|enumerator|TokenizePreprocessor
DECL|enumerator|PreparePreprocessorStatement
DECL|enumerator|TokenizePreprocessorStatement
DECL|enumerator|TokenizeInclude
DECL|enumerator|PrepareDefine
DECL|enumerator|TokenizeDefine
enum|enum
name|TokenizeMode
block|{
name|TokenizeCpp
block|,
name|TokenizePreprocessor
block|,
name|PreparePreprocessorStatement
block|,
name|TokenizePreprocessorStatement
block|,
name|TokenizeInclude
block|,
name|PrepareDefine
block|,
name|TokenizeDefine
block|}
enum|;
end_enum
begin_function
DECL|function|tokenize
specifier|static
name|Symbols
name|tokenize
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|,
name|int
name|lineNum
init|=
literal|1
parameter_list|,
name|TokenizeMode
name|mode
init|=
name|TokenizeCpp
parameter_list|)
block|{
name|Symbols
name|symbols
decl_stmt|;
specifier|const
name|char
modifier|*
name|begin
init|=
name|input
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|begin
decl_stmt|;
while|while
condition|(
operator|*
name|data
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|TokenizeCpp
operator|||
name|mode
operator|==
name|TokenizeDefine
condition|)
block|{
name|int
name|column
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|lexem
init|=
name|data
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|Token
name|token
init|=
name|NOTOKEN
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|signed
name|char
argument_list|>
argument_list|(
operator|*
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|++
name|data
expr_stmt|;
continue|continue;
block|}
name|int
name|nextindex
init|=
name|keywords
index|[
name|state
index|]
operator|.
name|next
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
name|keywords
index|[
name|state
index|]
operator|.
name|defchar
condition|)
name|next
operator|=
name|keywords
index|[
name|state
index|]
operator|.
name|defnext
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|state
operator|||
name|nextindex
condition|)
name|next
operator|=
name|keyword_trans
index|[
name|nextindex
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|data
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
break|break;
name|state
operator|=
name|next
expr_stmt|;
name|token
operator|=
name|keywords
index|[
name|state
index|]
operator|.
name|token
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
comment|// suboptimal, is_ident_char  should use a table
if|if
condition|(
name|keywords
index|[
name|state
index|]
operator|.
name|ident
operator|&&
name|is_ident_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
name|token
operator|=
name|keywords
index|[
name|state
index|]
operator|.
name|ident
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NOTOKEN
condition|)
block|{
operator|++
name|data
expr_stmt|;
comment|// an error really, but let's ignore this input
comment|// to not confuse moc later. However in pre-processor
comment|// only mode let's continue.
if|if
condition|(
operator|!
name|Preprocessor
operator|::
name|preprocessOnly
condition|)
continue|continue;
block|}
operator|++
name|column
expr_stmt|;
if|if
condition|(
name|token
operator|>
name|SPECIAL_TREATMENT_MARK
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|QUOTE
case|:
name|data
operator|=
name|skipQuote
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|token
operator|=
name|STRING_LITERAL
expr_stmt|;
comment|// concatenate multi-line strings for easier
comment|// STRING_LITERAAL handling in moc
if|if
condition|(
operator|!
name|Preprocessor
operator|::
name|preprocessOnly
operator|&&
operator|!
name|symbols
operator|.
name|isEmpty
argument_list|()
operator|&&
name|symbols
operator|.
name|last
argument_list|()
operator|.
name|token
operator|==
name|STRING_LITERAL
condition|)
block|{
name|QByteArray
name|newString
init|=
name|symbols
operator|.
name|last
argument_list|()
operator|.
name|unquotedLexem
argument_list|()
decl_stmt|;
name|newString
operator|+=
name|input
operator|.
name|mid
argument_list|(
name|lexem
operator|-
name|begin
operator|+
literal|1
argument_list|,
name|data
operator|-
name|lexem
operator|-
literal|2
argument_list|)
expr_stmt|;
name|newString
operator|.
name|prepend
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|newString
operator|.
name|append
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|symbols
operator|.
name|last
argument_list|()
operator|=
name|Symbol
argument_list|(
name|symbols
operator|.
name|last
argument_list|()
operator|.
name|lineNum
argument_list|,
name|STRING_LITERAL
argument_list|,
name|newString
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|SINGLEQUOTE
case|:
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|!=
literal|'\''
operator|||
operator|(
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|data
operator|-
literal|2
operator|)
operator|!=
literal|'\\'
operator|)
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
condition|)
operator|++
name|data
expr_stmt|;
name|token
operator|=
name|CHARACTER_LITERAL
expr_stmt|;
break|break;
case|case
name|LANGLE_SCOPE
case|:
comment|// split<:: into two tokens,< and ::
name|token
operator|=
name|LANGLE
expr_stmt|;
name|data
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|data
operator|||
operator|*
name|data
operator|!=
literal|'.'
condition|)
block|{
name|token
operator|=
name|INTEGER_LITERAL
expr_stmt|;
if|if
condition|(
name|data
operator|-
name|lexem
operator|==
literal|1
operator|&&
operator|(
operator|*
name|data
operator|==
literal|'x'
operator|||
operator|*
name|data
operator|==
literal|'X'
operator|)
operator|&&
operator|*
name|lexem
operator|==
literal|'0'
condition|)
block|{
operator|++
name|data
expr_stmt|;
while|while
condition|(
name|is_hex_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
block|}
break|break;
block|}
name|token
operator|=
name|FLOATING_LITERAL
expr_stmt|;
operator|++
name|data
expr_stmt|;
comment|// fall through
case|case
name|FLOATING_LITERAL
case|:
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'+'
operator|||
operator|*
name|data
operator|==
literal|'-'
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'e'
operator|||
operator|*
name|data
operator|==
literal|'E'
condition|)
block|{
operator|++
name|data
expr_stmt|;
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
literal|'f'
operator|||
operator|*
name|data
operator|==
literal|'F'
operator|||
operator|*
name|data
operator|==
literal|'l'
operator|||
operator|*
name|data
operator|==
literal|'L'
condition|)
operator|++
name|data
expr_stmt|;
break|break;
case|case
name|HASH
case|:
if|if
condition|(
name|column
operator|==
literal|1
operator|&&
name|mode
operator|==
name|TokenizeCpp
condition|)
block|{
name|mode
operator|=
name|PreparePreprocessorStatement
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|==
literal|' '
operator|||
operator|*
name|data
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
name|is_ident_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
name|mode
operator|=
name|TokenizePreprocessorStatement
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PP_HASHHASH
case|:
if|if
condition|(
name|mode
operator|==
name|TokenizeCpp
condition|)
continue|continue;
break|break;
case|case
name|NEWLINE
case|:
operator|++
name|lineNum
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TokenizeDefine
condition|)
block|{
name|mode
operator|=
name|TokenizeCpp
expr_stmt|;
comment|// emit the newline token
break|break;
block|}
continue|continue;
case|case
name|BACKSLASH
case|:
block|{
specifier|const
name|char
modifier|*
name|rewind
init|=
name|data
decl_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|==
literal|' '
operator|||
operator|*
name|data
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|&&
operator|*
name|data
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|data
expr_stmt|;
continue|continue;
block|}
name|data
operator|=
name|rewind
expr_stmt|;
block|}
break|break;
case|case
name|CHARACTER
case|:
while|while
condition|(
name|is_ident_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
name|token
operator|=
name|IDENTIFIER
expr_stmt|;
break|break;
case|case
name|C_COMMENT
case|:
if|if
condition|(
operator|*
name|data
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
operator|!=
literal|'/'
operator|||
operator|*
operator|(
name|data
operator|-
literal|2
operator|)
operator|!=
literal|'*'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
name|token
operator|=
name|WHITESPACE
expr_stmt|;
comment|// one comment, one whitespace
comment|// fall through;
case|case
name|WHITESPACE
case|:
if|if
condition|(
name|column
operator|==
literal|1
condition|)
name|column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|==
literal|' '
operator|||
operator|*
name|data
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
name|Preprocessor
operator|::
name|preprocessOnly
condition|)
comment|// tokenize whitespace
break|break;
continue|continue;
case|case
name|CPP_COMMENT
case|:
while|while
condition|(
operator|*
name|data
operator|&&
operator|*
name|data
operator|!=
literal|'\n'
condition|)
operator|++
name|data
expr_stmt|;
continue|continue;
comment|// ignore safely, the newline is a separator
default|default:
continue|continue;
comment|//ignore
block|}
block|}
ifdef|#
directive|ifdef
name|USE_LEXEM_STORE
if|if
condition|(
operator|!
name|Preprocessor
operator|::
name|preprocessOnly
operator|&&
name|token
operator|!=
name|IDENTIFIER
operator|&&
name|token
operator|!=
name|STRING_LITERAL
operator|&&
name|token
operator|!=
name|FLOATING_LITERAL
operator|&&
name|token
operator|!=
name|INTEGER_LITERAL
condition|)
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|token
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|token
argument_list|,
name|input
argument_list|,
name|lexem
operator|-
name|begin
argument_list|,
name|data
operator|-
name|lexem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//   Preprocessor
specifier|const
name|char
modifier|*
name|lexem
init|=
name|data
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|Token
name|token
init|=
name|NOTOKEN
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|TokenizePreprocessorStatement
condition|)
block|{
name|state
operator|=
name|pp_keyword_trans
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
literal|'#'
index|]
expr_stmt|;
name|mode
operator|=
name|TokenizePreprocessor
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|signed
name|char
argument_list|>
argument_list|(
operator|*
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|++
name|data
expr_stmt|;
continue|continue;
block|}
name|int
name|nextindex
init|=
name|pp_keywords
index|[
name|state
index|]
operator|.
name|next
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
name|pp_keywords
index|[
name|state
index|]
operator|.
name|defchar
condition|)
name|next
operator|=
name|pp_keywords
index|[
name|state
index|]
operator|.
name|defnext
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|state
operator|||
name|nextindex
condition|)
name|next
operator|=
name|pp_keyword_trans
index|[
name|nextindex
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|data
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
break|break;
name|state
operator|=
name|next
expr_stmt|;
name|token
operator|=
name|pp_keywords
index|[
name|state
index|]
operator|.
name|token
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
comment|// suboptimal, is_ident_char  should use a table
if|if
condition|(
name|pp_keywords
index|[
name|state
index|]
operator|.
name|ident
operator|&&
name|is_ident_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
name|token
operator|=
name|pp_keywords
index|[
name|state
index|]
operator|.
name|ident
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|NOTOKEN
case|:
operator|++
name|data
expr_stmt|;
break|break;
case|case
name|PP_DEFINE
case|:
name|mode
operator|=
name|PrepareDefine
expr_stmt|;
break|break;
case|case
name|PP_IFDEF
case|:
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|PP_IF
argument_list|)
expr_stmt|;
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|PP_DEFINED
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PP_IFNDEF
case|:
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|PP_IF
argument_list|)
expr_stmt|;
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|PP_NOT
argument_list|)
expr_stmt|;
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|PP_DEFINED
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PP_INCLUDE
case|:
name|mode
operator|=
name|TokenizeInclude
expr_stmt|;
break|break;
case|case
name|PP_QUOTE
case|:
name|data
operator|=
name|skipQuote
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|token
operator|=
name|PP_STRING_LITERAL
expr_stmt|;
break|break;
case|case
name|PP_SINGLEQUOTE
case|:
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|!=
literal|'\''
operator|||
operator|(
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|data
operator|-
literal|2
operator|)
operator|!=
literal|'\\'
operator|)
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
condition|)
operator|++
name|data
expr_stmt|;
name|token
operator|=
name|PP_CHARACTER_LITERAL
expr_stmt|;
break|break;
case|case
name|PP_DIGIT
case|:
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|data
operator|||
operator|*
name|data
operator|!=
literal|'.'
condition|)
block|{
name|token
operator|=
name|PP_INTEGER_LITERAL
expr_stmt|;
if|if
condition|(
name|data
operator|-
name|lexem
operator|==
literal|1
operator|&&
operator|(
operator|*
name|data
operator|==
literal|'x'
operator|||
operator|*
name|data
operator|==
literal|'X'
operator|)
operator|&&
operator|*
name|lexem
operator|==
literal|'0'
condition|)
block|{
operator|++
name|data
expr_stmt|;
while|while
condition|(
name|is_hex_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
block|}
break|break;
block|}
name|token
operator|=
name|PP_FLOATING_LITERAL
expr_stmt|;
operator|++
name|data
expr_stmt|;
comment|// fall through
case|case
name|PP_FLOATING_LITERAL
case|:
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'+'
operator|||
operator|*
name|data
operator|==
literal|'-'
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'e'
operator|||
operator|*
name|data
operator|==
literal|'E'
condition|)
block|{
operator|++
name|data
expr_stmt|;
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
literal|'f'
operator|||
operator|*
name|data
operator|==
literal|'F'
operator|||
operator|*
name|data
operator|==
literal|'l'
operator|||
operator|*
name|data
operator|==
literal|'L'
condition|)
operator|++
name|data
expr_stmt|;
break|break;
case|case
name|PP_CHARACTER
case|:
if|if
condition|(
name|mode
operator|==
name|PreparePreprocessorStatement
condition|)
block|{
comment|// rewind entire token to begin
name|data
operator|=
name|lexem
expr_stmt|;
name|mode
operator|=
name|TokenizePreprocessorStatement
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|is_ident_char
argument_list|(
operator|*
name|data
argument_list|)
condition|)
operator|++
name|data
expr_stmt|;
name|token
operator|=
name|PP_IDENTIFIER
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PrepareDefine
condition|)
block|{
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|token
argument_list|,
name|input
argument_list|,
name|lexem
operator|-
name|begin
argument_list|,
name|data
operator|-
name|lexem
argument_list|)
expr_stmt|;
comment|// make sure we explicitly add the whitespace here if the next char
comment|// is not an opening brace, so we can distinguish correctly between
comment|// regular and function macros
if|if
condition|(
operator|*
name|data
operator|!=
literal|'('
condition|)
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|WHITESPACE
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TokenizeDefine
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PP_C_COMMENT
case|:
if|if
condition|(
operator|*
name|data
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
operator|!=
literal|'/'
operator|||
operator|*
operator|(
name|data
operator|-
literal|2
operator|)
operator|!=
literal|'*'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|'\n'
condition|)
operator|++
name|lineNum
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
name|token
operator|=
name|PP_WHITESPACE
expr_stmt|;
comment|// one comment, one whitespace
comment|// fall through;
case|case
name|PP_WHITESPACE
case|:
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|==
literal|' '
operator|||
operator|*
name|data
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|data
expr_stmt|;
continue|continue;
comment|// the preprocessor needs no whitespace
case|case
name|PP_CPP_COMMENT
case|:
while|while
condition|(
operator|*
name|data
operator|&&
operator|*
name|data
operator|!=
literal|'\n'
condition|)
operator|++
name|data
expr_stmt|;
continue|continue;
comment|// ignore safely, the newline is a separator
case|case
name|PP_NEWLINE
case|:
operator|++
name|lineNum
expr_stmt|;
name|mode
operator|=
name|TokenizeCpp
expr_stmt|;
break|break;
case|case
name|PP_BACKSLASH
case|:
block|{
specifier|const
name|char
modifier|*
name|rewind
init|=
name|data
decl_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
operator|(
operator|*
name|data
operator|==
literal|' '
operator|||
operator|*
name|data
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|&&
operator|*
name|data
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|data
expr_stmt|;
continue|continue;
block|}
name|data
operator|=
name|rewind
expr_stmt|;
block|}
break|break;
case|case
name|PP_LANGLE
case|:
if|if
condition|(
name|mode
operator|!=
name|TokenizeInclude
condition|)
break|break;
name|token
operator|=
name|PP_STRING_LITERAL
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
operator|*
name|data
operator|!=
literal|'\n'
operator|&&
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
operator|!=
literal|'>'
condition|)
operator|++
name|data
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|mode
operator|==
name|PreparePreprocessorStatement
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|USE_LEXEM_STORE
if|if
condition|(
name|token
operator|!=
name|PP_IDENTIFIER
operator|&&
name|token
operator|!=
name|PP_STRING_LITERAL
operator|&&
name|token
operator|!=
name|PP_FLOATING_LITERAL
operator|&&
name|token
operator|!=
name|PP_INTEGER_LITERAL
condition|)
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|token
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|symbols
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|token
argument_list|,
name|input
argument_list|,
name|lexem
operator|-
name|begin
argument_list|,
name|data
operator|-
name|lexem
argument_list|)
expr_stmt|;
block|}
block|}
name|symbols
operator|+=
name|Symbol
argument_list|()
expr_stmt|;
comment|// eof symbol
return|return
name|symbols
return|;
block|}
end_function
begin_function
DECL|function|macroExpandSymbols
name|void
name|Preprocessor
operator|::
name|macroExpandSymbols
parameter_list|(
name|int
name|lineNum
parameter_list|,
specifier|const
name|Symbols
modifier|&
name|symbolList
parameter_list|,
name|Symbols
modifier|&
name|expanded
parameter_list|,
name|MacroSafeSet
name|safeset
parameter_list|)
block|{
name|Symbols
name|saveSymbols
init|=
name|symbols
decl_stmt|;
name|int
name|saveIndex
init|=
name|index
decl_stmt|;
name|symbols
operator|=
name|symbolList
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|next
argument_list|()
expr_stmt|;
name|macroExpandIdentifier
argument_list|(
name|lineNum
argument_list|,
name|expanded
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
block|}
name|symbols
operator|=
name|saveSymbols
expr_stmt|;
name|index
operator|=
name|saveIndex
expr_stmt|;
block|}
end_function
begin_function
DECL|function|macroExpandIdentifier
name|void
name|Preprocessor
operator|::
name|macroExpandIdentifier
parameter_list|(
name|int
name|lineNum
parameter_list|,
name|Symbols
modifier|&
name|preprocessed
parameter_list|,
name|MacroSafeSet
name|safeset
parameter_list|)
block|{
specifier|const
name|Symbol
modifier|&
name|s
init|=
name|symbol
argument_list|()
decl_stmt|;
comment|// not a macro
if|if
condition|(
name|s
operator|.
name|token
operator|!=
name|PP_IDENTIFIER
operator|||
operator|!
name|macros
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|||
name|safeset
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|preprocessed
operator|+=
name|s
expr_stmt|;
name|preprocessed
operator|.
name|last
argument_list|()
operator|.
name|lineNum
operator|=
name|lineNum
expr_stmt|;
return|return;
block|}
specifier|const
name|Macro
modifier|&
name|macro
init|=
name|macros
operator|.
name|value
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|safeset
operator|+=
name|s
expr_stmt|;
comment|// don't expand macros with arguments for now
if|if
condition|(
name|macro
operator|.
name|isFunction
condition|)
block|{
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
if|if
condition|(
operator|!
name|test
argument_list|(
name|PP_LPAREN
argument_list|)
condition|)
block|{
name|preprocessed
operator|+=
name|s
expr_stmt|;
return|return;
block|}
name|QList
argument_list|<
name|Symbols
argument_list|>
name|arguments
decl_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|Symbols
name|argument
decl_stmt|;
comment|// strip leading space
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
name|int
name|nesting
init|=
literal|0
decl_stmt|;
name|bool
name|vararg
init|=
name|macro
operator|.
name|isVariadic
operator|&&
operator|(
name|arguments
operator|.
name|size
argument_list|()
operator|==
name|macro
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|t
init|=
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|PP_LPAREN
condition|)
block|{
operator|++
name|nesting
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|PP_RPAREN
condition|)
block|{
operator|--
name|nesting
expr_stmt|;
if|if
condition|(
name|nesting
operator|<
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|PP_COMMA
operator|&&
name|nesting
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|vararg
condition|)
break|break;
block|}
name|argument
operator|+=
name|symbol
argument_list|()
expr_stmt|;
block|}
comment|// each argument undoergoes macro expansion
name|Symbols
name|expanded
decl_stmt|;
name|macroExpandSymbols
argument_list|(
name|lineNum
argument_list|,
name|argument
argument_list|,
name|expanded
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
name|arguments
operator|+=
name|expanded
expr_stmt|;
if|if
condition|(
name|nesting
operator|<
literal|0
condition|)
break|break;
block|}
comment|// empty VA_ARGS
if|if
condition|(
name|macro
operator|.
name|isVariadic
operator|&&
name|arguments
operator|.
name|size
argument_list|()
operator|==
name|macro
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|arguments
operator|+=
name|Symbols
argument_list|()
expr_stmt|;
if|if
condition|(
name|arguments
operator|.
name|size
argument_list|()
operator|!=
name|macro
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|&&
comment|// 0 argument macros are a bit special. They are ok if the
comment|// argument is pure whitespace or empty
operator|(
name|macro
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
name|error
argument_list|(
literal|"Macro argument mismatch."
argument_list|)
expr_stmt|;
comment|// now replace the macro arguments with the expanded arguments
name|Symbols
name|expansion
decl_stmt|;
enum|enum
name|Mode
block|{
name|Normal
block|,
name|Hash
block|,
name|HashHash
block|}
name|mode
init|=
name|Normal
enum|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|macro
operator|.
name|symbols
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Symbol
modifier|&
name|s
init|=
name|macro
operator|.
name|symbols
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|token
operator|==
name|HASH
operator|||
name|s
operator|.
name|token
operator|==
name|PP_HASHHASH
condition|)
block|{
name|mode
operator|=
operator|(
name|s
operator|.
name|token
operator|==
name|HASH
condition|?
name|Hash
else|:
name|HashHash
operator|)
expr_stmt|;
continue|continue;
block|}
name|int
name|index
init|=
name|macro
operator|.
name|arguments
operator|.
name|indexOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Normal
condition|)
block|{
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
name|expansion
operator|+=
name|arguments
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
name|expansion
operator|+=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Hash
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|token
operator|==
name|WHITESPACE
condition|)
continue|continue;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"'#' is not followed by a macro parameter"
argument_list|)
expr_stmt|;
specifier|const
name|Symbols
modifier|&
name|arg
init|=
name|arguments
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QByteArray
name|stringified
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arg
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|stringified
operator|+=
name|arg
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|lexem
argument_list|()
expr_stmt|;
block|}
name|stringified
operator|.
name|replace
argument_list|(
literal|'"'
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|stringified
operator|.
name|prepend
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|stringified
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|expansion
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|STRING_LITERAL
argument_list|,
name|stringified
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|HashHash
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|token
operator|==
name|WHITESPACE
condition|)
continue|continue;
while|while
condition|(
name|expansion
operator|.
name|size
argument_list|()
operator|&&
name|expansion
operator|.
name|last
argument_list|()
operator|.
name|token
operator|==
name|PP_WHITESPACE
condition|)
name|expansion
operator|.
name|pop_back
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|expansion
operator|.
name|size
argument_list|()
condition|)
name|error
argument_list|(
literal|"'##' can't appear first in macro argument"
argument_list|)
expr_stmt|;
name|Symbol
name|last
init|=
name|expansion
operator|.
name|last
argument_list|()
decl_stmt|;
name|expansion
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|Symbol
name|next
init|=
name|s
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
specifier|const
name|Symbols
modifier|&
name|arg
init|=
name|arguments
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|Normal
expr_stmt|;
continue|continue;
block|}
name|next
operator|=
name|arg
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|.
name|token
operator|==
name|STRING_LITERAL
operator|||
name|s
operator|.
name|token
operator|==
name|STRING_LITERAL
condition|)
name|error
argument_list|(
literal|"Can't concatenate non identifier tokens"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|token
operator|==
name|s
operator|.
name|token
condition|)
block|{
name|QByteArray
name|lexem
init|=
name|last
operator|.
name|lexem
argument_list|()
operator|+
name|next
operator|.
name|lexem
argument_list|()
decl_stmt|;
name|expansion
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|last
operator|.
name|token
argument_list|,
name|lexem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expansion
operator|+=
name|last
expr_stmt|;
name|expansion
operator|+=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
specifier|const
name|Symbols
modifier|&
name|arg
init|=
name|arguments
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|arg
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|expansion
operator|+=
name|arg
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|mode
operator|=
name|Normal
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|Normal
condition|)
name|error
argument_list|(
literal|"'#' or '##' found at the end of a macro argument"
argument_list|)
expr_stmt|;
name|macroExpandSymbols
argument_list|(
name|lineNum
argument_list|,
name|expansion
argument_list|,
name|preprocessed
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macroExpandSymbols
argument_list|(
name|lineNum
argument_list|,
name|macro
operator|.
name|symbols
argument_list|,
name|preprocessed
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|substituteMacro
name|void
name|Preprocessor
operator|::
name|substituteMacro
parameter_list|(
specifier|const
name|MacroName
modifier|&
name|macro
parameter_list|,
name|Symbols
modifier|&
name|substituted
parameter_list|,
name|MacroSafeSet
name|safeset
parameter_list|)
block|{
name|Symbols
name|saveSymbols
init|=
name|symbols
decl_stmt|;
name|int
name|saveIndex
init|=
name|index
decl_stmt|;
name|symbols
operator|=
name|macros
operator|.
name|value
argument_list|(
name|macro
argument_list|)
operator|.
name|symbols
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|safeset
operator|+=
name|macro
expr_stmt|;
name|substituteUntilNewline
argument_list|(
name|substituted
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|saveSymbols
expr_stmt|;
name|index
operator|=
name|saveIndex
expr_stmt|;
block|}
end_function
begin_function
DECL|function|substituteUntilNewline
name|void
name|Preprocessor
operator|::
name|substituteUntilNewline
parameter_list|(
name|Symbols
modifier|&
name|substituted
parameter_list|,
name|MacroSafeSet
name|safeset
parameter_list|)
block|{
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|token
init|=
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|PP_IDENTIFIER
condition|)
block|{
name|MacroName
name|macro
init|=
name|symbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|macros
operator|.
name|contains
argument_list|(
name|macro
argument_list|)
operator|&&
operator|!
name|safeset
operator|.
name|contains
argument_list|(
name|macro
argument_list|)
condition|)
block|{
name|substituteMacro
argument_list|(
name|macro
argument_list|,
name|substituted
argument_list|,
name|safeset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|PP_DEFINED
condition|)
block|{
name|bool
name|braces
init|=
name|test
argument_list|(
name|PP_LPAREN
argument_list|)
decl_stmt|;
name|next
argument_list|(
name|PP_IDENTIFIER
argument_list|)
expr_stmt|;
name|Symbol
name|definedOrNotDefined
init|=
name|symbol
argument_list|()
decl_stmt|;
name|definedOrNotDefined
operator|.
name|token
operator|=
name|macros
operator|.
name|contains
argument_list|(
name|definedOrNotDefined
argument_list|)
condition|?
name|PP_MOC_TRUE
else|:
name|PP_MOC_FALSE
expr_stmt|;
name|substituted
operator|+=
name|definedOrNotDefined
expr_stmt|;
if|if
condition|(
name|braces
condition|)
name|test
argument_list|(
name|PP_RPAREN
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|PP_NEWLINE
condition|)
block|{
name|substituted
operator|+=
name|symbol
argument_list|()
expr_stmt|;
break|break;
block|}
name|substituted
operator|+=
name|symbol
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_class
DECL|class|PP_Expression
class|class
name|PP_Expression
super|:
specifier|public
name|Parser
block|{
public|public:
DECL|function|value
name|int
name|value
parameter_list|()
block|{
name|index
operator|=
literal|0
expr_stmt|;
return|return
name|unary_expression_lookup
argument_list|()
condition|?
name|conditional_expression
argument_list|()
else|:
literal|0
return|;
block|}
name|int
name|conditional_expression
parameter_list|()
function_decl|;
name|int
name|logical_OR_expression
parameter_list|()
function_decl|;
name|int
name|logical_AND_expression
parameter_list|()
function_decl|;
name|int
name|inclusive_OR_expression
parameter_list|()
function_decl|;
name|int
name|exclusive_OR_expression
parameter_list|()
function_decl|;
name|int
name|AND_expression
parameter_list|()
function_decl|;
name|int
name|equality_expression
parameter_list|()
function_decl|;
name|int
name|relational_expression
parameter_list|()
function_decl|;
name|int
name|shift_expression
parameter_list|()
function_decl|;
name|int
name|additive_expression
parameter_list|()
function_decl|;
name|int
name|multiplicative_expression
parameter_list|()
function_decl|;
name|int
name|unary_expression
parameter_list|()
function_decl|;
name|bool
name|unary_expression_lookup
parameter_list|()
function_decl|;
name|int
name|primary_expression
parameter_list|()
function_decl|;
name|bool
name|primary_expression_lookup
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|conditional_expression
name|int
name|PP_Expression
operator|::
name|conditional_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|logical_OR_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_QUESTION
argument_list|)
condition|)
block|{
name|int
name|alt1
init|=
name|conditional_expression
argument_list|()
decl_stmt|;
name|int
name|alt2
init|=
name|test
argument_list|(
name|PP_COLON
argument_list|)
condition|?
name|conditional_expression
argument_list|()
else|:
literal|0
decl_stmt|;
return|return
name|value
condition|?
name|alt1
else|:
name|alt2
return|;
block|}
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|logical_OR_expression
name|int
name|PP_Expression
operator|::
name|logical_OR_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|logical_AND_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_OROR
argument_list|)
condition|)
return|return
name|logical_OR_expression
argument_list|()
operator|||
name|value
return|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|logical_AND_expression
name|int
name|PP_Expression
operator|::
name|logical_AND_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|inclusive_OR_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_ANDAND
argument_list|)
condition|)
return|return
name|logical_AND_expression
argument_list|()
operator|&&
name|value
return|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|inclusive_OR_expression
name|int
name|PP_Expression
operator|::
name|inclusive_OR_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|exclusive_OR_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_OR
argument_list|)
condition|)
return|return
name|value
operator||
name|inclusive_OR_expression
argument_list|()
return|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|exclusive_OR_expression
name|int
name|PP_Expression
operator|::
name|exclusive_OR_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|AND_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_HAT
argument_list|)
condition|)
return|return
name|value
operator|^
name|exclusive_OR_expression
argument_list|()
return|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|AND_expression
name|int
name|PP_Expression
operator|::
name|AND_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|equality_expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_AND
argument_list|)
condition|)
return|return
name|value
operator|&
name|AND_expression
argument_list|()
return|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|equality_expression
name|int
name|PP_Expression
operator|::
name|equality_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|relational_expression
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_EQEQ
case|:
return|return
name|value
operator|==
name|equality_expression
argument_list|()
return|;
case|case
name|PP_NE
case|:
return|return
name|value
operator|!=
name|equality_expression
argument_list|()
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function
begin_function
DECL|function|relational_expression
name|int
name|PP_Expression
operator|::
name|relational_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|shift_expression
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_LANGLE
case|:
return|return
name|value
operator|<
name|relational_expression
argument_list|()
return|;
case|case
name|PP_RANGLE
case|:
return|return
name|value
operator|>
name|relational_expression
argument_list|()
return|;
case|case
name|PP_LE
case|:
return|return
name|value
operator|<=
name|relational_expression
argument_list|()
return|;
case|case
name|PP_GE
case|:
return|return
name|value
operator|>=
name|relational_expression
argument_list|()
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function
begin_function
DECL|function|shift_expression
name|int
name|PP_Expression
operator|::
name|shift_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|additive_expression
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_LTLT
case|:
return|return
name|value
operator|<<
name|shift_expression
argument_list|()
return|;
case|case
name|PP_GTGT
case|:
return|return
name|value
operator|>>
name|shift_expression
argument_list|()
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function
begin_function
DECL|function|additive_expression
name|int
name|PP_Expression
operator|::
name|additive_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|multiplicative_expression
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_PLUS
case|:
return|return
name|value
operator|+
name|additive_expression
argument_list|()
return|;
case|case
name|PP_MINUS
case|:
return|return
name|value
operator|-
name|additive_expression
argument_list|()
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function
begin_function
DECL|function|multiplicative_expression
name|int
name|PP_Expression
operator|::
name|multiplicative_expression
parameter_list|()
block|{
name|int
name|value
init|=
name|unary_expression
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_STAR
case|:
return|return
name|value
operator|*
name|multiplicative_expression
argument_list|()
return|;
case|case
name|PP_PERCENT
case|:
block|{
name|int
name|remainder
init|=
name|multiplicative_expression
argument_list|()
decl_stmt|;
return|return
name|remainder
condition|?
name|value
operator|%
name|remainder
else|:
literal|0
return|;
block|}
case|case
name|PP_SLASH
case|:
block|{
name|int
name|div
init|=
name|multiplicative_expression
argument_list|()
decl_stmt|;
return|return
name|div
condition|?
name|value
operator|/
name|div
else|:
literal|0
return|;
block|}
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
empty_stmt|;
block|}
end_function
begin_function
DECL|function|unary_expression
name|int
name|PP_Expression
operator|::
name|unary_expression
parameter_list|()
block|{
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
name|PP_PLUS
case|:
return|return
name|unary_expression
argument_list|()
return|;
case|case
name|PP_MINUS
case|:
return|return
operator|-
name|unary_expression
argument_list|()
return|;
case|case
name|PP_NOT
case|:
return|return
operator|!
name|unary_expression
argument_list|()
return|;
case|case
name|PP_TILDE
case|:
return|return
name|~
name|unary_expression
argument_list|()
return|;
case|case
name|PP_MOC_TRUE
case|:
return|return
literal|1
return|;
case|case
name|PP_MOC_FALSE
case|:
return|return
literal|0
return|;
default|default:
name|prev
argument_list|()
expr_stmt|;
return|return
name|primary_expression
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|unary_expression_lookup
name|bool
name|PP_Expression
operator|::
name|unary_expression_lookup
parameter_list|()
block|{
name|Token
name|t
init|=
name|lookup
argument_list|()
decl_stmt|;
return|return
operator|(
name|primary_expression_lookup
argument_list|()
operator|||
name|t
operator|==
name|PP_PLUS
operator|||
name|t
operator|==
name|PP_MINUS
operator|||
name|t
operator|==
name|PP_NOT
operator|||
name|t
operator|==
name|PP_TILDE
operator|||
name|t
operator|==
name|PP_DEFINED
operator|)
return|;
block|}
end_function
begin_function
DECL|function|primary_expression
name|int
name|PP_Expression
operator|::
name|primary_expression
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_LPAREN
argument_list|)
condition|)
block|{
name|value
operator|=
name|conditional_expression
argument_list|()
expr_stmt|;
name|test
argument_list|(
name|PP_RPAREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
argument_list|()
expr_stmt|;
name|value
operator|=
name|lexem
argument_list|()
operator|.
name|toInt
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|primary_expression_lookup
name|bool
name|PP_Expression
operator|::
name|primary_expression_lookup
parameter_list|()
block|{
name|Token
name|t
init|=
name|lookup
argument_list|()
decl_stmt|;
return|return
operator|(
name|t
operator|==
name|PP_IDENTIFIER
operator|||
name|t
operator|==
name|PP_INTEGER_LITERAL
operator|||
name|t
operator|==
name|PP_FLOATING_LITERAL
operator|||
name|t
operator|==
name|PP_MOC_TRUE
operator|||
name|t
operator|==
name|PP_MOC_FALSE
operator|||
name|t
operator|==
name|PP_LPAREN
operator|)
return|;
block|}
end_function
begin_function
DECL|function|evaluateCondition
name|int
name|Preprocessor
operator|::
name|evaluateCondition
parameter_list|()
block|{
name|PP_Expression
name|expression
decl_stmt|;
name|expression
operator|.
name|currentFilenames
operator|=
name|currentFilenames
expr_stmt|;
name|substituteUntilNewline
argument_list|(
name|expression
operator|.
name|symbols
argument_list|)
expr_stmt|;
return|return
name|expression
operator|.
name|value
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|preprocess
name|void
name|Preprocessor
operator|::
name|preprocess
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|filename
parameter_list|,
name|Symbols
modifier|&
name|preprocessed
parameter_list|)
block|{
name|currentFilenames
operator|.
name|push
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|preprocessed
operator|.
name|reserve
argument_list|(
name|preprocessed
operator|.
name|size
argument_list|()
operator|+
name|symbols
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|token
init|=
name|next
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|PP_INCLUDE
case|:
block|{
name|int
name|lineNum
init|=
name|symbol
argument_list|()
operator|.
name|lineNum
decl_stmt|;
name|QByteArray
name|include
decl_stmt|;
name|bool
name|local
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|test
argument_list|(
name|PP_STRING_LITERAL
argument_list|)
condition|)
block|{
name|local
operator|=
name|lexem
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|include
operator|=
name|unquotedLexem
argument_list|()
expr_stmt|;
block|}
else|else
continue|continue;
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
comment|// #### stringery
name|QFileInfo
name|fi
decl_stmt|;
if|if
condition|(
name|local
condition|)
name|fi
operator|.
name|setFile
argument_list|(
name|QFileInfo
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|filename
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
operator|.
name|dir
argument_list|()
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|include
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|Preprocessor
operator|::
name|includes
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|fi
operator|.
name|exists
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|IncludePath
modifier|&
name|p
init|=
name|Preprocessor
operator|::
name|includes
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isFrameworkPath
condition|)
block|{
specifier|const
name|int
name|slashPos
init|=
name|include
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashPos
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|QByteArray
name|frameworkCandidate
init|=
name|include
operator|.
name|left
argument_list|(
name|slashPos
argument_list|)
decl_stmt|;
name|frameworkCandidate
operator|.
name|append
argument_list|(
literal|".framework/Headers/"
argument_list|)
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|QByteArray
argument_list|(
name|p
operator|.
name|path
operator|+
literal|'/'
operator|+
name|frameworkCandidate
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|include
operator|.
name|mid
argument_list|(
name|slashPos
operator|+
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fi
operator|.
name|setFile
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|p
operator|.
name|path
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|include
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// try again, maybe there's a file later in the include paths with the same name
comment|// (186067)
if|if
condition|(
name|fi
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|fi
operator|=
name|QFileInfo
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|fi
operator|.
name|exists
argument_list|()
operator|||
name|fi
operator|.
name|isDir
argument_list|()
condition|)
continue|continue;
name|include
operator|=
name|fi
operator|.
name|canonicalFilePath
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
if|if
condition|(
name|Preprocessor
operator|::
name|preprocessedIncludes
operator|.
name|contains
argument_list|(
name|include
argument_list|)
condition|)
continue|continue;
name|Preprocessor
operator|::
name|preprocessedIncludes
operator|.
name|insert
argument_list|(
name|include
argument_list|)
expr_stmt|;
name|QFile
name|file
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|include
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
continue|continue;
name|QByteArray
name|input
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|input
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|Symbols
name|saveSymbols
init|=
name|symbols
decl_stmt|;
name|int
name|saveIndex
init|=
name|index
decl_stmt|;
comment|// phase 1: get rid of backslash-newlines
name|input
operator|=
name|cleaned
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|// phase 2: tokenize for the preprocessor
name|symbols
operator|=
name|tokenize
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|.
name|clear
argument_list|()
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|// phase 3: preprocess conditions and substitute macros
name|preprocessed
operator|+=
name|Symbol
argument_list|(
literal|0
argument_list|,
name|MOC_INCLUDE_BEGIN
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|preprocess
argument_list|(
name|include
argument_list|,
name|preprocessed
argument_list|)
expr_stmt|;
name|preprocessed
operator|+=
name|Symbol
argument_list|(
name|lineNum
argument_list|,
name|MOC_INCLUDE_END
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|saveSymbols
expr_stmt|;
name|index
operator|=
name|saveIndex
expr_stmt|;
continue|continue;
block|}
case|case
name|PP_DEFINE
case|:
block|{
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|QByteArray
name|name
init|=
name|lexem
argument_list|()
decl_stmt|;
name|Macro
name|macro
decl_stmt|;
name|macro
operator|.
name|isVariadic
operator|=
literal|false
expr_stmt|;
name|Token
name|t
init|=
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|LPAREN
condition|)
block|{
comment|// we have a function macro
name|macro
operator|.
name|isFunction
operator|=
literal|true
expr_stmt|;
name|parseDefineArguments
argument_list|(
operator|&
name|macro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|PP_WHITESPACE
condition|)
block|{
name|macro
operator|.
name|isFunction
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Moc: internal error"
argument_list|)
expr_stmt|;
block|}
name|int
name|start
init|=
name|index
decl_stmt|;
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
name|macro
operator|.
name|symbols
operator|.
name|reserve
argument_list|(
name|index
operator|-
name|start
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// remove whitespace where there shouldn't be any:
comment|// Before and after the macro, after a # and around ##
name|Token
name|lastToken
init|=
name|HASH
decl_stmt|;
comment|// skip shitespace at the beginning
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|index
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Token
name|token
init|=
name|symbols
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|token
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|PP_WHITESPACE
operator|||
name|token
operator|==
name|WHITESPACE
condition|)
block|{
if|if
condition|(
name|lastToken
operator|==
name|PP_HASH
operator|||
name|lastToken
operator|==
name|HASH
operator|||
name|lastToken
operator|==
name|PP_HASHHASH
operator|||
name|lastToken
operator|==
name|PP_WHITESPACE
operator|||
name|lastToken
operator|==
name|WHITESPACE
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|PP_HASHHASH
condition|)
block|{
if|if
condition|(
operator|!
name|macro
operator|.
name|symbols
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|lastToken
operator|==
name|PP_WHITESPACE
operator|||
name|lastToken
operator|==
name|WHITESPACE
operator|)
condition|)
name|macro
operator|.
name|symbols
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|macro
operator|.
name|symbols
operator|.
name|append
argument_list|(
name|symbols
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastToken
operator|=
name|token
expr_stmt|;
block|}
comment|// remove trailing whitespace
while|while
condition|(
operator|!
name|macro
operator|.
name|symbols
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|macro
operator|.
name|symbols
operator|.
name|last
argument_list|()
operator|.
name|token
operator|==
name|PP_WHITESPACE
operator|||
name|macro
operator|.
name|symbols
operator|.
name|last
argument_list|()
operator|.
name|token
operator|==
name|WHITESPACE
operator|)
condition|)
name|macro
operator|.
name|symbols
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|macros
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|macro
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|PP_UNDEF
case|:
block|{
name|next
argument_list|(
name|IDENTIFIER
argument_list|)
expr_stmt|;
name|QByteArray
name|name
init|=
name|lexem
argument_list|()
decl_stmt|;
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
name|macros
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|PP_IDENTIFIER
case|:
block|{
comment|// substitute macros
name|macroExpandIdentifier
argument_list|(
name|symbol
argument_list|()
operator|.
name|lineNum
argument_list|,
name|preprocessed
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|PP_HASH
case|:
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
continue|continue;
comment|// skip unknown preprocessor statement
case|case
name|PP_IFDEF
case|:
case|case
name|PP_IFNDEF
case|:
case|case
name|PP_IF
case|:
while|while
condition|(
operator|!
name|evaluateCondition
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|skipBranch
argument_list|()
condition|)
break|break;
if|if
condition|(
name|test
argument_list|(
name|PP_ELIF
argument_list|)
condition|)
block|{                 }
else|else
block|{
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
continue|continue;
case|case
name|PP_ELIF
case|:
case|case
name|PP_ELSE
case|:
name|skipUntilEndif
argument_list|()
expr_stmt|;
comment|// fall through
case|case
name|PP_ENDIF
case|:
name|until
argument_list|(
name|PP_NEWLINE
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PP_NEWLINE
case|:
continue|continue;
case|case
name|SIGNALS
case|:
case|case
name|SLOTS
case|:
block|{
name|Symbol
name|sym
init|=
name|symbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|macros
operator|.
name|contains
argument_list|(
literal|"QT_NO_KEYWORDS"
argument_list|)
condition|)
name|sym
operator|.
name|token
operator|=
name|IDENTIFIER
expr_stmt|;
else|else
name|sym
operator|.
name|token
operator|=
operator|(
name|token
operator|==
name|SIGNALS
condition|?
name|Q_SIGNALS_TOKEN
else|:
name|Q_SLOTS_TOKEN
operator|)
expr_stmt|;
name|preprocessed
operator|+=
name|sym
expr_stmt|;
block|}
continue|continue;
default|default:
break|break;
block|}
name|preprocessed
operator|+=
name|symbol
argument_list|()
expr_stmt|;
block|}
name|currentFilenames
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|preprocessed
name|Symbols
name|Preprocessor
operator|::
name|preprocessed
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|filename
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|QFile
name|qfile
decl_stmt|;
name|qfile
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
return|return
name|preprocessed
argument_list|(
name|filename
argument_list|,
operator|&
name|qfile
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|preprocessed
name|Symbols
name|Preprocessor
operator|::
name|preprocessed
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|filename
parameter_list|,
name|QIODevice
modifier|*
name|file
parameter_list|)
block|{
name|QByteArray
name|input
init|=
name|file
operator|->
name|readAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|symbols
return|;
comment|// phase 1: get rid of backslash-newlines
name|input
operator|=
name|cleaned
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|// phase 2: tokenize for the preprocessor
name|symbols
operator|=
name|tokenize
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (int j = 0; j< symbols.size(); ++j)         fprintf(stderr, "line %d: %s(%s)\n",                symbols[j].lineNum,                symbols[j].lexem().constData(),                tokenTypeName(symbols[j].token));
endif|#
directive|endif
comment|// phase 3: preprocess conditions and substitute macros
name|Symbols
name|result
decl_stmt|;
name|preprocess
argument_list|(
name|filename
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (int j = 0; j< result.size(); ++j)         fprintf(stderr, "line %d: %s(%s)\n",                result[j].lineNum,                result[j].lexem().constData(),                tokenTypeName(result[j].token));
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|parseDefineArguments
name|void
name|Preprocessor
operator|::
name|parseDefineArguments
parameter_list|(
name|Macro
modifier|*
name|m
parameter_list|)
block|{
name|Symbols
name|arguments
decl_stmt|;
while|while
condition|(
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
name|Token
name|t
init|=
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|PP_RPAREN
condition|)
break|break;
if|if
condition|(
name|t
operator|!=
name|PP_IDENTIFIER
condition|)
block|{
name|QByteArray
name|l
init|=
name|lexem
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|"..."
condition|)
block|{
name|m
operator|->
name|isVariadic
operator|=
literal|true
expr_stmt|;
name|arguments
operator|+=
name|Symbol
argument_list|(
name|symbol
argument_list|()
operator|.
name|lineNum
argument_list|,
name|PP_IDENTIFIER
argument_list|,
literal|"__VA_ARGS__"
argument_list|)
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
if|if
condition|(
operator|!
name|test
argument_list|(
name|PP_RPAREN
argument_list|)
condition|)
name|error
argument_list|(
literal|"missing ')' in macro argument list"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|l
operator|.
name|constData
argument_list|()
argument_list|,
name|l
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
name|l
expr_stmt|;
name|error
argument_list|(
literal|"Unexpected character in macro argument list."
argument_list|)
expr_stmt|;
block|}
block|}
name|Symbol
name|arg
init|=
name|symbol
argument_list|()
decl_stmt|;
if|if
condition|(
name|arguments
operator|.
name|contains
argument_list|(
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Duplicate macro parameter."
argument_list|)
expr_stmt|;
name|arguments
operator|+=
name|symbol
argument_list|()
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
name|t
operator|=
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|PP_RPAREN
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|PP_COMMA
condition|)
continue|continue;
if|if
condition|(
name|lexem
argument_list|()
operator|==
literal|"..."
condition|)
block|{
comment|//GCC extension:    #define FOO(x, y...) x(y)
comment|// The last argument was already parsed. Just mark the macro as variadic.
name|m
operator|->
name|isVariadic
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
if|if
condition|(
operator|!
name|test
argument_list|(
name|PP_RPAREN
argument_list|)
condition|)
name|error
argument_list|(
literal|"missing ')' in macro argument list"
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"Unexpected character in macro argument list."
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
while|while
condition|(
name|test
argument_list|(
name|PP_WHITESPACE
argument_list|)
condition|)
block|{}
block|}
end_function
begin_function
DECL|function|until
name|void
name|Preprocessor
operator|::
name|until
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
while|while
condition|(
name|hasNext
argument_list|()
operator|&&
name|next
argument_list|()
operator|!=
name|t
condition|)
empty_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
