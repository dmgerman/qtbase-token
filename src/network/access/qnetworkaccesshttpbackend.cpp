begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QNETWORKACCESSHTTPBACKEND_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qnetworkaccesshttpbackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccesscache_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstractnetworkcache.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/private/qnetworksession_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie_p.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qsslconfiguration.h"
end_include
begin_include
include|#
directive|include
file|"qhttpthreaddelegate_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|// for strchr
end_comment
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|QSharedPointer<char>
argument_list|)
end_macro
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class_decl
class_decl|class
name|QNetworkProxy
class_decl|;
end_class_decl
begin_function
DECL|function|isSeparator
specifier|static
specifier|inline
name|bool
name|isSeparator
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|separators
index|[]
init|=
literal|"()<>@,;:\\\"/[]?={}"
decl_stmt|;
return|return
name|isLWS
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|separators
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|// ### merge with nextField in cookiejar.cpp
end_comment
begin_function
DECL|function|parseHttpOptionHeader
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|parseHttpOptionHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
comment|// The HTTP header is of the form:
comment|// header          = #1(directives)
comment|// directives      = token | value-directive
comment|// value-directive = token "=" (token | quoted-string)
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// skip spaces
name|pos
operator|=
name|nextNonWhitespace
argument_list|(
name|header
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|header
operator|.
name|length
argument_list|()
condition|)
return|return
name|result
return|;
comment|// end of parsing
comment|// pos points to a non-whitespace
name|int
name|comma
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|int
name|equal
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|comma
operator|==
name|pos
operator|||
name|equal
operator|==
name|pos
condition|)
comment|// huh? Broken header.
return|return
name|result
return|;
comment|// The key name is delimited by either a comma, an equal sign or the end
comment|// of the header, whichever comes first
name|int
name|end
init|=
name|comma
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
name|end
operator|=
name|header
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
operator|-
literal|1
operator|&&
name|end
operator|>
name|equal
condition|)
name|end
operator|=
name|equal
expr_stmt|;
comment|// equal sign comes before comma/end
name|QByteArray
name|key
init|=
name|QByteArray
argument_list|(
name|header
operator|.
name|constData
argument_list|()
operator|+
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
operator|.
name|trimmed
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|pos
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|equal
argument_list|)
operator|<
name|uint
argument_list|(
name|comma
argument_list|)
condition|)
block|{
comment|// case: token "=" (token | quoted-string)
comment|// skip spaces
name|pos
operator|=
name|nextNonWhitespace
argument_list|(
name|header
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|header
operator|.
name|length
argument_list|()
condition|)
comment|// huh? Broken header
return|return
name|result
return|;
name|QByteArray
name|value
decl_stmt|;
name|value
operator|.
name|reserve
argument_list|(
name|header
operator|.
name|length
argument_list|()
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'"'
condition|)
block|{
comment|// case: quoted-string
comment|// quoted-string  = (<"> *(qdtext | quoted-pair )<"> )
comment|// qdtext         =<any TEXT except<">>
comment|// quoted-pair    = "\" CHAR
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|header
operator|.
name|length
argument_list|()
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|// end of quoted text
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|header
operator|.
name|length
argument_list|()
condition|)
comment|// broken header
return|return
name|result
return|;
name|c
operator|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|value
operator|+=
name|c
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// case: token
while|while
condition|(
name|pos
operator|<
name|header
operator|.
name|length
argument_list|()
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSeparator
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|value
operator|+=
name|c
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
name|result
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// find the comma now:
name|comma
operator|=
name|header
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
operator|==
operator|-
literal|1
condition|)
return|return
name|result
return|;
comment|// end of parsing
name|pos
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// case: token
comment|// key is already set
name|result
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
name|QNetworkAccessBackend
modifier|*
DECL|function|create
name|QNetworkAccessHttpBackendFactory
operator|::
name|create
parameter_list|(
name|QNetworkAccessManager
operator|::
name|Operation
name|op
parameter_list|,
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
specifier|const
block|{
comment|// check the operation
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|QNetworkAccessManager
operator|::
name|GetOperation
case|:
case|case
name|QNetworkAccessManager
operator|::
name|PostOperation
case|:
case|case
name|QNetworkAccessManager
operator|::
name|HeadOperation
case|:
case|case
name|QNetworkAccessManager
operator|::
name|PutOperation
case|:
case|case
name|QNetworkAccessManager
operator|::
name|DeleteOperation
case|:
case|case
name|QNetworkAccessManager
operator|::
name|CustomOperation
case|:
break|break;
default|default:
comment|// no, we can't handle this request
return|return
literal|0
return|;
block|}
name|QUrl
name|url
init|=
name|request
operator|.
name|url
argument_list|()
decl_stmt|;
name|QString
name|scheme
init|=
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
condition|)
return|return
operator|new
name|QNetworkAccessHttpBackend
return|;
return|return
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|QNetworkAccessHttpBackend
name|QNetworkAccessHttpBackend
operator|::
name|QNetworkAccessHttpBackend
parameter_list|()
member_init_list|:
name|QNetworkAccessBackend
argument_list|()
member_init_list|,
name|statusCode
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingDownloadDataEmissions
argument_list|(
operator|new
name|QAtomicInt
argument_list|()
argument_list|)
member_init_list|,
name|pendingDownloadProgressEmissions
argument_list|(
operator|new
name|QAtomicInt
argument_list|()
argument_list|)
member_init_list|,
name|loadingFromCache
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|usingZerocopyDownloadBuffer
argument_list|(
literal|false
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
member_init_list|,
name|pendingSslConfiguration
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingIgnoreAllSslErrors
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
member_init_list|,
name|resumeOffset
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QNetworkAccessHttpBackend
name|QNetworkAccessHttpBackend
operator|::
name|~
name|QNetworkAccessHttpBackend
parameter_list|()
block|{
comment|// This will do nothing if the request was already finished or aborted
emit|emit
name|abortHttpRequest
argument_list|()
emit|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
operator|delete
name|pendingSslConfiguration
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*     For a given httpRequest     1) If AlwaysNetwork, return     2) If we have a cache entry for this url populate headers so the server can return 304     3) Calculate if response_is_fresh and if so send the cache and set loadedFromCache to true  */
end_comment
begin_function
DECL|function|loadFromCacheIfAllowed
name|bool
name|QNetworkAccessHttpBackend
operator|::
name|loadFromCacheIfAllowed
parameter_list|(
name|QHttpNetworkRequest
modifier|&
name|httpRequest
parameter_list|)
block|{
name|QNetworkRequest
operator|::
name|CacheLoadControl
name|CacheLoadControlAttribute
init|=
operator|(
name|QNetworkRequest
operator|::
name|CacheLoadControl
operator|)
name|request
argument_list|()
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CacheLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|PreferNetwork
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|CacheLoadControlAttribute
operator|==
name|QNetworkRequest
operator|::
name|AlwaysNetwork
condition|)
block|{
comment|// If the request does not already specify preferred cache-control
comment|// force reload from the network and tell any caching proxy servers to reload too
if|if
condition|(
operator|!
name|request
argument_list|()
operator|.
name|rawHeaderList
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Cache-Control"
argument_list|)
condition|)
block|{
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Cache-Control"
argument_list|,
literal|"no-cache"
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Pragma"
argument_list|,
literal|"no-cache"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// The disk cache API does not currently support partial content retrieval.
comment|// That is why we don't use the disk cache for any such requests.
if|if
condition|(
name|request
argument_list|()
operator|.
name|hasRawHeader
argument_list|(
literal|"Range"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|networkCache
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nc
condition|)
return|return
literal|false
return|;
comment|// no local cache
name|QNetworkCacheMetaData
name|metaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|url
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metaData
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// not in cache
if|if
condition|(
operator|!
name|metaData
operator|.
name|saveToDisk
argument_list|()
condition|)
return|return
literal|false
return|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"etag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"If-None-Match"
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|QDateTime
name|lastModified
init|=
name|metaData
operator|.
name|lastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastModified
operator|.
name|isValid
argument_list|()
condition|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"If-Modified-Since"
argument_list|,
name|QNetworkHeadersPrivate
operator|::
name|toHttpDate
argument_list|(
name|lastModified
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
init|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"must-revalidate"
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|QDateTime
name|currentDateTime
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
decl_stmt|;
name|QDateTime
name|expirationDate
init|=
name|metaData
operator|.
name|expirationDate
argument_list|()
decl_stmt|;
if|#
directive|if
literal|0
comment|/*      * age_value      *      is the value of Age: header received by the cache with      *              this response.      * date_value      *      is the value of the origin server's Date: header      * request_time      *      is the (local) time when the cache made the request      *              that resulted in this cached response      * response_time      *      is the (local) time when the cache received the      *              response      * now      *      is the current (local) time      */
block|int age_value = 0;     it = cacheHeaders.findRawHeader("age");     if (it != cacheHeaders.rawHeaders.constEnd())         age_value = it->second.toInt();      QDateTime dateHeader;     int date_value = 0;     it = cacheHeaders.findRawHeader("date");     if (it != cacheHeaders.rawHeaders.constEnd()) {         dateHeader = QNetworkHeadersPrivate::fromHttpDate(it->second);         date_value = dateHeader.toTime_t();     }      int now = currentDateTime.toUTC().toTime_t();     int request_time = now;     int response_time = now;
comment|// Algorithm from RFC 2616 section 13.2.3
block|int apparent_age = qMax(0, response_time - date_value);     int corrected_received_age = qMax(apparent_age, age_value);     int response_delay = response_time - request_time;     int corrected_initial_age = corrected_received_age + response_delay;     int resident_time = now - response_time;     int current_age   = corrected_initial_age + resident_time;
comment|// RFC 2616 13.2.4 Expiration Calculations
block|if (!expirationDate.isValid()) {         if (lastModified.isValid()) {             int diff = currentDateTime.secsTo(lastModified);             expirationDate = lastModified;             expirationDate.addSecs(diff / 10);             if (httpRequest.headerField("Warning").isEmpty()) {                 QDateTime dt;                 dt.setTime_t(current_age);                 if (dt.daysTo(currentDateTime)> 1)                     httpRequest.setHeaderField("Warning", "113");             }         }     }
comment|// the cache-saving code below sets the expirationDate with date+max_age
comment|// if "max-age" is present, or to Expires otherwise
block|int freshness_lifetime = dateHeader.secsTo(expirationDate);     bool response_is_fresh = (freshness_lifetime> current_age);
else|#
directive|else
name|bool
name|response_is_fresh
init|=
name|currentDateTime
operator|.
name|secsTo
argument_list|(
name|expirationDate
argument_list|)
operator|>=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|response_is_fresh
condition|)
return|return
literal|false
return|;
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"response_is_fresh"
operator|<<
name|CacheLoadControlAttribute
expr_stmt|;
endif|#
directive|endif
return|return
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convert
specifier|static
name|QHttpNetworkRequest
operator|::
name|Priority
name|convert
parameter_list|(
specifier|const
name|QNetworkRequest
operator|::
name|Priority
modifier|&
name|prio
parameter_list|)
block|{
switch|switch
condition|(
name|prio
condition|)
block|{
case|case
name|QNetworkRequest
operator|::
name|LowPriority
case|:
return|return
name|QHttpNetworkRequest
operator|::
name|LowPriority
return|;
case|case
name|QNetworkRequest
operator|::
name|HighPriority
case|:
return|return
name|QHttpNetworkRequest
operator|::
name|HighPriority
return|;
case|case
name|QNetworkRequest
operator|::
name|NormalPriority
case|:
default|default:
return|return
name|QHttpNetworkRequest
operator|::
name|NormalPriority
return|;
block|}
block|}
end_function
begin_function
DECL|function|postRequest
name|void
name|QNetworkAccessHttpBackend
operator|::
name|postRequest
parameter_list|()
block|{
name|QThread
modifier|*
name|thread
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isSynchronous
argument_list|()
condition|)
block|{
comment|// A synchronous HTTP request uses its own thread
name|thread
operator|=
operator|new
name|QThread
argument_list|()
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|thread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|manager
operator|->
name|httpThread
condition|)
block|{
comment|// We use the manager-global thread.
comment|// At some point we could switch to having multiple threads if it makes sense.
name|manager
operator|->
name|httpThread
operator|=
operator|new
name|QThread
argument_list|()
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|manager
operator|->
name|httpThread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|manager
operator|->
name|httpThread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|httpThread
operator|->
name|start
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|qRegisterMetaType
argument_list|<
name|QNetworkProxy
argument_list|>
argument_list|(
literal|"QNetworkProxy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|>
argument_list|(
literal|"QList<QSslError>"
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QSslConfiguration
argument_list|>
argument_list|(
literal|"QSslConfiguration"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|"QList<QPair<QByteArray,QByteArray>>"
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QHttpNetworkRequest
argument_list|>
argument_list|(
literal|"QHttpNetworkRequest"
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QNetworkReply
operator|::
name|NetworkError
argument_list|>
argument_list|(
literal|"QNetworkReply::NetworkError"
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|>
argument_list|(
literal|"QSharedPointer<char>"
argument_list|)
expr_stmt|;
name|thread
operator|=
name|manager
operator|->
name|httpThread
expr_stmt|;
block|}
else|else
block|{
comment|// Asynchronous request, thread already exists
name|thread
operator|=
name|manager
operator|->
name|httpThread
expr_stmt|;
block|}
name|QUrl
name|url
init|=
name|request
argument_list|()
operator|.
name|url
argument_list|()
decl_stmt|;
name|httpRequest
operator|.
name|setUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|bool
name|ssl
init|=
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
decl_stmt|;
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|ConnectionEncryptedAttribute
argument_list|,
name|ssl
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setSsl
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QNetworkProxy
name|transparentProxy
decl_stmt|,
name|cacheProxy
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QNetworkProxy
modifier|&
name|p
decl|,
name|proxyList
argument_list|()
control|)
block|{
comment|// use the first proxy that works
comment|// for non-encrypted connections, any transparent or HTTP proxy
comment|// for encrypted, only transparent proxies
if|if
condition|(
operator|!
name|ssl
operator|&&
operator|(
name|p
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|CachingCapability
operator|)
operator|&&
operator|(
name|p
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpProxy
operator|||
name|p
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpCachingProxy
operator|)
condition|)
block|{
name|cacheProxy
operator|=
name|p
expr_stmt|;
name|transparentProxy
operator|=
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|.
name|isTransparentProxy
argument_list|()
condition|)
block|{
name|transparentProxy
operator|=
name|p
expr_stmt|;
name|cacheProxy
operator|=
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
break|break;
block|}
block|}
comment|// check if at least one of the proxies
if|if
condition|(
name|transparentProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
operator|&&
name|cacheProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// unsuitable proxies
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"error"
argument_list|,
name|isSynchronous
argument_list|()
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QNetworkReply
operator|::
name|ProxyNotFoundError
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QString
argument_list|,
name|tr
argument_list|(
literal|"No suitable proxy found"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"finished"
argument_list|,
name|isSynchronous
argument_list|()
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|bool
name|loadedFromCache
init|=
literal|false
decl_stmt|;
name|httpRequest
operator|.
name|setPriority
argument_list|(
name|convert
argument_list|(
name|request
argument_list|()
operator|.
name|priority
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|operation
argument_list|()
condition|)
block|{
case|case
name|QNetworkAccessManager
operator|::
name|GetOperation
case|:
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Get
argument_list|)
expr_stmt|;
name|loadedFromCache
operator|=
name|loadFromCacheIfAllowed
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|HeadOperation
case|:
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Head
argument_list|)
expr_stmt|;
name|loadedFromCache
operator|=
name|loadFromCacheIfAllowed
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|PostOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Post
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|PutOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Put
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|DeleteOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Delete
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|CustomOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
comment|// for safety reasons, we don't know what the operation does
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Custom
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setCustomVerb
argument_list|(
name|request
argument_list|()
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CustomVerbAttribute
argument_list|)
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|// can't happen
block|}
if|if
condition|(
name|loadedFromCache
condition|)
block|{
comment|// commented this out since it will be called later anyway
comment|// by copyFinished()
comment|//QNetworkAccessBackend::finished();
return|return;
comment|// no need to send the request! :)
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|headers
init|=
name|request
argument_list|()
operator|.
name|rawHeaderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|resumeOffset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|headers
operator|.
name|contains
argument_list|(
literal|"Range"
argument_list|)
condition|)
block|{
comment|// Need to adjust resume offset for user specified range
name|headers
operator|.
name|removeOne
argument_list|(
literal|"Range"
argument_list|)
expr_stmt|;
comment|// We've already verified that requestRange starts with "bytes=", see canResume.
name|QByteArray
name|requestRange
init|=
name|request
argument_list|()
operator|.
name|rawHeader
argument_list|(
literal|"Range"
argument_list|)
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|requestRange
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
name|quint64
name|requestStartOffset
init|=
name|requestRange
operator|.
name|left
argument_list|(
name|index
argument_list|)
operator|.
name|toULongLong
argument_list|()
decl_stmt|;
name|quint64
name|requestEndOffset
init|=
name|requestRange
operator|.
name|mid
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|toULongLong
argument_list|()
decl_stmt|;
name|requestRange
operator|=
literal|"bytes="
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|resumeOffset
operator|+
name|requestStartOffset
argument_list|)
operator|+
literal|'-'
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|requestEndOffset
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Range"
argument_list|,
name|requestRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Range"
argument_list|,
literal|"bytes="
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|resumeOffset
argument_list|)
operator|+
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|header
decl|,
name|headers
control|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
name|header
argument_list|,
name|request
argument_list|()
operator|.
name|rawHeader
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
argument_list|()
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpPipeliningAllowedAttribute
argument_list|)
operator|.
name|toBool
argument_list|()
operator|==
literal|true
condition|)
name|httpRequest
operator|.
name|setPipeliningAllowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|LoadControl
argument_list|>
argument_list|(
name|request
argument_list|()
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|AuthenticationReuseAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|Automatic
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|QNetworkRequest
operator|::
name|Manual
condition|)
name|httpRequest
operator|.
name|setWithCredentials
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Create the HTTP thread delegate
name|QHttpThreadDelegate
modifier|*
name|delegate
init|=
operator|new
name|QHttpThreadDelegate
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_NO_BEARERMANAGEMENT
name|QVariant
name|v
argument_list|(
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|isValid
argument_list|()
condition|)
name|delegate
operator|->
name|networkSession
operator|=
name|qvariant_cast
argument_list|<
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
argument_list|>
argument_list|(
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// For the synchronous HTTP, this is the normal way the delegate gets deleted
comment|// For the asynchronous HTTP this is a safety measure, the delegate deletes itself when HTTP is finished
name|connect
argument_list|(
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set the properties it needs
name|delegate
operator|->
name|httpRequest
operator|=
name|httpRequest
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|delegate
operator|->
name|cacheProxy
operator|=
name|cacheProxy
expr_stmt|;
name|delegate
operator|->
name|transparentProxy
operator|=
name|transparentProxy
expr_stmt|;
endif|#
directive|endif
name|delegate
operator|->
name|ssl
operator|=
name|ssl
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|ssl
condition|)
name|delegate
operator|->
name|incomingSslConfiguration
operator|=
name|request
argument_list|()
operator|.
name|sslConfiguration
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Do we use synchronous HTTP?
name|delegate
operator|->
name|synchronous
operator|=
name|isSynchronous
argument_list|()
expr_stmt|;
comment|// The authentication manager is used to avoid the BlockingQueuedConnection communication
comment|// from HTTP thread to user thread in some cases.
name|delegate
operator|->
name|authenticationManager
operator|=
name|manager
operator|->
name|authenticationManager
expr_stmt|;
if|if
condition|(
operator|!
name|isSynchronous
argument_list|()
condition|)
block|{
comment|// Tell our zerocopy policy to the delegate
name|delegate
operator|->
name|downloadBufferMaximumSize
operator|=
name|request
argument_list|()
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|MaximumDownloadBufferSizeAttribute
argument_list|)
operator|.
name|toLongLong
argument_list|()
expr_stmt|;
comment|// These atomic integers are used for signal compression
name|delegate
operator|->
name|pendingDownloadData
operator|=
name|pendingDownloadDataEmissions
expr_stmt|;
name|delegate
operator|->
name|pendingDownloadProgress
operator|=
name|pendingDownloadProgressEmissions
expr_stmt|;
comment|// Connect the signals of the delegate to us
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadData
argument_list|(
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadData
argument_list|(
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadFinished
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replyFinished
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadMetaData
argument_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|,
name|int
argument_list|,
name|QString
argument_list|,
name|bool
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadMetaData
argument_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|,
name|int
argument_list|,
name|QString
argument_list|,
name|bool
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadProgressSlot
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|httpError
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
specifier|const
name|QString
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|sslConfigurationChanged
argument_list|(
name|QSslConfiguration
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replySslConfigurationChanged
argument_list|(
name|QSslConfiguration
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Those need to report back, therefire BlockingQueuedConnection
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|httpAuthenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|,
name|bool
operator|*
argument_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|replySslErrors
argument_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
operator|&
argument_list|,
name|bool
operator|*
argument_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// This signal we will use to start the request.
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|startHttpRequest
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|startRequest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|abortHttpRequest
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|abortRequest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
name|QNonContiguousByteDeviceThreadForwardImpl
modifier|*
name|forwardUploadDevice
init|=
operator|new
name|QNonContiguousByteDeviceThreadForwardImpl
argument_list|(
name|uploadByteDevice
operator|->
name|atEnd
argument_list|()
argument_list|,
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
operator|->
name|isResetDisabled
argument_list|()
condition|)
name|forwardUploadDevice
operator|->
name|disableReset
argument_list|()
expr_stmt|;
name|forwardUploadDevice
operator|->
name|setParent
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
comment|// needed to make sure it is moved on moveToThread()
name|delegate
operator|->
name|httpRequest
operator|.
name|setUploadByteDevice
argument_list|(
name|forwardUploadDevice
argument_list|)
expr_stmt|;
comment|// From main thread to user thread:
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|haveUploadData
argument_list|(
name|QByteArray
argument_list|,
name|bool
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|forwardUploadDevice
argument_list|,
name|SLOT
argument_list|(
name|haveDataSlot
argument_list|(
name|QByteArray
argument_list|,
name|bool
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|uploadByteDevice
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// From http thread to user thread:
name|QObject
operator|::
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|wantData
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|wantUploadDataSlot
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|processedData
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sentUploadDataSlot
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|resetData
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|resetUploadDataSlot
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
comment|// this is the only one with BlockingQueued!
block|}
block|}
elseif|else
if|if
condition|(
name|isSynchronous
argument_list|()
condition|)
block|{
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|startHttpRequestSynchronously
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|startRequestSynchronously
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
comment|// For the synchronous HTTP use case the use thread (this one here) is blocked
comment|// so we cannot use the asynchronous upload architecture.
comment|// We therefore won't use the QNonContiguousByteDeviceThreadForwardImpl but directly
comment|// use the uploadByteDevice provided to us by the QNetworkReplyImpl.
comment|// The code that is in QNetworkReplyImplPrivate::setup() makes sure it is safe to use from a thread
comment|// since it only wraps a QRingBuffer
name|delegate
operator|->
name|httpRequest
operator|.
name|setUploadByteDevice
argument_list|(
name|uploadByteDevice
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move the delegate to the http thread
name|delegate
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|// This call automatically moves the uploadDevice too for the asynchronous case.
comment|// Send an signal to the delegate so it starts working in the other thread
if|if
condition|(
name|isSynchronous
argument_list|()
condition|)
block|{
emit|emit
name|startHttpRequestSynchronously
argument_list|()
emit|;
comment|// This one is BlockingQueuedConnection, so it will return when all work is done
if|if
condition|(
name|delegate
operator|->
name|incomingErrorCode
operator|!=
name|QNetworkReply
operator|::
name|NoError
condition|)
block|{
name|replyDownloadMetaData
argument_list|(
name|delegate
operator|->
name|incomingHeaders
argument_list|,
name|delegate
operator|->
name|incomingStatusCode
argument_list|,
name|delegate
operator|->
name|incomingReasonPhrase
argument_list|,
name|delegate
operator|->
name|isPipeliningUsed
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|,
name|delegate
operator|->
name|incomingContentLength
argument_list|)
expr_stmt|;
name|httpError
argument_list|(
name|delegate
operator|->
name|incomingErrorCode
argument_list|,
name|delegate
operator|->
name|incomingErrorDetail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replyDownloadMetaData
argument_list|(
name|delegate
operator|->
name|incomingHeaders
argument_list|,
name|delegate
operator|->
name|incomingStatusCode
argument_list|,
name|delegate
operator|->
name|incomingReasonPhrase
argument_list|,
name|delegate
operator|->
name|isPipeliningUsed
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|,
name|delegate
operator|->
name|incomingContentLength
argument_list|)
expr_stmt|;
name|replyDownloadData
argument_list|(
name|delegate
operator|->
name|synchronousDownloadData
argument_list|)
expr_stmt|;
block|}
comment|// End the thread. It will delete itself from the finished() signal
name|thread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|finished
argument_list|()
expr_stmt|;
block|}
else|else
block|{
emit|emit
name|startHttpRequest
argument_list|()
emit|;
comment|// Signal to the HTTP thread and go back to user.
block|}
block|}
end_function
begin_function
DECL|function|invalidateCache
name|void
name|QNetworkAccessHttpBackend
operator|::
name|invalidateCache
parameter_list|()
block|{
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|networkCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|nc
condition|)
name|nc
operator|->
name|remove
argument_list|(
name|url
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|open
name|void
name|QNetworkAccessHttpBackend
operator|::
name|open
parameter_list|()
block|{
name|postRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeDownstreamChannel
name|void
name|QNetworkAccessHttpBackend
operator|::
name|closeDownstreamChannel
parameter_list|()
block|{
comment|// FIXME Maybe we can get rid of this whole architecture part
block|}
end_function
begin_function
DECL|function|downstreamReadyWrite
name|void
name|QNetworkAccessHttpBackend
operator|::
name|downstreamReadyWrite
parameter_list|()
block|{
comment|// FIXME Maybe we can get rid of this whole architecture part
block|}
end_function
begin_function
DECL|function|setDownstreamLimited
name|void
name|QNetworkAccessHttpBackend
operator|::
name|setDownstreamLimited
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|// We know that readBuffer maximum size limiting is broken since quite a while.
comment|// The task to fix this is QTBUG-15065
block|}
end_function
begin_function
DECL|function|replyDownloadData
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replyDownloadData
parameter_list|(
name|QByteArray
name|d
parameter_list|)
block|{
name|int
name|pendingSignals
init|=
operator|(
name|int
operator|)
name|pendingDownloadDataEmissions
operator|->
name|fetchAndAddAcquire
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pendingSignals
operator|>
literal|0
condition|)
block|{
comment|// Some more signal emissions to this slot are pending.
comment|// Instead of writing the downstream data, we wait
comment|// and do it in the next call we get
comment|// (signal comppression)
name|pendingDownloadData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|pendingDownloadData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// We need to usa a copy for calling writeDownstreamData as we could
comment|// possibly recurse into this this function when we call
comment|// appendDownstreamDataSignalEmissions because the user might call
comment|// processEvents() or spin an event loop when this occur.
name|QByteDataBuffer
name|pendingDownloadDataCopy
init|=
name|pendingDownloadData
decl_stmt|;
name|pendingDownloadData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeDownstreamData
argument_list|(
name|pendingDownloadDataCopy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replyFinished
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replyFinished
parameter_list|()
block|{
comment|// We are already loading from cache, we still however
comment|// got this signal because it was posted already
if|if
condition|(
name|loadingFromCache
condition|)
return|return;
name|finished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkForRedirect
name|void
name|QNetworkAccessHttpBackend
operator|::
name|checkForRedirect
parameter_list|(
specifier|const
name|int
name|statusCode
parameter_list|)
block|{
switch|switch
condition|(
name|statusCode
condition|)
block|{
case|case
literal|301
case|:
comment|// Moved Permanently
case|case
literal|302
case|:
comment|// Found
case|case
literal|303
case|:
comment|// See Other
case|case
literal|307
case|:
comment|// Temporary Redirect
comment|// What do we do about the caching of the HTML note?
comment|// The response to a 303 MUST NOT be cached, while the response to
comment|// all of the others is cacheable if the headers indicate it to be
name|QByteArray
name|header
init|=
name|rawHeader
argument_list|(
literal|"location"
argument_list|)
decl_stmt|;
name|QUrl
name|url
init|=
name|QUrl
operator|::
name|fromEncoded
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|isValid
argument_list|()
condition|)
name|url
operator|=
name|QUrl
argument_list|(
name|QLatin1String
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|redirectionRequested
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|replyDownloadMetaData
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replyDownloadMetaData
parameter_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|hm
parameter_list|,
name|int
name|sc
parameter_list|,
name|QString
name|rp
parameter_list|,
name|bool
name|pu
parameter_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
name|db
parameter_list|,
name|qint64
name|contentLength
parameter_list|)
block|{
name|statusCode
operator|=
name|sc
expr_stmt|;
name|reasonPhrase
operator|=
name|rp
expr_stmt|;
comment|// Download buffer
if|if
condition|(
operator|!
name|db
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|reply
operator|->
name|setDownloadBuffer
argument_list|(
name|db
argument_list|,
name|contentLength
argument_list|)
expr_stmt|;
name|usingZerocopyDownloadBuffer
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|usingZerocopyDownloadBuffer
operator|=
literal|false
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpPipeliningWasUsedAttribute
argument_list|,
name|pu
argument_list|)
expr_stmt|;
comment|// reconstruct the HTTP header
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|headerMap
init|=
name|hm
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|headerMap
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|headerMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QByteArray
name|header
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QByteArray
name|value
init|=
name|rawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|,
literal|"set-cookie"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|+=
literal|'\n'
expr_stmt|;
else|else
name|value
operator|+=
literal|", "
expr_stmt|;
block|}
name|value
operator|+=
name|it
operator|->
name|second
expr_stmt|;
name|setRawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|statusCode
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|reasonPhrase
argument_list|)
expr_stmt|;
comment|// is it a redirection?
name|checkForRedirect
argument_list|(
name|statusCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|statusCode
operator|>=
literal|500
operator|&&
name|statusCode
operator|<
literal|600
condition|)
block|{
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|networkCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|nc
condition|)
block|{
name|QNetworkCacheMetaData
name|metaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
name|bool
name|mustReValidate
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
init|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"must-revalidate"
argument_list|)
condition|)
name|mustReValidate
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mustReValidate
operator|&&
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|statusCode
operator|==
literal|304
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Received a 304 from"
operator|<<
name|url
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|networkCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|nc
condition|)
block|{
name|QNetworkCacheMetaData
name|oldMetaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|QNetworkCacheMetaData
name|metaData
init|=
name|fetchCacheMetaData
argument_list|(
name|oldMetaData
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldMetaData
operator|!=
name|metaData
condition|)
name|nc
operator|->
name|updateMetaData
argument_list|(
name|metaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|statusCode
operator|!=
literal|304
operator|&&
name|statusCode
operator|!=
literal|303
condition|)
block|{
if|if
condition|(
operator|!
name|isCachingEnabled
argument_list|()
condition|)
name|setCachingEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|metaDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replyDownloadProgressSlot
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replyDownloadProgressSlot
parameter_list|(
name|qint64
name|received
parameter_list|,
name|qint64
name|total
parameter_list|)
block|{
comment|// we can be sure here that there is a download buffer
name|int
name|pendingSignals
init|=
operator|(
name|int
operator|)
name|pendingDownloadProgressEmissions
operator|->
name|fetchAndAddAcquire
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pendingSignals
operator|>
literal|0
condition|)
block|{
comment|// Let's ignore this signal and look at the next one coming in
comment|// (signal comppression)
return|return;
block|}
comment|// Now do the actual notification of new bytes
name|writeDownstreamDataDownloadBuffer
argument_list|(
name|received
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|httpAuthenticationRequired
name|void
name|QNetworkAccessHttpBackend
operator|::
name|httpAuthenticationRequired
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
name|authenticationRequired
argument_list|(
name|auth
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|httpError
name|void
name|QNetworkAccessHttpBackend
operator|::
name|httpError
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorString
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"http error!"
operator|<<
name|errorCode
operator|<<
name|errorString
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
name|errorCode
argument_list|,
name|errorString
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_function
DECL|function|replySslErrors
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replySslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|list
parameter_list|,
name|bool
modifier|*
name|ignoreAll
parameter_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|*
name|toBeIgnored
parameter_list|)
block|{
comment|// Go to generic backend
name|sslErrors
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|// Check if the callback set any ignore and return this here to http thread
if|if
condition|(
name|pendingIgnoreAllSslErrors
condition|)
operator|*
name|ignoreAll
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|pendingIgnoreSslErrorsList
operator|.
name|isEmpty
argument_list|()
condition|)
operator|*
name|toBeIgnored
operator|=
name|pendingIgnoreSslErrorsList
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replySslConfigurationChanged
name|void
name|QNetworkAccessHttpBackend
operator|::
name|replySslConfigurationChanged
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|c
parameter_list|)
block|{
comment|// Receiving the used SSL configuration from the HTTP thread
if|if
condition|(
name|pendingSslConfiguration
condition|)
operator|*
name|pendingSslConfiguration
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|c
operator|.
name|isNull
argument_list|()
condition|)
name|pendingSslConfiguration
operator|=
operator|new
name|QSslConfiguration
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|resetUploadDataSlot
name|void
name|QNetworkAccessHttpBackend
operator|::
name|resetUploadDataSlot
parameter_list|(
name|bool
modifier|*
name|r
parameter_list|)
block|{
operator|*
name|r
operator|=
name|uploadByteDevice
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|sentUploadDataSlot
name|void
name|QNetworkAccessHttpBackend
operator|::
name|sentUploadDataSlot
parameter_list|(
name|qint64
name|amount
parameter_list|)
block|{
name|uploadByteDevice
operator|->
name|advanceReadPointer
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|wantUploadDataSlot
name|void
name|QNetworkAccessHttpBackend
operator|::
name|wantUploadDataSlot
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
comment|// call readPointer
name|qint64
name|currentUploadDataLength
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|data
init|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|uploadByteDevice
operator|->
name|readPointer
argument_list|(
name|maxSize
argument_list|,
name|currentUploadDataLength
argument_list|)
argument_list|)
decl_stmt|;
comment|// Let's make a copy of this data
name|QByteArray
name|dataArray
argument_list|(
name|data
argument_list|,
name|currentUploadDataLength
argument_list|)
decl_stmt|;
comment|// Communicate back to HTTP thread
emit|emit
name|haveUploadData
argument_list|(
name|dataArray
argument_list|,
name|uploadByteDevice
operator|->
name|atEnd
argument_list|()
argument_list|,
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*     A simple web page that can be used to test us: http://www.procata.com/cachetest/  */
end_comment
begin_function
DECL|function|sendCacheContents
name|bool
name|QNetworkAccessHttpBackend
operator|::
name|sendCacheContents
parameter_list|(
specifier|const
name|QNetworkCacheMetaData
modifier|&
name|metaData
parameter_list|)
block|{
name|setCachingEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|metaData
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|networkCache
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nc
argument_list|)
expr_stmt|;
name|QIODevice
modifier|*
name|contents
init|=
name|nc
operator|->
name|data
argument_list|(
name|url
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Can not send cache, the contents are 0"
operator|<<
name|url
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|contents
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|AttributesMap
name|attributes
init|=
name|metaData
operator|.
name|attributes
argument_list|()
decl_stmt|;
name|int
name|status
init|=
name|attributes
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|<
literal|100
condition|)
name|status
operator|=
literal|200
expr_stmt|;
comment|// fake it
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|attributes
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|SourceIsFromCacheAttribute
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|RawHeaderList
name|rawHeaders
init|=
name|metaData
operator|.
name|rawHeaders
argument_list|()
decl_stmt|;
name|QNetworkCacheMetaData
operator|::
name|RawHeaderList
operator|::
name|ConstIterator
name|it
init|=
name|rawHeaders
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|rawHeaders
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|setRawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|checkForRedirect
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// This needs to be emitted in the event loop because it can be reached at
comment|// the direct code path of qnam.get(...) before the user has a chance
comment|// to connect any signals.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"metaDataChanged"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QIODevice
operator|*
argument_list|>
argument_list|(
literal|"QIODevice*"
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"writeDownstreamData"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QIODevice
operator|*
argument_list|,
name|contents
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Successfully sent cache:"
operator|<<
name|url
argument_list|()
operator|<<
name|contents
operator|->
name|size
argument_list|()
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
comment|// Set the following flag so we can ignore some signals from HTTP thread
comment|// that would still come
name|loadingFromCache
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|copyFinished
name|void
name|QNetworkAccessHttpBackend
operator|::
name|copyFinished
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|)
block|{
operator|delete
name|dev
expr_stmt|;
name|finished
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_function
DECL|function|ignoreSslErrors
name|void
name|QNetworkAccessHttpBackend
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|pendingIgnoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QNetworkAccessHttpBackend
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
comment|// the pending list is set if QNetworkReply::ignoreSslErrors(const QList<QSslError>&errors)
comment|// is called before QNetworkAccessManager::get() (or post(), etc.)
name|pendingIgnoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fetchSslConfiguration
name|void
name|QNetworkAccessHttpBackend
operator|::
name|fetchSslConfiguration
parameter_list|(
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|pendingSslConfiguration
condition|)
name|config
operator|=
operator|*
name|pendingSslConfiguration
expr_stmt|;
else|else
name|config
operator|=
name|request
argument_list|()
operator|.
name|sslConfiguration
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSslConfiguration
name|void
name|QNetworkAccessHttpBackend
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|newconfig
parameter_list|)
block|{
comment|// Setting a SSL configuration on a reply is not supported. The user needs to set
comment|// her/his QSslConfiguration on the QNetworkRequest.
name|Q_UNUSED
argument_list|(
name|newconfig
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fetchCacheMetaData
name|QNetworkCacheMetaData
name|QNetworkAccessHttpBackend
operator|::
name|fetchCacheMetaData
parameter_list|(
specifier|const
name|QNetworkCacheMetaData
modifier|&
name|oldMetaData
parameter_list|)
specifier|const
block|{
name|QNetworkCacheMetaData
name|metaData
init|=
name|oldMetaData
decl_stmt|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|newHeaders
init|=
name|rawHeaderList
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QByteArray
name|header
decl|,
name|newHeaders
control|)
block|{
name|QByteArray
name|originalHeader
init|=
name|header
decl_stmt|;
name|header
operator|=
name|header
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|bool
name|hop_by_hop
init|=
operator|(
name|header
operator|==
literal|"connection"
operator|||
name|header
operator|==
literal|"keep-alive"
operator|||
name|header
operator|==
literal|"proxy-authenticate"
operator|||
name|header
operator|==
literal|"proxy-authorization"
operator|||
name|header
operator|==
literal|"te"
operator|||
name|header
operator|==
literal|"trailers"
operator|||
name|header
operator|==
literal|"transfer-encoding"
operator|||
name|header
operator|==
literal|"upgrade"
operator|)
decl_stmt|;
if|if
condition|(
name|hop_by_hop
condition|)
continue|continue;
comment|// we are currently not using the date header to determine the expiration time of a page,
comment|// but only the "Expires", "max-age" and "s-maxage" headers, see
comment|// QNetworkAccessHttpBackend::validateCache() and below ("metaData.setExpirationDate()").
if|if
condition|(
name|header
operator|==
literal|"date"
condition|)
continue|continue;
comment|// Don't store Warning 1xx headers
if|if
condition|(
name|header
operator|==
literal|"warning"
condition|)
block|{
name|QByteArray
name|v
init|=
name|rawHeader
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|length
argument_list|()
operator|==
literal|3
operator|&&
name|v
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|v
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|v
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|&&
name|v
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|v
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
continue|continue;
block|}
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|// Match the behavior of Firefox and assume Cache-Control: "no-transform"
if|if
condition|(
name|header
operator|==
literal|"content-encoding"
operator|||
name|header
operator|==
literal|"content-range"
operator|||
name|header
operator|==
literal|"content-type"
condition|)
continue|continue;
comment|// For MS servers that send "Content-Length: 0" on 304 responses
comment|// ignore this too
if|if
condition|(
name|header
operator|==
literal|"content-length"
condition|)
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|QByteArray
name|n
init|=
name|rawHeader
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|QByteArray
name|o
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|o
operator|=
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|o
operator|&&
name|header
operator|!=
literal|"date"
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"replacing"
operator|<<
name|header
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"new"
operator|<<
name|n
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"old"
operator|<<
name|o
expr_stmt|;
block|}
endif|#
directive|endif
name|cacheHeaders
operator|.
name|setRawHeader
argument_list|(
name|originalHeader
argument_list|,
name|rawHeader
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|.
name|setRawHeaders
argument_list|(
name|cacheHeaders
operator|.
name|rawHeaders
argument_list|)
expr_stmt|;
name|bool
name|checkExpired
init|=
literal|true
decl_stmt|;
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|cacheControl
operator|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|QByteArray
name|maxAge
init|=
name|cacheControl
operator|.
name|value
argument_list|(
literal|"max-age"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|maxAge
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|checkExpired
operator|=
literal|false
expr_stmt|;
name|QDateTime
name|dt
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
decl_stmt|;
name|dt
operator|=
name|dt
operator|.
name|addSecs
argument_list|(
name|maxAge
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setExpirationDate
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkExpired
condition|)
block|{
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"expires"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QDateTime
name|expiredDateTime
init|=
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
name|metaData
operator|.
name|setExpirationDate
argument_list|(
name|expiredDateTime
argument_list|)
expr_stmt|;
block|}
block|}
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"last-modified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|metaData
operator|.
name|setLastModified
argument_list|(
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|it
operator|->
name|second
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|canDiskCache
decl_stmt|;
comment|// only cache GET replies by default, all other replies (POST, PUT, DELETE)
comment|//  are not cacheable by default (according to RFC 2616 section 9)
if|if
condition|(
name|httpRequest
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
block|{
name|canDiskCache
operator|=
literal|true
expr_stmt|;
comment|// 14.32
comment|// HTTP/1.1 caches SHOULD treat "Pragma: no-cache" as if the client
comment|// had sent "Cache-Control: no-cache".
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"pragma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|->
name|second
operator|==
literal|"no-cache"
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// HTTP/1.1. Check the Cache-Control header
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"no-cache"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"no-store"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// responses to POST might be cacheable
block|}
elseif|else
if|if
condition|(
name|httpRequest
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Post
condition|)
block|{
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// some pages contain "expires:" and "cache-control: no-cache" field,
comment|// so we only might cache POST requests if we get "cache-control: max-age ..."
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"max-age"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|true
expr_stmt|;
comment|// responses to PUT and DELETE are not cacheable
block|}
else|else
block|{
name|canDiskCache
operator|=
literal|false
expr_stmt|;
block|}
name|metaData
operator|.
name|setSaveToDisk
argument_list|(
name|canDiskCache
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|AttributesMap
name|attributes
decl_stmt|;
if|if
condition|(
name|statusCode
operator|!=
literal|304
condition|)
block|{
comment|// update the status code
name|attributes
operator|.
name|insert
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|statusCode
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|insert
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|reasonPhrase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this is a redirection, keep the attributes intact
name|attributes
operator|=
name|oldMetaData
operator|.
name|attributes
argument_list|()
expr_stmt|;
block|}
name|metaData
operator|.
name|setAttributes
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
return|return
name|metaData
return|;
block|}
end_function
begin_function
DECL|function|canResume
name|bool
name|QNetworkAccessHttpBackend
operator|::
name|canResume
parameter_list|()
specifier|const
block|{
comment|// Only GET operation supports resuming.
if|if
condition|(
name|operation
argument_list|()
operator|!=
name|QNetworkAccessManager
operator|::
name|GetOperation
condition|)
return|return
literal|false
return|;
comment|// Can only resume if server/resource supports Range header.
name|QByteArray
name|acceptRangesheaderName
argument_list|(
literal|"Accept-Ranges"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasRawHeader
argument_list|(
name|acceptRangesheaderName
argument_list|)
operator|||
name|rawHeader
argument_list|(
name|acceptRangesheaderName
argument_list|)
operator|==
literal|"none"
condition|)
return|return
literal|false
return|;
comment|// We only support resuming for byte ranges.
if|if
condition|(
name|request
argument_list|()
operator|.
name|hasRawHeader
argument_list|(
literal|"Range"
argument_list|)
condition|)
block|{
name|QByteArray
name|range
init|=
name|request
argument_list|()
operator|.
name|rawHeader
argument_list|(
literal|"Range"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|startsWith
argument_list|(
literal|"bytes="
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
comment|// If we're using a download buffer then we don't support resuming/migration
comment|// right now. Too much trouble.
if|if
condition|(
name|usingZerocopyDownloadBuffer
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setResumeOffset
name|void
name|QNetworkAccessHttpBackend
operator|::
name|setResumeOffset
parameter_list|(
name|quint64
name|offset
parameter_list|)
block|{
name|resumeOffset
operator|=
name|offset
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
